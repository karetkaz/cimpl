typename: typename {
.kind: static const typename(ref)
.offset: 000008
.size: 0
.owner: 
.field size: int32 (size: 4 @0 -> const variable)
.field offset: int32 (size: 4 @0 -> const variable)
.field base: function (size: 8 @21928 -> static const inline)
.field file: function (size: 8 @22392 -> static const inline)
.field line: function (size: 8 @22856 -> static const inline)
.field name: function (size: 8 @23320 -> static const inline)
}
typename.size: int32: int32 {
.kind: const variable
.offset: 000000
.size: 4
.owner: typename
}
typename.offset: int32: int32 {
.kind: const variable
.offset: 000000
.size: 4
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.offset: 0055a8
.size: 8
.owner: typename
.param .result: typename (@+4->inline)
.param type: typename (@+4->ref)
.value: emit(nfc(1), type)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.offset: 005778
.size: 8
.owner: typename
.param .result: .cstr (@+8->inline)
.param type: typename (@+4->ref)
.value: emit(nfc(2), type)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.offset: 005948
.size: 8
.owner: typename
.param .result: int32 (@+8->inline)
.param type: typename (@+4->ref)
.value: emit(nfc(3), type)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.offset: 005b18
.size: 8
.owner: typename
.param .result: .cstr (@+8->inline)
.param type: typename (@+4->ref)
.value: emit(nfc(4), type)
}
void: typename {
.kind: static const typename(void)
.offset: 0000a0
.size: 0
.owner: 
}
bool: typename {
.kind: static const typename(bool)
.offset: 000130
.size: 1
.owner: 
}
char: typename {
.kind: static const typename(u32)
.offset: 0001c0
.size: 1
.owner: 
}
int8: typename {
.kind: static const typename(i32)
.offset: 000250
.size: 1
.owner: 
}
int16: typename {
.kind: static const typename(i32)
.offset: 0002e0
.size: 2
.owner: 
}
int32: typename {
.kind: static const typename(i32)
.offset: 000370
.size: 4
.owner: 
}
int64: typename {
.kind: static const typename(i64)
.offset: 000400
.size: 8
.owner: 
}
uint8: typename {
.kind: static const typename(u32)
.offset: 000490
.size: 1
.owner: 
}
uint16: typename {
.kind: static const typename(u32)
.offset: 000520
.size: 2
.owner: 
}
uint32: typename {
.kind: static const typename(u32)
.offset: 0005b0
.size: 4
.owner: 
.field zxt: function (size: 8 @32440 -> static const inline)
.field sxt: function (size: 8 @33176 -> static const inline)
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.offset: 007eb8
.size: 8
.owner: uint32
.param .result: int32 (@+16->inline)
.param value: int32 (@+12->i32)
.param offs: int32 (@+8->i32)
.param count: int32 (@+4->i32)
.value: emit(nfc(17), value, offs, count)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.offset: 008198
.size: 8
.owner: uint32
.param .result: int32 (@+16->inline)
.param value: int32 (@+12->i32)
.param offs: int32 (@+8->i32)
.param count: int32 (@+4->i32)
.value: emit(nfc(18), value, offs, count)
}
uint64: typename {
.kind: static const typename(u64)
.offset: 000640
.size: 8
.owner: 
.field zxt: function (size: 8 @33904 -> static const inline)
.field sxt: function (size: 8 @34632 -> static const inline)
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.offset: 008470
.size: 8
.owner: uint64
.param .result: int64 (@+24->inline)
.param value: int64 (@+16->i64)
.param offs: int32 (@+8->i32)
.param count: int32 (@+4->i32)
.value: emit(nfc(19), value, offs, count)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.offset: 008748
.size: 8
.owner: uint64
.param .result: int64 (@+24->inline)
.param value: int64 (@+16->i64)
.param offs: int32 (@+8->i32)
.param count: int32 (@+4->i32)
.value: emit(nfc(20), value, offs, count)
}
float32: typename {
.kind: static const typename(f32)
.offset: 0006d0
.size: 4
.owner: 
.field sin: function (size: 8 @35104 -> static const inline)
.field cos: function (size: 8 @35568 -> static const inline)
.field tan: function (size: 8 @36032 -> static const inline)
.field log: function (size: 8 @36496 -> static const inline)
.field exp: function (size: 8 @36960 -> static const inline)
.field pow: function (size: 8 @37568 -> static const inline)
.field sqrt: function (size: 8 @38032 -> static const inline)
.field atan2: function (size: 8 @38632 -> static const inline)
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.offset: 008920
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(21), x)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.offset: 008af0
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(22), x)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.offset: 008cc0
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(23), x)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.offset: 008e90
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(24), x)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.offset: 009060
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(25), x)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.offset: 0092c0
.size: 8
.owner: float32
.param .result: float32 (@+12->inline)
.param x: float32 (@+8->f32)
.param y: float32 (@+4->f32)
.value: emit(nfc(26), x, y)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.offset: 009490
.size: 8
.owner: float32
.param .result: float32 (@+8->inline)
.param x: float32 (@+4->f32)
.value: emit(nfc(27), x)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.offset: 0096e8
.size: 8
.owner: float32
.param .result: float32 (@+12->inline)
.param x: float32 (@+8->f32)
.param y: float32 (@+4->f32)
.value: emit(nfc(28), x, y)
}
float64: typename {
.kind: static const typename(f64)
.offset: 000760
.size: 8
.owner: 
.field sin: function (size: 8 @39088 -> static const inline)
.field cos: function (size: 8 @39544 -> static const inline)
.field tan: function (size: 8 @40000 -> static const inline)
.field log: function (size: 8 @40456 -> static const inline)
.field exp: function (size: 8 @40912 -> static const inline)
.field pow: function (size: 8 @41504 -> static const inline)
.field sqrt: function (size: 8 @41960 -> static const inline)
.field atan2: function (size: 8 @42552 -> static const inline)
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.offset: 0098b0
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(29), x)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.offset: 009a78
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(30), x)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.offset: 009c40
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(31), x)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.offset: 009e08
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(32), x)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.offset: 009fd0
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(33), x)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.offset: 00a220
.size: 8
.owner: float64
.param .result: float64 (@+24->inline)
.param x: float64 (@+16->f64)
.param y: float64 (@+8->f64)
.value: emit(nfc(34), x, y)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.offset: 00a3e8
.size: 8
.owner: float64
.param .result: float64 (@+16->inline)
.param x: float64 (@+8->f64)
.value: emit(nfc(35), x)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.offset: 00a638
.size: 8
.owner: float64
.param .result: float64 (@+24->inline)
.param x: float64 (@+16->f64)
.param y: float64 (@+8->f64)
.value: emit(nfc(36), x, y)
}
pointer: typename {
.kind: static const typename(ref)
.offset: 0007f0
.size: 4
.owner: 
}
variant: typename {
.kind: static const typename(var)
.offset: 000880
.size: 8
.owner: 
}
function: typename {
.kind: static const typename(ref)
.offset: 000910
.size: 8
.owner: 
}
object: typename {
.kind: static const typename(ref)
.offset: 0009a8
.size: 4
.owner: 
}
null: pointer: pointer {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: 0
}
true: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: 1
}
false: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: 0
}
int: typename: typename {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: int32
}
byte: typename: typename {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: uint8
}
float: typename: typename {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: float32
}
double: typename: typename {
.kind: static const inline
.offset: 000000
.size: 0
.owner: 
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.offset: 000e28
.size: 4
.owner: 
}
emit: function {
.kind: static const typename(void)
.offset: 000eb8
.size: 0
.owner: 
.field nop: void (size: 0 @0 -> static const inline)
.field not: bool (size: 0 @0 -> static const inline)
.field set: void (size: 0 @0 -> static const inline)
.field join: void (size: 0 @0 -> static const inline)
.field ret: void (size: 0 @0 -> static const inline)
.field call: void (size: 0 @0 -> static const inline)
.field p4x: typename (size: 16 @4776 -> static const typename(val))
.field dup: void (size: 0 @4920 -> static const typename(void))
.field load: void (size: 0 @5496 -> static const typename(void))
.field store: void (size: 0 @6792 -> static const typename(void))
.field cmt: void (size: 0 @7616 -> static const typename(void))
.field and: void (size: 0 @8048 -> static const typename(void))
.field or: void (size: 0 @8464 -> static const typename(void))
.field xor: void (size: 0 @8880 -> static const typename(void))
.field shl: void (size: 0 @9296 -> static const typename(void))
.field shr: void (size: 0 @9712 -> static const typename(void))
.field neg: void (size: 0 @10400 -> static const typename(void))
.field add: void (size: 0 @11392 -> static const typename(void))
.field sub: void (size: 0 @12352 -> static const typename(void))
.field mul: void (size: 0 @13312 -> static const typename(void))
.field div: void (size: 0 @14544 -> static const typename(void))
.field mod: void (size: 0 @15776 -> static const typename(void))
.field ceq: void (size: 0 @16736 -> static const typename(void))
.field clt: void (size: 0 @17696 -> static const typename(void))
.field cgt: void (size: 0 @18656 -> static const typename(void))
.field min: void (size: 0 @19616 -> static const typename(void))
.field max: void (size: 0 @20032 -> static const typename(void))
}
emit.nop: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: nop
}
emit.not: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: not.b32
}
emit.set: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: set.x1 sp(1)
}
emit.join: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: sync 1
}
emit.ret: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: ret
}
emit.call: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.offset: 0012a8
.size: 16
.owner: emit
.field dp3: float32 (size: 0 @0 -> static const inline)
.field dp4: float32 (size: 0 @0 -> static const inline)
.field dph: float32 (size: 0 @0 -> static const inline)
}
emit.p4x.dp3: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: void {
.kind: static const typename(void)
.offset: 001338
.size: 0
.owner: emit
.field x1: int32 (size: 0 @0 -> static const inline)
.field x2: int64 (size: 0 @0 -> static const inline)
.field x4: emit.p4x (size: 0 @0 -> static const inline)
}
emit.dup.x1: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: void {
.kind: static const typename(void)
.offset: 001578
.size: 0
.owner: emit
.field z32: int32 (size: 0 @0 -> static const inline)
.field z64: int64 (size: 0 @0 -> static const inline)
.field z128: emit.p4x (size: 0 @0 -> static const inline)
.field i8: int32 (size: 0 @0 -> static const inline)
.field i16: int32 (size: 0 @0 -> static const inline)
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field i128: emit.p4x (size: 0 @0 -> static const inline)
}
emit.load.z32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.z64
}
emit.load.z128: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.m8
}
emit.load.i16: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.m16
}
emit.load.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.m32
}
emit.load.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.m64
}
emit.load.i128: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.load
.value: load.m128
}
emit.store: void {
.kind: static const typename(void)
.offset: 001a88
.size: 0
.owner: emit
.field i8: void (size: 0 @0 -> static const inline)
.field i16: void (size: 0 @0 -> static const inline)
.field i32: void (size: 0 @0 -> static const inline)
.field i64: void (size: 0 @0 -> static const inline)
.field i128: void (size: 0 @0 -> static const inline)
}
emit.store.i8: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.store
.value: store.m8
}
emit.store.i16: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.store
.value: store.m16
}
emit.store.i32: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.store
.value: store.m32
}
emit.store.i64: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.store
.value: store.m64
}
emit.store.i128: void: void {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.store
.value: store.m128
}
emit.cmt: void {
.kind: static const typename(void)
.offset: 001dc0
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.cmt.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cmt
.value: cmt.b64
}
emit.and: void {
.kind: static const typename(void)
.offset: 001f70
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.and.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.and
.value: and.b64
}
emit.or: void {
.kind: static const typename(void)
.offset: 002110
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.or.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.or
.value: or.b64
}
emit.xor: void {
.kind: static const typename(void)
.offset: 0022b0
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.xor.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.xor
.value: xor.b64
}
emit.shl: void {
.kind: static const typename(void)
.offset: 002450
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.shl.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shl
.value: shl.b64
}
emit.shr: void {
.kind: static const typename(void)
.offset: 0025f0
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.shr.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64: uint64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.shr
.value: shr.b64
}
emit.neg: void {
.kind: static const typename(void)
.offset: 0028a0
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.neg.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.neg
.value: neg.v2d
}
emit.add: void {
.kind: static const typename(void)
.offset: 002c80
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.add.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.f64
}
emit.add.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.add
.value: add.v2d
}
emit.sub: void {
.kind: static const typename(void)
.offset: 003040
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.sub.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.sub
.value: sub.v2d
}
emit.mul: void {
.kind: static const typename(void)
.offset: 003400
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.mul.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mul
.value: mul.v2d
}
emit.div: void {
.kind: static const typename(void)
.offset: 0038d0
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.div.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.f64
}
emit.div.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.div
.value: div.v2d
}
emit.mod: void {
.kind: static const typename(void)
.offset: 003da0
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
}
emit.mod.i32: int32: int32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64: int64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32: uint32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32: float32 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64: float64 {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.mod
.value: mod.f64
}
emit.ceq: void {
.kind: static const typename(void)
.offset: 004160
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
.field p4f: bool (size: 0 @0 -> static const inline)
.field p2d: bool (size: 0 @0 -> static const inline)
}
emit.ceq.i32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: void {
.kind: static const typename(void)
.offset: 004520
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field u32: bool (size: 0 @0 -> static const inline)
.field u64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
}
emit.clt.i32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.clt
.value: clt.f64
}
emit.cgt: void {
.kind: static const typename(void)
.offset: 0048e0
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field u32: bool (size: 0 @0 -> static const inline)
.field u64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
}
emit.cgt.i32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool: bool {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.cgt
.value: cgt.f64
}
emit.min: void {
.kind: static const typename(void)
.offset: 004ca0
.size: 0
.owner: emit
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.min.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.min
.value: min.v2d
}
emit.max: void {
.kind: static const typename(void)
.offset: 004e40
.size: 0
.owner: emit
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.max.p4f: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: p4x: emit.p4x {
.kind: static const inline
.offset: 000000
.size: 0
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.offset: 0052b0
.size: 8
.owner: 
.param .result: void (@+0->inline)
.value: emit(nfc(0))
}
CLOCKS_PER_SEC: int32: int32 {
.kind: i32
.offset: 000000
.size: 0
.owner: 
.value: 1000000
}
RAND_MAX: int32: int32 {
.kind: i32
.offset: 000000
.size: 0
.owner: 
.value: 2147483647
}
raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void: function {
.kind: static const inline
.offset: 006060
.size: 8
.owner: 
.field abort: int32 (size: 0 @0 -> static i32)
.field error: int32 (size: 0 @0 -> static i32)
.field warn: int32 (size: 0 @0 -> static i32)
.field info: int32 (size: 0 @0 -> static i32)
.field debug: int32 (size: 0 @0 -> static i32)
.field verbose: int32 (size: 0 @0 -> static i32)
.field noTrace: int32 (size: 0 @0 -> static i32)
.field defTrace: int32 (size: 0 @0 -> static i32)
.param .result: void (@+20->inline)
.param level: int32 (@+20->i32)
.param message: char[*] (@+16->ref)
.param inspect: variant (@+12->var)
.param maxTrace: int32 (@+4->i32)
.value: emit(nfc(5), level, message, inspect, maxTrace)
}
raise.abort: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: -1
}
raise.error: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 0
}
raise.warn: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 1
}
raise.info: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 2
}
raise.debug: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 3
}
raise.verbose: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 4
}
raise.noTrace: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 0
}
raise.defTrace: int32: int32 {
.kind: static i32
.offset: 000000
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.offset: 006860
.size: 8
.owner: 
.param .result: int32 (@+12->inline)
.param args: pointer (@+8->ref)
.param action: function (@+4->ref)
.value: emit(nfc(6), args, action)
}
memmgr(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.offset: 006ac0
.size: 8
.owner: 
.param .result: pointer (@+12->inline)
.param ptr: pointer (@+8->ref)
.param size: int32 (@+4->i32)
.value: emit(nfc(7), ptr, size)
}
memset(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.offset: 006db0
.size: 8
.owner: 
.param .result: pointer (@+16->inline)
.param dst: pointer (@+12->ref)
.param value: int32 (@+8->i32)
.param size: int32 (@+4->i32)
.value: emit(nfc(8), dst, value, size)
}
memcpy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.offset: 007098
.size: 8
.owner: 
.param .result: pointer (@+16->inline)
.param dst: pointer (@+12->ref)
.param src: pointer (@+8->ref)
.param size: int32 (@+4->i32)
.value: emit(nfc(9), dst, src, size)
}
System: void {
.kind: static const typename(void)
.offset: 0070c8
.size: 0
.owner: 
.field exit: function (size: 8 @29440 -> static const inline)
.field srand: function (size: 8 @29912 -> static const inline)
.field rand: function (size: 8 @30240 -> static const inline)
.field time: function (size: 8 @30568 -> static const inline)
.field clock: function (size: 8 @30896 -> static const inline)
.field millis: function (size: 8 @31224 -> static const inline)
.field sleep: function (size: 8 @31688 -> static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.offset: 007300
.size: 8
.owner: System
.param .result: void (@+4->inline)
.param code: int32 (@+4->i32)
.value: emit(nfc(10), code)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.offset: 0074d8
.size: 8
.owner: System
.param .result: void (@+4->inline)
.param seed: int32 (@+4->i32)
.value: emit(nfc(11), seed)
}
System.rand(): int32: function {
.kind: static const inline
.offset: 007620
.size: 8
.owner: System
.param .result: int32 (@+4->inline)
.value: emit(nfc(12))
}
System.time(): int32: function {
.kind: static const inline
.offset: 007768
.size: 8
.owner: System
.param .result: int32 (@+4->inline)
.value: emit(nfc(13))
}
System.clock(): int32: function {
.kind: static const inline
.offset: 0078b0
.size: 8
.owner: System
.param .result: int32 (@+4->inline)
.value: emit(nfc(14))
}
System.millis(): int64: function {
.kind: static const inline
.offset: 0079f8
.size: 8
.owner: System
.param .result: int64 (@+8->inline)
.value: emit(nfc(15))
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.offset: 007bc8
.size: 8
.owner: System
.param .result: void (@+8->inline)
.param millis: int64 (@+8->i64)
.value: emit(nfc(16), millis)
}
File: typename {
.kind: static const typename(val)
.offset: 00a668
.size: 8
.owner: 
.field open: function (size: 8 @43304 -> static const inline)
.field create: function (size: 8 @43904 -> static const inline)
.field append: function (size: 8 @44504 -> static const inline)
.field peek: function (size: 8 @44968 -> static const inline)
.field read: function (size: 8 @45432 -> static const inline)
.field read: function (size: 8 @46312 -> static const inline)
.field readLine: function (size: 8 @47192 -> static const inline)
.field write: function (size: 8 @47792 -> static const inline)
.field write: function (size: 8 @48656 -> static const inline)
.field flush: function (size: 8 @49120 -> static const inline)
.field close: function (size: 8 @49584 -> static const inline)
.field in: File (size: 8 @49776 -> static const inline)
.field out: File (size: 8 @49968 -> static const inline)
.field err: File (size: 8 @50160 -> static const inline)
.field dbg: File (size: 8 @50352 -> static const inline)
}
File.open(path: char[*]): File: function {
.kind: static const inline
.offset: 00a928
.size: 8
.owner: File
.param .result: File (@+12->inline)
.param path: char[*] (@+4->ref)
.value: emit(nfc(37), path)
}
File.create(path: char[*]): File: function {
.kind: static const inline
.offset: 00ab80
.size: 8
.owner: File
.param .result: File (@+12->inline)
.param path: char[*] (@+4->ref)
.value: emit(nfc(38), path)
}
File.append(path: char[*]): File: function {
.kind: static const inline
.offset: 00add8
.size: 8
.owner: File
.param .result: File (@+12->inline)
.param path: char[*] (@+4->ref)
.value: emit(nfc(39), path)
}
File.peek(file: File): int32: function {
.kind: static const inline
.offset: 00afa8
.size: 8
.owner: File
.param .result: int32 (@+12->inline)
.param file: File (@+8->val)
.value: emit(nfc(40), file)
}
File.read(file: File): int32: function {
.kind: static const inline
.offset: 00b178
.size: 8
.owner: File
.param .result: int32 (@+12->inline)
.param file: File (@+8->val)
.value: emit(nfc(41), file)
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.offset: 00b4e8
.size: 8
.owner: File
.param .result: int32 (@+20->inline)
.param file: File (@+16->val)
.param buff: uint8[] (@+8->arr)
.value: emit(nfc(42), file, buff)
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.offset: 00b858
.size: 8
.owner: File
.param .result: int32 (@+20->inline)
.param file: File (@+16->val)
.param buff: uint8[] (@+8->arr)
.value: emit(nfc(43), file, buff)
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.offset: 00bab0
.size: 8
.owner: File
.param .result: int32 (@+16->inline)
.param file: File (@+12->val)
.param byte: uint8 (@+4->u32)
.value: emit(nfc(44), file, byte)
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.offset: 00be10
.size: 8
.owner: File
.param .result: int32 (@+20->inline)
.param file: File (@+16->val)
.param buff: uint8[] (@+8->arr)
.value: emit(nfc(45), file, buff)
}
File.flush(file: File): void: function {
.kind: static const inline
.offset: 00bfe0
.size: 8
.owner: File
.param .result: void (@+8->inline)
.param file: File (@+8->val)
.value: emit(nfc(46), file)
}
File.close(file: File): void: function {
.kind: static const inline
.offset: 00c1b0
.size: 8
.owner: File
.param .result: void (@+8->inline)
.param file: File (@+8->val)
.value: emit(nfc(47), file)
}
File.in: File: File {
.kind: static const inline
.offset: 00c270
.size: 8
.owner: File
.value: emit(nfc(48))
}
File.out: File: File {
.kind: static const inline
.offset: 00c330
.size: 8
.owner: File
.value: emit(nfc(49))
}
File.err: File: File {
.kind: static const inline
.offset: 00c3f0
.size: 8
.owner: File
.value: emit(nfc(50))
}
File.dbg: File: File {
.kind: static const inline
.offset: 00c4b0
.size: 8
.owner: File
.value: emit(nfc(51))
}
integer: typename: typename {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.value: int64
}
xrgb: typename {
.kind: static const typename(val)
.offset: 00c6f8
.size: 4
.owner: 
.field b: uint8 (size: 1 @0 -> variable(u32))
.field g: uint8 (size: 1 @1 -> variable(u32))
.field r: uint8 (size: 1 @2 -> variable(u32))
.field x: uint8 (size: 1 @3 -> variable(u32))
}
xrgb.b: uint8: uint8 {
.kind: variable(u32)
.offset: 000000
.size: 1
.owner: xrgb
}
xrgb.g: uint8: uint8 {
.kind: variable(u32)
.offset: 000001
.size: 1
.owner: xrgb
}
xrgb.r: uint8: uint8 {
.kind: variable(u32)
.offset: 000002
.size: 1
.owner: xrgb
}
xrgb.x: uint8: uint8 {
.kind: variable(u32)
.offset: 000003
.size: 1
.owner: xrgb
}
color: typename {
.kind: static const typename(val)
.offset: 00c9a0
.size: 4
.owner: 
.field rgb: xrgb (size: 4 @0 -> variable(val))
.field col: int32 (size: 4 @0 -> variable(i32))
}
color.rgb: xrgb: xrgb {
.kind: variable(val)
.offset: 000000
.size: 4
.owner: color
}
color.col: int32: int32 {
.kind: variable(i32)
.offset: 000000
.size: 4
.owner: color
}
type: object {
.kind: static const typename(ref)
.offset: 00cb38
.size: 12
.owner: 
.field intVariable: int32 (size: 4 @0 -> variable(i32))
.field objReference: type (size: 4 @4 -> variable(ref))
.field funReference: function (size: 4 @8 -> variable(ref))
}
type.intVariable: int32: int32 {
.kind: variable(i32)
.offset: 000000
.size: 4
.owner: type
}
type.objReference: type: type {
.kind: variable(ref)
.offset: 000004
.size: 4
.owner: type
}
type.funReference(x: int32, y: int32): int32: function {
.kind: variable(ref)
.offset: 000008
.size: 4
.owner: type
.param .result: int32 (@+12->variable)
.param x: int32 (@+8->variable(i32))
.param y: int32 (@+4->variable(i32))
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: 0
}
first(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: a
}
last(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: b
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: a + b
}
any(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: (a) ? a : b
}
min(a: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+8->inline)
.param a: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: a < b ? a : b
}
min(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+12->inline)
.param a: int32 (@+12->i32)
.param b: int32 (@+8->i32)
.param c: int32 (@+4->i32)
.value: min(min(a, b), c)
}
ma: int32: int32 {
.kind: variable(i32)
.offset: 000004
.size: 4
.owner: 
.value: 3
}
mb: int32: int32 {
.kind: variable(i32)
.offset: 000008
.size: 4
.owner: 
.value: 6
}
mc: int32: int32 {
.kind: variable(i32)
.offset: 00000c
.size: 4
.owner: 
.value: 9
}
min2var: int32: int32 {
.kind: variable(i32)
.offset: 000010
.size: 4
.owner: 
.value: min(ma, mb)
}
emitldz32: int32: int32 {
.kind: variable(i32)
.offset: 000014
.size: 4
.owner: 
.value: emit(load.z32)
}
emitldz64: int64: int64 {
.kind: variable(i64)
.offset: 00001c
.size: 8
.owner: 
.value: emit(load.z64)
}
emitA: int32: int32 {
.kind: variable(i32)
.offset: 000020
.size: 4
.owner: 
.value: 42
}
emitB: int32: int32 {
.kind: variable(i32)
.offset: 000024
.size: 4
.owner: 
.value: 96
}
emitAddi32: int32: int32 {
.kind: variable(i32)
.offset: 000028
.size: 4
.owner: 
.value: emit(add.i32, int32(emitA), emitB)
}
a: typename: typename {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.value: 96.300000
}
b: typename: typename {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.value: 42.140000
}
shift: int32: int32 {
.kind: variable(i32)
.offset: 00002c
.size: 4
.owner: 
.value: 2
}
boolA: bool: bool {
.kind: variable(bool)
.offset: 000030
.size: 1
.owner: 
.value: true
}
boolB: bool: bool {
.kind: variable(bool)
.offset: 000034
.size: 1
.owner: 
.value: !false
}
boolAnd: bool: bool {
.kind: variable(bool)
.offset: 000038
.size: 1
.owner: 
.value: boolA & boolB
}
boolIor: bool: bool {
.kind: variable(bool)
.offset: 00003c
.size: 1
.owner: 
.value: boolA | boolB
}
boolXor: bool: bool {
.kind: variable(bool)
.offset: 000040
.size: 1
.owner: 
.value: boolA ^ boolB
}
boolNot: bool: bool {
.kind: variable(bool)
.offset: 000044
.size: 1
.owner: 
.value: !boolB
}
boolCeq: bool: bool {
.kind: variable(bool)
.offset: 000048
.size: 1
.owner: 
.value: boolA == boolB
}
boolCne: bool: bool {
.kind: variable(bool)
.offset: 00004c
.size: 1
.owner: 
.value: boolA != boolB
}
boolClt: bool: bool {
.kind: variable(bool)
.offset: 000050
.size: 1
.owner: 
.value: boolA < boolB
}
boolCle: bool: bool {
.kind: variable(bool)
.offset: 000054
.size: 1
.owner: 
.value: boolA <= boolB
}
boolCgt: bool: bool {
.kind: variable(bool)
.offset: 000058
.size: 1
.owner: 
.value: boolA > boolB
}
boolCge: bool: bool {
.kind: variable(bool)
.offset: 00005c
.size: 1
.owner: 
.value: boolA >= boolB
}
chrA: char: char {
.kind: variable(u32)
.offset: 000060
.size: 1
.owner: 
.value: 'a'
}
chrB: char: char {
.kind: variable(u32)
.offset: 000064
.size: 1
.owner: 
.value: 'b'
}
chrPls: char: char {
.kind: variable(u32)
.offset: 000068
.size: 1
.owner: 
.value: +chrB
}
chrNeg: char: char {
.kind: variable(u32)
.offset: 00006c
.size: 1
.owner: 
.value: -chrB
}
chrCmt: char: char {
.kind: variable(u32)
.offset: 000070
.size: 1
.owner: 
.value: ~chrB
}
chrAdd: char: char {
.kind: variable(u32)
.offset: 000074
.size: 1
.owner: 
.value: chrA + chrB
}
chrSub: char: char {
.kind: variable(u32)
.offset: 000078
.size: 1
.owner: 
.value: chrA - chrB
}
chrMul: char: char {
.kind: variable(u32)
.offset: 00007c
.size: 1
.owner: 
.value: chrA * chrB
}
chrDiv: char: char {
.kind: variable(u32)
.offset: 000080
.size: 1
.owner: 
.value: chrA / chrB
}
chrMod: char: char {
.kind: variable(u32)
.offset: 000084
.size: 1
.owner: 
.value: chrA % chrB
}
chrAnd: char: char {
.kind: variable(u32)
.offset: 000088
.size: 1
.owner: 
.value: chrA & chrB
}
chrIor: char: char {
.kind: variable(u32)
.offset: 00008c
.size: 1
.owner: 
.value: chrA | chrB
}
chrXor: char: char {
.kind: variable(u32)
.offset: 000090
.size: 1
.owner: 
.value: chrA ^ chrB
}
chrShl: char: char {
.kind: variable(u32)
.offset: 000094
.size: 1
.owner: 
.value: (chrA) << shift
}
chrShr: char: char {
.kind: variable(u32)
.offset: 000098
.size: 1
.owner: 
.value: (chrA) >> shift
}
chrNot: bool: bool {
.kind: variable(bool)
.offset: 00009c
.size: 1
.owner: 
.value: !chrB
}
chrCeq: bool: bool {
.kind: variable(bool)
.offset: 0000a0
.size: 1
.owner: 
.value: chrA == chrB
}
chrCne: bool: bool {
.kind: variable(bool)
.offset: 0000a4
.size: 1
.owner: 
.value: chrA != chrB
}
chrClt: bool: bool {
.kind: variable(bool)
.offset: 0000a8
.size: 1
.owner: 
.value: chrA < chrB
}
chrCle: bool: bool {
.kind: variable(bool)
.offset: 0000ac
.size: 1
.owner: 
.value: chrA <= chrB
}
chrCgt: bool: bool {
.kind: variable(bool)
.offset: 0000b0
.size: 1
.owner: 
.value: chrA > chrB
}
chrCge: bool: bool {
.kind: variable(bool)
.offset: 0000b4
.size: 1
.owner: 
.value: chrA >= chrB
}
i8A: int8: int8 {
.kind: variable(i32)
.offset: 0000b8
.size: 1
.owner: 
.value: a
}
i8B: int8: int8 {
.kind: variable(i32)
.offset: 0000bc
.size: 1
.owner: 
.value: b
}
i8Pls: int8: int8 {
.kind: variable(i32)
.offset: 0000c0
.size: 1
.owner: 
.value: +i8B
}
i8Neg: int8: int8 {
.kind: variable(i32)
.offset: 0000c4
.size: 1
.owner: 
.value: -i8B
}
i8Cmt: int8: int8 {
.kind: variable(i32)
.offset: 0000c8
.size: 1
.owner: 
.value: ~i8B
}
i8Add: int8: int8 {
.kind: variable(i32)
.offset: 0000cc
.size: 1
.owner: 
.value: i8A + i8B
}
i8Sub: int8: int8 {
.kind: variable(i32)
.offset: 0000d0
.size: 1
.owner: 
.value: i8A - i8B
}
i8Mul: int8: int8 {
.kind: variable(i32)
.offset: 0000d4
.size: 1
.owner: 
.value: i8A * i8B
}
i8Div: int8: int8 {
.kind: variable(i32)
.offset: 0000d8
.size: 1
.owner: 
.value: i8A / i8B
}
i8Mod: int8: int8 {
.kind: variable(i32)
.offset: 0000dc
.size: 1
.owner: 
.value: i8A % i8B
}
i8And: int8: int8 {
.kind: variable(i32)
.offset: 0000e0
.size: 1
.owner: 
.value: i8A & i8B
}
i8Ior: int8: int8 {
.kind: variable(i32)
.offset: 0000e4
.size: 1
.owner: 
.value: i8A | i8B
}
i8Xor: int8: int8 {
.kind: variable(i32)
.offset: 0000e8
.size: 1
.owner: 
.value: i8A ^ i8B
}
i8Shl: int8: int8 {
.kind: variable(i32)
.offset: 0000ec
.size: 1
.owner: 
.value: (i8A) << shift
}
i8Shr: int8: int8 {
.kind: variable(i32)
.offset: 0000f0
.size: 1
.owner: 
.value: (i8A) >> shift
}
i8Not: bool: bool {
.kind: variable(bool)
.offset: 0000f4
.size: 1
.owner: 
.value: !i8B
}
i8Ceq: bool: bool {
.kind: variable(bool)
.offset: 0000f8
.size: 1
.owner: 
.value: i8A == i8B
}
i8Cne: bool: bool {
.kind: variable(bool)
.offset: 0000fc
.size: 1
.owner: 
.value: i8A != i8B
}
i8Clt: bool: bool {
.kind: variable(bool)
.offset: 000100
.size: 1
.owner: 
.value: i8A < i8B
}
i8Cle: bool: bool {
.kind: variable(bool)
.offset: 000104
.size: 1
.owner: 
.value: i8A <= i8B
}
i8Cgt: bool: bool {
.kind: variable(bool)
.offset: 000108
.size: 1
.owner: 
.value: i8A > i8B
}
i8Cge: bool: bool {
.kind: variable(bool)
.offset: 00010c
.size: 1
.owner: 
.value: i8A >= i8B
}
u8A: uint8: uint8 {
.kind: variable(u32)
.offset: 000110
.size: 1
.owner: 
.value: a
}
u8B: uint8: uint8 {
.kind: variable(u32)
.offset: 000114
.size: 1
.owner: 
.value: b
}
u8Pls: uint8: uint8 {
.kind: variable(u32)
.offset: 000118
.size: 1
.owner: 
.value: +u8B
}
u8Neg: uint8: uint8 {
.kind: variable(u32)
.offset: 00011c
.size: 1
.owner: 
.value: -u8B
}
u8Cmt: uint8: uint8 {
.kind: variable(u32)
.offset: 000120
.size: 1
.owner: 
.value: ~u8B
}
u8Add: uint8: uint8 {
.kind: variable(u32)
.offset: 000124
.size: 1
.owner: 
.value: u8A + u8B
}
u8Sub: uint8: uint8 {
.kind: variable(u32)
.offset: 000128
.size: 1
.owner: 
.value: u8A - u8B
}
u8Mul: uint8: uint8 {
.kind: variable(u32)
.offset: 00012c
.size: 1
.owner: 
.value: u8A * u8B
}
u8Div: uint8: uint8 {
.kind: variable(u32)
.offset: 000130
.size: 1
.owner: 
.value: u8A / u8B
}
u8Mod: uint8: uint8 {
.kind: variable(u32)
.offset: 000134
.size: 1
.owner: 
.value: u8A % u8B
}
u8And: uint8: uint8 {
.kind: variable(u32)
.offset: 000138
.size: 1
.owner: 
.value: u8A & u8B
}
u8Ior: uint8: uint8 {
.kind: variable(u32)
.offset: 00013c
.size: 1
.owner: 
.value: u8A | u8B
}
u8Xor: uint8: uint8 {
.kind: variable(u32)
.offset: 000140
.size: 1
.owner: 
.value: u8A ^ u8B
}
u8Shl: uint8: uint8 {
.kind: variable(u32)
.offset: 000144
.size: 1
.owner: 
.value: (u8A) << shift
}
u8Shr: uint8: uint8 {
.kind: variable(u32)
.offset: 000148
.size: 1
.owner: 
.value: (u8A) >> shift
}
u8Not: bool: bool {
.kind: variable(bool)
.offset: 00014c
.size: 1
.owner: 
.value: !u8B
}
u8Ceq: bool: bool {
.kind: variable(bool)
.offset: 000150
.size: 1
.owner: 
.value: u8A == u8B
}
u8Cne: bool: bool {
.kind: variable(bool)
.offset: 000154
.size: 1
.owner: 
.value: u8A != u8B
}
u8Clt: bool: bool {
.kind: variable(bool)
.offset: 000158
.size: 1
.owner: 
.value: u8A < u8B
}
u8Cle: bool: bool {
.kind: variable(bool)
.offset: 00015c
.size: 1
.owner: 
.value: u8A <= u8B
}
u8Cgt: bool: bool {
.kind: variable(bool)
.offset: 000160
.size: 1
.owner: 
.value: u8A > u8B
}
u8Cge: bool: bool {
.kind: variable(bool)
.offset: 000164
.size: 1
.owner: 
.value: u8A >= u8B
}
i16A: int16: int16 {
.kind: variable(i32)
.offset: 000168
.size: 2
.owner: 
.value: a
}
i16B: int16: int16 {
.kind: variable(i32)
.offset: 00016c
.size: 2
.owner: 
.value: b
}
i16Pls: int16: int16 {
.kind: variable(i32)
.offset: 000170
.size: 2
.owner: 
.value: +i16B
}
i16Neg: int16: int16 {
.kind: variable(i32)
.offset: 000174
.size: 2
.owner: 
.value: -i16B
}
i16Cmt: int16: int16 {
.kind: variable(i32)
.offset: 000178
.size: 2
.owner: 
.value: ~i16B
}
i16Add: int16: int16 {
.kind: variable(i32)
.offset: 00017c
.size: 2
.owner: 
.value: i16A + i16B
}
i16Sub: int16: int16 {
.kind: variable(i32)
.offset: 000180
.size: 2
.owner: 
.value: i16A - i16B
}
i16Mul: int16: int16 {
.kind: variable(i32)
.offset: 000184
.size: 2
.owner: 
.value: i16A * i16B
}
i16Div: int16: int16 {
.kind: variable(i32)
.offset: 000188
.size: 2
.owner: 
.value: i16A / i16B
}
i16Mod: int16: int16 {
.kind: variable(i32)
.offset: 00018c
.size: 2
.owner: 
.value: i16A % i16B
}
i16And: int16: int16 {
.kind: variable(i32)
.offset: 000190
.size: 2
.owner: 
.value: i16A & i16B
}
i16Ior: int16: int16 {
.kind: variable(i32)
.offset: 000194
.size: 2
.owner: 
.value: i16A | i16B
}
i16Xor: int16: int16 {
.kind: variable(i32)
.offset: 000198
.size: 2
.owner: 
.value: i16A ^ i16B
}
i16Shl: int16: int16 {
.kind: variable(i32)
.offset: 00019c
.size: 2
.owner: 
.value: (i16A) << shift
}
i16Shr: int16: int16 {
.kind: variable(i32)
.offset: 0001a0
.size: 2
.owner: 
.value: (i16A) >> shift
}
i16Not: bool: bool {
.kind: variable(bool)
.offset: 0001a4
.size: 1
.owner: 
.value: !i16B
}
i16Ceq: bool: bool {
.kind: variable(bool)
.offset: 0001a8
.size: 1
.owner: 
.value: i16A == i16B
}
i16Cne: bool: bool {
.kind: variable(bool)
.offset: 0001ac
.size: 1
.owner: 
.value: i16A != i16B
}
i16Clt: bool: bool {
.kind: variable(bool)
.offset: 0001b0
.size: 1
.owner: 
.value: i16A < i16B
}
i16Cle: bool: bool {
.kind: variable(bool)
.offset: 0001b4
.size: 1
.owner: 
.value: i16A <= i16B
}
i16Cgt: bool: bool {
.kind: variable(bool)
.offset: 0001b8
.size: 1
.owner: 
.value: i16A > i16B
}
i16Cge: bool: bool {
.kind: variable(bool)
.offset: 0001bc
.size: 1
.owner: 
.value: i16A >= i16B
}
u16A: uint16: uint16 {
.kind: variable(u32)
.offset: 0001c0
.size: 2
.owner: 
.value: a
}
u16B: uint16: uint16 {
.kind: variable(u32)
.offset: 0001c4
.size: 2
.owner: 
.value: b
}
u16Pls: uint16: uint16 {
.kind: variable(u32)
.offset: 0001c8
.size: 2
.owner: 
.value: +u16B
}
u16Neg: uint16: uint16 {
.kind: variable(u32)
.offset: 0001cc
.size: 2
.owner: 
.value: -u16B
}
u16Cmt: uint16: uint16 {
.kind: variable(u32)
.offset: 0001d0
.size: 2
.owner: 
.value: ~u16B
}
u16Add: uint16: uint16 {
.kind: variable(u32)
.offset: 0001d4
.size: 2
.owner: 
.value: u16A + u16B
}
u16Sub: uint16: uint16 {
.kind: variable(u32)
.offset: 0001d8
.size: 2
.owner: 
.value: u16A - u16B
}
u16Mul: uint16: uint16 {
.kind: variable(u32)
.offset: 0001dc
.size: 2
.owner: 
.value: u16A * u16B
}
u16Div: uint16: uint16 {
.kind: variable(u32)
.offset: 0001e0
.size: 2
.owner: 
.value: u16A / u16B
}
u16Mod: uint16: uint16 {
.kind: variable(u32)
.offset: 0001e4
.size: 2
.owner: 
.value: u16A % u16B
}
u16And: uint16: uint16 {
.kind: variable(u32)
.offset: 0001e8
.size: 2
.owner: 
.value: u16A & u16B
}
u16Ior: uint16: uint16 {
.kind: variable(u32)
.offset: 0001ec
.size: 2
.owner: 
.value: u16A | u16B
}
u16Xor: uint16: uint16 {
.kind: variable(u32)
.offset: 0001f0
.size: 2
.owner: 
.value: u16A ^ u16B
}
u16Shl: uint16: uint16 {
.kind: variable(u32)
.offset: 0001f4
.size: 2
.owner: 
.value: (u16A) << shift
}
u16Shr: uint16: uint16 {
.kind: variable(u32)
.offset: 0001f8
.size: 2
.owner: 
.value: (u16A) >> shift
}
u16Not: bool: bool {
.kind: variable(bool)
.offset: 0001fc
.size: 1
.owner: 
.value: !u16B
}
u16Ceq: bool: bool {
.kind: variable(bool)
.offset: 000200
.size: 1
.owner: 
.value: u16A == u16B
}
u16Cne: bool: bool {
.kind: variable(bool)
.offset: 000204
.size: 1
.owner: 
.value: u16A != u16B
}
u16Clt: bool: bool {
.kind: variable(bool)
.offset: 000208
.size: 1
.owner: 
.value: u16A < u16B
}
u16Cle: bool: bool {
.kind: variable(bool)
.offset: 00020c
.size: 1
.owner: 
.value: u16A <= u16B
}
u16Cgt: bool: bool {
.kind: variable(bool)
.offset: 000210
.size: 1
.owner: 
.value: u16A > u16B
}
u16Cge: bool: bool {
.kind: variable(bool)
.offset: 000214
.size: 1
.owner: 
.value: u16A >= u16B
}
i32A: int32: int32 {
.kind: variable(i32)
.offset: 000218
.size: 4
.owner: 
.value: a
}
i32B: int32: int32 {
.kind: variable(i32)
.offset: 00021c
.size: 4
.owner: 
.value: b
}
i32Pls: int32: int32 {
.kind: variable(i32)
.offset: 000220
.size: 4
.owner: 
.value: +i32B
}
i32Neg: int32: int32 {
.kind: variable(i32)
.offset: 000224
.size: 4
.owner: 
.value: -i32B
}
i32Cmt: int32: int32 {
.kind: variable(i32)
.offset: 000228
.size: 4
.owner: 
.value: ~i32B
}
i32Add: int32: int32 {
.kind: variable(i32)
.offset: 00022c
.size: 4
.owner: 
.value: i32A + i32B
}
i32Sub: int32: int32 {
.kind: variable(i32)
.offset: 000230
.size: 4
.owner: 
.value: i32A - i32B
}
i32Mul: int32: int32 {
.kind: variable(i32)
.offset: 000234
.size: 4
.owner: 
.value: i32A * i32B
}
i32Div: int32: int32 {
.kind: variable(i32)
.offset: 000238
.size: 4
.owner: 
.value: i32A / i32B
}
i32Mod: int32: int32 {
.kind: variable(i32)
.offset: 00023c
.size: 4
.owner: 
.value: i32A % i32B
}
i32And: int32: int32 {
.kind: variable(i32)
.offset: 000240
.size: 4
.owner: 
.value: i32A & i32B
}
i32Ior: int32: int32 {
.kind: variable(i32)
.offset: 000244
.size: 4
.owner: 
.value: i32A | i32B
}
i32Xor: int32: int32 {
.kind: variable(i32)
.offset: 000248
.size: 4
.owner: 
.value: i32A ^ i32B
}
i32Shl: int32: int32 {
.kind: variable(i32)
.offset: 00024c
.size: 4
.owner: 
.value: i32A << shift
}
i32Shr: int32: int32 {
.kind: variable(i32)
.offset: 000250
.size: 4
.owner: 
.value: i32A >> shift
}
i32Not: bool: bool {
.kind: variable(bool)
.offset: 000254
.size: 1
.owner: 
.value: !i32B
}
i32Ceq: bool: bool {
.kind: variable(bool)
.offset: 000258
.size: 1
.owner: 
.value: i32A == i32B
}
i32Cne: bool: bool {
.kind: variable(bool)
.offset: 00025c
.size: 1
.owner: 
.value: i32A != i32B
}
i32Clt: bool: bool {
.kind: variable(bool)
.offset: 000260
.size: 1
.owner: 
.value: i32A < i32B
}
i32Cle: bool: bool {
.kind: variable(bool)
.offset: 000264
.size: 1
.owner: 
.value: i32A <= i32B
}
i32Cgt: bool: bool {
.kind: variable(bool)
.offset: 000268
.size: 1
.owner: 
.value: i32A > i32B
}
i32Cge: bool: bool {
.kind: variable(bool)
.offset: 00026c
.size: 1
.owner: 
.value: i32A >= i32B
}
u32A: uint32: uint32 {
.kind: variable(u32)
.offset: 000270
.size: 4
.owner: 
.value: a
}
u32B: uint32: uint32 {
.kind: variable(u32)
.offset: 000274
.size: 4
.owner: 
.value: b
}
u32Pls: uint32: uint32 {
.kind: variable(u32)
.offset: 000278
.size: 4
.owner: 
.value: +u32B
}
u32Neg: uint32: uint32 {
.kind: variable(u32)
.offset: 00027c
.size: 4
.owner: 
.value: -u32B
}
u32Cmt: uint32: uint32 {
.kind: variable(u32)
.offset: 000280
.size: 4
.owner: 
.value: ~u32B
}
u32Add: uint32: uint32 {
.kind: variable(u32)
.offset: 000284
.size: 4
.owner: 
.value: u32A + u32B
}
u32Sub: uint32: uint32 {
.kind: variable(u32)
.offset: 000288
.size: 4
.owner: 
.value: u32A - u32B
}
u32Mul: uint32: uint32 {
.kind: variable(u32)
.offset: 00028c
.size: 4
.owner: 
.value: u32A * u32B
}
u32Div: uint32: uint32 {
.kind: variable(u32)
.offset: 000290
.size: 4
.owner: 
.value: u32A / u32B
}
u32Mod: uint32: uint32 {
.kind: variable(u32)
.offset: 000294
.size: 4
.owner: 
.value: u32A % u32B
}
u32And: uint32: uint32 {
.kind: variable(u32)
.offset: 000298
.size: 4
.owner: 
.value: u32A & u32B
}
u32Ior: uint32: uint32 {
.kind: variable(u32)
.offset: 00029c
.size: 4
.owner: 
.value: u32A | u32B
}
u32Xor: uint32: uint32 {
.kind: variable(u32)
.offset: 0002a0
.size: 4
.owner: 
.value: u32A ^ u32B
}
u32Shl: uint32: uint32 {
.kind: variable(u32)
.offset: 0002a4
.size: 4
.owner: 
.value: u32A << shift
}
u32Shr: uint32: uint32 {
.kind: variable(u32)
.offset: 0002a8
.size: 4
.owner: 
.value: u32A >> shift
}
u32Not: bool: bool {
.kind: variable(bool)
.offset: 0002ac
.size: 1
.owner: 
.value: !u32B
}
u32Ceq: bool: bool {
.kind: variable(bool)
.offset: 0002b0
.size: 1
.owner: 
.value: u32A == u32B
}
u32Cne: bool: bool {
.kind: variable(bool)
.offset: 0002b4
.size: 1
.owner: 
.value: u32A != u32B
}
u32Clt: bool: bool {
.kind: variable(bool)
.offset: 0002b8
.size: 1
.owner: 
.value: u32A < u32B
}
u32Cle: bool: bool {
.kind: variable(bool)
.offset: 0002bc
.size: 1
.owner: 
.value: u32A <= u32B
}
u32Cgt: bool: bool {
.kind: variable(bool)
.offset: 0002c0
.size: 1
.owner: 
.value: u32A > u32B
}
u32Cge: bool: bool {
.kind: variable(bool)
.offset: 0002c4
.size: 1
.owner: 
.value: u32A >= u32B
}
i64A: int64: int64 {
.kind: variable(i64)
.offset: 0002cc
.size: 8
.owner: 
.value: a
}
i64B: int64: int64 {
.kind: variable(i64)
.offset: 0002d4
.size: 8
.owner: 
.value: b
}
i64Pls: int64: int64 {
.kind: variable(i64)
.offset: 0002dc
.size: 8
.owner: 
.value: +i64B
}
i64Neg: int64: int64 {
.kind: variable(i64)
.offset: 0002e4
.size: 8
.owner: 
.value: -i64B
}
i64Cmt: int64: int64 {
.kind: variable(i64)
.offset: 0002ec
.size: 8
.owner: 
.value: ~i64B
}
i64Add: int64: int64 {
.kind: variable(i64)
.offset: 0002f4
.size: 8
.owner: 
.value: i64A + i64B
}
i64Sub: int64: int64 {
.kind: variable(i64)
.offset: 0002fc
.size: 8
.owner: 
.value: i64A - i64B
}
i64Mul: int64: int64 {
.kind: variable(i64)
.offset: 000304
.size: 8
.owner: 
.value: i64A * i64B
}
i64Div: int64: int64 {
.kind: variable(i64)
.offset: 00030c
.size: 8
.owner: 
.value: i64A / i64B
}
i64Mod: int64: int64 {
.kind: variable(i64)
.offset: 000314
.size: 8
.owner: 
.value: i64A % i64B
}
i64And: int64: int64 {
.kind: variable(i64)
.offset: 00031c
.size: 8
.owner: 
.value: i64A & i64B
}
i64Ior: int64: int64 {
.kind: variable(i64)
.offset: 000324
.size: 8
.owner: 
.value: i64A | i64B
}
i64Xor: int64: int64 {
.kind: variable(i64)
.offset: 00032c
.size: 8
.owner: 
.value: i64A ^ i64B
}
i64Shl: int64: int64 {
.kind: variable(i64)
.offset: 000334
.size: 8
.owner: 
.value: i64A << shift
}
i64Shr: int64: int64 {
.kind: variable(i64)
.offset: 00033c
.size: 8
.owner: 
.value: i64A >> shift
}
i64Not: bool: bool {
.kind: variable(bool)
.offset: 000340
.size: 1
.owner: 
.value: !i64B
}
i64Ceq: bool: bool {
.kind: variable(bool)
.offset: 000344
.size: 1
.owner: 
.value: i64A == i64B
}
i64Cne: bool: bool {
.kind: variable(bool)
.offset: 000348
.size: 1
.owner: 
.value: i64A != i64B
}
i64Clt: bool: bool {
.kind: variable(bool)
.offset: 00034c
.size: 1
.owner: 
.value: i64A < i64B
}
i64Cle: bool: bool {
.kind: variable(bool)
.offset: 000350
.size: 1
.owner: 
.value: i64A <= i64B
}
i64Cgt: bool: bool {
.kind: variable(bool)
.offset: 000354
.size: 1
.owner: 
.value: i64A > i64B
}
i64Cge: bool: bool {
.kind: variable(bool)
.offset: 000358
.size: 1
.owner: 
.value: i64A >= i64B
}
u64A: uint64: uint64 {
.kind: variable(u64)
.offset: 000360
.size: 8
.owner: 
.value: a
}
u64B: uint64: uint64 {
.kind: variable(u64)
.offset: 000368
.size: 8
.owner: 
.value: b
}
u64Pls: uint64: uint64 {
.kind: variable(u64)
.offset: 000370
.size: 8
.owner: 
.value: +u64B
}
u64Neg: uint64: uint64 {
.kind: variable(u64)
.offset: 000378
.size: 8
.owner: 
.value: -u64B
}
u64Cmt: uint64: uint64 {
.kind: variable(u64)
.offset: 000380
.size: 8
.owner: 
.value: ~u64B
}
u64Add: uint64: uint64 {
.kind: variable(u64)
.offset: 000388
.size: 8
.owner: 
.value: u64A + u64B
}
u64Sub: uint64: uint64 {
.kind: variable(u64)
.offset: 000390
.size: 8
.owner: 
.value: u64A - u64B
}
u64Mul: uint64: uint64 {
.kind: variable(u64)
.offset: 000398
.size: 8
.owner: 
.value: u64A * u64B
}
u64Div: uint64: uint64 {
.kind: variable(u64)
.offset: 0003a0
.size: 8
.owner: 
.value: u64A / u64B
}
u64Mod: uint64: uint64 {
.kind: variable(u64)
.offset: 0003a8
.size: 8
.owner: 
.value: u64A % u64B
}
u64And: uint64: uint64 {
.kind: variable(u64)
.offset: 0003b0
.size: 8
.owner: 
.value: u64A & u64B
}
u64Ior: uint64: uint64 {
.kind: variable(u64)
.offset: 0003b8
.size: 8
.owner: 
.value: u64A | u64B
}
u64Xor: uint64: uint64 {
.kind: variable(u64)
.offset: 0003c0
.size: 8
.owner: 
.value: u64A ^ u64B
}
u64Shl: uint64: uint64 {
.kind: variable(u64)
.offset: 0003c8
.size: 8
.owner: 
.value: u64A << shift
}
u64Shr: uint64: uint64 {
.kind: variable(u64)
.offset: 0003d0
.size: 8
.owner: 
.value: u64A >> shift
}
u64Not: bool: bool {
.kind: variable(bool)
.offset: 0003d4
.size: 1
.owner: 
.value: !u64B
}
u64Ceq: bool: bool {
.kind: variable(bool)
.offset: 0003d8
.size: 1
.owner: 
.value: u64A == u64B
}
u64Cne: bool: bool {
.kind: variable(bool)
.offset: 0003dc
.size: 1
.owner: 
.value: u64A != u64B
}
u64Clt: bool: bool {
.kind: variable(bool)
.offset: 0003e0
.size: 1
.owner: 
.value: u64A < u64B
}
u64Cle: bool: bool {
.kind: variable(bool)
.offset: 0003e4
.size: 1
.owner: 
.value: u64A <= u64B
}
u64Cgt: bool: bool {
.kind: variable(bool)
.offset: 0003e8
.size: 1
.owner: 
.value: u64A > u64B
}
u64Cge: bool: bool {
.kind: variable(bool)
.offset: 0003ec
.size: 1
.owner: 
.value: u64A >= u64B
}
f32A: float32: float32 {
.kind: variable(f32)
.offset: 0003f0
.size: 4
.owner: 
.value: a
}
f32B: float32: float32 {
.kind: variable(f32)
.offset: 0003f4
.size: 4
.owner: 
.value: b
}
f32Pls: float32: float32 {
.kind: variable(f32)
.offset: 0003f8
.size: 4
.owner: 
.value: +f32B
}
f32Neg: float32: float32 {
.kind: variable(f32)
.offset: 0003fc
.size: 4
.owner: 
.value: -f32B
}
f32Add: float32: float32 {
.kind: variable(f32)
.offset: 000400
.size: 4
.owner: 
.value: f32A + f32B
}
f32Sub: float32: float32 {
.kind: variable(f32)
.offset: 000404
.size: 4
.owner: 
.value: f32A - f32B
}
f32Mul: float32: float32 {
.kind: variable(f32)
.offset: 000408
.size: 4
.owner: 
.value: f32A * f32B
}
f32Div: float32: float32 {
.kind: variable(f32)
.offset: 00040c
.size: 4
.owner: 
.value: f32A / f32B
}
f32Mod: float32: float32 {
.kind: variable(f32)
.offset: 000410
.size: 4
.owner: 
.value: f32A % f32B
}
f32Not: bool: bool {
.kind: variable(bool)
.offset: 000414
.size: 1
.owner: 
.value: !f32B
}
f32Ceq: bool: bool {
.kind: variable(bool)
.offset: 000418
.size: 1
.owner: 
.value: f32A == f32B
}
f32Cne: bool: bool {
.kind: variable(bool)
.offset: 00041c
.size: 1
.owner: 
.value: f32A != f32B
}
f32Clt: bool: bool {
.kind: variable(bool)
.offset: 000420
.size: 1
.owner: 
.value: f32A < f32B
}
f32Cle: bool: bool {
.kind: variable(bool)
.offset: 000424
.size: 1
.owner: 
.value: f32A <= f32B
}
f32Cgt: bool: bool {
.kind: variable(bool)
.offset: 000428
.size: 1
.owner: 
.value: f32A > f32B
}
f32Cge: bool: bool {
.kind: variable(bool)
.offset: 00042c
.size: 1
.owner: 
.value: f32A >= f32B
}
f64A: float64: float64 {
.kind: variable(f64)
.offset: 000434
.size: 8
.owner: 
.value: a
}
f64B: float64: float64 {
.kind: variable(f64)
.offset: 00043c
.size: 8
.owner: 
.value: b
}
f64Pls: float64: float64 {
.kind: variable(f64)
.offset: 000444
.size: 8
.owner: 
.value: +f64B
}
f64Neg: float64: float64 {
.kind: variable(f64)
.offset: 00044c
.size: 8
.owner: 
.value: -f64B
}
f64Add: float64: float64 {
.kind: variable(f64)
.offset: 000454
.size: 8
.owner: 
.value: f64A + f64B
}
f64Sub: float64: float64 {
.kind: variable(f64)
.offset: 00045c
.size: 8
.owner: 
.value: f64A - f64B
}
f64Mul: float64: float64 {
.kind: variable(f64)
.offset: 000464
.size: 8
.owner: 
.value: f64A * f64B
}
f64Div: float64: float64 {
.kind: variable(f64)
.offset: 00046c
.size: 8
.owner: 
.value: f64A / f64B
}
f64Mod: float64: float64 {
.kind: variable(f64)
.offset: 000474
.size: 8
.owner: 
.value: f64A % f64B
}
f64Not: bool: bool {
.kind: variable(bool)
.offset: 000478
.size: 1
.owner: 
.value: !f64B
}
f64Ceq: bool: bool {
.kind: variable(bool)
.offset: 00047c
.size: 1
.owner: 
.value: f64A == f64B
}
f64Cne: bool: bool {
.kind: variable(bool)
.offset: 000480
.size: 1
.owner: 
.value: f64A != f64B
}
f64Clt: bool: bool {
.kind: variable(bool)
.offset: 000484
.size: 1
.owner: 
.value: f64A < f64B
}
f64Cle: bool: bool {
.kind: variable(bool)
.offset: 000488
.size: 1
.owner: 
.value: f64A <= f64B
}
f64Cgt: bool: bool {
.kind: variable(bool)
.offset: 00048c
.size: 1
.owner: 
.value: f64A > f64B
}
f64Cge: bool: bool {
.kind: variable(bool)
.offset: 000490
.size: 1
.owner: 
.value: f64A >= f64B
}
t: int32: int32 {
.kind: variable(i32)
.offset: 000494
.size: 4
.owner: 
.value: 0
}
arrFixedNoInit: int64[7]: int64[7] {
.kind: variable(val)
.offset: 0004cc
.size: 56
.owner: 
}
arrSliceNoInit: int64[]: int64[] {
.kind: variable(arr)
.offset: 0004d4
.size: 8
.owner: 
}
arrPtrNoInit: int64[*]: int64[*] {
.kind: variable(ref)
.offset: 0004d8
.size: 4
.owner: 
}
arrSliceInitNull: int64[]: int64[] {
.kind: variable(arr)
.offset: 0004e0
.size: 8
.owner: 
.value: null
}
arrPtrInitNull: int64[*]: int64[*] {
.kind: variable(ref)
.offset: 0004e4
.size: 4
.owner: 
.value: null
}
arrSliceInitFixed: int64[]: int64[] {
.kind: variable(arr)
.offset: 0004ec
.size: 8
.owner: 
.value: arrFixedNoInit
}
arrPtrInitFixed: int64[*]: int64[*] {
.kind: variable(ref)
.offset: 0004f0
.size: 4
.owner: 
.value: arrFixedNoInit
}
arrSliceInitSlice: int64[]: int64[] {
.kind: variable(arr)
.offset: 0004f8
.size: 8
.owner: 
.value: arrSliceInitFixed
}
arrPtrInitSlice: int64[*]: int64[*] {
.kind: variable(ref)
.offset: 0004fc
.size: 4
.owner: 
.value: arrSliceInitFixed
}
arrPtrInitPtr: int64[*]: int64[*] {
.kind: variable(ref)
.offset: 000500
.size: 4
.owner: 
.value: arrPtrInitFixed
}
arrSliceInitString: char[]: char[] {
.kind: variable(arr)
.offset: 000508
.size: 8
.owner: 
.value: 'string'
}
arrPtrInitString: char[*]: char[*] {
.kind: variable(ref)
.offset: 00050c
.size: 4
.owner: 
.value: 'string'
}
value: int64: int64 {
.kind: variable(i64)
.offset: 000514
.size: 8
.owner: 
.value: 33
}
valueRef: int64: int64 {
.kind: variable(ref)
.offset: 000518
.size: 4
.owner: 
.value: value
}
valuePtr: pointer: pointer {
.kind: variable(ref)
.offset: 00051c
.size: 4
.owner: 
.value: value
}
valueVar: variant: variant {
.kind: variable(var)
.offset: 000524
.size: 8
.owner: 
.value: value
}
copyVal: int64: int64 {
.kind: variable(i64)
.offset: 00052c
.size: 8
.owner: 
.value: value
}
copyRef: int64: int64 {
.kind: variable(ref)
.offset: 000530
.size: 4
.owner: 
.value: valueRef
}
copyPtr: pointer: pointer {
.kind: variable(ref)
.offset: 000534
.size: 4
.owner: 
.value: valuePtr
}
copyVar: variant: variant {
.kind: variable(var)
.offset: 00053c
.size: 8
.owner: 
.value: valueVar
}
fromRef: int64: int64 {
.kind: variable(i64)
.offset: 000544
.size: 8
.owner: 
.value: valueRef
}
fromPtr: int64: int64 {
.kind: variable(ref)
.offset: 000548
.size: 4
.owner: 
.value: valuePtr
}
fromVar: int64: int64 {
.kind: variable(ref)
.offset: 00054c
.size: 4
.owner: 
.value: valueVar
}
nullRef: int64: int64 {
.kind: variable(ref)
.offset: 000550
.size: 4
.owner: 
.value: null
}
nullPtr: pointer: pointer {
.kind: variable(ref)
.offset: 000554
.size: 4
.owner: 
.value: null
}
nullVar: variant: variant {
.kind: variable(var)
.offset: 00055c
.size: 8
.owner: 
.value: null
}
typePtr: pointer: pointer {
.kind: variable(ref)
.offset: 000560
.size: 4
.owner: 
.value: int64
}
typeVar: variant: variant {
.kind: variable(var)
.offset: 000568
.size: 8
.owner: 
.value: int64
}
ptrVoid: pointer: pointer {
.kind: variable(ref)
.offset: 00056c
.size: 4
.owner: 
.value: void
}
ptrBool: pointer: pointer {
.kind: variable(ref)
.offset: 000570
.size: 4
.owner: 
.value: bool
}
ptrChar: pointer: pointer {
.kind: variable(ref)
.offset: 000574
.size: 4
.owner: 
.value: char
}
ptrInt8: pointer: pointer {
.kind: variable(ref)
.offset: 000578
.size: 4
.owner: 
.value: int8
}
ptrInt16: pointer: pointer {
.kind: variable(ref)
.offset: 00057c
.size: 4
.owner: 
.value: int16
}
ptrInt32: pointer: pointer {
.kind: variable(ref)
.offset: 000580
.size: 4
.owner: 
.value: int32
}
ptrInt64: pointer: pointer {
.kind: variable(ref)
.offset: 000584
.size: 4
.owner: 
.value: int64
}
ptrUint8: pointer: pointer {
.kind: variable(ref)
.offset: 000588
.size: 4
.owner: 
.value: uint8
}
ptrUint16: pointer: pointer {
.kind: variable(ref)
.offset: 00058c
.size: 4
.owner: 
.value: uint16
}
ptrUint32: pointer: pointer {
.kind: variable(ref)
.offset: 000590
.size: 4
.owner: 
.value: uint32
}
ptrUint64: pointer: pointer {
.kind: variable(ref)
.offset: 000594
.size: 4
.owner: 
.value: uint64
}
ptrFloat32: pointer: pointer {
.kind: variable(ref)
.offset: 000598
.size: 4
.owner: 
.value: float32
}
ptrFloat64: pointer: pointer {
.kind: variable(ref)
.offset: 00059c
.size: 4
.owner: 
.value: float64
}
ptrTypename: pointer: pointer {
.kind: variable(ref)
.offset: 0005a0
.size: 4
.owner: 
.value: typename
}
ptrFunction: pointer: pointer {
.kind: variable(ref)
.offset: 0005a4
.size: 4
.owner: 
.value: function
}
ptrPointer: pointer: pointer {
.kind: variable(ref)
.offset: 0005a8
.size: 4
.owner: 
.value: pointer
}
ptrVariant: pointer: pointer {
.kind: variable(ref)
.offset: 0005ac
.size: 4
.owner: 
.value: variant
}
ptrObject: pointer: pointer {
.kind: variable(ref)
.offset: 0005b0
.size: 4
.owner: 
.value: object
}
varVoid: variant: variant {
.kind: variable(var)
.offset: 0005b8
.size: 8
.owner: 
.value: void
}
varBool: variant: variant {
.kind: variable(var)
.offset: 0005c0
.size: 8
.owner: 
.value: bool
}
varChar: variant: variant {
.kind: variable(var)
.offset: 0005c8
.size: 8
.owner: 
.value: char
}
varInt8: variant: variant {
.kind: variable(var)
.offset: 0005d0
.size: 8
.owner: 
.value: int8
}
varInt16: variant: variant {
.kind: variable(var)
.offset: 0005d8
.size: 8
.owner: 
.value: int16
}
varInt32: variant: variant {
.kind: variable(var)
.offset: 0005e0
.size: 8
.owner: 
.value: int32
}
varInt64: variant: variant {
.kind: variable(var)
.offset: 0005e8
.size: 8
.owner: 
.value: int64
}
varUint8: variant: variant {
.kind: variable(var)
.offset: 0005f0
.size: 8
.owner: 
.value: uint8
}
varUint16: variant: variant {
.kind: variable(var)
.offset: 0005f8
.size: 8
.owner: 
.value: uint16
}
varUint32: variant: variant {
.kind: variable(var)
.offset: 000600
.size: 8
.owner: 
.value: uint32
}
varUint64: variant: variant {
.kind: variable(var)
.offset: 000608
.size: 8
.owner: 
.value: uint64
}
varFloat32: variant: variant {
.kind: variable(var)
.offset: 000610
.size: 8
.owner: 
.value: float32
}
varFloat64: variant: variant {
.kind: variable(var)
.offset: 000618
.size: 8
.owner: 
.value: float64
}
varTypename: variant: variant {
.kind: variable(var)
.offset: 000620
.size: 8
.owner: 
.value: typename
}
varFunction: variant: variant {
.kind: variable(var)
.offset: 000628
.size: 8
.owner: 
.value: function
}
varPointer: variant: variant {
.kind: variable(var)
.offset: 000630
.size: 8
.owner: 
.value: pointer
}
varVariant: variant: variant {
.kind: variable(var)
.offset: 000638
.size: 8
.owner: 
.value: variant
}
varObject: variant: variant {
.kind: variable(var)
.offset: 000640
.size: 8
.owner: 
.value: object
}
copyPtrFloat64: variant: variant {
.kind: variable(var)
.offset: 000648
.size: 8
.owner: 
.value: ptrFloat64
}
copyVarFloat64: pointer: pointer {
.kind: variable(ref)
.offset: 00064c
.size: 4
.owner: 
.value: varFloat64
}
localNoInit: int64: int64 {
.kind: variable(i64)
.offset: 000654
.size: 8
.owner: 
}
globalNoInit: int64: int64 {
.kind: static variable(i64)
.offset: 01c610
.size: 8
.owner: 
}
localInitValue: int64: int64 {
.kind: variable(i64)
.offset: 00065c
.size: 8
.owner: 
.value: 42
}
globalInitValue: int64: int64 {
.kind: static variable(i64)
.offset: 01c618
.size: 8
.owner: 
.value: 1024
}
localInitLocal: int64: int64 {
.kind: variable(i64)
.offset: 000664
.size: 8
.owner: 
.value: localInitValue
}
globalInitLocal: int64: int64 {
.kind: static variable(i64)
.offset: 01c620
.size: 8
.owner: 
.value: localInitValue
}
localInitGlobal: int64: int64 {
.kind: variable(i64)
.offset: 00066c
.size: 8
.owner: 
.value: globalInitValue
}
globalInitGlobal: int64: int64 {
.kind: static variable(i64)
.offset: 01c628
.size: 8
.owner: 
.value: globalInitValue
}
pi64: float64: float64 {
.kind: variable(f64)
.offset: 000674
.size: 8
.owner: 
.value: 3.141593
}
e64: float64: float64 {
.kind: variable(f64)
.offset: 00067c
.size: 8
.owner: 
.value: 2.718282
}
pi32: float32: float32 {
.kind: variable(f32)
.offset: 000680
.size: 4
.owner: 
.value: pi64
}
e32: float32: float32 {
.kind: variable(f32)
.offset: 000684
.size: 4
.owner: 
.value: e64
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+12->inline)
.param r: int32 (@+12->i32)
.param g: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: int32 (@+12->inline)
.param r: int32 (@+12->i32)
.param g: int32 (@+8->i32)
.param b: int32 (@+4->i32)
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
}
r_comp: int32: int32 {
.kind: variable(i32)
.offset: 000688
.size: 4
.owner: 
.value: 14 << 3
}
g_comp: int32: int32 {
.kind: variable(i32)
.offset: 00068c
.size: 4
.owner: 
.value: 63 << 2
}
b_comp: int32: int32 {
.kind: variable(i32)
.offset: 000690
.size: 4
.owner: 
.value: 31 << 3
}
r5g6b5: int32: int32 {
.kind: variable(i32)
.offset: 000694
.size: 4
.owner: 
.value: rgb565(r_comp, g_comp, b_comp)
}
r8g8b8: int32: int32 {
.kind: variable(i32)
.offset: 000698
.size: 4
.owner: 
.value: rgb888(r_comp, g_comp, b_comp)
}
zextR5: int32: int32 {
.kind: variable(i32)
.offset: 00069c
.size: 4
.owner: 
.value: uint32.zxt(r5g6b5, 11, 5)
}
zextG6: int32: int32 {
.kind: variable(i32)
.offset: 0006a0
.size: 4
.owner: 
.value: uint32.zxt(r5g6b5, 5, 6)
}
zextB5: int32: int32 {
.kind: variable(i32)
.offset: 0006a4
.size: 4
.owner: 
.value: uint32.zxt(r5g6b5, 0, 5)
}
sextR5: int32: int32 {
.kind: variable(i32)
.offset: 0006a8
.size: 4
.owner: 
.value: uint32.sxt(r5g6b5, 11, 5)
}
sextG6: int32: int32 {
.kind: variable(i32)
.offset: 0006ac
.size: 4
.owner: 
.value: uint32.sxt(r5g6b5, 5, 6)
}
sextB5: int32: int32 {
.kind: variable(i32)
.offset: 0006b0
.size: 4
.owner: 
.value: uint32.sxt(r5g6b5, 0, 5)
}
zextR8: int32: int32 {
.kind: variable(i32)
.offset: 0006b4
.size: 4
.owner: 
.value: uint32.zxt(r8g8b8, 16, 8)
}
zextG8: int32: int32 {
.kind: variable(i32)
.offset: 0006b8
.size: 4
.owner: 
.value: uint32.zxt(r8g8b8, 8, 8)
}
zextB8: int32: int32 {
.kind: variable(i32)
.offset: 0006bc
.size: 4
.owner: 
.value: uint32.zxt(r8g8b8, 0, 8)
}
sextR8: int32: int32 {
.kind: variable(i32)
.offset: 0006c0
.size: 4
.owner: 
.value: uint32.sxt(r8g8b8, 16, 8)
}
sextG8: int32: int32 {
.kind: variable(i32)
.offset: 0006c4
.size: 4
.owner: 
.value: uint32.sxt(r8g8b8, 8, 8)
}
sextB8: int32: int32 {
.kind: variable(i32)
.offset: 0006c8
.size: 4
.owner: 
.value: uint32.sxt(r8g8b8, 0, 8)
}
sinF64: float64: float64 {
.kind: variable(f64)
.offset: 0006d0
.size: 8
.owner: 
.value: float64.sin(pi64 / (2))
}
cosF64: float64: float64 {
.kind: variable(f64)
.offset: 0006d8
.size: 8
.owner: 
.value: float64.cos(pi64 / (2))
}
tanF64: float64: float64 {
.kind: variable(f64)
.offset: 0006e0
.size: 8
.owner: 
.value: float64.tan(pi64 / (4))
}
logF64: float64: float64 {
.kind: variable(f64)
.offset: 0006e8
.size: 8
.owner: 
.value: float64.log(e64 * e64 * e64)
}
expF64: float64: float64 {
.kind: variable(f64)
.offset: 0006f0
.size: 8
.owner: 
.value: float64.exp(1.000000)
}
powF64: float64: float64 {
.kind: variable(f64)
.offset: 0006f8
.size: 8
.owner: 
.value: float64.pow(pi64 * pi64, 0.500000)
}
sqrtF64: float64: float64 {
.kind: variable(f64)
.offset: 000700
.size: 8
.owner: 
.value: float64.sqrt(pi64 * pi64)
}
atanF64: float64: float64 {
.kind: variable(f64)
.offset: 000708
.size: 8
.owner: 
.value: float64.atan2(pi64, 1.000000)
}
sinF32: float32: float32 {
.kind: variable(f32)
.offset: 00070c
.size: 4
.owner: 
.value: float32.sin(pi32 / (2))
}
cosF32: float32: float32 {
.kind: variable(f32)
.offset: 000710
.size: 4
.owner: 
.value: float32.cos(pi32 / (2))
}
tanF32: float32: float32 {
.kind: variable(f32)
.offset: 000714
.size: 4
.owner: 
.value: float32.tan(pi32 / (4))
}
logF32: float32: float32 {
.kind: variable(f32)
.offset: 000718
.size: 4
.owner: 
.value: float32.log(e32 * e32 * e32)
}
expF32: float32: float32 {
.kind: variable(f32)
.offset: 00071c
.size: 4
.owner: 
.value: float32.exp(1.000000)
}
powF32: float32: float32 {
.kind: variable(f32)
.offset: 000720
.size: 4
.owner: 
.value: float32.pow(pi32 * pi32, 0.500000)
}
sqrtF32: float32: float32 {
.kind: variable(f32)
.offset: 000724
.size: 4
.owner: 
.value: float32.sqrt(pi32 * pi32)
}
atanF32: float32: float32 {
.kind: variable(f32)
.offset: 000728
.size: 4
.owner: 
.value: float32.atan2(pi32, 1.000000)
}
free(data: pointer): pointer: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: pointer (@+4->inline)
.param data: pointer (@+4->ref)
.value: memmgr(data, 0)
}
malloc(size: int32): pointer: function {
.kind: inline
.offset: 000000
.size: 0
.owner: 
.param .result: pointer (@+4->inline)
.param size: int32 (@+4->i32)
.value: memmgr(null, size)
}
p1: pointer: pointer {
.kind: variable(ref)
.offset: 00072c
.size: 4
.owner: 
.value: malloc(1024)
}
p2: pointer: pointer {
.kind: variable(ref)
.offset: 000730
.size: 4
.owner: 
.value: memmgr(null, 80)
}
p3: pointer: pointer {
.kind: variable(ref)
.offset: 000734
.size: 4
.owner: 
.value: memmgr(null, 160)
}
p4: pointer: pointer {
.kind: variable(ref)
.offset: 000738
.size: 4
.owner: 
.value: memmgr(null, 820)
}
val1: int64: int64 {
.kind: variable(i64)
.offset: 000740
.size: 8
.owner: 
.value: 42
}
val2: int64: int64 {
.kind: variable(i64)
.offset: 000748
.size: 8
.owner: 
.value: 96
}
.main(): void: function {
.kind: static function
.offset: 01c630
.size: 5069
.owner: 
.field typename: typename (size: 0 @8 -> static const typename(ref))
.field void: typename (size: 0 @160 -> static const typename(void))
.field bool: typename (size: 1 @304 -> static const typename(bool))
.field char: typename (size: 1 @448 -> static const typename(u32))
.field int8: typename (size: 1 @592 -> static const typename(i32))
.field int16: typename (size: 2 @736 -> static const typename(i32))
.field int32: typename (size: 4 @880 -> static const typename(i32))
.field int64: typename (size: 8 @1024 -> static const typename(i64))
.field uint8: typename (size: 1 @1168 -> static const typename(u32))
.field uint16: typename (size: 2 @1312 -> static const typename(u32))
.field uint32: typename (size: 4 @1456 -> static const typename(u32))
.field uint64: typename (size: 8 @1600 -> static const typename(u64))
.field float32: typename (size: 4 @1744 -> static const typename(f32))
.field float64: typename (size: 8 @1888 -> static const typename(f64))
.field pointer: typename (size: 4 @2032 -> static const typename(ref))
.field variant: typename (size: 8 @2176 -> static const typename(var))
.field function: typename (size: 8 @2320 -> static const typename(ref))
.field object: typename (size: 4 @2472 -> static const typename(ref))
.field null: pointer (size: 0 @0 -> static const inline)
.field true: bool (size: 0 @0 -> static const inline)
.field false: bool (size: 0 @0 -> static const inline)
.field int: typename (size: 0 @0 -> static const inline)
.field byte: typename (size: 0 @0 -> static const inline)
.field float: typename (size: 0 @0 -> static const inline)
.field double: typename (size: 0 @0 -> static const inline)
.field .cstr: char (size: 4 @3624 -> static const typename(arr))
.field emit: function (size: 0 @3768 -> static const typename(void))
.field halt: function (size: 8 @21168 -> static const inline)
.field CLOCKS_PER_SEC: int32 (size: 0 @0 -> i32)
.field RAND_MAX: int32 (size: 0 @0 -> i32)
.field raise: function (size: 8 @24672 -> static const inline)
.field tryExec: function (size: 8 @26720 -> static const inline)
.field memmgr: function (size: 8 @27328 -> static const inline)
.field memset: function (size: 8 @28080 -> static const inline)
.field memcpy: function (size: 8 @28824 -> static const inline)
.field System: void (size: 0 @28872 -> static const typename(void))
.field File: typename (size: 8 @42600 -> static const typename(val))
.field integer: typename (size: 0 @0 -> inline)
.field xrgb: typename (size: 4 @50936 -> static const typename(val))
.field color: typename (size: 4 @51616 -> static const typename(val))
.field type: object (size: 12 @52024 -> static const typename(ref))
.field zero: function (size: 0 @0 -> inline)
.field first: function (size: 0 @0 -> inline)
.field last: function (size: 0 @0 -> inline)
.field sum: function (size: 0 @0 -> inline)
.field any: function (size: 0 @0 -> inline)
.field min: function (size: 0 @0 -> inline)
.field min: function (size: 0 @0 -> inline)
.field ma: int32 (size: 4 @4 -> variable(i32))
.field mb: int32 (size: 4 @8 -> variable(i32))
.field mc: int32 (size: 4 @12 -> variable(i32))
.field min2var: int32 (size: 4 @16 -> variable(i32))
.field emitldz32: int32 (size: 4 @20 -> variable(i32))
.field emitldz64: int64 (size: 8 @28 -> variable(i64))
.field emitA: int32 (size: 4 @32 -> variable(i32))
.field emitB: int32 (size: 4 @36 -> variable(i32))
.field emitAddi32: int32 (size: 4 @40 -> variable(i32))
.field a: typename (size: 0 @0 -> inline)
.field b: typename (size: 0 @0 -> inline)
.field shift: int32 (size: 4 @44 -> variable(i32))
.field boolA: bool (size: 1 @48 -> variable(bool))
.field boolB: bool (size: 1 @52 -> variable(bool))
.field boolAnd: bool (size: 1 @56 -> variable(bool))
.field boolIor: bool (size: 1 @60 -> variable(bool))
.field boolXor: bool (size: 1 @64 -> variable(bool))
.field boolNot: bool (size: 1 @68 -> variable(bool))
.field boolCeq: bool (size: 1 @72 -> variable(bool))
.field boolCne: bool (size: 1 @76 -> variable(bool))
.field boolClt: bool (size: 1 @80 -> variable(bool))
.field boolCle: bool (size: 1 @84 -> variable(bool))
.field boolCgt: bool (size: 1 @88 -> variable(bool))
.field boolCge: bool (size: 1 @92 -> variable(bool))
.field chrA: char (size: 1 @96 -> variable(u32))
.field chrB: char (size: 1 @100 -> variable(u32))
.field chrPls: char (size: 1 @104 -> variable(u32))
.field chrNeg: char (size: 1 @108 -> variable(u32))
.field chrCmt: char (size: 1 @112 -> variable(u32))
.field chrAdd: char (size: 1 @116 -> variable(u32))
.field chrSub: char (size: 1 @120 -> variable(u32))
.field chrMul: char (size: 1 @124 -> variable(u32))
.field chrDiv: char (size: 1 @128 -> variable(u32))
.field chrMod: char (size: 1 @132 -> variable(u32))
.field chrAnd: char (size: 1 @136 -> variable(u32))
.field chrIor: char (size: 1 @140 -> variable(u32))
.field chrXor: char (size: 1 @144 -> variable(u32))
.field chrShl: char (size: 1 @148 -> variable(u32))
.field chrShr: char (size: 1 @152 -> variable(u32))
.field chrNot: bool (size: 1 @156 -> variable(bool))
.field chrCeq: bool (size: 1 @160 -> variable(bool))
.field chrCne: bool (size: 1 @164 -> variable(bool))
.field chrClt: bool (size: 1 @168 -> variable(bool))
.field chrCle: bool (size: 1 @172 -> variable(bool))
.field chrCgt: bool (size: 1 @176 -> variable(bool))
.field chrCge: bool (size: 1 @180 -> variable(bool))
.field i8A: int8 (size: 1 @184 -> variable(i32))
.field i8B: int8 (size: 1 @188 -> variable(i32))
.field i8Pls: int8 (size: 1 @192 -> variable(i32))
.field i8Neg: int8 (size: 1 @196 -> variable(i32))
.field i8Cmt: int8 (size: 1 @200 -> variable(i32))
.field i8Add: int8 (size: 1 @204 -> variable(i32))
.field i8Sub: int8 (size: 1 @208 -> variable(i32))
.field i8Mul: int8 (size: 1 @212 -> variable(i32))
.field i8Div: int8 (size: 1 @216 -> variable(i32))
.field i8Mod: int8 (size: 1 @220 -> variable(i32))
.field i8And: int8 (size: 1 @224 -> variable(i32))
.field i8Ior: int8 (size: 1 @228 -> variable(i32))
.field i8Xor: int8 (size: 1 @232 -> variable(i32))
.field i8Shl: int8 (size: 1 @236 -> variable(i32))
.field i8Shr: int8 (size: 1 @240 -> variable(i32))
.field i8Not: bool (size: 1 @244 -> variable(bool))
.field i8Ceq: bool (size: 1 @248 -> variable(bool))
.field i8Cne: bool (size: 1 @252 -> variable(bool))
.field i8Clt: bool (size: 1 @256 -> variable(bool))
.field i8Cle: bool (size: 1 @260 -> variable(bool))
.field i8Cgt: bool (size: 1 @264 -> variable(bool))
.field i8Cge: bool (size: 1 @268 -> variable(bool))
.field u8A: uint8 (size: 1 @272 -> variable(u32))
.field u8B: uint8 (size: 1 @276 -> variable(u32))
.field u8Pls: uint8 (size: 1 @280 -> variable(u32))
.field u8Neg: uint8 (size: 1 @284 -> variable(u32))
.field u8Cmt: uint8 (size: 1 @288 -> variable(u32))
.field u8Add: uint8 (size: 1 @292 -> variable(u32))
.field u8Sub: uint8 (size: 1 @296 -> variable(u32))
.field u8Mul: uint8 (size: 1 @300 -> variable(u32))
.field u8Div: uint8 (size: 1 @304 -> variable(u32))
.field u8Mod: uint8 (size: 1 @308 -> variable(u32))
.field u8And: uint8 (size: 1 @312 -> variable(u32))
.field u8Ior: uint8 (size: 1 @316 -> variable(u32))
.field u8Xor: uint8 (size: 1 @320 -> variable(u32))
.field u8Shl: uint8 (size: 1 @324 -> variable(u32))
.field u8Shr: uint8 (size: 1 @328 -> variable(u32))
.field u8Not: bool (size: 1 @332 -> variable(bool))
.field u8Ceq: bool (size: 1 @336 -> variable(bool))
.field u8Cne: bool (size: 1 @340 -> variable(bool))
.field u8Clt: bool (size: 1 @344 -> variable(bool))
.field u8Cle: bool (size: 1 @348 -> variable(bool))
.field u8Cgt: bool (size: 1 @352 -> variable(bool))
.field u8Cge: bool (size: 1 @356 -> variable(bool))
.field i16A: int16 (size: 2 @360 -> variable(i32))
.field i16B: int16 (size: 2 @364 -> variable(i32))
.field i16Pls: int16 (size: 2 @368 -> variable(i32))
.field i16Neg: int16 (size: 2 @372 -> variable(i32))
.field i16Cmt: int16 (size: 2 @376 -> variable(i32))
.field i16Add: int16 (size: 2 @380 -> variable(i32))
.field i16Sub: int16 (size: 2 @384 -> variable(i32))
.field i16Mul: int16 (size: 2 @388 -> variable(i32))
.field i16Div: int16 (size: 2 @392 -> variable(i32))
.field i16Mod: int16 (size: 2 @396 -> variable(i32))
.field i16And: int16 (size: 2 @400 -> variable(i32))
.field i16Ior: int16 (size: 2 @404 -> variable(i32))
.field i16Xor: int16 (size: 2 @408 -> variable(i32))
.field i16Shl: int16 (size: 2 @412 -> variable(i32))
.field i16Shr: int16 (size: 2 @416 -> variable(i32))
.field i16Not: bool (size: 1 @420 -> variable(bool))
.field i16Ceq: bool (size: 1 @424 -> variable(bool))
.field i16Cne: bool (size: 1 @428 -> variable(bool))
.field i16Clt: bool (size: 1 @432 -> variable(bool))
.field i16Cle: bool (size: 1 @436 -> variable(bool))
.field i16Cgt: bool (size: 1 @440 -> variable(bool))
.field i16Cge: bool (size: 1 @444 -> variable(bool))
.field u16A: uint16 (size: 2 @448 -> variable(u32))
.field u16B: uint16 (size: 2 @452 -> variable(u32))
.field u16Pls: uint16 (size: 2 @456 -> variable(u32))
.field u16Neg: uint16 (size: 2 @460 -> variable(u32))
.field u16Cmt: uint16 (size: 2 @464 -> variable(u32))
.field u16Add: uint16 (size: 2 @468 -> variable(u32))
.field u16Sub: uint16 (size: 2 @472 -> variable(u32))
.field u16Mul: uint16 (size: 2 @476 -> variable(u32))
.field u16Div: uint16 (size: 2 @480 -> variable(u32))
.field u16Mod: uint16 (size: 2 @484 -> variable(u32))
.field u16And: uint16 (size: 2 @488 -> variable(u32))
.field u16Ior: uint16 (size: 2 @492 -> variable(u32))
.field u16Xor: uint16 (size: 2 @496 -> variable(u32))
.field u16Shl: uint16 (size: 2 @500 -> variable(u32))
.field u16Shr: uint16 (size: 2 @504 -> variable(u32))
.field u16Not: bool (size: 1 @508 -> variable(bool))
.field u16Ceq: bool (size: 1 @512 -> variable(bool))
.field u16Cne: bool (size: 1 @516 -> variable(bool))
.field u16Clt: bool (size: 1 @520 -> variable(bool))
.field u16Cle: bool (size: 1 @524 -> variable(bool))
.field u16Cgt: bool (size: 1 @528 -> variable(bool))
.field u16Cge: bool (size: 1 @532 -> variable(bool))
.field i32A: int32 (size: 4 @536 -> variable(i32))
.field i32B: int32 (size: 4 @540 -> variable(i32))
.field i32Pls: int32 (size: 4 @544 -> variable(i32))
.field i32Neg: int32 (size: 4 @548 -> variable(i32))
.field i32Cmt: int32 (size: 4 @552 -> variable(i32))
.field i32Add: int32 (size: 4 @556 -> variable(i32))
.field i32Sub: int32 (size: 4 @560 -> variable(i32))
.field i32Mul: int32 (size: 4 @564 -> variable(i32))
.field i32Div: int32 (size: 4 @568 -> variable(i32))
.field i32Mod: int32 (size: 4 @572 -> variable(i32))
.field i32And: int32 (size: 4 @576 -> variable(i32))
.field i32Ior: int32 (size: 4 @580 -> variable(i32))
.field i32Xor: int32 (size: 4 @584 -> variable(i32))
.field i32Shl: int32 (size: 4 @588 -> variable(i32))
.field i32Shr: int32 (size: 4 @592 -> variable(i32))
.field i32Not: bool (size: 1 @596 -> variable(bool))
.field i32Ceq: bool (size: 1 @600 -> variable(bool))
.field i32Cne: bool (size: 1 @604 -> variable(bool))
.field i32Clt: bool (size: 1 @608 -> variable(bool))
.field i32Cle: bool (size: 1 @612 -> variable(bool))
.field i32Cgt: bool (size: 1 @616 -> variable(bool))
.field i32Cge: bool (size: 1 @620 -> variable(bool))
.field u32A: uint32 (size: 4 @624 -> variable(u32))
.field u32B: uint32 (size: 4 @628 -> variable(u32))
.field u32Pls: uint32 (size: 4 @632 -> variable(u32))
.field u32Neg: uint32 (size: 4 @636 -> variable(u32))
.field u32Cmt: uint32 (size: 4 @640 -> variable(u32))
.field u32Add: uint32 (size: 4 @644 -> variable(u32))
.field u32Sub: uint32 (size: 4 @648 -> variable(u32))
.field u32Mul: uint32 (size: 4 @652 -> variable(u32))
.field u32Div: uint32 (size: 4 @656 -> variable(u32))
.field u32Mod: uint32 (size: 4 @660 -> variable(u32))
.field u32And: uint32 (size: 4 @664 -> variable(u32))
.field u32Ior: uint32 (size: 4 @668 -> variable(u32))
.field u32Xor: uint32 (size: 4 @672 -> variable(u32))
.field u32Shl: uint32 (size: 4 @676 -> variable(u32))
.field u32Shr: uint32 (size: 4 @680 -> variable(u32))
.field u32Not: bool (size: 1 @684 -> variable(bool))
.field u32Ceq: bool (size: 1 @688 -> variable(bool))
.field u32Cne: bool (size: 1 @692 -> variable(bool))
.field u32Clt: bool (size: 1 @696 -> variable(bool))
.field u32Cle: bool (size: 1 @700 -> variable(bool))
.field u32Cgt: bool (size: 1 @704 -> variable(bool))
.field u32Cge: bool (size: 1 @708 -> variable(bool))
.field i64A: int64 (size: 8 @716 -> variable(i64))
.field i64B: int64 (size: 8 @724 -> variable(i64))
.field i64Pls: int64 (size: 8 @732 -> variable(i64))
.field i64Neg: int64 (size: 8 @740 -> variable(i64))
.field i64Cmt: int64 (size: 8 @748 -> variable(i64))
.field i64Add: int64 (size: 8 @756 -> variable(i64))
.field i64Sub: int64 (size: 8 @764 -> variable(i64))
.field i64Mul: int64 (size: 8 @772 -> variable(i64))
.field i64Div: int64 (size: 8 @780 -> variable(i64))
.field i64Mod: int64 (size: 8 @788 -> variable(i64))
.field i64And: int64 (size: 8 @796 -> variable(i64))
.field i64Ior: int64 (size: 8 @804 -> variable(i64))
.field i64Xor: int64 (size: 8 @812 -> variable(i64))
.field i64Shl: int64 (size: 8 @820 -> variable(i64))
.field i64Shr: int64 (size: 8 @828 -> variable(i64))
.field i64Not: bool (size: 1 @832 -> variable(bool))
.field i64Ceq: bool (size: 1 @836 -> variable(bool))
.field i64Cne: bool (size: 1 @840 -> variable(bool))
.field i64Clt: bool (size: 1 @844 -> variable(bool))
.field i64Cle: bool (size: 1 @848 -> variable(bool))
.field i64Cgt: bool (size: 1 @852 -> variable(bool))
.field i64Cge: bool (size: 1 @856 -> variable(bool))
.field u64A: uint64 (size: 8 @864 -> variable(u64))
.field u64B: uint64 (size: 8 @872 -> variable(u64))
.field u64Pls: uint64 (size: 8 @880 -> variable(u64))
.field u64Neg: uint64 (size: 8 @888 -> variable(u64))
.field u64Cmt: uint64 (size: 8 @896 -> variable(u64))
.field u64Add: uint64 (size: 8 @904 -> variable(u64))
.field u64Sub: uint64 (size: 8 @912 -> variable(u64))
.field u64Mul: uint64 (size: 8 @920 -> variable(u64))
.field u64Div: uint64 (size: 8 @928 -> variable(u64))
.field u64Mod: uint64 (size: 8 @936 -> variable(u64))
.field u64And: uint64 (size: 8 @944 -> variable(u64))
.field u64Ior: uint64 (size: 8 @952 -> variable(u64))
.field u64Xor: uint64 (size: 8 @960 -> variable(u64))
.field u64Shl: uint64 (size: 8 @968 -> variable(u64))
.field u64Shr: uint64 (size: 8 @976 -> variable(u64))
.field u64Not: bool (size: 1 @980 -> variable(bool))
.field u64Ceq: bool (size: 1 @984 -> variable(bool))
.field u64Cne: bool (size: 1 @988 -> variable(bool))
.field u64Clt: bool (size: 1 @992 -> variable(bool))
.field u64Cle: bool (size: 1 @996 -> variable(bool))
.field u64Cgt: bool (size: 1 @1000 -> variable(bool))
.field u64Cge: bool (size: 1 @1004 -> variable(bool))
.field f32A: float32 (size: 4 @1008 -> variable(f32))
.field f32B: float32 (size: 4 @1012 -> variable(f32))
.field f32Pls: float32 (size: 4 @1016 -> variable(f32))
.field f32Neg: float32 (size: 4 @1020 -> variable(f32))
.field f32Add: float32 (size: 4 @1024 -> variable(f32))
.field f32Sub: float32 (size: 4 @1028 -> variable(f32))
.field f32Mul: float32 (size: 4 @1032 -> variable(f32))
.field f32Div: float32 (size: 4 @1036 -> variable(f32))
.field f32Mod: float32 (size: 4 @1040 -> variable(f32))
.field f32Not: bool (size: 1 @1044 -> variable(bool))
.field f32Ceq: bool (size: 1 @1048 -> variable(bool))
.field f32Cne: bool (size: 1 @1052 -> variable(bool))
.field f32Clt: bool (size: 1 @1056 -> variable(bool))
.field f32Cle: bool (size: 1 @1060 -> variable(bool))
.field f32Cgt: bool (size: 1 @1064 -> variable(bool))
.field f32Cge: bool (size: 1 @1068 -> variable(bool))
.field f64A: float64 (size: 8 @1076 -> variable(f64))
.field f64B: float64 (size: 8 @1084 -> variable(f64))
.field f64Pls: float64 (size: 8 @1092 -> variable(f64))
.field f64Neg: float64 (size: 8 @1100 -> variable(f64))
.field f64Add: float64 (size: 8 @1108 -> variable(f64))
.field f64Sub: float64 (size: 8 @1116 -> variable(f64))
.field f64Mul: float64 (size: 8 @1124 -> variable(f64))
.field f64Div: float64 (size: 8 @1132 -> variable(f64))
.field f64Mod: float64 (size: 8 @1140 -> variable(f64))
.field f64Not: bool (size: 1 @1144 -> variable(bool))
.field f64Ceq: bool (size: 1 @1148 -> variable(bool))
.field f64Cne: bool (size: 1 @1152 -> variable(bool))
.field f64Clt: bool (size: 1 @1156 -> variable(bool))
.field f64Cle: bool (size: 1 @1160 -> variable(bool))
.field f64Cgt: bool (size: 1 @1164 -> variable(bool))
.field f64Cge: bool (size: 1 @1168 -> variable(bool))
.field t: int32 (size: 4 @1172 -> variable(i32))
.field arrFixedNoInit: int64[7] (size: 56 @1228 -> variable(val))
.field arrSliceNoInit: int64[] (size: 8 @1236 -> variable(arr))
.field arrPtrNoInit: int64[*] (size: 4 @1240 -> variable(ref))
.field arrSliceInitNull: int64[] (size: 8 @1248 -> variable(arr))
.field arrPtrInitNull: int64[*] (size: 4 @1252 -> variable(ref))
.field arrSliceInitFixed: int64[] (size: 8 @1260 -> variable(arr))
.field arrPtrInitFixed: int64[*] (size: 4 @1264 -> variable(ref))
.field arrSliceInitSlice: int64[] (size: 8 @1272 -> variable(arr))
.field arrPtrInitSlice: int64[*] (size: 4 @1276 -> variable(ref))
.field arrPtrInitPtr: int64[*] (size: 4 @1280 -> variable(ref))
.field arrSliceInitString: char[] (size: 8 @1288 -> variable(arr))
.field arrPtrInitString: char[*] (size: 4 @1292 -> variable(ref))
.field value: int64 (size: 8 @1300 -> variable(i64))
.field valueRef: int64 (size: 4 @1304 -> variable(ref))
.field valuePtr: pointer (size: 4 @1308 -> variable(ref))
.field valueVar: variant (size: 8 @1316 -> variable(var))
.field copyVal: int64 (size: 8 @1324 -> variable(i64))
.field copyRef: int64 (size: 4 @1328 -> variable(ref))
.field copyPtr: pointer (size: 4 @1332 -> variable(ref))
.field copyVar: variant (size: 8 @1340 -> variable(var))
.field fromRef: int64 (size: 8 @1348 -> variable(i64))
.field fromPtr: int64 (size: 4 @1352 -> variable(ref))
.field fromVar: int64 (size: 4 @1356 -> variable(ref))
.field nullRef: int64 (size: 4 @1360 -> variable(ref))
.field nullPtr: pointer (size: 4 @1364 -> variable(ref))
.field nullVar: variant (size: 8 @1372 -> variable(var))
.field typePtr: pointer (size: 4 @1376 -> variable(ref))
.field typeVar: variant (size: 8 @1384 -> variable(var))
.field ptrVoid: pointer (size: 4 @1388 -> variable(ref))
.field ptrBool: pointer (size: 4 @1392 -> variable(ref))
.field ptrChar: pointer (size: 4 @1396 -> variable(ref))
.field ptrInt8: pointer (size: 4 @1400 -> variable(ref))
.field ptrInt16: pointer (size: 4 @1404 -> variable(ref))
.field ptrInt32: pointer (size: 4 @1408 -> variable(ref))
.field ptrInt64: pointer (size: 4 @1412 -> variable(ref))
.field ptrUint8: pointer (size: 4 @1416 -> variable(ref))
.field ptrUint16: pointer (size: 4 @1420 -> variable(ref))
.field ptrUint32: pointer (size: 4 @1424 -> variable(ref))
.field ptrUint64: pointer (size: 4 @1428 -> variable(ref))
.field ptrFloat32: pointer (size: 4 @1432 -> variable(ref))
.field ptrFloat64: pointer (size: 4 @1436 -> variable(ref))
.field ptrTypename: pointer (size: 4 @1440 -> variable(ref))
.field ptrFunction: pointer (size: 4 @1444 -> variable(ref))
.field ptrPointer: pointer (size: 4 @1448 -> variable(ref))
.field ptrVariant: pointer (size: 4 @1452 -> variable(ref))
.field ptrObject: pointer (size: 4 @1456 -> variable(ref))
.field varVoid: variant (size: 8 @1464 -> variable(var))
.field varBool: variant (size: 8 @1472 -> variable(var))
.field varChar: variant (size: 8 @1480 -> variable(var))
.field varInt8: variant (size: 8 @1488 -> variable(var))
.field varInt16: variant (size: 8 @1496 -> variable(var))
.field varInt32: variant (size: 8 @1504 -> variable(var))
.field varInt64: variant (size: 8 @1512 -> variable(var))
.field varUint8: variant (size: 8 @1520 -> variable(var))
.field varUint16: variant (size: 8 @1528 -> variable(var))
.field varUint32: variant (size: 8 @1536 -> variable(var))
.field varUint64: variant (size: 8 @1544 -> variable(var))
.field varFloat32: variant (size: 8 @1552 -> variable(var))
.field varFloat64: variant (size: 8 @1560 -> variable(var))
.field varTypename: variant (size: 8 @1568 -> variable(var))
.field varFunction: variant (size: 8 @1576 -> variable(var))
.field varPointer: variant (size: 8 @1584 -> variable(var))
.field varVariant: variant (size: 8 @1592 -> variable(var))
.field varObject: variant (size: 8 @1600 -> variable(var))
.field copyPtrFloat64: variant (size: 8 @1608 -> variable(var))
.field copyVarFloat64: pointer (size: 4 @1612 -> variable(ref))
.field localNoInit: int64 (size: 8 @1620 -> variable(i64))
.field globalNoInit: int64 (size: 8 @116240 -> static variable(i64))
.field localInitValue: int64 (size: 8 @1628 -> variable(i64))
.field globalInitValue: int64 (size: 8 @116248 -> static variable(i64))
.field localInitLocal: int64 (size: 8 @1636 -> variable(i64))
.field globalInitLocal: int64 (size: 8 @116256 -> static variable(i64))
.field localInitGlobal: int64 (size: 8 @1644 -> variable(i64))
.field globalInitGlobal: int64 (size: 8 @116264 -> static variable(i64))
.field pi64: float64 (size: 8 @1652 -> variable(f64))
.field e64: float64 (size: 8 @1660 -> variable(f64))
.field pi32: float32 (size: 4 @1664 -> variable(f32))
.field e32: float32 (size: 4 @1668 -> variable(f32))
.field rgb888: function (size: 0 @0 -> inline)
.field rgb565: function (size: 0 @0 -> inline)
.field r_comp: int32 (size: 4 @1672 -> variable(i32))
.field g_comp: int32 (size: 4 @1676 -> variable(i32))
.field b_comp: int32 (size: 4 @1680 -> variable(i32))
.field r5g6b5: int32 (size: 4 @1684 -> variable(i32))
.field r8g8b8: int32 (size: 4 @1688 -> variable(i32))
.field zextR5: int32 (size: 4 @1692 -> variable(i32))
.field zextG6: int32 (size: 4 @1696 -> variable(i32))
.field zextB5: int32 (size: 4 @1700 -> variable(i32))
.field sextR5: int32 (size: 4 @1704 -> variable(i32))
.field sextG6: int32 (size: 4 @1708 -> variable(i32))
.field sextB5: int32 (size: 4 @1712 -> variable(i32))
.field zextR8: int32 (size: 4 @1716 -> variable(i32))
.field zextG8: int32 (size: 4 @1720 -> variable(i32))
.field zextB8: int32 (size: 4 @1724 -> variable(i32))
.field sextR8: int32 (size: 4 @1728 -> variable(i32))
.field sextG8: int32 (size: 4 @1732 -> variable(i32))
.field sextB8: int32 (size: 4 @1736 -> variable(i32))
.field sinF64: float64 (size: 8 @1744 -> variable(f64))
.field cosF64: float64 (size: 8 @1752 -> variable(f64))
.field tanF64: float64 (size: 8 @1760 -> variable(f64))
.field logF64: float64 (size: 8 @1768 -> variable(f64))
.field expF64: float64 (size: 8 @1776 -> variable(f64))
.field powF64: float64 (size: 8 @1784 -> variable(f64))
.field sqrtF64: float64 (size: 8 @1792 -> variable(f64))
.field atanF64: float64 (size: 8 @1800 -> variable(f64))
.field sinF32: float32 (size: 4 @1804 -> variable(f32))
.field cosF32: float32 (size: 4 @1808 -> variable(f32))
.field tanF32: float32 (size: 4 @1812 -> variable(f32))
.field logF32: float32 (size: 4 @1816 -> variable(f32))
.field expF32: float32 (size: 4 @1820 -> variable(f32))
.field powF32: float32 (size: 4 @1824 -> variable(f32))
.field sqrtF32: float32 (size: 4 @1828 -> variable(f32))
.field atanF32: float32 (size: 4 @1832 -> variable(f32))
.field free: function (size: 0 @0 -> inline)
.field malloc: function (size: 0 @0 -> inline)
.field p1: pointer (size: 4 @1836 -> variable(ref))
.field p2: pointer (size: 4 @1840 -> variable(ref))
.field p3: pointer (size: 4 @1844 -> variable(ref))
.field p4: pointer (size: 4 @1848 -> variable(ref))
.field val1: int64 (size: 8 @1856 -> variable(i64))
.field val2: int64 (size: 8 @1864 -> variable(i64))
.field .main: function (size: 5069 @116272 -> static function)
.param .result: void (@+0->variable)
.value: {
	{
		integer: typename := int64;
		static const xrgb: struct {
			b: uint8;
			g: uint8;
			r: uint8;
			x: uint8;
		};
		static const color: struct {
			rgb: xrgb;
			col: int32;
		};
		static const type: struct {
			intVariable: int32;
			objReference: type;
			funReference(x: int32, y: int32): int32;
		};
		zero(a: int32, b: int32): int32 := 0;
		first(a: int32, b: int32): int32 := a;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		min(a: int32, b: int32, c: int32): int32 := min(min(a, b), c);
		ma: int32 := 3;
		mb: int32 := 6;
		mc: int32 := 9;
		min2var: int32 := min(ma, mb);
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddi32: int32 := emit(add.i32, int32(emitA), emitB);
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !chrB;
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !i8B;
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !u8B;
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !i16B;
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !u16B;
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !i32B;
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !u32B;
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !i64B;
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !u64B;
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !f32B;
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !f64B;
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		static if (0 == 0) {
			raise(1, '0 == 0', null, 1);
		}
		static if (0 != 0) {
			raise(1, '0 != 0', null, 2);
		}
		static if (0 == 0) {
			raise(1, '0 == 0', null, 3);
		}
		else {
			raise(1, '0 != 0', null, 4);
		}
		static if (0 != 0) {
			raise(1, '0 != 0', null, 5);
		}
		else {
			raise(1, '0 == 0', null, 6);
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(1, 't == 0', variant(&t), 7);
			}
			if (t != 0) {
				raise(1, 't != 0', variant(&t), 8);
			}
			if (t != 0) {
				raise(1, 't != 0', variant(&t), 9);
			}
			else {
				raise(1, 't == 0', variant(&t), 10);
			}
			if (t != 0) {
				raise(1, 't != 0', variant(&t), 11);
			}
			else {
				raise(1, 't == 0', variant(&t), 12);
			}
		}
		static if (!true) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrSliceNoInit: int64[];
		arrPtrNoInit: int64[*];
		arrSliceInitNull: int64[] := null;
		arrPtrInitNull: int64[*] := null;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrPtrInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrPtrInitSlice: int64[*] := arrSliceInitFixed;
		arrPtrInitPtr: int64[*] := arrPtrInitFixed;
		arrSliceInitString: char[] := 'string';
		arrPtrInitString: char[*] := 'string';
		static if (!true) {
			integer: typename := int32;
		}
		value: int64 := 33;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		copyVal: int64 := value;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static if (!true) {
			integer: typename := int32;
		}
		localNoInit: int64;
		static globalNoInit: int64;
		localInitValue: int64 := 42;
		static globalInitValue: int64 := 1024;
		localInitLocal: int64 := localInitValue;
		static globalInitLocal: int64 := localInitValue;
		localInitGlobal: int64 := globalInitValue;
		static globalInitGlobal: int64 := globalInitValue;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zextR5: int32 := uint32.zxt(r5g6b5, 11, 5);
		zextG6: int32 := uint32.zxt(r5g6b5, 5, 6);
		zextB5: int32 := uint32.zxt(r5g6b5, 0, 5);
		sextR5: int32 := uint32.sxt(r5g6b5, 11, 5);
		sextG6: int32 := uint32.sxt(r5g6b5, 5, 6);
		sextB5: int32 := uint32.sxt(r5g6b5, 0, 5);
		zextR8: int32 := uint32.zxt(r8g8b8, 16, 8);
		zextG8: int32 := uint32.zxt(r8g8b8, 8, 8);
		zextB8: int32 := uint32.zxt(r8g8b8, 0, 8);
		sextR8: int32 := uint32.sxt(r8g8b8, 16, 8);
		sextG8: int32 := uint32.sxt(r8g8b8, 8, 8);
		sextB8: int32 := uint32.sxt(r8g8b8, 0, 8);
		sinF64: float64 := float64.sin(pi64 / (2));
		cosF64: float64 := float64.cos(pi64 / (2));
		tanF64: float64 := float64.tan(pi64 / (4));
		logF64: float64 := float64.log(e64 * e64 * e64);
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(pi64 * pi64, 0.500000);
		sqrtF64: float64 := float64.sqrt(pi64 * pi64);
		atanF64: float64 := float64.atan2(pi64, 1.000000);
		sinF32: float32 := float32.sin(pi32 / (2));
		cosF32: float32 := float32.cos(pi32 / (2));
		tanF32: float32 := float32.tan(pi32 / (4));
		logF32: float32 := float32.log(e32 * e32 * e32);
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(pi32 * pi32, 0.500000);
		sqrtF32: float32 := float32.sqrt(pi32 * pi32);
		atanF32: float32 := float32.atan2(pi32, 1.000000);
		free(data: pointer): pointer := memmgr(data, 0);
		malloc(size: int32): pointer := memmgr(null, size);
		p1: pointer := malloc(1024);
		p2: pointer := memmgr(null, 80);
		p3: pointer := memmgr(null, 160);
		p4: pointer := memmgr(null, 820);
		memset(p1, 0, 1024);
		memcpy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		raise(1, 'val1', variant(&val1), 0);
		raise(1, 'val2', variant(&val2), 0);
		memcpy(pointer(&val2), pointer(&val1), 8);
		memset(pointer(&val1), 0, 8);
		raise(1, 'val1', variant(&val1), 0);
		raise(1, 'val2', variant(&val2), 0);
	}
}
.instructions: [5069 bytes @.01c630]
	extras/Tests/lang.inline.ci:17: (10 bytes): ma: int32 := 3
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	extras/Tests/lang.inline.ci:18: (10 bytes): mb: int32 := 6
	1c 06 00 00 00 00 00 00 00 load.c64 6
	6a                         i64.2i32
	extras/Tests/lang.inline.ci:19: (10 bytes): mc: int32 := 9
	1c 09 00 00 00 00 00 00 00 load.c64 9
	6a                         i64.2i32
	extras/Tests/lang.inline.ci:23: (29 bytes): min2var: int32 := min(ma, mb)
	11 08 00 00                load.sp(+8)
	22                         load.m32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	58                         clt.i32
	06 0d 00 00                jz +13
	11 08 00 00                load.sp(+8)
	22                         load.m32
	04 09 00 00                jmp +9
	11 04 00 00                load.sp(+4)
	22                         load.m32
	extras/Tests/lang.useEmit.ci:3: (1 bytes): emitldz32: int32 := emit(load.z32)
	18                         load.z32
	extras/Tests/lang.useEmit.ci:4: (1 bytes): emitldz64: int64 := emit(load.z64)
	19                         load.z64
	extras/Tests/lang.useEmit.ci:7: (10 bytes): emitA: int32 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	6a                         i64.2i32
	extras/Tests/lang.useEmit.ci:8: (10 bytes): emitB: int32 := 96
	1c 60 00 00 00 00 00 00 00 load.c64 96
	6a                         i64.2i32
	extras/Tests/lang.useEmit.ci:10: (11 bytes): emitAddi32: int32 := emit(add.i32, int32(emitA), emitB)
	11 00 00 00                load.sp(+0)
	22                         load.m32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	51                         add.i32
	extras/Tests/lang.useOperator.ci:5: (10 bytes): shift: int32 := 2
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	extras/Tests/lang.useOperator.ci:7: (10 bytes): boolA: bool := true
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6c                         i64.2bool
	extras/Tests/lang.useOperator.ci:8: (11 bytes): boolB: bool := !false
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6c                         i64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	11 04 00 00                load.sp(+4)
	20                         load.m8
	11 04 00 00                load.sp(+4)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	11 08 00 00                load.sp(+8)
	20                         load.m8
	11 08 00 00                load.sp(+8)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:30: (10 bytes): chrA: char := 'a'
	1c 61 00 00 00 00 00 00 00 load.c64 97
	6a                         i64.2i32
	extras/Tests/lang.useOperator.ci:31: (10 bytes): chrB: char := 'b'
	1c 62 00 00 00 00 00 00 00 load.c64 98
	6a                         i64.2i32
	extras/Tests/lang.useOperator.ci:32: (6 bytes): chrPls: char := +chrB
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	34                         div.u32
	extras/Tests/lang.useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:43: (11 bytes): chrShl: char := (chrA) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	11 68 00 00                load.sp(+104)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:44: (11 bytes): chrShr: char := (chrA) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	11 6c 00 00                load.sp(+108)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:45: (7 bytes): chrNot: bool := !chrB
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:53: (10 bytes): i8A: int8 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:54: (10 bytes): i8B: int8 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:55: (6 bytes): i8Pls: int8 := +i8B
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	54                         div.i32
	extras/Tests/lang.useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:66: (11 bytes): i8Shl: int8 := (i8A) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	11 c0 00 00                load.sp(+192)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:67: (11 bytes): i8Shr: int8 := (i8A) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	11 c4 00 00                load.sp(+196)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:68: (7 bytes): i8Not: bool := !i8B
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:76: (10 bytes): u8A: uint8 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:77: (10 bytes): u8B: uint8 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:78: (6 bytes): u8Pls: uint8 := +u8B
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	34                         div.u32
	extras/Tests/lang.useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:89: (11 bytes): u8Shl: uint8 := (u8A) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	11 18 01 00                load.sp(+280)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:90: (11 bytes): u8Shr: uint8 := (u8A) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	11 1c 01 00                load.sp(+284)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:91: (7 bytes): u8Not: bool := !u8B
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:99: (10 bytes): i16A: int16 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:100: (10 bytes): i16B: int16 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:101: (6 bytes): i16Pls: int16 := +i16B
	11 00 00 00                load.sp(+0)
	21                         load.m16
	00                         nop
	extras/Tests/lang.useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	11 04 00 00                load.sp(+4)
	21                         load.m16
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	11 08 00 00                load.sp(+8)
	21                         load.m16
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	11 10 00 00                load.sp(+16)
	21                         load.m16
	11 10 00 00                load.sp(+16)
	21                         load.m16
	51                         add.i32
	extras/Tests/lang.useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	11 14 00 00                load.sp(+20)
	21                         load.m16
	11 14 00 00                load.sp(+20)
	21                         load.m16
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	11 18 00 00                load.sp(+24)
	21                         load.m16
	11 18 00 00                load.sp(+24)
	21                         load.m16
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	54                         div.i32
	extras/Tests/lang.useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	11 20 00 00                load.sp(+32)
	21                         load.m16
	11 20 00 00                load.sp(+32)
	21                         load.m16
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	11 24 00 00                load.sp(+36)
	21                         load.m16
	11 24 00 00                load.sp(+36)
	21                         load.m16
	31                         and.b32
	extras/Tests/lang.useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	11 28 00 00                load.sp(+40)
	21                         load.m16
	11 28 00 00                load.sp(+40)
	21                         load.m16
	32                         or.b32
	extras/Tests/lang.useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:112: (11 bytes): i16Shl: int16 := (i16A) << shift
	11 30 00 00                load.sp(+48)
	21                         load.m16
	11 70 01 00                load.sp(+368)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:113: (11 bytes): i16Shr: int16 := (i16A) >> shift
	11 34 00 00                load.sp(+52)
	21                         load.m16
	11 74 01 00                load.sp(+372)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:114: (7 bytes): i16Not: bool := !i16B
	11 34 00 00                load.sp(+52)
	21                         load.m16
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	11 40 00 00                load.sp(+64)
	21                         load.m16
	11 40 00 00                load.sp(+64)
	21                         load.m16
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	11 44 00 00                load.sp(+68)
	21                         load.m16
	11 44 00 00                load.sp(+68)
	21                         load.m16
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	11 48 00 00                load.sp(+72)
	21                         load.m16
	11 48 00 00                load.sp(+72)
	21                         load.m16
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	11 50 00 00                load.sp(+80)
	21                         load.m16
	11 50 00 00                load.sp(+80)
	21                         load.m16
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:122: (10 bytes): u16A: uint16 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:123: (10 bytes): u16B: uint16 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:124: (6 bytes): u16Pls: uint16 := +u16B
	11 00 00 00                load.sp(+0)
	21                         load.m16
	00                         nop
	extras/Tests/lang.useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	11 04 00 00                load.sp(+4)
	21                         load.m16
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	11 08 00 00                load.sp(+8)
	21                         load.m16
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	11 10 00 00                load.sp(+16)
	21                         load.m16
	11 10 00 00                load.sp(+16)
	21                         load.m16
	51                         add.i32
	extras/Tests/lang.useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	11 14 00 00                load.sp(+20)
	21                         load.m16
	11 14 00 00                load.sp(+20)
	21                         load.m16
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	11 18 00 00                load.sp(+24)
	21                         load.m16
	11 18 00 00                load.sp(+24)
	21                         load.m16
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	34                         div.u32
	extras/Tests/lang.useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	11 20 00 00                load.sp(+32)
	21                         load.m16
	11 20 00 00                load.sp(+32)
	21                         load.m16
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	11 24 00 00                load.sp(+36)
	21                         load.m16
	11 24 00 00                load.sp(+36)
	21                         load.m16
	31                         and.b32
	extras/Tests/lang.useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	11 28 00 00                load.sp(+40)
	21                         load.m16
	11 28 00 00                load.sp(+40)
	21                         load.m16
	32                         or.b32
	extras/Tests/lang.useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:135: (11 bytes): u16Shl: uint16 := (u16A) << shift
	11 30 00 00                load.sp(+48)
	21                         load.m16
	11 c8 01 00                load.sp(+456)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:136: (11 bytes): u16Shr: uint16 := (u16A) >> shift
	11 34 00 00                load.sp(+52)
	21                         load.m16
	11 cc 01 00                load.sp(+460)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:137: (7 bytes): u16Not: bool := !u16B
	11 34 00 00                load.sp(+52)
	21                         load.m16
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	11 40 00 00                load.sp(+64)
	21                         load.m16
	11 40 00 00                load.sp(+64)
	21                         load.m16
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	11 44 00 00                load.sp(+68)
	21                         load.m16
	11 44 00 00                load.sp(+68)
	21                         load.m16
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	11 48 00 00                load.sp(+72)
	21                         load.m16
	11 48 00 00                load.sp(+72)
	21                         load.m16
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	11 50 00 00                load.sp(+80)
	21                         load.m16
	11 50 00 00                load.sp(+80)
	21                         load.m16
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:145: (10 bytes): i32A: int32 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:146: (10 bytes): i32B: int32 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:147: (6 bytes): i32Pls: int32 := +i32B
	11 00 00 00                load.sp(+0)
	22                         load.m32
	00                         nop
	extras/Tests/lang.useOperator.ci:148: (6 bytes): i32Neg: int32 := -i32B
	11 04 00 00                load.sp(+4)
	22                         load.m32
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:149: (6 bytes): i32Cmt: int32 := ~i32B
	11 08 00 00                load.sp(+8)
	22                         load.m32
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:150: (11 bytes): i32Add: int32 := i32A + i32B
	11 10 00 00                load.sp(+16)
	22                         load.m32
	11 10 00 00                load.sp(+16)
	22                         load.m32
	51                         add.i32
	extras/Tests/lang.useOperator.ci:151: (11 bytes): i32Sub: int32 := i32A - i32B
	11 14 00 00                load.sp(+20)
	22                         load.m32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:152: (11 bytes): i32Mul: int32 := i32A * i32B
	11 18 00 00                load.sp(+24)
	22                         load.m32
	11 18 00 00                load.sp(+24)
	22                         load.m32
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:153: (11 bytes): i32Div: int32 := i32A / i32B
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	54                         div.i32
	extras/Tests/lang.useOperator.ci:154: (11 bytes): i32Mod: int32 := i32A % i32B
	11 20 00 00                load.sp(+32)
	22                         load.m32
	11 20 00 00                load.sp(+32)
	22                         load.m32
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:155: (11 bytes): i32And: int32 := i32A & i32B
	11 24 00 00                load.sp(+36)
	22                         load.m32
	11 24 00 00                load.sp(+36)
	22                         load.m32
	31                         and.b32
	extras/Tests/lang.useOperator.ci:156: (11 bytes): i32Ior: int32 := i32A | i32B
	11 28 00 00                load.sp(+40)
	22                         load.m32
	11 28 00 00                load.sp(+40)
	22                         load.m32
	32                         or.b32
	extras/Tests/lang.useOperator.ci:157: (11 bytes): i32Xor: int32 := i32A ^ i32B
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:158: (11 bytes): i32Shl: int32 := i32A << shift
	11 30 00 00                load.sp(+48)
	22                         load.m32
	11 20 02 00                load.sp(+544)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:159: (11 bytes): i32Shr: int32 := i32A >> shift
	11 34 00 00                load.sp(+52)
	22                         load.m32
	11 24 02 00                load.sp(+548)
	22                         load.m32
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:160: (7 bytes): i32Not: bool := !i32B
	11 34 00 00                load.sp(+52)
	22                         load.m32
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:161: (11 bytes): i32Ceq: bool := i32A == i32B
	11 3c 00 00                load.sp(+60)
	22                         load.m32
	11 3c 00 00                load.sp(+60)
	22                         load.m32
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:162: (12 bytes): i32Cne: bool := i32A != i32B
	11 40 00 00                load.sp(+64)
	22                         load.m32
	11 40 00 00                load.sp(+64)
	22                         load.m32
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:163: (11 bytes): i32Clt: bool := i32A < i32B
	11 44 00 00                load.sp(+68)
	22                         load.m32
	11 44 00 00                load.sp(+68)
	22                         load.m32
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:164: (12 bytes): i32Cle: bool := i32A <= i32B
	11 48 00 00                load.sp(+72)
	22                         load.m32
	11 48 00 00                load.sp(+72)
	22                         load.m32
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:165: (11 bytes): i32Cgt: bool := i32A > i32B
	11 4c 00 00                load.sp(+76)
	22                         load.m32
	11 4c 00 00                load.sp(+76)
	22                         load.m32
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:166: (12 bytes): i32Cge: bool := i32A >= i32B
	11 50 00 00                load.sp(+80)
	22                         load.m32
	11 50 00 00                load.sp(+80)
	22                         load.m32
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:168: (10 bytes): u32A: uint32 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:169: (10 bytes): u32B: uint32 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8a                         f64.2i32
	extras/Tests/lang.useOperator.ci:170: (6 bytes): u32Pls: uint32 := +u32B
	11 00 00 00                load.sp(+0)
	22                         load.m32
	00                         nop
	extras/Tests/lang.useOperator.ci:171: (6 bytes): u32Neg: uint32 := -u32B
	11 04 00 00                load.sp(+4)
	22                         load.m32
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:172: (6 bytes): u32Cmt: uint32 := ~u32B
	11 08 00 00                load.sp(+8)
	22                         load.m32
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:173: (11 bytes): u32Add: uint32 := u32A + u32B
	11 10 00 00                load.sp(+16)
	22                         load.m32
	11 10 00 00                load.sp(+16)
	22                         load.m32
	51                         add.i32
	extras/Tests/lang.useOperator.ci:174: (11 bytes): u32Sub: uint32 := u32A - u32B
	11 14 00 00                load.sp(+20)
	22                         load.m32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:175: (11 bytes): u32Mul: uint32 := u32A * u32B
	11 18 00 00                load.sp(+24)
	22                         load.m32
	11 18 00 00                load.sp(+24)
	22                         load.m32
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:176: (11 bytes): u32Div: uint32 := u32A / u32B
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	34                         div.u32
	extras/Tests/lang.useOperator.ci:177: (11 bytes): u32Mod: uint32 := u32A % u32B
	11 20 00 00                load.sp(+32)
	22                         load.m32
	11 20 00 00                load.sp(+32)
	22                         load.m32
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:178: (11 bytes): u32And: uint32 := u32A & u32B
	11 24 00 00                load.sp(+36)
	22                         load.m32
	11 24 00 00                load.sp(+36)
	22                         load.m32
	31                         and.b32
	extras/Tests/lang.useOperator.ci:179: (11 bytes): u32Ior: uint32 := u32A | u32B
	11 28 00 00                load.sp(+40)
	22                         load.m32
	11 28 00 00                load.sp(+40)
	22                         load.m32
	32                         or.b32
	extras/Tests/lang.useOperator.ci:180: (11 bytes): u32Xor: uint32 := u32A ^ u32B
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:181: (11 bytes): u32Shl: uint32 := u32A << shift
	11 30 00 00                load.sp(+48)
	22                         load.m32
	11 78 02 00                load.sp(+632)
	22                         load.m32
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:182: (11 bytes): u32Shr: uint32 := u32A >> shift
	11 34 00 00                load.sp(+52)
	22                         load.m32
	11 7c 02 00                load.sp(+636)
	22                         load.m32
	3b                         shr.b32
	extras/Tests/lang.useOperator.ci:183: (7 bytes): u32Not: bool := !u32B
	11 34 00 00                load.sp(+52)
	22                         load.m32
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:184: (11 bytes): u32Ceq: bool := u32A == u32B
	11 3c 00 00                load.sp(+60)
	22                         load.m32
	11 3c 00 00                load.sp(+60)
	22                         load.m32
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:185: (12 bytes): u32Cne: bool := u32A != u32B
	11 40 00 00                load.sp(+64)
	22                         load.m32
	11 40 00 00                load.sp(+64)
	22                         load.m32
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:186: (11 bytes): u32Clt: bool := u32A < u32B
	11 44 00 00                load.sp(+68)
	22                         load.m32
	11 44 00 00                load.sp(+68)
	22                         load.m32
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:187: (12 bytes): u32Cle: bool := u32A <= u32B
	11 48 00 00                load.sp(+72)
	22                         load.m32
	11 48 00 00                load.sp(+72)
	22                         load.m32
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:188: (11 bytes): u32Cgt: bool := u32A > u32B
	11 4c 00 00                load.sp(+76)
	22                         load.m32
	11 4c 00 00                load.sp(+76)
	22                         load.m32
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:189: (12 bytes): u32Cge: bool := u32A >= u32B
	11 50 00 00                load.sp(+80)
	22                         load.m32
	11 50 00 00                load.sp(+80)
	22                         load.m32
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:191: (10 bytes): i64A: int64 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8c                         f64.2i64
	extras/Tests/lang.useOperator.ci:192: (10 bytes): i64B: int64 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8c                         f64.2i64
	extras/Tests/lang.useOperator.ci:193: (6 bytes): i64Pls: int64 := +i64B
	11 00 00 00                load.sp(+0)
	23                         load.m64
	00                         nop
	extras/Tests/lang.useOperator.ci:194: (6 bytes): i64Neg: int64 := -i64B
	11 08 00 00                load.sp(+8)
	23                         load.m64
	60                         neg.i64
	extras/Tests/lang.useOperator.ci:195: (6 bytes): i64Cmt: int64 := ~i64B
	11 10 00 00                load.sp(+16)
	23                         load.m64
	40                         cmt.b64
	extras/Tests/lang.useOperator.ci:196: (11 bytes): i64Add: int64 := i64A + i64B
	11 20 00 00                load.sp(+32)
	23                         load.m64
	11 20 00 00                load.sp(+32)
	23                         load.m64
	61                         add.i64
	extras/Tests/lang.useOperator.ci:197: (11 bytes): i64Sub: int64 := i64A - i64B
	11 28 00 00                load.sp(+40)
	23                         load.m64
	11 28 00 00                load.sp(+40)
	23                         load.m64
	62                         sub.i64
	extras/Tests/lang.useOperator.ci:198: (11 bytes): i64Mul: int64 := i64A * i64B
	11 30 00 00                load.sp(+48)
	23                         load.m64
	11 30 00 00                load.sp(+48)
	23                         load.m64
	63                         mul.i64
	extras/Tests/lang.useOperator.ci:199: (11 bytes): i64Div: int64 := i64A / i64B
	11 38 00 00                load.sp(+56)
	23                         load.m64
	11 38 00 00                load.sp(+56)
	23                         load.m64
	64                         div.i64
	extras/Tests/lang.useOperator.ci:200: (11 bytes): i64Mod: int64 := i64A % i64B
	11 40 00 00                load.sp(+64)
	23                         load.m64
	11 40 00 00                load.sp(+64)
	23                         load.m64
	65                         mod.i64
	extras/Tests/lang.useOperator.ci:201: (11 bytes): i64And: int64 := i64A & i64B
	11 48 00 00                load.sp(+72)
	23                         load.m64
	11 48 00 00                load.sp(+72)
	23                         load.m64
	41                         and.b64
	extras/Tests/lang.useOperator.ci:202: (11 bytes): i64Ior: int64 := i64A | i64B
	11 50 00 00                load.sp(+80)
	23                         load.m64
	11 50 00 00                load.sp(+80)
	23                         load.m64
	42                         or.b64
	extras/Tests/lang.useOperator.ci:203: (11 bytes): i64Xor: int64 := i64A ^ i64B
	11 58 00 00                load.sp(+88)
	23                         load.m64
	11 58 00 00                load.sp(+88)
	23                         load.m64
	46                         xor.b64
	extras/Tests/lang.useOperator.ci:204: (11 bytes): i64Shl: int64 := i64A << shift
	11 60 00 00                load.sp(+96)
	23                         load.m64
	11 08 03 00                load.sp(+776)
	22                         load.m32
	4a                         shl.b64
	extras/Tests/lang.useOperator.ci:205: (11 bytes): i64Shr: int64 := i64A >> shift
	11 68 00 00                load.sp(+104)
	23                         load.m64
	11 10 03 00                load.sp(+784)
	22                         load.m32
	4c                         sar.b64
	extras/Tests/lang.useOperator.ci:206: (7 bytes): i64Not: bool := !i64B
	11 68 00 00                load.sp(+104)
	23                         load.m64
	6c                         i64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:207: (11 bytes): i64Ceq: bool := i64A == i64B
	11 74 00 00                load.sp(+116)
	23                         load.m64
	11 74 00 00                load.sp(+116)
	23                         load.m64
	67                         ceq.i64
	extras/Tests/lang.useOperator.ci:208: (12 bytes): i64Cne: bool := i64A != i64B
	11 78 00 00                load.sp(+120)
	23                         load.m64
	11 78 00 00                load.sp(+120)
	23                         load.m64
	67                         ceq.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:209: (11 bytes): i64Clt: bool := i64A < i64B
	11 7c 00 00                load.sp(+124)
	23                         load.m64
	11 7c 00 00                load.sp(+124)
	23                         load.m64
	68                         clt.i64
	extras/Tests/lang.useOperator.ci:210: (12 bytes): i64Cle: bool := i64A <= i64B
	11 80 00 00                load.sp(+128)
	23                         load.m64
	11 80 00 00                load.sp(+128)
	23                         load.m64
	69                         cgt.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:211: (11 bytes): i64Cgt: bool := i64A > i64B
	11 84 00 00                load.sp(+132)
	23                         load.m64
	11 84 00 00                load.sp(+132)
	23                         load.m64
	69                         cgt.i64
	extras/Tests/lang.useOperator.ci:212: (12 bytes): i64Cge: bool := i64A >= i64B
	11 88 00 00                load.sp(+136)
	23                         load.m64
	11 88 00 00                load.sp(+136)
	23                         load.m64
	68                         clt.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:214: (10 bytes): u64A: uint64 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8c                         f64.2i64
	extras/Tests/lang.useOperator.ci:215: (10 bytes): u64B: uint64 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8c                         f64.2i64
	extras/Tests/lang.useOperator.ci:216: (6 bytes): u64Pls: uint64 := +u64B
	11 00 00 00                load.sp(+0)
	23                         load.m64
	00                         nop
	extras/Tests/lang.useOperator.ci:217: (6 bytes): u64Neg: uint64 := -u64B
	11 08 00 00                load.sp(+8)
	23                         load.m64
	60                         neg.i64
	extras/Tests/lang.useOperator.ci:218: (6 bytes): u64Cmt: uint64 := ~u64B
	11 10 00 00                load.sp(+16)
	23                         load.m64
	40                         cmt.b64
	extras/Tests/lang.useOperator.ci:219: (11 bytes): u64Add: uint64 := u64A + u64B
	11 20 00 00                load.sp(+32)
	23                         load.m64
	11 20 00 00                load.sp(+32)
	23                         load.m64
	61                         add.i64
	extras/Tests/lang.useOperator.ci:220: (11 bytes): u64Sub: uint64 := u64A - u64B
	11 28 00 00                load.sp(+40)
	23                         load.m64
	11 28 00 00                load.sp(+40)
	23                         load.m64
	62                         sub.i64
	extras/Tests/lang.useOperator.ci:221: (11 bytes): u64Mul: uint64 := u64A * u64B
	11 30 00 00                load.sp(+48)
	23                         load.m64
	11 30 00 00                load.sp(+48)
	23                         load.m64
	43                         mul.u64
	extras/Tests/lang.useOperator.ci:222: (11 bytes): u64Div: uint64 := u64A / u64B
	11 38 00 00                load.sp(+56)
	23                         load.m64
	11 38 00 00                load.sp(+56)
	23                         load.m64
	44                         div.u64
	extras/Tests/lang.useOperator.ci:223: (11 bytes): u64Mod: uint64 := u64A % u64B
	11 40 00 00                load.sp(+64)
	23                         load.m64
	11 40 00 00                load.sp(+64)
	23                         load.m64
	45                         mod.u64
	extras/Tests/lang.useOperator.ci:224: (11 bytes): u64And: uint64 := u64A & u64B
	11 48 00 00                load.sp(+72)
	23                         load.m64
	11 48 00 00                load.sp(+72)
	23                         load.m64
	41                         and.b64
	extras/Tests/lang.useOperator.ci:225: (11 bytes): u64Ior: uint64 := u64A | u64B
	11 50 00 00                load.sp(+80)
	23                         load.m64
	11 50 00 00                load.sp(+80)
	23                         load.m64
	42                         or.b64
	extras/Tests/lang.useOperator.ci:226: (11 bytes): u64Xor: uint64 := u64A ^ u64B
	11 58 00 00                load.sp(+88)
	23                         load.m64
	11 58 00 00                load.sp(+88)
	23                         load.m64
	46                         xor.b64
	extras/Tests/lang.useOperator.ci:227: (11 bytes): u64Shl: uint64 := u64A << shift
	11 60 00 00                load.sp(+96)
	23                         load.m64
	11 9c 03 00                load.sp(+924)
	22                         load.m32
	4a                         shl.b64
	extras/Tests/lang.useOperator.ci:228: (11 bytes): u64Shr: uint64 := u64A >> shift
	11 68 00 00                load.sp(+104)
	23                         load.m64
	11 a4 03 00                load.sp(+932)
	22                         load.m32
	4b                         shr.b64
	extras/Tests/lang.useOperator.ci:229: (7 bytes): u64Not: bool := !u64B
	11 68 00 00                load.sp(+104)
	23                         load.m64
	6c                         i64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:230: (11 bytes): u64Ceq: bool := u64A == u64B
	11 74 00 00                load.sp(+116)
	23                         load.m64
	11 74 00 00                load.sp(+116)
	23                         load.m64
	67                         ceq.i64
	extras/Tests/lang.useOperator.ci:231: (12 bytes): u64Cne: bool := u64A != u64B
	11 78 00 00                load.sp(+120)
	23                         load.m64
	11 78 00 00                load.sp(+120)
	23                         load.m64
	67                         ceq.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:232: (11 bytes): u64Clt: bool := u64A < u64B
	11 7c 00 00                load.sp(+124)
	23                         load.m64
	11 7c 00 00                load.sp(+124)
	23                         load.m64
	48                         clt.u64
	extras/Tests/lang.useOperator.ci:233: (12 bytes): u64Cle: bool := u64A <= u64B
	11 80 00 00                load.sp(+128)
	23                         load.m64
	11 80 00 00                load.sp(+128)
	23                         load.m64
	49                         cgt.u64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:234: (11 bytes): u64Cgt: bool := u64A > u64B
	11 84 00 00                load.sp(+132)
	23                         load.m64
	11 84 00 00                load.sp(+132)
	23                         load.m64
	49                         cgt.u64
	extras/Tests/lang.useOperator.ci:235: (12 bytes): u64Cge: bool := u64A >= u64B
	11 88 00 00                load.sp(+136)
	23                         load.m64
	11 88 00 00                load.sp(+136)
	23                         load.m64
	48                         clt.u64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:237: (10 bytes): f32A: float32 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	8b                         f64.2f32
	extras/Tests/lang.useOperator.ci:238: (10 bytes): f32B: float32 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	8b                         f64.2f32
	extras/Tests/lang.useOperator.ci:239: (6 bytes): f32Pls: float32 := +f32B
	11 00 00 00                load.sp(+0)
	22                         load.m32
	00                         nop
	extras/Tests/lang.useOperator.ci:240: (6 bytes): f32Neg: float32 := -f32B
	11 04 00 00                load.sp(+4)
	22                         load.m32
	70                         neg.f32
	extras/Tests/lang.useOperator.ci:242: (11 bytes): f32Add: float32 := f32A + f32B
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	71                         add.f32
	extras/Tests/lang.useOperator.ci:243: (11 bytes): f32Sub: float32 := f32A - f32B
	11 10 00 00                load.sp(+16)
	22                         load.m32
	11 10 00 00                load.sp(+16)
	22                         load.m32
	72                         sub.f32
	extras/Tests/lang.useOperator.ci:244: (11 bytes): f32Mul: float32 := f32A * f32B
	11 14 00 00                load.sp(+20)
	22                         load.m32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	73                         mul.f32
	extras/Tests/lang.useOperator.ci:245: (11 bytes): f32Div: float32 := f32A / f32B
	11 18 00 00                load.sp(+24)
	22                         load.m32
	11 18 00 00                load.sp(+24)
	22                         load.m32
	74                         div.f32
	extras/Tests/lang.useOperator.ci:246: (11 bytes): f32Mod: float32 := f32A % f32B
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	75                         mod.f32
	extras/Tests/lang.useOperator.ci:252: (7 bytes): f32Not: bool := !f32B
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	7b                         f32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:253: (11 bytes): f32Ceq: bool := f32A == f32B
	11 24 00 00                load.sp(+36)
	22                         load.m32
	11 24 00 00                load.sp(+36)
	22                         load.m32
	77                         ceq.f32
	extras/Tests/lang.useOperator.ci:254: (12 bytes): f32Cne: bool := f32A != f32B
	11 28 00 00                load.sp(+40)
	22                         load.m32
	11 28 00 00                load.sp(+40)
	22                         load.m32
	77                         ceq.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:255: (11 bytes): f32Clt: bool := f32A < f32B
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	78                         clt.f32
	extras/Tests/lang.useOperator.ci:256: (12 bytes): f32Cle: bool := f32A <= f32B
	11 30 00 00                load.sp(+48)
	22                         load.m32
	11 30 00 00                load.sp(+48)
	22                         load.m32
	79                         cgt.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:257: (11 bytes): f32Cgt: bool := f32A > f32B
	11 34 00 00                load.sp(+52)
	22                         load.m32
	11 34 00 00                load.sp(+52)
	22                         load.m32
	79                         cgt.f32
	extras/Tests/lang.useOperator.ci:258: (12 bytes): f32Cge: bool := f32A >= f32B
	11 38 00 00                load.sp(+56)
	22                         load.m32
	11 38 00 00                load.sp(+56)
	22                         load.m32
	78                         clt.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:260: (9 bytes): f64A: float64 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	extras/Tests/lang.useOperator.ci:261: (9 bytes): f64B: float64 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	extras/Tests/lang.useOperator.ci:262: (6 bytes): f64Pls: float64 := +f64B
	11 00 00 00                load.sp(+0)
	23                         load.m64
	00                         nop
	extras/Tests/lang.useOperator.ci:263: (6 bytes): f64Neg: float64 := -f64B
	11 08 00 00                load.sp(+8)
	23                         load.m64
	80                         neg.f64
	extras/Tests/lang.useOperator.ci:265: (11 bytes): f64Add: float64 := f64A + f64B
	11 18 00 00                load.sp(+24)
	23                         load.m64
	11 18 00 00                load.sp(+24)
	23                         load.m64
	81                         add.f64
	extras/Tests/lang.useOperator.ci:266: (11 bytes): f64Sub: float64 := f64A - f64B
	11 20 00 00                load.sp(+32)
	23                         load.m64
	11 20 00 00                load.sp(+32)
	23                         load.m64
	82                         sub.f64
	extras/Tests/lang.useOperator.ci:267: (11 bytes): f64Mul: float64 := f64A * f64B
	11 28 00 00                load.sp(+40)
	23                         load.m64
	11 28 00 00                load.sp(+40)
	23                         load.m64
	83                         mul.f64
	extras/Tests/lang.useOperator.ci:268: (11 bytes): f64Div: float64 := f64A / f64B
	11 30 00 00                load.sp(+48)
	23                         load.m64
	11 30 00 00                load.sp(+48)
	23                         load.m64
	84                         div.f64
	extras/Tests/lang.useOperator.ci:269: (11 bytes): f64Mod: float64 := f64A % f64B
	11 38 00 00                load.sp(+56)
	23                         load.m64
	11 38 00 00                load.sp(+56)
	23                         load.m64
	85                         mod.f64
	extras/Tests/lang.useOperator.ci:275: (7 bytes): f64Not: bool := !f64B
	11 38 00 00                load.sp(+56)
	23                         load.m64
	8d                         f64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:276: (11 bytes): f64Ceq: bool := f64A == f64B
	11 44 00 00                load.sp(+68)
	23                         load.m64
	11 44 00 00                load.sp(+68)
	23                         load.m64
	87                         ceq.f64
	extras/Tests/lang.useOperator.ci:277: (12 bytes): f64Cne: bool := f64A != f64B
	11 48 00 00                load.sp(+72)
	23                         load.m64
	11 48 00 00                load.sp(+72)
	23                         load.m64
	87                         ceq.f64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:278: (11 bytes): f64Clt: bool := f64A < f64B
	11 4c 00 00                load.sp(+76)
	23                         load.m64
	11 4c 00 00                load.sp(+76)
	23                         load.m64
	88                         clt.f64
	extras/Tests/lang.useOperator.ci:279: (12 bytes): f64Cle: bool := f64A <= f64B
	11 50 00 00                load.sp(+80)
	23                         load.m64
	11 50 00 00                load.sp(+80)
	23                         load.m64
	89                         cgt.f64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:280: (11 bytes): f64Cgt: bool := f64A > f64B
	11 54 00 00                load.sp(+84)
	23                         load.m64
	11 54 00 00                load.sp(+84)
	23                         load.m64
	89                         cgt.f64
	extras/Tests/lang.useOperator.ci:281: (12 bytes): f64Cge: bool := f64A >= f64B
	11 58 00 00                load.sp(+88)
	23                         load.m64
	11 58 00 00                load.sp(+88)
	23                         load.m64
	88                         clt.f64
	0a                         not.b32
	extras/Tests/lang.statementIf.ci:4: (49 bytes): raise(1, '0 == 0', null, 1);
	1b 04 00 00 00             load.c32 4
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	1f 00 6c 01 00             load.ref .016c00 ;"0 == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:12: (49 bytes): raise(1, '0 == 0', null, 3);
	1b 0c 00 00 00             load.c32 12
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	1f 00 6c 01 00             load.ref .016c00 ;"0 == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:22: (49 bytes): raise(1, '0 == 0', null, 6);
	1b 16 00 00 00             load.c32 22
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 06 00 00 00 00 00 00 00 load.c64 6
	6a                         i64.2i32
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	1f 00 6c 01 00             load.ref .016c00 ;"0 == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:26: (10 bytes): t: int32 := 0
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	extras/Tests/lang.statementIf.ci:28: (72 bytes): if (t == 0)
	11 00 00 00                load.sp(+0)
	22                         load.m32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	57                         ceq.i32
	06 38 00 00                jz +56
	extras/Tests/lang.statementIf.ci:29: (48 bytes): raise(1, 't == 0', variant(&t), 7);
	1b 1d 00 00 00             load.c32 29
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 07 00 00 00 00 00 00 00 load.c64 7
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 10 6c 01 00             load.ref .016c10 ;"t == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:32: (73 bytes): if (t != 0)
	11 00 00 00                load.sp(+0)
	22                         load.m32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	57                         ceq.i32
	0a                         not.b32
	06 38 00 00                jz +56
	extras/Tests/lang.statementIf.ci:33: (48 bytes): raise(1, 't != 0', variant(&t), 8);
	1b 21 00 00 00             load.c32 33
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 17 6c 01 00             load.ref .016c17 ;"t != 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:36: (129 bytes): if (t != 0)
	11 00 00 00                load.sp(+0)
	22                         load.m32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	57                         ceq.i32
	0a                         not.b32
	06 3c 00 00                jz +60
	extras/Tests/lang.statementIf.ci:37: (48 bytes): raise(1, 't != 0', variant(&t), 9);
	1b 25 00 00 00             load.c32 37
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 09 00 00 00 00 00 00 00 load.c64 9
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 17 6c 01 00             load.ref .016c17 ;"t != 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	04 38 00 00                jmp +56
	extras/Tests/lang.statementIf.ci:40: (48 bytes): raise(1, 't == 0', variant(&t), 10);
	1b 28 00 00 00             load.c32 40
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 0a 00 00 00 00 00 00 00 load.c64 10
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 10 6c 01 00             load.ref .016c10 ;"t == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.statementIf.ci:43: (129 bytes): if (t != 0)
	11 00 00 00                load.sp(+0)
	22                         load.m32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	57                         ceq.i32
	0a                         not.b32
	06 3c 00 00                jz +60
	extras/Tests/lang.statementIf.ci:44: (48 bytes): raise(1, 't != 0', variant(&t), 11);
	1b 2c 00 00 00             load.c32 44
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 0b 00 00 00 00 00 00 00 load.c64 11
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 17 6c 01 00             load.ref .016c17 ;"t != 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	04 38 00 00                jmp +56
	extras/Tests/lang.statementIf.ci:47: (48 bytes): raise(1, 't == 0', variant(&t), 12);
	1b 2f 00 00 00             load.c32 47
	1f 66 c5 00 00             load.ref .00c566 ;"extras/Tests/lang.statementIf.ci"
	1c 0c 00 00 00 00 00 00 00 load.c64 12
	6a                         i64.2i32
	1f 70 03 00 00             load.ref .000370 ;int32
	11 10 00 00                load.sp(+16)
	1f 10 6c 01 00             load.ref .016c10 ;"t == 0"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	10 00 00 00                inc.sp(+0)
	extras/Tests/lang.varInitArray.ci:8: (4 bytes): arrFixedNoInit: int64[7]
	10 38 00 00                inc.sp(+56)
	extras/Tests/lang.varInitArray.ci:9: (4 bytes): arrSliceNoInit: int64[]
	10 08 00 00                inc.sp(+8)
	extras/Tests/lang.varInitArray.ci:10: (4 bytes): arrPtrNoInit: int64[*]
	10 04 00 00                inc.sp(+4)
	extras/Tests/lang.varInitArray.ci:13: (10 bytes): arrSliceInitNull: int64[] := null
	1b 00 00 00 00             load.c32 0
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	extras/Tests/lang.varInitArray.ci:14: (5 bytes): arrPtrInitNull: int64[*] := null
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	extras/Tests/lang.varInitArray.ci:17: (14 bytes): arrSliceInitFixed: int64[] := arrFixedNoInit
	1c 07 00 00 00 00 00 00 00 load.c64 7
	6a                         i64.2i32
	11 1c 00 00                load.sp(+28)
	extras/Tests/lang.varInitArray.ci:18: (4 bytes): arrPtrInitFixed: int64[*] := arrFixedNoInit
	11 20 00 00                load.sp(+32)
	extras/Tests/lang.varInitArray.ci:21: (5 bytes): arrSliceInitSlice: int64[] := arrSliceInitFixed
	11 04 00 00                load.sp(+4)
	23                         load.m64
	extras/Tests/lang.varInitArray.ci:22: (4 bytes): arrPtrInitSlice: int64[*] := arrSliceInitFixed
	11 0c 00 00                load.sp(+12)
	extras/Tests/lang.varInitArray.ci:26: (5 bytes): arrPtrInitPtr: int64[*] := arrPtrInitFixed
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	extras/Tests/lang.varInitArray.ci:37: (10 bytes): arrSliceInitString: char[] := 'string'
	1b 06 00 00 00             load.c32 6
	1f 58 6d 01 00             load.ref .016d58 ;"string"
	extras/Tests/lang.varInitArray.ci:38: (5 bytes): arrPtrInitString: char[*] := 'string'
	1f 58 6d 01 00             load.ref .016d58 ;"string"
	extras/Tests/lang.varInitByRef.ci:7: (9 bytes): value: int64 := 33
	1c 21 00 00 00 00 00 00 00 load.c64 33
	extras/Tests/lang.varInitByRef.ci:8: (4 bytes): valueRef: int64 := value
	11 00 00 00                load.sp(+0)
	extras/Tests/lang.varInitByRef.ci:9: (4 bytes): valuePtr: pointer := value
	11 04 00 00                load.sp(+4)
	extras/Tests/lang.varInitByRef.ci:10: (9 bytes): valueVar: variant := value
	1f 00 04 00 00             load.ref .000400 ;int64
	11 0c 00 00                load.sp(+12)
	extras/Tests/lang.varInitByRef.ci:12: (5 bytes): copyVal: int64 := value
	11 10 00 00                load.sp(+16)
	23                         load.m64
	extras/Tests/lang.varInitByRef.ci:13: (5 bytes): copyRef: int64 := valueRef
	11 14 00 00                load.sp(+20)
	22                         load.m32
	extras/Tests/lang.varInitByRef.ci:14: (5 bytes): copyPtr: pointer := valuePtr
	11 14 00 00                load.sp(+20)
	22                         load.m32
	extras/Tests/lang.varInitByRef.ci:15: (5 bytes): copyVar: variant := valueVar
	11 10 00 00                load.sp(+16)
	23                         load.m64
	extras/Tests/lang.varInitByRef.ci:16: (6 bytes): fromRef: int64 := valueRef
	11 24 00 00                load.sp(+36)
	22                         load.m32
	23                         load.m64
	extras/Tests/lang.varInitByRef.ci:17: (5 bytes): fromPtr: int64 := valuePtr
	11 28 00 00                load.sp(+40)
	22                         load.m32
	extras/Tests/lang.varInitByRef.ci:18: (5 bytes): fromVar: int64 := valueVar
	11 24 00 00                load.sp(+36)
	22                         load.m32
	extras/Tests/lang.varInitByRef.ci:20: (5 bytes): nullRef: int64 := null
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	extras/Tests/lang.varInitByRef.ci:21: (5 bytes): nullPtr: pointer := null
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	extras/Tests/lang.varInitByRef.ci:22: (10 bytes): nullVar: variant := null
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	extras/Tests/lang.varInitByRef.ci:23: (5 bytes): typePtr: pointer := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:24: (10 bytes): typeVar: variant := int64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:27: (5 bytes): ptrVoid: pointer := void
	1f a0 00 00 00             load.ref .0000a0 ;void
	extras/Tests/lang.varInitByRef.ci:28: (5 bytes): ptrBool: pointer := bool
	1f 30 01 00 00             load.ref .000130 ;bool
	extras/Tests/lang.varInitByRef.ci:29: (5 bytes): ptrChar: pointer := char
	1f c0 01 00 00             load.ref .0001c0 ;char
	extras/Tests/lang.varInitByRef.ci:30: (5 bytes): ptrInt8: pointer := int8
	1f 50 02 00 00             load.ref .000250 ;int8
	extras/Tests/lang.varInitByRef.ci:31: (5 bytes): ptrInt16: pointer := int16
	1f e0 02 00 00             load.ref .0002e0 ;int16
	extras/Tests/lang.varInitByRef.ci:32: (5 bytes): ptrInt32: pointer := int32
	1f 70 03 00 00             load.ref .000370 ;int32
	extras/Tests/lang.varInitByRef.ci:33: (5 bytes): ptrInt64: pointer := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:34: (5 bytes): ptrUint8: pointer := uint8
	1f 90 04 00 00             load.ref .000490 ;uint8
	extras/Tests/lang.varInitByRef.ci:35: (5 bytes): ptrUint16: pointer := uint16
	1f 20 05 00 00             load.ref .000520 ;uint16
	extras/Tests/lang.varInitByRef.ci:36: (5 bytes): ptrUint32: pointer := uint32
	1f b0 05 00 00             load.ref .0005b0 ;uint32
	extras/Tests/lang.varInitByRef.ci:37: (5 bytes): ptrUint64: pointer := uint64
	1f 40 06 00 00             load.ref .000640 ;uint64
	extras/Tests/lang.varInitByRef.ci:38: (5 bytes): ptrFloat32: pointer := float32
	1f d0 06 00 00             load.ref .0006d0 ;float32
	extras/Tests/lang.varInitByRef.ci:39: (5 bytes): ptrFloat64: pointer := float64
	1f 60 07 00 00             load.ref .000760 ;float64
	extras/Tests/lang.varInitByRef.ci:40: (5 bytes): ptrTypename: pointer := typename
	1f 08 00 00 00             load.ref .000008 ;typename
	extras/Tests/lang.varInitByRef.ci:41: (5 bytes): ptrFunction: pointer := function
	1f 10 09 00 00             load.ref .000910 ;function
	extras/Tests/lang.varInitByRef.ci:42: (5 bytes): ptrPointer: pointer := pointer
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	extras/Tests/lang.varInitByRef.ci:43: (5 bytes): ptrVariant: pointer := variant
	1f 80 08 00 00             load.ref .000880 ;variant
	extras/Tests/lang.varInitByRef.ci:44: (5 bytes): ptrObject: pointer := object
	1f a8 09 00 00             load.ref .0009a8 ;object
	extras/Tests/lang.varInitByRef.ci:47: (10 bytes): varVoid: variant := void
	1f 08 00 00 00             load.ref .000008 ;typename
	1f a0 00 00 00             load.ref .0000a0 ;void
	extras/Tests/lang.varInitByRef.ci:48: (10 bytes): varBool: variant := bool
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 30 01 00 00             load.ref .000130 ;bool
	extras/Tests/lang.varInitByRef.ci:49: (10 bytes): varChar: variant := char
	1f 08 00 00 00             load.ref .000008 ;typename
	1f c0 01 00 00             load.ref .0001c0 ;char
	extras/Tests/lang.varInitByRef.ci:50: (10 bytes): varInt8: variant := int8
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 50 02 00 00             load.ref .000250 ;int8
	extras/Tests/lang.varInitByRef.ci:51: (10 bytes): varInt16: variant := int16
	1f 08 00 00 00             load.ref .000008 ;typename
	1f e0 02 00 00             load.ref .0002e0 ;int16
	extras/Tests/lang.varInitByRef.ci:52: (10 bytes): varInt32: variant := int32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 70 03 00 00             load.ref .000370 ;int32
	extras/Tests/lang.varInitByRef.ci:53: (10 bytes): varInt64: variant := int64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:54: (10 bytes): varUint8: variant := uint8
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 90 04 00 00             load.ref .000490 ;uint8
	extras/Tests/lang.varInitByRef.ci:55: (10 bytes): varUint16: variant := uint16
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 20 05 00 00             load.ref .000520 ;uint16
	extras/Tests/lang.varInitByRef.ci:56: (10 bytes): varUint32: variant := uint32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f b0 05 00 00             load.ref .0005b0 ;uint32
	extras/Tests/lang.varInitByRef.ci:57: (10 bytes): varUint64: variant := uint64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 40 06 00 00             load.ref .000640 ;uint64
	extras/Tests/lang.varInitByRef.ci:58: (10 bytes): varFloat32: variant := float32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f d0 06 00 00             load.ref .0006d0 ;float32
	extras/Tests/lang.varInitByRef.ci:59: (10 bytes): varFloat64: variant := float64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 60 07 00 00             load.ref .000760 ;float64
	extras/Tests/lang.varInitByRef.ci:60: (10 bytes): varTypename: variant := typename
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 08 00 00 00             load.ref .000008 ;typename
	extras/Tests/lang.varInitByRef.ci:61: (10 bytes): varFunction: variant := function
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 10 09 00 00             load.ref .000910 ;function
	extras/Tests/lang.varInitByRef.ci:62: (10 bytes): varPointer: variant := pointer
	1f 08 00 00 00             load.ref .000008 ;typename
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	extras/Tests/lang.varInitByRef.ci:63: (10 bytes): varVariant: variant := variant
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 80 08 00 00             load.ref .000880 ;variant
	extras/Tests/lang.varInitByRef.ci:64: (10 bytes): varObject: variant := object
	1f 08 00 00 00             load.ref .000008 ;typename
	1f a8 09 00 00             load.ref .0009a8 ;object
	extras/Tests/lang.varInitByRef.ci:67: (10 bytes): copyPtrFloat64: variant := ptrFloat64
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	11 a8 00 00                load.sp(+168)
	22                         load.m32
	extras/Tests/lang.varInitByRef.ci:70: (5 bytes): copyVarFloat64: pointer := varFloat64
	11 30 00 00                load.sp(+48)
	22                         load.m32
	extras/Tests/lang.varInitStatic.ci:7: (4 bytes): localNoInit: int64
	10 08 00 00                inc.sp(+8)
	extras/Tests/lang.varInitStatic.ci:9: (9 bytes): localInitValue: int64 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/lang.varInitStatic.ci:10: (15 bytes): static globalInitValue: int64 := 1024
	1c 00 04 00 00 00 00 00 00 load.c64 1024
	1f 18 c6 01 00             load.ref .01c618 ;globalInitValue: int64
	28                         store.m64
	extras/Tests/lang.varInitStatic.ci:11: (5 bytes): localInitLocal: int64 := localInitValue
	11 00 00 00                load.sp(+0)
	23                         load.m64
	extras/Tests/lang.varInitStatic.ci:12: (11 bytes): static globalInitLocal: int64 := localInitValue
	11 08 00 00                load.sp(+8)
	23                         load.m64
	1f 20 c6 01 00             load.ref .01c620 ;globalInitLocal: int64
	28                         store.m64
	extras/Tests/lang.varInitStatic.ci:13: (6 bytes): localInitGlobal: int64 := globalInitValue
	1f 18 c6 01 00             load.ref .01c618 ;globalInitValue: int64
	23                         load.m64
	extras/Tests/lang.varInitStatic.ci:14: (12 bytes): static globalInitGlobal: int64 := globalInitValue
	1f 18 c6 01 00             load.ref .01c618 ;globalInitValue: int64
	23                         load.m64
	1f 28 c6 01 00             load.ref .01c628 ;globalInitGlobal: int64
	28                         store.m64
	extras/Tests/stdc.nfcNumber.ci:3: (9 bytes): pi64: float64 := 3.141593
	1e 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	extras/Tests/stdc.nfcNumber.ci:4: (9 bytes): e64: float64 := 2.718282
	1e 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	extras/Tests/stdc.nfcNumber.ci:6: (6 bytes): pi32: float32 := pi64
	11 08 00 00                load.sp(+8)
	23                         load.m64
	8b                         f64.2f32
	extras/Tests/stdc.nfcNumber.ci:7: (6 bytes): e32: float32 := e64
	11 04 00 00                load.sp(+4)
	23                         load.m64
	8b                         f64.2f32
	extras/Tests/stdc.nfcNumber.ci:14: (21 bytes): r_comp: int32 := 14 << 3
	1c 0e 00 00 00 00 00 00 00 load.c64 14
	6a                         i64.2i32
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	3a                         shl.b32
	extras/Tests/stdc.nfcNumber.ci:15: (21 bytes): g_comp: int32 := 63 << 2
	1c 3f 00 00 00 00 00 00 00 load.c64 63
	6a                         i64.2i32
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	3a                         shl.b32
	extras/Tests/stdc.nfcNumber.ci:16: (21 bytes): b_comp: int32 := 31 << 3
	1c 1f 00 00 00 00 00 00 00 load.c64 31
	6a                         i64.2i32
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	3a                         shl.b32
	extras/Tests/stdc.nfcNumber.ci:18: (83 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	11 08 00 00                load.sp(+8)
	22                         load.m32
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	3a                         shl.b32
	1c 00 f8 00 00 00 00 00 00 load.c64 63488
	6a                         i64.2i32
	31                         and.b32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	3a                         shl.b32
	1c e0 07 00 00 00 00 00 00 load.c64 2016
	6a                         i64.2i32
	31                         and.b32
	32                         or.b32
	11 04 00 00                load.sp(+4)
	22                         load.m32
	1c 03 00 00 00 00 00 00 00 load.c64 3
	6a                         i64.2i32
	3c                         sar.b32
	1c 1f 00 00 00 00 00 00 00 load.c64 31
	6a                         i64.2i32
	31                         and.b32
	32                         or.b32
	extras/Tests/stdc.nfcNumber.ci:19: (72 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	1c 10 00 00 00 00 00 00 00 load.c64 16
	6a                         i64.2i32
	3a                         shl.b32
	1c 00 00 ff 00 00 00 00 00 load.c64 16711680
	6a                         i64.2i32
	31                         and.b32
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	3a                         shl.b32
	1c 00 ff 00 00 00 00 00 00 load.c64 65280
	6a                         i64.2i32
	31                         and.b32
	32                         or.b32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	1c ff 00 00 00 00 00 00 00 load.c64 255
	6a                         i64.2i32
	31                         and.b32
	32                         or.b32
	extras/Tests/stdc.nfcNumber.ci:21: (29 bytes): zextR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	1c 0b 00 00 00 00 00 00 00 load.c64 11
	6a                         i64.2i32
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:22: (29 bytes): zextG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	1c 06 00 00 00 00 00 00 00 load.c64 6
	6a                         i64.2i32
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	11 10 00 00                load.sp(+16)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:23: (29 bytes): zextB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:25: (29 bytes): sextR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	1c 0b 00 00 00 00 00 00 00 load.c64 11
	6a                         i64.2i32
	11 18 00 00                load.sp(+24)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:26: (29 bytes): sextG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	1c 06 00 00 00 00 00 00 00 load.c64 6
	6a                         i64.2i32
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	11 1c 00 00                load.sp(+28)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:27: (29 bytes): sextB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	1c 05 00 00 00 00 00 00 00 load.c64 5
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 20 00 00                load.sp(+32)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:29: (29 bytes): zextR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 10 00 00 00 00 00 00 00 load.c64 16
	6a                         i64.2i32
	11 20 00 00                load.sp(+32)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:30: (29 bytes): zextG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	11 24 00 00                load.sp(+36)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:31: (29 bytes): zextB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 28 00 00                load.sp(+40)
	22                         load.m32
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:33: (29 bytes): sextR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 10 00 00 00 00 00 00 00 load.c64 16
	6a                         i64.2i32
	11 2c 00 00                load.sp(+44)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:34: (29 bytes): sextG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	11 30 00 00                load.sp(+48)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:35: (29 bytes): sextB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 34 00 00                load.sp(+52)
	22                         load.m32
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:37: (21 bytes): sinF64: float64 := float64.sin(pi64 / (2))
	11 54 00 00                load.sp(+84)
	23                         load.m64
	// TODO: to many conversions: i64.2i32; i32.2f64
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	5d                         i32.2f64
	84                         div.f64
	01 1d 00 00                nfc(29) ;float64.sin(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:38: (21 bytes): cosF64: float64 := float64.cos(pi64 / (2))
	11 5c 00 00                load.sp(+92)
	23                         load.m64
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	5d                         i32.2f64
	84                         div.f64
	01 1e 00 00                nfc(30) ;float64.cos(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:39: (21 bytes): tanF64: float64 := float64.tan(pi64 / (4))
	11 64 00 00                load.sp(+100)
	23                         load.m64
	1c 04 00 00 00 00 00 00 00 load.c64 4
	6a                         i64.2i32
	5d                         i32.2f64
	84                         div.f64
	01 1f 00 00                nfc(31) ;float64.tan(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:40: (21 bytes): logF64: float64 := float64.log(e64 * e64 * e64)
	11 64 00 00                load.sp(+100)
	23                         load.m64
	11 6c 00 00                load.sp(+108)
	23                         load.m64
	83                         mul.f64
	11 6c 00 00                load.sp(+108)
	23                         load.m64
	83                         mul.f64
	01 20 00 00                nfc(32) ;float64.log(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:41: (13 bytes): expF64: float64 := float64.exp(1.000000)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	01 21 00 00                nfc(33) ;float64.exp(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:42: (24 bytes): powF64: float64 := float64.pow(pi64 * pi64, 0.500000)
	1e 00 00 00 00 00 00 e0 3f load.f64 0.500000
	11 84 00 00                load.sp(+132)
	23                         load.m64
	11 8c 00 00                load.sp(+140)
	23                         load.m64
	83                         mul.f64
	01 22 00 00                nfc(34) ;float64.pow(x: float64, y: float64): float64
	extras/Tests/stdc.nfcNumber.ci:43: (15 bytes): sqrtF64: float64 := float64.sqrt(pi64 * pi64)
	11 84 00 00                load.sp(+132)
	23                         load.m64
	11 8c 00 00                load.sp(+140)
	23                         load.m64
	83                         mul.f64
	01 23 00 00                nfc(35) ;float64.sqrt(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:44: (18 bytes): atanF64: float64 := float64.atan2(pi64, 1.000000)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	11 94 00 00                load.sp(+148)
	23                         load.m64
	01 24 00 00                nfc(36) ;float64.atan2(x: float64, y: float64): float64
	extras/Tests/stdc.nfcNumber.ci:46: (21 bytes): sinF32: float32 := float32.sin(pi32 / (2))
	11 88 00 00                load.sp(+136)
	22                         load.m32
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	5b                         i32.2f32
	74                         div.f32
	01 15 00 00                nfc(21) ;float32.sin(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:47: (21 bytes): cosF32: float32 := float32.cos(pi32 / (2))
	11 8c 00 00                load.sp(+140)
	22                         load.m32
	1c 02 00 00 00 00 00 00 00 load.c64 2
	6a                         i64.2i32
	5b                         i32.2f32
	74                         div.f32
	01 16 00 00                nfc(22) ;float32.cos(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:48: (21 bytes): tanF32: float32 := float32.tan(pi32 / (4))
	11 90 00 00                load.sp(+144)
	22                         load.m32
	1c 04 00 00 00 00 00 00 00 load.c64 4
	6a                         i64.2i32
	5b                         i32.2f32
	74                         div.f32
	01 17 00 00                nfc(23) ;float32.tan(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:49: (21 bytes): logF32: float32 := float32.log(e32 * e32 * e32)
	11 90 00 00                load.sp(+144)
	22                         load.m32
	11 94 00 00                load.sp(+148)
	22                         load.m32
	73                         mul.f32
	11 94 00 00                load.sp(+148)
	22                         load.m32
	73                         mul.f32
	01 18 00 00                nfc(24) ;float32.log(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:50: (14 bytes): expF32: float32 := float32.exp(1.000000)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	8b                         f64.2f32
	01 19 00 00                nfc(25) ;float32.exp(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:51: (25 bytes): powF32: float32 := float32.pow(pi32 * pi32, 0.500000)
	1e 00 00 00 00 00 00 e0 3f load.f64 0.500000
	8b                         f64.2f32
	11 a0 00 00                load.sp(+160)
	22                         load.m32
	11 a4 00 00                load.sp(+164)
	22                         load.m32
	73                         mul.f32
	01 1a 00 00                nfc(26) ;float32.pow(x: float32, y: float32): float32
	extras/Tests/stdc.nfcNumber.ci:52: (15 bytes): sqrtF32: float32 := float32.sqrt(pi32 * pi32)
	11 a0 00 00                load.sp(+160)
	22                         load.m32
	11 a4 00 00                load.sp(+164)
	22                         load.m32
	73                         mul.f32
	01 1b 00 00                nfc(27) ;float32.sqrt(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:53: (19 bytes): atanF32: float32 := float32.atan2(pi32, 1.000000)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	8b                         f64.2f32
	11 a8 00 00                load.sp(+168)
	22                         load.m32
	01 1c 00 00                nfc(28) ;float32.atan2(x: float32, y: float32): float32
	extras/Tests/stdc.nfcMemory.ci:6: (19 bytes): p1: pointer := malloc(1024)
	1c 00 04 00 00 00 00 00 00 load.c64 1024
	6a                         i64.2i32
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:7: (19 bytes): p2: pointer := memmgr(null, 80)
	1c 50 00 00 00 00 00 00 00 load.c64 80
	6a                         i64.2i32
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:8: (19 bytes): p3: pointer := memmgr(null, 160)
	1c a0 00 00 00 00 00 00 00 load.c64 160
	6a                         i64.2i32
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:9: (19 bytes): p4: pointer := memmgr(null, 820)
	1c 34 03 00 00 00 00 00 00 load.c64 820
	6a                         i64.2i32
	1f 00 00 00 00             load.ref .000000 ;null: pointer
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:12: (33 bytes): memset(p1, 0, 1024);
	1c 00 04 00 00 00 00 00 00 load.c64 1024
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	01 08 00 00                nfc(8) ;memset(dst: pointer, value: int32, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:13: (28 bytes): memcpy(p1, p3, 160);
	1c a0 00 00 00 00 00 00 00 load.c64 160
	6a                         i64.2i32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	11 14 00 00                load.sp(+20)
	22                         load.m32
	01 09 00 00                nfc(9) ;memcpy(dst: pointer, src: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:16: (23 bytes): free(p1);
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 10 00 00                load.sp(+16)
	22                         load.m32
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:17: (23 bytes): free(p2);
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 0c 00 00                load.sp(+12)
	22                         load.m32
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:18: (23 bytes): free(p3);
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 08 00 00                load.sp(+8)
	22                         load.m32
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:19: (23 bytes): free(p4);
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 04 00 00                load.sp(+4)
	22                         load.m32
	01 07 00 00                nfc(7) ;memmgr(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:22: (9 bytes): val1: int64 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/stdc.nfcMemory.ci:23: (9 bytes): val2: int64 := 96
	1c 60 00 00 00 00 00 00 00 load.c64 96
	extras/Tests/stdc.nfcMemory.ci:25: (48 bytes): raise(1, 'val1', variant(&val1), 0);
	1b 19 00 00 00             load.c32 25
	1f 0d c6 00 00             load.ref .00c60d ;"extras/Tests/stdc.nfcMemory.ci"
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	1f 00 04 00 00             load.ref .000400 ;int64
	11 18 00 00                load.sp(+24)
	1f 85 bc 01 00             load.ref .01bc85 ;"val1"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:26: (48 bytes): raise(1, 'val2', variant(&val2), 0);
	1b 1a 00 00 00             load.c32 26
	1f 0d c6 00 00             load.ref .00c60d ;"extras/Tests/stdc.nfcMemory.ci"
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	1f 00 04 00 00             load.ref .000400 ;int64
	11 10 00 00                load.sp(+16)
	1f 8a bc 01 00             load.ref .01bc8a ;"val2"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:28: (26 bytes): memcpy(pointer(&val2), pointer(&val1), 8);
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	11 0c 00 00                load.sp(+12)
	11 08 00 00                load.sp(+8)
	01 09 00 00                nfc(9) ;memcpy(dst: pointer, src: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:29: (32 bytes): memset(pointer(&val1), 0, 8);
	1c 08 00 00 00 00 00 00 00 load.c64 8
	6a                         i64.2i32
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	11 10 00 00                load.sp(+16)
	01 08 00 00                nfc(8) ;memset(dst: pointer, value: int32, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:31: (48 bytes): raise(1, 'val1', variant(&val1), 0);
	1b 1f 00 00 00             load.c32 31
	1f 0d c6 00 00             load.ref .00c60d ;"extras/Tests/stdc.nfcMemory.ci"
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	1f 00 04 00 00             load.ref .000400 ;int64
	11 18 00 00                load.sp(+24)
	1f 85 bc 01 00             load.ref .01bc85 ;"val1"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:32: (48 bytes): raise(1, 'val2', variant(&val2), 0);
	1b 20 00 00 00             load.c32 32
	1f 0d c6 00 00             load.ref .00c60d ;"extras/Tests/stdc.nfcMemory.ci"
	1c 00 00 00 00 00 00 00 00 load.c64 0
	6a                         i64.2i32
	1f 00 04 00 00             load.ref .000400 ;int64
	11 10 00 00                load.sp(+16)
	1f 8a bc 01 00             load.ref .01bc8a ;"val2"
	1c 01 00 00 00 00 00 00 00 load.c64 1
	6a                         i64.2i32
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	01 00 00 00                nfc(0) ;halt(): void
}

/*-- Globals:
extras/Tests/lang.inline.ci:17: ma: int32(3)
extras/Tests/lang.inline.ci:18: mb: int32(6)
extras/Tests/lang.inline.ci:19: mc: int32(9)
extras/Tests/lang.inline.ci:23: min2var: int32(3)
extras/Tests/lang.useEmit.ci:3: emitldz32: int32(0)
extras/Tests/lang.useEmit.ci:4: emitldz64: int64(0)
extras/Tests/lang.useEmit.ci:7: emitA: int32(42)
extras/Tests/lang.useEmit.ci:8: emitB: int32(96)
extras/Tests/lang.useEmit.ci:10: emitAddi32: int32(138)
extras/Tests/lang.useOperator.ci:5: shift: int32(2)
extras/Tests/lang.useOperator.ci:7: boolA: bool(1)
extras/Tests/lang.useOperator.ci:8: boolB: bool(1)
extras/Tests/lang.useOperator.ci:17: boolAnd: bool(1)
extras/Tests/lang.useOperator.ci:18: boolIor: bool(1)
extras/Tests/lang.useOperator.ci:19: boolXor: bool(0)
extras/Tests/lang.useOperator.ci:22: boolNot: bool(0)
extras/Tests/lang.useOperator.ci:23: boolCeq: bool(1)
extras/Tests/lang.useOperator.ci:24: boolCne: bool(0)
extras/Tests/lang.useOperator.ci:25: boolClt: bool(0)
extras/Tests/lang.useOperator.ci:26: boolCle: bool(1)
extras/Tests/lang.useOperator.ci:27: boolCgt: bool(0)
extras/Tests/lang.useOperator.ci:28: boolCge: bool(1)
extras/Tests/lang.useOperator.ci:30: chrA: char('a')
extras/Tests/lang.useOperator.ci:31: chrB: char('b')
extras/Tests/lang.useOperator.ci:32: chrPls: char('b')
extras/Tests/lang.useOperator.ci:33: chrNeg: char('�')
extras/Tests/lang.useOperator.ci:34: chrCmt: char('�')
extras/Tests/lang.useOperator.ci:35: chrAdd: char('�')
extras/Tests/lang.useOperator.ci:36: chrSub: char('�')
extras/Tests/lang.useOperator.ci:37: chrMul: char('"')
extras/Tests/lang.useOperator.ci:38: chrDiv: char('')
extras/Tests/lang.useOperator.ci:39: chrMod: char('a')
extras/Tests/lang.useOperator.ci:40: chrAnd: char('`')
extras/Tests/lang.useOperator.ci:41: chrIor: char('c')
extras/Tests/lang.useOperator.ci:42: chrXor: char('')
extras/Tests/lang.useOperator.ci:43: chrShl: char('�')
extras/Tests/lang.useOperator.ci:44: chrShr: char('')
extras/Tests/lang.useOperator.ci:45: chrNot: bool(0)
extras/Tests/lang.useOperator.ci:46: chrCeq: bool(0)
extras/Tests/lang.useOperator.ci:47: chrCne: bool(1)
extras/Tests/lang.useOperator.ci:48: chrClt: bool(1)
extras/Tests/lang.useOperator.ci:49: chrCle: bool(1)
extras/Tests/lang.useOperator.ci:50: chrCgt: bool(0)
extras/Tests/lang.useOperator.ci:51: chrCge: bool(0)
extras/Tests/lang.useOperator.ci:53: i8A: int8(96)
extras/Tests/lang.useOperator.ci:54: i8B: int8(42)
extras/Tests/lang.useOperator.ci:55: i8Pls: int8(42)
extras/Tests/lang.useOperator.ci:56: i8Neg: int8(-42)
extras/Tests/lang.useOperator.ci:57: i8Cmt: int8(-43)
extras/Tests/lang.useOperator.ci:58: i8Add: int8(-118)
extras/Tests/lang.useOperator.ci:59: i8Sub: int8(54)
extras/Tests/lang.useOperator.ci:60: i8Mul: int8(-64)
extras/Tests/lang.useOperator.ci:61: i8Div: int8(2)
extras/Tests/lang.useOperator.ci:62: i8Mod: int8(12)
extras/Tests/lang.useOperator.ci:63: i8And: int8(32)
extras/Tests/lang.useOperator.ci:64: i8Ior: int8(106)
extras/Tests/lang.useOperator.ci:65: i8Xor: int8(74)
extras/Tests/lang.useOperator.ci:66: i8Shl: int8(-128)
extras/Tests/lang.useOperator.ci:67: i8Shr: int8(24)
extras/Tests/lang.useOperator.ci:68: i8Not: bool(0)
extras/Tests/lang.useOperator.ci:69: i8Ceq: bool(0)
extras/Tests/lang.useOperator.ci:70: i8Cne: bool(1)
extras/Tests/lang.useOperator.ci:71: i8Clt: bool(0)
extras/Tests/lang.useOperator.ci:72: i8Cle: bool(0)
extras/Tests/lang.useOperator.ci:73: i8Cgt: bool(1)
extras/Tests/lang.useOperator.ci:74: i8Cge: bool(1)
extras/Tests/lang.useOperator.ci:76: u8A: uint8(96)
extras/Tests/lang.useOperator.ci:77: u8B: uint8(42)
extras/Tests/lang.useOperator.ci:78: u8Pls: uint8(42)
extras/Tests/lang.useOperator.ci:79: u8Neg: uint8(214)
extras/Tests/lang.useOperator.ci:80: u8Cmt: uint8(213)
extras/Tests/lang.useOperator.ci:81: u8Add: uint8(138)
extras/Tests/lang.useOperator.ci:82: u8Sub: uint8(54)
extras/Tests/lang.useOperator.ci:83: u8Mul: uint8(192)
extras/Tests/lang.useOperator.ci:84: u8Div: uint8(2)
extras/Tests/lang.useOperator.ci:85: u8Mod: uint8(12)
extras/Tests/lang.useOperator.ci:86: u8And: uint8(32)
extras/Tests/lang.useOperator.ci:87: u8Ior: uint8(106)
extras/Tests/lang.useOperator.ci:88: u8Xor: uint8(74)
extras/Tests/lang.useOperator.ci:89: u8Shl: uint8(128)
extras/Tests/lang.useOperator.ci:90: u8Shr: uint8(24)
extras/Tests/lang.useOperator.ci:91: u8Not: bool(0)
extras/Tests/lang.useOperator.ci:92: u8Ceq: bool(0)
extras/Tests/lang.useOperator.ci:93: u8Cne: bool(1)
extras/Tests/lang.useOperator.ci:94: u8Clt: bool(0)
extras/Tests/lang.useOperator.ci:95: u8Cle: bool(0)
extras/Tests/lang.useOperator.ci:96: u8Cgt: bool(1)
extras/Tests/lang.useOperator.ci:97: u8Cge: bool(1)
extras/Tests/lang.useOperator.ci:99: i16A: int16(96)
extras/Tests/lang.useOperator.ci:100: i16B: int16(42)
extras/Tests/lang.useOperator.ci:101: i16Pls: int16(42)
extras/Tests/lang.useOperator.ci:102: i16Neg: int16(-42)
extras/Tests/lang.useOperator.ci:103: i16Cmt: int16(-43)
extras/Tests/lang.useOperator.ci:104: i16Add: int16(138)
extras/Tests/lang.useOperator.ci:105: i16Sub: int16(54)
extras/Tests/lang.useOperator.ci:106: i16Mul: int16(4032)
extras/Tests/lang.useOperator.ci:107: i16Div: int16(2)
extras/Tests/lang.useOperator.ci:108: i16Mod: int16(12)
extras/Tests/lang.useOperator.ci:109: i16And: int16(32)
extras/Tests/lang.useOperator.ci:110: i16Ior: int16(106)
extras/Tests/lang.useOperator.ci:111: i16Xor: int16(74)
extras/Tests/lang.useOperator.ci:112: i16Shl: int16(384)
extras/Tests/lang.useOperator.ci:113: i16Shr: int16(24)
extras/Tests/lang.useOperator.ci:114: i16Not: bool(0)
extras/Tests/lang.useOperator.ci:115: i16Ceq: bool(0)
extras/Tests/lang.useOperator.ci:116: i16Cne: bool(1)
extras/Tests/lang.useOperator.ci:117: i16Clt: bool(0)
extras/Tests/lang.useOperator.ci:118: i16Cle: bool(0)
extras/Tests/lang.useOperator.ci:119: i16Cgt: bool(1)
extras/Tests/lang.useOperator.ci:120: i16Cge: bool(1)
extras/Tests/lang.useOperator.ci:122: u16A: uint16(96)
extras/Tests/lang.useOperator.ci:123: u16B: uint16(42)
extras/Tests/lang.useOperator.ci:124: u16Pls: uint16(42)
extras/Tests/lang.useOperator.ci:125: u16Neg: uint16(65494)
extras/Tests/lang.useOperator.ci:126: u16Cmt: uint16(65493)
extras/Tests/lang.useOperator.ci:127: u16Add: uint16(138)
extras/Tests/lang.useOperator.ci:128: u16Sub: uint16(54)
extras/Tests/lang.useOperator.ci:129: u16Mul: uint16(4032)
extras/Tests/lang.useOperator.ci:130: u16Div: uint16(2)
extras/Tests/lang.useOperator.ci:131: u16Mod: uint16(12)
extras/Tests/lang.useOperator.ci:132: u16And: uint16(32)
extras/Tests/lang.useOperator.ci:133: u16Ior: uint16(106)
extras/Tests/lang.useOperator.ci:134: u16Xor: uint16(74)
extras/Tests/lang.useOperator.ci:135: u16Shl: uint16(384)
extras/Tests/lang.useOperator.ci:136: u16Shr: uint16(24)
extras/Tests/lang.useOperator.ci:137: u16Not: bool(0)
extras/Tests/lang.useOperator.ci:138: u16Ceq: bool(0)
extras/Tests/lang.useOperator.ci:139: u16Cne: bool(1)
extras/Tests/lang.useOperator.ci:140: u16Clt: bool(0)
extras/Tests/lang.useOperator.ci:141: u16Cle: bool(0)
extras/Tests/lang.useOperator.ci:142: u16Cgt: bool(1)
extras/Tests/lang.useOperator.ci:143: u16Cge: bool(1)
extras/Tests/lang.useOperator.ci:145: i32A: int32(96)
extras/Tests/lang.useOperator.ci:146: i32B: int32(42)
extras/Tests/lang.useOperator.ci:147: i32Pls: int32(42)
extras/Tests/lang.useOperator.ci:148: i32Neg: int32(-42)
extras/Tests/lang.useOperator.ci:149: i32Cmt: int32(-43)
extras/Tests/lang.useOperator.ci:150: i32Add: int32(138)
extras/Tests/lang.useOperator.ci:151: i32Sub: int32(54)
extras/Tests/lang.useOperator.ci:152: i32Mul: int32(4032)
extras/Tests/lang.useOperator.ci:153: i32Div: int32(2)
extras/Tests/lang.useOperator.ci:154: i32Mod: int32(12)
extras/Tests/lang.useOperator.ci:155: i32And: int32(32)
extras/Tests/lang.useOperator.ci:156: i32Ior: int32(106)
extras/Tests/lang.useOperator.ci:157: i32Xor: int32(74)
extras/Tests/lang.useOperator.ci:158: i32Shl: int32(384)
extras/Tests/lang.useOperator.ci:159: i32Shr: int32(24)
extras/Tests/lang.useOperator.ci:160: i32Not: bool(0)
extras/Tests/lang.useOperator.ci:161: i32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:162: i32Cne: bool(1)
extras/Tests/lang.useOperator.ci:163: i32Clt: bool(0)
extras/Tests/lang.useOperator.ci:164: i32Cle: bool(0)
extras/Tests/lang.useOperator.ci:165: i32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:166: i32Cge: bool(1)
extras/Tests/lang.useOperator.ci:168: u32A: uint32(96)
extras/Tests/lang.useOperator.ci:169: u32B: uint32(42)
extras/Tests/lang.useOperator.ci:170: u32Pls: uint32(42)
extras/Tests/lang.useOperator.ci:171: u32Neg: uint32(4294967254)
extras/Tests/lang.useOperator.ci:172: u32Cmt: uint32(4294967253)
extras/Tests/lang.useOperator.ci:173: u32Add: uint32(138)
extras/Tests/lang.useOperator.ci:174: u32Sub: uint32(54)
extras/Tests/lang.useOperator.ci:175: u32Mul: uint32(4032)
extras/Tests/lang.useOperator.ci:176: u32Div: uint32(2)
extras/Tests/lang.useOperator.ci:177: u32Mod: uint32(12)
extras/Tests/lang.useOperator.ci:178: u32And: uint32(32)
extras/Tests/lang.useOperator.ci:179: u32Ior: uint32(106)
extras/Tests/lang.useOperator.ci:180: u32Xor: uint32(74)
extras/Tests/lang.useOperator.ci:181: u32Shl: uint32(384)
extras/Tests/lang.useOperator.ci:182: u32Shr: uint32(24)
extras/Tests/lang.useOperator.ci:183: u32Not: bool(0)
extras/Tests/lang.useOperator.ci:184: u32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:185: u32Cne: bool(1)
extras/Tests/lang.useOperator.ci:186: u32Clt: bool(0)
extras/Tests/lang.useOperator.ci:187: u32Cle: bool(0)
extras/Tests/lang.useOperator.ci:188: u32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:189: u32Cge: bool(1)
extras/Tests/lang.useOperator.ci:191: i64A: int64(96)
extras/Tests/lang.useOperator.ci:192: i64B: int64(42)
extras/Tests/lang.useOperator.ci:193: i64Pls: int64(42)
extras/Tests/lang.useOperator.ci:194: i64Neg: int64(-42)
extras/Tests/lang.useOperator.ci:195: i64Cmt: int64(-43)
extras/Tests/lang.useOperator.ci:196: i64Add: int64(138)
extras/Tests/lang.useOperator.ci:197: i64Sub: int64(54)
extras/Tests/lang.useOperator.ci:198: i64Mul: int64(4032)
extras/Tests/lang.useOperator.ci:199: i64Div: int64(2)
extras/Tests/lang.useOperator.ci:200: i64Mod: int64(12)
extras/Tests/lang.useOperator.ci:201: i64And: int64(32)
extras/Tests/lang.useOperator.ci:202: i64Ior: int64(106)
extras/Tests/lang.useOperator.ci:203: i64Xor: int64(74)
extras/Tests/lang.useOperator.ci:204: i64Shl: int64(384)
extras/Tests/lang.useOperator.ci:205: i64Shr: int64(24)
extras/Tests/lang.useOperator.ci:206: i64Not: bool(0)
extras/Tests/lang.useOperator.ci:207: i64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:208: i64Cne: bool(1)
extras/Tests/lang.useOperator.ci:209: i64Clt: bool(0)
extras/Tests/lang.useOperator.ci:210: i64Cle: bool(0)
extras/Tests/lang.useOperator.ci:211: i64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:212: i64Cge: bool(1)
extras/Tests/lang.useOperator.ci:214: u64A: uint64(96)
extras/Tests/lang.useOperator.ci:215: u64B: uint64(42)
extras/Tests/lang.useOperator.ci:216: u64Pls: uint64(42)
extras/Tests/lang.useOperator.ci:217: u64Neg: uint64(18446744073709551574)
extras/Tests/lang.useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
extras/Tests/lang.useOperator.ci:219: u64Add: uint64(138)
extras/Tests/lang.useOperator.ci:220: u64Sub: uint64(54)
extras/Tests/lang.useOperator.ci:221: u64Mul: uint64(4032)
extras/Tests/lang.useOperator.ci:222: u64Div: uint64(2)
extras/Tests/lang.useOperator.ci:223: u64Mod: uint64(12)
extras/Tests/lang.useOperator.ci:224: u64And: uint64(32)
extras/Tests/lang.useOperator.ci:225: u64Ior: uint64(106)
extras/Tests/lang.useOperator.ci:226: u64Xor: uint64(74)
extras/Tests/lang.useOperator.ci:227: u64Shl: uint64(384)
extras/Tests/lang.useOperator.ci:228: u64Shr: uint64(24)
extras/Tests/lang.useOperator.ci:229: u64Not: bool(0)
extras/Tests/lang.useOperator.ci:230: u64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:231: u64Cne: bool(1)
extras/Tests/lang.useOperator.ci:232: u64Clt: bool(0)
extras/Tests/lang.useOperator.ci:233: u64Cle: bool(0)
extras/Tests/lang.useOperator.ci:234: u64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:235: u64Cge: bool(1)
extras/Tests/lang.useOperator.ci:237: f32A: float32(96.300003)
extras/Tests/lang.useOperator.ci:238: f32B: float32(42.139999)
extras/Tests/lang.useOperator.ci:239: f32Pls: float32(42.139999)
extras/Tests/lang.useOperator.ci:240: f32Neg: float32(-42.139999)
extras/Tests/lang.useOperator.ci:242: f32Add: float32(138.440002)
extras/Tests/lang.useOperator.ci:243: f32Sub: float32(54.160004)
extras/Tests/lang.useOperator.ci:244: f32Mul: float32(4058.082031)
extras/Tests/lang.useOperator.ci:245: f32Div: float32(2.285240)
extras/Tests/lang.useOperator.ci:246: f32Mod: float32(12.020004)
extras/Tests/lang.useOperator.ci:252: f32Not: bool(0)
extras/Tests/lang.useOperator.ci:253: f32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:254: f32Cne: bool(1)
extras/Tests/lang.useOperator.ci:255: f32Clt: bool(0)
extras/Tests/lang.useOperator.ci:256: f32Cle: bool(0)
extras/Tests/lang.useOperator.ci:257: f32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:258: f32Cge: bool(1)
extras/Tests/lang.useOperator.ci:260: f64A: float64(96.300000)
extras/Tests/lang.useOperator.ci:261: f64B: float64(42.140000)
extras/Tests/lang.useOperator.ci:262: f64Pls: float64(42.140000)
extras/Tests/lang.useOperator.ci:263: f64Neg: float64(-42.140000)
extras/Tests/lang.useOperator.ci:265: f64Add: float64(138.440000)
extras/Tests/lang.useOperator.ci:266: f64Sub: float64(54.160000)
extras/Tests/lang.useOperator.ci:267: f64Mul: float64(4058.082000)
extras/Tests/lang.useOperator.ci:268: f64Div: float64(2.285240)
extras/Tests/lang.useOperator.ci:269: f64Mod: float64(12.020000)
extras/Tests/lang.useOperator.ci:275: f64Not: bool(0)
extras/Tests/lang.useOperator.ci:276: f64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:277: f64Cne: bool(1)
extras/Tests/lang.useOperator.ci:278: f64Clt: bool(0)
extras/Tests/lang.useOperator.ci:279: f64Cle: bool(0)
extras/Tests/lang.useOperator.ci:280: f64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:281: f64Cge: bool(1)
extras/Tests/lang.statementIf.ci:26: t: int32(0)
extras/Tests/lang.varInitArray.ci:8: arrFixedNoInit: int64[7]([7] {???})
extras/Tests/lang.varInitArray.ci:9: arrSliceNoInit: int64[](null)
extras/Tests/lang.varInitArray.ci:10: arrPtrNoInit: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:13: arrSliceInitNull: int64[](null)
extras/Tests/lang.varInitArray.ci:14: arrPtrInitNull: int64[*](null)
extras/Tests/lang.varInitArray.ci:17: arrSliceInitFixed: int64[]([7] {???})
extras/Tests/lang.varInitArray.ci:18: arrPtrInitFixed: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:21: arrSliceInitSlice: int64[]([7] {???})
extras/Tests/lang.varInitArray.ci:22: arrPtrInitSlice: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:26: arrPtrInitPtr: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:37: arrSliceInitString: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
extras/Tests/lang.varInitArray.ci:38: arrPtrInitString: char[*]("string")
extras/Tests/lang.varInitByRef.ci:7: value: int64(33)
extras/Tests/lang.varInitByRef.ci:8: valueRef: int64(33)
extras/Tests/lang.varInitByRef.ci:9: valuePtr: pointer(<{??}@07f9e4>)
extras/Tests/lang.varInitByRef.ci:10: valueVar: variant({int64} 33)
extras/Tests/lang.varInitByRef.ci:12: copyVal: int64(33)
extras/Tests/lang.varInitByRef.ci:13: copyRef: int64(33)
extras/Tests/lang.varInitByRef.ci:14: copyPtr: pointer(<{??}@07f9e4>)
extras/Tests/lang.varInitByRef.ci:15: copyVar: variant({int64} 33)
extras/Tests/lang.varInitByRef.ci:16: fromRef: int64(33)
extras/Tests/lang.varInitByRef.ci:17: fromPtr: int64(33)
extras/Tests/lang.varInitByRef.ci:18: fromVar: int64(33)
extras/Tests/lang.varInitByRef.ci:20: nullRef: int64(null)
extras/Tests/lang.varInitByRef.ci:21: nullPtr: pointer(null)
extras/Tests/lang.varInitByRef.ci:22: nullVar: variant(null)
extras/Tests/lang.varInitByRef.ci:23: typePtr: pointer(<int64@000400>)
extras/Tests/lang.varInitByRef.ci:24: typeVar: variant({typename} int64)
extras/Tests/lang.varInitByRef.ci:27: ptrVoid: pointer(<void@0000a0>)
extras/Tests/lang.varInitByRef.ci:28: ptrBool: pointer(<bool@000130>)
extras/Tests/lang.varInitByRef.ci:29: ptrChar: pointer(<char@0001c0>)
extras/Tests/lang.varInitByRef.ci:30: ptrInt8: pointer(<int8@000250>)
extras/Tests/lang.varInitByRef.ci:31: ptrInt16: pointer(<int16@0002e0>)
extras/Tests/lang.varInitByRef.ci:32: ptrInt32: pointer(<int32@000370>)
extras/Tests/lang.varInitByRef.ci:33: ptrInt64: pointer(<int64@000400>)
extras/Tests/lang.varInitByRef.ci:34: ptrUint8: pointer(<uint8@000490>)
extras/Tests/lang.varInitByRef.ci:35: ptrUint16: pointer(<uint16@000520>)
extras/Tests/lang.varInitByRef.ci:36: ptrUint32: pointer(<uint32@0005b0>)
extras/Tests/lang.varInitByRef.ci:37: ptrUint64: pointer(<uint64@000640>)
extras/Tests/lang.varInitByRef.ci:38: ptrFloat32: pointer(<float32@0006d0>)
extras/Tests/lang.varInitByRef.ci:39: ptrFloat64: pointer(<float64@000760>)
extras/Tests/lang.varInitByRef.ci:40: ptrTypename: pointer(<typename@000008>)
extras/Tests/lang.varInitByRef.ci:41: ptrFunction: pointer(<function@000910>)
extras/Tests/lang.varInitByRef.ci:42: ptrPointer: pointer(<pointer@0007f0>)
extras/Tests/lang.varInitByRef.ci:43: ptrVariant: pointer(<variant@000880>)
extras/Tests/lang.varInitByRef.ci:44: ptrObject: pointer(<object@0009a8>)
extras/Tests/lang.varInitByRef.ci:47: varVoid: variant({typename} void)
extras/Tests/lang.varInitByRef.ci:48: varBool: variant({typename} bool)
extras/Tests/lang.varInitByRef.ci:49: varChar: variant({typename} char)
extras/Tests/lang.varInitByRef.ci:50: varInt8: variant({typename} int8)
extras/Tests/lang.varInitByRef.ci:51: varInt16: variant({typename} int16)
extras/Tests/lang.varInitByRef.ci:52: varInt32: variant({typename} int32)
extras/Tests/lang.varInitByRef.ci:53: varInt64: variant({typename} int64)
extras/Tests/lang.varInitByRef.ci:54: varUint8: variant({typename} uint8)
extras/Tests/lang.varInitByRef.ci:55: varUint16: variant({typename} uint16)
extras/Tests/lang.varInitByRef.ci:56: varUint32: variant({typename} uint32)
extras/Tests/lang.varInitByRef.ci:57: varUint64: variant({typename} uint64)
extras/Tests/lang.varInitByRef.ci:58: varFloat32: variant({typename} float32)
extras/Tests/lang.varInitByRef.ci:59: varFloat64: variant({typename} float64)
extras/Tests/lang.varInitByRef.ci:60: varTypename: variant({typename} typename)
extras/Tests/lang.varInitByRef.ci:61: varFunction: variant({typename} function)
extras/Tests/lang.varInitByRef.ci:62: varPointer: variant({typename} pointer)
extras/Tests/lang.varInitByRef.ci:63: varVariant: variant({typename} variant)
extras/Tests/lang.varInitByRef.ci:64: varObject: variant({typename} object)
extras/Tests/lang.varInitByRef.ci:67: copyPtrFloat64: variant({pointer} <float64@000760>)
extras/Tests/lang.varInitByRef.ci:70: copyVarFloat64: pointer(<float64@000760>)
extras/Tests/lang.varInitStatic.ci:7: localNoInit: int64(???)
extras/Tests/lang.varInitStatic.ci:8: globalNoInit: int64(0)
extras/Tests/lang.varInitStatic.ci:9: localInitValue: int64(42)
extras/Tests/lang.varInitStatic.ci:10: globalInitValue: int64(1024)
extras/Tests/lang.varInitStatic.ci:11: localInitLocal: int64(42)
extras/Tests/lang.varInitStatic.ci:12: globalInitLocal: int64(42)
extras/Tests/lang.varInitStatic.ci:13: localInitGlobal: int64(1024)
extras/Tests/lang.varInitStatic.ci:14: globalInitGlobal: int64(1024)
extras/Tests/stdc.nfcNumber.ci:3: pi64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:4: e64: float64(2.718282)
extras/Tests/stdc.nfcNumber.ci:6: pi32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:7: e32: float32(2.718282)
extras/Tests/stdc.nfcNumber.ci:14: r_comp: int32(112)
extras/Tests/stdc.nfcNumber.ci:15: g_comp: int32(252)
extras/Tests/stdc.nfcNumber.ci:16: b_comp: int32(248)
extras/Tests/stdc.nfcNumber.ci:18: r5g6b5: int32(30719)
extras/Tests/stdc.nfcNumber.ci:19: r8g8b8: int32(7404792)
extras/Tests/stdc.nfcNumber.ci:21: zextR5: int32(14)
extras/Tests/stdc.nfcNumber.ci:22: zextG6: int32(63)
extras/Tests/stdc.nfcNumber.ci:23: zextB5: int32(31)
extras/Tests/stdc.nfcNumber.ci:25: sextR5: int32(14)
extras/Tests/stdc.nfcNumber.ci:26: sextG6: int32(-1)
extras/Tests/stdc.nfcNumber.ci:27: sextB5: int32(-1)
extras/Tests/stdc.nfcNumber.ci:29: zextR8: int32(112)
extras/Tests/stdc.nfcNumber.ci:30: zextG8: int32(252)
extras/Tests/stdc.nfcNumber.ci:31: zextB8: int32(248)
extras/Tests/stdc.nfcNumber.ci:33: sextR8: int32(112)
extras/Tests/stdc.nfcNumber.ci:34: sextG8: int32(-4)
extras/Tests/stdc.nfcNumber.ci:35: sextB8: int32(-8)
extras/Tests/stdc.nfcNumber.ci:37: sinF64: float64(1.000000)
extras/Tests/stdc.nfcNumber.ci:38: cosF64: float64(0.000000)
extras/Tests/stdc.nfcNumber.ci:39: tanF64: float64(1.000000)
extras/Tests/stdc.nfcNumber.ci:40: logF64: float64(3.000000)
extras/Tests/stdc.nfcNumber.ci:41: expF64: float64(2.718282)
extras/Tests/stdc.nfcNumber.ci:42: powF64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:43: sqrtF64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:44: atanF64: float64(1.262627)
extras/Tests/stdc.nfcNumber.ci:46: sinF32: float32(1.000000)
extras/Tests/stdc.nfcNumber.ci:47: cosF32: float32(-0.000000)
extras/Tests/stdc.nfcNumber.ci:48: tanF32: float32(1.000000)
extras/Tests/stdc.nfcNumber.ci:49: logF32: float32(3.000000)
extras/Tests/stdc.nfcNumber.ci:50: expF32: float32(2.718282)
extras/Tests/stdc.nfcNumber.ci:51: powF32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:52: sqrtF32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:53: atanF32: float32(1.262627)
extras/Tests/stdc.nfcMemory.ci:6: p1: pointer(<{??}@???>)
extras/Tests/stdc.nfcMemory.ci:7: p2: pointer(<{??}@???>)
extras/Tests/stdc.nfcMemory.ci:8: p3: pointer(<{??}@???>)
extras/Tests/stdc.nfcMemory.ci:9: p4: pointer(<{??}@???>)
extras/Tests/stdc.nfcMemory.ci:22: val1: int64(0)
extras/Tests/stdc.nfcMemory.ci:23: val2: int64(42)
.main: function(.main)
// */

/*-- Allocations:
memory[meta] @000000; size: 116240(113.5 Kb)
memory[code] @000000; size: 121341(118.5 Kb)
memory[stack] @000000; size: 131018(127.9 Kb)
memory[heap] @01d9fd; size: 271665(265.3 Kb)
memory[free] @01da18; size: 271616(265.2 Kb)
// */
