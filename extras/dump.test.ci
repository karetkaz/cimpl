
---------- Compile: `stdlib.ci`

---------- Compile: `test.ci`

---------- Generate: byte-code

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4 -> const variable)
.field offset: int32 (size: 4 -> const variable)
.field base: function (size: 0 -> static const inline)
.field file: function (size: 0 -> static const inline)
.field line: function (size: 0 -> static const inline)
.field name: function (size: 0 -> static const inline)
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(1)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(2)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(3)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(4)
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.field pop: function (size: 0 -> static const inline)
.field swap: function (size: 0 -> static const inline)
.field bsr: function (size: 0 -> static const inline)
.field bsf: function (size: 0 -> static const inline)
.field hib: function (size: 0 -> static const inline)
.field lob: function (size: 0 -> static const inline)
.value: 0
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(18)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(19)
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(20)
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(21)
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(22)
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(23)
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(24)
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(25)
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.value: 0
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(26)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(27)
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(28)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(29)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(30)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(31)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(32)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(33)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(34)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(35)
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(36)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(37)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(38)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(39)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(40)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(41)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(42)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(43)
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0 -> static const inline)
.field fill: function (size: 0 -> static const inline)
.field copy: function (size: 0 -> static const inline)
.field move: function (size: 0 -> static const inline)
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param ptr: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(7)
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param value: int32 (size: 4 -> variable(i32))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(8)
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(9)
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(10)
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'true'
.value: 1
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'false'
.value: 0
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'byte'
.value: uint8
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'float'
.value: float32
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'double'
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0 -> static const inline)
.field not: bool (size: 0 -> static const inline)
.field set: void (size: 0 -> static const inline)
.field ret: void (size: 0 -> static const inline)
.field call: void (size: 0 -> static const inline)
.field p4x: typename (size: 16 -> static const typename(val))
.field dup: void (size: 0 -> static const typename(void))
.field load: void (size: 0 -> static const typename(void))
.field store: void (size: 0 -> static const typename(void))
.field cmt: void (size: 0 -> static const typename(void))
.field and: void (size: 0 -> static const typename(void))
.field or: void (size: 0 -> static const typename(void))
.field xor: void (size: 0 -> static const typename(void))
.field shl: void (size: 0 -> static const typename(void))
.field shr: void (size: 0 -> static const typename(void))
.field neg: void (size: 0 -> static const typename(void))
.field add: void (size: 0 -> static const typename(void))
.field sub: void (size: 0 -> static const typename(void))
.field mul: void (size: 0 -> static const typename(void))
.field div: void (size: 0 -> static const typename(void))
.field mod: void (size: 0 -> static const typename(void))
.field ceq: void (size: 0 -> static const typename(void))
.field clt: void (size: 0 -> static const typename(void))
.field cgt: void (size: 0 -> static const typename(void))
.field min: void (size: 0 -> static const typename(void))
.field max: void (size: 0 -> static const typename(void))
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0 -> static const inline)
.field dp4: float32 (size: 0 -> static const inline)
.field dph: float32 (size: 0 -> static const inline)
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0 -> static const inline)
.field x2: int64 (size: 0 -> static const inline)
.field x4: emit.p4x (size: 0 -> static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0 -> static const inline)
.field z64: int64 (size: 0 -> static const inline)
.field z128: emit.p4x (size: 0 -> static const inline)
.field i8: int32 (size: 0 -> static const inline)
.field i16: int32 (size: 0 -> static const inline)
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field i128: emit.p4x (size: 0 -> static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0 -> static const inline)
.field i16: void (size: 0 -> static const inline)
.field i32: void (size: 0 -> static const inline)
.field i64: void (size: 0 -> static const inline)
.field i128: void (size: 0 -> static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
}
emit.mul: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
.field p4f: bool (size: 0 -> static const inline)
.field p2d: bool (size: 0 -> static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0 -> inline)
.value: nfc(0)
}
CLOCKS_PER_SEC: int64 {
.kind: i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0 -> static const i64)
.field error: int64 (size: 0 -> static const i64)
.field warn: int64 (size: 0 -> static const i64)
.field info: int64 (size: 0 -> static const i64)
.field debug: int64 (size: 0 -> static const i64)
.field verbose: int64 (size: 0 -> static const i64)
.field noTrace: int64 (size: 0 -> static const i64)
.field defTrace: int64 (size: 0 -> static const i64)
.param .result: void (size: 0 -> inline)
.param file: char[*] (size: 4 -> variable(ref))
.param line: int32 (size: 4 -> variable(i32))
.param level: int32 (size: 4 -> variable(i32))
.param trace: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.param inspect: variant (size: 8 -> variable(var))
.value: nfc(5)
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 2
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 3
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 4
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4 -> inline)
.param args: pointer (size: 4 -> variable(ref))
.param action: function (size: 4 -> variable(ref))
.value: nfc(6)
}
System: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'System'
.field exit: function (size: 0 -> static const inline)
.field srand: function (size: 0 -> static const inline)
.field rand: function (size: 0 -> static const inline)
.field time: function (size: 0 -> static const inline)
.field clock: function (size: 0 -> static const inline)
.field millis: function (size: 0 -> static const inline)
.field sleep: function (size: 0 -> static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0 -> inline)
.param code: int32 (size: 4 -> variable(i32))
.value: nfc(11)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0 -> inline)
.param seed: int32 (size: 4 -> variable(i32))
.value: nfc(12)
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(13)
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(14)
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(15)
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8 -> inline)
.value: nfc(16)
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0 -> inline)
.param millis: int64 (size: 8 -> variable(i64))
.value: nfc(17)
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'stdlib.ci'
.line: 5
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.verbose, raise.noTrace, message, inspect)
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'stdlib.ci'
.line: 6
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.verbose, raise.noTrace, message, null)
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'stdlib.ci'
.line: 8
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.defTrace, message, inspect)
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'stdlib.ci'
.line: 9
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.defTrace, message, null)
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'stdlib.ci'
.line: 11
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.noTrace, message, inspect)
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'stdlib.ci'
.line: 12
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.noTrace, message, null)
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'stdlib.ci'
.line: 14
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.info, raise.noTrace, message, inspect)
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'stdlib.ci'
.line: 15
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.info, raise.noTrace, message, null)
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'stdlib.ci'
.line: 17
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.warn, raise.noTrace, message, inspect)
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'stdlib.ci'
.line: 18
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.warn, raise.noTrace, message, null)
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'stdlib.ci'
.line: 20
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.error, raise.defTrace, message, inspect)
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'stdlib.ci'
.line: 21
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.error, raise.defTrace, message, null)
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'stdlib.ci'
.line: 23
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.abort, raise.defTrace, message, inspect)
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'stdlib.ci'
.line: 24
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.abort, raise.defTrace, message, null)
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'stdlib.ci'
.line: 25
.param .result: void (size: 0 -> void)
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'stdlib.ci'
.line: 27
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: void(condition ? void(0) : abort(message, inspect))
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'stdlib.ci'
.line: 28
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.value: void(condition ? void(0) : abort(message))
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'stdlib.ci'
.line: 29
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 69
.name: 'assertEq'
.file: 'stdlib.ci'
.line: 32
.param .result: void (size: 0 -> variable(void))
.param expected: int32 (size: 4 -> variable(i32))
.param returned: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.value: {
	if (returned == expected) {
		return;
	}
	static const NonEqualIntegers: struct {
		const expected: int32;
		const returned: int32;
		const message: char[*];
	};
	details: NonEqualIntegers := {
		details.expected := expected;
		details.returned := returned;
		details.message := (message);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (69 bytes)
	stdlib.ci:33: (10 bytes): if (returned == expected)
	<assertEq+?>:    dup.x1 sp(2)
	<assertEq+?>:    dup.x1 sp(4)
	<assertEq+?>:    ceq.i32
	<assertEq+?>:    jz <assertEq+?>
	stdlib.ci:34: (1 bytes): return;
	<assertEq+?>:    ret
	stdlib.ci:41: (16 bytes): details: NonEqualIntegers := {...}
	<assertEq+?>:    inc.sp(+16)
	stdlib.ci:42: (4 bytes): details.expected := expected;
	<assertEq+?>:    dup.x1 sp(7)
	<assertEq+?>:    set.x1 sp(1)
	stdlib.ci:43: (4 bytes): details.returned := returned;
	<assertEq+?>:    dup.x1 sp(6)
	<assertEq+?>:    set.x1 sp(2)
	stdlib.ci:44: (4 bytes): details.message := (message);
	<assertEq+?>:    dup.x1 sp(5)
	<assertEq+?>:    set.x1 sp(3)
	stdlib.ci:46: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>:    load.ref .?????? ;"stdlib.ci"
	<assertEq+?>:    load.c32 46
	<assertEq+?>:    load.c32 -1
	<assertEq+?>:    load.c32 128
	<assertEq+?>:    load.ref .?????? ;"assertion failed"
	<assertEq+?>:    load.ref .?????? ;assertEq.NonEqualIntegers
	<assertEq+?>:    load.sp(+24)
	<assertEq+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>:    inc.sp(-16)
	<assertEq+?>:    ret
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'stdlib.ci'
.line: 48
.param .result: void (size: 0 -> void)
.param expected: int32 (size: 4 -> i32)
.param returned: int32 (size: 4 -> i32)
.value: assertEq(expected, returned, null)
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'stdlib.ci'
.line: 52
.param .result: int32 (size: 4 -> i32)
.param type: typename (size: 4 -> ref)
.value: int32(type.size)
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'integer'
.file: 'test.ci'
.line: 4
.value: int64
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitldz32'
.file: 'test/lang.inlineEmit.ci'
.line: 3
.value: emit(load.z32)
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitldz64'
.file: 'test/lang.inlineEmit.ci'
.line: 4
.value: emit(load.z64)
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitA'
.file: 'test/lang.inlineEmit.ci'
.line: 6
.value: 42
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitB'
.file: 'test/lang.inlineEmit.ci'
.line: 7
.value: 96
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitAddI32'
.file: 'test/lang.inlineEmit.ci'
.line: 9
.value: emit(int32(emitA), int32(emitB), add.i32)
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitDivI32'
.file: 'test/lang.inlineEmit.ci'
.line: 10
.value: emit(int32(10), int32(5), div.i32)
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'emitNfcF32'
.file: 'test/lang.inlineEmit.ci'
.line: 11
.value: emit(float32(3.140000 / (2)), float32.sin)
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt32'
.file: 'test/lang.inlineEmit.ci'
.line: 14
.param .result: int32 (size: 4 -> i32)
.param value: float32 (size: 4 -> f32)
.value: int32(emit(float32(value)))
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt64'
.file: 'test/lang.inlineEmit.ci'
.line: 15
.param .result: int64 (size: 8 -> i64)
.param value: float64 (size: 8 -> f64)
.value: int64(emit(float64(value)))
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt1'
.file: 'test/lang.inlineEmit.ci'
.line: 17
.value: floatAsInt32(500)
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt2'
.file: 'test/lang.inlineEmit.ci'
.line: 18
.value: floatAsInt32(500)
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt3'
.file: 'test/lang.inlineEmit.ci'
.line: 19
.value: floatAsInt64(500)
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt4'
.file: 'test/lang.inlineEmit.ci'
.line: 20
.value: floatAsInt64(500)
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'emitSlice'
.file: 'test/lang.inlineEmit.ci'
.line: 23
.value: emit(int32(3), pointer("string"))
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'zero'
.file: 'test/lang.inlineMacros.ci'
.line: 3
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: 0
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'last'
.file: 'test/lang.inlineMacros.ci'
.line: 4
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: b
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'test/lang.inlineMacros.ci'
.line: 5
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: a + b
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'test/lang.inlineMacros.ci'
.line: 6
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> variable(i32))
.param b: int32 (size: 4 -> i32)
.value: (a) ? a : b
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'test/lang.inlineMacros.ci'
.line: 7
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> variable(i32))
.param b: int32 (size: 4 -> variable(i32))
.value: a < b ? a : b
}
sum(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'test/lang.inlineMacros.ci'
.line: 9
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: sum(sum(a, b), c)
}
any(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'test/lang.inlineMacros.ci'
.line: 10
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: any(any(a, b), c)
}
min(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'test/lang.inlineMacros.ci'
.line: 11
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: min(min(a, b), c)
}
ma: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'ma'
.file: 'test/lang.inlineMacros.ci'
.line: 13
.value: 3
}
mb: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'mb'
.file: 'test/lang.inlineMacros.ci'
.line: 14
.value: 6
}
mc: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'mc'
.file: 'test/lang.inlineMacros.ci'
.line: 15
.value: 9
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVal'
.file: 'test/lang.inlineMacros.ci'
.line: 17
.value: zero(2, 3)
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVar'
.file: 'test/lang.inlineMacros.ci'
.line: 18
.value: zero(ma, mb)
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroXpr'
.file: 'test/lang.inlineMacros.ci'
.line: 19
.value: zero(ma + mb, mb + mc)
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVal'
.file: 'test/lang.inlineMacros.ci'
.line: 21
.value: last(2, 3)
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVar'
.file: 'test/lang.inlineMacros.ci'
.line: 22
.value: last(ma, mb)
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastXpr'
.file: 'test/lang.inlineMacros.ci'
.line: 23
.value: last(ma + mb, mb + mc)
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Val'
.file: 'test/lang.inlineMacros.ci'
.line: 25
.value: sum(3, 12)
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Var'
.file: 'test/lang.inlineMacros.ci'
.line: 26
.value: sum(ma, mb)
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 27
.value: sum(ma + mb, mb + mc)
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Val'
.file: 'test/lang.inlineMacros.ci'
.line: 29
.value: any(3, 12)
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Var'
.file: 'test/lang.inlineMacros.ci'
.line: 30
.value: any(ma, mb)
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 31
.value: any(ma + mb, mb + mc)
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Val'
.file: 'test/lang.inlineMacros.ci'
.line: 33
.value: min(3, 12)
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Var'
.file: 'test/lang.inlineMacros.ci'
.line: 34
.value: min(ma, mb)
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 35
.value: min(ma + mb, mb + mc)
}
sum3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Val'
.file: 'test/lang.inlineMacros.ci'
.line: 37
.value: sum(3, 2, 6)
}
sum3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Var'
.file: 'test/lang.inlineMacros.ci'
.line: 38
.value: sum(ma, mb, mc)
}
sum3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 39
.value: sum(ma + mb, mb + mc, mc + ma)
}
any3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Val'
.file: 'test/lang.inlineMacros.ci'
.line: 41
.value: any(3, 2, 6)
}
any3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Var'
.file: 'test/lang.inlineMacros.ci'
.line: 42
.value: any(ma, mb, mc)
}
any3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 43
.value: any(ma + mb, mb + mc, mc + ma)
}
min3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Val'
.file: 'test/lang.inlineMacros.ci'
.line: 45
.value: min(3, 2, 6)
}
min3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Var'
.file: 'test/lang.inlineMacros.ci'
.line: 46
.value: min(ma, mb, mc)
}
min3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Xpr'
.file: 'test/lang.inlineMacros.ci'
.line: 47
.value: min(ma + mb, mb + mc, mc + ma)
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci'
.line: 3
.value: 1
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci'
.line: 4
.param .result: int32 (size: 4 -> i32)
.value: 2
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci'
.line: 5
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.value: 3
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci'
.line: 6
.param .result: int32 (size: 4 -> i32)
.param a: float32 (size: 4 -> f32)
.value: 4
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci'
.line: 7
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: 5
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload1'
.file: 'test/test.inlineOverload.ci'
.line: 9
.value: overload
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload2'
.file: 'test/test.inlineOverload.ci'
.line: 10
.value: overload()
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload3'
.file: 'test/test.inlineOverload.ci'
.line: 11
.value: overload(0)
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload4'
.file: 'test/test.inlineOverload.ci'
.line: 12
.value: overload(0.000000)
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload5'
.file: 'test/test.inlineOverload.ci'
.line: 13
.value: overload(0, 0)
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci'
.line: 15
.field degrees: float64 (size: 8 -> variable(f64))
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'test/test.inlineOverload.ci'
.line: 15
.owner: Celsius
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci'
.line: 16
.field degrees: float64 (size: 8 -> variable(f64))
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'test/test.inlineOverload.ci'
.line: 16
.owner: Fahrenheit
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci'
.line: 21
.param .result: Celsius (size: 8 -> val)
.param value: float64 (size: 8 -> f64)
.value: Celsius(emit(float64(value)))
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci'
.line: 22
.param .result: Fahrenheit (size: 8 -> val)
.param value: float64 (size: 8 -> f64)
.value: Fahrenheit(emit(float64(value)))
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci'
.line: 25
.param .result: Celsius (size: 8 -> val)
.param value: Fahrenheit (size: 8 -> val)
.value: Celsius((value.degrees - (32)) / 1.800000)
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci'
.line: 26
.param .result: Fahrenheit (size: 8 -> val)
.param value: Celsius (size: 8 -> val)
.value: Fahrenheit(value.degrees * 1.800000 + (32))
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.name: 'boilC'
.file: 'test/test.inlineOverload.ci'
.line: 28
.value: Celsius(100.000000)
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.name: 'boilF'
.file: 'test/test.inlineOverload.ci'
.line: 29
.value: Fahrenheit(boilC)
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'test/lang.initByRef.ci'
.line: 7
.value: 42
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'valueRef'
.file: 'test/lang.initByRef.ci'
.line: 8
.value: value
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valuePtr'
.file: 'test/lang.initByRef.ci'
.line: 9
.value: value
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueVar'
.file: 'test/lang.initByRef.ci'
.line: 10
.value: value
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'fromRef'
.file: 'test/lang.initByRef.ci'
.line: 12
.value: valueRef
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromPtr'
.file: 'test/lang.initByRef.ci'
.line: 13
.value: valuePtr
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromVar'
.file: 'test/lang.initByRef.ci'
.line: 14
.value: valueVar
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'nullRef'
.file: 'test/lang.initByRef.ci'
.line: 16
.value: null
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'nullPtr'
.file: 'test/lang.initByRef.ci'
.line: 17
.value: null
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'nullVar'
.file: 'test/lang.initByRef.ci'
.line: 18
.value: null
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'nullTyp'
.file: 'test/lang.initByRef.ci'
.line: 19
.value: null
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'nullFun'
.file: 'test/lang.initByRef.ci'
.line: 20
.value: null
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'nullObj'
.file: 'test/lang.initByRef.ci'
.line: 21
.value: null
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'typePtr'
.file: 'test/lang.initByRef.ci'
.line: 23
.value: int64
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'typeVar'
.file: 'test/lang.initByRef.ci'
.line: 24
.value: int64
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeTyp'
.file: 'test/lang.initByRef.ci'
.line: 25
.value: int64
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'local'
.file: 'test/lang.initByRef.ci'
.line: 27
.value: value
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'copyVal'
.file: 'test/lang.initByRef.ci'
.line: 28
.value: local
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'copyRef'
.file: 'test/lang.initByRef.ci'
.line: 29
.value: valueRef
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyPtr'
.file: 'test/lang.initByRef.ci'
.line: 30
.value: valuePtr
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyVar'
.file: 'test/lang.initByRef.ci'
.line: 31
.value: valueVar
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'copyTyp'
.file: 'test/lang.initByRef.ci'
.line: 32
.value: typeTyp
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVoid'
.file: 'test/lang.initByRef.ci'
.line: 35
.value: void
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrBool'
.file: 'test/lang.initByRef.ci'
.line: 36
.value: bool
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrChar'
.file: 'test/lang.initByRef.ci'
.line: 37
.value: char
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt8'
.file: 'test/lang.initByRef.ci'
.line: 38
.value: int8
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt16'
.file: 'test/lang.initByRef.ci'
.line: 39
.value: int16
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt32'
.file: 'test/lang.initByRef.ci'
.line: 40
.value: int32
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt64'
.file: 'test/lang.initByRef.ci'
.line: 41
.value: int64
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint8'
.file: 'test/lang.initByRef.ci'
.line: 42
.value: uint8
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint16'
.file: 'test/lang.initByRef.ci'
.line: 43
.value: uint16
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint32'
.file: 'test/lang.initByRef.ci'
.line: 44
.value: uint32
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint64'
.file: 'test/lang.initByRef.ci'
.line: 45
.value: uint64
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat32'
.file: 'test/lang.initByRef.ci'
.line: 46
.value: float32
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat64'
.file: 'test/lang.initByRef.ci'
.line: 47
.value: float64
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrTypename'
.file: 'test/lang.initByRef.ci'
.line: 48
.value: typename
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFunction'
.file: 'test/lang.initByRef.ci'
.line: 49
.value: function
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrPointer'
.file: 'test/lang.initByRef.ci'
.line: 50
.value: pointer
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVariant'
.file: 'test/lang.initByRef.ci'
.line: 51
.value: variant
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrObject'
.file: 'test/lang.initByRef.ci'
.line: 52
.value: object
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVoid'
.file: 'test/lang.initByRef.ci'
.line: 55
.value: void
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varBool'
.file: 'test/lang.initByRef.ci'
.line: 56
.value: bool
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varChar'
.file: 'test/lang.initByRef.ci'
.line: 57
.value: char
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt8'
.file: 'test/lang.initByRef.ci'
.line: 58
.value: int8
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt16'
.file: 'test/lang.initByRef.ci'
.line: 59
.value: int16
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt32'
.file: 'test/lang.initByRef.ci'
.line: 60
.value: int32
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt64'
.file: 'test/lang.initByRef.ci'
.line: 61
.value: int64
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint8'
.file: 'test/lang.initByRef.ci'
.line: 62
.value: uint8
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint16'
.file: 'test/lang.initByRef.ci'
.line: 63
.value: uint16
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint32'
.file: 'test/lang.initByRef.ci'
.line: 64
.value: uint32
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint64'
.file: 'test/lang.initByRef.ci'
.line: 65
.value: uint64
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat32'
.file: 'test/lang.initByRef.ci'
.line: 66
.value: float32
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat64'
.file: 'test/lang.initByRef.ci'
.line: 67
.value: float64
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varTypename'
.file: 'test/lang.initByRef.ci'
.line: 68
.value: typename
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFunction'
.file: 'test/lang.initByRef.ci'
.line: 69
.value: function
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varPointer'
.file: 'test/lang.initByRef.ci'
.line: 70
.value: pointer
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVariant'
.file: 'test/lang.initByRef.ci'
.line: 71
.value: variant
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varObject'
.file: 'test/lang.initByRef.ci'
.line: 72
.value: object
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVoid'
.file: 'test/lang.initByRef.ci'
.line: 75
.value: void
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typBool'
.file: 'test/lang.initByRef.ci'
.line: 76
.value: bool
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typChar'
.file: 'test/lang.initByRef.ci'
.line: 77
.value: char
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt8'
.file: 'test/lang.initByRef.ci'
.line: 78
.value: int8
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt16'
.file: 'test/lang.initByRef.ci'
.line: 79
.value: int16
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt32'
.file: 'test/lang.initByRef.ci'
.line: 80
.value: int32
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt64'
.file: 'test/lang.initByRef.ci'
.line: 81
.value: int64
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint8'
.file: 'test/lang.initByRef.ci'
.line: 82
.value: uint8
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint16'
.file: 'test/lang.initByRef.ci'
.line: 83
.value: uint16
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint32'
.file: 'test/lang.initByRef.ci'
.line: 84
.value: uint32
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint64'
.file: 'test/lang.initByRef.ci'
.line: 85
.value: uint64
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat32'
.file: 'test/lang.initByRef.ci'
.line: 86
.value: float32
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat64'
.file: 'test/lang.initByRef.ci'
.line: 87
.value: float64
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typTypename'
.file: 'test/lang.initByRef.ci'
.line: 88
.value: typename
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFunction'
.file: 'test/lang.initByRef.ci'
.line: 89
.value: function
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typPointer'
.file: 'test/lang.initByRef.ci'
.line: 90
.value: pointer
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVariant'
.file: 'test/lang.initByRef.ci'
.line: 91
.value: variant
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typObject'
.file: 'test/lang.initByRef.ci'
.line: 92
.value: object
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valueOfPtr'
.file: 'test/lang.initByRef.ci'
.line: 95
.value: pointer(value)
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueOfVar'
.file: 'test/lang.initByRef.ci'
.line: 96
.value: variant(value)
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'valueOfTyp'
.file: 'test/lang.initByRef.ci'
.line: 97
.value: typename(value)
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeOfValue'
.file: 'test/lang.initByRef.ci'
.line: 99
.value: typename(value)
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyPtrFloat64'
.file: 'test/lang.initByRef.ci'
.line: 105
.value: ptrFloat64
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyVarFloat64'
.file: 'test/lang.initByRef.ci'
.line: 108
.value: varFloat64
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.name: 'empty'
.file: 'test/lang.function.ci'
.line: 3
.param .result: void (size: 0 -> variable(void))
.value: {
}
.instructions: (1 bytes)
	<empty+?>:    ret
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'funAdd'
.file: 'test/lang.function.ci'
.line: 6
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	test/lang.function.ci:7: (8 bytes): return .result := x + y;
	<funAdd+?>:    dup.x1 sp(2)
	<funAdd+?>:    dup.x1 sp(2)
	<funAdd+?>:    add.i32
	<funAdd+?>:    set.x1 sp(4)
	<funAdd+?>:    ret
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddResult'
.file: 'test/lang.function.ci'
.line: 11
.value: funAdd(2, 7)
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funAddRef'
.file: 'test/lang.function.ci'
.line: 14
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funAdd
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddRefResult'
.file: 'test/lang.function.ci'
.line: 17
.value: funAddRef(2, 8)
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMul'
.file: 'test/lang.function.ci'
.line: 20
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funMul
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulResult'
.file: 'test/lang.function.ci'
.line: 23
.value: funMul(2, 6)
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMulRef'
.file: 'test/lang.function.ci'
.line: 26
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funMul
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulRefResult'
.file: 'test/lang.function.ci'
.line: 29
.value: funMulRef(2, 7)
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'funMul'
.file: 'test/lang.function.ci'
.line: 32
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.function.ci:33: (8 bytes): return .result := x * y;
	<funMul+?>:    dup.x1 sp(2)
	<funMul+?>:    dup.x1 sp(2)
	<funMul+?>:    mul.i32
	<funMul+?>:    set.x1 sp(4)
	<funMul+?>:    ret
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 55
.name: 'fib'
.file: 'test/lang.function.ci'
.line: 37
.param .result: uint32 (size: 4 -> variable(u32))
.param n: uint32 (size: 4 -> variable(u32))
.value: {
	if (n <= (1)) {
		return .result := n;
	}
	return .result := fib(n - (1)) + fib(n - (2));
}
.instructions: (55 bytes)
	test/lang.function.ci:38: (17 bytes): if (n <= (1))
	<fib+?>:    dup.x1 sp(1)
	<fib+?>:    load.c32 1
	<fib+?>:    cgt.u32
	<fib+?>:    jnz <fib+?>
	test/lang.function.ci:39: (5 bytes): return .result := n;
	<fib+?>:    dup.x1 sp(1)
	<fib+?>:    set.x1 sp(3)
	<fib+?>:    ret
	test/lang.function.ci:41: (38 bytes): return .result := fib(n - (1)) + fib(n - (2));
	<fib+?>:    load.z32
	<fib+?>:    dup.x1 sp(2)
	<fib+?>:    inc.i32(-1)
	<fib+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<fib+?>:    call
	<fib+?>:    inc.sp(-4)
	<fib+?>:    load.z32
	<fib+?>:    dup.x1 sp(3)
	<fib+?>:    inc.i32(-2)
	<fib+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<fib+?>:    call
	<fib+?>:    inc.sp(-4)
	<fib+?>:    add.i32
	<fib+?>:    set.x1 sp(3)
	<fib+?>:    ret
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'fibonacci_13'
.file: 'test/lang.function.ci'
.line: 45
.value: fib(13)
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVoid'
.file: 'test/lang.reflect.ci'
.line: 3
.value: sizeof(void)
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofBool'
.file: 'test/lang.reflect.ci'
.line: 4
.value: sizeof(bool)
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofChar'
.file: 'test/lang.reflect.ci'
.line: 5
.value: sizeof(char)
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt8'
.file: 'test/lang.reflect.ci'
.line: 6
.value: sizeof(int8)
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt16'
.file: 'test/lang.reflect.ci'
.line: 7
.value: sizeof(int16)
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt32'
.file: 'test/lang.reflect.ci'
.line: 8
.value: sizeof(int32)
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt64'
.file: 'test/lang.reflect.ci'
.line: 9
.value: sizeof(int64)
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint8'
.file: 'test/lang.reflect.ci'
.line: 10
.value: sizeof(uint8)
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint16'
.file: 'test/lang.reflect.ci'
.line: 11
.value: sizeof(uint16)
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint32'
.file: 'test/lang.reflect.ci'
.line: 12
.value: sizeof(uint32)
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint64'
.file: 'test/lang.reflect.ci'
.line: 13
.value: sizeof(uint64)
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat32'
.file: 'test/lang.reflect.ci'
.line: 14
.value: sizeof(float32)
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat64'
.file: 'test/lang.reflect.ci'
.line: 15
.value: sizeof(float64)
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofPointer'
.file: 'test/lang.reflect.ci'
.line: 16
.value: sizeof(pointer)
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVariant'
.file: 'test/lang.reflect.ci'
.line: 17
.value: sizeof(variant)
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofTypename'
.file: 'test/lang.reflect.ci'
.line: 18
.value: sizeof(typename)
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFunction'
.file: 'test/lang.reflect.ci'
.line: 19
.value: sizeof(function)
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofObject'
.file: 'test/lang.reflect.ci'
.line: 20
.value: sizeof(object)
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.name: 'RecordSizeof'
.file: 'test/lang.reflect.ci'
.line: 22
.field x: int64 (size: 8 -> variable(i64))
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'x'
.file: 'test/lang.reflect.ci'
.line: 23
.owner: RecordSizeof
.value: 0
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.name: 'RecordSizeofExt'
.file: 'test/lang.reflect.ci'
.line: 26
.field y: int32 (size: 4 -> variable(i32))
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'test/lang.reflect.ci'
.line: 27
.owner: RecordSizeofExt
.value: 0
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofRecord'
.file: 'test/lang.reflect.ci'
.line: 30
.value: RecordSizeofExt
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfRecord'
.file: 'test/lang.reflect.ci'
.line: 31
.value: typename.name(typeofRecord)
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfRecord'
.file: 'test/lang.reflect.ci'
.line: 32
.value: typeofRecord.offset
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfRecord'
.file: 'test/lang.reflect.ci'
.line: 33
.value: sizeof(typeofRecord)
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfRecord'
.file: 'test/lang.reflect.ci'
.line: 34
.value: typename.file(typeofRecord)
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfRecord'
.file: 'test/lang.reflect.ci'
.line: 35
.value: typename.line(typeofRecord)
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase'
.file: 'test/lang.reflect.ci'
.line: 37
.value: typename.base(typeofRecord)
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfBase'
.file: 'test/lang.reflect.ci'
.line: 38
.value: typename.name(typeofBase)
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase'
.file: 'test/lang.reflect.ci'
.line: 39
.value: typeofBase.offset
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase'
.file: 'test/lang.reflect.ci'
.line: 40
.value: sizeof(typeofBase)
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfBase'
.file: 'test/lang.reflect.ci'
.line: 41
.value: typename.file(typeofBase)
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfBase'
.file: 'test/lang.reflect.ci'
.line: 42
.value: typename.line(typeofBase)
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase1'
.file: 'test/lang.reflect.ci'
.line: 44
.value: typename.base(typeofBase)
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase1'
.file: 'test/lang.reflect.ci'
.line: 45
.value: typeofBase1.offset
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase1'
.file: 'test/lang.reflect.ci'
.line: 46
.value: typeofBase1.size
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase2'
.file: 'test/lang.reflect.ci'
.line: 48
.value: typename.base(typeofBase1)
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase2'
.file: 'test/lang.reflect.ci'
.line: 49
.value: typeofBase2.offset
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase2'
.file: 'test/lang.reflect.ci'
.line: 50
.value: typeofBase2.size
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'pi64'
.file: 'test/stdc.number.ci'
.line: 3
.value: 3.141593
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'e64'
.file: 'test/stdc.number.ci'
.line: 4
.value: 2.718282
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'pi32'
.file: 'test/stdc.number.ci'
.line: 6
.value: pi64
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'e32'
.file: 'test/stdc.number.ci'
.line: 7
.value: e64
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb888'
.file: 'test/stdc.number.ci'
.line: 10
.param .result: int32 (size: 4 -> i32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb565'
.file: 'test/stdc.number.ci'
.line: 12
.param .result: int32 (size: 4 -> i32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r_comp'
.file: 'test/stdc.number.ci'
.line: 14
.value: 14 << 3
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'g_comp'
.file: 'test/stdc.number.ci'
.line: 15
.value: 63 << 2
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'b_comp'
.file: 'test/stdc.number.ci'
.line: 16
.value: 31 << 3
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r5g6b5'
.file: 'test/stdc.number.ci'
.line: 18
.value: rgb565(r_comp, g_comp, b_comp)
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r8g8b8'
.file: 'test/stdc.number.ci'
.line: 19
.value: rgb888(r_comp, g_comp, b_comp)
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR5'
.file: 'test/stdc.number.ci'
.line: 21
.value: uint32.zxt(r5g6b5, 11, 5)
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG6'
.file: 'test/stdc.number.ci'
.line: 22
.value: uint32.zxt(r5g6b5, 5, 6)
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB5'
.file: 'test/stdc.number.ci'
.line: 23
.value: uint32.zxt(r5g6b5, 0, 5)
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR5'
.file: 'test/stdc.number.ci'
.line: 25
.value: uint32.sxt(r5g6b5, 11, 5)
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG6'
.file: 'test/stdc.number.ci'
.line: 26
.value: uint32.sxt(r5g6b5, 5, 6)
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB5'
.file: 'test/stdc.number.ci'
.line: 27
.value: uint32.sxt(r5g6b5, 0, 5)
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR8'
.file: 'test/stdc.number.ci'
.line: 29
.value: uint32.zxt(r8g8b8, 16, 8)
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG8'
.file: 'test/stdc.number.ci'
.line: 30
.value: uint32.zxt(r8g8b8, 8, 8)
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB8'
.file: 'test/stdc.number.ci'
.line: 31
.value: uint32.zxt(r8g8b8, 0, 8)
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR8'
.file: 'test/stdc.number.ci'
.line: 33
.value: uint32.sxt(r8g8b8, 16, 8)
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG8'
.file: 'test/stdc.number.ci'
.line: 34
.value: uint32.sxt(r8g8b8, 8, 8)
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB8'
.file: 'test/stdc.number.ci'
.line: 35
.value: uint32.sxt(r8g8b8, 0, 8)
}
sinF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'sinF64'
.file: 'test/stdc.number.ci'
.line: 37
.value: float64.sin(pi64 / (2))
}
cosF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'cosF64'
.file: 'test/stdc.number.ci'
.line: 38
.value: float64.cos(pi64 / (2))
}
tanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'tanF64'
.file: 'test/stdc.number.ci'
.line: 39
.value: float64.tan(pi64 / (4))
}
logF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'logF64'
.file: 'test/stdc.number.ci'
.line: 40
.value: float64.log(e64 * e64 * e64)
}
expF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'expF64'
.file: 'test/stdc.number.ci'
.line: 41
.value: float64.exp(1.000000)
}
powF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'powF64'
.file: 'test/stdc.number.ci'
.line: 42
.value: float64.pow(pi64 * pi64, 0.500000)
}
sqrtF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'sqrtF64'
.file: 'test/stdc.number.ci'
.line: 43
.value: float64.sqrt(pi64 * pi64)
}
atanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'atanF64'
.file: 'test/stdc.number.ci'
.line: 44
.value: float64.atan2(pi64, 1.000000)
}
sinF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'sinF32'
.file: 'test/stdc.number.ci'
.line: 46
.value: float32.sin(pi32 / (2))
}
cosF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'cosF32'
.file: 'test/stdc.number.ci'
.line: 47
.value: float32.cos(pi32 / (2))
}
tanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'tanF32'
.file: 'test/stdc.number.ci'
.line: 48
.value: float32.tan(pi32 / (4))
}
logF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'logF32'
.file: 'test/stdc.number.ci'
.line: 49
.value: float32.log(e32 * e32 * e32)
}
expF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'expF32'
.file: 'test/stdc.number.ci'
.line: 50
.value: float32.exp(1.000000)
}
powF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'powF32'
.file: 'test/stdc.number.ci'
.line: 51
.value: float32.pow(pi32 * pi32, 0.500000)
}
sqrtF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'sqrtF32'
.file: 'test/stdc.number.ci'
.line: 52
.value: float32.sqrt(pi32 * pi32)
}
atanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'atanF32'
.file: 'test/stdc.number.ci'
.line: 53
.value: float32.atan2(pi32, 1.000000)
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'realloc'
.file: 'test/stdc.memory.ci'
.line: 3
.param .result: pointer (size: 4 -> ref)
.param data: pointer (size: 4 -> ref)
.param size: int32 (size: 4 -> i32)
.value: pointer.alloc(data, size)
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'malloc'
.file: 'test/stdc.memory.ci'
.line: 4
.param .result: pointer (size: 4 -> ref)
.param size: int32 (size: 4 -> i32)
.value: pointer.alloc(null, size)
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'free'
.file: 'test/stdc.memory.ci'
.line: 5
.param .result: pointer (size: 4 -> ref)
.param data: pointer (size: 4 -> ref)
.value: pointer.alloc(data, 0)
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p1'
.file: 'test/stdc.memory.ci'
.line: 7
.value: malloc(1024)
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p2'
.file: 'test/stdc.memory.ci'
.line: 8
.value: malloc(80)
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p3'
.file: 'test/stdc.memory.ci'
.line: 9
.value: malloc(160)
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p4'
.file: 'test/stdc.memory.ci'
.line: 10
.value: malloc(820)
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val1'
.file: 'test/stdc.memory.ci'
.line: 23
.value: 42
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val2'
.file: 'test/stdc.memory.ci'
.line: 24
.value: 96
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.name: 'noError'
.file: 'test/stdc.execute.ci'
.line: 11
.param .result: void (size: 0 -> variable(void))
.param ptr: pointer (size: 4 -> variable(ref))
.value: {
}
.instructions: (1 bytes)
	<noError+?>:    ret
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'stackOverflow'
.file: 'test/stdc.execute.ci'
.line: 14
.param .result: void (size: 0 -> variable(void))
.param ptr: pointer (size: 4 -> variable(ref))
.value: {
	data: uint8[1024];
	stackOverflow(ptr);
}
.instructions: (24 bytes)
	test/stdc.execute.ci:15: (4 bytes): data: uint8[1024]
	<stackOverflow+?>:    inc.sp(+1024)
	test/stdc.execute.ci:16: (15 bytes): stackOverflow(ptr);
	<stackOverflow+?>:    load.sp(+1028)
	<stackOverflow+?>:    load.i32
	<stackOverflow+?>:    load.ref .?????? ;stackOverflow(ptr: pointer): void
	<stackOverflow+?>:    call
	<stackOverflow+?>:    inc.sp(-4)
	<stackOverflow+?>:    inc.sp(-1024)
	<stackOverflow+?>:    ret
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'divisionByZero'
.file: 'test/stdc.execute.ci'
.line: 19
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	value: int32 := 3 / 0;
}
.instructions: (12 bytes)
	test/stdc.execute.ci:20: (7 bytes): value: int32 := 3 / 0
	<divisionByZero+?>:    load.c32 3
	<divisionByZero+?>:    load.z32
	<divisionByZero+?>:    div.i32
	<divisionByZero+?>:    inc.sp(-4)
	<divisionByZero+?>:    ret
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 64
.name: 'abortExecution'
.file: 'test/stdc.execute.ci'
.line: 23
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		details.message := ("assertion failed");
		details.expected := 97;
		details.returned := 77;
	};
	raise(raise.abort, raise.noTrace, "fatal error", details);
}
.instructions: (64 bytes)
	test/stdc.execute.ci:29: (25 bytes): details: NotEquals := {...}
	<abortExecution+?>:    inc.sp(+16)
	test/stdc.execute.ci:30: (7 bytes): details.message := ("assertion failed");
	<abortExecution+?>:    load.ref .?????? ;"assertion failed"
	<abortExecution+?>:    set.x1 sp(1)
	test/stdc.execute.ci:31: (7 bytes): details.expected := 97;
	<abortExecution+?>:    load.c32 97
	<abortExecution+?>:    set.x1 sp(2)
	test/stdc.execute.ci:32: (7 bytes): details.returned := 77;
	<abortExecution+?>:    load.c32 77
	<abortExecution+?>:    set.x1 sp(3)
	test/stdc.execute.ci:34: (34 bytes): raise(raise.abort, raise.noTrace, "fatal error", details);
	<abortExecution+?>:    load.ref .?????? ;"test/stdc.execute.ci"
	<abortExecution+?>:    load.c32 34
	<abortExecution+?>:    load.c32 -1
	<abortExecution+?>:    load.z32
	<abortExecution+?>:    load.ref .?????? ;"fatal error"
	<abortExecution+?>:    load.ref .?????? ;abortExecution.NotEquals
	<abortExecution+?>:    load.sp(+24)
	<abortExecution+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+?>:    inc.sp(-16)
	<abortExecution+?>:    ret
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.name: 'invalidMemoryAccess'
.file: 'test/stdc.execute.ci'
.line: 37
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes)
	test/stdc.execute.ci:38: (5 bytes): i32Ref: int32 := null
	<invalidMemoryAccess+?>:    load.ref .?????? ;null
	test/stdc.execute.ci:39: (3 bytes): i32Val: int32 := i32Ref
	<invalidMemoryAccess+?>:    dup.x1 sp(0)
	<invalidMemoryAccess+?>:    load.i32
	<invalidMemoryAccess+?>:    inc.sp(-8)
	<invalidMemoryAccess+?>:    ret
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.name: 'invalidInstruction'
.file: 'test/stdc.execute.ci'
.line: 42
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	emit(load.z32, ret);
}
.instructions: (2 bytes)
	test/stdc.execute.ci:43: (2 bytes): emit(load.z32, ret);
	<invalidInstruction+?>:    load.z32
	<invalidInstruction+?>:    ret
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr0'
.file: 'test/stdc.execute.ci'
.line: 46
.value: tryExec(null, noError)
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr1'
.file: 'test/stdc.execute.ci'
.line: 47
.value: tryExec(null, null)
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr2'
.file: 'test/stdc.execute.ci'
.line: 48
.value: tryExec(null, stackOverflow)
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr3'
.file: 'test/stdc.execute.ci'
.line: 49
.value: tryExec(null, divisionByZero)
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr4'
.file: 'test/stdc.execute.ci'
.line: 50
.value: tryExec(null, invalidInstruction)
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr5'
.file: 'test/stdc.execute.ci'
.line: 51
.value: tryExec(null, invalidMemoryAccess)
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr6'
.file: 'test/stdc.execute.ci'
.line: 52
.value: tryExec(null, abortExecution)
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.name: 'arrFixedNoInit'
.file: 'test/lang.array.ci'
.line: 49
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayNoInit'
.file: 'test/lang.array.ci'
.line: 50
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceNoInit'
.file: 'test/lang.array.ci'
.line: 51
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitNull'
.file: 'test/lang.array.ci'
.line: 59
.value: null
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitNull'
.file: 'test/lang.array.ci'
.line: 60
.value: null
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitFixed'
.file: 'test/lang.array.ci'
.line: 63
.value: arrFixedNoInit
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitFixed'
.file: 'test/lang.array.ci'
.line: 64
.value: arrFixedNoInit
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitSlice'
.file: 'test/lang.array.ci'
.line: 67
.value: arrSliceInitFixed
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitSlice'
.file: 'test/lang.array.ci'
.line: 68
.value: arrSliceInitFixed
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitPtr'
.file: 'test/lang.array.ci'
.line: 71
.value: arrArrayInitFixed
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.name: 'strFixed'
.file: 'test/lang.array.ci'
.line: 81
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'strArray'
.file: 'test/lang.array.ci'
.line: 86
.value: "string"
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'strSlice'
.file: 'test/lang.array.ci'
.line: 90
.value: "string"
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 5
.name: 'lenSlice'
.file: 'test/lang.array.ci'
.line: 103
.param .result: int32 (size: 4 -> variable(i32))
.param values: int64[] (size: 8 -> variable(arr))
.value: {
	return .result := values.length;
}
.instructions: (5 bytes)
	test/lang.array.ci:103: (5 bytes): return .result := values.length;
	<lenSlice+?>:    dup.x1 sp(2)
	<lenSlice+?>:    set.x1 sp(4)
	<lenSlice+?>:    ret
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthFixed'
.file: 'test/lang.array.ci'
.line: 104
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[7] (size: 4 -> variable(ref))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:104: (12 bytes): return .result := values[idx];
	<nthFixed+?>:    dup.x1 sp(1)
	<nthFixed+?>:    dup.x1 sp(3)
	<nthFixed+?>:    mad.u32 8
	<nthFixed+?>:    load.i64
	<nthFixed+?>:    set.x2 sp(5)
	<nthFixed+?>:    ret
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthArray'
.file: 'test/lang.array.ci'
.line: 105
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[*] (size: 4 -> variable(ref))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:105: (12 bytes): return .result := values[idx];
	<nthArray+?>:    dup.x1 sp(1)
	<nthArray+?>:    dup.x1 sp(3)
	<nthArray+?>:    mad.u32 8
	<nthArray+?>:    load.i64
	<nthArray+?>:    set.x2 sp(5)
	<nthArray+?>:    ret
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthSlice'
.file: 'test/lang.array.ci'
.line: 106
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[] (size: 8 -> variable(arr))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:106: (12 bytes): return .result := values[idx];
	<nthSlice+?>:    dup.x1 sp(1)
	<nthSlice+?>:    dup.x1 sp(4)
	<nthSlice+?>:    mad.u32 8
	<nthSlice+?>:    load.i64
	<nthSlice+?>:    set.x2 sp(6)
	<nthSlice+?>:    ret
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'RecordMemberTest'
.file: 'test/lang.member.ci'
.line: 3
.field Inner: typename (size: 8 -> static const typename(val))
.field member: int32 (size: 4 -> variable(i32))
.field constant: int32 (size: 4 -> const variable(i32))
.field memberInit: int32 (size: 4 -> variable(i32))
.field constantInit: int32 (size: 4 -> const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8 -> variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8 -> const variable(val))
.field global: int32 (size: 4 -> static variable(i32))
.field globalInit: int32 (size: 4 -> static variable(i32))
.field globalConstant: int32 (size: 4 -> static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8 -> static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8 -> static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8 -> static const variable(val))
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Inner'
.file: 'test/lang.member.ci'
.line: 5
.owner: RecordMemberTest
.field member: int32 (size: 4 -> variable(i32))
.field constant: int32 (size: 4 -> const variable(i32))
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'test/lang.member.ci'
.line: 6
.owner: RecordMemberTest.Inner
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'test/lang.member.ci'
.line: 7
.owner: RecordMemberTest.Inner
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'test/lang.member.ci'
.line: 11
.owner: RecordMemberTest
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'test/lang.member.ci'
.line: 14
.owner: RecordMemberTest
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'memberInit'
.file: 'test/lang.member.ci'
.line: 17
.owner: RecordMemberTest
.value: 2
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constantInit'
.file: 'test/lang.member.ci'
.line: 20
.owner: RecordMemberTest
.value: 3
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'memberRec'
.file: 'test/lang.member.ci'
.line: 23
.owner: RecordMemberTest
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'constantRec'
.file: 'test/lang.member.ci'
.line: 26
.owner: RecordMemberTest
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'global'
.file: 'test/lang.member.ci'
.line: 35
.owner: RecordMemberTest
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'globalInit'
.file: 'test/lang.member.ci'
.line: 38
.owner: RecordMemberTest
.value: 5
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'globalConstant'
.file: 'test/lang.member.ci'
.line: 41
.owner: RecordMemberTest
.value: 6
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRec'
.file: 'test/lang.member.ci'
.line: 44
.owner: RecordMemberTest
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRecInit'
.file: 'test/lang.member.ci'
.line: 47
.owner: RecordMemberTest
.value: {
	globalRecInit.member := 51;
	globalRecInit.constant := 52;
}
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalConstantRec'
.file: 'test/lang.member.ci'
.line: 50
.owner: RecordMemberTest
.value: {
	globalConstantRec.member := 61;
	globalConstantRec.constant := 62;
}
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.name: 'recordMemberTest'
.file: 'test/lang.member.ci'
.line: 53
.value: {
	recordMemberTest.member := 6;
	recordMemberTest.constant := 7;
	recordMemberTest.memberInit := 8;
	recordMemberTest.constantInit := 9;
	recordMemberTest.memberRec.member := 61;
	recordMemberTest.memberRec.constant := 62;
	recordMemberTest.constantRec.member := 71;
	recordMemberTest.constantRec.constant := 72;
}
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'RecordMethodTest'
.file: 'test/lang.method.ci'
.line: 3
.field staticMethod: function (size: 8 -> static const function)
.field forwardMethod: function (size: 4 -> static variable(ref))
.field abstractMethod: function (size: 4 -> variable(ref))
.field delegateMethod: function (size: 4 -> variable(ref))
.field virtualMethod: function (size: 8 -> static const function)
.field virtualMethod: function (size: 4 -> variable(ref))
.field forwardMethod: function (size: 8 -> static const function)
}
RecordMethodTest.staticMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'staticMethod'
.file: 'test/lang.method.ci'
.line: 6
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	test/lang.method.ci:7: (8 bytes): return .result := x + y;
	<staticMethod+?>:    dup.x1 sp(2)
	<staticMethod+?>:    dup.x1 sp(2)
	<staticMethod+?>:    add.i32
	<staticMethod+?>:    set.x1 sp(4)
	<staticMethod+?>:    ret
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'forwardMethod'
.file: 'test/lang.method.ci'
.line: 12
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: forwardMethod
}
RecordMethodTest.abstractMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'abstractMethod'
.file: 'test/lang.method.ci'
.line: 16
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
}
RecordMethodTest.delegateMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'delegateMethod'
.file: 'test/lang.method.ci'
.line: 20
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: forwardMethod
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'virtualMethod'
.file: 'test/lang.method.ci'
.line: 26
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:27: (8 bytes): return .result := x * y;
	<virtualMethod+?>:    dup.x1 sp(2)
	<virtualMethod+?>:    dup.x1 sp(2)
	<virtualMethod+?>:    mul.i32
	<virtualMethod+?>:    set.x1 sp(4)
	<virtualMethod+?>:    ret
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'virtualMethod'
.file: 'test/lang.method.ci'
.line: 26
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: virtualMethod
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'forwardMethod'
.file: 'test/lang.method.ci'
.line: 31
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:32: (8 bytes): return .result := x * y;
	<forwardMethod+?>:    dup.x1 sp(2)
	<forwardMethod+?>:    dup.x1 sp(2)
	<forwardMethod+?>:    mul.i32
	<forwardMethod+?>:    set.x1 sp(4)
	<forwardMethod+?>:    ret
}
globalFunction(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'globalFunction'
.file: 'test/lang.method.ci'
.line: 41
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:42: (8 bytes): return .result := x * y;
	<globalFunction+?>:    dup.x1 sp(2)
	<globalFunction+?>:    dup.x1 sp(2)
	<globalFunction+?>:    mul.i32
	<globalFunction+?>:    set.x1 sp(4)
	<globalFunction+?>:    ret
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.name: 'recordMethodTest'
.file: 'test/lang.method.ci'
.line: 45
.value: {
	recordMethodTest.delegateMethod := globalFunction;
	recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
	recordMethodTest.virtualMethod := virtualMethod;
}
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'rgbF32'
.file: 'test/lang.recUnion.ci'
.line: 2
.field r: float32 (size: 4 -> variable(f32))
.field g: float32 (size: 4 -> variable(f32))
.field b: float32 (size: 4 -> variable(f32))
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'r'
.file: 'test/lang.recUnion.ci'
.line: 3
.owner: rgbF32
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'g'
.file: 'test/lang.recUnion.ci'
.line: 4
.owner: rgbF32
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'b'
.file: 'test/lang.recUnion.ci'
.line: 5
.owner: rgbF32
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.name: 'rgbU8'
.file: 'test/lang.recUnion.ci'
.line: 9
.field b: uint8 (size: 1 -> variable(u32))
.field g: uint8 (size: 1 -> variable(u32))
.field r: uint8 (size: 1 -> variable(u32))
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'test/lang.recUnion.ci'
.line: 10
.owner: rgbU8
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'test/lang.recUnion.ci'
.line: 11
.owner: rgbU8
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'test/lang.recUnion.ci'
.line: 12
.owner: rgbU8
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'color'
.file: 'test/lang.recUnion.ci'
.line: 16
.field col: uint32 (size: 4 -> variable(u32))
.field rgb: rgbU8 (size: 3 -> variable(val))
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'col'
.file: 'test/lang.recUnion.ci'
.line: 17
.owner: color
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'rgb'
.file: 'test/lang.recUnion.ci'
.line: 18
.owner: color
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'Color'
.file: 'test/lang.recUnion.ci'
.line: 22
.field value: rgbF32 (size: 16 -> variable(val))
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.name: 'value'
.file: 'test/lang.recUnion.ci'
.line: 23
.owner: Color
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'black'
.file: 'test/lang.recUnion.ci'
.line: 26
.value: {
	black.r := (0);
	black.g := (0);
	black.b := (0);
}
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'green'
.file: 'test/lang.recUnion.ci'
.line: 27
.value: {
	green.r := (0);
	green.g := (255);
	green.b := (0);
}
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'white'
.file: 'test/lang.recUnion.ci'
.line: 28
.value: {
	white.r := (255);
	white.g := (255);
	white.b := (255);
}
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'cyan'
.file: 'test/lang.recUnion.ci'
.line: 30
.value: {
	cyan.col := (65535);
}
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'blue'
.file: 'test/lang.recUnion.ci'
.line: 31
.value: {
	blue.rgb.r := (0);
	blue.rgb.g := (0);
	blue.rgb.b := (255);
}
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'record_pack0'
.file: 'test/lang.recPacking.ci'
.line: 2
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 3
.owner: record_pack0
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 4
.owner: record_pack0
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 5
.owner: record_pack0
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 6
.owner: record_pack0
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 7
.owner: record_pack0
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 8
.owner: record_pack0
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.name: 'record_pack1'
.file: 'test/lang.recPacking.ci'
.line: 12
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 13
.owner: record_pack1
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 14
.owner: record_pack1
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 15
.owner: record_pack1
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 16
.owner: record_pack1
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 17
.owner: record_pack1
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 18
.owner: record_pack1
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.name: 'record_pack2'
.file: 'test/lang.recPacking.ci'
.line: 22
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 23
.owner: record_pack2
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 24
.owner: record_pack2
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 25
.owner: record_pack2
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 26
.owner: record_pack2
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 27
.owner: record_pack2
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 28
.owner: record_pack2
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'record_pack4'
.file: 'test/lang.recPacking.ci'
.line: 32
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 33
.owner: record_pack4
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 34
.owner: record_pack4
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 35
.owner: record_pack4
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 36
.owner: record_pack4
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 37
.owner: record_pack4
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 38
.owner: record_pack4
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_pack8'
.file: 'test/lang.recPacking.ci'
.line: 42
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 43
.owner: record_pack8
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 44
.owner: record_pack8
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 45
.owner: record_pack8
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 46
.owner: record_pack8
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 47
.owner: record_pack8
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 48
.owner: record_pack8
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_packDef'
.file: 'test/lang.recPacking.ci'
.line: 52
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci'
.line: 53
.owner: record_packDef
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci'
.line: 54
.owner: record_packDef
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci'
.line: 55
.owner: record_packDef
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci'
.line: 56
.owner: record_packDef
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci'
.line: 57
.owner: record_packDef
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci'
.line: 58
.owner: record_packDef
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'a'
.file: 'test/lang.useOperator.ci'
.line: 3
.value: 96.300000
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'b'
.file: 'test/lang.useOperator.ci'
.line: 4
.value: 42.140000
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'shift'
.file: 'test/lang.useOperator.ci'
.line: 5
.value: 2
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolA'
.file: 'test/lang.useOperator.ci'
.line: 7
.value: true
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolB'
.file: 'test/lang.useOperator.ci'
.line: 8
.value: !false
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolAnd'
.file: 'test/lang.useOperator.ci'
.line: 17
.value: boolA & boolB
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolIor'
.file: 'test/lang.useOperator.ci'
.line: 18
.value: boolA | boolB
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolXor'
.file: 'test/lang.useOperator.ci'
.line: 19
.value: boolA ^ boolB
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolNot'
.file: 'test/lang.useOperator.ci'
.line: 22
.value: !boolB
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCeq'
.file: 'test/lang.useOperator.ci'
.line: 23
.value: boolA == boolB
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCne'
.file: 'test/lang.useOperator.ci'
.line: 24
.value: boolA != boolB
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolClt'
.file: 'test/lang.useOperator.ci'
.line: 25
.value: boolA < boolB
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCle'
.file: 'test/lang.useOperator.ci'
.line: 26
.value: boolA <= boolB
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCgt'
.file: 'test/lang.useOperator.ci'
.line: 27
.value: boolA > boolB
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCge'
.file: 'test/lang.useOperator.ci'
.line: 28
.value: boolA >= boolB
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrA'
.file: 'test/lang.useOperator.ci'
.line: 30
.value: 'a'
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrB'
.file: 'test/lang.useOperator.ci'
.line: 31
.value: 'b'
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrPls'
.file: 'test/lang.useOperator.ci'
.line: 32
.value: +chrB
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrNeg'
.file: 'test/lang.useOperator.ci'
.line: 33
.value: -chrB
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrCmt'
.file: 'test/lang.useOperator.ci'
.line: 34
.value: ~chrB
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAdd'
.file: 'test/lang.useOperator.ci'
.line: 35
.value: chrA + chrB
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrSub'
.file: 'test/lang.useOperator.ci'
.line: 36
.value: chrA - chrB
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMul'
.file: 'test/lang.useOperator.ci'
.line: 37
.value: chrA * chrB
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrDiv'
.file: 'test/lang.useOperator.ci'
.line: 38
.value: chrA / chrB
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMod'
.file: 'test/lang.useOperator.ci'
.line: 39
.value: chrA % chrB
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAnd'
.file: 'test/lang.useOperator.ci'
.line: 40
.value: chrA & chrB
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrIor'
.file: 'test/lang.useOperator.ci'
.line: 41
.value: chrA | chrB
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrXor'
.file: 'test/lang.useOperator.ci'
.line: 42
.value: chrA ^ chrB
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShl'
.file: 'test/lang.useOperator.ci'
.line: 43
.value: (chrA) << shift
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShr'
.file: 'test/lang.useOperator.ci'
.line: 44
.value: (chrA) >> shift
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrNot'
.file: 'test/lang.useOperator.ci'
.line: 45
.value: !(chrB)
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCeq'
.file: 'test/lang.useOperator.ci'
.line: 46
.value: chrA == chrB
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCne'
.file: 'test/lang.useOperator.ci'
.line: 47
.value: chrA != chrB
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrClt'
.file: 'test/lang.useOperator.ci'
.line: 48
.value: chrA < chrB
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCle'
.file: 'test/lang.useOperator.ci'
.line: 49
.value: chrA <= chrB
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCgt'
.file: 'test/lang.useOperator.ci'
.line: 50
.value: chrA > chrB
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCge'
.file: 'test/lang.useOperator.ci'
.line: 51
.value: chrA >= chrB
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8A'
.file: 'test/lang.useOperator.ci'
.line: 53
.value: a
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8B'
.file: 'test/lang.useOperator.ci'
.line: 54
.value: b
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Pls'
.file: 'test/lang.useOperator.ci'
.line: 55
.value: +i8B
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Neg'
.file: 'test/lang.useOperator.ci'
.line: 56
.value: -i8B
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Cmt'
.file: 'test/lang.useOperator.ci'
.line: 57
.value: ~i8B
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Add'
.file: 'test/lang.useOperator.ci'
.line: 58
.value: i8A + i8B
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Sub'
.file: 'test/lang.useOperator.ci'
.line: 59
.value: i8A - i8B
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mul'
.file: 'test/lang.useOperator.ci'
.line: 60
.value: i8A * i8B
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Div'
.file: 'test/lang.useOperator.ci'
.line: 61
.value: i8A / i8B
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mod'
.file: 'test/lang.useOperator.ci'
.line: 62
.value: i8A % i8B
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8And'
.file: 'test/lang.useOperator.ci'
.line: 63
.value: i8A & i8B
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Ior'
.file: 'test/lang.useOperator.ci'
.line: 64
.value: i8A | i8B
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Xor'
.file: 'test/lang.useOperator.ci'
.line: 65
.value: i8A ^ i8B
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shl'
.file: 'test/lang.useOperator.ci'
.line: 66
.value: (i8A) << shift
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shr'
.file: 'test/lang.useOperator.ci'
.line: 67
.value: (i8A) >> shift
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Not'
.file: 'test/lang.useOperator.ci'
.line: 68
.value: !(i8B)
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Ceq'
.file: 'test/lang.useOperator.ci'
.line: 69
.value: i8A == i8B
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cne'
.file: 'test/lang.useOperator.ci'
.line: 70
.value: i8A != i8B
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Clt'
.file: 'test/lang.useOperator.ci'
.line: 71
.value: i8A < i8B
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cle'
.file: 'test/lang.useOperator.ci'
.line: 72
.value: i8A <= i8B
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cgt'
.file: 'test/lang.useOperator.ci'
.line: 73
.value: i8A > i8B
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cge'
.file: 'test/lang.useOperator.ci'
.line: 74
.value: i8A >= i8B
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8A'
.file: 'test/lang.useOperator.ci'
.line: 76
.value: a
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8B'
.file: 'test/lang.useOperator.ci'
.line: 77
.value: b
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Pls'
.file: 'test/lang.useOperator.ci'
.line: 78
.value: +u8B
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Neg'
.file: 'test/lang.useOperator.ci'
.line: 79
.value: -u8B
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Cmt'
.file: 'test/lang.useOperator.ci'
.line: 80
.value: ~u8B
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Add'
.file: 'test/lang.useOperator.ci'
.line: 81
.value: u8A + u8B
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Sub'
.file: 'test/lang.useOperator.ci'
.line: 82
.value: u8A - u8B
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mul'
.file: 'test/lang.useOperator.ci'
.line: 83
.value: u8A * u8B
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Div'
.file: 'test/lang.useOperator.ci'
.line: 84
.value: u8A / u8B
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mod'
.file: 'test/lang.useOperator.ci'
.line: 85
.value: u8A % u8B
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8And'
.file: 'test/lang.useOperator.ci'
.line: 86
.value: u8A & u8B
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Ior'
.file: 'test/lang.useOperator.ci'
.line: 87
.value: u8A | u8B
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Xor'
.file: 'test/lang.useOperator.ci'
.line: 88
.value: u8A ^ u8B
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shl'
.file: 'test/lang.useOperator.ci'
.line: 89
.value: (u8A) << shift
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shr'
.file: 'test/lang.useOperator.ci'
.line: 90
.value: (u8A) >> shift
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Not'
.file: 'test/lang.useOperator.ci'
.line: 91
.value: !(u8B)
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Ceq'
.file: 'test/lang.useOperator.ci'
.line: 92
.value: u8A == u8B
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cne'
.file: 'test/lang.useOperator.ci'
.line: 93
.value: u8A != u8B
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Clt'
.file: 'test/lang.useOperator.ci'
.line: 94
.value: u8A < u8B
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cle'
.file: 'test/lang.useOperator.ci'
.line: 95
.value: u8A <= u8B
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cgt'
.file: 'test/lang.useOperator.ci'
.line: 96
.value: u8A > u8B
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cge'
.file: 'test/lang.useOperator.ci'
.line: 97
.value: u8A >= u8B
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16A'
.file: 'test/lang.useOperator.ci'
.line: 99
.value: a
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16B'
.file: 'test/lang.useOperator.ci'
.line: 100
.value: b
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Pls'
.file: 'test/lang.useOperator.ci'
.line: 101
.value: +i16B
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Neg'
.file: 'test/lang.useOperator.ci'
.line: 102
.value: -i16B
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Cmt'
.file: 'test/lang.useOperator.ci'
.line: 103
.value: ~i16B
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Add'
.file: 'test/lang.useOperator.ci'
.line: 104
.value: i16A + i16B
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Sub'
.file: 'test/lang.useOperator.ci'
.line: 105
.value: i16A - i16B
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mul'
.file: 'test/lang.useOperator.ci'
.line: 106
.value: i16A * i16B
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Div'
.file: 'test/lang.useOperator.ci'
.line: 107
.value: i16A / i16B
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mod'
.file: 'test/lang.useOperator.ci'
.line: 108
.value: i16A % i16B
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16And'
.file: 'test/lang.useOperator.ci'
.line: 109
.value: i16A & i16B
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Ior'
.file: 'test/lang.useOperator.ci'
.line: 110
.value: i16A | i16B
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Xor'
.file: 'test/lang.useOperator.ci'
.line: 111
.value: i16A ^ i16B
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shl'
.file: 'test/lang.useOperator.ci'
.line: 112
.value: (i16A) << shift
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shr'
.file: 'test/lang.useOperator.ci'
.line: 113
.value: (i16A) >> shift
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Not'
.file: 'test/lang.useOperator.ci'
.line: 114
.value: !(i16B)
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Ceq'
.file: 'test/lang.useOperator.ci'
.line: 115
.value: i16A == i16B
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cne'
.file: 'test/lang.useOperator.ci'
.line: 116
.value: i16A != i16B
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Clt'
.file: 'test/lang.useOperator.ci'
.line: 117
.value: i16A < i16B
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cle'
.file: 'test/lang.useOperator.ci'
.line: 118
.value: i16A <= i16B
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cgt'
.file: 'test/lang.useOperator.ci'
.line: 119
.value: i16A > i16B
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cge'
.file: 'test/lang.useOperator.ci'
.line: 120
.value: i16A >= i16B
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16A'
.file: 'test/lang.useOperator.ci'
.line: 122
.value: a
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16B'
.file: 'test/lang.useOperator.ci'
.line: 123
.value: b
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Pls'
.file: 'test/lang.useOperator.ci'
.line: 124
.value: +u16B
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Neg'
.file: 'test/lang.useOperator.ci'
.line: 125
.value: -u16B
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Cmt'
.file: 'test/lang.useOperator.ci'
.line: 126
.value: ~u16B
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Add'
.file: 'test/lang.useOperator.ci'
.line: 127
.value: u16A + u16B
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Sub'
.file: 'test/lang.useOperator.ci'
.line: 128
.value: u16A - u16B
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mul'
.file: 'test/lang.useOperator.ci'
.line: 129
.value: u16A * u16B
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Div'
.file: 'test/lang.useOperator.ci'
.line: 130
.value: u16A / u16B
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mod'
.file: 'test/lang.useOperator.ci'
.line: 131
.value: u16A % u16B
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16And'
.file: 'test/lang.useOperator.ci'
.line: 132
.value: u16A & u16B
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Ior'
.file: 'test/lang.useOperator.ci'
.line: 133
.value: u16A | u16B
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Xor'
.file: 'test/lang.useOperator.ci'
.line: 134
.value: u16A ^ u16B
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shl'
.file: 'test/lang.useOperator.ci'
.line: 135
.value: (u16A) << shift
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shr'
.file: 'test/lang.useOperator.ci'
.line: 136
.value: (u16A) >> shift
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Not'
.file: 'test/lang.useOperator.ci'
.line: 137
.value: !(u16B)
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Ceq'
.file: 'test/lang.useOperator.ci'
.line: 138
.value: u16A == u16B
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cne'
.file: 'test/lang.useOperator.ci'
.line: 139
.value: u16A != u16B
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Clt'
.file: 'test/lang.useOperator.ci'
.line: 140
.value: u16A < u16B
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cle'
.file: 'test/lang.useOperator.ci'
.line: 141
.value: u16A <= u16B
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cgt'
.file: 'test/lang.useOperator.ci'
.line: 142
.value: u16A > u16B
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cge'
.file: 'test/lang.useOperator.ci'
.line: 143
.value: u16A >= u16B
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32A'
.file: 'test/lang.useOperator.ci'
.line: 145
.value: a
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32B'
.file: 'test/lang.useOperator.ci'
.line: 146
.value: b
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Pls'
.file: 'test/lang.useOperator.ci'
.line: 147
.value: +i32B
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Neg'
.file: 'test/lang.useOperator.ci'
.line: 148
.value: -i32B
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Cmt'
.file: 'test/lang.useOperator.ci'
.line: 149
.value: ~i32B
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Add'
.file: 'test/lang.useOperator.ci'
.line: 150
.value: i32A + i32B
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Sub'
.file: 'test/lang.useOperator.ci'
.line: 151
.value: i32A - i32B
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mul'
.file: 'test/lang.useOperator.ci'
.line: 152
.value: i32A * i32B
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Div'
.file: 'test/lang.useOperator.ci'
.line: 153
.value: i32A / i32B
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mod'
.file: 'test/lang.useOperator.ci'
.line: 154
.value: i32A % i32B
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32And'
.file: 'test/lang.useOperator.ci'
.line: 155
.value: i32A & i32B
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Ior'
.file: 'test/lang.useOperator.ci'
.line: 156
.value: i32A | i32B
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Xor'
.file: 'test/lang.useOperator.ci'
.line: 157
.value: i32A ^ i32B
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shl'
.file: 'test/lang.useOperator.ci'
.line: 158
.value: i32A << shift
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shr'
.file: 'test/lang.useOperator.ci'
.line: 159
.value: i32A >> shift
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Not'
.file: 'test/lang.useOperator.ci'
.line: 160
.value: !(i32B)
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Ceq'
.file: 'test/lang.useOperator.ci'
.line: 161
.value: i32A == i32B
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cne'
.file: 'test/lang.useOperator.ci'
.line: 162
.value: i32A != i32B
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Clt'
.file: 'test/lang.useOperator.ci'
.line: 163
.value: i32A < i32B
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cle'
.file: 'test/lang.useOperator.ci'
.line: 164
.value: i32A <= i32B
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cgt'
.file: 'test/lang.useOperator.ci'
.line: 165
.value: i32A > i32B
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cge'
.file: 'test/lang.useOperator.ci'
.line: 166
.value: i32A >= i32B
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32A'
.file: 'test/lang.useOperator.ci'
.line: 168
.value: a
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32B'
.file: 'test/lang.useOperator.ci'
.line: 169
.value: b
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Pls'
.file: 'test/lang.useOperator.ci'
.line: 170
.value: +u32B
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Neg'
.file: 'test/lang.useOperator.ci'
.line: 171
.value: -u32B
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Cmt'
.file: 'test/lang.useOperator.ci'
.line: 172
.value: ~u32B
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Add'
.file: 'test/lang.useOperator.ci'
.line: 173
.value: u32A + u32B
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Sub'
.file: 'test/lang.useOperator.ci'
.line: 174
.value: u32A - u32B
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mul'
.file: 'test/lang.useOperator.ci'
.line: 175
.value: u32A * u32B
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Div'
.file: 'test/lang.useOperator.ci'
.line: 176
.value: u32A / u32B
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mod'
.file: 'test/lang.useOperator.ci'
.line: 177
.value: u32A % u32B
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32And'
.file: 'test/lang.useOperator.ci'
.line: 178
.value: u32A & u32B
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Ior'
.file: 'test/lang.useOperator.ci'
.line: 179
.value: u32A | u32B
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Xor'
.file: 'test/lang.useOperator.ci'
.line: 180
.value: u32A ^ u32B
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shl'
.file: 'test/lang.useOperator.ci'
.line: 181
.value: u32A << shift
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shr'
.file: 'test/lang.useOperator.ci'
.line: 182
.value: u32A >> shift
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Not'
.file: 'test/lang.useOperator.ci'
.line: 183
.value: !(u32B)
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Ceq'
.file: 'test/lang.useOperator.ci'
.line: 184
.value: u32A == u32B
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cne'
.file: 'test/lang.useOperator.ci'
.line: 185
.value: u32A != u32B
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Clt'
.file: 'test/lang.useOperator.ci'
.line: 186
.value: u32A < u32B
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cle'
.file: 'test/lang.useOperator.ci'
.line: 187
.value: u32A <= u32B
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cgt'
.file: 'test/lang.useOperator.ci'
.line: 188
.value: u32A > u32B
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cge'
.file: 'test/lang.useOperator.ci'
.line: 189
.value: u32A >= u32B
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64A'
.file: 'test/lang.useOperator.ci'
.line: 191
.value: a
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64B'
.file: 'test/lang.useOperator.ci'
.line: 192
.value: b
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Pls'
.file: 'test/lang.useOperator.ci'
.line: 193
.value: +i64B
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Neg'
.file: 'test/lang.useOperator.ci'
.line: 194
.value: -i64B
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Cmt'
.file: 'test/lang.useOperator.ci'
.line: 195
.value: ~i64B
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Add'
.file: 'test/lang.useOperator.ci'
.line: 196
.value: i64A + i64B
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Sub'
.file: 'test/lang.useOperator.ci'
.line: 197
.value: i64A - i64B
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mul'
.file: 'test/lang.useOperator.ci'
.line: 198
.value: i64A * i64B
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Div'
.file: 'test/lang.useOperator.ci'
.line: 199
.value: i64A / i64B
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mod'
.file: 'test/lang.useOperator.ci'
.line: 200
.value: i64A % i64B
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64And'
.file: 'test/lang.useOperator.ci'
.line: 201
.value: i64A & i64B
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Ior'
.file: 'test/lang.useOperator.ci'
.line: 202
.value: i64A | i64B
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Xor'
.file: 'test/lang.useOperator.ci'
.line: 203
.value: i64A ^ i64B
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shl'
.file: 'test/lang.useOperator.ci'
.line: 204
.value: i64A << shift
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shr'
.file: 'test/lang.useOperator.ci'
.line: 205
.value: i64A >> shift
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Not'
.file: 'test/lang.useOperator.ci'
.line: 206
.value: !(i64B)
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Ceq'
.file: 'test/lang.useOperator.ci'
.line: 207
.value: i64A == i64B
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cne'
.file: 'test/lang.useOperator.ci'
.line: 208
.value: i64A != i64B
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Clt'
.file: 'test/lang.useOperator.ci'
.line: 209
.value: i64A < i64B
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cle'
.file: 'test/lang.useOperator.ci'
.line: 210
.value: i64A <= i64B
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cgt'
.file: 'test/lang.useOperator.ci'
.line: 211
.value: i64A > i64B
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cge'
.file: 'test/lang.useOperator.ci'
.line: 212
.value: i64A >= i64B
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64A'
.file: 'test/lang.useOperator.ci'
.line: 214
.value: a
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64B'
.file: 'test/lang.useOperator.ci'
.line: 215
.value: b
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Pls'
.file: 'test/lang.useOperator.ci'
.line: 216
.value: +u64B
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Neg'
.file: 'test/lang.useOperator.ci'
.line: 217
.value: -u64B
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Cmt'
.file: 'test/lang.useOperator.ci'
.line: 218
.value: ~u64B
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Add'
.file: 'test/lang.useOperator.ci'
.line: 219
.value: u64A + u64B
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Sub'
.file: 'test/lang.useOperator.ci'
.line: 220
.value: u64A - u64B
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mul'
.file: 'test/lang.useOperator.ci'
.line: 221
.value: u64A * u64B
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Div'
.file: 'test/lang.useOperator.ci'
.line: 222
.value: u64A / u64B
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mod'
.file: 'test/lang.useOperator.ci'
.line: 223
.value: u64A % u64B
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64And'
.file: 'test/lang.useOperator.ci'
.line: 224
.value: u64A & u64B
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Ior'
.file: 'test/lang.useOperator.ci'
.line: 225
.value: u64A | u64B
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Xor'
.file: 'test/lang.useOperator.ci'
.line: 226
.value: u64A ^ u64B
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shl'
.file: 'test/lang.useOperator.ci'
.line: 227
.value: u64A << shift
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shr'
.file: 'test/lang.useOperator.ci'
.line: 228
.value: u64A >> shift
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Not'
.file: 'test/lang.useOperator.ci'
.line: 229
.value: !(u64B)
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Ceq'
.file: 'test/lang.useOperator.ci'
.line: 230
.value: u64A == u64B
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cne'
.file: 'test/lang.useOperator.ci'
.line: 231
.value: u64A != u64B
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Clt'
.file: 'test/lang.useOperator.ci'
.line: 232
.value: u64A < u64B
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cle'
.file: 'test/lang.useOperator.ci'
.line: 233
.value: u64A <= u64B
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cgt'
.file: 'test/lang.useOperator.ci'
.line: 234
.value: u64A > u64B
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cge'
.file: 'test/lang.useOperator.ci'
.line: 235
.value: u64A >= u64B
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32A'
.file: 'test/lang.useOperator.ci'
.line: 237
.value: a
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32B'
.file: 'test/lang.useOperator.ci'
.line: 238
.value: b
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Pls'
.file: 'test/lang.useOperator.ci'
.line: 239
.value: +f32B
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Neg'
.file: 'test/lang.useOperator.ci'
.line: 240
.value: -f32B
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Add'
.file: 'test/lang.useOperator.ci'
.line: 242
.value: f32A + f32B
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Sub'
.file: 'test/lang.useOperator.ci'
.line: 243
.value: f32A - f32B
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mul'
.file: 'test/lang.useOperator.ci'
.line: 244
.value: f32A * f32B
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Div'
.file: 'test/lang.useOperator.ci'
.line: 245
.value: f32A / f32B
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mod'
.file: 'test/lang.useOperator.ci'
.line: 246
.value: f32A % f32B
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Not'
.file: 'test/lang.useOperator.ci'
.line: 252
.value: !(f32B)
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Ceq'
.file: 'test/lang.useOperator.ci'
.line: 253
.value: f32A == f32B
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cne'
.file: 'test/lang.useOperator.ci'
.line: 254
.value: f32A != f32B
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Clt'
.file: 'test/lang.useOperator.ci'
.line: 255
.value: f32A < f32B
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cle'
.file: 'test/lang.useOperator.ci'
.line: 256
.value: f32A <= f32B
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cgt'
.file: 'test/lang.useOperator.ci'
.line: 257
.value: f32A > f32B
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cge'
.file: 'test/lang.useOperator.ci'
.line: 258
.value: f32A >= f32B
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64A'
.file: 'test/lang.useOperator.ci'
.line: 260
.value: a
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64B'
.file: 'test/lang.useOperator.ci'
.line: 261
.value: b
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Pls'
.file: 'test/lang.useOperator.ci'
.line: 262
.value: +f64B
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Neg'
.file: 'test/lang.useOperator.ci'
.line: 263
.value: -f64B
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Add'
.file: 'test/lang.useOperator.ci'
.line: 265
.value: f64A + f64B
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Sub'
.file: 'test/lang.useOperator.ci'
.line: 266
.value: f64A - f64B
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mul'
.file: 'test/lang.useOperator.ci'
.line: 267
.value: f64A * f64B
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Div'
.file: 'test/lang.useOperator.ci'
.line: 268
.value: f64A / f64B
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mod'
.file: 'test/lang.useOperator.ci'
.line: 269
.value: f64A % f64B
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Not'
.file: 'test/lang.useOperator.ci'
.line: 275
.value: !(f64B)
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Ceq'
.file: 'test/lang.useOperator.ci'
.line: 276
.value: f64A == f64B
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cne'
.file: 'test/lang.useOperator.ci'
.line: 277
.value: f64A != f64B
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Clt'
.file: 'test/lang.useOperator.ci'
.line: 278
.value: f64A < f64B
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cle'
.file: 'test/lang.useOperator.ci'
.line: 279
.value: f64A <= f64B
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cgt'
.file: 'test/lang.useOperator.ci'
.line: 280
.value: f64A > f64B
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cge'
.file: 'test/lang.useOperator.ci'
.line: 281
.value: f64A >= f64B
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrA'
.file: 'test/lang.useOperator.ci'
.line: 283
.value: null
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrB'
.file: 'test/lang.useOperator.ci'
.line: 284
.value: pointer(shift)
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCeq'
.file: 'test/lang.useOperator.ci'
.line: 299
.value: ptrA == ptrB
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCne'
.file: 'test/lang.useOperator.ci'
.line: 300
.value: ptrA != ptrB
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 't'
.file: 'test/lang.statementIf.ci'
.line: 26
.value: 0
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'forIdx'
.file: 'test/lang.statementFor.ci'
.line: 12
}
.main: function {
.kind: static function
.base: `function`
.size: 7028
.name: '.main'
.print: '.main'
.field typename: typename (size: 136 -> static const typename(ref))
.field void: typename (size: 0 -> static const typename(void))
.field bool: typename (size: 1 -> static const typename(bool))
.field char: typename (size: 1 -> static const typename(i32))
.field int8: typename (size: 1 -> static const typename(i32))
.field int16: typename (size: 2 -> static const typename(i32))
.field int32: typename (size: 4 -> static const typename(i32))
.field int64: typename (size: 8 -> static const typename(i64))
.field uint8: typename (size: 1 -> static const typename(u32))
.field uint16: typename (size: 2 -> static const typename(u32))
.field uint32: typename (size: 4 -> static const typename(u32))
.field uint64: typename (size: 8 -> static const typename(u64))
.field float32: typename (size: 4 -> static const typename(f32))
.field float64: typename (size: 8 -> static const typename(f64))
.field pointer: typename (size: 4 -> static const typename(ref))
.field variant: typename (size: 8 -> static const typename(var))
.field function: typename (size: 4 -> static const typename(ref))
.field object: typename (size: 4 -> static const typename(ref))
.field null: pointer (size: 0 -> static const inline)
.field true: bool (size: 0 -> static const inline)
.field false: bool (size: 0 -> static const inline)
.field int: typename (size: 0 -> static const inline)
.field byte: typename (size: 0 -> static const inline)
.field float: typename (size: 0 -> static const inline)
.field double: typename (size: 0 -> static const inline)
.field .cstr: char (size: 4 -> static const typename(arr))
.field emit: function (size: 0 -> static const typename(void))
.field halt: function (size: 0 -> static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0 -> i64)
.field RAND_MAX: int64 (size: 0 -> i64)
.field raise: function (size: 0 -> static const inline)
.field tryExec: function (size: 0 -> static const inline)
.field System: void (size: 0 -> static const typename(void))
.field verbose: function (size: 0 -> inline)
.field verbose: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assertEq: function (size: 69 -> static const function)
.field assertEq: function (size: 0 -> inline)
.field sizeof: function (size: 0 -> inline)
.field integer: typename (size: 0 -> inline)
.field emitldz32: int32 (size: 4 -> variable(i32))
.field emitldz64: int64 (size: 8 -> variable(i64))
.field emitA: int32 (size: 4 -> variable(i32))
.field emitB: int32 (size: 4 -> variable(i32))
.field emitAddI32: int32 (size: 4 -> variable(i32))
.field emitDivI32: int32 (size: 4 -> variable(i32))
.field emitNfcF32: float32 (size: 4 -> variable(f32))
.field floatAsInt32: function (size: 0 -> inline)
.field floatAsInt64: function (size: 0 -> inline)
.field emitFloatAsInt1: int32 (size: 4 -> variable(i32))
.field emitFloatAsInt2: int64 (size: 8 -> variable(i64))
.field emitFloatAsInt3: int32 (size: 4 -> variable(i32))
.field emitFloatAsInt4: int64 (size: 8 -> variable(i64))
.field emitSlice: char[] (size: 8 -> variable(arr))
.field zero: function (size: 0 -> inline)
.field last: function (size: 0 -> inline)
.field sum: function (size: 0 -> inline)
.field any: function (size: 0 -> inline)
.field min: function (size: 0 -> inline)
.field sum: function (size: 0 -> inline)
.field any: function (size: 0 -> inline)
.field min: function (size: 0 -> inline)
.field ma: int32 (size: 4 -> variable(i32))
.field mb: int32 (size: 4 -> variable(i32))
.field mc: int32 (size: 4 -> variable(i32))
.field zeroVal: int32 (size: 4 -> variable(i32))
.field zeroVar: int32 (size: 4 -> variable(i32))
.field zeroXpr: int32 (size: 4 -> variable(i32))
.field lastVal: int32 (size: 4 -> variable(i32))
.field lastVar: int32 (size: 4 -> variable(i32))
.field lastXpr: int32 (size: 4 -> variable(i32))
.field sum2Val: int32 (size: 4 -> variable(i32))
.field sum2Var: int32 (size: 4 -> variable(i32))
.field sum2Xpr: int32 (size: 4 -> variable(i32))
.field any2Val: int32 (size: 4 -> variable(i32))
.field any2Var: int32 (size: 4 -> variable(i32))
.field any2Xpr: int32 (size: 4 -> variable(i32))
.field min2Val: int32 (size: 4 -> variable(i32))
.field min2Var: int32 (size: 4 -> variable(i32))
.field min2Xpr: int32 (size: 4 -> variable(i32))
.field sum3Val: int32 (size: 4 -> variable(i32))
.field sum3Var: int32 (size: 4 -> variable(i32))
.field sum3Xpr: int32 (size: 4 -> variable(i32))
.field any3Val: int32 (size: 4 -> variable(i32))
.field any3Var: int32 (size: 4 -> variable(i32))
.field any3Xpr: int32 (size: 4 -> variable(i32))
.field min3Val: int32 (size: 4 -> variable(i32))
.field min3Var: int32 (size: 4 -> variable(i32))
.field min3Xpr: int32 (size: 4 -> variable(i32))
.field overload: typename (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload1: float32 (size: 4 -> variable(f32))
.field overload2: float32 (size: 4 -> variable(f32))
.field overload3: float32 (size: 4 -> variable(f32))
.field overload4: float32 (size: 4 -> variable(f32))
.field overload5: float32 (size: 4 -> variable(f32))
.field Celsius: typename (size: 8 -> static const typename(val))
.field Fahrenheit: typename (size: 8 -> static const typename(val))
.field Celsius: function (size: 0 -> inline)
.field Fahrenheit: function (size: 0 -> inline)
.field Celsius: function (size: 0 -> inline)
.field Fahrenheit: function (size: 0 -> inline)
.field boilC: Celsius (size: 8 -> variable(val))
.field boilF: Fahrenheit (size: 8 -> variable(val))
.field value: int64 (size: 8 -> static variable(i64))
.field valueRef: int64 (size: 4 -> variable(ref))
.field valuePtr: pointer (size: 4 -> variable(ref))
.field valueVar: variant (size: 8 -> variable(var))
.field fromRef: int64 (size: 8 -> variable(i64))
.field fromPtr: int64 (size: 4 -> variable(ref))
.field fromVar: int64 (size: 4 -> variable(ref))
.field nullRef: int64 (size: 4 -> variable(ref))
.field nullPtr: pointer (size: 4 -> variable(ref))
.field nullVar: variant (size: 8 -> variable(var))
.field nullTyp: typename (size: 4 -> variable(ref))
.field nullFun: function (size: 4 -> variable(ref))
.field nullObj: object (size: 4 -> variable(ref))
.field typePtr: pointer (size: 4 -> variable(ref))
.field typeVar: variant (size: 8 -> variable(var))
.field typeTyp: typename (size: 4 -> variable(ref))
.field local: int64 (size: 8 -> variable(i64))
.field copyVal: int64 (size: 8 -> variable(i64))
.field copyRef: int64 (size: 4 -> variable(ref))
.field copyPtr: pointer (size: 4 -> variable(ref))
.field copyVar: variant (size: 8 -> variable(var))
.field copyTyp: typename (size: 4 -> variable(ref))
.field ptrVoid: pointer (size: 4 -> variable(ref))
.field ptrBool: pointer (size: 4 -> variable(ref))
.field ptrChar: pointer (size: 4 -> variable(ref))
.field ptrInt8: pointer (size: 4 -> variable(ref))
.field ptrInt16: pointer (size: 4 -> variable(ref))
.field ptrInt32: pointer (size: 4 -> variable(ref))
.field ptrInt64: pointer (size: 4 -> variable(ref))
.field ptrUint8: pointer (size: 4 -> variable(ref))
.field ptrUint16: pointer (size: 4 -> variable(ref))
.field ptrUint32: pointer (size: 4 -> variable(ref))
.field ptrUint64: pointer (size: 4 -> variable(ref))
.field ptrFloat32: pointer (size: 4 -> variable(ref))
.field ptrFloat64: pointer (size: 4 -> variable(ref))
.field ptrTypename: pointer (size: 4 -> variable(ref))
.field ptrFunction: pointer (size: 4 -> variable(ref))
.field ptrPointer: pointer (size: 4 -> variable(ref))
.field ptrVariant: pointer (size: 4 -> variable(ref))
.field ptrObject: pointer (size: 4 -> variable(ref))
.field varVoid: variant (size: 8 -> variable(var))
.field varBool: variant (size: 8 -> variable(var))
.field varChar: variant (size: 8 -> variable(var))
.field varInt8: variant (size: 8 -> variable(var))
.field varInt16: variant (size: 8 -> variable(var))
.field varInt32: variant (size: 8 -> variable(var))
.field varInt64: variant (size: 8 -> variable(var))
.field varUint8: variant (size: 8 -> variable(var))
.field varUint16: variant (size: 8 -> variable(var))
.field varUint32: variant (size: 8 -> variable(var))
.field varUint64: variant (size: 8 -> variable(var))
.field varFloat32: variant (size: 8 -> variable(var))
.field varFloat64: variant (size: 8 -> variable(var))
.field varTypename: variant (size: 8 -> variable(var))
.field varFunction: variant (size: 8 -> variable(var))
.field varPointer: variant (size: 8 -> variable(var))
.field varVariant: variant (size: 8 -> variable(var))
.field varObject: variant (size: 8 -> variable(var))
.field typVoid: typename (size: 4 -> variable(ref))
.field typBool: typename (size: 4 -> variable(ref))
.field typChar: typename (size: 4 -> variable(ref))
.field typInt8: typename (size: 4 -> variable(ref))
.field typInt16: typename (size: 4 -> variable(ref))
.field typInt32: typename (size: 4 -> variable(ref))
.field typInt64: typename (size: 4 -> variable(ref))
.field typUint8: typename (size: 4 -> variable(ref))
.field typUint16: typename (size: 4 -> variable(ref))
.field typUint32: typename (size: 4 -> variable(ref))
.field typUint64: typename (size: 4 -> variable(ref))
.field typFloat32: typename (size: 4 -> variable(ref))
.field typFloat64: typename (size: 4 -> variable(ref))
.field typTypename: typename (size: 4 -> variable(ref))
.field typFunction: typename (size: 4 -> variable(ref))
.field typPointer: typename (size: 4 -> variable(ref))
.field typVariant: typename (size: 4 -> variable(ref))
.field typObject: typename (size: 4 -> variable(ref))
.field valueOfPtr: pointer (size: 4 -> variable(ref))
.field valueOfVar: variant (size: 8 -> variable(var))
.field valueOfTyp: typename (size: 4 -> variable(ref))
.field typeOfValue: typename (size: 4 -> variable(ref))
.field copyPtrFloat64: variant (size: 8 -> variable(var))
.field copyVarFloat64: pointer (size: 4 -> variable(ref))
.field empty: function (size: 1 -> static const function)
.field funAdd: function (size: 8 -> static const function)
.field funAddResult: int32 (size: 4 -> variable(i32))
.field funAddRef: function (size: 4 -> variable(ref))
.field funAddRefResult: int32 (size: 4 -> variable(i32))
.field funMul: function (size: 4 -> variable(ref))
.field funMulResult: int32 (size: 4 -> variable(i32))
.field funMulRef: function (size: 4 -> variable(ref))
.field funMulRefResult: int32 (size: 4 -> variable(i32))
.field funMul: function (size: 8 -> static const function)
.field fib: function (size: 55 -> static const function)
.field fibonacci_13: uint32 (size: 4 -> variable(u32))
.field sizeofVoid: int32 (size: 4 -> variable(i32))
.field sizeofBool: int32 (size: 4 -> variable(i32))
.field sizeofChar: int32 (size: 4 -> variable(i32))
.field sizeofInt8: int32 (size: 4 -> variable(i32))
.field sizeofInt16: int32 (size: 4 -> variable(i32))
.field sizeofInt32: int32 (size: 4 -> variable(i32))
.field sizeofInt64: int32 (size: 4 -> variable(i32))
.field sizeofUint8: int32 (size: 4 -> variable(i32))
.field sizeofUint16: int32 (size: 4 -> variable(i32))
.field sizeofUint32: int32 (size: 4 -> variable(i32))
.field sizeofUint64: int32 (size: 4 -> variable(i32))
.field sizeofFloat32: int32 (size: 4 -> variable(i32))
.field sizeofFloat64: int32 (size: 4 -> variable(i32))
.field sizeofPointer: int32 (size: 4 -> variable(i32))
.field sizeofVariant: int32 (size: 4 -> variable(i32))
.field sizeofTypename: int32 (size: 4 -> variable(i32))
.field sizeofFunction: int32 (size: 4 -> variable(i32))
.field sizeofObject: int32 (size: 4 -> variable(i32))
.field RecordSizeof: object (size: 12 -> static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16 -> static const typename(ref))
.field typeofRecord: typename (size: 4 -> variable(ref))
.field nameOfRecord: char[*] (size: 4 -> variable(ref))
.field offsetOfRecord: int32 (size: 4 -> variable(i32))
.field sizeOfRecord: int32 (size: 4 -> variable(i32))
.field fileOfRecord: char[*] (size: 4 -> variable(ref))
.field lineOfRecord: int32 (size: 4 -> variable(i32))
.field typeofBase: typename (size: 4 -> variable(ref))
.field nameOfBase: char[*] (size: 4 -> variable(ref))
.field offsetOfBase: int32 (size: 4 -> variable(i32))
.field sizeOfBase: int32 (size: 4 -> variable(i32))
.field fileOfBase: char[*] (size: 4 -> variable(ref))
.field lineOfBase: int32 (size: 4 -> variable(i32))
.field typeofBase1: typename (size: 4 -> variable(ref))
.field offsetOfBase1: int32 (size: 4 -> variable(i32))
.field sizeOfBase1: int32 (size: 4 -> variable(i32))
.field typeofBase2: typename (size: 4 -> variable(ref))
.field offsetOfBase2: int32 (size: 4 -> variable(i32))
.field sizeOfBase2: int32 (size: 4 -> variable(i32))
.field pi64: float64 (size: 8 -> variable(f64))
.field e64: float64 (size: 8 -> variable(f64))
.field pi32: float32 (size: 4 -> variable(f32))
.field e32: float32 (size: 4 -> variable(f32))
.field rgb888: function (size: 0 -> inline)
.field rgb565: function (size: 0 -> inline)
.field r_comp: int32 (size: 4 -> variable(i32))
.field g_comp: int32 (size: 4 -> variable(i32))
.field b_comp: int32 (size: 4 -> variable(i32))
.field r5g6b5: int32 (size: 4 -> variable(i32))
.field r8g8b8: int32 (size: 4 -> variable(i32))
.field zxtR5: int32 (size: 4 -> variable(i32))
.field zxtG6: int32 (size: 4 -> variable(i32))
.field zxtB5: int32 (size: 4 -> variable(i32))
.field sxtR5: int32 (size: 4 -> variable(i32))
.field sxtG6: int32 (size: 4 -> variable(i32))
.field sxtB5: int32 (size: 4 -> variable(i32))
.field zxtR8: int32 (size: 4 -> variable(i32))
.field zxtG8: int32 (size: 4 -> variable(i32))
.field zxtB8: int32 (size: 4 -> variable(i32))
.field sxtR8: int32 (size: 4 -> variable(i32))
.field sxtG8: int32 (size: 4 -> variable(i32))
.field sxtB8: int32 (size: 4 -> variable(i32))
.field sinF64: float64 (size: 8 -> variable(f64))
.field cosF64: float64 (size: 8 -> variable(f64))
.field tanF64: float64 (size: 8 -> variable(f64))
.field logF64: float64 (size: 8 -> variable(f64))
.field expF64: float64 (size: 8 -> variable(f64))
.field powF64: float64 (size: 8 -> variable(f64))
.field sqrtF64: float64 (size: 8 -> variable(f64))
.field atanF64: float64 (size: 8 -> variable(f64))
.field sinF32: float32 (size: 4 -> variable(f32))
.field cosF32: float32 (size: 4 -> variable(f32))
.field tanF32: float32 (size: 4 -> variable(f32))
.field logF32: float32 (size: 4 -> variable(f32))
.field expF32: float32 (size: 4 -> variable(f32))
.field powF32: float32 (size: 4 -> variable(f32))
.field sqrtF32: float32 (size: 4 -> variable(f32))
.field atanF32: float32 (size: 4 -> variable(f32))
.field realloc: function (size: 0 -> inline)
.field malloc: function (size: 0 -> inline)
.field free: function (size: 0 -> inline)
.field p1: pointer (size: 4 -> variable(ref))
.field p2: pointer (size: 4 -> variable(ref))
.field p3: pointer (size: 4 -> variable(ref))
.field p4: pointer (size: 4 -> variable(ref))
.field val1: int64 (size: 8 -> variable(i64))
.field val2: int64 (size: 8 -> variable(i64))
.field noError: function (size: 1 -> static const function)
.field stackOverflow: function (size: 24 -> static const function)
.field divisionByZero: function (size: 12 -> static const function)
.field abortExecution: function (size: 64 -> static const function)
.field invalidMemoryAccess: function (size: 13 -> static const function)
.field invalidInstruction: function (size: 2 -> static const function)
.field tryExecErr0: int32 (size: 4 -> variable(i32))
.field tryExecErr1: int32 (size: 4 -> variable(i32))
.field tryExecErr2: int32 (size: 4 -> variable(i32))
.field tryExecErr3: int32 (size: 4 -> variable(i32))
.field tryExecErr4: int32 (size: 4 -> variable(i32))
.field tryExecErr5: int32 (size: 4 -> variable(i32))
.field tryExecErr6: int32 (size: 4 -> variable(i32))
.field arrFixedNoInit: int64[7] (size: 56 -> variable(val))
.field arrArrayNoInit: int64[*] (size: 4 -> variable(ref))
.field arrSliceNoInit: int64[] (size: 8 -> variable(arr))
.field arrArrayInitNull: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitNull: int64[] (size: 8 -> variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitFixed: int64[] (size: 8 -> variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitSlice: int64[] (size: 8 -> variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4 -> variable(ref))
.field strFixed: char[7] (size: 7 -> variable(val))
.field strArray: char[*] (size: 4 -> variable(ref))
.field strSlice: char[] (size: 8 -> variable(arr))
.field lenSlice: function (size: 5 -> static const function)
.field nthFixed: function (size: 12 -> static const function)
.field nthArray: function (size: 12 -> static const function)
.field nthSlice: function (size: 12 -> static const function)
.field RecordMemberTest: typename (size: 32 -> static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32 -> variable(val))
.field RecordMethodTest: typename (size: 16 -> static const typename(val))
.field globalFunction: function (size: 8 -> static const function)
.field recordMethodTest: RecordMethodTest (size: 16 -> variable(val))
.field rgbF32: typename (size: 16 -> static const typename(val))
.field rgbU8: typename (size: 3 -> static const typename(val))
.field color: typename (size: 4 -> static const typename(val))
.field Color: object (size: 20 -> static const typename(ref))
.field black: rgbU8 (size: 3 -> variable(val))
.field green: rgbU8 (size: 3 -> variable(val))
.field white: rgbU8 (size: 3 -> variable(val))
.field cyan: color (size: 4 -> variable(val))
.field blue: color (size: 4 -> variable(val))
.field record_pack0: typename (size: 8 -> static const typename(val))
.field record_pack1: typename (size: 17 -> static const typename(val))
.field record_pack2: typename (size: 20 -> static const typename(val))
.field record_pack4: typename (size: 24 -> static const typename(val))
.field record_pack8: typename (size: 32 -> static const typename(val))
.field record_packDef: typename (size: 32 -> static const typename(val))
.field a: typename (size: 0 -> inline)
.field b: typename (size: 0 -> inline)
.field shift: int32 (size: 4 -> variable(i32))
.field boolA: bool (size: 1 -> variable(bool))
.field boolB: bool (size: 1 -> variable(bool))
.field boolAnd: bool (size: 1 -> variable(bool))
.field boolIor: bool (size: 1 -> variable(bool))
.field boolXor: bool (size: 1 -> variable(bool))
.field boolNot: bool (size: 1 -> variable(bool))
.field boolCeq: bool (size: 1 -> variable(bool))
.field boolCne: bool (size: 1 -> variable(bool))
.field boolClt: bool (size: 1 -> variable(bool))
.field boolCle: bool (size: 1 -> variable(bool))
.field boolCgt: bool (size: 1 -> variable(bool))
.field boolCge: bool (size: 1 -> variable(bool))
.field chrA: char (size: 1 -> variable(i32))
.field chrB: char (size: 1 -> variable(i32))
.field chrPls: char (size: 1 -> variable(i32))
.field chrNeg: char (size: 1 -> variable(i32))
.field chrCmt: char (size: 1 -> variable(i32))
.field chrAdd: char (size: 1 -> variable(i32))
.field chrSub: char (size: 1 -> variable(i32))
.field chrMul: char (size: 1 -> variable(i32))
.field chrDiv: char (size: 1 -> variable(i32))
.field chrMod: char (size: 1 -> variable(i32))
.field chrAnd: char (size: 1 -> variable(i32))
.field chrIor: char (size: 1 -> variable(i32))
.field chrXor: char (size: 1 -> variable(i32))
.field chrShl: char (size: 1 -> variable(i32))
.field chrShr: char (size: 1 -> variable(i32))
.field chrNot: bool (size: 1 -> variable(bool))
.field chrCeq: bool (size: 1 -> variable(bool))
.field chrCne: bool (size: 1 -> variable(bool))
.field chrClt: bool (size: 1 -> variable(bool))
.field chrCle: bool (size: 1 -> variable(bool))
.field chrCgt: bool (size: 1 -> variable(bool))
.field chrCge: bool (size: 1 -> variable(bool))
.field i8A: int8 (size: 1 -> variable(i32))
.field i8B: int8 (size: 1 -> variable(i32))
.field i8Pls: int8 (size: 1 -> variable(i32))
.field i8Neg: int8 (size: 1 -> variable(i32))
.field i8Cmt: int8 (size: 1 -> variable(i32))
.field i8Add: int8 (size: 1 -> variable(i32))
.field i8Sub: int8 (size: 1 -> variable(i32))
.field i8Mul: int8 (size: 1 -> variable(i32))
.field i8Div: int8 (size: 1 -> variable(i32))
.field i8Mod: int8 (size: 1 -> variable(i32))
.field i8And: int8 (size: 1 -> variable(i32))
.field i8Ior: int8 (size: 1 -> variable(i32))
.field i8Xor: int8 (size: 1 -> variable(i32))
.field i8Shl: int8 (size: 1 -> variable(i32))
.field i8Shr: int8 (size: 1 -> variable(i32))
.field i8Not: bool (size: 1 -> variable(bool))
.field i8Ceq: bool (size: 1 -> variable(bool))
.field i8Cne: bool (size: 1 -> variable(bool))
.field i8Clt: bool (size: 1 -> variable(bool))
.field i8Cle: bool (size: 1 -> variable(bool))
.field i8Cgt: bool (size: 1 -> variable(bool))
.field i8Cge: bool (size: 1 -> variable(bool))
.field u8A: uint8 (size: 1 -> variable(u32))
.field u8B: uint8 (size: 1 -> variable(u32))
.field u8Pls: uint8 (size: 1 -> variable(u32))
.field u8Neg: uint8 (size: 1 -> variable(u32))
.field u8Cmt: uint8 (size: 1 -> variable(u32))
.field u8Add: uint8 (size: 1 -> variable(u32))
.field u8Sub: uint8 (size: 1 -> variable(u32))
.field u8Mul: uint8 (size: 1 -> variable(u32))
.field u8Div: uint8 (size: 1 -> variable(u32))
.field u8Mod: uint8 (size: 1 -> variable(u32))
.field u8And: uint8 (size: 1 -> variable(u32))
.field u8Ior: uint8 (size: 1 -> variable(u32))
.field u8Xor: uint8 (size: 1 -> variable(u32))
.field u8Shl: uint8 (size: 1 -> variable(u32))
.field u8Shr: uint8 (size: 1 -> variable(u32))
.field u8Not: bool (size: 1 -> variable(bool))
.field u8Ceq: bool (size: 1 -> variable(bool))
.field u8Cne: bool (size: 1 -> variable(bool))
.field u8Clt: bool (size: 1 -> variable(bool))
.field u8Cle: bool (size: 1 -> variable(bool))
.field u8Cgt: bool (size: 1 -> variable(bool))
.field u8Cge: bool (size: 1 -> variable(bool))
.field i16A: int16 (size: 2 -> variable(i32))
.field i16B: int16 (size: 2 -> variable(i32))
.field i16Pls: int16 (size: 2 -> variable(i32))
.field i16Neg: int16 (size: 2 -> variable(i32))
.field i16Cmt: int16 (size: 2 -> variable(i32))
.field i16Add: int16 (size: 2 -> variable(i32))
.field i16Sub: int16 (size: 2 -> variable(i32))
.field i16Mul: int16 (size: 2 -> variable(i32))
.field i16Div: int16 (size: 2 -> variable(i32))
.field i16Mod: int16 (size: 2 -> variable(i32))
.field i16And: int16 (size: 2 -> variable(i32))
.field i16Ior: int16 (size: 2 -> variable(i32))
.field i16Xor: int16 (size: 2 -> variable(i32))
.field i16Shl: int16 (size: 2 -> variable(i32))
.field i16Shr: int16 (size: 2 -> variable(i32))
.field i16Not: bool (size: 1 -> variable(bool))
.field i16Ceq: bool (size: 1 -> variable(bool))
.field i16Cne: bool (size: 1 -> variable(bool))
.field i16Clt: bool (size: 1 -> variable(bool))
.field i16Cle: bool (size: 1 -> variable(bool))
.field i16Cgt: bool (size: 1 -> variable(bool))
.field i16Cge: bool (size: 1 -> variable(bool))
.field u16A: uint16 (size: 2 -> variable(u32))
.field u16B: uint16 (size: 2 -> variable(u32))
.field u16Pls: uint16 (size: 2 -> variable(u32))
.field u16Neg: uint16 (size: 2 -> variable(u32))
.field u16Cmt: uint16 (size: 2 -> variable(u32))
.field u16Add: uint16 (size: 2 -> variable(u32))
.field u16Sub: uint16 (size: 2 -> variable(u32))
.field u16Mul: uint16 (size: 2 -> variable(u32))
.field u16Div: uint16 (size: 2 -> variable(u32))
.field u16Mod: uint16 (size: 2 -> variable(u32))
.field u16And: uint16 (size: 2 -> variable(u32))
.field u16Ior: uint16 (size: 2 -> variable(u32))
.field u16Xor: uint16 (size: 2 -> variable(u32))
.field u16Shl: uint16 (size: 2 -> variable(u32))
.field u16Shr: uint16 (size: 2 -> variable(u32))
.field u16Not: bool (size: 1 -> variable(bool))
.field u16Ceq: bool (size: 1 -> variable(bool))
.field u16Cne: bool (size: 1 -> variable(bool))
.field u16Clt: bool (size: 1 -> variable(bool))
.field u16Cle: bool (size: 1 -> variable(bool))
.field u16Cgt: bool (size: 1 -> variable(bool))
.field u16Cge: bool (size: 1 -> variable(bool))
.field i32A: int32 (size: 4 -> variable(i32))
.field i32B: int32 (size: 4 -> variable(i32))
.field i32Pls: int32 (size: 4 -> variable(i32))
.field i32Neg: int32 (size: 4 -> variable(i32))
.field i32Cmt: int32 (size: 4 -> variable(i32))
.field i32Add: int32 (size: 4 -> variable(i32))
.field i32Sub: int32 (size: 4 -> variable(i32))
.field i32Mul: int32 (size: 4 -> variable(i32))
.field i32Div: int32 (size: 4 -> variable(i32))
.field i32Mod: int32 (size: 4 -> variable(i32))
.field i32And: int32 (size: 4 -> variable(i32))
.field i32Ior: int32 (size: 4 -> variable(i32))
.field i32Xor: int32 (size: 4 -> variable(i32))
.field i32Shl: int32 (size: 4 -> variable(i32))
.field i32Shr: int32 (size: 4 -> variable(i32))
.field i32Not: bool (size: 1 -> variable(bool))
.field i32Ceq: bool (size: 1 -> variable(bool))
.field i32Cne: bool (size: 1 -> variable(bool))
.field i32Clt: bool (size: 1 -> variable(bool))
.field i32Cle: bool (size: 1 -> variable(bool))
.field i32Cgt: bool (size: 1 -> variable(bool))
.field i32Cge: bool (size: 1 -> variable(bool))
.field u32A: uint32 (size: 4 -> variable(u32))
.field u32B: uint32 (size: 4 -> variable(u32))
.field u32Pls: uint32 (size: 4 -> variable(u32))
.field u32Neg: uint32 (size: 4 -> variable(u32))
.field u32Cmt: uint32 (size: 4 -> variable(u32))
.field u32Add: uint32 (size: 4 -> variable(u32))
.field u32Sub: uint32 (size: 4 -> variable(u32))
.field u32Mul: uint32 (size: 4 -> variable(u32))
.field u32Div: uint32 (size: 4 -> variable(u32))
.field u32Mod: uint32 (size: 4 -> variable(u32))
.field u32And: uint32 (size: 4 -> variable(u32))
.field u32Ior: uint32 (size: 4 -> variable(u32))
.field u32Xor: uint32 (size: 4 -> variable(u32))
.field u32Shl: uint32 (size: 4 -> variable(u32))
.field u32Shr: uint32 (size: 4 -> variable(u32))
.field u32Not: bool (size: 1 -> variable(bool))
.field u32Ceq: bool (size: 1 -> variable(bool))
.field u32Cne: bool (size: 1 -> variable(bool))
.field u32Clt: bool (size: 1 -> variable(bool))
.field u32Cle: bool (size: 1 -> variable(bool))
.field u32Cgt: bool (size: 1 -> variable(bool))
.field u32Cge: bool (size: 1 -> variable(bool))
.field i64A: int64 (size: 8 -> variable(i64))
.field i64B: int64 (size: 8 -> variable(i64))
.field i64Pls: int64 (size: 8 -> variable(i64))
.field i64Neg: int64 (size: 8 -> variable(i64))
.field i64Cmt: int64 (size: 8 -> variable(i64))
.field i64Add: int64 (size: 8 -> variable(i64))
.field i64Sub: int64 (size: 8 -> variable(i64))
.field i64Mul: int64 (size: 8 -> variable(i64))
.field i64Div: int64 (size: 8 -> variable(i64))
.field i64Mod: int64 (size: 8 -> variable(i64))
.field i64And: int64 (size: 8 -> variable(i64))
.field i64Ior: int64 (size: 8 -> variable(i64))
.field i64Xor: int64 (size: 8 -> variable(i64))
.field i64Shl: int64 (size: 8 -> variable(i64))
.field i64Shr: int64 (size: 8 -> variable(i64))
.field i64Not: bool (size: 1 -> variable(bool))
.field i64Ceq: bool (size: 1 -> variable(bool))
.field i64Cne: bool (size: 1 -> variable(bool))
.field i64Clt: bool (size: 1 -> variable(bool))
.field i64Cle: bool (size: 1 -> variable(bool))
.field i64Cgt: bool (size: 1 -> variable(bool))
.field i64Cge: bool (size: 1 -> variable(bool))
.field u64A: uint64 (size: 8 -> variable(u64))
.field u64B: uint64 (size: 8 -> variable(u64))
.field u64Pls: uint64 (size: 8 -> variable(u64))
.field u64Neg: uint64 (size: 8 -> variable(u64))
.field u64Cmt: uint64 (size: 8 -> variable(u64))
.field u64Add: uint64 (size: 8 -> variable(u64))
.field u64Sub: uint64 (size: 8 -> variable(u64))
.field u64Mul: uint64 (size: 8 -> variable(u64))
.field u64Div: uint64 (size: 8 -> variable(u64))
.field u64Mod: uint64 (size: 8 -> variable(u64))
.field u64And: uint64 (size: 8 -> variable(u64))
.field u64Ior: uint64 (size: 8 -> variable(u64))
.field u64Xor: uint64 (size: 8 -> variable(u64))
.field u64Shl: uint64 (size: 8 -> variable(u64))
.field u64Shr: uint64 (size: 8 -> variable(u64))
.field u64Not: bool (size: 1 -> variable(bool))
.field u64Ceq: bool (size: 1 -> variable(bool))
.field u64Cne: bool (size: 1 -> variable(bool))
.field u64Clt: bool (size: 1 -> variable(bool))
.field u64Cle: bool (size: 1 -> variable(bool))
.field u64Cgt: bool (size: 1 -> variable(bool))
.field u64Cge: bool (size: 1 -> variable(bool))
.field f32A: float32 (size: 4 -> variable(f32))
.field f32B: float32 (size: 4 -> variable(f32))
.field f32Pls: float32 (size: 4 -> variable(f32))
.field f32Neg: float32 (size: 4 -> variable(f32))
.field f32Add: float32 (size: 4 -> variable(f32))
.field f32Sub: float32 (size: 4 -> variable(f32))
.field f32Mul: float32 (size: 4 -> variable(f32))
.field f32Div: float32 (size: 4 -> variable(f32))
.field f32Mod: float32 (size: 4 -> variable(f32))
.field f32Not: bool (size: 1 -> variable(bool))
.field f32Ceq: bool (size: 1 -> variable(bool))
.field f32Cne: bool (size: 1 -> variable(bool))
.field f32Clt: bool (size: 1 -> variable(bool))
.field f32Cle: bool (size: 1 -> variable(bool))
.field f32Cgt: bool (size: 1 -> variable(bool))
.field f32Cge: bool (size: 1 -> variable(bool))
.field f64A: float64 (size: 8 -> variable(f64))
.field f64B: float64 (size: 8 -> variable(f64))
.field f64Pls: float64 (size: 8 -> variable(f64))
.field f64Neg: float64 (size: 8 -> variable(f64))
.field f64Add: float64 (size: 8 -> variable(f64))
.field f64Sub: float64 (size: 8 -> variable(f64))
.field f64Mul: float64 (size: 8 -> variable(f64))
.field f64Div: float64 (size: 8 -> variable(f64))
.field f64Mod: float64 (size: 8 -> variable(f64))
.field f64Not: bool (size: 1 -> variable(bool))
.field f64Ceq: bool (size: 1 -> variable(bool))
.field f64Cne: bool (size: 1 -> variable(bool))
.field f64Clt: bool (size: 1 -> variable(bool))
.field f64Cle: bool (size: 1 -> variable(bool))
.field f64Cgt: bool (size: 1 -> variable(bool))
.field f64Cge: bool (size: 1 -> variable(bool))
.field ptrA: pointer (size: 4 -> variable(ref))
.field ptrB: pointer (size: 4 -> variable(ref))
.field ptrCeq: bool (size: 1 -> variable(bool))
.field ptrCne: bool (size: 1 -> variable(bool))
.field t: int32 (size: 4 -> variable(i32))
.field forIdx: int32 (size: 4 -> variable(i32))
.field .main: function (size: 7028 -> static function)
.value: {
	{
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				static const NonEqualIntegers: struct {
					const expected: int32;
					const returned: int32;
					const message: char[*];
				};
				details: NonEqualIntegers := {
					details.expected := expected;
					details.returned := returned;
					details.message := (message);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32);
		emitDivI32: int32 := emit(int32(10), int32(5), div.i32);
		emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin);
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(int32(3), pointer("string"));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		sum(a: int32, b: int32, c: int32): int32 := sum(sum(a, b), c);
		any(a: int32, b: int32, c: int32): int32 := any(any(a, b), c);
		min(a: int32, b: int32, c: int32): int32 := min(min(a, b), c);
		ma: int32 := 3;
		mb: int32 := 6;
		mc: int32 := 9;
		zeroVal: int32 := zero(2, 3);
		zeroVar: int32 := zero(ma, mb);
		zeroXpr: int32 := zero(ma + mb, mb + mc);
		lastVal: int32 := last(2, 3);
		lastVar: int32 := last(ma, mb);
		lastXpr: int32 := last(ma + mb, mb + mc);
		sum2Val: int32 := sum(3, 12);
		sum2Var: int32 := sum(ma, mb);
		sum2Xpr: int32 := sum(ma + mb, mb + mc);
		any2Val: int32 := any(3, 12);
		any2Var: int32 := any(ma, mb);
		any2Xpr: int32 := any(ma + mb, mb + mc);
		min2Val: int32 := min(3, 12);
		min2Var: int32 := min(ma, mb);
		min2Xpr: int32 := min(ma + mb, mb + mc);
		sum3Val: int32 := sum(3, 2, 6);
		sum3Var: int32 := sum(ma, mb, mc);
		sum3Xpr: int32 := sum(ma + mb, mb + mc, mc + ma);
		any3Val: int32 := any(3, 2, 6);
		any3Var: int32 := any(ma, mb, mc);
		any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma);
		min3Val: int32 := min(3, 2, 6);
		min3Var: int32 := min(ma, mb, mc);
		min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(0, 0);
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius((value.degrees - (32)) / 1.800000);
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(value.degrees * 1.800000 + (32));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (typename(int64) == null) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return .result := x + y;
		};
		funAddResult: int32 := funAdd(2, 7);
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(2, 8);
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(2, 6);
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(2, 7);
		static const funMul(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		static const fib(n: uint32): uint32 := {
			if (n <= (1)) {
				return .result := n;
			}
			return .result := fib(n - (1)) + fib(n - (2));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5);
		zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6);
		zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5);
		sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5);
		sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6);
		sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5);
		zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8);
		zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8);
		zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8);
		sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8);
		sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8);
		sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8);
		sinF64: float64 := float64.sin(pi64 / (2));
		cosF64: float64 := float64.cos(pi64 / (2));
		tanF64: float64 := float64.tan(pi64 / (4));
		logF64: float64 := float64.log(e64 * e64 * e64);
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(pi64 * pi64, 0.500000);
		sqrtF64: float64 := float64.sqrt(pi64 * pi64);
		atanF64: float64 := float64.atan2(pi64, 1.000000);
		sinF32: float32 := float32.sin(pi32 / (2));
		cosF32: float32 := float32.cos(pi32 / (2));
		tanF32: float32 := float32.tan(pi32 / (4));
		logF32: float32 := float32.log(e32 * e32 * e32);
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(pi32 * pi32, 0.500000);
		sqrtF32: float32 := float32.sqrt(pi32 * pi32);
		atanF32: float32 := float32.atan2(pi32, 1.000000);
		realloc(data: pointer, size: int32): pointer := pointer.alloc(data, size);
		malloc(size: int32): pointer := pointer.alloc(null, size);
		free(data: pointer): pointer := pointer.alloc(data, 0);
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(p1, 0, 1024);
		pointer.copy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug("val1", val1);
		debug("val2", val2);
		pointer.move(pointer(val2), pointer(val1), sizeof(int64));
		pointer.fill(pointer(val1), 0, sizeof(int64));
		debug("val1", val1);
		debug("val2", val2);
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[1024];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := 3 / 0;
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				details.message := ("assertion failed");
				details.expected := 97;
				details.returned := 77;
			};
			raise(raise.abort, raise.noTrace, "fatal error", details);
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(load.z32, ret);
		};
		tryExecErr0: int32 := tryExec(null, noError);
		tryExecErr1: int32 := tryExec(null, null);
		tryExecErr2: int32 := tryExec(null, stackOverflow);
		tryExecErr3: int32 := tryExec(null, divisionByZero);
		tryExecErr4: int32 := tryExec(null, invalidInstruction);
		tryExecErr5: int32 := tryExec(null, invalidMemoryAccess);
		tryExecErr6: int32 := tryExec(null, abortExecution);
		static if (typename(int64) == null) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1) {
			arrFixedNoInit[i] := (42 + i);
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(strFixed, pointer("string"), 7);
		debug("string as variant", strFixed);
		debug("string to variant", variant(strFixed));
		strArray: char[*] := "string";
		debug("string as variant", strArray);
		debug("string to variant", variant(strArray));
		strSlice: char[] := "string";
		debug("string as variant", strSlice);
		debug("string to variant", variant(strSlice));
		assert(arrSliceNoInit.length >= (0));
		assert(arrSliceInitNull.length == (0));
		assert(arrFixedNoInit[0] == (42));
		static const lenSlice(values: int64[]): int32 := {
			return .result := values.length;
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return .result := values[idx];
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return .result := values[idx];
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return .result := values[idx];
		};
		assertEq(7, arrFixedNoInit.length);
		assertEq(arrFixedNoInit.length, arrSliceInitFixed.length);
		assertEq(arrFixedNoInit.length, arrSliceInitSlice.length);
		assertEq(0, lenSlice(null));
		assertEq(0, lenSlice(arrSliceInitNull));
		assertEq(arrFixedNoInit.length, lenSlice(arrFixedNoInit));
		assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitFixed));
		assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitSlice));
		for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1) {
			expected: int64 := 42 + i;
			assert(expected == arrFixedNoInit[i]);
			assert(expected == arrArrayInitFixed[i]);
			assert(expected == arrSliceInitFixed[i]);
			assert(expected == nthFixed(i, arrFixedNoInit));
			assert(expected == nthFixed(i, arrArrayInitFixed));
			assert(expected == nthFixed(i, arrSliceInitFixed));
			assert(expected == nthArray(i, arrFixedNoInit));
			assert(expected == nthArray(i, arrArrayInitFixed));
			assert(expected == nthArray(i, arrSliceInitFixed));
			assert(expected == nthSlice(i, arrFixedNoInit));
			assert(expected == nthSlice(i, arrSliceInitFixed));
			assert(expected == arrSliceInitSlice[i]);
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 5;
			static const globalConstant: int32 := 6;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				globalRecInit.member := 51;
				globalRecInit.constant := 52;
			};
			static const globalConstantRec: Inner := {
				globalConstantRec.member := 61;
				globalConstantRec.constant := 62;
			};
		};
		recordMemberTest: RecordMemberTest := {
			recordMemberTest.member := 6;
			recordMemberTest.constant := 7;
			recordMemberTest.memberInit := 8;
			recordMemberTest.constantInit := 9;
			recordMemberTest.memberRec.member := 61;
			recordMemberTest.memberRec.constant := 62;
			recordMemberTest.constantRec.member := 71;
			recordMemberTest.constantRec.constant := 72;
		};
		static const RecordMethodTest: struct {
			static const staticMethod(x: int32, y: int32): int32 := {
				return .result := x + y;
			};
			static forwardMethod(x: int32, y: int32): int32 := forwardMethod;
			abstractMethod(x: int32, y: int32): int32;
			delegateMethod(x: int32, y: int32): int32 := forwardMethod;
			static const virtualMethod(x: int32, y: int32): int32 := {
				return .result := x * y;
			};
			virtualMethod(x: int32, y: int32): int32 := virtualMethod;
			static const forwardMethod(x: int32, y: int32): int32 := {
				return .result := x * y;
			};
		};
		static const globalFunction(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		recordMethodTest: RecordMethodTest := {
			recordMethodTest.delegateMethod := globalFunction;
			recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
			recordMethodTest.virtualMethod := virtualMethod;
		};
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			black.r := (0);
			black.g := (0);
			black.b := (0);
		};
		green: rgbU8 := {
			green.r := (0);
			green.g := (255);
			green.b := (0);
		};
		white: rgbU8 := {
			white.r := (255);
			white.g := (255);
			white.b := (255);
		};
		cyan: color := {
			cyan.col := (65535);
		};
		blue: color := {
			blue.rgb.r := (0);
			blue.rgb.g := (0);
			blue.rgb.b := (255);
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !(chrB);
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !(i8B);
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !(u8B);
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !(i16B);
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !(u16B);
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !(i32B);
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !(u32B);
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !(i64B);
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !(u64B);
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !(f32B);
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !(f64B);
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := ptrA == ptrB;
		ptrCne: bool := ptrA != ptrB;
		static if (0 == 0) {
			raise(raise.debug, 1, "0 == 0", null);
		}
		static if (0 != 0) {
			raise(raise.debug, 2, "0 != 0", null);
		}
		static if (0 == 0) {
			raise(raise.debug, 3, "0 == 0", null);
		}
		else {
			raise(raise.debug, 4, "0 != 0", null);
		}
		static if (0 != 0) {
			raise(raise.debug, 5, "0 != 0", null);
		}
		else {
			raise(raise.debug, 6, "0 == 0", null);
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(raise.debug, 7, "t == 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 8, "t != 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				raise(raise.debug, 10, "t != 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 11, "t != 0", t);
			}
			else {
				raise(raise.debug, 12, "t == 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				if (t == 1) {
					raise(raise.debug, 10, "t == 1", t);
				}
				else {
					if (t == 2) {
						raise(raise.debug, 10, "t == 2", t);
					}
					else {
						if (t == 3) {
							raise(raise.debug, 10, "t == 3", t);
						}
						else {
							if (t == 4) {
								raise(raise.debug, 10, "t == 4", t);
							}
							else {
								if (t == 5) {
									raise(raise.debug, 10, "t == 5", t);
								}
								else {
									raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
								}
							}
						}
					}
				}
			}
		}
		static if (typename(int64) == null) {
			error("integer is not declared");
		}
		static if (typename(int64) != typename) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; i < 2; i := i + 1) {
			debug("for (int i = 0; i < 2; i += 1)", i);
		}
		forIdx: int32;
		for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1) {
			debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i < 2) {
				continue;
			}
			debug("for with continue", i);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i > 2) {
				break;
			}
			debug("for with break", i);
		}
	}
}
.instructions: (7028 bytes)
	test/lang.initByRef.ci:7: (13 bytes): static value: int64 := 42
	<.main+?>:    load.c64 42
	<.main+?>:    store.m64 .?????? ;value
	test/lang.member.ci:35: (5 bytes): static global: int32
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.global
	test/lang.member.ci:38: (9 bytes): static globalInit: int32 := 5
	<.main+?>:    load.c32 5
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalInit
	test/lang.member.ci:41: (9 bytes): static const globalConstant: int32 := 6
	<.main+?>:    load.c32 6
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstant
	test/lang.member.ci:47: (18 bytes): static globalRecInit: Inner := {...}
	<.main+?>:    load.c32 51
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalRecInit
	test/lang.member.ci:47: (9 bytes): globalRecInit.constant := 52;
	<.main+?>:    load.c32 52
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalRecInit+4
	test/lang.member.ci:50: (18 bytes): static const globalConstantRec: Inner := {...}
	<.main+?>:    load.c32 61
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstantRec
	test/lang.member.ci:50: (9 bytes): globalConstantRec.constant := 62;
	<.main+?>:    load.c32 62
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstantRec+4
	test/lang.method.ci:12: (9 bytes): static forwardMethod(x: int32, y: int32): int32 := forwardMethod
	<.main+?>:    load.ref .?????? ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+?>:    store.m32 .?????? ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	test/lang.inlineEmit.ci:3: (1 bytes): emitldz32: int32 := emit(load.z32)
	<.main+?>:    load.z32
	test/lang.inlineEmit.ci:4: (1 bytes): emitldz64: int64 := emit(load.z64)
	<.main+?>:    load.z64
	test/lang.inlineEmit.ci:6: (5 bytes): emitA: int32 := 42
	<.main+?>:    load.c32 42
	test/lang.inlineEmit.ci:7: (5 bytes): emitB: int32 := 96
	<.main+?>:    load.c32 96
	test/lang.inlineEmit.ci:9: (5 bytes): emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	test/lang.inlineEmit.ci:10: (11 bytes): emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+?>:    load.c32 10
	<.main+?>:    load.c32 5
	<.main+?>:    div.i32
	test/lang.inlineEmit.ci:11: (24 bytes): emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin)
	<.main+?>:    load.f64 3.140000
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    f64.2f32
	<.main+?>:    nfc(28) ;float32.sin(x: float32): float32
	test/lang.inlineEmit.ci:17: (5 bytes): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+?>:    load.f32 500.000000
	test/lang.inlineEmit.ci:18: (6 bytes): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+?>:    load.f32 500.000000
	<.main+?>:    i32.2i64
	test/lang.inlineEmit.ci:19: (10 bytes): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+?>:    load.f64 500.000000
	<.main+?>:    i64.2i32
	test/lang.inlineEmit.ci:20: (9 bytes): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+?>:    load.f64 500.000000
	test/lang.inlineEmit.ci:23: (10 bytes): emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+?>:    load.c32 3
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.inlineMacros.ci:13: (5 bytes): ma: int32 := 3
	<.main+?>:    load.c32 3
	test/lang.inlineMacros.ci:14: (5 bytes): mb: int32 := 6
	<.main+?>:    load.c32 6
	test/lang.inlineMacros.ci:15: (5 bytes): mc: int32 := 9
	<.main+?>:    load.c32 9
	test/lang.inlineMacros.ci:17: (1 bytes): zeroVal: int32 := zero(2, 3)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:18: (1 bytes): zeroVar: int32 := zero(ma, mb)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:19: (1 bytes): zeroXpr: int32 := zero(ma + mb, mb + mc)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:21: (5 bytes): lastVal: int32 := last(2, 3)
	<.main+?>:    load.c32 3
	test/lang.inlineMacros.ci:22: (2 bytes): lastVar: int32 := last(ma, mb)
	<.main+?>:    dup.x1 sp(5)
	test/lang.inlineMacros.ci:23: (5 bytes): lastXpr: int32 := last(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:25: (9 bytes): sum2Val: int32 := sum(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    inc.i32(+12)
	test/lang.inlineMacros.ci:26: (5 bytes): sum2Var: int32 := sum(ma, mb)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:27: (11 bytes): sum2Xpr: int32 := sum(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:29: (24 bytes): any2Val: int32 := any(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 12
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:30: (18 bytes): any2Var: int32 := any(ma, mb)
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:31: (24 bytes): any2Xpr: int32 := any(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:33: (33 bytes): min2Val: int32 := min(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 12
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:34: (27 bytes): min2Var: int32 := min(ma, mb)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:35: (33 bytes): min2Xpr: int32 := min(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:37: (13 bytes): sum3Val: int32 := sum(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    inc.i32(+2)
	<.main+?>:    inc.i32(+6)
	test/lang.inlineMacros.ci:38: (8 bytes): sum3Var: int32 := sum(ma, mb, mc)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:39: (17 bytes): sum3Xpr: int32 := sum(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:41: (43 bytes): any3Val: int32 := any(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 2
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 6
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:42: (34 bytes): any3Var: int32 := any(ma, mb, mc)
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:43: (43 bytes): any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:45: (61 bytes): min3Val: int32 := min(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 2
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    load.c32 6
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:46: (52 bytes): min3Var: int32 := min(ma, mb, mc)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    dup.x1 sp(23)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:47: (61 bytes): min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(27)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/test.inlineOverload.ci:9: (5 bytes): overload1: float32 := overload
	<.main+?>:    load.f32 1.000000
	test/test.inlineOverload.ci:10: (5 bytes): overload2: float32 := overload()
	<.main+?>:    load.f32 2.000000
	test/test.inlineOverload.ci:11: (5 bytes): overload3: float32 := overload(0)
	<.main+?>:    load.f32 3.000000
	test/test.inlineOverload.ci:12: (5 bytes): overload4: float32 := overload(0.000000)
	<.main+?>:    load.f32 4.000000
	test/test.inlineOverload.ci:13: (5 bytes): overload5: float32 := overload(0, 0)
	<.main+?>:    load.f32 5.000000
	test/test.inlineOverload.ci:28: (9 bytes): boilC: Celsius := Celsius(100.000000)
	<.main+?>:    load.f64 100.000000
	test/test.inlineOverload.ci:29: (22 bytes): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.f64 1.800000
	<.main+?>:    mul.f64
	<.main+?>:    load.f64 32.000000
	<.main+?>:    add.f64
	test/lang.initByRef.ci:8: (5 bytes): valueRef: int64 := value
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:9: (5 bytes): valuePtr: pointer := value
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:10: (10 bytes): valueVar: variant := value
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:12: (3 bytes): fromRef: int64 := valueRef
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.i64
	test/lang.initByRef.ci:13: (2 bytes): fromPtr: int64 := valuePtr
	<.main+?>:    dup.x1 sp(4)
	test/lang.initByRef.ci:14: (2 bytes): fromVar: int64 := valueVar
	<.main+?>:    dup.x1 sp(3)
	test/lang.initByRef.ci:16: (5 bytes): nullRef: int64 := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:17: (5 bytes): nullPtr: pointer := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:18: (10 bytes): nullVar: variant := null
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:19: (5 bytes): nullTyp: typename := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:20: (5 bytes): nullFun: function := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:21: (5 bytes): nullObj: object := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:23: (5 bytes): typePtr: pointer := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:24: (10 bytes): typeVar: variant := int64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:25: (5 bytes): typeTyp: typename := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:27: (4 bytes): local: int64 := value
	<.main+?>:    load.m64 .?????? ;value
	test/lang.initByRef.ci:28: (2 bytes): copyVal: int64 := local
	<.main+?>:    dup.x2 sp(0)
	test/lang.initByRef.ci:29: (2 bytes): copyRef: int64 := valueRef
	<.main+?>:    dup.x1 sp(22)
	test/lang.initByRef.ci:30: (2 bytes): copyPtr: pointer := valuePtr
	<.main+?>:    dup.x1 sp(22)
	test/lang.initByRef.ci:31: (2 bytes): copyVar: variant := valueVar
	<.main+?>:    dup.x2 sp(21)
	test/lang.initByRef.ci:32: (2 bytes): copyTyp: typename := typeTyp
	<.main+?>:    dup.x1 sp(8)
	test/lang.initByRef.ci:35: (5 bytes): ptrVoid: pointer := void
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:36: (5 bytes): ptrBool: pointer := bool
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:37: (5 bytes): ptrChar: pointer := char
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:38: (5 bytes): ptrInt8: pointer := int8
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:39: (5 bytes): ptrInt16: pointer := int16
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:40: (5 bytes): ptrInt32: pointer := int32
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:41: (5 bytes): ptrInt64: pointer := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:42: (5 bytes): ptrUint8: pointer := uint8
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:43: (5 bytes): ptrUint16: pointer := uint16
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:44: (5 bytes): ptrUint32: pointer := uint32
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:45: (5 bytes): ptrUint64: pointer := uint64
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:46: (5 bytes): ptrFloat32: pointer := float32
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:47: (5 bytes): ptrFloat64: pointer := float64
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:48: (5 bytes): ptrTypename: pointer := typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:49: (5 bytes): ptrFunction: pointer := function
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:50: (5 bytes): ptrPointer: pointer := pointer
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:51: (5 bytes): ptrVariant: pointer := variant
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:52: (5 bytes): ptrObject: pointer := object
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:55: (10 bytes): varVoid: variant := void
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:56: (10 bytes): varBool: variant := bool
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:57: (10 bytes): varChar: variant := char
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:58: (10 bytes): varInt8: variant := int8
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:59: (10 bytes): varInt16: variant := int16
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:60: (10 bytes): varInt32: variant := int32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:61: (10 bytes): varInt64: variant := int64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:62: (10 bytes): varUint8: variant := uint8
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:63: (10 bytes): varUint16: variant := uint16
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:64: (10 bytes): varUint32: variant := uint32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:65: (10 bytes): varUint64: variant := uint64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:66: (10 bytes): varFloat32: variant := float32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:67: (10 bytes): varFloat64: variant := float64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:68: (10 bytes): varTypename: variant := typename
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:69: (10 bytes): varFunction: variant := function
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:70: (10 bytes): varPointer: variant := pointer
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:71: (10 bytes): varVariant: variant := variant
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:72: (10 bytes): varObject: variant := object
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:75: (5 bytes): typVoid: typename := void
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:76: (5 bytes): typBool: typename := bool
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:77: (5 bytes): typChar: typename := char
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:78: (5 bytes): typInt8: typename := int8
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:79: (5 bytes): typInt16: typename := int16
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:80: (5 bytes): typInt32: typename := int32
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:81: (5 bytes): typInt64: typename := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:82: (5 bytes): typUint8: typename := uint8
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:83: (5 bytes): typUint16: typename := uint16
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:84: (5 bytes): typUint32: typename := uint32
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:85: (5 bytes): typUint64: typename := uint64
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:86: (5 bytes): typFloat32: typename := float32
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:87: (5 bytes): typFloat64: typename := float64
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:88: (5 bytes): typTypename: typename := typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:89: (5 bytes): typFunction: typename := function
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:90: (5 bytes): typPointer: typename := pointer
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:91: (5 bytes): typVariant: typename := variant
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:92: (5 bytes): typObject: typename := object
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:95: (5 bytes): valueOfPtr: pointer := pointer(value)
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:96: (10 bytes): valueOfVar: variant := variant(value)
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:97: (5 bytes): valueOfTyp: typename := typename(value)
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:99: (5 bytes): typeOfValue: typename := typename(value)
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:105: (7 bytes): copyPtrFloat64: variant := ptrFloat64
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    dup.x1 sp(65)
	test/lang.initByRef.ci:108: (2 bytes): copyVarFloat64: pointer := varFloat64
	<.main+?>:    dup.x1 sp(35)
	test/lang.function.ci:11: (21 bytes): funAddResult: int32 := funAdd(2, 7)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;funAdd(x: int32, y: int32): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:14: (5 bytes): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+?>:    load.ref .?????? ;funAdd(x: int32, y: int32): int32
	test/lang.function.ci:17: (18 bytes): funAddRefResult: int32 := funAddRef(2, 8)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 8
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:20: (5 bytes): funMul(x: int32, y: int32): int32 := funMul
	<.main+?>:    load.ref .?????? ;funMul(x: int32, y: int32): int32
	test/lang.function.ci:23: (18 bytes): funMulResult: int32 := funMul(2, 6)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 6
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:26: (2 bytes): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+?>:    dup.x1 sp(1)
	test/lang.function.ci:29: (18 bytes): funMulRefResult: int32 := funMulRef(2, 7)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:45: (16 bytes): fibonacci_13: uint32 := fib(13)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 13
	<.main+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<.main+?>:    call
	<.main+?>:    inc.sp(-4)
	test/lang.reflect.ci:3: (4 bytes): sizeofVoid: int32 := sizeof(void)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:4: (4 bytes): sizeofBool: int32 := sizeof(bool)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:5: (4 bytes): sizeofChar: int32 := sizeof(char)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:6: (4 bytes): sizeofInt8: int32 := sizeof(int8)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:7: (4 bytes): sizeofInt16: int32 := sizeof(int16)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:8: (4 bytes): sizeofInt32: int32 := sizeof(int32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:9: (4 bytes): sizeofInt64: int32 := sizeof(int64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:10: (4 bytes): sizeofUint8: int32 := sizeof(uint8)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:11: (4 bytes): sizeofUint16: int32 := sizeof(uint16)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:12: (4 bytes): sizeofUint32: int32 := sizeof(uint32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:13: (4 bytes): sizeofUint64: int32 := sizeof(uint64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:14: (4 bytes): sizeofFloat32: int32 := sizeof(float32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:15: (4 bytes): sizeofFloat64: int32 := sizeof(float64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:16: (4 bytes): sizeofPointer: int32 := sizeof(pointer)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:17: (4 bytes): sizeofVariant: int32 := sizeof(variant)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:18: (4 bytes): sizeofTypename: int32 := sizeof(typename)
	<.main+?>:    load.m32 .?????? ;typename+24
	test/lang.reflect.ci:19: (4 bytes): sizeofFunction: int32 := sizeof(function)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:20: (4 bytes): sizeofObject: int32 := sizeof(object)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:30: (5 bytes): typeofRecord: typename := RecordSizeofExt
	<.main+?>:    load.ref .?????? ;RecordSizeofExt
	test/lang.reflect.ci:31: (6 bytes): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    nfc(4) ;typename.name(type: typename): .cstr
	test/lang.reflect.ci:32: (7 bytes): offsetOfRecord: int32 := typeofRecord.offset
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:33: (7 bytes): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:34: (6 bytes): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    nfc(2) ;typename.file(type: typename): .cstr
	test/lang.reflect.ci:35: (6 bytes): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    nfc(3) ;typename.line(type: typename): int32
	test/lang.reflect.ci:37: (6 bytes): typeofBase: typename := typename.base(typeofRecord)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:38: (6 bytes): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    nfc(4) ;typename.name(type: typename): .cstr
	test/lang.reflect.ci:39: (7 bytes): offsetOfBase: int32 := typeofBase.offset
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:40: (7 bytes): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:41: (6 bytes): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    nfc(2) ;typename.file(type: typename): .cstr
	test/lang.reflect.ci:42: (6 bytes): lineOfBase: int32 := typename.line(typeofBase)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    nfc(3) ;typename.line(type: typename): int32
	test/lang.reflect.ci:44: (6 bytes): typeofBase1: typename := typename.base(typeofBase)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:45: (7 bytes): offsetOfBase1: int32 := typeofBase1.offset
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:46: (7 bytes): sizeOfBase1: int32 := typeofBase1.size
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:48: (6 bytes): typeofBase2: typename := typename.base(typeofBase1)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:49: (7 bytes): offsetOfBase2: int32 := typeofBase2.offset
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:50: (7 bytes): sizeOfBase2: int32 := typeofBase2.size
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/stdc.number.ci:3: (9 bytes): pi64: float64 := 3.141593
	<.main+?>:    load.f64 3.141593
	test/stdc.number.ci:4: (9 bytes): e64: float64 := 2.718282
	<.main+?>:    load.f64 2.718282
	test/stdc.number.ci:6: (3 bytes): pi32: float32 := pi64
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    f64.2f32
	test/stdc.number.ci:7: (3 bytes): e32: float32 := e64
	<.main+?>:    dup.x2 sp(1)
	<.main+?>:    f64.2f32
	test/stdc.number.ci:14: (7 bytes): r_comp: int32 := 14 << 3
	<.main+?>:    load.c32 14
	<.main+?>:    b32.shl 0x003
	test/stdc.number.ci:15: (7 bytes): g_comp: int32 := 63 << 2
	<.main+?>:    load.c32 63
	<.main+?>:    b32.shl 0x002
	test/stdc.number.ci:16: (7 bytes): b_comp: int32 := 31 << 3
	<.main+?>:    load.c32 31
	<.main+?>:    b32.shl 0x003
	test/stdc.number.ci:18: (28 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.shl 0x008
	<.main+?>:    load.c32 63488
	<.main+?>:    and.b32
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.shl 0x003
	<.main+?>:    load.c32 2016
	<.main+?>:    and.b32
	<.main+?>:    or.b32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    b32.sar 0x003
	<.main+?>:    b32.and 0x01f
	<.main+?>:    or.b32
	test/stdc.number.ci:19: (26 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    b32.shl 0x010
	<.main+?>:    load.c32 16711680
	<.main+?>:    and.b32
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    b32.shl 0x008
	<.main+?>:    load.c32 65280
	<.main+?>:    and.b32
	<.main+?>:    or.b32
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.and 0x0ff
	<.main+?>:    or.b32
	test/stdc.number.ci:21: (16 bytes): zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    load.c32 11
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:22: (16 bytes): zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.c32 5
	<.main+?>:    load.c32 6
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:23: (12 bytes): zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:25: (16 bytes): sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    load.c32 11
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:26: (16 bytes): sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    load.c32 5
	<.main+?>:    load.c32 6
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:27: (12 bytes): sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:29: (16 bytes): zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.c32 16
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:30: (16 bytes): zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    load.c32 8
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:31: (12 bytes): zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:33: (16 bytes): sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    load.c32 16
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:34: (16 bytes): sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    load.c32 8
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:35: (12 bytes): sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:37: (16 bytes): sinF64: float64 := float64.sin(pi64 / (2))
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(36) ;float64.sin(x: float64): float64
	test/stdc.number.ci:38: (16 bytes): cosF64: float64 := float64.cos(pi64 / (2))
	<.main+?>:    dup.x2 sp(23)
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(37) ;float64.cos(x: float64): float64
	test/stdc.number.ci:39: (16 bytes): tanF64: float64 := float64.tan(pi64 / (4))
	<.main+?>:    dup.x2 sp(25)
	<.main+?>:    load.f64 4.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(38) ;float64.tan(x: float64): float64
	test/stdc.number.ci:40: (12 bytes): logF64: float64 := float64.log(e64 * e64 * e64)
	<.main+?>:    dup.x2 sp(25)
	<.main+?>:    dup.x2 sp(27)
	<.main+?>:    mul.f64
	<.main+?>:    dup.x2 sp(27)
	<.main+?>:    mul.f64
	<.main+?>:    nfc(39) ;float64.log(x: float64): float64
	test/stdc.number.ci:41: (13 bytes): expF64: float64 := float64.exp(1.000000)
	<.main+?>:    load.f64 1.000000
	<.main+?>:    nfc(40) ;float64.exp(x: float64): float64
	test/stdc.number.ci:42: (18 bytes): powF64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    mul.f64
	<.main+?>:    load.f64 0.500000
	<.main+?>:    nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc.number.ci:43: (9 bytes): sqrtF64: float64 := float64.sqrt(pi64 * pi64)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(35)
	<.main+?>:    mul.f64
	<.main+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc.number.ci:44: (15 bytes): atanF64: float64 := float64.atan2(pi64, 1.000000)
	<.main+?>:    dup.x2 sp(35)
	<.main+?>:    load.f64 1.000000
	<.main+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc.number.ci:46: (12 bytes): sinF32: float32 := float32.sin(pi32 / (2))
	<.main+?>:    dup.x1 sp(34)
	<.main+?>:    load.f32 2.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(28) ;float32.sin(x: float32): float32
	test/stdc.number.ci:47: (12 bytes): cosF32: float32 := float32.cos(pi32 / (2))
	<.main+?>:    dup.x1 sp(35)
	<.main+?>:    load.f32 2.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(29) ;float32.cos(x: float32): float32
	test/stdc.number.ci:48: (12 bytes): tanF32: float32 := float32.tan(pi32 / (4))
	<.main+?>:    dup.x1 sp(36)
	<.main+?>:    load.f32 4.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(30) ;float32.tan(x: float32): float32
	test/stdc.number.ci:49: (12 bytes): logF32: float32 := float32.log(e32 * e32 * e32)
	<.main+?>:    dup.x1 sp(36)
	<.main+?>:    dup.x1 sp(37)
	<.main+?>:    mul.f32
	<.main+?>:    dup.x1 sp(37)
	<.main+?>:    mul.f32
	<.main+?>:    nfc(31) ;float32.log(x: float32): float32
	test/stdc.number.ci:50: (9 bytes): expF32: float32 := float32.exp(1.000000)
	<.main+?>:    load.f32 1.000000
	<.main+?>:    nfc(32) ;float32.exp(x: float32): float32
	test/stdc.number.ci:51: (14 bytes): powF32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+?>:    dup.x1 sp(39)
	<.main+?>:    dup.x1 sp(40)
	<.main+?>:    mul.f32
	<.main+?>:    load.f32 0.500000
	<.main+?>:    nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc.number.ci:52: (9 bytes): sqrtF32: float32 := float32.sqrt(pi32 * pi32)
	<.main+?>:    dup.x1 sp(40)
	<.main+?>:    dup.x1 sp(41)
	<.main+?>:    mul.f32
	<.main+?>:    nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc.number.ci:53: (11 bytes): atanF32: float32 := float32.atan2(pi32, 1.000000)
	<.main+?>:    dup.x1 sp(41)
	<.main+?>:    load.f32 1.000000
	<.main+?>:    nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc.memory.ci:7: (14 bytes): p1: pointer := malloc(1024)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 1024
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:8: (14 bytes): p2: pointer := malloc(80)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 80
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:9: (14 bytes): p3: pointer := malloc(160)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 160
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:10: (14 bytes): p4: pointer := malloc(820)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 820
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:13: (16 bytes): pointer.fill(p1, 0, 1024);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 1024
	<.main+?>:    nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:14: (17 bytes): pointer.copy(p1, p3, 160);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.c32 160
	<.main+?>:    nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:17: (11 bytes): free(p1);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:18: (11 bytes): free(p2);
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:19: (11 bytes): free(p3);
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:20: (11 bytes): free(p4);
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:23: (9 bytes): val1: int64 := 42
	<.main+?>:    load.c64 42
	test/stdc.memory.ci:24: (9 bytes): val2: int64 := 96
	<.main+?>:    load.c64 96
	test/stdc.memory.ci:26: (34 bytes): debug("val1", val1);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 26
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val1"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+32)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:27: (34 bytes): debug("val2", val2);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 27
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val2"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:29: (20 bytes): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.m32 .??????
	<.main+?>:    nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:30: (17 bytes): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.z32
	<.main+?>:    load.m32 .??????
	<.main+?>:    nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:32: (34 bytes): debug("val1", val1);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 32
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val1"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+32)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:33: (34 bytes): debug("val2", val2);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 33
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val2"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.execute.ci:46: (14 bytes): tryExecErr0: int32 := tryExec(null, noError)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;noError(ptr: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:47: (14 bytes): tryExecErr1: int32 := tryExec(null, null)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:48: (14 bytes): tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;stackOverflow(ptr: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:49: (14 bytes): tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;divisionByZero(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:50: (14 bytes): tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;invalidInstruction(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:51: (14 bytes): tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;invalidMemoryAccess(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:52: (14 bytes): tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;abortExecution(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang.array.ci:49: (4 bytes): arrFixedNoInit: int64[7]
	<.main+?>:    inc.sp(+56)
	test/lang.array.ci:50: (4 bytes): arrArrayNoInit: int64[*]
	<.main+?>:    inc.sp(+4)
	test/lang.array.ci:51: (4 bytes): arrSliceNoInit: int64[]
	<.main+?>:    inc.sp(+8)
	test/lang.array.ci:54: (45 bytes): for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.array.ci:55: (20 bytes): arrFixedNoInit[i] := (42 + i);
	<.main+?>:    load.c32 42
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	<.main+?>:    i32.2i64
	<.main+?>:    load.sp(+24)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    mad.u32 8
	<.main+?>:    store.i64
	test/lang.array.ci:54: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.array.ci:54: (12 bytes): i < arrFixedNoInit.length
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.array.ci:59: (5 bytes): arrArrayInitNull: int64[*] := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.array.ci:60: (6 bytes): arrSliceInitNull: int64[] := null
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;null
	test/lang.array.ci:63: (4 bytes): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+?>:    load.sp(+24)
	test/lang.array.ci:64: (9 bytes): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+32)
	test/lang.array.ci:67: (2 bytes): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+?>:    dup.x1 sp(0)
	test/lang.array.ci:68: (2 bytes): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+?>:    dup.x2 sp(1)
	test/lang.array.ci:71: (2 bytes): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+?>:    dup.x1 sp(5)
	test/lang.array.ci:81: (4 bytes): strFixed: char[7]
	<.main+?>:    inc.sp(+8)
	test/lang.array.ci:82: (22 bytes): pointer.copy(strFixed, pointer("string"), 7);
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.ref .?????? ;"string"
	<.main+?>:    load.c32 7
	<.main+?>:    nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/lang.array.ci:83: (34 bytes): debug("string as variant", strFixed);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 83
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:84: (34 bytes): debug("string to variant", variant(strFixed));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 84
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:86: (5 bytes): strArray: char[*] := "string"
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.array.ci:87: (32 bytes): debug("string as variant", strArray);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 87
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:88: (32 bytes): debug("string to variant", variant(strArray));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 88
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:90: (10 bytes): strSlice: char[] := "string"
	<.main+?>:    load.c32 6
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.array.ci:91: (32 bytes): debug("string as variant", strSlice);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 91
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:92: (32 bytes): debug("string to variant", variant(strSlice));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 92
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:98: (51 bytes): assert(arrSliceNoInit.length >= (0));
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    load.z32
	<.main+?>:    clt.u32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 98
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:99: (51 bytes): assert(arrSliceInitNull.length == (0));
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 99
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:101: (59 bytes): assert(arrFixedNoInit[0] == (42));
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    load.c64 42
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 101
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:108: (25 bytes): assertEq(7, arrFixedNoInit.length);
	<.main+?>:    load.c32 7
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:109: (22 bytes): assertEq(arrFixedNoInit.length, arrSliceInitFixed.length);
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:110: (22 bytes): assertEq(arrFixedNoInit.length, arrSliceInitSlice.length);
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:112: (32 bytes): assertEq(0, lenSlice(null));
	<.main+?>:    load.z32
	<.main+?>:    load.z64
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:113: (29 bytes): assertEq(0, lenSlice(arrSliceInitNull));
	<.main+?>:    load.z32
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:114: (40 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrFixedNoInit));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+84)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:115: (33 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitFixed));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(11)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:116: (33 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitSlice));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:118: (807 bytes): for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.array.ci:119: (9 bytes): expected: int64 := 42 + i
	<.main+?>:    load.c32 42
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	<.main+?>:    i32.2i64
	test/lang.array.ci:120: (61 bytes): assert(expected == arrFixedNoInit[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.sp(+92)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 120
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:121: (59 bytes): assert(expected == arrArrayInitFixed[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 121
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:122: (59 bytes): assert(expected == arrSliceInitFixed[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 122
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:124: (67 bytes): assert(expected == nthFixed(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.sp(+104)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 124
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:125: (65 bytes): assert(expected == nthFixed(i, arrArrayInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 125
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:126: (65 bytes): assert(expected == nthFixed(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 126
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:128: (67 bytes): assert(expected == nthArray(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.sp(+104)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 128
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:129: (65 bytes): assert(expected == nthArray(i, arrArrayInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 129
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:130: (65 bytes): assert(expected == nthArray(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 130
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:132: (72 bytes): assert(expected == nthSlice(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+108)
	<.main+?>:    load.ref .?????? ;nthSlice(idx: int32, values: int64[]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 132
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:134: (65 bytes): assert(expected == nthSlice(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    load.ref .?????? ;nthSlice(idx: int32, values: int64[]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 134
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:136: (59 bytes): assert(expected == arrSliceInitSlice[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 136
	<.main+?>:    load.c32 -1
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    inc.sp(-8)
	test/lang.array.ci:118: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.array.ci:118: (12 bytes): i < arrFixedNoInit.length
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.member.ci:53: (60 bytes): recordMemberTest: RecordMemberTest := {...}
	<.main+?>:    inc.sp(+32)
	test/lang.member.ci:54: (7 bytes): recordMemberTest.member := 6;
	<.main+?>:    load.c32 6
	<.main+?>:    set.x1 sp(1)
	test/lang.member.ci:55: (7 bytes): recordMemberTest.constant := 7;
	<.main+?>:    load.c32 7
	<.main+?>:    set.x1 sp(2)
	test/lang.member.ci:56: (7 bytes): recordMemberTest.memberInit := 8;
	<.main+?>:    load.c32 8
	<.main+?>:    set.x1 sp(3)
	test/lang.member.ci:57: (7 bytes): recordMemberTest.constantInit := 9;
	<.main+?>:    load.c32 9
	<.main+?>:    set.x1 sp(4)
	test/lang.member.ci:60: (7 bytes): recordMemberTest.memberRec.member := 61;
	<.main+?>:    load.c32 61
	<.main+?>:    set.x1 sp(5)
	test/lang.member.ci:61: (7 bytes): recordMemberTest.memberRec.constant := 62;
	<.main+?>:    load.c32 62
	<.main+?>:    set.x1 sp(6)
	test/lang.member.ci:65: (7 bytes): recordMemberTest.constantRec.member := 71;
	<.main+?>:    load.c32 71
	<.main+?>:    set.x1 sp(7)
	test/lang.member.ci:66: (7 bytes): recordMemberTest.constantRec.constant := 72;
	<.main+?>:    load.c32 72
	<.main+?>:    set.x1 sp(8)
	test/lang.method.ci:45: (25 bytes): recordMethodTest: RecordMethodTest := {...}
	<.main+?>:    inc.sp(+16)
	test/lang.method.ci:46: (7 bytes): recordMethodTest.delegateMethod := globalFunction;
	<.main+?>:    load.ref .?????? ;globalFunction(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(2)
	test/lang.method.ci:47: (7 bytes): recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
	<.main+?>:    load.ref .?????? ;RecordMethodTest.staticMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(1)
	:: (7 bytes): recordMethodTest.virtualMethod := virtualMethod
	<.main+?>:    load.ref .?????? ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(3)
	test/lang.recUnion.ci:26: (22 bytes): black: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:26: (6 bytes): black.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:26: (6 bytes): black.g := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:26: (6 bytes): black.b := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (26 bytes): green: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:27: (6 bytes): green.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (10 bytes): green.g := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (6 bytes): green.b := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (34 bytes): white: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:28: (10 bytes): white.r := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (10 bytes): white.g := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (10 bytes): white.b := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:30: (11 bytes): cyan: color := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:30: (7 bytes): cyan.col := (65535);
	<.main+?>:    load.c32 65535
	<.main+?>:    set.x1 sp(1)
	test/lang.recUnion.ci:31: (26 bytes): blue: color := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:31: (6 bytes): blue.rgb.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:31: (6 bytes): blue.rgb.g := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:31: (10 bytes): blue.rgb.b := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.useOperator.ci:5: (5 bytes): shift: int32 := 2
	<.main+?>:    load.c32 2
	test/lang.useOperator.ci:7: (5 bytes): boolA: bool := true
	<.main+?>:    load.c32 1
	test/lang.useOperator.ci:8: (5 bytes): boolB: bool := !false
	<.main+?>:    load.c32 1
	test/lang.useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    not.b32
	test/lang.useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:30: (5 bytes): chrA: char := 'a'
	<.main+?>:    load.c32 97
	test/lang.useOperator.ci:31: (5 bytes): chrB: char := 'b'
	<.main+?>:    load.c32 98
	test/lang.useOperator.ci:32: (5 bytes): chrPls: char := +chrB
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.i32
	test/lang.useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:43: (8 bytes): chrShl: char := (chrA) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(26)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:44: (8 bytes): chrShr: char := (chrA) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(27)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:45: (7 bytes): chrNot: bool := !(chrB)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:53: (5 bytes): i8A: int8 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:54: (5 bytes): i8B: int8 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:55: (5 bytes): i8Pls: int8 := +i8B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.i32
	test/lang.useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:66: (8 bytes): i8Shl: int8 := (i8A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(48)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:67: (8 bytes): i8Shr: int8 := (i8A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(49)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:68: (7 bytes): i8Not: bool := !(i8B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:76: (5 bytes): u8A: uint8 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:77: (5 bytes): u8B: uint8 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:78: (5 bytes): u8Pls: uint8 := +u8B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.u32
	test/lang.useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:89: (8 bytes): u8Shl: uint8 := (u8A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(70)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:90: (8 bytes): u8Shr: uint8 := (u8A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(71)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:91: (7 bytes): u8Not: bool := !(u8B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:99: (5 bytes): i16A: int16 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:100: (5 bytes): i16B: int16 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:101: (5 bytes): i16Pls: int16 := +i16B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i16
	test/lang.useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i16
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i16
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    add.i32
	test/lang.useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    div.i32
	test/lang.useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    and.b32
	test/lang.useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    or.b32
	test/lang.useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:112: (8 bytes): i16Shl: int16 := (i16A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(92)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:113: (8 bytes): i16Shr: int16 := (i16A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(93)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:114: (7 bytes): i16Not: bool := !(i16B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:122: (5 bytes): u16A: uint16 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:123: (5 bytes): u16B: uint16 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:124: (5 bytes): u16Pls: uint16 := +u16B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i16
	test/lang.useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i16
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i16
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    add.i32
	test/lang.useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    div.u32
	test/lang.useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    and.b32
	test/lang.useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    or.b32
	test/lang.useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:135: (8 bytes): u16Shl: uint16 := (u16A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(114)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:136: (8 bytes): u16Shr: uint16 := (u16A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(115)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:137: (7 bytes): u16Not: bool := !(u16B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:145: (5 bytes): i32A: int32 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:146: (5 bytes): i32B: int32 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:147: (2 bytes): i32Pls: int32 := +i32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:148: (3 bytes): i32Neg: int32 := -i32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:149: (3 bytes): i32Cmt: int32 := ~i32B
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:150: (5 bytes): i32Add: int32 := i32A + i32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    add.i32
	test/lang.useOperator.ci:151: (5 bytes): i32Sub: int32 := i32A - i32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:152: (5 bytes): i32Mul: int32 := i32A * i32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:153: (5 bytes): i32Div: int32 := i32A / i32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    div.i32
	test/lang.useOperator.ci:154: (5 bytes): i32Mod: int32 := i32A % i32B
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:155: (5 bytes): i32And: int32 := i32A & i32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    and.b32
	test/lang.useOperator.ci:156: (5 bytes): i32Ior: int32 := i32A | i32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    or.b32
	test/lang.useOperator.ci:157: (5 bytes): i32Xor: int32 := i32A ^ i32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:158: (5 bytes): i32Shl: int32 := i32A << shift
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(136)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:159: (5 bytes): i32Shr: int32 := i32A >> shift
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(137)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:160: (4 bytes): i32Not: bool := !(i32B)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:161: (5 bytes): i32Ceq: bool := i32A == i32B
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:162: (6 bytes): i32Cne: bool := i32A != i32B
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:163: (5 bytes): i32Clt: bool := i32A < i32B
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:164: (6 bytes): i32Cle: bool := i32A <= i32B
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:165: (5 bytes): i32Cgt: bool := i32A > i32B
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:166: (6 bytes): i32Cge: bool := i32A >= i32B
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:168: (5 bytes): u32A: uint32 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:169: (5 bytes): u32B: uint32 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:170: (2 bytes): u32Pls: uint32 := +u32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:171: (3 bytes): u32Neg: uint32 := -u32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:172: (3 bytes): u32Cmt: uint32 := ~u32B
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:173: (5 bytes): u32Add: uint32 := u32A + u32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    add.i32
	test/lang.useOperator.ci:174: (5 bytes): u32Sub: uint32 := u32A - u32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:175: (5 bytes): u32Mul: uint32 := u32A * u32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:176: (5 bytes): u32Div: uint32 := u32A / u32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    div.u32
	test/lang.useOperator.ci:177: (5 bytes): u32Mod: uint32 := u32A % u32B
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:178: (5 bytes): u32And: uint32 := u32A & u32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    and.b32
	test/lang.useOperator.ci:179: (5 bytes): u32Ior: uint32 := u32A | u32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    or.b32
	test/lang.useOperator.ci:180: (5 bytes): u32Xor: uint32 := u32A ^ u32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:181: (5 bytes): u32Shl: uint32 := u32A << shift
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(158)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:182: (5 bytes): u32Shr: uint32 := u32A >> shift
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(159)
	<.main+?>:    shr.b32
	test/lang.useOperator.ci:183: (4 bytes): u32Not: bool := !(u32B)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:184: (5 bytes): u32Ceq: bool := u32A == u32B
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:185: (6 bytes): u32Cne: bool := u32A != u32B
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:186: (5 bytes): u32Clt: bool := u32A < u32B
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:187: (6 bytes): u32Cle: bool := u32A <= u32B
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:188: (5 bytes): u32Cgt: bool := u32A > u32B
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:189: (6 bytes): u32Cge: bool := u32A >= u32B
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:191: (9 bytes): i64A: int64 := a
	<.main+?>:    load.c64 96
	test/lang.useOperator.ci:192: (9 bytes): i64B: int64 := b
	<.main+?>:    load.c64 42
	test/lang.useOperator.ci:193: (2 bytes): i64Pls: int64 := +i64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:194: (3 bytes): i64Neg: int64 := -i64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.i64
	test/lang.useOperator.ci:195: (3 bytes): i64Cmt: int64 := ~i64B
	<.main+?>:    dup.x2 sp(4)
	<.main+?>:    cmt.b64
	test/lang.useOperator.ci:196: (5 bytes): i64Add: int64 := i64A + i64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    add.i64
	test/lang.useOperator.ci:197: (5 bytes): i64Sub: int64 := i64A - i64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    sub.i64
	test/lang.useOperator.ci:198: (5 bytes): i64Mul: int64 := i64A * i64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    mul.i64
	test/lang.useOperator.ci:199: (5 bytes): i64Div: int64 := i64A / i64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    div.i64
	test/lang.useOperator.ci:200: (5 bytes): i64Mod: int64 := i64A % i64B
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    mod.i64
	test/lang.useOperator.ci:201: (5 bytes): i64And: int64 := i64A & i64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    and.b64
	test/lang.useOperator.ci:202: (5 bytes): i64Ior: int64 := i64A | i64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    or.b64
	test/lang.useOperator.ci:203: (5 bytes): i64Xor: int64 := i64A ^ i64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    xor.b64
	test/lang.useOperator.ci:204: (5 bytes): i64Shl: int64 := i64A << shift
	<.main+?>:    dup.x2 sp(24)
	<.main+?>:    dup.x1 sp(194)
	<.main+?>:    shl.b64
	test/lang.useOperator.ci:205: (5 bytes): i64Shr: int64 := i64A >> shift
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    dup.x1 sp(196)
	<.main+?>:    sar.b64
	test/lang.useOperator.ci:206: (4 bytes): i64Not: bool := !(i64B)
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    i64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:207: (5 bytes): i64Ceq: bool := i64A == i64B
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    ceq.i64
	test/lang.useOperator.ci:208: (6 bytes): i64Cne: bool := i64A != i64B
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    ceq.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:209: (5 bytes): i64Clt: bool := i64A < i64B
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    clt.i64
	test/lang.useOperator.ci:210: (6 bytes): i64Cle: bool := i64A <= i64B
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    cgt.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:211: (5 bytes): i64Cgt: bool := i64A > i64B
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    cgt.i64
	test/lang.useOperator.ci:212: (6 bytes): i64Cge: bool := i64A >= i64B
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    clt.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:214: (9 bytes): u64A: uint64 := a
	<.main+?>:    load.c64 96
	test/lang.useOperator.ci:215: (9 bytes): u64B: uint64 := b
	<.main+?>:    load.c64 42
	test/lang.useOperator.ci:216: (2 bytes): u64Pls: uint64 := +u64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:217: (3 bytes): u64Neg: uint64 := -u64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.i64
	test/lang.useOperator.ci:218: (3 bytes): u64Cmt: uint64 := ~u64B
	<.main+?>:    dup.x2 sp(4)
	<.main+?>:    cmt.b64
	test/lang.useOperator.ci:219: (5 bytes): u64Add: uint64 := u64A + u64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    add.i64
	test/lang.useOperator.ci:220: (5 bytes): u64Sub: uint64 := u64A - u64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    sub.i64
	test/lang.useOperator.ci:221: (5 bytes): u64Mul: uint64 := u64A * u64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    mul.u64
	test/lang.useOperator.ci:222: (5 bytes): u64Div: uint64 := u64A / u64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    div.u64
	test/lang.useOperator.ci:223: (5 bytes): u64Mod: uint64 := u64A % u64B
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    mod.u64
	test/lang.useOperator.ci:224: (5 bytes): u64And: uint64 := u64A & u64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    and.b64
	test/lang.useOperator.ci:225: (5 bytes): u64Ior: uint64 := u64A | u64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    or.b64
	test/lang.useOperator.ci:226: (5 bytes): u64Xor: uint64 := u64A ^ u64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    xor.b64
	test/lang.useOperator.ci:227: (5 bytes): u64Shl: uint64 := u64A << shift
	<.main+?>:    dup.x2 sp(24)
	<.main+?>:    dup.x1 sp(231)
	<.main+?>:    shl.b64
	test/lang.useOperator.ci:228: (5 bytes): u64Shr: uint64 := u64A >> shift
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    dup.x1 sp(233)
	<.main+?>:    shr.b64
	test/lang.useOperator.ci:229: (4 bytes): u64Not: bool := !(u64B)
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    i64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:230: (5 bytes): u64Ceq: bool := u64A == u64B
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    ceq.i64
	test/lang.useOperator.ci:231: (6 bytes): u64Cne: bool := u64A != u64B
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    ceq.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:232: (5 bytes): u64Clt: bool := u64A < u64B
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    clt.u64
	test/lang.useOperator.ci:233: (6 bytes): u64Cle: bool := u64A <= u64B
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    cgt.u64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:234: (5 bytes): u64Cgt: bool := u64A > u64B
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    cgt.u64
	test/lang.useOperator.ci:235: (6 bytes): u64Cge: bool := u64A >= u64B
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    clt.u64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:237: (5 bytes): f32A: float32 := a
	<.main+?>:    load.f32 96.300003
	test/lang.useOperator.ci:238: (5 bytes): f32B: float32 := b
	<.main+?>:    load.f32 42.139999
	test/lang.useOperator.ci:239: (2 bytes): f32Pls: float32 := +f32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:240: (3 bytes): f32Neg: float32 := -f32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.f32
	test/lang.useOperator.ci:242: (5 bytes): f32Add: float32 := f32A + f32B
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    add.f32
	test/lang.useOperator.ci:243: (5 bytes): f32Sub: float32 := f32A - f32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    sub.f32
	test/lang.useOperator.ci:244: (5 bytes): f32Mul: float32 := f32A * f32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mul.f32
	test/lang.useOperator.ci:245: (5 bytes): f32Div: float32 := f32A / f32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    div.f32
	test/lang.useOperator.ci:246: (5 bytes): f32Mod: float32 := f32A % f32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    mod.f32
	test/lang.useOperator.ci:252: (4 bytes): f32Not: bool := !(f32B)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    f32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:253: (5 bytes): f32Ceq: bool := f32A == f32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    ceq.f32
	test/lang.useOperator.ci:254: (6 bytes): f32Cne: bool := f32A != f32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    ceq.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:255: (5 bytes): f32Clt: bool := f32A < f32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    clt.f32
	test/lang.useOperator.ci:256: (6 bytes): f32Cle: bool := f32A <= f32B
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    cgt.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:257: (5 bytes): f32Cgt: bool := f32A > f32B
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    cgt.f32
	test/lang.useOperator.ci:258: (6 bytes): f32Cge: bool := f32A >= f32B
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    clt.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:260: (9 bytes): f64A: float64 := a
	<.main+?>:    load.f64 96.300000
	test/lang.useOperator.ci:261: (9 bytes): f64B: float64 := b
	<.main+?>:    load.f64 42.140000
	test/lang.useOperator.ci:262: (2 bytes): f64Pls: float64 := +f64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:263: (3 bytes): f64Neg: float64 := -f64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.f64
	test/lang.useOperator.ci:265: (5 bytes): f64Add: float64 := f64A + f64B
	<.main+?>:    dup.x2 sp(6)
	<.main+?>:    dup.x2 sp(6)
	<.main+?>:    add.f64
	test/lang.useOperator.ci:266: (5 bytes): f64Sub: float64 := f64A - f64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    sub.f64
	test/lang.useOperator.ci:267: (5 bytes): f64Mul: float64 := f64A * f64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    mul.f64
	test/lang.useOperator.ci:268: (5 bytes): f64Div: float64 := f64A / f64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    div.f64
	test/lang.useOperator.ci:269: (5 bytes): f64Mod: float64 := f64A % f64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    mod.f64
	test/lang.useOperator.ci:275: (4 bytes): f64Not: bool := !(f64B)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    f64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:276: (5 bytes): f64Ceq: bool := f64A == f64B
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    ceq.f64
	test/lang.useOperator.ci:277: (6 bytes): f64Cne: bool := f64A != f64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    ceq.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:278: (5 bytes): f64Clt: bool := f64A < f64B
	<.main+?>:    dup.x2 sp(19)
	<.main+?>:    dup.x2 sp(19)
	<.main+?>:    clt.f64
	test/lang.useOperator.ci:279: (6 bytes): f64Cle: bool := f64A <= f64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    cgt.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:280: (5 bytes): f64Cgt: bool := f64A > f64B
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    cgt.f64
	test/lang.useOperator.ci:281: (6 bytes): f64Cge: bool := f64A >= f64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    clt.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:283: (5 bytes): ptrA: pointer := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.useOperator.ci:284: (4 bytes): ptrB: pointer := pointer(shift)
	<.main+?>:    load.sp(+1128)
	test/lang.useOperator.ci:299: (5 bytes): ptrCeq: bool := ptrA == ptrB
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:300: (6 bytes): ptrCne: bool := ptrA != ptrB
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.statementIf.ci:4: (39 bytes): raise(raise.debug, 1, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 4
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 1
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:12: (39 bytes): raise(raise.debug, 3, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 12
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 3
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:22: (39 bytes): raise(raise.debug, 6, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 22
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 6
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:26: (1 bytes): t: int32 := 0
	<.main+?>:    load.z32
	test/lang.statementIf.ci:28: (46 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:29: (38 bytes): raise(raise.debug, 7, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 29
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:32: (46 bytes): if (t != 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementIf.ci:33: (38 bytes): raise(raise.debug, 8, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 33
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 8
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:36: (88 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:37: (38 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 37
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 9
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:40: (38 bytes): raise(raise.debug, 10, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 40
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:43: (88 bytes): if (t != 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementIf.ci:44: (38 bytes): raise(raise.debug, 11, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 44
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 11
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:47: (38 bytes): raise(raise.debug, 12, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 47
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 12
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:50: (358 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:51: (38 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 51
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 9
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:53: (308 bytes): if (t == 1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 1
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:54: (38 bytes): raise(raise.debug, 10, "t == 1", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 54
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 1"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:56: (254 bytes): if (t == 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:57: (38 bytes): raise(raise.debug, 10, "t == 2", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 57
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 2"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:59: (200 bytes): if (t == 3)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 3
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:60: (38 bytes): raise(raise.debug, 10, "t == 3", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 60
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 3"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:62: (146 bytes): if (t == 4)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 4
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:63: (38 bytes): raise(raise.debug, 10, "t == 4", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 63
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 4"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:65: (92 bytes): if (t == 5)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 5
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:66: (38 bytes): raise(raise.debug, 10, "t == 5", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 66
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 5"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:69: (38 bytes): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 69
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:3: (47 bytes): for ( ; ; )
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:4: (35 bytes): debug("for ( ; ; )");
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 4
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for ( ; ; )"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:5: (4 bytes): break;
	<.main+?>:    jmp <.main+?>
	:: (4 bytes)
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:8: (59 bytes): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:9: (34 bytes): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 9
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for (int i = 0; i < 2; i += 1)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:8: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:8: (12 bytes): i < 2
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.statementFor.ci:12: (1 bytes): forIdx: int32
	<.main+?>:    load.z32
	test/lang.statementFor.ci:13: (57 bytes): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+?>:    load.z32
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:14: (34 bytes): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:13: (4 bytes): forIdx := forIdx + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:13: (12 bytes): forIdx < 2
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementFor.ci:17: (75 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:18: (16 bytes): if (i < 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementFor.ci:19: (4 bytes): continue;
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:21: (34 bytes): debug("for with continue", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 21
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for with continue"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:17: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:17: (12 bytes): i < 7
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.statementFor.ci:24: (75 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:25: (16 bytes): if (i > 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    cgt.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementFor.ci:26: (4 bytes): break;
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:28: (34 bytes): debug("for with break", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 28
	<.main+?>:    load.c32 3
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for with break"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:24: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:24: (12 bytes): i < 7
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	<.main+?>:    nfc(0) ;halt(): void
}

---------- Execute:

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
stdlib.ci:32: assertEq: function(<assertEq @02a560>)
test/lang.inlineEmit.ci:3: emitldz32: int32(0)
test/lang.inlineEmit.ci:4: emitldz64: int64(0)
test/lang.inlineEmit.ci:6: emitA: int32(42)
test/lang.inlineEmit.ci:7: emitB: int32(96)
test/lang.inlineEmit.ci:9: emitAddI32: int32(138)
test/lang.inlineEmit.ci:10: emitDivI32: int32(2)
test/lang.inlineEmit.ci:11: emitNfcF32: float32(1.000000)
test/lang.inlineEmit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang.inlineEmit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang.inlineEmit.ci:19: emitFloatAsInt3: int32(0)
test/lang.inlineEmit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang.inlineEmit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang.inlineMacros.ci:13: ma: int32(3)
test/lang.inlineMacros.ci:14: mb: int32(6)
test/lang.inlineMacros.ci:15: mc: int32(9)
test/lang.inlineMacros.ci:17: zeroVal: int32(0)
test/lang.inlineMacros.ci:18: zeroVar: int32(0)
test/lang.inlineMacros.ci:19: zeroXpr: int32(0)
test/lang.inlineMacros.ci:21: lastVal: int32(3)
test/lang.inlineMacros.ci:22: lastVar: int32(6)
test/lang.inlineMacros.ci:23: lastXpr: int32(15)
test/lang.inlineMacros.ci:25: sum2Val: int32(15)
test/lang.inlineMacros.ci:26: sum2Var: int32(9)
test/lang.inlineMacros.ci:27: sum2Xpr: int32(24)
test/lang.inlineMacros.ci:29: any2Val: int32(3)
test/lang.inlineMacros.ci:30: any2Var: int32(3)
test/lang.inlineMacros.ci:31: any2Xpr: int32(9)
test/lang.inlineMacros.ci:33: min2Val: int32(3)
test/lang.inlineMacros.ci:34: min2Var: int32(3)
test/lang.inlineMacros.ci:35: min2Xpr: int32(9)
test/lang.inlineMacros.ci:37: sum3Val: int32(11)
test/lang.inlineMacros.ci:38: sum3Var: int32(18)
test/lang.inlineMacros.ci:39: sum3Xpr: int32(36)
test/lang.inlineMacros.ci:41: any3Val: int32(3)
test/lang.inlineMacros.ci:42: any3Var: int32(3)
test/lang.inlineMacros.ci:43: any3Xpr: int32(9)
test/lang.inlineMacros.ci:45: min3Val: int32(2)
test/lang.inlineMacros.ci:46: min3Var: int32(3)
test/lang.inlineMacros.ci:47: min3Xpr: int32(9)
test/test.inlineOverload.ci:9: overload1: float32(1.000000)
test/test.inlineOverload.ci:10: overload2: float32(2.000000)
test/test.inlineOverload.ci:11: overload3: float32(3.000000)
test/test.inlineOverload.ci:12: overload4: float32(4.000000)
test/test.inlineOverload.ci:13: overload5: float32(5.000000)
test/test.inlineOverload.ci:15: Celsius: typename(<Celsius>)
test/test.inlineOverload.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/test.inlineOverload.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
test/test.inlineOverload.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
test/lang.initByRef.ci:7: value: int64(42)
test/lang.initByRef.ci:8: valueRef: int64(42)
test/lang.initByRef.ci:9: valuePtr: pointer(<value @02a5a8>)
test/lang.initByRef.ci:10: valueVar: variant({int64: 42})
test/lang.initByRef.ci:12: fromRef: int64(42)
test/lang.initByRef.ci:13: fromPtr: int64(42)
test/lang.initByRef.ci:14: fromVar: int64(42)
test/lang.initByRef.ci:16: nullRef: int64(null)
test/lang.initByRef.ci:17: nullPtr: pointer(null)
test/lang.initByRef.ci:18: nullVar: variant(null)
test/lang.initByRef.ci:19: nullTyp: typename(null)
test/lang.initByRef.ci:20: nullFun: function(null)
test/lang.initByRef.ci:21: nullObj: object(null)
test/lang.initByRef.ci:23: typePtr: pointer(<int64 @000400>)
test/lang.initByRef.ci:24: typeVar: variant({typename: <int64>})
test/lang.initByRef.ci:25: typeTyp: typename(<int64>)
test/lang.initByRef.ci:27: local: int64(42)
test/lang.initByRef.ci:28: copyVal: int64(42)
test/lang.initByRef.ci:29: copyRef: int64(42)
test/lang.initByRef.ci:30: copyPtr: pointer(<value @02a5a8>)
test/lang.initByRef.ci:31: copyVar: variant({int64: 42})
test/lang.initByRef.ci:32: copyTyp: typename(<int64>)
test/lang.initByRef.ci:35: ptrVoid: pointer(<void @0000a0>)
test/lang.initByRef.ci:36: ptrBool: pointer(<bool @000130>)
test/lang.initByRef.ci:37: ptrChar: pointer(<char @0001c0>)
test/lang.initByRef.ci:38: ptrInt8: pointer(<int8 @000250>)
test/lang.initByRef.ci:39: ptrInt16: pointer(<int16 @0002e0>)
test/lang.initByRef.ci:40: ptrInt32: pointer(<int32 @000370>)
test/lang.initByRef.ci:41: ptrInt64: pointer(<int64 @000400>)
test/lang.initByRef.ci:42: ptrUint8: pointer(<uint8 @000490>)
test/lang.initByRef.ci:43: ptrUint16: pointer(<uint16 @000520>)
test/lang.initByRef.ci:44: ptrUint32: pointer(<uint32 @0005b0>)
test/lang.initByRef.ci:45: ptrUint64: pointer(<uint64 @000640>)
test/lang.initByRef.ci:46: ptrFloat32: pointer(<float32 @0006d0>)
test/lang.initByRef.ci:47: ptrFloat64: pointer(<float64 @000760>)
test/lang.initByRef.ci:48: ptrTypename: pointer(<typename @000008>)
test/lang.initByRef.ci:49: ptrFunction: pointer(<function @000910>)
test/lang.initByRef.ci:50: ptrPointer: pointer(<pointer @0007f0>)
test/lang.initByRef.ci:51: ptrVariant: pointer(<variant @000880>)
test/lang.initByRef.ci:52: ptrObject: pointer(<object @0009a8>)
test/lang.initByRef.ci:55: varVoid: variant({typename: <void>})
test/lang.initByRef.ci:56: varBool: variant({typename: <bool>})
test/lang.initByRef.ci:57: varChar: variant({typename: <char>})
test/lang.initByRef.ci:58: varInt8: variant({typename: <int8>})
test/lang.initByRef.ci:59: varInt16: variant({typename: <int16>})
test/lang.initByRef.ci:60: varInt32: variant({typename: <int32>})
test/lang.initByRef.ci:61: varInt64: variant({typename: <int64>})
test/lang.initByRef.ci:62: varUint8: variant({typename: <uint8>})
test/lang.initByRef.ci:63: varUint16: variant({typename: <uint16>})
test/lang.initByRef.ci:64: varUint32: variant({typename: <uint32>})
test/lang.initByRef.ci:65: varUint64: variant({typename: <uint64>})
test/lang.initByRef.ci:66: varFloat32: variant({typename: <float32>})
test/lang.initByRef.ci:67: varFloat64: variant({typename: <float64>})
test/lang.initByRef.ci:68: varTypename: variant({typename: <typename>})
test/lang.initByRef.ci:69: varFunction: variant({typename: <function>})
test/lang.initByRef.ci:70: varPointer: variant({typename: <pointer>})
test/lang.initByRef.ci:71: varVariant: variant({typename: <variant>})
test/lang.initByRef.ci:72: varObject: variant({typename: <object>})
test/lang.initByRef.ci:75: typVoid: typename(<void>)
test/lang.initByRef.ci:76: typBool: typename(<bool>)
test/lang.initByRef.ci:77: typChar: typename(<char>)
test/lang.initByRef.ci:78: typInt8: typename(<int8>)
test/lang.initByRef.ci:79: typInt16: typename(<int16>)
test/lang.initByRef.ci:80: typInt32: typename(<int32>)
test/lang.initByRef.ci:81: typInt64: typename(<int64>)
test/lang.initByRef.ci:82: typUint8: typename(<uint8>)
test/lang.initByRef.ci:83: typUint16: typename(<uint16>)
test/lang.initByRef.ci:84: typUint32: typename(<uint32>)
test/lang.initByRef.ci:85: typUint64: typename(<uint64>)
test/lang.initByRef.ci:86: typFloat32: typename(<float32>)
test/lang.initByRef.ci:87: typFloat64: typename(<float64>)
test/lang.initByRef.ci:88: typTypename: typename(<typename>)
test/lang.initByRef.ci:89: typFunction: typename(<function>)
test/lang.initByRef.ci:90: typPointer: typename(<pointer>)
test/lang.initByRef.ci:91: typVariant: typename(<variant>)
test/lang.initByRef.ci:92: typObject: typename(<object>)
test/lang.initByRef.ci:95: valueOfPtr: pointer(<value @02a5a8>)
test/lang.initByRef.ci:96: valueOfVar: variant({int64: 42})
test/lang.initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang.initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang.initByRef.ci:105: copyPtrFloat64: variant({pointer: <float64 @000760>})
test/lang.initByRef.ci:108: copyVarFloat64: pointer(<float64 @000760>)
test/lang.function.ci:3: empty: function(<empty @02a5b0>)
test/lang.function.ci:6: funAdd: function(<funAdd @02a5b8>)
test/lang.function.ci:11: funAddResult: int32(9)
test/lang.function.ci:14: funAddRef: function(<funAdd @02a5b8>)
test/lang.function.ci:17: funAddRefResult: int32(10)
test/lang.function.ci:20: funMul: function(<funMul @02a5c0>)
test/lang.function.ci:23: funMulResult: int32(12)
test/lang.function.ci:26: funMulRef: function(<funMul @02a5c0>)
test/lang.function.ci:29: funMulRefResult: int32(14)
test/lang.function.ci:32: funMul: function(<funMul @02a5c0>)
test/lang.function.ci:37: fib: function(<fib @02a5c8>)
test/lang.function.ci:45: fibonacci_13: uint32(233)
test/lang.reflect.ci:3: sizeofVoid: int32(0)
test/lang.reflect.ci:4: sizeofBool: int32(1)
test/lang.reflect.ci:5: sizeofChar: int32(1)
test/lang.reflect.ci:6: sizeofInt8: int32(1)
test/lang.reflect.ci:7: sizeofInt16: int32(2)
test/lang.reflect.ci:8: sizeofInt32: int32(4)
test/lang.reflect.ci:9: sizeofInt64: int32(8)
test/lang.reflect.ci:10: sizeofUint8: int32(1)
test/lang.reflect.ci:11: sizeofUint16: int32(2)
test/lang.reflect.ci:12: sizeofUint32: int32(4)
test/lang.reflect.ci:13: sizeofUint64: int32(8)
test/lang.reflect.ci:14: sizeofFloat32: int32(4)
test/lang.reflect.ci:15: sizeofFloat64: int32(8)
test/lang.reflect.ci:16: sizeofPointer: int32(4)
test/lang.reflect.ci:17: sizeofVariant: int32(8)
test/lang.reflect.ci:18: sizeofTypename: int32(136)
test/lang.reflect.ci:19: sizeofFunction: int32(4)
test/lang.reflect.ci:20: sizeofObject: int32(4)
test/lang.reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang.reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang.reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang.reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang.reflect.ci:32: offsetOfRecord: int32(96432)
test/lang.reflect.ci:33: sizeOfRecord: int32(16)
test/lang.reflect.ci:34: fileOfRecord: char[*]("test/lang.reflect.ci")
test/lang.reflect.ci:35: lineOfRecord: int32(26)
test/lang.reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang.reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang.reflect.ci:39: offsetOfBase: int32(96160)
test/lang.reflect.ci:40: sizeOfBase: int32(12)
test/lang.reflect.ci:41: fileOfBase: char[*]("test/lang.reflect.ci")
test/lang.reflect.ci:42: lineOfBase: int32(22)
test/lang.reflect.ci:44: typeofBase1: typename(<object>)
test/lang.reflect.ci:45: offsetOfBase1: int32(2472)
test/lang.reflect.ci:46: sizeOfBase1: int32(4)
test/lang.reflect.ci:48: typeofBase2: typename(<typename>)
test/lang.reflect.ci:49: offsetOfBase2: int32(8)
test/lang.reflect.ci:50: sizeOfBase2: int32(136)
test/stdc.number.ci:3: pi64: float64(3.141593)
test/stdc.number.ci:4: e64: float64(2.718282)
test/stdc.number.ci:6: pi32: float32(3.141593)
test/stdc.number.ci:7: e32: float32(2.718282)
test/stdc.number.ci:14: r_comp: int32(112)
test/stdc.number.ci:15: g_comp: int32(252)
test/stdc.number.ci:16: b_comp: int32(248)
test/stdc.number.ci:18: r5g6b5: int32(30719)
test/stdc.number.ci:19: r8g8b8: int32(7404792)
test/stdc.number.ci:21: zxtR5: int32(14)
test/stdc.number.ci:22: zxtG6: int32(63)
test/stdc.number.ci:23: zxtB5: int32(31)
test/stdc.number.ci:25: sxtR5: int32(14)
test/stdc.number.ci:26: sxtG6: int32(-1)
test/stdc.number.ci:27: sxtB5: int32(-1)
test/stdc.number.ci:29: zxtR8: int32(112)
test/stdc.number.ci:30: zxtG8: int32(252)
test/stdc.number.ci:31: zxtB8: int32(248)
test/stdc.number.ci:33: sxtR8: int32(112)
test/stdc.number.ci:34: sxtG8: int32(-4)
test/stdc.number.ci:35: sxtB8: int32(-8)
test/stdc.number.ci:37: sinF64: float64(1.000000)
test/stdc.number.ci:38: cosF64: float64(0.000000)
test/stdc.number.ci:39: tanF64: float64(1.000000)
test/stdc.number.ci:40: logF64: float64(3.000000)
test/stdc.number.ci:41: expF64: float64(2.718282)
test/stdc.number.ci:42: powF64: float64(3.141593)
test/stdc.number.ci:43: sqrtF64: float64(3.141593)
test/stdc.number.ci:44: atanF64: float64(1.262627)
test/stdc.number.ci:46: sinF32: float32(1.000000)
test/stdc.number.ci:47: cosF32: float32(-0.000000)
test/stdc.number.ci:48: tanF32: float32(1.000000)
test/stdc.number.ci:49: logF32: float32(3.000000)
test/stdc.number.ci:50: expF32: float32(2.718282)
test/stdc.number.ci:51: powF32: float32(3.141593)
test/stdc.number.ci:52: sqrtF32: float32(3.141593)
test/stdc.number.ci:53: atanF32: float32(1.262627)
test/stdc.memory.ci:7: p1: pointer(<@02c2a0>)
test/stdc.memory.ci:8: p2: pointer(<@02c6b0>)
test/stdc.memory.ci:9: p3: pointer(<@02c710>)
test/stdc.memory.ci:10: p4: pointer(<@02c7c0>)
test/stdc.memory.ci:23: val1: int64(0)
test/stdc.memory.ci:24: val2: int64(42)
test/stdc.execute.ci:11: noError: function(<noError @02a600>)
test/stdc.execute.ci:14: stackOverflow: function(<stackOverflow @02a608>)
test/stdc.execute.ci:19: divisionByZero: function(<divisionByZero @02a620>)
test/stdc.execute.ci:23: abortExecution: function(<abortExecution @02a630>)
test/stdc.execute.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess @02a670>)
test/stdc.execute.ci:42: invalidInstruction: function(<invalidInstruction @02a680>)
test/stdc.execute.ci:46: tryExecErr0: int32(0)
test/stdc.execute.ci:47: tryExecErr1: int32(1)
test/stdc.execute.ci:48: tryExecErr2: int32(2)
test/stdc.execute.ci:49: tryExecErr3: int32(3)
test/stdc.execute.ci:50: tryExecErr4: int32(4)
test/stdc.execute.ci:51: tryExecErr5: int32(5)
test/stdc.execute.ci:52: tryExecErr6: int32(6)
test/lang.array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:50: arrArrayNoInit: int64[*](BadRef)
test/lang.array.ci:51: arrSliceNoInit: int64[](BadRef)
test/lang.array.ci:59: arrArrayInitNull: int64[*](null)
test/lang.array.ci:60: arrSliceInitNull: int64[](null)
test/lang.array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang.array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang.array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang.array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang.array.ci:86: strArray: char[*]("string")
test/lang.array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang.array.ci:103: lenSlice: function(<lenSlice @02a688>)
test/lang.array.ci:104: nthFixed: function(<nthFixed @02a690>)
test/lang.array.ci:105: nthArray: function(<nthArray @02a6a0>)
test/lang.array.ci:106: nthSlice: function(<nthSlice @02a6b0>)
test/lang.member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang.member.ci:35: RecordMemberTest.global: int32(0)
test/lang.member.ci:38: RecordMemberTest.globalInit: int32(5)
test/lang.member.ci:41: RecordMemberTest.globalConstant: int32(6)
test/lang.member.ci:44: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(0)
})
test/lang.member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: int32(51),
	constant: int32(52)
})
test/lang.member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: int32(61),
	constant: int32(62)
})
test/lang.member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang.member.ci:53: recordMemberTest: RecordMemberTest({
	member: int32(6),
	constant: int32(7),
	memberInit: int32(8),
	constantInit: int32(9),
	memberRec: Inner({
		member: int32(61),
		constant: int32(62)
	}),
	constantRec: Inner({
		member: int32(71),
		constant: int32(72)
	})
})
test/lang.method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod @02a6f0>)
test/lang.method.ci:12: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod @02a708>)
test/lang.method.ci:26: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod @02a700>)
test/lang.method.ci:31: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod @02a708>)
test/lang.method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang.method.ci:41: globalFunction: function(<globalFunction @02a710>)
test/lang.method.ci:45: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<RecordMethodTest.staticMethod @02a6f0>),
	delegateMethod: function(<globalFunction @02a710>),
	virtualMethod: function(<RecordMethodTest.virtualMethod @02a700>)
})
test/lang.recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang.recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang.recUnion.ci:16: color: typename(<color>)
test/lang.recUnion.ci:22: Color: typename(<Color>)
test/lang.recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
test/lang.recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
test/lang.recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
test/lang.recUnion.ci:30: cyan: color({
	col: uint32(65535),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(255),
		r: uint8(0)
	})
})
test/lang.recUnion.ci:31: blue: color({
	col: uint32(255),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(0),
		r: uint8(0)
	})
})
test/lang.recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang.recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang.recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang.recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang.recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang.recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang.useOperator.ci:5: shift: int32(2)
test/lang.useOperator.ci:7: boolA: bool(1)
test/lang.useOperator.ci:8: boolB: bool(1)
test/lang.useOperator.ci:17: boolAnd: bool(1)
test/lang.useOperator.ci:18: boolIor: bool(1)
test/lang.useOperator.ci:19: boolXor: bool(0)
test/lang.useOperator.ci:22: boolNot: bool(0)
test/lang.useOperator.ci:23: boolCeq: bool(1)
test/lang.useOperator.ci:24: boolCne: bool(0)
test/lang.useOperator.ci:25: boolClt: bool(0)
test/lang.useOperator.ci:26: boolCle: bool(1)
test/lang.useOperator.ci:27: boolCgt: bool(0)
test/lang.useOperator.ci:28: boolCge: bool(1)
test/lang.useOperator.ci:30: chrA: char('a')
test/lang.useOperator.ci:31: chrB: char('b')
test/lang.useOperator.ci:32: chrPls: char('b')
test/lang.useOperator.ci:33: chrNeg: char('')
test/lang.useOperator.ci:34: chrCmt: char('')
test/lang.useOperator.ci:35: chrAdd: char('')
test/lang.useOperator.ci:36: chrSub: char('')
test/lang.useOperator.ci:37: chrMul: char('\"')
test/lang.useOperator.ci:38: chrDiv: char('')
test/lang.useOperator.ci:39: chrMod: char('a')
test/lang.useOperator.ci:40: chrAnd: char('`')
test/lang.useOperator.ci:41: chrIor: char('c')
test/lang.useOperator.ci:42: chrXor: char('')
test/lang.useOperator.ci:43: chrShl: char('')
test/lang.useOperator.ci:44: chrShr: char('')
test/lang.useOperator.ci:45: chrNot: bool(0)
test/lang.useOperator.ci:46: chrCeq: bool(0)
test/lang.useOperator.ci:47: chrCne: bool(1)
test/lang.useOperator.ci:48: chrClt: bool(1)
test/lang.useOperator.ci:49: chrCle: bool(1)
test/lang.useOperator.ci:50: chrCgt: bool(0)
test/lang.useOperator.ci:51: chrCge: bool(0)
test/lang.useOperator.ci:53: i8A: int8(96)
test/lang.useOperator.ci:54: i8B: int8(42)
test/lang.useOperator.ci:55: i8Pls: int8(42)
test/lang.useOperator.ci:56: i8Neg: int8(-42)
test/lang.useOperator.ci:57: i8Cmt: int8(-43)
test/lang.useOperator.ci:58: i8Add: int8(-118)
test/lang.useOperator.ci:59: i8Sub: int8(54)
test/lang.useOperator.ci:60: i8Mul: int8(-64)
test/lang.useOperator.ci:61: i8Div: int8(2)
test/lang.useOperator.ci:62: i8Mod: int8(12)
test/lang.useOperator.ci:63: i8And: int8(32)
test/lang.useOperator.ci:64: i8Ior: int8(106)
test/lang.useOperator.ci:65: i8Xor: int8(74)
test/lang.useOperator.ci:66: i8Shl: int8(-128)
test/lang.useOperator.ci:67: i8Shr: int8(24)
test/lang.useOperator.ci:68: i8Not: bool(0)
test/lang.useOperator.ci:69: i8Ceq: bool(0)
test/lang.useOperator.ci:70: i8Cne: bool(1)
test/lang.useOperator.ci:71: i8Clt: bool(0)
test/lang.useOperator.ci:72: i8Cle: bool(0)
test/lang.useOperator.ci:73: i8Cgt: bool(1)
test/lang.useOperator.ci:74: i8Cge: bool(1)
test/lang.useOperator.ci:76: u8A: uint8(96)
test/lang.useOperator.ci:77: u8B: uint8(42)
test/lang.useOperator.ci:78: u8Pls: uint8(42)
test/lang.useOperator.ci:79: u8Neg: uint8(214)
test/lang.useOperator.ci:80: u8Cmt: uint8(213)
test/lang.useOperator.ci:81: u8Add: uint8(138)
test/lang.useOperator.ci:82: u8Sub: uint8(54)
test/lang.useOperator.ci:83: u8Mul: uint8(192)
test/lang.useOperator.ci:84: u8Div: uint8(2)
test/lang.useOperator.ci:85: u8Mod: uint8(12)
test/lang.useOperator.ci:86: u8And: uint8(32)
test/lang.useOperator.ci:87: u8Ior: uint8(106)
test/lang.useOperator.ci:88: u8Xor: uint8(74)
test/lang.useOperator.ci:89: u8Shl: uint8(128)
test/lang.useOperator.ci:90: u8Shr: uint8(24)
test/lang.useOperator.ci:91: u8Not: bool(0)
test/lang.useOperator.ci:92: u8Ceq: bool(0)
test/lang.useOperator.ci:93: u8Cne: bool(1)
test/lang.useOperator.ci:94: u8Clt: bool(0)
test/lang.useOperator.ci:95: u8Cle: bool(0)
test/lang.useOperator.ci:96: u8Cgt: bool(1)
test/lang.useOperator.ci:97: u8Cge: bool(1)
test/lang.useOperator.ci:99: i16A: int16(96)
test/lang.useOperator.ci:100: i16B: int16(42)
test/lang.useOperator.ci:101: i16Pls: int16(42)
test/lang.useOperator.ci:102: i16Neg: int16(-42)
test/lang.useOperator.ci:103: i16Cmt: int16(-43)
test/lang.useOperator.ci:104: i16Add: int16(138)
test/lang.useOperator.ci:105: i16Sub: int16(54)
test/lang.useOperator.ci:106: i16Mul: int16(4032)
test/lang.useOperator.ci:107: i16Div: int16(2)
test/lang.useOperator.ci:108: i16Mod: int16(12)
test/lang.useOperator.ci:109: i16And: int16(32)
test/lang.useOperator.ci:110: i16Ior: int16(106)
test/lang.useOperator.ci:111: i16Xor: int16(74)
test/lang.useOperator.ci:112: i16Shl: int16(384)
test/lang.useOperator.ci:113: i16Shr: int16(24)
test/lang.useOperator.ci:114: i16Not: bool(0)
test/lang.useOperator.ci:115: i16Ceq: bool(0)
test/lang.useOperator.ci:116: i16Cne: bool(1)
test/lang.useOperator.ci:117: i16Clt: bool(0)
test/lang.useOperator.ci:118: i16Cle: bool(0)
test/lang.useOperator.ci:119: i16Cgt: bool(1)
test/lang.useOperator.ci:120: i16Cge: bool(1)
test/lang.useOperator.ci:122: u16A: uint16(96)
test/lang.useOperator.ci:123: u16B: uint16(42)
test/lang.useOperator.ci:124: u16Pls: uint16(42)
test/lang.useOperator.ci:125: u16Neg: uint16(65494)
test/lang.useOperator.ci:126: u16Cmt: uint16(65493)
test/lang.useOperator.ci:127: u16Add: uint16(138)
test/lang.useOperator.ci:128: u16Sub: uint16(54)
test/lang.useOperator.ci:129: u16Mul: uint16(4032)
test/lang.useOperator.ci:130: u16Div: uint16(2)
test/lang.useOperator.ci:131: u16Mod: uint16(12)
test/lang.useOperator.ci:132: u16And: uint16(32)
test/lang.useOperator.ci:133: u16Ior: uint16(106)
test/lang.useOperator.ci:134: u16Xor: uint16(74)
test/lang.useOperator.ci:135: u16Shl: uint16(384)
test/lang.useOperator.ci:136: u16Shr: uint16(24)
test/lang.useOperator.ci:137: u16Not: bool(0)
test/lang.useOperator.ci:138: u16Ceq: bool(0)
test/lang.useOperator.ci:139: u16Cne: bool(1)
test/lang.useOperator.ci:140: u16Clt: bool(0)
test/lang.useOperator.ci:141: u16Cle: bool(0)
test/lang.useOperator.ci:142: u16Cgt: bool(1)
test/lang.useOperator.ci:143: u16Cge: bool(1)
test/lang.useOperator.ci:145: i32A: int32(96)
test/lang.useOperator.ci:146: i32B: int32(42)
test/lang.useOperator.ci:147: i32Pls: int32(42)
test/lang.useOperator.ci:148: i32Neg: int32(-42)
test/lang.useOperator.ci:149: i32Cmt: int32(-43)
test/lang.useOperator.ci:150: i32Add: int32(138)
test/lang.useOperator.ci:151: i32Sub: int32(54)
test/lang.useOperator.ci:152: i32Mul: int32(4032)
test/lang.useOperator.ci:153: i32Div: int32(2)
test/lang.useOperator.ci:154: i32Mod: int32(12)
test/lang.useOperator.ci:155: i32And: int32(32)
test/lang.useOperator.ci:156: i32Ior: int32(106)
test/lang.useOperator.ci:157: i32Xor: int32(74)
test/lang.useOperator.ci:158: i32Shl: int32(384)
test/lang.useOperator.ci:159: i32Shr: int32(24)
test/lang.useOperator.ci:160: i32Not: bool(0)
test/lang.useOperator.ci:161: i32Ceq: bool(0)
test/lang.useOperator.ci:162: i32Cne: bool(1)
test/lang.useOperator.ci:163: i32Clt: bool(0)
test/lang.useOperator.ci:164: i32Cle: bool(0)
test/lang.useOperator.ci:165: i32Cgt: bool(1)
test/lang.useOperator.ci:166: i32Cge: bool(1)
test/lang.useOperator.ci:168: u32A: uint32(96)
test/lang.useOperator.ci:169: u32B: uint32(42)
test/lang.useOperator.ci:170: u32Pls: uint32(42)
test/lang.useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang.useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang.useOperator.ci:173: u32Add: uint32(138)
test/lang.useOperator.ci:174: u32Sub: uint32(54)
test/lang.useOperator.ci:175: u32Mul: uint32(4032)
test/lang.useOperator.ci:176: u32Div: uint32(2)
test/lang.useOperator.ci:177: u32Mod: uint32(12)
test/lang.useOperator.ci:178: u32And: uint32(32)
test/lang.useOperator.ci:179: u32Ior: uint32(106)
test/lang.useOperator.ci:180: u32Xor: uint32(74)
test/lang.useOperator.ci:181: u32Shl: uint32(384)
test/lang.useOperator.ci:182: u32Shr: uint32(24)
test/lang.useOperator.ci:183: u32Not: bool(0)
test/lang.useOperator.ci:184: u32Ceq: bool(0)
test/lang.useOperator.ci:185: u32Cne: bool(1)
test/lang.useOperator.ci:186: u32Clt: bool(0)
test/lang.useOperator.ci:187: u32Cle: bool(0)
test/lang.useOperator.ci:188: u32Cgt: bool(1)
test/lang.useOperator.ci:189: u32Cge: bool(1)
test/lang.useOperator.ci:191: i64A: int64(96)
test/lang.useOperator.ci:192: i64B: int64(42)
test/lang.useOperator.ci:193: i64Pls: int64(42)
test/lang.useOperator.ci:194: i64Neg: int64(-42)
test/lang.useOperator.ci:195: i64Cmt: int64(-43)
test/lang.useOperator.ci:196: i64Add: int64(138)
test/lang.useOperator.ci:197: i64Sub: int64(54)
test/lang.useOperator.ci:198: i64Mul: int64(4032)
test/lang.useOperator.ci:199: i64Div: int64(2)
test/lang.useOperator.ci:200: i64Mod: int64(12)
test/lang.useOperator.ci:201: i64And: int64(32)
test/lang.useOperator.ci:202: i64Ior: int64(106)
test/lang.useOperator.ci:203: i64Xor: int64(74)
test/lang.useOperator.ci:204: i64Shl: int64(384)
test/lang.useOperator.ci:205: i64Shr: int64(24)
test/lang.useOperator.ci:206: i64Not: bool(0)
test/lang.useOperator.ci:207: i64Ceq: bool(0)
test/lang.useOperator.ci:208: i64Cne: bool(1)
test/lang.useOperator.ci:209: i64Clt: bool(0)
test/lang.useOperator.ci:210: i64Cle: bool(0)
test/lang.useOperator.ci:211: i64Cgt: bool(1)
test/lang.useOperator.ci:212: i64Cge: bool(1)
test/lang.useOperator.ci:214: u64A: uint64(96)
test/lang.useOperator.ci:215: u64B: uint64(42)
test/lang.useOperator.ci:216: u64Pls: uint64(42)
test/lang.useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang.useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang.useOperator.ci:219: u64Add: uint64(138)
test/lang.useOperator.ci:220: u64Sub: uint64(54)
test/lang.useOperator.ci:221: u64Mul: uint64(4032)
test/lang.useOperator.ci:222: u64Div: uint64(2)
test/lang.useOperator.ci:223: u64Mod: uint64(12)
test/lang.useOperator.ci:224: u64And: uint64(32)
test/lang.useOperator.ci:225: u64Ior: uint64(106)
test/lang.useOperator.ci:226: u64Xor: uint64(74)
test/lang.useOperator.ci:227: u64Shl: uint64(384)
test/lang.useOperator.ci:228: u64Shr: uint64(24)
test/lang.useOperator.ci:229: u64Not: bool(0)
test/lang.useOperator.ci:230: u64Ceq: bool(0)
test/lang.useOperator.ci:231: u64Cne: bool(1)
test/lang.useOperator.ci:232: u64Clt: bool(0)
test/lang.useOperator.ci:233: u64Cle: bool(0)
test/lang.useOperator.ci:234: u64Cgt: bool(1)
test/lang.useOperator.ci:235: u64Cge: bool(1)
test/lang.useOperator.ci:237: f32A: float32(96.300003)
test/lang.useOperator.ci:238: f32B: float32(42.139999)
test/lang.useOperator.ci:239: f32Pls: float32(42.139999)
test/lang.useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang.useOperator.ci:242: f32Add: float32(138.440002)
test/lang.useOperator.ci:243: f32Sub: float32(54.160004)
test/lang.useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang.useOperator.ci:245: f32Div: float32(2.285240)
test/lang.useOperator.ci:246: f32Mod: float32(12.020004)
test/lang.useOperator.ci:252: f32Not: bool(0)
test/lang.useOperator.ci:253: f32Ceq: bool(0)
test/lang.useOperator.ci:254: f32Cne: bool(1)
test/lang.useOperator.ci:255: f32Clt: bool(0)
test/lang.useOperator.ci:256: f32Cle: bool(0)
test/lang.useOperator.ci:257: f32Cgt: bool(1)
test/lang.useOperator.ci:258: f32Cge: bool(1)
test/lang.useOperator.ci:260: f64A: float64(96.300000)
test/lang.useOperator.ci:261: f64B: float64(42.140000)
test/lang.useOperator.ci:262: f64Pls: float64(42.140000)
test/lang.useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang.useOperator.ci:265: f64Add: float64(138.440000)
test/lang.useOperator.ci:266: f64Sub: float64(54.160000)
test/lang.useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang.useOperator.ci:268: f64Div: float64(2.285240)
test/lang.useOperator.ci:269: f64Mod: float64(12.020000)
test/lang.useOperator.ci:275: f64Not: bool(0)
test/lang.useOperator.ci:276: f64Ceq: bool(0)
test/lang.useOperator.ci:277: f64Cne: bool(1)
test/lang.useOperator.ci:278: f64Clt: bool(0)
test/lang.useOperator.ci:279: f64Cle: bool(0)
test/lang.useOperator.ci:280: f64Cgt: bool(1)
test/lang.useOperator.ci:281: f64Cge: bool(1)
test/lang.useOperator.ci:283: ptrA: pointer(null)
test/lang.useOperator.ci:284: ptrB: pointer(<@1ff9e0>)
test/lang.useOperator.ci:299: ptrCeq: bool(0)
test/lang.useOperator.ci:300: ptrCne: bool(1)
test/lang.statementIf.ci:26: t: int32(0)
test/lang.statementFor.ci:12: forIdx: int32(2)

---------- Memory layout:
memory[all] @000000; size: 1572880(1.5 Mb)
memory[meta] @000000; size: 173408(169.3 Kb)
memory[code] @02a718; size: 7028(6.9 Kb)
memory[heap] @02c28c; size: 1391748(1.3 Mb)
memory[stack] @0fff50; size: 524224(511.9 Kb)

---------- Memory allocations:
memory[free] @02c2a0; size: 1391696(1.3 Mb)
