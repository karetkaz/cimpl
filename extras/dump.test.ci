typename: typename {
.kind: static const typename(ref)
.size: 136
.field size: int32 (size: 4 @24 -> const variable)
.field offset: int32 (size: 4 @32 -> const variable)
.field base: function (size: 0 @21928 -> static const inline)
.field file: function (size: 0 @22392 -> static const inline)
.field line: function (size: 0 @22856 -> static const inline)
.field name: function (size: 0 @23320 -> static const inline)
}
typename.size: int32 {
.kind: const variable
.size: 4
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.size: 4
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.size: 0
.owner: typename
.param .result: typename (size: 4 @0 -> inline)
.param type: typename (size: 4 @4 -> variable(ref))
.value: nfc(1)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.size: 0
.owner: typename
.param .result: .cstr (size: 4 @0 -> inline)
.param type: typename (size: 4 @4 -> variable(ref))
.value: nfc(2)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.size: 0
.owner: typename
.param .result: int32 (size: 4 @0 -> inline)
.param type: typename (size: 4 @4 -> variable(ref))
.value: nfc(3)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.size: 0
.owner: typename
.param .result: .cstr (size: 4 @0 -> inline)
.param type: typename (size: 4 @4 -> variable(ref))
.value: nfc(4)
}
void: typename {
.kind: static const typename(void)
.size: 0
}
bool: typename {
.kind: static const typename(bool)
.size: 1
.value: 0
}
char: typename {
.kind: static const typename(u32)
.size: 1
.value: 0
}
int8: typename {
.kind: static const typename(i32)
.size: 1
.value: 0
}
int16: typename {
.kind: static const typename(i32)
.size: 2
.value: 0
}
int32: typename {
.kind: static const typename(i32)
.size: 4
.value: 0
}
int64: typename {
.kind: static const typename(i64)
.size: 8
.value: 0
}
uint8: typename {
.kind: static const typename(u32)
.size: 1
.value: 0
}
uint16: typename {
.kind: static const typename(u32)
.size: 2
.value: 0
}
uint32: typename {
.kind: static const typename(u32)
.size: 4
.field zxt: function (size: 0 @32440 -> static const inline)
.field sxt: function (size: 0 @33176 -> static const inline)
.value: 0
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.size: 0
.owner: uint32
.param .result: int32 (size: 4 @0 -> inline)
.param value: int32 (size: 4 @4 -> variable(i32))
.param offs: int32 (size: 4 @8 -> variable(i32))
.param count: int32 (size: 4 @12 -> variable(i32))
.value: nfc(17)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.size: 0
.owner: uint32
.param .result: int32 (size: 4 @0 -> inline)
.param value: int32 (size: 4 @4 -> variable(i32))
.param offs: int32 (size: 4 @8 -> variable(i32))
.param count: int32 (size: 4 @12 -> variable(i32))
.value: nfc(18)
}
uint64: typename {
.kind: static const typename(u64)
.size: 8
.field zxt: function (size: 0 @33904 -> static const inline)
.field sxt: function (size: 0 @34632 -> static const inline)
.value: 0
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.size: 0
.owner: uint64
.param .result: int64 (size: 8 @8 -> inline)
.param value: int64 (size: 8 @8 -> variable(i64))
.param offs: int32 (size: 4 @12 -> variable(i32))
.param count: int32 (size: 4 @16 -> variable(i32))
.value: nfc(19)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.size: 0
.owner: uint64
.param .result: int64 (size: 8 @8 -> inline)
.param value: int64 (size: 8 @8 -> variable(i64))
.param offs: int32 (size: 4 @12 -> variable(i32))
.param count: int32 (size: 4 @16 -> variable(i32))
.value: nfc(20)
}
float32: typename {
.kind: static const typename(f32)
.size: 4
.field sin: function (size: 0 @35104 -> static const inline)
.field cos: function (size: 0 @35568 -> static const inline)
.field tan: function (size: 0 @36032 -> static const inline)
.field log: function (size: 0 @36496 -> static const inline)
.field exp: function (size: 0 @36960 -> static const inline)
.field pow: function (size: 0 @37568 -> static const inline)
.field sqrt: function (size: 0 @38032 -> static const inline)
.field atan2: function (size: 0 @38632 -> static const inline)
.value: 0
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(21)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(22)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(23)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(24)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(25)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.param y: float32 (size: 4 @8 -> variable(f32))
.value: nfc(26)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.value: nfc(27)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.size: 0
.owner: float32
.param .result: float32 (size: 4 @0 -> inline)
.param x: float32 (size: 4 @4 -> variable(f32))
.param y: float32 (size: 4 @8 -> variable(f32))
.value: nfc(28)
}
float64: typename {
.kind: static const typename(f64)
.size: 8
.field sin: function (size: 0 @39088 -> static const inline)
.field cos: function (size: 0 @39544 -> static const inline)
.field tan: function (size: 0 @40000 -> static const inline)
.field log: function (size: 0 @40456 -> static const inline)
.field exp: function (size: 0 @40912 -> static const inline)
.field pow: function (size: 0 @41504 -> static const inline)
.field sqrt: function (size: 0 @41960 -> static const inline)
.field atan2: function (size: 0 @42552 -> static const inline)
.value: 0
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(29)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(30)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(31)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(32)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(33)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.param y: float64 (size: 8 @16 -> variable(f64))
.value: nfc(34)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.value: nfc(35)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.size: 0
.owner: float64
.param .result: float64 (size: 8 @0 -> inline)
.param x: float64 (size: 8 @8 -> variable(f64))
.param y: float64 (size: 8 @16 -> variable(f64))
.value: nfc(36)
}
pointer: typename {
.kind: static const typename(ref)
.size: 4
.field alloc: function (size: 0 @27328 -> static const inline)
.field fill: function (size: 0 @28080 -> static const inline)
.field copy: function (size: 0 @28824 -> static const inline)
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.size: 0
.owner: pointer
.param .result: pointer (size: 4 @0 -> inline)
.param ptr: pointer (size: 4 @4 -> variable(ref))
.param size: int32 (size: 4 @8 -> variable(i32))
.value: nfc(7)
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.size: 0
.owner: pointer
.param .result: pointer (size: 4 @0 -> inline)
.param dst: pointer (size: 4 @4 -> variable(ref))
.param value: int32 (size: 4 @8 -> variable(i32))
.param size: int32 (size: 4 @12 -> variable(i32))
.value: nfc(8)
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.size: 0
.owner: pointer
.param .result: pointer (size: 4 @0 -> inline)
.param dst: pointer (size: 4 @4 -> variable(ref))
.param src: pointer (size: 4 @8 -> variable(ref))
.param size: int32 (size: 4 @12 -> variable(i32))
.value: nfc(9)
}
variant: typename {
.kind: static const typename(var)
.size: 8
}
function: typename {
.kind: static const typename(ref)
.size: 8
}
object: typename {
.kind: static const typename(ref)
.size: 4
}
null: pointer {
.kind: static const inline
.size: 0
.value: {pointer @0}
}
true: bool {
.kind: static const inline
.size: 0
.value: 1
}
false: bool {
.kind: static const inline
.size: 0
.value: 0
}
int: typename {
.kind: static const inline
.size: 0
.value: int32
}
byte: typename {
.kind: static const inline
.size: 0
.value: uint8
}
float: typename {
.kind: static const inline
.size: 0
.value: float32
}
double: typename {
.kind: static const inline
.size: 0
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.size: 4
}
emit: function {
.kind: static const typename(void)
.size: 0
.field nop: void (size: 0 @0 -> static const inline)
.field not: bool (size: 0 @0 -> static const inline)
.field set: void (size: 0 @0 -> static const inline)
.field join: void (size: 0 @0 -> static const inline)
.field ret: void (size: 0 @0 -> static const inline)
.field call: void (size: 0 @0 -> static const inline)
.field p4x: typename (size: 16 @4776 -> static const typename(val))
.field dup: void (size: 0 @4920 -> static const typename(void))
.field load: void (size: 0 @5496 -> static const typename(void))
.field store: void (size: 0 @6792 -> static const typename(void))
.field cmt: void (size: 0 @7616 -> static const typename(void))
.field and: void (size: 0 @8048 -> static const typename(void))
.field or: void (size: 0 @8464 -> static const typename(void))
.field xor: void (size: 0 @8880 -> static const typename(void))
.field shl: void (size: 0 @9296 -> static const typename(void))
.field shr: void (size: 0 @9712 -> static const typename(void))
.field neg: void (size: 0 @10400 -> static const typename(void))
.field add: void (size: 0 @11392 -> static const typename(void))
.field sub: void (size: 0 @12352 -> static const typename(void))
.field mul: void (size: 0 @13312 -> static const typename(void))
.field div: void (size: 0 @14544 -> static const typename(void))
.field mod: void (size: 0 @15776 -> static const typename(void))
.field ceq: void (size: 0 @16736 -> static const typename(void))
.field clt: void (size: 0 @17696 -> static const typename(void))
.field cgt: void (size: 0 @18656 -> static const typename(void))
.field min: void (size: 0 @19616 -> static const typename(void))
.field max: void (size: 0 @20032 -> static const typename(void))
}
emit.nop: void {
.kind: static const inline
.size: 0
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.size: 0
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.size: 0
.owner: emit
.value: set.x1 sp(1)
}
emit.join: void {
.kind: static const inline
.size: 0
.owner: emit
.value: sync 1
}
emit.ret: void {
.kind: static const inline
.size: 0
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.size: 0
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.size: 16
.owner: emit
.field dp3: float32 (size: 0 @0 -> static const inline)
.field dp4: float32 (size: 0 @0 -> static const inline)
.field dph: float32 (size: 0 @0 -> static const inline)
}
emit.p4x.dp3: float32 {
.kind: static const inline
.size: 0
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32 {
.kind: static const inline
.size: 0
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32 {
.kind: static const inline
.size: 0
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field x1: int32 (size: 0 @0 -> static const inline)
.field x2: int64 (size: 0 @0 -> static const inline)
.field x4: emit.p4x (size: 0 @0 -> static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.size: 0
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.size: 0
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field z32: int32 (size: 0 @0 -> static const inline)
.field z64: int64 (size: 0 @0 -> static const inline)
.field z128: emit.p4x (size: 0 @0 -> static const inline)
.field i8: int32 (size: 0 @0 -> static const inline)
.field i16: int32 (size: 0 @0 -> static const inline)
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field i128: emit.p4x (size: 0 @0 -> static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.m8
}
emit.load.i16: int32 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.m16
}
emit.load.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.m32
}
emit.load.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.m64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.load
.value: load.m128
}
emit.store: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i8: void (size: 0 @0 -> static const inline)
.field i16: void (size: 0 @0 -> static const inline)
.field i32: void (size: 0 @0 -> static const inline)
.field i64: void (size: 0 @0 -> static const inline)
.field i128: void (size: 0 @0 -> static const inline)
}
emit.store.i8: void {
.kind: static const inline
.size: 0
.owner: emit.store
.value: store.m8
}
emit.store.i16: void {
.kind: static const inline
.size: 0
.owner: emit.store
.value: store.m16
}
emit.store.i32: void {
.kind: static const inline
.size: 0
.owner: emit.store
.value: store.m32
}
emit.store.i64: void {
.kind: static const inline
.size: 0
.owner: emit.store
.value: store.m64
}
emit.store.i128: void {
.kind: static const inline
.size: 0
.owner: emit.store
.value: store.m128
}
emit.cmt: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.cmt
.value: cmt.b64
}
emit.and: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.and
.value: and.b64
}
emit.or: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.or
.value: or.b64
}
emit.xor: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.xor
.value: xor.b64
}
emit.shl: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.shl
.value: shl.b64
}
emit.shr: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint64 (size: 0 @0 -> static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.size: 0
.owner: emit.shr
.value: shr.b64
}
emit.neg: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.neg
.value: neg.v2d
}
emit.add: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.add.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.add
.value: add.v2d
}
emit.sub: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.sub.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.sub
.value: sub.v2d
}
emit.mul: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.mul.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.mul
.value: mul.v2d
}
emit.div: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.div.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.div
.value: div.v2d
}
emit.mod: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: int32 (size: 0 @0 -> static const inline)
.field i64: int64 (size: 0 @0 -> static const inline)
.field u32: uint32 (size: 0 @0 -> static const inline)
.field u64: uint32 (size: 0 @0 -> static const inline)
.field f32: float32 (size: 0 @0 -> static const inline)
.field f64: float64 (size: 0 @0 -> static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.size: 0
.owner: emit.mod
.value: mod.f64
}
emit.ceq: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
.field p4f: bool (size: 0 @0 -> static const inline)
.field p2d: bool (size: 0 @0 -> static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.size: 0
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field u32: bool (size: 0 @0 -> static const inline)
.field u64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.size: 0
.owner: emit.clt
.value: clt.f64
}
emit.cgt: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field i32: bool (size: 0 @0 -> static const inline)
.field i64: bool (size: 0 @0 -> static const inline)
.field u32: bool (size: 0 @0 -> static const inline)
.field u64: bool (size: 0 @0 -> static const inline)
.field f32: bool (size: 0 @0 -> static const inline)
.field f64: bool (size: 0 @0 -> static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.size: 0
.owner: emit.cgt
.value: cgt.f64
}
emit.min: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.min
.value: min.v2d
}
emit.max: void {
.kind: static const typename(void)
.size: 0
.owner: emit
.field p4f: emit.p4x (size: 0 @0 -> static const inline)
.field p2d: emit.p4x (size: 0 @0 -> static const inline)
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.size: 0
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.size: 0
.param .result: void (size: 0 @0 -> inline)
.value: nfc(0)
}
CLOCKS_PER_SEC: int32 {
.kind: i32
.size: 0
.value: 1000000
}
RAND_MAX: int32 {
.kind: i32
.size: 0
.value: 2147483647
}
raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void: function {
.kind: static const inline
.size: 0
.field abort: int32 (size: 0 @0 -> static i32)
.field error: int32 (size: 0 @0 -> static i32)
.field warn: int32 (size: 0 @0 -> static i32)
.field info: int32 (size: 0 @0 -> static i32)
.field debug: int32 (size: 0 @0 -> static i32)
.field verbose: int32 (size: 0 @0 -> static i32)
.field noTrace: int32 (size: 0 @0 -> static i32)
.field defTrace: int32 (size: 0 @0 -> static i32)
.param .result: void (size: 0 @0 -> inline)
.param level: int32 (size: 4 @4 -> variable(i32))
.param message: char[*] (size: 4 @8 -> variable(ref))
.param inspect: variant (size: 8 @16 -> variable(var))
.param maxTrace: int32 (size: 4 @20 -> variable(i32))
.value: nfc(5)
}
raise.abort: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: -1
}
raise.error: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 0
}
raise.warn: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 1
}
raise.info: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 2
}
raise.debug: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 3
}
raise.verbose: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 4
}
raise.noTrace: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 0
}
raise.defTrace: int32 {
.kind: static i32
.size: 0
.owner: raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.size: 0
.param .result: int32 (size: 4 @4 -> inline)
.param args: pointer (size: 4 @4 -> variable(ref))
.param action: function (size: 4 @8 -> variable(ref))
.value: nfc(6)
}
System: void {
.kind: static const typename(void)
.size: 0
.field exit: function (size: 0 @29440 -> static const inline)
.field srand: function (size: 0 @29912 -> static const inline)
.field rand: function (size: 0 @30240 -> static const inline)
.field time: function (size: 0 @30568 -> static const inline)
.field clock: function (size: 0 @30896 -> static const inline)
.field millis: function (size: 0 @31224 -> static const inline)
.field sleep: function (size: 0 @31688 -> static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: void (size: 0 @0 -> inline)
.param code: int32 (size: 4 @4 -> variable(i32))
.value: nfc(10)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: void (size: 0 @0 -> inline)
.param seed: int32 (size: 4 @4 -> variable(i32))
.value: nfc(11)
}
System.rand(): int32: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: int32 (size: 4 @4 -> inline)
.value: nfc(12)
}
System.time(): int32: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: int32 (size: 4 @4 -> inline)
.value: nfc(13)
}
System.clock(): int32: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: int32 (size: 4 @4 -> inline)
.value: nfc(14)
}
System.millis(): int64: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: int64 (size: 8 @8 -> inline)
.value: nfc(15)
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.size: 0
.owner: System
.param .result: void (size: 0 @0 -> inline)
.param millis: int64 (size: 8 @8 -> variable(i64))
.value: nfc(16)
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.param inspect: variant (size: 8 @12 -> var)
.value: raise(raise.verbose, message, inspect, raise.defTrace)
}
trace(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.value: raise(raise.verbose, message, null, raise.defTrace)
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @0 -> ref)
.param inspect: variant (size: 8 @0 -> var)
.value: raise(raise.debug, message, inspect, raise.noTrace)
}
debug(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @0 -> ref)
.value: raise(raise.debug, message, null, raise.noTrace)
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.param inspect: variant (size: 8 @12 -> var)
.value: raise(raise.info, message, inspect, raise.noTrace)
}
info(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.value: raise(raise.info, message, null, raise.noTrace)
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.param inspect: variant (size: 8 @12 -> var)
.value: raise(raise.warn, message, inspect, raise.noTrace)
}
warn(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.value: raise(raise.warn, message, null, raise.noTrace)
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.param inspect: variant (size: 8 @12 -> var)
.value: raise(raise.error, message, inspect, raise.defTrace)
}
error(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.value: raise(raise.error, message, null, raise.defTrace)
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @4 -> ref)
.param inspect: variant (size: 8 @12 -> var)
.value: raise(raise.abort, message, inspect, raise.defTrace)
}
abort(message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param message: char[*] (size: 4 @0 -> ref)
.value: raise(raise.abort, message, null, raise.defTrace)
}
abort(): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.value: raise(raise.abort, "execution aborted!", null, raise.defTrace)
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param condition: bool (size: 4 @4 -> bool)
.param message: char[*] (size: 4 @8 -> ref)
.param inspect: variant (size: 8 @16 -> var)
.value: void(condition ? void(0) : abort(message, inspect))
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param condition: bool (size: 4 @0 -> bool)
.param message: char[*] (size: 4 @0 -> ref)
.value: void(condition ? void(0) : abort(message))
}
assert(condition: bool): void: function {
.kind: inline
.size: 0
.param .result: void (size: 0 @0 -> void)
.param condition: bool (size: 4 @0 -> bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
}
integer: typename {
.kind: inline
.size: 0
.value: int64
}
t: int32 {
.kind: variable(i32)
.size: 4
.value: 0
}
forIdx: int32 {
.kind: variable(i32)
.size: 4
}
rgbF32: typename {
.kind: static const typename(val)
.size: 16
.field r: float32 (size: 4 @0 -> variable(f32))
.field g: float32 (size: 4 @4 -> variable(f32))
.field b: float32 (size: 4 @8 -> variable(f32))
}
rgbF32.r: float32 {
.kind: variable(f32)
.size: 4
.owner: rgbF32
}
rgbF32.g: float32 {
.kind: variable(f32)
.size: 4
.owner: rgbF32
}
rgbF32.b: float32 {
.kind: variable(f32)
.size: 4
.owner: rgbF32
}
rgbU8: typename {
.kind: static const typename(val)
.size: 3
.field b: uint8 (size: 1 @0 -> variable(u32))
.field g: uint8 (size: 1 @1 -> variable(u32))
.field r: uint8 (size: 1 @2 -> variable(u32))
}
rgbU8.b: uint8 {
.kind: variable(u32)
.size: 1
.owner: rgbU8
}
rgbU8.g: uint8 {
.kind: variable(u32)
.size: 1
.owner: rgbU8
}
rgbU8.r: uint8 {
.kind: variable(u32)
.size: 1
.owner: rgbU8
}
color: typename {
.kind: static const typename(val)
.size: 4
.field col: uint32 (size: 4 @0 -> variable(u32))
.field rgb: rgbU8 (size: 3 @0 -> variable(val))
}
color.col: uint32 {
.kind: variable(u32)
.size: 4
.owner: color
}
color.rgb: rgbU8 {
.kind: variable(val)
.size: 3
.owner: color
}
Color: object {
.kind: static const typename(ref)
.size: 20
.field value: rgbF32 (size: 16 @4 -> variable(val))
}
Color.value: rgbF32 {
.kind: variable(val)
.size: 16
.owner: Color
}
record_pack0: typename {
.kind: static const typename(val)
.size: 8
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @0 -> variable(u64))
.field _1: uint8 (size: 1 @0 -> variable(u32))
.field b: uint32 (size: 4 @0 -> variable(u32))
.field _2: uint8 (size: 1 @0 -> variable(u32))
.field c: uint16 (size: 2 @0 -> variable(u32))
}
record_pack0._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack0
}
record_pack0.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_pack0
}
record_pack0._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack0
}
record_pack0.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_pack0
}
record_pack0._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack0
}
record_pack0.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_pack0
}
record_pack1: typename {
.kind: static const typename(val)
.size: 17
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @1 -> variable(u64))
.field _1: uint8 (size: 1 @9 -> variable(u32))
.field b: uint32 (size: 4 @10 -> variable(u32))
.field _2: uint8 (size: 1 @14 -> variable(u32))
.field c: uint16 (size: 2 @15 -> variable(u32))
}
record_pack1._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack1
}
record_pack1.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_pack1
}
record_pack1._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack1
}
record_pack1.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_pack1
}
record_pack1._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack1
}
record_pack1.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_pack1
}
record_pack2: typename {
.kind: static const typename(val)
.size: 20
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @2 -> variable(u64))
.field _1: uint8 (size: 1 @10 -> variable(u32))
.field b: uint32 (size: 4 @12 -> variable(u32))
.field _2: uint8 (size: 1 @16 -> variable(u32))
.field c: uint16 (size: 2 @18 -> variable(u32))
}
record_pack2._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack2
}
record_pack2.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_pack2
}
record_pack2._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack2
}
record_pack2.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_pack2
}
record_pack2._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack2
}
record_pack2.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_pack2
}
record_pack4: typename {
.kind: static const typename(val)
.size: 24
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @4 -> variable(u64))
.field _1: uint8 (size: 1 @12 -> variable(u32))
.field b: uint32 (size: 4 @16 -> variable(u32))
.field _2: uint8 (size: 1 @20 -> variable(u32))
.field c: uint16 (size: 2 @22 -> variable(u32))
}
record_pack4._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack4
}
record_pack4.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_pack4
}
record_pack4._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack4
}
record_pack4.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_pack4
}
record_pack4._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack4
}
record_pack4.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_pack4
}
record_pack8: typename {
.kind: static const typename(val)
.size: 32
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @8 -> variable(u64))
.field _1: uint8 (size: 1 @16 -> variable(u32))
.field b: uint32 (size: 4 @20 -> variable(u32))
.field _2: uint8 (size: 1 @24 -> variable(u32))
.field c: uint16 (size: 2 @26 -> variable(u32))
}
record_pack8._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack8
}
record_pack8.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_pack8
}
record_pack8._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack8
}
record_pack8.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_pack8
}
record_pack8._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_pack8
}
record_pack8.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_pack8
}
record_packDef: typename {
.kind: static const typename(val)
.size: 32
.field _0: uint8 (size: 1 @0 -> variable(u32))
.field a: uint64 (size: 8 @8 -> variable(u64))
.field _1: uint8 (size: 1 @16 -> variable(u32))
.field b: uint32 (size: 4 @20 -> variable(u32))
.field _2: uint8 (size: 1 @24 -> variable(u32))
.field c: uint16 (size: 2 @26 -> variable(u32))
}
record_packDef._0: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_packDef
}
record_packDef.a: uint64 {
.kind: variable(u64)
.size: 8
.owner: record_packDef
}
record_packDef._1: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_packDef
}
record_packDef.b: uint32 {
.kind: variable(u32)
.size: 4
.owner: record_packDef
}
record_packDef._2: uint8 {
.kind: variable(u32)
.size: 1
.owner: record_packDef
}
record_packDef.c: uint16 {
.kind: variable(u32)
.size: 2
.owner: record_packDef
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: 0
}
last(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: (b)
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: a + b
}
any(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @4 -> variable(i32))
.param b: int32 (size: 4 @4 -> i32)
.value: (a) ? a : b
}
min(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @4 -> variable(i32))
.param b: int32 (size: 4 @8 -> variable(i32))
.value: a < b ? a : b
}
sum(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @4 -> i32)
.param b: int32 (size: 4 @8 -> i32)
.param c: int32 (size: 4 @12 -> i32)
.value: sum(sum(a, b), c)
}
any(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.param c: int32 (size: 4 @0 -> i32)
.value: any(any(a, b), c)
}
min(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.param c: int32 (size: 4 @0 -> i32)
.value: min(min(a, b), c)
}
ma: int32 {
.kind: variable(i32)
.size: 4
.value: 3
}
mb: int32 {
.kind: variable(i32)
.size: 4
.value: 6
}
mc: int32 {
.kind: variable(i32)
.size: 4
.value: 9
}
zeroVal: int32 {
.kind: variable(i32)
.size: 4
.value: zero(2, 3)
}
zeroVar: int32 {
.kind: variable(i32)
.size: 4
.value: zero(ma, mb)
}
zeroXpr: int32 {
.kind: variable(i32)
.size: 4
.value: zero(ma + mb, mb + mc)
}
lastVal: int32 {
.kind: variable(i32)
.size: 4
.value: last(2, 3)
}
lastVar: int32 {
.kind: variable(i32)
.size: 4
.value: last(ma, mb)
}
lastXpr: int32 {
.kind: variable(i32)
.size: 4
.value: last(ma + mb, mb + mc)
}
sum2Val: int32 {
.kind: variable(i32)
.size: 4
.value: sum(3, 12)
}
sum2Var: int32 {
.kind: variable(i32)
.size: 4
.value: sum(ma, mb)
}
sum2Xpr: int32 {
.kind: variable(i32)
.size: 4
.value: sum(ma + mb, mb + mc)
}
any2Val: int32 {
.kind: variable(i32)
.size: 4
.value: any(3, 12)
}
any2Var: int32 {
.kind: variable(i32)
.size: 4
.value: any(ma, mb)
}
any2Xpr: int32 {
.kind: variable(i32)
.size: 4
.value: any(ma + mb, mb + mc)
}
min2Val: int32 {
.kind: variable(i32)
.size: 4
.value: min(3, 12)
}
min2Var: int32 {
.kind: variable(i32)
.size: 4
.value: min(ma, mb)
}
min2Xpr: int32 {
.kind: variable(i32)
.size: 4
.value: min(ma + mb, mb + mc)
}
any3Val: int32 {
.kind: variable(i32)
.size: 4
.value: any(3, 2, 6)
}
any3Var: int32 {
.kind: variable(i32)
.size: 4
.value: any(ma, mb, mc)
}
any3Xpr: int32 {
.kind: variable(i32)
.size: 4
.value: any(ma + mb, mb + mc, mc + ma)
}
min3Val: int32 {
.kind: variable(i32)
.size: 4
.value: min(3, 2, 6)
}
min3Var: int32 {
.kind: variable(i32)
.size: 4
.value: min(ma, mb, mc)
}
min3Xpr: int32 {
.kind: variable(i32)
.size: 4
.value: min(ma + mb, mb + mc, mc + ma)
}
overload: typename {
.kind: inline
.size: 0
.value: 1
}
overload(): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.value: 2
}
overload(a: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.value: 3
}
overload(a: float32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: float32 (size: 4 @4 -> f32)
.value: 4
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param a: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: 5
}
overload1: float32 {
.kind: variable(f32)
.size: 4
.value: overload
}
overload2: float32 {
.kind: variable(f32)
.size: 4
.value: overload()
}
overload3: float32 {
.kind: variable(f32)
.size: 4
.value: overload(0)
}
overload4: float32 {
.kind: variable(f32)
.size: 4
.value: overload(0.000000)
}
overload5: float32 {
.kind: variable(f32)
.size: 4
.value: overload(0, 0)
}
emitldz32: int32 {
.kind: variable(i32)
.size: 4
.value: emit(load.z32)
}
emitldz64: int64 {
.kind: variable(i64)
.size: 8
.value: emit(load.z64)
}
emitA: int32 {
.kind: variable(i32)
.size: 4
.value: 42
}
emitB: int32 {
.kind: variable(i32)
.size: 4
.value: 96
}
emitAddI32: int32 {
.kind: variable(i32)
.size: 4
.value: emit(int32(emitA), int32(emitB), add.i32)
}
emitDivI32: int32 {
.kind: variable(i32)
.size: 4
.value: emit(int32(10), int32(5), div.i32)
}
emitNfcF32: float32 {
.kind: variable(f32)
.size: 4
.value: emit(float32(3.140000 / (2)), float32.sin)
}
sizeof(type: typename): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param type: typename (size: 4 @0 -> ref)
.value: type.size
}
sizeofVoid: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(void)
}
sizeofBool: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(bool)
}
sizeofChar: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(char)
}
sizeofInt8: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(int8)
}
sizeofInt16: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(int16)
}
sizeofInt32: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(int32)
}
sizeofInt64: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(int64)
}
sizeofUint8: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(uint8)
}
sizeofUint16: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(uint16)
}
sizeofUint32: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(uint32)
}
sizeofUint64: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(uint64)
}
sizeofFloat32: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(float32)
}
sizeofFloat64: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(float64)
}
sizeofPointer: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(pointer)
}
sizeofVariant: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(variant)
}
sizeofTypename: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(typename)
}
sizeofFunction: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(function)
}
sizeofObject: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(object)
}
RecordSizeof: object {
.kind: static const typename(ref)
.size: 12
.field x: int64 (size: 8 @4 -> variable(i64))
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.size: 8
.owner: RecordSizeof
.value: 0
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.size: 16
.field y: int32 (size: 4 @12 -> variable(i32))
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.size: 4
.owner: RecordSizeofExt
.value: 0
}
typeofRecord: typename {
.kind: variable(ref)
.size: 4
.value: RecordSizeofExt
}
nameOfRecord: char[*] {
.kind: variable(ref)
.size: 4
.value: typename.name(typeofRecord)
}
sizeOfRecord: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(typeofRecord)
}
fileOfRecord: char[*] {
.kind: variable(ref)
.size: 4
.value: typename.file(typeofRecord)
}
lineOfRecord: int32 {
.kind: variable(i32)
.size: 4
.value: typename.line(typeofRecord)
}
typeofBase: typename {
.kind: variable(ref)
.size: 4
.value: typename.base(typeofRecord)
}
nameOfBase: char[*] {
.kind: variable(ref)
.size: 4
.value: typename.name(typeofBase)
}
sizeOfBase: int32 {
.kind: variable(i32)
.size: 4
.value: sizeof(typeofBase)
}
fileOfBase: char[*] {
.kind: variable(ref)
.size: 4
.value: typename.file(typeofBase)
}
lineOfBase: int32 {
.kind: variable(i32)
.size: 4
.value: typename.line(typeofBase)
}
typeofBase1: typename {
.kind: variable(ref)
.size: 4
.value: typename.base(typeofBase)
}
sizeofBase1: int32 {
.kind: variable(i32)
.size: 4
.value: typeofBase1.size
}
typeofBase2: typename {
.kind: variable(ref)
.size: 4
.value: typename.base(typeofBase1)
}
sizeofBase2: int32 {
.kind: variable(i32)
.size: 4
.value: typeofBase2.size
}
empty(): void: function {
.kind: static const function
.size: 1
.param .result: void (size: 0 @0 -> variable(void))
.value: {
}
.instructions: [1 bytes @.023d40]
	03                         ret
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.size: 9
.param .result: int32 (size: 4 @4 -> variable(i32))
.param x: int32 (size: 4 @8 -> variable(i32))
.param y: int32 (size: 4 @12 -> variable(i32))
.value: {
	return .result := x + y;
}
.instructions: [9 bytes @.023d41]
	extras/Tests/lang.function.ci:7: (8 bytes): return .result := x + y;
	12 02                      dup.x1 sp(2)
	12 02                      dup.x1 sp(2)
	51                         add.i32
	15 04                      set.x1 sp(4)
	03                         ret
	03                         ret
}
funAddResult: int32 {
.kind: variable(i32)
.size: 4
.value: funAdd(2, 7)
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.size: 4
.param .result: int32 (size: 4 @4 -> variable(i32))
.param x: int32 (size: 4 @8 -> variable(i32))
.param y: int32 (size: 4 @12 -> variable(i32))
.value: funAdd
}
funAddRefResult: int32 {
.kind: variable(i32)
.size: 4
.value: funAddRef(2, 8)
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.size: 4
.param .result: int32 (size: 4 @4 -> variable(i32))
.param x: int32 (size: 4 @8 -> variable(i32))
.param y: int32 (size: 4 @12 -> variable(i32))
.value: funMul
}
funMulResult: int32 {
.kind: variable(i32)
.size: 4
.value: funMul(2, 6)
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.size: 4
.param .result: int32 (size: 4 @4 -> variable(i32))
.param x: int32 (size: 4 @8 -> variable(i32))
.param y: int32 (size: 4 @12 -> variable(i32))
.value: funMul
}
funMulRefResult: int32 {
.kind: variable(i32)
.size: 4
.value: funMulRef(2, 7)
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.size: 9
.param .result: int32 (size: 4 @4 -> variable(i32))
.param x: int32 (size: 4 @8 -> variable(i32))
.param y: int32 (size: 4 @12 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: [9 bytes @.023d4a]
	extras/Tests/lang.function.ci:33: (8 bytes): return .result := x * y;
	12 02                      dup.x1 sp(2)
	12 02                      dup.x1 sp(2)
	53                         mul.i32
	15 04                      set.x1 sp(4)
	03                         ret
	03                         ret
}
fib(n: uint32): uint32: function {
.kind: static const function
.size: 87
.param .result: uint32 (size: 4 @4 -> variable(u32))
.param n: uint32 (size: 4 @8 -> variable(u32))
.value: {
	if (n <= (1)) {
		if (n <= (0)) {
			return .result := (0);
		}
		return .result := (1);
	}
	return .result := fib(n - (1)) + fib(n - (2));
}
.instructions: [87 bytes @.023d53]
	extras/Tests/lang.function.ci:38: (40 bytes): if (n <= (1))
	12 01                      dup.x1 sp(1)
	1b 01 00 00 00             load.c32 1
	39                         cgt.u32
	05 20 00 00                jnz +32
	extras/Tests/lang.function.ci:39: (20 bytes): if (n <= (0))
	12 01                      dup.x1 sp(1)
	1b 00 00 00 00             load.c32 0
	39                         cgt.u32
	05 0c 00 00                jnz +12
	extras/Tests/lang.function.ci:40: (8 bytes): return .result := (0);
	1b 00 00 00 00             load.c32 0
	15 03                      set.x1 sp(3)
	03                         ret
	extras/Tests/lang.function.ci:42: (8 bytes): return .result := (1);
	1b 01 00 00 00             load.c32 1
	15 03                      set.x1 sp(3)
	03                         ret
	extras/Tests/lang.function.ci:44: (46 bytes): return .result := fib(n - (1)) + fib(n - (2));
	1b 00 00 00 00             load.c32 0
	12 02                      dup.x1 sp(2)
	0b ff ff ff                inc.i32(-1)
	1f 53 3d 02 00             load.ref .023d53 ;fib(n: uint32): uint32
	02                         call
	10 fc ff ff                inc.sp(-4)
	1b 00 00 00 00             load.c32 0
	12 03                      dup.x1 sp(3)
	0b fe ff ff                inc.i32(-2)
	1f 53 3d 02 00             load.ref .023d53 ;fib(n: uint32): uint32
	02                         call
	10 fc ff ff                inc.sp(-4)
	51                         add.i32
	15 03                      set.x1 sp(3)
	03                         ret
	// FIXME: do not generate multiple ret instructions if not needed
	03                         ret
}
fibonacci_13: uint32 {
.kind: variable(u32)
.size: 4
.value: fib(13)
}
a: typename {
.kind: inline
.size: 0
.value: 96.300000
}
b: typename {
.kind: inline
.size: 0
.value: 42.140000
}
shift: int32 {
.kind: variable(i32)
.size: 4
.value: 2
}
boolA: bool {
.kind: variable(bool)
.size: 1
.value: true
}
boolB: bool {
.kind: variable(bool)
.size: 1
.value: !false
}
boolAnd: bool {
.kind: variable(bool)
.size: 1
.value: boolA & boolB
}
boolIor: bool {
.kind: variable(bool)
.size: 1
.value: boolA | boolB
}
boolXor: bool {
.kind: variable(bool)
.size: 1
.value: boolA ^ boolB
}
boolNot: bool {
.kind: variable(bool)
.size: 1
.value: !boolB
}
boolCeq: bool {
.kind: variable(bool)
.size: 1
.value: boolA == boolB
}
boolCne: bool {
.kind: variable(bool)
.size: 1
.value: boolA != boolB
}
boolClt: bool {
.kind: variable(bool)
.size: 1
.value: boolA < boolB
}
boolCle: bool {
.kind: variable(bool)
.size: 1
.value: boolA <= boolB
}
boolCgt: bool {
.kind: variable(bool)
.size: 1
.value: boolA > boolB
}
boolCge: bool {
.kind: variable(bool)
.size: 1
.value: boolA >= boolB
}
chrA: char {
.kind: variable(u32)
.size: 1
.value: 'a'
}
chrB: char {
.kind: variable(u32)
.size: 1
.value: 'b'
}
chrPls: char {
.kind: variable(u32)
.size: 1
.value: +chrB
}
chrNeg: char {
.kind: variable(u32)
.size: 1
.value: -chrB
}
chrCmt: char {
.kind: variable(u32)
.size: 1
.value: ~chrB
}
chrAdd: char {
.kind: variable(u32)
.size: 1
.value: chrA + chrB
}
chrSub: char {
.kind: variable(u32)
.size: 1
.value: chrA - chrB
}
chrMul: char {
.kind: variable(u32)
.size: 1
.value: chrA * chrB
}
chrDiv: char {
.kind: variable(u32)
.size: 1
.value: chrA / chrB
}
chrMod: char {
.kind: variable(u32)
.size: 1
.value: chrA % chrB
}
chrAnd: char {
.kind: variable(u32)
.size: 1
.value: chrA & chrB
}
chrIor: char {
.kind: variable(u32)
.size: 1
.value: chrA | chrB
}
chrXor: char {
.kind: variable(u32)
.size: 1
.value: chrA ^ chrB
}
chrShl: char {
.kind: variable(u32)
.size: 1
.value: (chrA) << shift
}
chrShr: char {
.kind: variable(u32)
.size: 1
.value: (chrA) >> shift
}
chrNot: bool {
.kind: variable(bool)
.size: 1
.value: !(chrB)
}
chrCeq: bool {
.kind: variable(bool)
.size: 1
.value: chrA == chrB
}
chrCne: bool {
.kind: variable(bool)
.size: 1
.value: chrA != chrB
}
chrClt: bool {
.kind: variable(bool)
.size: 1
.value: chrA < chrB
}
chrCle: bool {
.kind: variable(bool)
.size: 1
.value: chrA <= chrB
}
chrCgt: bool {
.kind: variable(bool)
.size: 1
.value: chrA > chrB
}
chrCge: bool {
.kind: variable(bool)
.size: 1
.value: chrA >= chrB
}
i8A: int8 {
.kind: variable(i32)
.size: 1
.value: a
}
i8B: int8 {
.kind: variable(i32)
.size: 1
.value: b
}
i8Pls: int8 {
.kind: variable(i32)
.size: 1
.value: +i8B
}
i8Neg: int8 {
.kind: variable(i32)
.size: 1
.value: -i8B
}
i8Cmt: int8 {
.kind: variable(i32)
.size: 1
.value: ~i8B
}
i8Add: int8 {
.kind: variable(i32)
.size: 1
.value: i8A + i8B
}
i8Sub: int8 {
.kind: variable(i32)
.size: 1
.value: i8A - i8B
}
i8Mul: int8 {
.kind: variable(i32)
.size: 1
.value: i8A * i8B
}
i8Div: int8 {
.kind: variable(i32)
.size: 1
.value: i8A / i8B
}
i8Mod: int8 {
.kind: variable(i32)
.size: 1
.value: i8A % i8B
}
i8And: int8 {
.kind: variable(i32)
.size: 1
.value: i8A & i8B
}
i8Ior: int8 {
.kind: variable(i32)
.size: 1
.value: i8A | i8B
}
i8Xor: int8 {
.kind: variable(i32)
.size: 1
.value: i8A ^ i8B
}
i8Shl: int8 {
.kind: variable(i32)
.size: 1
.value: (i8A) << shift
}
i8Shr: int8 {
.kind: variable(i32)
.size: 1
.value: (i8A) >> shift
}
i8Not: bool {
.kind: variable(bool)
.size: 1
.value: !(i8B)
}
i8Ceq: bool {
.kind: variable(bool)
.size: 1
.value: i8A == i8B
}
i8Cne: bool {
.kind: variable(bool)
.size: 1
.value: i8A != i8B
}
i8Clt: bool {
.kind: variable(bool)
.size: 1
.value: i8A < i8B
}
i8Cle: bool {
.kind: variable(bool)
.size: 1
.value: i8A <= i8B
}
i8Cgt: bool {
.kind: variable(bool)
.size: 1
.value: i8A > i8B
}
i8Cge: bool {
.kind: variable(bool)
.size: 1
.value: i8A >= i8B
}
u8A: uint8 {
.kind: variable(u32)
.size: 1
.value: a
}
u8B: uint8 {
.kind: variable(u32)
.size: 1
.value: b
}
u8Pls: uint8 {
.kind: variable(u32)
.size: 1
.value: +u8B
}
u8Neg: uint8 {
.kind: variable(u32)
.size: 1
.value: -u8B
}
u8Cmt: uint8 {
.kind: variable(u32)
.size: 1
.value: ~u8B
}
u8Add: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A + u8B
}
u8Sub: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A - u8B
}
u8Mul: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A * u8B
}
u8Div: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A / u8B
}
u8Mod: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A % u8B
}
u8And: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A & u8B
}
u8Ior: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A | u8B
}
u8Xor: uint8 {
.kind: variable(u32)
.size: 1
.value: u8A ^ u8B
}
u8Shl: uint8 {
.kind: variable(u32)
.size: 1
.value: (u8A) << shift
}
u8Shr: uint8 {
.kind: variable(u32)
.size: 1
.value: (u8A) >> shift
}
u8Not: bool {
.kind: variable(bool)
.size: 1
.value: !(u8B)
}
u8Ceq: bool {
.kind: variable(bool)
.size: 1
.value: u8A == u8B
}
u8Cne: bool {
.kind: variable(bool)
.size: 1
.value: u8A != u8B
}
u8Clt: bool {
.kind: variable(bool)
.size: 1
.value: u8A < u8B
}
u8Cle: bool {
.kind: variable(bool)
.size: 1
.value: u8A <= u8B
}
u8Cgt: bool {
.kind: variable(bool)
.size: 1
.value: u8A > u8B
}
u8Cge: bool {
.kind: variable(bool)
.size: 1
.value: u8A >= u8B
}
i16A: int16 {
.kind: variable(i32)
.size: 2
.value: a
}
i16B: int16 {
.kind: variable(i32)
.size: 2
.value: b
}
i16Pls: int16 {
.kind: variable(i32)
.size: 2
.value: +i16B
}
i16Neg: int16 {
.kind: variable(i32)
.size: 2
.value: -i16B
}
i16Cmt: int16 {
.kind: variable(i32)
.size: 2
.value: ~i16B
}
i16Add: int16 {
.kind: variable(i32)
.size: 2
.value: i16A + i16B
}
i16Sub: int16 {
.kind: variable(i32)
.size: 2
.value: i16A - i16B
}
i16Mul: int16 {
.kind: variable(i32)
.size: 2
.value: i16A * i16B
}
i16Div: int16 {
.kind: variable(i32)
.size: 2
.value: i16A / i16B
}
i16Mod: int16 {
.kind: variable(i32)
.size: 2
.value: i16A % i16B
}
i16And: int16 {
.kind: variable(i32)
.size: 2
.value: i16A & i16B
}
i16Ior: int16 {
.kind: variable(i32)
.size: 2
.value: i16A | i16B
}
i16Xor: int16 {
.kind: variable(i32)
.size: 2
.value: i16A ^ i16B
}
i16Shl: int16 {
.kind: variable(i32)
.size: 2
.value: (i16A) << shift
}
i16Shr: int16 {
.kind: variable(i32)
.size: 2
.value: (i16A) >> shift
}
i16Not: bool {
.kind: variable(bool)
.size: 1
.value: !(i16B)
}
i16Ceq: bool {
.kind: variable(bool)
.size: 1
.value: i16A == i16B
}
i16Cne: bool {
.kind: variable(bool)
.size: 1
.value: i16A != i16B
}
i16Clt: bool {
.kind: variable(bool)
.size: 1
.value: i16A < i16B
}
i16Cle: bool {
.kind: variable(bool)
.size: 1
.value: i16A <= i16B
}
i16Cgt: bool {
.kind: variable(bool)
.size: 1
.value: i16A > i16B
}
i16Cge: bool {
.kind: variable(bool)
.size: 1
.value: i16A >= i16B
}
u16A: uint16 {
.kind: variable(u32)
.size: 2
.value: a
}
u16B: uint16 {
.kind: variable(u32)
.size: 2
.value: b
}
u16Pls: uint16 {
.kind: variable(u32)
.size: 2
.value: +u16B
}
u16Neg: uint16 {
.kind: variable(u32)
.size: 2
.value: -u16B
}
u16Cmt: uint16 {
.kind: variable(u32)
.size: 2
.value: ~u16B
}
u16Add: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A + u16B
}
u16Sub: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A - u16B
}
u16Mul: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A * u16B
}
u16Div: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A / u16B
}
u16Mod: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A % u16B
}
u16And: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A & u16B
}
u16Ior: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A | u16B
}
u16Xor: uint16 {
.kind: variable(u32)
.size: 2
.value: u16A ^ u16B
}
u16Shl: uint16 {
.kind: variable(u32)
.size: 2
.value: (u16A) << shift
}
u16Shr: uint16 {
.kind: variable(u32)
.size: 2
.value: (u16A) >> shift
}
u16Not: bool {
.kind: variable(bool)
.size: 1
.value: !(u16B)
}
u16Ceq: bool {
.kind: variable(bool)
.size: 1
.value: u16A == u16B
}
u16Cne: bool {
.kind: variable(bool)
.size: 1
.value: u16A != u16B
}
u16Clt: bool {
.kind: variable(bool)
.size: 1
.value: u16A < u16B
}
u16Cle: bool {
.kind: variable(bool)
.size: 1
.value: u16A <= u16B
}
u16Cgt: bool {
.kind: variable(bool)
.size: 1
.value: u16A > u16B
}
u16Cge: bool {
.kind: variable(bool)
.size: 1
.value: u16A >= u16B
}
i32A: int32 {
.kind: variable(i32)
.size: 4
.value: a
}
i32B: int32 {
.kind: variable(i32)
.size: 4
.value: b
}
i32Pls: int32 {
.kind: variable(i32)
.size: 4
.value: +i32B
}
i32Neg: int32 {
.kind: variable(i32)
.size: 4
.value: -i32B
}
i32Cmt: int32 {
.kind: variable(i32)
.size: 4
.value: ~i32B
}
i32Add: int32 {
.kind: variable(i32)
.size: 4
.value: i32A + i32B
}
i32Sub: int32 {
.kind: variable(i32)
.size: 4
.value: i32A - i32B
}
i32Mul: int32 {
.kind: variable(i32)
.size: 4
.value: i32A * i32B
}
i32Div: int32 {
.kind: variable(i32)
.size: 4
.value: i32A / i32B
}
i32Mod: int32 {
.kind: variable(i32)
.size: 4
.value: i32A % i32B
}
i32And: int32 {
.kind: variable(i32)
.size: 4
.value: i32A & i32B
}
i32Ior: int32 {
.kind: variable(i32)
.size: 4
.value: i32A | i32B
}
i32Xor: int32 {
.kind: variable(i32)
.size: 4
.value: i32A ^ i32B
}
i32Shl: int32 {
.kind: variable(i32)
.size: 4
.value: i32A << shift
}
i32Shr: int32 {
.kind: variable(i32)
.size: 4
.value: i32A >> shift
}
i32Not: bool {
.kind: variable(bool)
.size: 1
.value: !(i32B)
}
i32Ceq: bool {
.kind: variable(bool)
.size: 1
.value: i32A == i32B
}
i32Cne: bool {
.kind: variable(bool)
.size: 1
.value: i32A != i32B
}
i32Clt: bool {
.kind: variable(bool)
.size: 1
.value: i32A < i32B
}
i32Cle: bool {
.kind: variable(bool)
.size: 1
.value: i32A <= i32B
}
i32Cgt: bool {
.kind: variable(bool)
.size: 1
.value: i32A > i32B
}
i32Cge: bool {
.kind: variable(bool)
.size: 1
.value: i32A >= i32B
}
u32A: uint32 {
.kind: variable(u32)
.size: 4
.value: a
}
u32B: uint32 {
.kind: variable(u32)
.size: 4
.value: b
}
u32Pls: uint32 {
.kind: variable(u32)
.size: 4
.value: +u32B
}
u32Neg: uint32 {
.kind: variable(u32)
.size: 4
.value: -u32B
}
u32Cmt: uint32 {
.kind: variable(u32)
.size: 4
.value: ~u32B
}
u32Add: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A + u32B
}
u32Sub: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A - u32B
}
u32Mul: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A * u32B
}
u32Div: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A / u32B
}
u32Mod: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A % u32B
}
u32And: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A & u32B
}
u32Ior: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A | u32B
}
u32Xor: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A ^ u32B
}
u32Shl: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A << shift
}
u32Shr: uint32 {
.kind: variable(u32)
.size: 4
.value: u32A >> shift
}
u32Not: bool {
.kind: variable(bool)
.size: 1
.value: !(u32B)
}
u32Ceq: bool {
.kind: variable(bool)
.size: 1
.value: u32A == u32B
}
u32Cne: bool {
.kind: variable(bool)
.size: 1
.value: u32A != u32B
}
u32Clt: bool {
.kind: variable(bool)
.size: 1
.value: u32A < u32B
}
u32Cle: bool {
.kind: variable(bool)
.size: 1
.value: u32A <= u32B
}
u32Cgt: bool {
.kind: variable(bool)
.size: 1
.value: u32A > u32B
}
u32Cge: bool {
.kind: variable(bool)
.size: 1
.value: u32A >= u32B
}
i64A: int64 {
.kind: variable(i64)
.size: 8
.value: a
}
i64B: int64 {
.kind: variable(i64)
.size: 8
.value: b
}
i64Pls: int64 {
.kind: variable(i64)
.size: 8
.value: +i64B
}
i64Neg: int64 {
.kind: variable(i64)
.size: 8
.value: -i64B
}
i64Cmt: int64 {
.kind: variable(i64)
.size: 8
.value: ~i64B
}
i64Add: int64 {
.kind: variable(i64)
.size: 8
.value: i64A + i64B
}
i64Sub: int64 {
.kind: variable(i64)
.size: 8
.value: i64A - i64B
}
i64Mul: int64 {
.kind: variable(i64)
.size: 8
.value: i64A * i64B
}
i64Div: int64 {
.kind: variable(i64)
.size: 8
.value: i64A / i64B
}
i64Mod: int64 {
.kind: variable(i64)
.size: 8
.value: i64A % i64B
}
i64And: int64 {
.kind: variable(i64)
.size: 8
.value: i64A & i64B
}
i64Ior: int64 {
.kind: variable(i64)
.size: 8
.value: i64A | i64B
}
i64Xor: int64 {
.kind: variable(i64)
.size: 8
.value: i64A ^ i64B
}
i64Shl: int64 {
.kind: variable(i64)
.size: 8
.value: i64A << shift
}
i64Shr: int64 {
.kind: variable(i64)
.size: 8
.value: i64A >> shift
}
i64Not: bool {
.kind: variable(bool)
.size: 1
.value: !(i64B)
}
i64Ceq: bool {
.kind: variable(bool)
.size: 1
.value: i64A == i64B
}
i64Cne: bool {
.kind: variable(bool)
.size: 1
.value: i64A != i64B
}
i64Clt: bool {
.kind: variable(bool)
.size: 1
.value: i64A < i64B
}
i64Cle: bool {
.kind: variable(bool)
.size: 1
.value: i64A <= i64B
}
i64Cgt: bool {
.kind: variable(bool)
.size: 1
.value: i64A > i64B
}
i64Cge: bool {
.kind: variable(bool)
.size: 1
.value: i64A >= i64B
}
u64A: uint64 {
.kind: variable(u64)
.size: 8
.value: a
}
u64B: uint64 {
.kind: variable(u64)
.size: 8
.value: b
}
u64Pls: uint64 {
.kind: variable(u64)
.size: 8
.value: +u64B
}
u64Neg: uint64 {
.kind: variable(u64)
.size: 8
.value: -u64B
}
u64Cmt: uint64 {
.kind: variable(u64)
.size: 8
.value: ~u64B
}
u64Add: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A + u64B
}
u64Sub: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A - u64B
}
u64Mul: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A * u64B
}
u64Div: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A / u64B
}
u64Mod: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A % u64B
}
u64And: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A & u64B
}
u64Ior: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A | u64B
}
u64Xor: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A ^ u64B
}
u64Shl: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A << shift
}
u64Shr: uint64 {
.kind: variable(u64)
.size: 8
.value: u64A >> shift
}
u64Not: bool {
.kind: variable(bool)
.size: 1
.value: !(u64B)
}
u64Ceq: bool {
.kind: variable(bool)
.size: 1
.value: u64A == u64B
}
u64Cne: bool {
.kind: variable(bool)
.size: 1
.value: u64A != u64B
}
u64Clt: bool {
.kind: variable(bool)
.size: 1
.value: u64A < u64B
}
u64Cle: bool {
.kind: variable(bool)
.size: 1
.value: u64A <= u64B
}
u64Cgt: bool {
.kind: variable(bool)
.size: 1
.value: u64A > u64B
}
u64Cge: bool {
.kind: variable(bool)
.size: 1
.value: u64A >= u64B
}
f32A: float32 {
.kind: variable(f32)
.size: 4
.value: a
}
f32B: float32 {
.kind: variable(f32)
.size: 4
.value: b
}
f32Pls: float32 {
.kind: variable(f32)
.size: 4
.value: +f32B
}
f32Neg: float32 {
.kind: variable(f32)
.size: 4
.value: -f32B
}
f32Add: float32 {
.kind: variable(f32)
.size: 4
.value: f32A + f32B
}
f32Sub: float32 {
.kind: variable(f32)
.size: 4
.value: f32A - f32B
}
f32Mul: float32 {
.kind: variable(f32)
.size: 4
.value: f32A * f32B
}
f32Div: float32 {
.kind: variable(f32)
.size: 4
.value: f32A / f32B
}
f32Mod: float32 {
.kind: variable(f32)
.size: 4
.value: f32A % f32B
}
f32Not: bool {
.kind: variable(bool)
.size: 1
.value: !(f32B)
}
f32Ceq: bool {
.kind: variable(bool)
.size: 1
.value: f32A == f32B
}
f32Cne: bool {
.kind: variable(bool)
.size: 1
.value: f32A != f32B
}
f32Clt: bool {
.kind: variable(bool)
.size: 1
.value: f32A < f32B
}
f32Cle: bool {
.kind: variable(bool)
.size: 1
.value: f32A <= f32B
}
f32Cgt: bool {
.kind: variable(bool)
.size: 1
.value: f32A > f32B
}
f32Cge: bool {
.kind: variable(bool)
.size: 1
.value: f32A >= f32B
}
f64A: float64 {
.kind: variable(f64)
.size: 8
.value: a
}
f64B: float64 {
.kind: variable(f64)
.size: 8
.value: b
}
f64Pls: float64 {
.kind: variable(f64)
.size: 8
.value: +f64B
}
f64Neg: float64 {
.kind: variable(f64)
.size: 8
.value: -f64B
}
f64Add: float64 {
.kind: variable(f64)
.size: 8
.value: f64A + f64B
}
f64Sub: float64 {
.kind: variable(f64)
.size: 8
.value: f64A - f64B
}
f64Mul: float64 {
.kind: variable(f64)
.size: 8
.value: f64A * f64B
}
f64Div: float64 {
.kind: variable(f64)
.size: 8
.value: f64A / f64B
}
f64Mod: float64 {
.kind: variable(f64)
.size: 8
.value: f64A % f64B
}
f64Not: bool {
.kind: variable(bool)
.size: 1
.value: !(f64B)
}
f64Ceq: bool {
.kind: variable(bool)
.size: 1
.value: f64A == f64B
}
f64Cne: bool {
.kind: variable(bool)
.size: 1
.value: f64A != f64B
}
f64Clt: bool {
.kind: variable(bool)
.size: 1
.value: f64A < f64B
}
f64Cle: bool {
.kind: variable(bool)
.size: 1
.value: f64A <= f64B
}
f64Cgt: bool {
.kind: variable(bool)
.size: 1
.value: f64A > f64B
}
f64Cge: bool {
.kind: variable(bool)
.size: 1
.value: f64A >= f64B
}
ptrA: pointer {
.kind: variable(ref)
.size: 4
.value: null
}
ptrB: pointer {
.kind: variable(ref)
.size: 4
.value: pointer(shift)
}
ptrCeq: bool {
.kind: variable(bool)
.size: 1
.value: ptrA == ptrB
}
ptrCne: bool {
.kind: variable(bool)
.size: 1
.value: ptrA != ptrB
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.size: 56
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.size: 8
}
arrPtrNoInit: int64[*] {
.kind: variable(ref)
.size: 4
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.size: 8
.value: null
}
arrPtrInitNull: int64[*] {
.kind: variable(ref)
.size: 4
.value: null
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.size: 8
.value: arrFixedNoInit
}
arrPtrInitFixed: int64[*] {
.kind: variable(ref)
.size: 4
.value: arrFixedNoInit
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.size: 8
.value: arrSliceInitFixed
}
arrPtrInitSlice: int64[*] {
.kind: variable(ref)
.size: 4
.value: arrSliceInitFixed
}
arrPtrInitPtr: int64[*] {
.kind: variable(ref)
.size: 4
.value: arrPtrInitFixed
}
arrSliceInitString: char[] {
.kind: variable(arr)
.size: 8
.value: "string"
}
arrPtrInitString: char[*] {
.kind: variable(ref)
.size: 4
.value: "string"
}
value: int64 {
.kind: static variable(i64)
.size: 8
.value: 42
}
valueRef: int64 {
.kind: variable(ref)
.size: 4
.value: value
}
valuePtr: pointer {
.kind: variable(ref)
.size: 4
.value: value
}
valueVar: variant {
.kind: variable(var)
.size: 8
.value: value
}
fromRef: int64 {
.kind: variable(i64)
.size: 8
.value: valueRef
}
fromPtr: int64 {
.kind: variable(ref)
.size: 4
.value: valuePtr
}
fromVar: int64 {
.kind: variable(ref)
.size: 4
.value: valueVar
}
nullRef: int64 {
.kind: variable(ref)
.size: 4
.value: null
}
nullPtr: pointer {
.kind: variable(ref)
.size: 4
.value: null
}
nullVar: variant {
.kind: variable(var)
.size: 8
.value: null
}
nullTyp: typename {
.kind: variable(ref)
.size: 4
.value: null
}
nullFun: function {
.kind: variable(ref)
.size: 4
.value: null
}
nullObj: object {
.kind: variable(ref)
.size: 4
.value: null
}
typePtr: pointer {
.kind: variable(ref)
.size: 4
.value: int64
}
typeVar: variant {
.kind: variable(var)
.size: 8
.value: int64
}
typeTyp: typename {
.kind: variable(ref)
.size: 4
.value: int64
}
local: int64 {
.kind: variable(i64)
.size: 8
.value: value
}
copyVal: int64 {
.kind: variable(i64)
.size: 8
.value: local
}
copyRef: int64 {
.kind: variable(ref)
.size: 4
.value: valueRef
}
copyPtr: pointer {
.kind: variable(ref)
.size: 4
.value: valuePtr
}
copyVar: variant {
.kind: variable(var)
.size: 8
.value: valueVar
}
copyTyp: typename {
.kind: variable(ref)
.size: 4
.value: typeTyp
}
ptrVoid: pointer {
.kind: variable(ref)
.size: 4
.value: void
}
ptrBool: pointer {
.kind: variable(ref)
.size: 4
.value: bool
}
ptrChar: pointer {
.kind: variable(ref)
.size: 4
.value: char
}
ptrInt8: pointer {
.kind: variable(ref)
.size: 4
.value: int8
}
ptrInt16: pointer {
.kind: variable(ref)
.size: 4
.value: int16
}
ptrInt32: pointer {
.kind: variable(ref)
.size: 4
.value: int32
}
ptrInt64: pointer {
.kind: variable(ref)
.size: 4
.value: int64
}
ptrUint8: pointer {
.kind: variable(ref)
.size: 4
.value: uint8
}
ptrUint16: pointer {
.kind: variable(ref)
.size: 4
.value: uint16
}
ptrUint32: pointer {
.kind: variable(ref)
.size: 4
.value: uint32
}
ptrUint64: pointer {
.kind: variable(ref)
.size: 4
.value: uint64
}
ptrFloat32: pointer {
.kind: variable(ref)
.size: 4
.value: float32
}
ptrFloat64: pointer {
.kind: variable(ref)
.size: 4
.value: float64
}
ptrTypename: pointer {
.kind: variable(ref)
.size: 4
.value: typename
}
ptrFunction: pointer {
.kind: variable(ref)
.size: 4
.value: function
}
ptrPointer: pointer {
.kind: variable(ref)
.size: 4
.value: pointer
}
ptrVariant: pointer {
.kind: variable(ref)
.size: 4
.value: variant
}
ptrObject: pointer {
.kind: variable(ref)
.size: 4
.value: object
}
varVoid: variant {
.kind: variable(var)
.size: 8
.value: void
}
varBool: variant {
.kind: variable(var)
.size: 8
.value: bool
}
varChar: variant {
.kind: variable(var)
.size: 8
.value: char
}
varInt8: variant {
.kind: variable(var)
.size: 8
.value: int8
}
varInt16: variant {
.kind: variable(var)
.size: 8
.value: int16
}
varInt32: variant {
.kind: variable(var)
.size: 8
.value: int32
}
varInt64: variant {
.kind: variable(var)
.size: 8
.value: int64
}
varUint8: variant {
.kind: variable(var)
.size: 8
.value: uint8
}
varUint16: variant {
.kind: variable(var)
.size: 8
.value: uint16
}
varUint32: variant {
.kind: variable(var)
.size: 8
.value: uint32
}
varUint64: variant {
.kind: variable(var)
.size: 8
.value: uint64
}
varFloat32: variant {
.kind: variable(var)
.size: 8
.value: float32
}
varFloat64: variant {
.kind: variable(var)
.size: 8
.value: float64
}
varTypename: variant {
.kind: variable(var)
.size: 8
.value: typename
}
varFunction: variant {
.kind: variable(var)
.size: 8
.value: function
}
varPointer: variant {
.kind: variable(var)
.size: 8
.value: pointer
}
varVariant: variant {
.kind: variable(var)
.size: 8
.value: variant
}
varObject: variant {
.kind: variable(var)
.size: 8
.value: object
}
typVoid: typename {
.kind: variable(ref)
.size: 4
.value: void
}
typBool: typename {
.kind: variable(ref)
.size: 4
.value: bool
}
typChar: typename {
.kind: variable(ref)
.size: 4
.value: char
}
typInt8: typename {
.kind: variable(ref)
.size: 4
.value: int8
}
typInt16: typename {
.kind: variable(ref)
.size: 4
.value: int16
}
typInt32: typename {
.kind: variable(ref)
.size: 4
.value: int32
}
typInt64: typename {
.kind: variable(ref)
.size: 4
.value: int64
}
typUint8: typename {
.kind: variable(ref)
.size: 4
.value: uint8
}
typUint16: typename {
.kind: variable(ref)
.size: 4
.value: uint16
}
typUint32: typename {
.kind: variable(ref)
.size: 4
.value: uint32
}
typUint64: typename {
.kind: variable(ref)
.size: 4
.value: uint64
}
typFloat32: typename {
.kind: variable(ref)
.size: 4
.value: float32
}
typFloat64: typename {
.kind: variable(ref)
.size: 4
.value: float64
}
typTypename: typename {
.kind: variable(ref)
.size: 4
.value: typename
}
typFunction: typename {
.kind: variable(ref)
.size: 4
.value: function
}
typPointer: typename {
.kind: variable(ref)
.size: 4
.value: pointer
}
typVariant: typename {
.kind: variable(ref)
.size: 4
.value: variant
}
typObject: typename {
.kind: variable(ref)
.size: 4
.value: object
}
valueOfPtr: pointer {
.kind: variable(ref)
.size: 4
.value: pointer(value)
}
valueOfVar: variant {
.kind: variable(var)
.size: 8
.value: variant(value)
}
valueOfTyp: typename {
.kind: variable(ref)
.size: 4
.value: typename(value)
}
typeOfValue: typename {
.kind: variable(ref)
.size: 4
.value: typename(value)
}
copyPtrFloat64: variant {
.kind: variable(var)
.size: 8
.value: ptrFloat64
}
copyVarFloat64: pointer {
.kind: variable(ref)
.size: 4
.value: varFloat64
}
localNoInit: int64 {
.kind: variable(i64)
.size: 8
}
globalNoInit: int64 {
.kind: static variable(i64)
.size: 8
}
localInitValue: int64 {
.kind: variable(i64)
.size: 8
.value: 42
}
globalInitValue: int64 {
.kind: static variable(i64)
.size: 8
.value: 1024
}
localInitLocal: int64 {
.kind: variable(i64)
.size: 8
.value: localInitValue
}
globalInitLocal: int64 {
.kind: static variable(i64)
.size: 8
.value: localInitValue
}
localInitGlobal: int64 {
.kind: variable(i64)
.size: 8
.value: globalInitValue
}
globalInitGlobal: int64 {
.kind: static variable(i64)
.size: 8
.value: globalInitValue
}
InitMember: typename {
.kind: static const typename(val)
.size: 16
.field intMember: int32 (size: 4 @0 -> variable(i32))
.field intMemberDef: int32 (size: 4 @4 -> variable(i32))
.field intConstMember: int32 (size: 4 @8 -> const variable(i32))
.field intConstMemberDef: int32 (size: 4 @12 -> const variable(i32))
.field intGlobal: int32 (size: 4 @146904 -> static variable(i32))
.field intConstant: int32 (size: 4 @146908 -> static const variable(i32))
}
InitMember.intMember: int32 {
.kind: variable(i32)
.size: 4
.owner: InitMember
}
InitMember.intMemberDef: int32 {
.kind: variable(i32)
.size: 4
.owner: InitMember
.value: 9
}
InitMember.intConstMember: int32 {
.kind: const variable(i32)
.size: 4
.owner: InitMember
}
InitMember.intConstMemberDef: int32 {
.kind: const variable(i32)
.size: 4
.owner: InitMember
.value: 42
}
InitMember.intGlobal: int32 {
.kind: static variable(i32)
.size: 4
.owner: InitMember
.value: 0
}
InitMember.intConstant: int32 {
.kind: static const variable(i32)
.size: 4
.owner: InitMember
.value: 0
}
pi64: float64 {
.kind: variable(f64)
.size: 8
.value: 3.141593
}
e64: float64 {
.kind: variable(f64)
.size: 8
.value: 2.718282
}
pi32: float32 {
.kind: variable(f32)
.size: 4
.value: pi64
}
e32: float32 {
.kind: variable(f32)
.size: 4
.value: e64
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param r: int32 (size: 4 @0 -> i32)
.param g: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.size: 0
.param .result: int32 (size: 4 @0 -> i32)
.param r: int32 (size: 4 @0 -> i32)
.param g: int32 (size: 4 @0 -> i32)
.param b: int32 (size: 4 @0 -> i32)
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
}
r_comp: int32 {
.kind: variable(i32)
.size: 4
.value: 14 << 3
}
g_comp: int32 {
.kind: variable(i32)
.size: 4
.value: 63 << 2
}
b_comp: int32 {
.kind: variable(i32)
.size: 4
.value: 31 << 3
}
r5g6b5: int32 {
.kind: variable(i32)
.size: 4
.value: rgb565(r_comp, g_comp, b_comp)
}
r8g8b8: int32 {
.kind: variable(i32)
.size: 4
.value: rgb888(r_comp, g_comp, b_comp)
}
zxtR5: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r5g6b5, 11, 5)
}
zxtG6: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r5g6b5, 5, 6)
}
zxtB5: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r5g6b5, 0, 5)
}
sxtR5: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r5g6b5, 11, 5)
}
sxtG6: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r5g6b5, 5, 6)
}
sxtB5: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r5g6b5, 0, 5)
}
zxtR8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r8g8b8, 16, 8)
}
zxtG8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r8g8b8, 8, 8)
}
zxtB8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.zxt(r8g8b8, 0, 8)
}
sxtR8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r8g8b8, 16, 8)
}
sxtG8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r8g8b8, 8, 8)
}
sxtB8: int32 {
.kind: variable(i32)
.size: 4
.value: uint32.sxt(r8g8b8, 0, 8)
}
sinF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.sin(pi64 / (2))
}
cosF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.cos(pi64 / (2))
}
tanF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.tan(pi64 / (4))
}
logF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.log(e64 * e64 * e64)
}
expF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.exp(1.000000)
}
powF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.pow(pi64 * pi64, 0.500000)
}
sqrtF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.sqrt(pi64 * pi64)
}
atanF64: float64 {
.kind: variable(f64)
.size: 8
.value: float64.atan2(pi64, 1.000000)
}
sinF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.sin(pi32 / (2))
}
cosF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.cos(pi32 / (2))
}
tanF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.tan(pi32 / (4))
}
logF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.log(e32 * e32 * e32)
}
expF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.exp(1.000000)
}
powF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.pow(pi32 * pi32, 0.500000)
}
sqrtF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.sqrt(pi32 * pi32)
}
atanF32: float32 {
.kind: variable(f32)
.size: 4
.value: float32.atan2(pi32, 1.000000)
}
malloc(size: int32): pointer: function {
.kind: inline
.size: 0
.param .result: pointer (size: 4 @0 -> ref)
.param size: int32 (size: 4 @0 -> i32)
.value: pointer.alloc(null, size)
}
free(data: pointer): pointer: function {
.kind: inline
.size: 0
.param .result: pointer (size: 4 @0 -> ref)
.param data: pointer (size: 4 @0 -> ref)
.value: pointer.alloc(data, 0)
}
p1: pointer {
.kind: variable(ref)
.size: 4
.value: malloc(1024)
}
p2: pointer {
.kind: variable(ref)
.size: 4
.value: malloc(80)
}
p3: pointer {
.kind: variable(ref)
.size: 4
.value: malloc(160)
}
p4: pointer {
.kind: variable(ref)
.size: 4
.value: malloc(820)
}
val1: int64 {
.kind: variable(i64)
.size: 8
.value: 42
}
val2: int64 {
.kind: variable(i64)
.size: 8
.value: 96
}
.main(): void: function {
.kind: static function
.size: 4786
.field typename: typename (size: 136 @8 -> static const typename(ref))
.field void: typename (size: 0 @160 -> static const typename(void))
.field bool: typename (size: 1 @304 -> static const typename(bool))
.field char: typename (size: 1 @448 -> static const typename(u32))
.field int8: typename (size: 1 @592 -> static const typename(i32))
.field int16: typename (size: 2 @736 -> static const typename(i32))
.field int32: typename (size: 4 @880 -> static const typename(i32))
.field int64: typename (size: 8 @1024 -> static const typename(i64))
.field uint8: typename (size: 1 @1168 -> static const typename(u32))
.field uint16: typename (size: 2 @1312 -> static const typename(u32))
.field uint32: typename (size: 4 @1456 -> static const typename(u32))
.field uint64: typename (size: 8 @1600 -> static const typename(u64))
.field float32: typename (size: 4 @1744 -> static const typename(f32))
.field float64: typename (size: 8 @1888 -> static const typename(f64))
.field pointer: typename (size: 4 @2032 -> static const typename(ref))
.field variant: typename (size: 8 @2176 -> static const typename(var))
.field function: typename (size: 8 @2320 -> static const typename(ref))
.field object: typename (size: 4 @2472 -> static const typename(ref))
.field null: pointer (size: 0 @0 -> static const inline)
.field true: bool (size: 0 @0 -> static const inline)
.field false: bool (size: 0 @0 -> static const inline)
.field int: typename (size: 0 @0 -> static const inline)
.field byte: typename (size: 0 @0 -> static const inline)
.field float: typename (size: 0 @0 -> static const inline)
.field double: typename (size: 0 @0 -> static const inline)
.field .cstr: char (size: 4 @3624 -> static const typename(arr))
.field emit: function (size: 0 @3768 -> static const typename(void))
.field halt: function (size: 0 @21168 -> static const inline)
.field CLOCKS_PER_SEC: int32 (size: 0 @0 -> i32)
.field RAND_MAX: int32 (size: 0 @0 -> i32)
.field raise: function (size: 0 @24672 -> static const inline)
.field tryExec: function (size: 0 @26720 -> static const inline)
.field System: void (size: 0 @28872 -> static const typename(void))
.field trace: function (size: 0 @0 -> inline)
.field trace: function (size: 0 @0 -> inline)
.field debug: function (size: 0 @0 -> inline)
.field debug: function (size: 0 @0 -> inline)
.field info: function (size: 0 @0 -> inline)
.field info: function (size: 0 @0 -> inline)
.field warn: function (size: 0 @0 -> inline)
.field warn: function (size: 0 @0 -> inline)
.field error: function (size: 0 @0 -> inline)
.field error: function (size: 0 @0 -> inline)
.field abort: function (size: 0 @0 -> inline)
.field abort: function (size: 0 @0 -> inline)
.field abort: function (size: 0 @0 -> inline)
.field assert: function (size: 0 @0 -> inline)
.field assert: function (size: 0 @0 -> inline)
.field assert: function (size: 0 @0 -> inline)
.field integer: typename (size: 0 @0 -> inline)
.field t: int32 (size: 4 @12 -> variable(i32))
.field forIdx: int32 (size: 4 @16 -> variable(i32))
.field rgbF32: typename (size: 16 @53488 -> static const typename(val))
.field rgbU8: typename (size: 3 @54032 -> static const typename(val))
.field color: typename (size: 4 @54576 -> static const typename(val))
.field Color: object (size: 20 @54984 -> static const typename(ref))
.field record_pack0: typename (size: 8 @55352 -> static const typename(val))
.field record_pack1: typename (size: 17 @56304 -> static const typename(val))
.field record_pack2: typename (size: 20 @57256 -> static const typename(val))
.field record_pack4: typename (size: 24 @58208 -> static const typename(val))
.field record_pack8: typename (size: 32 @59160 -> static const typename(val))
.field record_packDef: typename (size: 32 @60112 -> static const typename(val))
.field zero: function (size: 0 @0 -> inline)
.field last: function (size: 0 @0 -> inline)
.field sum: function (size: 0 @0 -> inline)
.field any: function (size: 0 @0 -> inline)
.field min: function (size: 0 @0 -> inline)
.field sum: function (size: 0 @0 -> inline)
.field any: function (size: 0 @0 -> inline)
.field min: function (size: 0 @0 -> inline)
.field ma: int32 (size: 4 @20 -> variable(i32))
.field mb: int32 (size: 4 @24 -> variable(i32))
.field mc: int32 (size: 4 @28 -> variable(i32))
.field zeroVal: int32 (size: 4 @32 -> variable(i32))
.field zeroVar: int32 (size: 4 @36 -> variable(i32))
.field zeroXpr: int32 (size: 4 @40 -> variable(i32))
.field lastVal: int32 (size: 4 @44 -> variable(i32))
.field lastVar: int32 (size: 4 @48 -> variable(i32))
.field lastXpr: int32 (size: 4 @52 -> variable(i32))
.field sum2Val: int32 (size: 4 @56 -> variable(i32))
.field sum2Var: int32 (size: 4 @60 -> variable(i32))
.field sum2Xpr: int32 (size: 4 @64 -> variable(i32))
.field any2Val: int32 (size: 4 @68 -> variable(i32))
.field any2Var: int32 (size: 4 @72 -> variable(i32))
.field any2Xpr: int32 (size: 4 @76 -> variable(i32))
.field min2Val: int32 (size: 4 @80 -> variable(i32))
.field min2Var: int32 (size: 4 @84 -> variable(i32))
.field min2Xpr: int32 (size: 4 @88 -> variable(i32))
.field any3Val: int32 (size: 4 @92 -> variable(i32))
.field any3Var: int32 (size: 4 @96 -> variable(i32))
.field any3Xpr: int32 (size: 4 @100 -> variable(i32))
.field min3Val: int32 (size: 4 @104 -> variable(i32))
.field min3Var: int32 (size: 4 @108 -> variable(i32))
.field min3Xpr: int32 (size: 4 @112 -> variable(i32))
.field overload: typename (size: 0 @0 -> inline)
.field overload: function (size: 0 @0 -> inline)
.field overload: function (size: 0 @0 -> inline)
.field overload: function (size: 0 @0 -> inline)
.field overload: function (size: 0 @0 -> inline)
.field overload1: float32 (size: 4 @116 -> variable(f32))
.field overload2: float32 (size: 4 @120 -> variable(f32))
.field overload3: float32 (size: 4 @124 -> variable(f32))
.field overload4: float32 (size: 4 @128 -> variable(f32))
.field overload5: float32 (size: 4 @132 -> variable(f32))
.field emitldz32: int32 (size: 4 @136 -> variable(i32))
.field emitldz64: int64 (size: 8 @144 -> variable(i64))
.field emitA: int32 (size: 4 @148 -> variable(i32))
.field emitB: int32 (size: 4 @152 -> variable(i32))
.field emitAddI32: int32 (size: 4 @156 -> variable(i32))
.field emitDivI32: int32 (size: 4 @160 -> variable(i32))
.field emitNfcF32: float32 (size: 4 @164 -> variable(f32))
.field sizeof: function (size: 0 @0 -> inline)
.field sizeofVoid: int32 (size: 4 @168 -> variable(i32))
.field sizeofBool: int32 (size: 4 @172 -> variable(i32))
.field sizeofChar: int32 (size: 4 @176 -> variable(i32))
.field sizeofInt8: int32 (size: 4 @180 -> variable(i32))
.field sizeofInt16: int32 (size: 4 @184 -> variable(i32))
.field sizeofInt32: int32 (size: 4 @188 -> variable(i32))
.field sizeofInt64: int32 (size: 4 @192 -> variable(i32))
.field sizeofUint8: int32 (size: 4 @196 -> variable(i32))
.field sizeofUint16: int32 (size: 4 @200 -> variable(i32))
.field sizeofUint32: int32 (size: 4 @204 -> variable(i32))
.field sizeofUint64: int32 (size: 4 @208 -> variable(i32))
.field sizeofFloat32: int32 (size: 4 @212 -> variable(i32))
.field sizeofFloat64: int32 (size: 4 @216 -> variable(i32))
.field sizeofPointer: int32 (size: 4 @220 -> variable(i32))
.field sizeofVariant: int32 (size: 4 @224 -> variable(i32))
.field sizeofTypename: int32 (size: 4 @228 -> variable(i32))
.field sizeofFunction: int32 (size: 4 @232 -> variable(i32))
.field sizeofObject: int32 (size: 4 @236 -> variable(i32))
.field RecordSizeof: object (size: 12 @76120 -> static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16 @76392 -> static const typename(ref))
.field typeofRecord: typename (size: 4 @240 -> variable(ref))
.field nameOfRecord: char[*] (size: 4 @244 -> variable(ref))
.field sizeOfRecord: int32 (size: 4 @248 -> variable(i32))
.field fileOfRecord: char[*] (size: 4 @252 -> variable(ref))
.field lineOfRecord: int32 (size: 4 @256 -> variable(i32))
.field typeofBase: typename (size: 4 @260 -> variable(ref))
.field nameOfBase: char[*] (size: 4 @264 -> variable(ref))
.field sizeOfBase: int32 (size: 4 @268 -> variable(i32))
.field fileOfBase: char[*] (size: 4 @272 -> variable(ref))
.field lineOfBase: int32 (size: 4 @276 -> variable(i32))
.field typeofBase1: typename (size: 4 @280 -> variable(ref))
.field sizeofBase1: int32 (size: 4 @284 -> variable(i32))
.field typeofBase2: typename (size: 4 @288 -> variable(ref))
.field sizeofBase2: int32 (size: 4 @292 -> variable(i32))
.field empty: function (size: 1 @146752 -> static const function)
.field funAdd: function (size: 9 @146753 -> static const function)
.field funAddResult: int32 (size: 4 @296 -> variable(i32))
.field funAddRef: function (size: 4 @300 -> variable(ref))
.field funAddRefResult: int32 (size: 4 @304 -> variable(i32))
.field funMul: function (size: 4 @308 -> variable(ref))
.field funMulResult: int32 (size: 4 @312 -> variable(i32))
.field funMulRef: function (size: 4 @316 -> variable(ref))
.field funMulRefResult: int32 (size: 4 @320 -> variable(i32))
.field funMul: function (size: 9 @146762 -> static const function)
.field fib: function (size: 87 @146771 -> static const function)
.field fibonacci_13: uint32 (size: 4 @324 -> variable(u32))
.field a: typename (size: 0 @0 -> inline)
.field b: typename (size: 0 @0 -> inline)
.field shift: int32 (size: 4 @328 -> variable(i32))
.field boolA: bool (size: 1 @332 -> variable(bool))
.field boolB: bool (size: 1 @336 -> variable(bool))
.field boolAnd: bool (size: 1 @340 -> variable(bool))
.field boolIor: bool (size: 1 @344 -> variable(bool))
.field boolXor: bool (size: 1 @348 -> variable(bool))
.field boolNot: bool (size: 1 @352 -> variable(bool))
.field boolCeq: bool (size: 1 @356 -> variable(bool))
.field boolCne: bool (size: 1 @360 -> variable(bool))
.field boolClt: bool (size: 1 @364 -> variable(bool))
.field boolCle: bool (size: 1 @368 -> variable(bool))
.field boolCgt: bool (size: 1 @372 -> variable(bool))
.field boolCge: bool (size: 1 @376 -> variable(bool))
.field chrA: char (size: 1 @380 -> variable(u32))
.field chrB: char (size: 1 @384 -> variable(u32))
.field chrPls: char (size: 1 @388 -> variable(u32))
.field chrNeg: char (size: 1 @392 -> variable(u32))
.field chrCmt: char (size: 1 @396 -> variable(u32))
.field chrAdd: char (size: 1 @400 -> variable(u32))
.field chrSub: char (size: 1 @404 -> variable(u32))
.field chrMul: char (size: 1 @408 -> variable(u32))
.field chrDiv: char (size: 1 @412 -> variable(u32))
.field chrMod: char (size: 1 @416 -> variable(u32))
.field chrAnd: char (size: 1 @420 -> variable(u32))
.field chrIor: char (size: 1 @424 -> variable(u32))
.field chrXor: char (size: 1 @428 -> variable(u32))
.field chrShl: char (size: 1 @432 -> variable(u32))
.field chrShr: char (size: 1 @436 -> variable(u32))
.field chrNot: bool (size: 1 @440 -> variable(bool))
.field chrCeq: bool (size: 1 @444 -> variable(bool))
.field chrCne: bool (size: 1 @448 -> variable(bool))
.field chrClt: bool (size: 1 @452 -> variable(bool))
.field chrCle: bool (size: 1 @456 -> variable(bool))
.field chrCgt: bool (size: 1 @460 -> variable(bool))
.field chrCge: bool (size: 1 @464 -> variable(bool))
.field i8A: int8 (size: 1 @468 -> variable(i32))
.field i8B: int8 (size: 1 @472 -> variable(i32))
.field i8Pls: int8 (size: 1 @476 -> variable(i32))
.field i8Neg: int8 (size: 1 @480 -> variable(i32))
.field i8Cmt: int8 (size: 1 @484 -> variable(i32))
.field i8Add: int8 (size: 1 @488 -> variable(i32))
.field i8Sub: int8 (size: 1 @492 -> variable(i32))
.field i8Mul: int8 (size: 1 @496 -> variable(i32))
.field i8Div: int8 (size: 1 @500 -> variable(i32))
.field i8Mod: int8 (size: 1 @504 -> variable(i32))
.field i8And: int8 (size: 1 @508 -> variable(i32))
.field i8Ior: int8 (size: 1 @512 -> variable(i32))
.field i8Xor: int8 (size: 1 @516 -> variable(i32))
.field i8Shl: int8 (size: 1 @520 -> variable(i32))
.field i8Shr: int8 (size: 1 @524 -> variable(i32))
.field i8Not: bool (size: 1 @528 -> variable(bool))
.field i8Ceq: bool (size: 1 @532 -> variable(bool))
.field i8Cne: bool (size: 1 @536 -> variable(bool))
.field i8Clt: bool (size: 1 @540 -> variable(bool))
.field i8Cle: bool (size: 1 @544 -> variable(bool))
.field i8Cgt: bool (size: 1 @548 -> variable(bool))
.field i8Cge: bool (size: 1 @552 -> variable(bool))
.field u8A: uint8 (size: 1 @556 -> variable(u32))
.field u8B: uint8 (size: 1 @560 -> variable(u32))
.field u8Pls: uint8 (size: 1 @564 -> variable(u32))
.field u8Neg: uint8 (size: 1 @568 -> variable(u32))
.field u8Cmt: uint8 (size: 1 @572 -> variable(u32))
.field u8Add: uint8 (size: 1 @576 -> variable(u32))
.field u8Sub: uint8 (size: 1 @580 -> variable(u32))
.field u8Mul: uint8 (size: 1 @584 -> variable(u32))
.field u8Div: uint8 (size: 1 @588 -> variable(u32))
.field u8Mod: uint8 (size: 1 @592 -> variable(u32))
.field u8And: uint8 (size: 1 @596 -> variable(u32))
.field u8Ior: uint8 (size: 1 @600 -> variable(u32))
.field u8Xor: uint8 (size: 1 @604 -> variable(u32))
.field u8Shl: uint8 (size: 1 @608 -> variable(u32))
.field u8Shr: uint8 (size: 1 @612 -> variable(u32))
.field u8Not: bool (size: 1 @616 -> variable(bool))
.field u8Ceq: bool (size: 1 @620 -> variable(bool))
.field u8Cne: bool (size: 1 @624 -> variable(bool))
.field u8Clt: bool (size: 1 @628 -> variable(bool))
.field u8Cle: bool (size: 1 @632 -> variable(bool))
.field u8Cgt: bool (size: 1 @636 -> variable(bool))
.field u8Cge: bool (size: 1 @640 -> variable(bool))
.field i16A: int16 (size: 2 @644 -> variable(i32))
.field i16B: int16 (size: 2 @648 -> variable(i32))
.field i16Pls: int16 (size: 2 @652 -> variable(i32))
.field i16Neg: int16 (size: 2 @656 -> variable(i32))
.field i16Cmt: int16 (size: 2 @660 -> variable(i32))
.field i16Add: int16 (size: 2 @664 -> variable(i32))
.field i16Sub: int16 (size: 2 @668 -> variable(i32))
.field i16Mul: int16 (size: 2 @672 -> variable(i32))
.field i16Div: int16 (size: 2 @676 -> variable(i32))
.field i16Mod: int16 (size: 2 @680 -> variable(i32))
.field i16And: int16 (size: 2 @684 -> variable(i32))
.field i16Ior: int16 (size: 2 @688 -> variable(i32))
.field i16Xor: int16 (size: 2 @692 -> variable(i32))
.field i16Shl: int16 (size: 2 @696 -> variable(i32))
.field i16Shr: int16 (size: 2 @700 -> variable(i32))
.field i16Not: bool (size: 1 @704 -> variable(bool))
.field i16Ceq: bool (size: 1 @708 -> variable(bool))
.field i16Cne: bool (size: 1 @712 -> variable(bool))
.field i16Clt: bool (size: 1 @716 -> variable(bool))
.field i16Cle: bool (size: 1 @720 -> variable(bool))
.field i16Cgt: bool (size: 1 @724 -> variable(bool))
.field i16Cge: bool (size: 1 @728 -> variable(bool))
.field u16A: uint16 (size: 2 @732 -> variable(u32))
.field u16B: uint16 (size: 2 @736 -> variable(u32))
.field u16Pls: uint16 (size: 2 @740 -> variable(u32))
.field u16Neg: uint16 (size: 2 @744 -> variable(u32))
.field u16Cmt: uint16 (size: 2 @748 -> variable(u32))
.field u16Add: uint16 (size: 2 @752 -> variable(u32))
.field u16Sub: uint16 (size: 2 @756 -> variable(u32))
.field u16Mul: uint16 (size: 2 @760 -> variable(u32))
.field u16Div: uint16 (size: 2 @764 -> variable(u32))
.field u16Mod: uint16 (size: 2 @768 -> variable(u32))
.field u16And: uint16 (size: 2 @772 -> variable(u32))
.field u16Ior: uint16 (size: 2 @776 -> variable(u32))
.field u16Xor: uint16 (size: 2 @780 -> variable(u32))
.field u16Shl: uint16 (size: 2 @784 -> variable(u32))
.field u16Shr: uint16 (size: 2 @788 -> variable(u32))
.field u16Not: bool (size: 1 @792 -> variable(bool))
.field u16Ceq: bool (size: 1 @796 -> variable(bool))
.field u16Cne: bool (size: 1 @800 -> variable(bool))
.field u16Clt: bool (size: 1 @804 -> variable(bool))
.field u16Cle: bool (size: 1 @808 -> variable(bool))
.field u16Cgt: bool (size: 1 @812 -> variable(bool))
.field u16Cge: bool (size: 1 @816 -> variable(bool))
.field i32A: int32 (size: 4 @820 -> variable(i32))
.field i32B: int32 (size: 4 @824 -> variable(i32))
.field i32Pls: int32 (size: 4 @828 -> variable(i32))
.field i32Neg: int32 (size: 4 @832 -> variable(i32))
.field i32Cmt: int32 (size: 4 @836 -> variable(i32))
.field i32Add: int32 (size: 4 @840 -> variable(i32))
.field i32Sub: int32 (size: 4 @844 -> variable(i32))
.field i32Mul: int32 (size: 4 @848 -> variable(i32))
.field i32Div: int32 (size: 4 @852 -> variable(i32))
.field i32Mod: int32 (size: 4 @856 -> variable(i32))
.field i32And: int32 (size: 4 @860 -> variable(i32))
.field i32Ior: int32 (size: 4 @864 -> variable(i32))
.field i32Xor: int32 (size: 4 @868 -> variable(i32))
.field i32Shl: int32 (size: 4 @872 -> variable(i32))
.field i32Shr: int32 (size: 4 @876 -> variable(i32))
.field i32Not: bool (size: 1 @880 -> variable(bool))
.field i32Ceq: bool (size: 1 @884 -> variable(bool))
.field i32Cne: bool (size: 1 @888 -> variable(bool))
.field i32Clt: bool (size: 1 @892 -> variable(bool))
.field i32Cle: bool (size: 1 @896 -> variable(bool))
.field i32Cgt: bool (size: 1 @900 -> variable(bool))
.field i32Cge: bool (size: 1 @904 -> variable(bool))
.field u32A: uint32 (size: 4 @908 -> variable(u32))
.field u32B: uint32 (size: 4 @912 -> variable(u32))
.field u32Pls: uint32 (size: 4 @916 -> variable(u32))
.field u32Neg: uint32 (size: 4 @920 -> variable(u32))
.field u32Cmt: uint32 (size: 4 @924 -> variable(u32))
.field u32Add: uint32 (size: 4 @928 -> variable(u32))
.field u32Sub: uint32 (size: 4 @932 -> variable(u32))
.field u32Mul: uint32 (size: 4 @936 -> variable(u32))
.field u32Div: uint32 (size: 4 @940 -> variable(u32))
.field u32Mod: uint32 (size: 4 @944 -> variable(u32))
.field u32And: uint32 (size: 4 @948 -> variable(u32))
.field u32Ior: uint32 (size: 4 @952 -> variable(u32))
.field u32Xor: uint32 (size: 4 @956 -> variable(u32))
.field u32Shl: uint32 (size: 4 @960 -> variable(u32))
.field u32Shr: uint32 (size: 4 @964 -> variable(u32))
.field u32Not: bool (size: 1 @968 -> variable(bool))
.field u32Ceq: bool (size: 1 @972 -> variable(bool))
.field u32Cne: bool (size: 1 @976 -> variable(bool))
.field u32Clt: bool (size: 1 @980 -> variable(bool))
.field u32Cle: bool (size: 1 @984 -> variable(bool))
.field u32Cgt: bool (size: 1 @988 -> variable(bool))
.field u32Cge: bool (size: 1 @992 -> variable(bool))
.field i64A: int64 (size: 8 @1000 -> variable(i64))
.field i64B: int64 (size: 8 @1008 -> variable(i64))
.field i64Pls: int64 (size: 8 @1016 -> variable(i64))
.field i64Neg: int64 (size: 8 @1024 -> variable(i64))
.field i64Cmt: int64 (size: 8 @1032 -> variable(i64))
.field i64Add: int64 (size: 8 @1040 -> variable(i64))
.field i64Sub: int64 (size: 8 @1048 -> variable(i64))
.field i64Mul: int64 (size: 8 @1056 -> variable(i64))
.field i64Div: int64 (size: 8 @1064 -> variable(i64))
.field i64Mod: int64 (size: 8 @1072 -> variable(i64))
.field i64And: int64 (size: 8 @1080 -> variable(i64))
.field i64Ior: int64 (size: 8 @1088 -> variable(i64))
.field i64Xor: int64 (size: 8 @1096 -> variable(i64))
.field i64Shl: int64 (size: 8 @1104 -> variable(i64))
.field i64Shr: int64 (size: 8 @1112 -> variable(i64))
.field i64Not: bool (size: 1 @1116 -> variable(bool))
.field i64Ceq: bool (size: 1 @1120 -> variable(bool))
.field i64Cne: bool (size: 1 @1124 -> variable(bool))
.field i64Clt: bool (size: 1 @1128 -> variable(bool))
.field i64Cle: bool (size: 1 @1132 -> variable(bool))
.field i64Cgt: bool (size: 1 @1136 -> variable(bool))
.field i64Cge: bool (size: 1 @1140 -> variable(bool))
.field u64A: uint64 (size: 8 @1148 -> variable(u64))
.field u64B: uint64 (size: 8 @1156 -> variable(u64))
.field u64Pls: uint64 (size: 8 @1164 -> variable(u64))
.field u64Neg: uint64 (size: 8 @1172 -> variable(u64))
.field u64Cmt: uint64 (size: 8 @1180 -> variable(u64))
.field u64Add: uint64 (size: 8 @1188 -> variable(u64))
.field u64Sub: uint64 (size: 8 @1196 -> variable(u64))
.field u64Mul: uint64 (size: 8 @1204 -> variable(u64))
.field u64Div: uint64 (size: 8 @1212 -> variable(u64))
.field u64Mod: uint64 (size: 8 @1220 -> variable(u64))
.field u64And: uint64 (size: 8 @1228 -> variable(u64))
.field u64Ior: uint64 (size: 8 @1236 -> variable(u64))
.field u64Xor: uint64 (size: 8 @1244 -> variable(u64))
.field u64Shl: uint64 (size: 8 @1252 -> variable(u64))
.field u64Shr: uint64 (size: 8 @1260 -> variable(u64))
.field u64Not: bool (size: 1 @1264 -> variable(bool))
.field u64Ceq: bool (size: 1 @1268 -> variable(bool))
.field u64Cne: bool (size: 1 @1272 -> variable(bool))
.field u64Clt: bool (size: 1 @1276 -> variable(bool))
.field u64Cle: bool (size: 1 @1280 -> variable(bool))
.field u64Cgt: bool (size: 1 @1284 -> variable(bool))
.field u64Cge: bool (size: 1 @1288 -> variable(bool))
.field f32A: float32 (size: 4 @1292 -> variable(f32))
.field f32B: float32 (size: 4 @1296 -> variable(f32))
.field f32Pls: float32 (size: 4 @1300 -> variable(f32))
.field f32Neg: float32 (size: 4 @1304 -> variable(f32))
.field f32Add: float32 (size: 4 @1308 -> variable(f32))
.field f32Sub: float32 (size: 4 @1312 -> variable(f32))
.field f32Mul: float32 (size: 4 @1316 -> variable(f32))
.field f32Div: float32 (size: 4 @1320 -> variable(f32))
.field f32Mod: float32 (size: 4 @1324 -> variable(f32))
.field f32Not: bool (size: 1 @1328 -> variable(bool))
.field f32Ceq: bool (size: 1 @1332 -> variable(bool))
.field f32Cne: bool (size: 1 @1336 -> variable(bool))
.field f32Clt: bool (size: 1 @1340 -> variable(bool))
.field f32Cle: bool (size: 1 @1344 -> variable(bool))
.field f32Cgt: bool (size: 1 @1348 -> variable(bool))
.field f32Cge: bool (size: 1 @1352 -> variable(bool))
.field f64A: float64 (size: 8 @1360 -> variable(f64))
.field f64B: float64 (size: 8 @1368 -> variable(f64))
.field f64Pls: float64 (size: 8 @1376 -> variable(f64))
.field f64Neg: float64 (size: 8 @1384 -> variable(f64))
.field f64Add: float64 (size: 8 @1392 -> variable(f64))
.field f64Sub: float64 (size: 8 @1400 -> variable(f64))
.field f64Mul: float64 (size: 8 @1408 -> variable(f64))
.field f64Div: float64 (size: 8 @1416 -> variable(f64))
.field f64Mod: float64 (size: 8 @1424 -> variable(f64))
.field f64Not: bool (size: 1 @1428 -> variable(bool))
.field f64Ceq: bool (size: 1 @1432 -> variable(bool))
.field f64Cne: bool (size: 1 @1436 -> variable(bool))
.field f64Clt: bool (size: 1 @1440 -> variable(bool))
.field f64Cle: bool (size: 1 @1444 -> variable(bool))
.field f64Cgt: bool (size: 1 @1448 -> variable(bool))
.field f64Cge: bool (size: 1 @1452 -> variable(bool))
.field ptrA: pointer (size: 4 @1456 -> variable(ref))
.field ptrB: pointer (size: 4 @1460 -> variable(ref))
.field ptrCeq: bool (size: 1 @1464 -> variable(bool))
.field ptrCne: bool (size: 1 @1468 -> variable(bool))
.field arrFixedNoInit: int64[7] (size: 56 @1524 -> variable(val))
.field arrSliceNoInit: int64[] (size: 8 @1532 -> variable(arr))
.field arrPtrNoInit: int64[*] (size: 4 @1536 -> variable(ref))
.field arrSliceInitNull: int64[] (size: 8 @1544 -> variable(arr))
.field arrPtrInitNull: int64[*] (size: 4 @1548 -> variable(ref))
.field arrSliceInitFixed: int64[] (size: 8 @1556 -> variable(arr))
.field arrPtrInitFixed: int64[*] (size: 4 @1560 -> variable(ref))
.field arrSliceInitSlice: int64[] (size: 8 @1568 -> variable(arr))
.field arrPtrInitSlice: int64[*] (size: 4 @1572 -> variable(ref))
.field arrPtrInitPtr: int64[*] (size: 4 @1576 -> variable(ref))
.field arrSliceInitString: char[] (size: 8 @1584 -> variable(arr))
.field arrPtrInitString: char[*] (size: 4 @1588 -> variable(ref))
.field value: int64 (size: 8 @146864 -> static variable(i64))
.field valueRef: int64 (size: 4 @1592 -> variable(ref))
.field valuePtr: pointer (size: 4 @1596 -> variable(ref))
.field valueVar: variant (size: 8 @1604 -> variable(var))
.field fromRef: int64 (size: 8 @1612 -> variable(i64))
.field fromPtr: int64 (size: 4 @1616 -> variable(ref))
.field fromVar: int64 (size: 4 @1620 -> variable(ref))
.field nullRef: int64 (size: 4 @1624 -> variable(ref))
.field nullPtr: pointer (size: 4 @1628 -> variable(ref))
.field nullVar: variant (size: 8 @1636 -> variable(var))
.field nullTyp: typename (size: 4 @1640 -> variable(ref))
.field nullFun: function (size: 4 @1644 -> variable(ref))
.field nullObj: object (size: 4 @1648 -> variable(ref))
.field typePtr: pointer (size: 4 @1652 -> variable(ref))
.field typeVar: variant (size: 8 @1660 -> variable(var))
.field typeTyp: typename (size: 4 @1664 -> variable(ref))
.field local: int64 (size: 8 @1672 -> variable(i64))
.field copyVal: int64 (size: 8 @1680 -> variable(i64))
.field copyRef: int64 (size: 4 @1684 -> variable(ref))
.field copyPtr: pointer (size: 4 @1688 -> variable(ref))
.field copyVar: variant (size: 8 @1696 -> variable(var))
.field copyTyp: typename (size: 4 @1700 -> variable(ref))
.field ptrVoid: pointer (size: 4 @1704 -> variable(ref))
.field ptrBool: pointer (size: 4 @1708 -> variable(ref))
.field ptrChar: pointer (size: 4 @1712 -> variable(ref))
.field ptrInt8: pointer (size: 4 @1716 -> variable(ref))
.field ptrInt16: pointer (size: 4 @1720 -> variable(ref))
.field ptrInt32: pointer (size: 4 @1724 -> variable(ref))
.field ptrInt64: pointer (size: 4 @1728 -> variable(ref))
.field ptrUint8: pointer (size: 4 @1732 -> variable(ref))
.field ptrUint16: pointer (size: 4 @1736 -> variable(ref))
.field ptrUint32: pointer (size: 4 @1740 -> variable(ref))
.field ptrUint64: pointer (size: 4 @1744 -> variable(ref))
.field ptrFloat32: pointer (size: 4 @1748 -> variable(ref))
.field ptrFloat64: pointer (size: 4 @1752 -> variable(ref))
.field ptrTypename: pointer (size: 4 @1756 -> variable(ref))
.field ptrFunction: pointer (size: 4 @1760 -> variable(ref))
.field ptrPointer: pointer (size: 4 @1764 -> variable(ref))
.field ptrVariant: pointer (size: 4 @1768 -> variable(ref))
.field ptrObject: pointer (size: 4 @1772 -> variable(ref))
.field varVoid: variant (size: 8 @1780 -> variable(var))
.field varBool: variant (size: 8 @1788 -> variable(var))
.field varChar: variant (size: 8 @1796 -> variable(var))
.field varInt8: variant (size: 8 @1804 -> variable(var))
.field varInt16: variant (size: 8 @1812 -> variable(var))
.field varInt32: variant (size: 8 @1820 -> variable(var))
.field varInt64: variant (size: 8 @1828 -> variable(var))
.field varUint8: variant (size: 8 @1836 -> variable(var))
.field varUint16: variant (size: 8 @1844 -> variable(var))
.field varUint32: variant (size: 8 @1852 -> variable(var))
.field varUint64: variant (size: 8 @1860 -> variable(var))
.field varFloat32: variant (size: 8 @1868 -> variable(var))
.field varFloat64: variant (size: 8 @1876 -> variable(var))
.field varTypename: variant (size: 8 @1884 -> variable(var))
.field varFunction: variant (size: 8 @1892 -> variable(var))
.field varPointer: variant (size: 8 @1900 -> variable(var))
.field varVariant: variant (size: 8 @1908 -> variable(var))
.field varObject: variant (size: 8 @1916 -> variable(var))
.field typVoid: typename (size: 4 @1920 -> variable(ref))
.field typBool: typename (size: 4 @1924 -> variable(ref))
.field typChar: typename (size: 4 @1928 -> variable(ref))
.field typInt8: typename (size: 4 @1932 -> variable(ref))
.field typInt16: typename (size: 4 @1936 -> variable(ref))
.field typInt32: typename (size: 4 @1940 -> variable(ref))
.field typInt64: typename (size: 4 @1944 -> variable(ref))
.field typUint8: typename (size: 4 @1948 -> variable(ref))
.field typUint16: typename (size: 4 @1952 -> variable(ref))
.field typUint32: typename (size: 4 @1956 -> variable(ref))
.field typUint64: typename (size: 4 @1960 -> variable(ref))
.field typFloat32: typename (size: 4 @1964 -> variable(ref))
.field typFloat64: typename (size: 4 @1968 -> variable(ref))
.field typTypename: typename (size: 4 @1972 -> variable(ref))
.field typFunction: typename (size: 4 @1976 -> variable(ref))
.field typPointer: typename (size: 4 @1980 -> variable(ref))
.field typVariant: typename (size: 4 @1984 -> variable(ref))
.field typObject: typename (size: 4 @1988 -> variable(ref))
.field valueOfPtr: pointer (size: 4 @1992 -> variable(ref))
.field valueOfVar: variant (size: 8 @2000 -> variable(var))
.field valueOfTyp: typename (size: 4 @2004 -> variable(ref))
.field typeOfValue: typename (size: 4 @2008 -> variable(ref))
.field copyPtrFloat64: variant (size: 8 @2016 -> variable(var))
.field copyVarFloat64: pointer (size: 4 @2020 -> variable(ref))
.field localNoInit: int64 (size: 8 @2028 -> variable(i64))
.field globalNoInit: int64 (size: 8 @146872 -> static variable(i64))
.field localInitValue: int64 (size: 8 @2036 -> variable(i64))
.field globalInitValue: int64 (size: 8 @146880 -> static variable(i64))
.field localInitLocal: int64 (size: 8 @2044 -> variable(i64))
.field globalInitLocal: int64 (size: 8 @146888 -> static variable(i64))
.field localInitGlobal: int64 (size: 8 @2052 -> variable(i64))
.field globalInitGlobal: int64 (size: 8 @146896 -> static variable(i64))
.field InitMember: typename (size: 16 @136776 -> static const typename(val))
.field pi64: float64 (size: 8 @2060 -> variable(f64))
.field e64: float64 (size: 8 @2068 -> variable(f64))
.field pi32: float32 (size: 4 @2072 -> variable(f32))
.field e32: float32 (size: 4 @2076 -> variable(f32))
.field rgb888: function (size: 0 @0 -> inline)
.field rgb565: function (size: 0 @0 -> inline)
.field r_comp: int32 (size: 4 @2080 -> variable(i32))
.field g_comp: int32 (size: 4 @2084 -> variable(i32))
.field b_comp: int32 (size: 4 @2088 -> variable(i32))
.field r5g6b5: int32 (size: 4 @2092 -> variable(i32))
.field r8g8b8: int32 (size: 4 @2096 -> variable(i32))
.field zxtR5: int32 (size: 4 @2100 -> variable(i32))
.field zxtG6: int32 (size: 4 @2104 -> variable(i32))
.field zxtB5: int32 (size: 4 @2108 -> variable(i32))
.field sxtR5: int32 (size: 4 @2112 -> variable(i32))
.field sxtG6: int32 (size: 4 @2116 -> variable(i32))
.field sxtB5: int32 (size: 4 @2120 -> variable(i32))
.field zxtR8: int32 (size: 4 @2124 -> variable(i32))
.field zxtG8: int32 (size: 4 @2128 -> variable(i32))
.field zxtB8: int32 (size: 4 @2132 -> variable(i32))
.field sxtR8: int32 (size: 4 @2136 -> variable(i32))
.field sxtG8: int32 (size: 4 @2140 -> variable(i32))
.field sxtB8: int32 (size: 4 @2144 -> variable(i32))
.field sinF64: float64 (size: 8 @2152 -> variable(f64))
.field cosF64: float64 (size: 8 @2160 -> variable(f64))
.field tanF64: float64 (size: 8 @2168 -> variable(f64))
.field logF64: float64 (size: 8 @2176 -> variable(f64))
.field expF64: float64 (size: 8 @2184 -> variable(f64))
.field powF64: float64 (size: 8 @2192 -> variable(f64))
.field sqrtF64: float64 (size: 8 @2200 -> variable(f64))
.field atanF64: float64 (size: 8 @2208 -> variable(f64))
.field sinF32: float32 (size: 4 @2212 -> variable(f32))
.field cosF32: float32 (size: 4 @2216 -> variable(f32))
.field tanF32: float32 (size: 4 @2220 -> variable(f32))
.field logF32: float32 (size: 4 @2224 -> variable(f32))
.field expF32: float32 (size: 4 @2228 -> variable(f32))
.field powF32: float32 (size: 4 @2232 -> variable(f32))
.field sqrtF32: float32 (size: 4 @2236 -> variable(f32))
.field atanF32: float32 (size: 4 @2240 -> variable(f32))
.field malloc: function (size: 0 @0 -> inline)
.field free: function (size: 0 @0 -> inline)
.field p1: pointer (size: 4 @2244 -> variable(ref))
.field p2: pointer (size: 4 @2248 -> variable(ref))
.field p3: pointer (size: 4 @2252 -> variable(ref))
.field p4: pointer (size: 4 @2256 -> variable(ref))
.field val1: int64 (size: 8 @2264 -> variable(i64))
.field val2: int64 (size: 8 @2272 -> variable(i64))
.field .main: function (size: 4786 @146912 -> static function)
.param .result: void (size: 0 @0 -> variable)
.value: {
	intGlobal	intConstant	{
		static if (typename(raise) == function) {
			trace(message: char[*], inspect: variant): void := raise(raise.verbose, message, inspect, raise.defTrace);
			trace(message: char[*]): void := raise(raise.verbose, message, null, raise.defTrace);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, message, inspect, raise.noTrace);
			debug(message: char[*]): void := raise(raise.debug, message, null, raise.noTrace);
			info(message: char[*], inspect: variant): void := raise(raise.info, message, inspect, raise.noTrace);
			info(message: char[*]): void := raise(raise.info, message, null, raise.noTrace);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, message, inspect, raise.noTrace);
			warn(message: char[*]): void := raise(raise.warn, message, null, raise.noTrace);
			error(message: char[*], inspect: variant): void := raise(raise.error, message, inspect, raise.defTrace);
			error(message: char[*]): void := raise(raise.error, message, null, raise.defTrace);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, message, inspect, raise.defTrace);
			abort(message: char[*]): void := raise(raise.abort, message, null, raise.defTrace);
			abort(): void := raise(raise.abort, "execution aborted!", null, raise.defTrace);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
		}
	}
	{
		integer: typename := int64;
		static if (0 == 0) {
			raise(raise.debug, "0 == 0", null, 1);
		}
		static if (0 != 0) {
			raise(raise.debug, "0 != 0", null, 2);
		}
		static if (0 == 0) {
			raise(raise.debug, "0 == 0", null, 3);
		}
		else {
			raise(raise.debug, "0 != 0", null, 4);
		}
		static if (0 != 0) {
			raise(raise.debug, "0 != 0", null, 5);
		}
		else {
			raise(raise.debug, "0 == 0", null, 6);
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(raise.debug, "t == 0", t, 7);
			}
			if (t != 0) {
				raise(raise.debug, "t != 0", t, 8);
			}
			if (t != 0) {
				raise(raise.debug, "t != 0", t, 9);
			}
			else {
				raise(raise.debug, "t == 0", t, 10);
			}
			if (t != 0) {
				raise(raise.debug, "t != 0", t, 11);
			}
			else {
				raise(raise.debug, "t == 0", t, 12);
			}
		}
		static if (typename(int64) == null) {
			abort("integer is not declared");
		}
		static if (typename(int64) != typename) {
			abort("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; i < 2; i := i + 1) {
			debug("for (int i = 0; i < 2; i += 1)", i);
		}
		forIdx: int32;
		for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1) {
			debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
		}
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := (b);
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		sum(a: int32, b: int32, c: int32): int32 := sum(sum(a, b), c);
		any(a: int32, b: int32, c: int32): int32 := any(any(a, b), c);
		min(a: int32, b: int32, c: int32): int32 := min(min(a, b), c);
		ma: int32 := 3;
		mb: int32 := 6;
		mc: int32 := 9;
		zeroVal: int32 := zero(2, 3);
		zeroVar: int32 := zero(ma, mb);
		zeroXpr: int32 := zero(ma + mb, mb + mc);
		lastVal: int32 := last(2, 3);
		lastVar: int32 := last(ma, mb);
		lastXpr: int32 := last(ma + mb, mb + mc);
		sum2Val: int32 := sum(3, 12);
		sum2Var: int32 := sum(ma, mb);
		sum2Xpr: int32 := sum(ma + mb, mb + mc);
		any2Val: int32 := any(3, 12);
		any2Var: int32 := any(ma, mb);
		any2Xpr: int32 := any(ma + mb, mb + mc);
		min2Val: int32 := min(3, 12);
		min2Var: int32 := min(ma, mb);
		min2Xpr: int32 := min(ma + mb, mb + mc);
		any3Val: int32 := any(3, 2, 6);
		any3Var: int32 := any(ma, mb, mc);
		any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma);
		min3Val: int32 := min(3, 2, 6);
		min3Var: int32 := min(ma, mb, mc);
		min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(0, 0);
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32);
		emitDivI32: int32 := emit(int32(10), int32(5), div.i32);
		emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin);
		sizeof(type: typename): int32 := type.size;
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		sizeofBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		sizeofBase2: int32 := typeofBase2.size;
		static const empty(): void := {
		}
;
		static const funAdd(x: int32, y: int32): int32 := {
			return .result := x + y;
		}
;
		funAddResult: int32 := funAdd(2, 7);
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(2, 8);
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(2, 6);
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(2, 7);
		static const funMul(x: int32, y: int32): int32 := {
			return .result := x * y;
		}
;
		static const fib(n: uint32): uint32 := {
			if (n <= (1)) {
				if (n <= (0)) {
					return .result := (0);
				}
				return .result := (1);
			}
			return .result := fib(n - (1)) + fib(n - (2));
		}
;
		fibonacci_13: uint32 := fib(13);
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !(chrB);
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !(i8B);
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !(u8B);
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !(i16B);
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !(u16B);
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !(i32B);
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !(u32B);
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !(i64B);
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !(u64B);
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !(f32B);
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !(f64B);
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := ptrA == ptrB;
		ptrCne: bool := ptrA != ptrB;
		static if (typename(int64) == null) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrSliceNoInit: int64[];
		arrPtrNoInit: int64[*];
		arrSliceInitNull: int64[] := null;
		arrPtrInitNull: int64[*] := null;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrPtrInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrPtrInitSlice: int64[*] := arrSliceInitFixed;
		arrPtrInitPtr: int64[*] := arrPtrInitFixed;
		arrSliceInitString: char[] := "string";
		arrPtrInitString: char[*] := "string";
		assert(arrFixedNoInit.length == 7);
		assert(arrSliceNoInit.length == (0), "This one might fail");
		assert(arrSliceInitNull.length == (0));
		assert(arrSliceInitSlice.length == arrSliceInitFixed.length);
		static if (typename(int64) == null) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static if (typename(int64) == null) {
			integer: typename := int32;
		}
		localNoInit: int64;
		static globalNoInit: int64;
		localInitValue: int64 := 42;
		static globalInitValue: int64 := 1024;
		localInitLocal: int64 := localInitValue;
		static globalInitLocal: int64 := localInitValue;
		localInitGlobal: int64 := globalInitValue;
		static globalInitGlobal: int64 := globalInitValue;
		static const InitMember: struct {
			intMember: int32;
			intMemberDef: int32 := 9;
			const intConstMember: int32;
			const intConstMemberDef: int32 := 42;
			static intGlobal: int32 := 0;
			static const intConstant: int32 := 0;
		};
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5);
		zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6);
		zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5);
		sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5);
		sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6);
		sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5);
		zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8);
		zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8);
		zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8);
		sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8);
		sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8);
		sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8);
		sinF64: float64 := float64.sin(pi64 / (2));
		cosF64: float64 := float64.cos(pi64 / (2));
		tanF64: float64 := float64.tan(pi64 / (4));
		logF64: float64 := float64.log(e64 * e64 * e64);
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(pi64 * pi64, 0.500000);
		sqrtF64: float64 := float64.sqrt(pi64 * pi64);
		atanF64: float64 := float64.atan2(pi64, 1.000000);
		sinF32: float32 := float32.sin(pi32 / (2));
		cosF32: float32 := float32.cos(pi32 / (2));
		tanF32: float32 := float32.tan(pi32 / (4));
		logF32: float32 := float32.log(e32 * e32 * e32);
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(pi32 * pi32, 0.500000);
		sqrtF32: float32 := float32.sqrt(pi32 * pi32);
		atanF32: float32 := float32.atan2(pi32, 1.000000);
		malloc(size: int32): pointer := pointer.alloc(null, size);
		free(data: pointer): pointer := pointer.alloc(data, 0);
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(p1, 0, 1024);
		pointer.copy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug("val1", val1);
		debug("val2", val2);
		pointer.copy(pointer(val2), pointer(val1), 8);
		pointer.fill(pointer(val1), 0, 8);
		debug("val1", val1);
		debug("val2", val2);
		assert(5 == 5, "5 != 5");
	}
}
.instructions: [4786 bytes @.023de0]
	// FIXME: incorrect initializer code generated for: `static int32 intGlobal = 0;`
	extras/Tests/lang.varInitByVal.ci:38: (4 bytes): intGlobal
	2a d8 3d 02                load.m32 .023dd8 ;InitMember.intGlobal
	// FIXME: incorrect initializer code generated for: `static const int32 intConstant = 0;`
	extras/Tests/lang.varInitByVal.ci:43: (4 bytes): intConstant
	2a dc 3d 02                load.m32 .023ddc ;InitMember.intConstant
	extras/Tests/lang.statementIf.ci:4: (29 bytes): raise(raise.debug, "0 == 0", null, 1);
	1b 03 00 00 00             load.c32 3
	1f 80 ce 00 00             load.ref .00ce80 ;"0 == 0"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 01 00 00 00             load.c32 1
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:12: (29 bytes): raise(raise.debug, "0 == 0", null, 3);
	1b 03 00 00 00             load.c32 3
	1f 80 ce 00 00             load.ref .00ce80 ;"0 == 0"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 03 00 00 00             load.c32 3
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:22: (29 bytes): raise(raise.debug, "0 == 0", null, 6);
	1b 03 00 00 00             load.c32 3
	1f 80 ce 00 00             load.ref .00ce80 ;"0 == 0"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 06 00 00 00             load.c32 6
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:26: (5 bytes): t: int32 := 0
	1b 00 00 00 00             load.c32 0
	extras/Tests/lang.statementIf.ci:28: (40 bytes): if (t == 0)
	12 00                      dup.x1 sp(0)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	06 20 00 00                jz +32
	extras/Tests/lang.statementIf.ci:29: (28 bytes): raise(raise.debug, "t == 0", t, 7);
	1b 03 00 00 00             load.c32 3
	1f 90 ce 00 00             load.ref .00ce90 ;"t == 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 07 00 00 00             load.c32 7
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:32: (40 bytes): if (t != 0)
	12 00                      dup.x1 sp(0)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	05 20 00 00                jnz +32
	extras/Tests/lang.statementIf.ci:33: (28 bytes): raise(raise.debug, "t != 0", t, 8);
	1b 03 00 00 00             load.c32 3
	1f 97 ce 00 00             load.ref .00ce97 ;"t != 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 08 00 00 00             load.c32 8
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:36: (72 bytes): if (t != 0)
	12 00                      dup.x1 sp(0)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	05 24 00 00                jnz +36
	extras/Tests/lang.statementIf.ci:37: (28 bytes): raise(raise.debug, "t != 0", t, 9);
	1b 03 00 00 00             load.c32 3
	1f 97 ce 00 00             load.ref .00ce97 ;"t != 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 09 00 00 00             load.c32 9
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	04 20 00 00                jmp +32
	extras/Tests/lang.statementIf.ci:40: (28 bytes): raise(raise.debug, "t == 0", t, 10);
	1b 03 00 00 00             load.c32 3
	1f 90 ce 00 00             load.ref .00ce90 ;"t == 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 0a 00 00 00             load.c32 10
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementIf.ci:43: (72 bytes): if (t != 0)
	12 00                      dup.x1 sp(0)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	05 24 00 00                jnz +36
	extras/Tests/lang.statementIf.ci:44: (28 bytes): raise(raise.debug, "t != 0", t, 11);
	1b 03 00 00 00             load.c32 3
	1f 97 ce 00 00             load.ref .00ce97 ;"t != 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 0b 00 00 00             load.c32 11
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	04 20 00 00                jmp +32
	extras/Tests/lang.statementIf.ci:47: (28 bytes): raise(raise.debug, "t == 0", t, 12);
	1b 03 00 00 00             load.c32 3
	1f 90 ce 00 00             load.ref .00ce90 ;"t == 0"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 0c 00 00 00             load.c32 12
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementFor.ci:3: (41 bytes): for ( ; ; )
	04 25 00 00                jmp +37
	extras/Tests/lang.statementFor.ci:4: (29 bytes): debug("for ( ; ; )");
	1b 03 00 00 00             load.c32 3
	1f 58 cf 00 00             load.ref .00cf58 ;"for ( ; ; )"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementFor.ci:5: (4 bytes): break;
	04 08 00 00                jmp +8
	:: (4 bytes)
	04 df ff ff                jmp -33
	extras/Tests/lang.statementFor.ci:8: (57 bytes): for (i: int32 := 0; i < 2; i := i + 1)
	1b 00 00 00 00             load.c32 0
	04 24 00 00                jmp +36
	extras/Tests/lang.statementFor.ci:9: (28 bytes): debug("for (int i = 0; i < 2; i += 1)", i);
	1b 03 00 00 00             load.c32 3
	1f 66 cf 00 00             load.ref .00cf66 ;"for (int i = 0; i < 2; i += 1)"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementFor.ci:8: (4 bytes): i := i + 1
	0b 01 00 00                inc.i32(+1)
	extras/Tests/lang.statementFor.ci:8: (12 bytes): i < 2
	12 00                      dup.x1 sp(0)
	1b 02 00 00 00             load.c32 2
	58                         clt.i32
	05 d8 ff ff                jnz -40
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.statementFor.ci:12: (5 bytes): forIdx: int32
	1b 00 00 00 00             load.c32 0
	extras/Tests/lang.statementFor.ci:13: (55 bytes): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	1b 00 00 00 00             load.c32 0
	15 01                      set.x1 sp(1)
	04 24 00 00                jmp +36
	extras/Tests/lang.statementFor.ci:14: (28 bytes): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	1b 03 00 00 00             load.c32 3
	1f 8c cf 00 00             load.ref .00cf8c ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	1f 70 03 00 00             load.ref .000370 ;int32
	11 0c 00 00                load.sp(+12)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.statementFor.ci:13: (4 bytes): forIdx := forIdx + 1
	0b 01 00 00                inc.i32(+1)
	extras/Tests/lang.statementFor.ci:13: (12 bytes): forIdx < 2
	12 00                      dup.x1 sp(0)
	1b 02 00 00 00             load.c32 2
	58                         clt.i32
	05 d8 ff ff                jnz -40
	extras/Tests/lang.inlineArgs.ci:13: (5 bytes): ma: int32 := 3
	1b 03 00 00 00             load.c32 3
	extras/Tests/lang.inlineArgs.ci:14: (5 bytes): mb: int32 := 6
	1b 06 00 00 00             load.c32 6
	extras/Tests/lang.inlineArgs.ci:15: (5 bytes): mc: int32 := 9
	1b 09 00 00 00             load.c32 9
	extras/Tests/lang.inlineArgs.ci:17: (5 bytes): zeroVal: int32 := zero(2, 3)
	1b 00 00 00 00             load.c32 0
	extras/Tests/lang.inlineArgs.ci:18: (5 bytes): zeroVar: int32 := zero(ma, mb)
	1b 00 00 00 00             load.c32 0
	extras/Tests/lang.inlineArgs.ci:19: (5 bytes): zeroXpr: int32 := zero(ma + mb, mb + mc)
	1b 00 00 00 00             load.c32 0
	extras/Tests/lang.inlineArgs.ci:21: (5 bytes): lastVal: int32 := last(2, 3)
	1b 03 00 00 00             load.c32 3
	extras/Tests/lang.inlineArgs.ci:22: (2 bytes): lastVar: int32 := last(ma, mb)
	12 05                      dup.x1 sp(5)
	extras/Tests/lang.inlineArgs.ci:23: (5 bytes): lastXpr: int32 := last(ma + mb, mb + mc)
	12 06                      dup.x1 sp(6)
	12 06                      dup.x1 sp(6)
	51                         add.i32
	extras/Tests/lang.inlineArgs.ci:25: (9 bytes): sum2Val: int32 := sum(3, 12)
	1b 03 00 00 00             load.c32 3
	0b 0c 00 00                inc.i32(+12)
	extras/Tests/lang.inlineArgs.ci:26: (5 bytes): sum2Var: int32 := sum(ma, mb)
	12 09                      dup.x1 sp(9)
	12 09                      dup.x1 sp(9)
	51                         add.i32
	extras/Tests/lang.inlineArgs.ci:27: (11 bytes): sum2Xpr: int32 := sum(ma + mb, mb + mc)
	12 0a                      dup.x1 sp(10)
	12 0a                      dup.x1 sp(10)
	51                         add.i32
	12 0a                      dup.x1 sp(10)
	12 0a                      dup.x1 sp(10)
	51                         add.i32
	51                         add.i32
	extras/Tests/lang.inlineArgs.ci:29: (24 bytes): any2Val: int32 := any(3, 12)
	1b 03 00 00 00             load.c32 3
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	1b 0c 00 00 00             load.c32 12
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:30: (18 bytes): any2Var: int32 := any(ma, mb)
	12 0c                      dup.x1 sp(12)
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 06 00 00                jmp +6
	12 0c                      dup.x1 sp(12)
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:31: (24 bytes): any2Xpr: int32 := any(ma + mb, mb + mc)
	12 0d                      dup.x1 sp(13)
	12 0d                      dup.x1 sp(13)
	51                         add.i32
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	12 0d                      dup.x1 sp(13)
	12 0d                      dup.x1 sp(13)
	51                         add.i32
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:33: (33 bytes): min2Val: int32 := min(3, 12)
	1b 03 00 00 00             load.c32 3
	1b 0c 00 00 00             load.c32 12
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.inlineArgs.ci:34: (27 bytes): min2Var: int32 := min(ma, mb)
	12 0f                      dup.x1 sp(15)
	12 0f                      dup.x1 sp(15)
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.inlineArgs.ci:35: (33 bytes): min2Xpr: int32 := min(ma + mb, mb + mc)
	12 10                      dup.x1 sp(16)
	12 10                      dup.x1 sp(16)
	51                         add.i32
	12 10                      dup.x1 sp(16)
	12 10                      dup.x1 sp(16)
	51                         add.i32
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.inlineArgs.ci:42: (43 bytes): any3Val: int32 := any(3, 2, 6)
	1b 03 00 00 00             load.c32 3
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	1b 02 00 00 00             load.c32 2
	15 01                      set.x1 sp(1)
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	1b 06 00 00 00             load.c32 6
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:43: (34 bytes): any3Var: int32 := any(ma, mb, mc)
	12 12                      dup.x1 sp(18)
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 06 00 00                jmp +6
	12 12                      dup.x1 sp(18)
	15 01                      set.x1 sp(1)
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 06 00 00                jmp +6
	12 11                      dup.x1 sp(17)
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:44: (43 bytes): any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma)
	12 13                      dup.x1 sp(19)
	12 13                      dup.x1 sp(19)
	51                         add.i32
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	12 13                      dup.x1 sp(19)
	12 13                      dup.x1 sp(19)
	51                         add.i32
	15 01                      set.x1 sp(1)
	12 00                      dup.x1 sp(0)
	06 0a 00 00                jz +10
	12 00                      dup.x1 sp(0)
	04 09 00 00                jmp +9
	12 12                      dup.x1 sp(18)
	12 15                      dup.x1 sp(21)
	51                         add.i32
	15 01                      set.x1 sp(1)
	extras/Tests/lang.inlineArgs.ci:46: (61 bytes): min3Val: int32 := min(3, 2, 6)
	1b 03 00 00 00             load.c32 3
	1b 02 00 00 00             load.c32 2
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	1b 06 00 00 00             load.c32 6
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.inlineArgs.ci:47: (52 bytes): min3Var: int32 := min(ma, mb, mc)
	12 15                      dup.x1 sp(21)
	12 15                      dup.x1 sp(21)
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	12 14                      dup.x1 sp(20)
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.inlineArgs.ci:48: (61 bytes): min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma)
	12 16                      dup.x1 sp(22)
	12 16                      dup.x1 sp(22)
	51                         add.i32
	12 16                      dup.x1 sp(22)
	12 16                      dup.x1 sp(22)
	51                         add.i32
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	12 15                      dup.x1 sp(21)
	12 18                      dup.x1 sp(24)
	51                         add.i32
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	58                         clt.i32
	06 0a 00 00                jz +10
	12 01                      dup.x1 sp(1)
	04 06 00 00                jmp +6
	12 00                      dup.x1 sp(0)
	15 02                      set.x1 sp(2)
	10 fc ff ff                inc.sp(-4)
	extras/Tests/test.inlineOverload.ci:9: (5 bytes): overload1: float32 := overload
	1d 00 00 80 3f             load.f32 1.000000
	extras/Tests/test.inlineOverload.ci:10: (5 bytes): overload2: float32 := overload()
	1d 00 00 00 40             load.f32 2.000000
	extras/Tests/test.inlineOverload.ci:11: (5 bytes): overload3: float32 := overload(0)
	1d 00 00 40 40             load.f32 3.000000
	extras/Tests/test.inlineOverload.ci:12: (5 bytes): overload4: float32 := overload(0.000000)
	1d 00 00 80 3f             load.f32 1.000000
	extras/Tests/test.inlineOverload.ci:13: (5 bytes): overload5: float32 := overload(0, 0)
	1d 00 00 a0 40             load.f32 5.000000
	extras/Tests/lang.inlineEmit.ci:3: (1 bytes): emitldz32: int32 := emit(load.z32)
	18                         load.z32
	extras/Tests/lang.inlineEmit.ci:4: (1 bytes): emitldz64: int64 := emit(load.z64)
	19                         load.z64
	extras/Tests/lang.inlineEmit.ci:6: (5 bytes): emitA: int32 := 42
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.inlineEmit.ci:7: (5 bytes): emitB: int32 := 96
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.inlineEmit.ci:9: (5 bytes): emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	51                         add.i32
	extras/Tests/lang.inlineEmit.ci:10: (11 bytes): emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	1b 0a 00 00 00             load.c32 10
	1b 05 00 00 00             load.c32 5
	54                         div.i32
	extras/Tests/lang.inlineEmit.ci:11: (24 bytes): emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin)
	1e 1f 85 eb 51 b8 1e 09 40 load.f64 3.140000
	1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	84                         div.f64
	8b                         f64.2f32
	01 15 00 00                nfc(21) ;float32.sin(x: float32): float32
	extras/Tests/lang.reflection.ci:5: (4 bytes): sizeofVoid: int32 := sizeof(void)
	2a b8 00 00                load.m32 .0000b8
	extras/Tests/lang.reflection.ci:6: (4 bytes): sizeofBool: int32 := sizeof(bool)
	2a 48 01 00                load.m32 .000148
	extras/Tests/lang.reflection.ci:7: (4 bytes): sizeofChar: int32 := sizeof(char)
	2a d8 01 00                load.m32 .0001d8
	extras/Tests/lang.reflection.ci:8: (4 bytes): sizeofInt8: int32 := sizeof(int8)
	2a 68 02 00                load.m32 .000268
	extras/Tests/lang.reflection.ci:9: (4 bytes): sizeofInt16: int32 := sizeof(int16)
	2a f8 02 00                load.m32 .0002f8
	extras/Tests/lang.reflection.ci:10: (4 bytes): sizeofInt32: int32 := sizeof(int32)
	2a 88 03 00                load.m32 .000388
	extras/Tests/lang.reflection.ci:11: (4 bytes): sizeofInt64: int32 := sizeof(int64)
	2a 18 04 00                load.m32 .000418
	extras/Tests/lang.reflection.ci:12: (4 bytes): sizeofUint8: int32 := sizeof(uint8)
	2a a8 04 00                load.m32 .0004a8
	extras/Tests/lang.reflection.ci:13: (4 bytes): sizeofUint16: int32 := sizeof(uint16)
	2a 38 05 00                load.m32 .000538
	extras/Tests/lang.reflection.ci:14: (4 bytes): sizeofUint32: int32 := sizeof(uint32)
	2a c8 05 00                load.m32 .0005c8
	extras/Tests/lang.reflection.ci:15: (4 bytes): sizeofUint64: int32 := sizeof(uint64)
	2a 58 06 00                load.m32 .000658
	extras/Tests/lang.reflection.ci:16: (4 bytes): sizeofFloat32: int32 := sizeof(float32)
	2a e8 06 00                load.m32 .0006e8
	extras/Tests/lang.reflection.ci:17: (4 bytes): sizeofFloat64: int32 := sizeof(float64)
	2a 78 07 00                load.m32 .000778
	extras/Tests/lang.reflection.ci:18: (4 bytes): sizeofPointer: int32 := sizeof(pointer)
	2a 08 08 00                load.m32 .000808
	extras/Tests/lang.reflection.ci:19: (4 bytes): sizeofVariant: int32 := sizeof(variant)
	2a 98 08 00                load.m32 .000898
	extras/Tests/lang.reflection.ci:20: (4 bytes): sizeofTypename: int32 := sizeof(typename)
	2a 20 00 00                load.m32 .000020 ;typename+24
	extras/Tests/lang.reflection.ci:21: (4 bytes): sizeofFunction: int32 := sizeof(function)
	2a 28 09 00                load.m32 .000928
	extras/Tests/lang.reflection.ci:22: (4 bytes): sizeofObject: int32 := sizeof(object)
	2a c0 09 00                load.m32 .0009c0
	extras/Tests/lang.reflection.ci:32: (5 bytes): typeofRecord: typename := RecordSizeofExt
	1f 68 2a 01 00             load.ref .012a68 ;RecordSizeofExt
	extras/Tests/lang.reflection.ci:33: (6 bytes): nameOfRecord: char[*] := typename.name(typeofRecord)
	12 00                      dup.x1 sp(0)
	01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	extras/Tests/lang.reflection.ci:34: (7 bytes): sizeOfRecord: int32 := sizeof(typeofRecord)
	12 01                      dup.x1 sp(1)
	0b 18 00 00                inc.i32(+24)
	22                         load.m32
	extras/Tests/lang.reflection.ci:35: (6 bytes): fileOfRecord: char[*] := typename.file(typeofRecord)
	12 02                      dup.x1 sp(2)
	01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	extras/Tests/lang.reflection.ci:36: (6 bytes): lineOfRecord: int32 := typename.line(typeofRecord)
	12 03                      dup.x1 sp(3)
	01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	extras/Tests/lang.reflection.ci:38: (6 bytes): typeofBase: typename := typename.base(typeofRecord)
	12 04                      dup.x1 sp(4)
	01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	extras/Tests/lang.reflection.ci:39: (6 bytes): nameOfBase: char[*] := typename.name(typeofBase)
	12 00                      dup.x1 sp(0)
	01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	extras/Tests/lang.reflection.ci:40: (7 bytes): sizeOfBase: int32 := sizeof(typeofBase)
	12 01                      dup.x1 sp(1)
	0b 18 00 00                inc.i32(+24)
	22                         load.m32
	extras/Tests/lang.reflection.ci:41: (6 bytes): fileOfBase: char[*] := typename.file(typeofBase)
	12 02                      dup.x1 sp(2)
	01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	extras/Tests/lang.reflection.ci:42: (6 bytes): lineOfBase: int32 := typename.line(typeofBase)
	12 03                      dup.x1 sp(3)
	01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	extras/Tests/lang.reflection.ci:44: (6 bytes): typeofBase1: typename := typename.base(typeofBase)
	12 04                      dup.x1 sp(4)
	01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	extras/Tests/lang.reflection.ci:45: (7 bytes): sizeofBase1: int32 := typeofBase1.size
	12 00                      dup.x1 sp(0)
	0b 18 00 00                inc.i32(+24)
	22                         load.m32
	extras/Tests/lang.reflection.ci:47: (6 bytes): typeofBase2: typename := typename.base(typeofBase1)
	12 01                      dup.x1 sp(1)
	01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	extras/Tests/lang.reflection.ci:48: (7 bytes): sizeofBase2: int32 := typeofBase2.size
	12 00                      dup.x1 sp(0)
	0b 18 00 00                inc.i32(+24)
	22                         load.m32
	extras/Tests/lang.function.ci:11: (25 bytes): funAddResult: int32 := funAdd(2, 7)
	1b 00 00 00 00             load.c32 0
	1b 02 00 00 00             load.c32 2
	1b 07 00 00 00             load.c32 7
	1f 41 3d 02 00             load.ref .023d41 ;funAdd(x: int32, y: int32): int32
	02                         call
	10 f8 ff ff                inc.sp(-8)
	extras/Tests/lang.function.ci:14: (5 bytes): funAddRef(x: int32, y: int32): int32 := funAdd
	1f 41 3d 02 00             load.ref .023d41 ;funAdd(x: int32, y: int32): int32
	extras/Tests/lang.function.ci:17: (22 bytes): funAddRefResult: int32 := funAddRef(2, 8)
	1b 00 00 00 00             load.c32 0
	1b 02 00 00 00             load.c32 2
	1b 08 00 00 00             load.c32 8
	12 03                      dup.x1 sp(3)
	02                         call
	10 f8 ff ff                inc.sp(-8)
	extras/Tests/lang.function.ci:20: (5 bytes): funMul(x: int32, y: int32): int32 := funMul
	1f 4a 3d 02 00             load.ref .023d4a ;funMul(x: int32, y: int32): int32
	extras/Tests/lang.function.ci:23: (22 bytes): funMulResult: int32 := funMul(2, 6)
	1b 00 00 00 00             load.c32 0
	1b 02 00 00 00             load.c32 2
	1b 06 00 00 00             load.c32 6
	12 03                      dup.x1 sp(3)
	02                         call
	10 f8 ff ff                inc.sp(-8)
	extras/Tests/lang.function.ci:26: (2 bytes): funMulRef(x: int32, y: int32): int32 := funMul
	12 01                      dup.x1 sp(1)
	extras/Tests/lang.function.ci:29: (22 bytes): funMulRefResult: int32 := funMulRef(2, 7)
	1b 00 00 00 00             load.c32 0
	1b 02 00 00 00             load.c32 2
	1b 07 00 00 00             load.c32 7
	12 03                      dup.x1 sp(3)
	02                         call
	10 f8 ff ff                inc.sp(-8)
	extras/Tests/lang.function.ci:48: (20 bytes): fibonacci_13: uint32 := fib(13)
	1b 00 00 00 00             load.c32 0
	1b 0d 00 00 00             load.c32 13
	1f 53 3d 02 00             load.ref .023d53 ;fib(n: uint32): uint32
	02                         call
	10 fc ff ff                inc.sp(-4)
	extras/Tests/lang.useOperator.ci:5: (5 bytes): shift: int32 := 2
	1b 02 00 00 00             load.c32 2
	extras/Tests/lang.useOperator.ci:7: (5 bytes): boolA: bool := true
	1b 01 00 00 00             load.c32 1
	extras/Tests/lang.useOperator.ci:8: (6 bytes): boolB: bool := !false
	1b 00 00 00 00             load.c32 0
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	11 04 00 00                load.sp(+4)
	20                         load.m8
	11 04 00 00                load.sp(+4)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	11 08 00 00                load.sp(+8)
	20                         load.m8
	11 08 00 00                load.sp(+8)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	11 0c 00 00                load.sp(+12)
	20                         load.m8
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:30: (5 bytes): chrA: char := 'a'
	1b 61 00 00 00             load.c32 97
	extras/Tests/lang.useOperator.ci:31: (5 bytes): chrB: char := 'b'
	1b 62 00 00 00             load.c32 98
	extras/Tests/lang.useOperator.ci:32: (6 bytes): chrPls: char := +chrB
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	34                         div.u32
	extras/Tests/lang.useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:43: (8 bytes): chrShl: char := (chrA) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	12 1a                      dup.x1 sp(26)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:44: (8 bytes): chrShr: char := (chrA) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	12 1b                      dup.x1 sp(27)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:45: (7 bytes): chrNot: bool := !(chrB)
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:53: (5 bytes): i8A: int8 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:54: (5 bytes): i8B: int8 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:55: (6 bytes): i8Pls: int8 := +i8B
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	54                         div.i32
	extras/Tests/lang.useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:66: (8 bytes): i8Shl: int8 := (i8A) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	12 30                      dup.x1 sp(48)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:67: (8 bytes): i8Shr: int8 := (i8A) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	12 31                      dup.x1 sp(49)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:68: (7 bytes): i8Not: bool := !(i8B)
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:76: (5 bytes): u8A: uint8 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:77: (5 bytes): u8B: uint8 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:78: (6 bytes): u8Pls: uint8 := +u8B
	11 00 00 00                load.sp(+0)
	20                         load.m8
	00                         nop
	extras/Tests/lang.useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	11 04 00 00                load.sp(+4)
	20                         load.m8
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	11 08 00 00                load.sp(+8)
	20                         load.m8
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	11 10 00 00                load.sp(+16)
	20                         load.m8
	11 10 00 00                load.sp(+16)
	20                         load.m8
	51                         add.i32
	extras/Tests/lang.useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	11 14 00 00                load.sp(+20)
	20                         load.m8
	11 14 00 00                load.sp(+20)
	20                         load.m8
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	11 18 00 00                load.sp(+24)
	20                         load.m8
	11 18 00 00                load.sp(+24)
	20                         load.m8
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	11 1c 00 00                load.sp(+28)
	20                         load.m8
	34                         div.u32
	extras/Tests/lang.useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	11 20 00 00                load.sp(+32)
	20                         load.m8
	11 20 00 00                load.sp(+32)
	20                         load.m8
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	11 24 00 00                load.sp(+36)
	20                         load.m8
	11 24 00 00                load.sp(+36)
	20                         load.m8
	31                         and.b32
	extras/Tests/lang.useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	11 28 00 00                load.sp(+40)
	20                         load.m8
	11 28 00 00                load.sp(+40)
	20                         load.m8
	32                         or.b32
	extras/Tests/lang.useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	11 2c 00 00                load.sp(+44)
	20                         load.m8
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:89: (8 bytes): u8Shl: uint8 := (u8A) << shift
	11 30 00 00                load.sp(+48)
	20                         load.m8
	12 46                      dup.x1 sp(70)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:90: (8 bytes): u8Shr: uint8 := (u8A) >> shift
	11 34 00 00                load.sp(+52)
	20                         load.m8
	12 47                      dup.x1 sp(71)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:91: (7 bytes): u8Not: bool := !(u8B)
	11 34 00 00                load.sp(+52)
	20                         load.m8
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	11 3c 00 00                load.sp(+60)
	20                         load.m8
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	11 40 00 00                load.sp(+64)
	20                         load.m8
	11 40 00 00                load.sp(+64)
	20                         load.m8
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	11 44 00 00                load.sp(+68)
	20                         load.m8
	11 44 00 00                load.sp(+68)
	20                         load.m8
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	11 48 00 00                load.sp(+72)
	20                         load.m8
	11 48 00 00                load.sp(+72)
	20                         load.m8
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	11 4c 00 00                load.sp(+76)
	20                         load.m8
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	11 50 00 00                load.sp(+80)
	20                         load.m8
	11 50 00 00                load.sp(+80)
	20                         load.m8
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:99: (5 bytes): i16A: int16 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:100: (5 bytes): i16B: int16 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:101: (6 bytes): i16Pls: int16 := +i16B
	11 00 00 00                load.sp(+0)
	21                         load.m16
	00                         nop
	extras/Tests/lang.useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	11 04 00 00                load.sp(+4)
	21                         load.m16
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	11 08 00 00                load.sp(+8)
	21                         load.m16
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	11 10 00 00                load.sp(+16)
	21                         load.m16
	11 10 00 00                load.sp(+16)
	21                         load.m16
	51                         add.i32
	extras/Tests/lang.useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	11 14 00 00                load.sp(+20)
	21                         load.m16
	11 14 00 00                load.sp(+20)
	21                         load.m16
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	11 18 00 00                load.sp(+24)
	21                         load.m16
	11 18 00 00                load.sp(+24)
	21                         load.m16
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	54                         div.i32
	extras/Tests/lang.useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	11 20 00 00                load.sp(+32)
	21                         load.m16
	11 20 00 00                load.sp(+32)
	21                         load.m16
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	11 24 00 00                load.sp(+36)
	21                         load.m16
	11 24 00 00                load.sp(+36)
	21                         load.m16
	31                         and.b32
	extras/Tests/lang.useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	11 28 00 00                load.sp(+40)
	21                         load.m16
	11 28 00 00                load.sp(+40)
	21                         load.m16
	32                         or.b32
	extras/Tests/lang.useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:112: (8 bytes): i16Shl: int16 := (i16A) << shift
	11 30 00 00                load.sp(+48)
	21                         load.m16
	12 5c                      dup.x1 sp(92)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:113: (8 bytes): i16Shr: int16 := (i16A) >> shift
	11 34 00 00                load.sp(+52)
	21                         load.m16
	12 5d                      dup.x1 sp(93)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:114: (7 bytes): i16Not: bool := !(i16B)
	11 34 00 00                load.sp(+52)
	21                         load.m16
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	11 40 00 00                load.sp(+64)
	21                         load.m16
	11 40 00 00                load.sp(+64)
	21                         load.m16
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	11 44 00 00                load.sp(+68)
	21                         load.m16
	11 44 00 00                load.sp(+68)
	21                         load.m16
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	11 48 00 00                load.sp(+72)
	21                         load.m16
	11 48 00 00                load.sp(+72)
	21                         load.m16
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	11 50 00 00                load.sp(+80)
	21                         load.m16
	11 50 00 00                load.sp(+80)
	21                         load.m16
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:122: (5 bytes): u16A: uint16 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:123: (5 bytes): u16B: uint16 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:124: (6 bytes): u16Pls: uint16 := +u16B
	11 00 00 00                load.sp(+0)
	21                         load.m16
	00                         nop
	extras/Tests/lang.useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	11 04 00 00                load.sp(+4)
	21                         load.m16
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	11 08 00 00                load.sp(+8)
	21                         load.m16
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	11 10 00 00                load.sp(+16)
	21                         load.m16
	11 10 00 00                load.sp(+16)
	21                         load.m16
	51                         add.i32
	extras/Tests/lang.useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	11 14 00 00                load.sp(+20)
	21                         load.m16
	11 14 00 00                load.sp(+20)
	21                         load.m16
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	11 18 00 00                load.sp(+24)
	21                         load.m16
	11 18 00 00                load.sp(+24)
	21                         load.m16
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	11 1c 00 00                load.sp(+28)
	21                         load.m16
	34                         div.u32
	extras/Tests/lang.useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	11 20 00 00                load.sp(+32)
	21                         load.m16
	11 20 00 00                load.sp(+32)
	21                         load.m16
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	11 24 00 00                load.sp(+36)
	21                         load.m16
	11 24 00 00                load.sp(+36)
	21                         load.m16
	31                         and.b32
	extras/Tests/lang.useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	11 28 00 00                load.sp(+40)
	21                         load.m16
	11 28 00 00                load.sp(+40)
	21                         load.m16
	32                         or.b32
	extras/Tests/lang.useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	11 2c 00 00                load.sp(+44)
	21                         load.m16
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:135: (8 bytes): u16Shl: uint16 := (u16A) << shift
	11 30 00 00                load.sp(+48)
	21                         load.m16
	12 72                      dup.x1 sp(114)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:136: (8 bytes): u16Shr: uint16 := (u16A) >> shift
	11 34 00 00                load.sp(+52)
	21                         load.m16
	12 73                      dup.x1 sp(115)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:137: (7 bytes): u16Not: bool := !(u16B)
	11 34 00 00                load.sp(+52)
	21                         load.m16
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	11 3c 00 00                load.sp(+60)
	21                         load.m16
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	11 40 00 00                load.sp(+64)
	21                         load.m16
	11 40 00 00                load.sp(+64)
	21                         load.m16
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	11 44 00 00                load.sp(+68)
	21                         load.m16
	11 44 00 00                load.sp(+68)
	21                         load.m16
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	11 48 00 00                load.sp(+72)
	21                         load.m16
	11 48 00 00                load.sp(+72)
	21                         load.m16
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	11 4c 00 00                load.sp(+76)
	21                         load.m16
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	11 50 00 00                load.sp(+80)
	21                         load.m16
	11 50 00 00                load.sp(+80)
	21                         load.m16
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:145: (5 bytes): i32A: int32 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:146: (5 bytes): i32B: int32 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:147: (3 bytes): i32Pls: int32 := +i32B
	12 00                      dup.x1 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:148: (3 bytes): i32Neg: int32 := -i32B
	12 01                      dup.x1 sp(1)
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:149: (3 bytes): i32Cmt: int32 := ~i32B
	12 02                      dup.x1 sp(2)
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:150: (5 bytes): i32Add: int32 := i32A + i32B
	12 04                      dup.x1 sp(4)
	12 04                      dup.x1 sp(4)
	51                         add.i32
	extras/Tests/lang.useOperator.ci:151: (5 bytes): i32Sub: int32 := i32A - i32B
	12 05                      dup.x1 sp(5)
	12 05                      dup.x1 sp(5)
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:152: (5 bytes): i32Mul: int32 := i32A * i32B
	12 06                      dup.x1 sp(6)
	12 06                      dup.x1 sp(6)
	53                         mul.i32
	extras/Tests/lang.useOperator.ci:153: (5 bytes): i32Div: int32 := i32A / i32B
	12 07                      dup.x1 sp(7)
	12 07                      dup.x1 sp(7)
	54                         div.i32
	extras/Tests/lang.useOperator.ci:154: (5 bytes): i32Mod: int32 := i32A % i32B
	12 08                      dup.x1 sp(8)
	12 08                      dup.x1 sp(8)
	55                         mod.i32
	extras/Tests/lang.useOperator.ci:155: (5 bytes): i32And: int32 := i32A & i32B
	12 09                      dup.x1 sp(9)
	12 09                      dup.x1 sp(9)
	31                         and.b32
	extras/Tests/lang.useOperator.ci:156: (5 bytes): i32Ior: int32 := i32A | i32B
	12 0a                      dup.x1 sp(10)
	12 0a                      dup.x1 sp(10)
	32                         or.b32
	extras/Tests/lang.useOperator.ci:157: (5 bytes): i32Xor: int32 := i32A ^ i32B
	12 0b                      dup.x1 sp(11)
	12 0b                      dup.x1 sp(11)
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:158: (5 bytes): i32Shl: int32 := i32A << shift
	12 0c                      dup.x1 sp(12)
	12 88                      dup.x1 sp(136)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:159: (5 bytes): i32Shr: int32 := i32A >> shift
	12 0d                      dup.x1 sp(13)
	12 89                      dup.x1 sp(137)
	3c                         sar.b32
	extras/Tests/lang.useOperator.ci:160: (4 bytes): i32Not: bool := !(i32B)
	12 0d                      dup.x1 sp(13)
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:161: (5 bytes): i32Ceq: bool := i32A == i32B
	12 0f                      dup.x1 sp(15)
	12 0f                      dup.x1 sp(15)
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:162: (6 bytes): i32Cne: bool := i32A != i32B
	12 10                      dup.x1 sp(16)
	12 10                      dup.x1 sp(16)
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:163: (5 bytes): i32Clt: bool := i32A < i32B
	12 11                      dup.x1 sp(17)
	12 11                      dup.x1 sp(17)
	58                         clt.i32
	extras/Tests/lang.useOperator.ci:164: (6 bytes): i32Cle: bool := i32A <= i32B
	12 12                      dup.x1 sp(18)
	12 12                      dup.x1 sp(18)
	59                         cgt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:165: (5 bytes): i32Cgt: bool := i32A > i32B
	12 13                      dup.x1 sp(19)
	12 13                      dup.x1 sp(19)
	59                         cgt.i32
	extras/Tests/lang.useOperator.ci:166: (6 bytes): i32Cge: bool := i32A >= i32B
	12 14                      dup.x1 sp(20)
	12 14                      dup.x1 sp(20)
	58                         clt.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:168: (5 bytes): u32A: uint32 := a
	1b 60 00 00 00             load.c32 96
	extras/Tests/lang.useOperator.ci:169: (5 bytes): u32B: uint32 := b
	1b 2a 00 00 00             load.c32 42
	extras/Tests/lang.useOperator.ci:170: (3 bytes): u32Pls: uint32 := +u32B
	12 00                      dup.x1 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:171: (3 bytes): u32Neg: uint32 := -u32B
	12 01                      dup.x1 sp(1)
	50                         neg.i32
	extras/Tests/lang.useOperator.ci:172: (3 bytes): u32Cmt: uint32 := ~u32B
	12 02                      dup.x1 sp(2)
	30                         cmt.b32
	extras/Tests/lang.useOperator.ci:173: (5 bytes): u32Add: uint32 := u32A + u32B
	12 04                      dup.x1 sp(4)
	12 04                      dup.x1 sp(4)
	51                         add.i32
	extras/Tests/lang.useOperator.ci:174: (5 bytes): u32Sub: uint32 := u32A - u32B
	12 05                      dup.x1 sp(5)
	12 05                      dup.x1 sp(5)
	52                         sub.i32
	extras/Tests/lang.useOperator.ci:175: (5 bytes): u32Mul: uint32 := u32A * u32B
	12 06                      dup.x1 sp(6)
	12 06                      dup.x1 sp(6)
	33                         mul.u32
	extras/Tests/lang.useOperator.ci:176: (5 bytes): u32Div: uint32 := u32A / u32B
	12 07                      dup.x1 sp(7)
	12 07                      dup.x1 sp(7)
	34                         div.u32
	extras/Tests/lang.useOperator.ci:177: (5 bytes): u32Mod: uint32 := u32A % u32B
	12 08                      dup.x1 sp(8)
	12 08                      dup.x1 sp(8)
	35                         mod.u32
	extras/Tests/lang.useOperator.ci:178: (5 bytes): u32And: uint32 := u32A & u32B
	12 09                      dup.x1 sp(9)
	12 09                      dup.x1 sp(9)
	31                         and.b32
	extras/Tests/lang.useOperator.ci:179: (5 bytes): u32Ior: uint32 := u32A | u32B
	12 0a                      dup.x1 sp(10)
	12 0a                      dup.x1 sp(10)
	32                         or.b32
	extras/Tests/lang.useOperator.ci:180: (5 bytes): u32Xor: uint32 := u32A ^ u32B
	12 0b                      dup.x1 sp(11)
	12 0b                      dup.x1 sp(11)
	36                         xor.b32
	extras/Tests/lang.useOperator.ci:181: (5 bytes): u32Shl: uint32 := u32A << shift
	12 0c                      dup.x1 sp(12)
	12 9e                      dup.x1 sp(158)
	3a                         shl.b32
	extras/Tests/lang.useOperator.ci:182: (5 bytes): u32Shr: uint32 := u32A >> shift
	12 0d                      dup.x1 sp(13)
	12 9f                      dup.x1 sp(159)
	3b                         shr.b32
	extras/Tests/lang.useOperator.ci:183: (4 bytes): u32Not: bool := !(u32B)
	12 0d                      dup.x1 sp(13)
	5a                         i32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:184: (5 bytes): u32Ceq: bool := u32A == u32B
	12 0f                      dup.x1 sp(15)
	12 0f                      dup.x1 sp(15)
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:185: (6 bytes): u32Cne: bool := u32A != u32B
	12 10                      dup.x1 sp(16)
	12 10                      dup.x1 sp(16)
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:186: (5 bytes): u32Clt: bool := u32A < u32B
	12 11                      dup.x1 sp(17)
	12 11                      dup.x1 sp(17)
	38                         clt.u32
	extras/Tests/lang.useOperator.ci:187: (6 bytes): u32Cle: bool := u32A <= u32B
	12 12                      dup.x1 sp(18)
	12 12                      dup.x1 sp(18)
	39                         cgt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:188: (5 bytes): u32Cgt: bool := u32A > u32B
	12 13                      dup.x1 sp(19)
	12 13                      dup.x1 sp(19)
	39                         cgt.u32
	extras/Tests/lang.useOperator.ci:189: (6 bytes): u32Cge: bool := u32A >= u32B
	12 14                      dup.x1 sp(20)
	12 14                      dup.x1 sp(20)
	38                         clt.u32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:191: (9 bytes): i64A: int64 := a
	1c 60 00 00 00 00 00 00 00 load.c64 96
	extras/Tests/lang.useOperator.ci:192: (9 bytes): i64B: int64 := b
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/lang.useOperator.ci:193: (3 bytes): i64Pls: int64 := +i64B
	13 00                      dup.x2 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:194: (3 bytes): i64Neg: int64 := -i64B
	13 02                      dup.x2 sp(2)
	60                         neg.i64
	extras/Tests/lang.useOperator.ci:195: (3 bytes): i64Cmt: int64 := ~i64B
	13 04                      dup.x2 sp(4)
	40                         cmt.b64
	extras/Tests/lang.useOperator.ci:196: (5 bytes): i64Add: int64 := i64A + i64B
	13 08                      dup.x2 sp(8)
	13 08                      dup.x2 sp(8)
	61                         add.i64
	extras/Tests/lang.useOperator.ci:197: (5 bytes): i64Sub: int64 := i64A - i64B
	13 0a                      dup.x2 sp(10)
	13 0a                      dup.x2 sp(10)
	62                         sub.i64
	extras/Tests/lang.useOperator.ci:198: (5 bytes): i64Mul: int64 := i64A * i64B
	13 0c                      dup.x2 sp(12)
	13 0c                      dup.x2 sp(12)
	63                         mul.i64
	extras/Tests/lang.useOperator.ci:199: (5 bytes): i64Div: int64 := i64A / i64B
	13 0e                      dup.x2 sp(14)
	13 0e                      dup.x2 sp(14)
	64                         div.i64
	extras/Tests/lang.useOperator.ci:200: (5 bytes): i64Mod: int64 := i64A % i64B
	13 10                      dup.x2 sp(16)
	13 10                      dup.x2 sp(16)
	65                         mod.i64
	extras/Tests/lang.useOperator.ci:201: (5 bytes): i64And: int64 := i64A & i64B
	13 12                      dup.x2 sp(18)
	13 12                      dup.x2 sp(18)
	41                         and.b64
	extras/Tests/lang.useOperator.ci:202: (5 bytes): i64Ior: int64 := i64A | i64B
	13 14                      dup.x2 sp(20)
	13 14                      dup.x2 sp(20)
	42                         or.b64
	extras/Tests/lang.useOperator.ci:203: (5 bytes): i64Xor: int64 := i64A ^ i64B
	13 16                      dup.x2 sp(22)
	13 16                      dup.x2 sp(22)
	46                         xor.b64
	extras/Tests/lang.useOperator.ci:204: (5 bytes): i64Shl: int64 := i64A << shift
	13 18                      dup.x2 sp(24)
	12 c2                      dup.x1 sp(194)
	4a                         shl.b64
	extras/Tests/lang.useOperator.ci:205: (5 bytes): i64Shr: int64 := i64A >> shift
	13 1a                      dup.x2 sp(26)
	12 c4                      dup.x1 sp(196)
	4c                         sar.b64
	extras/Tests/lang.useOperator.ci:206: (4 bytes): i64Not: bool := !(i64B)
	13 1a                      dup.x2 sp(26)
	6c                         i64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:207: (5 bytes): i64Ceq: bool := i64A == i64B
	13 1d                      dup.x2 sp(29)
	13 1d                      dup.x2 sp(29)
	67                         ceq.i64
	extras/Tests/lang.useOperator.ci:208: (6 bytes): i64Cne: bool := i64A != i64B
	13 1e                      dup.x2 sp(30)
	13 1e                      dup.x2 sp(30)
	67                         ceq.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:209: (5 bytes): i64Clt: bool := i64A < i64B
	13 1f                      dup.x2 sp(31)
	13 1f                      dup.x2 sp(31)
	68                         clt.i64
	extras/Tests/lang.useOperator.ci:210: (6 bytes): i64Cle: bool := i64A <= i64B
	13 20                      dup.x2 sp(32)
	13 20                      dup.x2 sp(32)
	69                         cgt.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:211: (5 bytes): i64Cgt: bool := i64A > i64B
	13 21                      dup.x2 sp(33)
	13 21                      dup.x2 sp(33)
	69                         cgt.i64
	extras/Tests/lang.useOperator.ci:212: (6 bytes): i64Cge: bool := i64A >= i64B
	13 22                      dup.x2 sp(34)
	13 22                      dup.x2 sp(34)
	68                         clt.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:214: (9 bytes): u64A: uint64 := a
	1c 60 00 00 00 00 00 00 00 load.c64 96
	extras/Tests/lang.useOperator.ci:215: (9 bytes): u64B: uint64 := b
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/lang.useOperator.ci:216: (3 bytes): u64Pls: uint64 := +u64B
	13 00                      dup.x2 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:217: (3 bytes): u64Neg: uint64 := -u64B
	13 02                      dup.x2 sp(2)
	60                         neg.i64
	extras/Tests/lang.useOperator.ci:218: (3 bytes): u64Cmt: uint64 := ~u64B
	13 04                      dup.x2 sp(4)
	40                         cmt.b64
	extras/Tests/lang.useOperator.ci:219: (5 bytes): u64Add: uint64 := u64A + u64B
	13 08                      dup.x2 sp(8)
	13 08                      dup.x2 sp(8)
	61                         add.i64
	extras/Tests/lang.useOperator.ci:220: (5 bytes): u64Sub: uint64 := u64A - u64B
	13 0a                      dup.x2 sp(10)
	13 0a                      dup.x2 sp(10)
	62                         sub.i64
	extras/Tests/lang.useOperator.ci:221: (5 bytes): u64Mul: uint64 := u64A * u64B
	13 0c                      dup.x2 sp(12)
	13 0c                      dup.x2 sp(12)
	43                         mul.u64
	extras/Tests/lang.useOperator.ci:222: (5 bytes): u64Div: uint64 := u64A / u64B
	13 0e                      dup.x2 sp(14)
	13 0e                      dup.x2 sp(14)
	44                         div.u64
	extras/Tests/lang.useOperator.ci:223: (5 bytes): u64Mod: uint64 := u64A % u64B
	13 10                      dup.x2 sp(16)
	13 10                      dup.x2 sp(16)
	45                         mod.u64
	extras/Tests/lang.useOperator.ci:224: (5 bytes): u64And: uint64 := u64A & u64B
	13 12                      dup.x2 sp(18)
	13 12                      dup.x2 sp(18)
	41                         and.b64
	extras/Tests/lang.useOperator.ci:225: (5 bytes): u64Ior: uint64 := u64A | u64B
	13 14                      dup.x2 sp(20)
	13 14                      dup.x2 sp(20)
	42                         or.b64
	extras/Tests/lang.useOperator.ci:226: (5 bytes): u64Xor: uint64 := u64A ^ u64B
	13 16                      dup.x2 sp(22)
	13 16                      dup.x2 sp(22)
	46                         xor.b64
	extras/Tests/lang.useOperator.ci:227: (5 bytes): u64Shl: uint64 := u64A << shift
	13 18                      dup.x2 sp(24)
	12 e7                      dup.x1 sp(231)
	4a                         shl.b64
	extras/Tests/lang.useOperator.ci:228: (5 bytes): u64Shr: uint64 := u64A >> shift
	13 1a                      dup.x2 sp(26)
	12 e9                      dup.x1 sp(233)
	4b                         shr.b64
	extras/Tests/lang.useOperator.ci:229: (4 bytes): u64Not: bool := !(u64B)
	13 1a                      dup.x2 sp(26)
	6c                         i64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:230: (5 bytes): u64Ceq: bool := u64A == u64B
	13 1d                      dup.x2 sp(29)
	13 1d                      dup.x2 sp(29)
	67                         ceq.i64
	extras/Tests/lang.useOperator.ci:231: (6 bytes): u64Cne: bool := u64A != u64B
	13 1e                      dup.x2 sp(30)
	13 1e                      dup.x2 sp(30)
	67                         ceq.i64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:232: (5 bytes): u64Clt: bool := u64A < u64B
	13 1f                      dup.x2 sp(31)
	13 1f                      dup.x2 sp(31)
	48                         clt.u64
	extras/Tests/lang.useOperator.ci:233: (6 bytes): u64Cle: bool := u64A <= u64B
	13 20                      dup.x2 sp(32)
	13 20                      dup.x2 sp(32)
	49                         cgt.u64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:234: (5 bytes): u64Cgt: bool := u64A > u64B
	13 21                      dup.x2 sp(33)
	13 21                      dup.x2 sp(33)
	49                         cgt.u64
	extras/Tests/lang.useOperator.ci:235: (6 bytes): u64Cge: bool := u64A >= u64B
	13 22                      dup.x2 sp(34)
	13 22                      dup.x2 sp(34)
	48                         clt.u64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:237: (5 bytes): f32A: float32 := a
	1d 9a 99 c0 42             load.f32 96.300003
	extras/Tests/lang.useOperator.ci:238: (5 bytes): f32B: float32 := b
	1d 5c 8f 28 42             load.f32 42.139999
	extras/Tests/lang.useOperator.ci:239: (3 bytes): f32Pls: float32 := +f32B
	12 00                      dup.x1 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:240: (3 bytes): f32Neg: float32 := -f32B
	12 01                      dup.x1 sp(1)
	70                         neg.f32
	extras/Tests/lang.useOperator.ci:242: (5 bytes): f32Add: float32 := f32A + f32B
	12 03                      dup.x1 sp(3)
	12 03                      dup.x1 sp(3)
	71                         add.f32
	extras/Tests/lang.useOperator.ci:243: (5 bytes): f32Sub: float32 := f32A - f32B
	12 04                      dup.x1 sp(4)
	12 04                      dup.x1 sp(4)
	72                         sub.f32
	extras/Tests/lang.useOperator.ci:244: (5 bytes): f32Mul: float32 := f32A * f32B
	12 05                      dup.x1 sp(5)
	12 05                      dup.x1 sp(5)
	73                         mul.f32
	extras/Tests/lang.useOperator.ci:245: (5 bytes): f32Div: float32 := f32A / f32B
	12 06                      dup.x1 sp(6)
	12 06                      dup.x1 sp(6)
	74                         div.f32
	extras/Tests/lang.useOperator.ci:246: (5 bytes): f32Mod: float32 := f32A % f32B
	12 07                      dup.x1 sp(7)
	12 07                      dup.x1 sp(7)
	75                         mod.f32
	extras/Tests/lang.useOperator.ci:252: (4 bytes): f32Not: bool := !(f32B)
	12 07                      dup.x1 sp(7)
	7b                         f32.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:253: (5 bytes): f32Ceq: bool := f32A == f32B
	12 09                      dup.x1 sp(9)
	12 09                      dup.x1 sp(9)
	77                         ceq.f32
	extras/Tests/lang.useOperator.ci:254: (6 bytes): f32Cne: bool := f32A != f32B
	12 0a                      dup.x1 sp(10)
	12 0a                      dup.x1 sp(10)
	77                         ceq.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:255: (5 bytes): f32Clt: bool := f32A < f32B
	12 0b                      dup.x1 sp(11)
	12 0b                      dup.x1 sp(11)
	78                         clt.f32
	extras/Tests/lang.useOperator.ci:256: (6 bytes): f32Cle: bool := f32A <= f32B
	12 0c                      dup.x1 sp(12)
	12 0c                      dup.x1 sp(12)
	79                         cgt.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:257: (5 bytes): f32Cgt: bool := f32A > f32B
	12 0d                      dup.x1 sp(13)
	12 0d                      dup.x1 sp(13)
	79                         cgt.f32
	extras/Tests/lang.useOperator.ci:258: (6 bytes): f32Cge: bool := f32A >= f32B
	12 0e                      dup.x1 sp(14)
	12 0e                      dup.x1 sp(14)
	78                         clt.f32
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:260: (9 bytes): f64A: float64 := a
	1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	extras/Tests/lang.useOperator.ci:261: (9 bytes): f64B: float64 := b
	1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	extras/Tests/lang.useOperator.ci:262: (3 bytes): f64Pls: float64 := +f64B
	13 00                      dup.x2 sp(0)
	00                         nop
	extras/Tests/lang.useOperator.ci:263: (3 bytes): f64Neg: float64 := -f64B
	13 02                      dup.x2 sp(2)
	80                         neg.f64
	extras/Tests/lang.useOperator.ci:265: (5 bytes): f64Add: float64 := f64A + f64B
	13 06                      dup.x2 sp(6)
	13 06                      dup.x2 sp(6)
	81                         add.f64
	extras/Tests/lang.useOperator.ci:266: (5 bytes): f64Sub: float64 := f64A - f64B
	13 08                      dup.x2 sp(8)
	13 08                      dup.x2 sp(8)
	82                         sub.f64
	extras/Tests/lang.useOperator.ci:267: (5 bytes): f64Mul: float64 := f64A * f64B
	13 0a                      dup.x2 sp(10)
	13 0a                      dup.x2 sp(10)
	83                         mul.f64
	extras/Tests/lang.useOperator.ci:268: (5 bytes): f64Div: float64 := f64A / f64B
	13 0c                      dup.x2 sp(12)
	13 0c                      dup.x2 sp(12)
	84                         div.f64
	extras/Tests/lang.useOperator.ci:269: (5 bytes): f64Mod: float64 := f64A % f64B
	13 0e                      dup.x2 sp(14)
	13 0e                      dup.x2 sp(14)
	85                         mod.f64
	extras/Tests/lang.useOperator.ci:275: (4 bytes): f64Not: bool := !(f64B)
	13 0e                      dup.x2 sp(14)
	8d                         f64.2bool
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:276: (5 bytes): f64Ceq: bool := f64A == f64B
	13 11                      dup.x2 sp(17)
	13 11                      dup.x2 sp(17)
	87                         ceq.f64
	extras/Tests/lang.useOperator.ci:277: (6 bytes): f64Cne: bool := f64A != f64B
	13 12                      dup.x2 sp(18)
	13 12                      dup.x2 sp(18)
	87                         ceq.f64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:278: (5 bytes): f64Clt: bool := f64A < f64B
	13 13                      dup.x2 sp(19)
	13 13                      dup.x2 sp(19)
	88                         clt.f64
	extras/Tests/lang.useOperator.ci:279: (6 bytes): f64Cle: bool := f64A <= f64B
	13 14                      dup.x2 sp(20)
	13 14                      dup.x2 sp(20)
	89                         cgt.f64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:280: (5 bytes): f64Cgt: bool := f64A > f64B
	13 15                      dup.x2 sp(21)
	13 15                      dup.x2 sp(21)
	89                         cgt.f64
	extras/Tests/lang.useOperator.ci:281: (6 bytes): f64Cge: bool := f64A >= f64B
	13 16                      dup.x2 sp(22)
	13 16                      dup.x2 sp(22)
	88                         clt.f64
	0a                         not.b32
	extras/Tests/lang.useOperator.ci:283: (5 bytes): ptrA: pointer := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.useOperator.ci:284: (4 bytes): ptrB: pointer := pointer(shift)
	11 68 04 00                load.sp(+1128)
	extras/Tests/lang.useOperator.ci:299: (5 bytes): ptrCeq: bool := ptrA == ptrB
	12 01                      dup.x1 sp(1)
	12 01                      dup.x1 sp(1)
	57                         ceq.i32
	extras/Tests/lang.useOperator.ci:300: (6 bytes): ptrCne: bool := ptrA != ptrB
	12 02                      dup.x1 sp(2)
	12 02                      dup.x1 sp(2)
	57                         ceq.i32
	0a                         not.b32
	extras/Tests/lang.varInitArray.ci:8: (4 bytes): arrFixedNoInit: int64[7]
	10 38 00 00                inc.sp(+56)
	extras/Tests/lang.varInitArray.ci:9: (4 bytes): arrSliceNoInit: int64[]
	10 08 00 00                inc.sp(+8)
	extras/Tests/lang.varInitArray.ci:10: (4 bytes): arrPtrNoInit: int64[*]
	10 04 00 00                inc.sp(+4)
	extras/Tests/lang.varInitArray.ci:13: (10 bytes): arrSliceInitNull: int64[] := null
	1b 00 00 00 00             load.c32 0
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitArray.ci:14: (5 bytes): arrPtrInitNull: int64[*] := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitArray.ci:17: (9 bytes): arrSliceInitFixed: int64[] := arrFixedNoInit
	1b 07 00 00 00             load.c32 7
	11 1c 00 00                load.sp(+28)
	extras/Tests/lang.varInitArray.ci:18: (4 bytes): arrPtrInitFixed: int64[*] := arrFixedNoInit
	11 20 00 00                load.sp(+32)
	extras/Tests/lang.varInitArray.ci:21: (2 bytes): arrSliceInitSlice: int64[] := arrSliceInitFixed
	13 01                      dup.x2 sp(1)
	extras/Tests/lang.varInitArray.ci:22: (4 bytes): arrPtrInitSlice: int64[*] := arrSliceInitFixed
	11 0c 00 00                load.sp(+12)
	extras/Tests/lang.varInitArray.ci:26: (2 bytes): arrPtrInitPtr: int64[*] := arrPtrInitFixed
	12 03                      dup.x1 sp(3)
	extras/Tests/lang.varInitArray.ci:37: (10 bytes): arrSliceInitString: char[] := "string"
	1b 06 00 00 00             load.c32 6
	1f d8 d0 01 00             load.ref .01d0d8 ;"string"
	extras/Tests/lang.varInitArray.ci:38: (5 bytes): arrPtrInitString: char[*] := "string"
	1f d8 d0 01 00             load.ref .01d0d8 ;"string"
	extras/Tests/lang.varInitArray.ci:47: (48 bytes): assert(arrFixedNoInit.length == 7);
	1b 07 00 00 00             load.c32 7
	1b 07 00 00 00             load.c32 7
	57                         ceq.i32
	06 08 00 00                jz +8
	04 21 00 00                jmp +33
	1b ff ff ff ff             load.c32 -1
	1f 9c a6 00 00             load.ref .00a69c ;"assertion failed!"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 80 00 00 00             load.c32 128
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.varInitArray.ci:48: (45 bytes): assert(arrSliceNoInit.length == (0), "This one might fail");
	12 0e                      dup.x1 sp(14)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	06 08 00 00                jz +8
	04 21 00 00                jmp +33
	1b ff ff ff ff             load.c32 -1
	1f f7 d0 01 00             load.ref .01d0f7 ;"This one might fail"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 80 00 00 00             load.c32 128
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.varInitArray.ci:50: (45 bytes): assert(arrSliceInitNull.length == (0));
	12 0b                      dup.x1 sp(11)
	1b 00 00 00 00             load.c32 0
	57                         ceq.i32
	06 08 00 00                jz +8
	04 21 00 00                jmp +33
	1b ff ff ff ff             load.c32 -1
	1f 9c a6 00 00             load.ref .00a69c ;"assertion failed!"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 80 00 00 00             load.c32 128
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.varInitArray.ci:51: (42 bytes): assert(arrSliceInitSlice.length == arrSliceInitFixed.length);
	12 05                      dup.x1 sp(5)
	12 09                      dup.x1 sp(9)
	57                         ceq.i32
	06 08 00 00                jz +8
	04 21 00 00                jmp +33
	1b ff ff ff ff             load.c32 -1
	1f 9c a6 00 00             load.ref .00a69c ;"assertion failed!"
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	1b 80 00 00 00             load.c32 128
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/lang.varInitByRef.ci:7: (13 bytes): static value: int64 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	2e b0 3d 02                store.m64 .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:8: (5 bytes): valueRef: int64 := value
	1f b0 3d 02 00             load.ref .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:9: (5 bytes): valuePtr: pointer := value
	1f b0 3d 02 00             load.ref .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:10: (10 bytes): valueVar: variant := value
	1f 00 04 00 00             load.ref .000400 ;int64
	1f b0 3d 02 00             load.ref .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:12: (3 bytes): fromRef: int64 := valueRef
	12 03                      dup.x1 sp(3)
	23                         load.m64
	extras/Tests/lang.varInitByRef.ci:13: (2 bytes): fromPtr: int64 := valuePtr
	12 04                      dup.x1 sp(4)
	extras/Tests/lang.varInitByRef.ci:14: (2 bytes): fromVar: int64 := valueVar
	12 03                      dup.x1 sp(3)
	extras/Tests/lang.varInitByRef.ci:16: (5 bytes): nullRef: int64 := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:17: (5 bytes): nullPtr: pointer := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:18: (10 bytes): nullVar: variant := null
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:19: (5 bytes): nullTyp: typename := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:20: (5 bytes): nullFun: function := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:21: (5 bytes): nullObj: object := null
	1f 00 00 00 00             load.ref .000000 ;null
	extras/Tests/lang.varInitByRef.ci:23: (5 bytes): typePtr: pointer := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:24: (10 bytes): typeVar: variant := int64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:25: (5 bytes): typeTyp: typename := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:27: (4 bytes): local: int64 := value
	2b b0 3d 02                load.m64 .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:28: (2 bytes): copyVal: int64 := local
	13 00                      dup.x2 sp(0)
	extras/Tests/lang.varInitByRef.ci:29: (2 bytes): copyRef: int64 := valueRef
	12 16                      dup.x1 sp(22)
	extras/Tests/lang.varInitByRef.ci:30: (2 bytes): copyPtr: pointer := valuePtr
	12 16                      dup.x1 sp(22)
	extras/Tests/lang.varInitByRef.ci:31: (2 bytes): copyVar: variant := valueVar
	13 15                      dup.x2 sp(21)
	extras/Tests/lang.varInitByRef.ci:32: (2 bytes): copyTyp: typename := typeTyp
	12 08                      dup.x1 sp(8)
	extras/Tests/lang.varInitByRef.ci:35: (5 bytes): ptrVoid: pointer := void
	1f a0 00 00 00             load.ref .0000a0 ;void
	extras/Tests/lang.varInitByRef.ci:36: (5 bytes): ptrBool: pointer := bool
	1f 30 01 00 00             load.ref .000130 ;bool
	extras/Tests/lang.varInitByRef.ci:37: (5 bytes): ptrChar: pointer := char
	1f c0 01 00 00             load.ref .0001c0 ;char
	extras/Tests/lang.varInitByRef.ci:38: (5 bytes): ptrInt8: pointer := int8
	1f 50 02 00 00             load.ref .000250 ;int8
	extras/Tests/lang.varInitByRef.ci:39: (5 bytes): ptrInt16: pointer := int16
	1f e0 02 00 00             load.ref .0002e0 ;int16
	extras/Tests/lang.varInitByRef.ci:40: (5 bytes): ptrInt32: pointer := int32
	1f 70 03 00 00             load.ref .000370 ;int32
	extras/Tests/lang.varInitByRef.ci:41: (5 bytes): ptrInt64: pointer := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:42: (5 bytes): ptrUint8: pointer := uint8
	1f 90 04 00 00             load.ref .000490 ;uint8
	extras/Tests/lang.varInitByRef.ci:43: (5 bytes): ptrUint16: pointer := uint16
	1f 20 05 00 00             load.ref .000520 ;uint16
	extras/Tests/lang.varInitByRef.ci:44: (5 bytes): ptrUint32: pointer := uint32
	1f b0 05 00 00             load.ref .0005b0 ;uint32
	extras/Tests/lang.varInitByRef.ci:45: (5 bytes): ptrUint64: pointer := uint64
	1f 40 06 00 00             load.ref .000640 ;uint64
	extras/Tests/lang.varInitByRef.ci:46: (5 bytes): ptrFloat32: pointer := float32
	1f d0 06 00 00             load.ref .0006d0 ;float32
	extras/Tests/lang.varInitByRef.ci:47: (5 bytes): ptrFloat64: pointer := float64
	1f 60 07 00 00             load.ref .000760 ;float64
	extras/Tests/lang.varInitByRef.ci:48: (5 bytes): ptrTypename: pointer := typename
	1f 08 00 00 00             load.ref .000008 ;typename
	extras/Tests/lang.varInitByRef.ci:49: (5 bytes): ptrFunction: pointer := function
	1f 10 09 00 00             load.ref .000910 ;function
	extras/Tests/lang.varInitByRef.ci:50: (5 bytes): ptrPointer: pointer := pointer
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	extras/Tests/lang.varInitByRef.ci:51: (5 bytes): ptrVariant: pointer := variant
	1f 80 08 00 00             load.ref .000880 ;variant
	extras/Tests/lang.varInitByRef.ci:52: (5 bytes): ptrObject: pointer := object
	1f a8 09 00 00             load.ref .0009a8 ;object
	extras/Tests/lang.varInitByRef.ci:55: (10 bytes): varVoid: variant := void
	1f 08 00 00 00             load.ref .000008 ;typename
	1f a0 00 00 00             load.ref .0000a0 ;void
	extras/Tests/lang.varInitByRef.ci:56: (10 bytes): varBool: variant := bool
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 30 01 00 00             load.ref .000130 ;bool
	extras/Tests/lang.varInitByRef.ci:57: (10 bytes): varChar: variant := char
	1f 08 00 00 00             load.ref .000008 ;typename
	1f c0 01 00 00             load.ref .0001c0 ;char
	extras/Tests/lang.varInitByRef.ci:58: (10 bytes): varInt8: variant := int8
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 50 02 00 00             load.ref .000250 ;int8
	extras/Tests/lang.varInitByRef.ci:59: (10 bytes): varInt16: variant := int16
	1f 08 00 00 00             load.ref .000008 ;typename
	1f e0 02 00 00             load.ref .0002e0 ;int16
	extras/Tests/lang.varInitByRef.ci:60: (10 bytes): varInt32: variant := int32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 70 03 00 00             load.ref .000370 ;int32
	extras/Tests/lang.varInitByRef.ci:61: (10 bytes): varInt64: variant := int64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:62: (10 bytes): varUint8: variant := uint8
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 90 04 00 00             load.ref .000490 ;uint8
	extras/Tests/lang.varInitByRef.ci:63: (10 bytes): varUint16: variant := uint16
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 20 05 00 00             load.ref .000520 ;uint16
	extras/Tests/lang.varInitByRef.ci:64: (10 bytes): varUint32: variant := uint32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f b0 05 00 00             load.ref .0005b0 ;uint32
	extras/Tests/lang.varInitByRef.ci:65: (10 bytes): varUint64: variant := uint64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 40 06 00 00             load.ref .000640 ;uint64
	extras/Tests/lang.varInitByRef.ci:66: (10 bytes): varFloat32: variant := float32
	1f 08 00 00 00             load.ref .000008 ;typename
	1f d0 06 00 00             load.ref .0006d0 ;float32
	extras/Tests/lang.varInitByRef.ci:67: (10 bytes): varFloat64: variant := float64
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 60 07 00 00             load.ref .000760 ;float64
	extras/Tests/lang.varInitByRef.ci:68: (10 bytes): varTypename: variant := typename
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 08 00 00 00             load.ref .000008 ;typename
	extras/Tests/lang.varInitByRef.ci:69: (10 bytes): varFunction: variant := function
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 10 09 00 00             load.ref .000910 ;function
	extras/Tests/lang.varInitByRef.ci:70: (10 bytes): varPointer: variant := pointer
	1f 08 00 00 00             load.ref .000008 ;typename
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	extras/Tests/lang.varInitByRef.ci:71: (10 bytes): varVariant: variant := variant
	1f 08 00 00 00             load.ref .000008 ;typename
	1f 80 08 00 00             load.ref .000880 ;variant
	extras/Tests/lang.varInitByRef.ci:72: (10 bytes): varObject: variant := object
	1f 08 00 00 00             load.ref .000008 ;typename
	1f a8 09 00 00             load.ref .0009a8 ;object
	extras/Tests/lang.varInitByRef.ci:75: (5 bytes): typVoid: typename := void
	1f a0 00 00 00             load.ref .0000a0 ;void
	extras/Tests/lang.varInitByRef.ci:76: (5 bytes): typBool: typename := bool
	1f 30 01 00 00             load.ref .000130 ;bool
	extras/Tests/lang.varInitByRef.ci:77: (5 bytes): typChar: typename := char
	1f c0 01 00 00             load.ref .0001c0 ;char
	extras/Tests/lang.varInitByRef.ci:78: (5 bytes): typInt8: typename := int8
	1f 50 02 00 00             load.ref .000250 ;int8
	extras/Tests/lang.varInitByRef.ci:79: (5 bytes): typInt16: typename := int16
	1f e0 02 00 00             load.ref .0002e0 ;int16
	extras/Tests/lang.varInitByRef.ci:80: (5 bytes): typInt32: typename := int32
	1f 70 03 00 00             load.ref .000370 ;int32
	extras/Tests/lang.varInitByRef.ci:81: (5 bytes): typInt64: typename := int64
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:82: (5 bytes): typUint8: typename := uint8
	1f 90 04 00 00             load.ref .000490 ;uint8
	extras/Tests/lang.varInitByRef.ci:83: (5 bytes): typUint16: typename := uint16
	1f 20 05 00 00             load.ref .000520 ;uint16
	extras/Tests/lang.varInitByRef.ci:84: (5 bytes): typUint32: typename := uint32
	1f b0 05 00 00             load.ref .0005b0 ;uint32
	extras/Tests/lang.varInitByRef.ci:85: (5 bytes): typUint64: typename := uint64
	1f 40 06 00 00             load.ref .000640 ;uint64
	extras/Tests/lang.varInitByRef.ci:86: (5 bytes): typFloat32: typename := float32
	1f d0 06 00 00             load.ref .0006d0 ;float32
	extras/Tests/lang.varInitByRef.ci:87: (5 bytes): typFloat64: typename := float64
	1f 60 07 00 00             load.ref .000760 ;float64
	extras/Tests/lang.varInitByRef.ci:88: (5 bytes): typTypename: typename := typename
	1f 08 00 00 00             load.ref .000008 ;typename
	extras/Tests/lang.varInitByRef.ci:89: (5 bytes): typFunction: typename := function
	1f 10 09 00 00             load.ref .000910 ;function
	extras/Tests/lang.varInitByRef.ci:90: (5 bytes): typPointer: typename := pointer
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	extras/Tests/lang.varInitByRef.ci:91: (5 bytes): typVariant: typename := variant
	1f 80 08 00 00             load.ref .000880 ;variant
	extras/Tests/lang.varInitByRef.ci:92: (5 bytes): typObject: typename := object
	1f a8 09 00 00             load.ref .0009a8 ;object
	extras/Tests/lang.varInitByRef.ci:95: (5 bytes): valueOfPtr: pointer := pointer(value)
	1f b0 3d 02 00             load.ref .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:96: (10 bytes): valueOfVar: variant := variant(value)
	1f 00 04 00 00             load.ref .000400 ;int64
	1f b0 3d 02 00             load.ref .023db0 ;value
	extras/Tests/lang.varInitByRef.ci:97: (5 bytes): valueOfTyp: typename := typename(value)
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:99: (5 bytes): typeOfValue: typename := typename(value)
	1f 00 04 00 00             load.ref .000400 ;int64
	extras/Tests/lang.varInitByRef.ci:105: (7 bytes): copyPtrFloat64: variant := ptrFloat64
	1f f0 07 00 00             load.ref .0007f0 ;pointer
	12 41                      dup.x1 sp(65)
	extras/Tests/lang.varInitByRef.ci:108: (2 bytes): copyVarFloat64: pointer := varFloat64
	12 23                      dup.x1 sp(35)
	extras/Tests/lang.varInitByVal.ci:7: (9 bytes): localNoInit: int64
	1c 00 00 00 00 00 00 00 00 load.c64 0
	extras/Tests/lang.varInitByVal.ci:8: (13 bytes): static globalNoInit: int64
	1c 00 00 00 00 00 00 00 00 load.c64 0
	2e b8 3d 02                store.m64 .023db8 ;globalNoInit
	extras/Tests/lang.varInitByVal.ci:9: (9 bytes): localInitValue: int64 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/lang.varInitByVal.ci:10: (13 bytes): static globalInitValue: int64 := 1024
	1c 00 04 00 00 00 00 00 00 load.c64 1024
	2e c0 3d 02                store.m64 .023dc0 ;globalInitValue
	extras/Tests/lang.varInitByVal.ci:11: (2 bytes): localInitLocal: int64 := localInitValue
	13 00                      dup.x2 sp(0)
	extras/Tests/lang.varInitByVal.ci:12: (6 bytes): static globalInitLocal: int64 := localInitValue
	13 02                      dup.x2 sp(2)
	2e c8 3d 02                store.m64 .023dc8 ;globalInitLocal
	extras/Tests/lang.varInitByVal.ci:13: (4 bytes): localInitGlobal: int64 := globalInitValue
	2b c0 3d 02                load.m64 .023dc0 ;globalInitValue
	extras/Tests/lang.varInitByVal.ci:14: (8 bytes): static globalInitGlobal: int64 := globalInitValue
	2b c0 3d 02                load.m64 .023dc0 ;globalInitValue
	2e d0 3d 02                store.m64 .023dd0 ;globalInitGlobal
	extras/Tests/stdc.nfcNumber.ci:3: (9 bytes): pi64: float64 := 3.141593
	1e 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	extras/Tests/stdc.nfcNumber.ci:4: (9 bytes): e64: float64 := 2.718282
	1e 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	extras/Tests/stdc.nfcNumber.ci:6: (3 bytes): pi32: float32 := pi64
	13 02                      dup.x2 sp(2)
	8b                         f64.2f32
	extras/Tests/stdc.nfcNumber.ci:7: (3 bytes): e32: float32 := e64
	13 01                      dup.x2 sp(1)
	8b                         f64.2f32
	extras/Tests/stdc.nfcNumber.ci:14: (7 bytes): r_comp: int32 := 14 << 3
	1b 0e 00 00 00             load.c32 14
	3f 43                      b32.shl 0x003
	extras/Tests/stdc.nfcNumber.ci:15: (7 bytes): g_comp: int32 := 63 << 2
	1b 3f 00 00 00             load.c32 63
	3f 42                      b32.shl 0x002
	extras/Tests/stdc.nfcNumber.ci:16: (7 bytes): b_comp: int32 := 31 << 3
	1b 1f 00 00 00             load.c32 31
	3f 43                      b32.shl 0x003
	extras/Tests/stdc.nfcNumber.ci:18: (28 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	12 02                      dup.x1 sp(2)
	3f 48                      b32.shl 0x008
	1b 00 f8 00 00             load.c32 63488
	31                         and.b32
	12 02                      dup.x1 sp(2)
	3f 43                      b32.shl 0x003
	1b e0 07 00 00             load.c32 2016
	31                         and.b32
	32                         or.b32
	12 01                      dup.x1 sp(1)
	3f c3                      b32.sar 0x003
	3f 05                      b32.and 0x01f
	32                         or.b32
	extras/Tests/stdc.nfcNumber.ci:19: (26 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	12 03                      dup.x1 sp(3)
	3f 50                      b32.shl 0x010
	1b 00 00 ff 00             load.c32 16711680
	31                         and.b32
	12 03                      dup.x1 sp(3)
	3f 48                      b32.shl 0x008
	1b 00 ff 00 00             load.c32 65280
	31                         and.b32
	32                         or.b32
	12 02                      dup.x1 sp(2)
	3f 08                      b32.and 0x0ff
	32                         or.b32
	extras/Tests/stdc.nfcNumber.ci:21: (16 bytes): zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	12 01                      dup.x1 sp(1)
	1b 0b 00 00 00             load.c32 11
	1b 05 00 00 00             load.c32 5
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:22: (16 bytes): zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	12 02                      dup.x1 sp(2)
	1b 05 00 00 00             load.c32 5
	1b 06 00 00 00             load.c32 6
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:23: (16 bytes): zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	12 03                      dup.x1 sp(3)
	1b 00 00 00 00             load.c32 0
	1b 05 00 00 00             load.c32 5
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:25: (16 bytes): sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	12 04                      dup.x1 sp(4)
	1b 0b 00 00 00             load.c32 11
	1b 05 00 00 00             load.c32 5
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:26: (16 bytes): sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	12 05                      dup.x1 sp(5)
	1b 05 00 00 00             load.c32 5
	1b 06 00 00 00             load.c32 6
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:27: (16 bytes): sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	12 06                      dup.x1 sp(6)
	1b 00 00 00 00             load.c32 0
	1b 05 00 00 00             load.c32 5
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:29: (16 bytes): zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	12 06                      dup.x1 sp(6)
	1b 10 00 00 00             load.c32 16
	1b 08 00 00 00             load.c32 8
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:30: (16 bytes): zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	12 07                      dup.x1 sp(7)
	1b 08 00 00 00             load.c32 8
	1b 08 00 00 00             load.c32 8
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:31: (16 bytes): zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	12 08                      dup.x1 sp(8)
	1b 00 00 00 00             load.c32 0
	1b 08 00 00 00             load.c32 8
	01 11 00 00                nfc(17) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:33: (16 bytes): sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	12 09                      dup.x1 sp(9)
	1b 10 00 00 00             load.c32 16
	1b 08 00 00 00             load.c32 8
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:34: (16 bytes): sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	12 0a                      dup.x1 sp(10)
	1b 08 00 00 00             load.c32 8
	1b 08 00 00 00             load.c32 8
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:35: (16 bytes): sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	12 0b                      dup.x1 sp(11)
	1b 00 00 00 00             load.c32 0
	1b 08 00 00 00             load.c32 8
	01 12 00 00                nfc(18) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	extras/Tests/stdc.nfcNumber.ci:37: (16 bytes): sinF64: float64 := float64.sin(pi64 / (2))
	13 15                      dup.x2 sp(21)
	1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	84                         div.f64
	01 1d 00 00                nfc(29) ;float64.sin(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:38: (16 bytes): cosF64: float64 := float64.cos(pi64 / (2))
	13 17                      dup.x2 sp(23)
	1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	84                         div.f64
	01 1e 00 00                nfc(30) ;float64.cos(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:39: (16 bytes): tanF64: float64 := float64.tan(pi64 / (4))
	13 19                      dup.x2 sp(25)
	1e 00 00 00 00 00 00 10 40 load.f64 4.000000
	84                         div.f64
	01 1f 00 00                nfc(31) ;float64.tan(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:40: (12 bytes): logF64: float64 := float64.log(e64 * e64 * e64)
	13 19                      dup.x2 sp(25)
	13 1b                      dup.x2 sp(27)
	83                         mul.f64
	13 1b                      dup.x2 sp(27)
	83                         mul.f64
	01 20 00 00                nfc(32) ;float64.log(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:41: (13 bytes): expF64: float64 := float64.exp(1.000000)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	01 21 00 00                nfc(33) ;float64.exp(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:42: (18 bytes): powF64: float64 := float64.pow(pi64 * pi64, 0.500000)
	13 1f                      dup.x2 sp(31)
	13 21                      dup.x2 sp(33)
	83                         mul.f64
	1e 00 00 00 00 00 00 e0 3f load.f64 0.500000
	01 22 00 00                nfc(34) ;float64.pow(x: float64, y: float64): float64
	extras/Tests/stdc.nfcNumber.ci:43: (9 bytes): sqrtF64: float64 := float64.sqrt(pi64 * pi64)
	13 21                      dup.x2 sp(33)
	13 23                      dup.x2 sp(35)
	83                         mul.f64
	01 23 00 00                nfc(35) ;float64.sqrt(x: float64): float64
	extras/Tests/stdc.nfcNumber.ci:44: (15 bytes): atanF64: float64 := float64.atan2(pi64, 1.000000)
	13 23                      dup.x2 sp(35)
	1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	01 24 00 00                nfc(36) ;float64.atan2(x: float64, y: float64): float64
	extras/Tests/stdc.nfcNumber.ci:46: (12 bytes): sinF32: float32 := float32.sin(pi32 / (2))
	12 22                      dup.x1 sp(34)
	1d 00 00 00 40             load.f32 2.000000
	74                         div.f32
	01 15 00 00                nfc(21) ;float32.sin(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:47: (12 bytes): cosF32: float32 := float32.cos(pi32 / (2))
	12 23                      dup.x1 sp(35)
	1d 00 00 00 40             load.f32 2.000000
	74                         div.f32
	01 16 00 00                nfc(22) ;float32.cos(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:48: (12 bytes): tanF32: float32 := float32.tan(pi32 / (4))
	12 24                      dup.x1 sp(36)
	1d 00 00 80 40             load.f32 4.000000
	74                         div.f32
	01 17 00 00                nfc(23) ;float32.tan(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:49: (12 bytes): logF32: float32 := float32.log(e32 * e32 * e32)
	12 24                      dup.x1 sp(36)
	12 25                      dup.x1 sp(37)
	73                         mul.f32
	12 25                      dup.x1 sp(37)
	73                         mul.f32
	01 18 00 00                nfc(24) ;float32.log(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:50: (9 bytes): expF32: float32 := float32.exp(1.000000)
	1d 00 00 80 3f             load.f32 1.000000
	01 19 00 00                nfc(25) ;float32.exp(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:51: (14 bytes): powF32: float32 := float32.pow(pi32 * pi32, 0.500000)
	12 27                      dup.x1 sp(39)
	12 28                      dup.x1 sp(40)
	73                         mul.f32
	1d 00 00 00 3f             load.f32 0.500000
	01 1a 00 00                nfc(26) ;float32.pow(x: float32, y: float32): float32
	extras/Tests/stdc.nfcNumber.ci:52: (9 bytes): sqrtF32: float32 := float32.sqrt(pi32 * pi32)
	12 28                      dup.x1 sp(40)
	12 29                      dup.x1 sp(41)
	73                         mul.f32
	01 1b 00 00                nfc(27) ;float32.sqrt(x: float32): float32
	extras/Tests/stdc.nfcNumber.ci:53: (11 bytes): atanF32: float32 := float32.atan2(pi32, 1.000000)
	12 29                      dup.x1 sp(41)
	1d 00 00 80 3f             load.f32 1.000000
	01 1c 00 00                nfc(28) ;float32.atan2(x: float32, y: float32): float32
	extras/Tests/stdc.nfcMemory.ci:6: (14 bytes): p1: pointer := malloc(1024)
	1f 00 00 00 00             load.ref .000000 ;null
	1b 00 04 00 00             load.c32 1024
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:7: (14 bytes): p2: pointer := malloc(80)
	1f 00 00 00 00             load.ref .000000 ;null
	1b 50 00 00 00             load.c32 80
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:8: (14 bytes): p3: pointer := malloc(160)
	1f 00 00 00 00             load.ref .000000 ;null
	1b a0 00 00 00             load.c32 160
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:9: (14 bytes): p4: pointer := malloc(820)
	1f 00 00 00 00             load.ref .000000 ;null
	1b 34 03 00 00             load.c32 820
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	extras/Tests/stdc.nfcMemory.ci:12: (20 bytes): pointer.fill(p1, 0, 1024);
	12 03                      dup.x1 sp(3)
	1b 00 00 00 00             load.c32 0
	1b 00 04 00 00             load.c32 1024
	01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:13: (17 bytes): pointer.copy(p1, p3, 160);
	12 03                      dup.x1 sp(3)
	12 02                      dup.x1 sp(2)
	1b a0 00 00 00             load.c32 160
	01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:16: (15 bytes): free(p1);
	12 03                      dup.x1 sp(3)
	1b 00 00 00 00             load.c32 0
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:17: (15 bytes): free(p2);
	12 02                      dup.x1 sp(2)
	1b 00 00 00 00             load.c32 0
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:18: (15 bytes): free(p3);
	12 01                      dup.x1 sp(1)
	1b 00 00 00 00             load.c32 0
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:19: (15 bytes): free(p4);
	12 00                      dup.x1 sp(0)
	1b 00 00 00 00             load.c32 0
	01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:22: (9 bytes): val1: int64 := 42
	1c 2a 00 00 00 00 00 00 00 load.c64 42
	extras/Tests/stdc.nfcMemory.ci:23: (9 bytes): val2: int64 := 96
	1c 60 00 00 00 00 00 00 00 load.c64 96
	extras/Tests/stdc.nfcMemory.ci:25: (28 bytes): debug("val1", val1);
	1b 03 00 00 00             load.c32 3
	1f 15 34 02 00             load.ref .023415 ;"val1"
	1f 00 04 00 00             load.ref .000400 ;int64
	11 14 00 00                load.sp(+20)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:26: (28 bytes): debug("val2", val2);
	1b 03 00 00 00             load.c32 3
	1f 1a 34 02 00             load.ref .02341a ;"val2"
	1f 00 04 00 00             load.ref .000400 ;int64
	11 0c 00 00                load.sp(+12)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:28: (21 bytes): pointer.copy(pointer(val2), pointer(val1), 8);
	11 00 00 00                load.sp(+0)
	11 0c 00 00                load.sp(+12)
	1b 08 00 00 00             load.c32 8
	01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:29: (22 bytes): pointer.fill(pointer(val1), 0, 8);
	11 08 00 00                load.sp(+8)
	1b 00 00 00 00             load.c32 0
	1b 08 00 00 00             load.c32 8
	01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	10 fc ff ff                inc.sp(-4)
	extras/Tests/stdc.nfcMemory.ci:31: (28 bytes): debug("val1", val1);
	1b 03 00 00 00             load.c32 3
	1f 15 34 02 00             load.ref .023415 ;"val1"
	1f 00 04 00 00             load.ref .000400 ;int64
	11 14 00 00                load.sp(+20)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	extras/Tests/stdc.nfcMemory.ci:32: (28 bytes): debug("val2", val2);
	1b 03 00 00 00             load.c32 3
	1f 1a 34 02 00             load.ref .02341a ;"val2"
	1f 00 04 00 00             load.ref .000400 ;int64
	11 0c 00 00                load.sp(+12)
	1b 00 00 00 00             load.c32 0
	01 05 00 00                nfc(5) ;raise(level: int32, message: char[*], inspect: variant, maxTrace: int32): void
	01 00 00 00                nfc(0) ;halt(): void
}

/*-- Globals:
extras/Tests/lang.statementIf.ci:26: t: int32(0)
extras/Tests/lang.statementFor.ci:12: forIdx: int32(2)
extras/Tests/lang.inlineArgs.ci:13: ma: int32(3)
extras/Tests/lang.inlineArgs.ci:14: mb: int32(6)
extras/Tests/lang.inlineArgs.ci:15: mc: int32(9)
extras/Tests/lang.inlineArgs.ci:17: zeroVal: int32(0)
extras/Tests/lang.inlineArgs.ci:18: zeroVar: int32(0)
extras/Tests/lang.inlineArgs.ci:19: zeroXpr: int32(0)
extras/Tests/lang.inlineArgs.ci:21: lastVal: int32(3)
extras/Tests/lang.inlineArgs.ci:22: lastVar: int32(6)
extras/Tests/lang.inlineArgs.ci:23: lastXpr: int32(15)
extras/Tests/lang.inlineArgs.ci:25: sum2Val: int32(15)
extras/Tests/lang.inlineArgs.ci:26: sum2Var: int32(9)
extras/Tests/lang.inlineArgs.ci:27: sum2Xpr: int32(24)
extras/Tests/lang.inlineArgs.ci:29: any2Val: int32(3)
extras/Tests/lang.inlineArgs.ci:30: any2Var: int32(3)
extras/Tests/lang.inlineArgs.ci:31: any2Xpr: int32(9)
extras/Tests/lang.inlineArgs.ci:33: min2Val: int32(3)
extras/Tests/lang.inlineArgs.ci:34: min2Var: int32(3)
extras/Tests/lang.inlineArgs.ci:35: min2Xpr: int32(9)
extras/Tests/lang.inlineArgs.ci:42: any3Val: int32(3)
extras/Tests/lang.inlineArgs.ci:43: any3Var: int32(3)
extras/Tests/lang.inlineArgs.ci:44: any3Xpr: int32(9)
extras/Tests/lang.inlineArgs.ci:46: min3Val: int32(2)
extras/Tests/lang.inlineArgs.ci:47: min3Var: int32(3)
extras/Tests/lang.inlineArgs.ci:48: min3Xpr: int32(9)
extras/Tests/test.inlineOverload.ci:9: overload1: float32(1.000000)
extras/Tests/test.inlineOverload.ci:10: overload2: float32(2.000000)
extras/Tests/test.inlineOverload.ci:11: overload3: float32(3.000000)
extras/Tests/test.inlineOverload.ci:12: overload4: float32(FIXME: 4.000000)
extras/Tests/test.inlineOverload.ci:13: overload5: float32(5.000000)
extras/Tests/lang.inlineEmit.ci:3: emitldz32: int32(0)
extras/Tests/lang.inlineEmit.ci:4: emitldz64: int64(0)
extras/Tests/lang.inlineEmit.ci:6: emitA: int32(42)
extras/Tests/lang.inlineEmit.ci:7: emitB: int32(96)
extras/Tests/lang.inlineEmit.ci:9: emitAddI32: int32(138)
extras/Tests/lang.inlineEmit.ci:10: emitDivI32: int32(2)
extras/Tests/lang.inlineEmit.ci:11: emitNfcF32: float32(1.000000)
extras/Tests/lang.reflection.ci:5: sizeofVoid: int32(0)
extras/Tests/lang.reflection.ci:6: sizeofBool: int32(1)
extras/Tests/lang.reflection.ci:7: sizeofChar: int32(1)
extras/Tests/lang.reflection.ci:8: sizeofInt8: int32(1)
extras/Tests/lang.reflection.ci:9: sizeofInt16: int32(2)
extras/Tests/lang.reflection.ci:10: sizeofInt32: int32(4)
extras/Tests/lang.reflection.ci:11: sizeofInt64: int32(8)
extras/Tests/lang.reflection.ci:12: sizeofUint8: int32(1)
extras/Tests/lang.reflection.ci:13: sizeofUint16: int32(2)
extras/Tests/lang.reflection.ci:14: sizeofUint32: int32(4)
extras/Tests/lang.reflection.ci:15: sizeofUint64: int32(8)
extras/Tests/lang.reflection.ci:16: sizeofFloat32: int32(4)
extras/Tests/lang.reflection.ci:17: sizeofFloat64: int32(8)
extras/Tests/lang.reflection.ci:18: sizeofPointer: int32(4)
extras/Tests/lang.reflection.ci:19: sizeofVariant: int32(8)
extras/Tests/lang.reflection.ci:20: sizeofTypename: int32(136)
extras/Tests/lang.reflection.ci:21: sizeofFunction: int32(8)
extras/Tests/lang.reflection.ci:22: sizeofObject: int32(4)
extras/Tests/lang.reflection.ci:32: typeofRecord: typename(RecordSizeofExt)
extras/Tests/lang.reflection.ci:33: nameOfRecord: char[*]("RecordSizeofExt")
extras/Tests/lang.reflection.ci:34: sizeOfRecord: int32(16)
extras/Tests/lang.reflection.ci:35: fileOfRecord: char[*]("extras/Tests/lang.reflection.ci")
extras/Tests/lang.reflection.ci:36: lineOfRecord: int32(28)
extras/Tests/lang.reflection.ci:38: typeofBase: typename(RecordSizeof)
extras/Tests/lang.reflection.ci:39: nameOfBase: char[*]("RecordSizeof")
extras/Tests/lang.reflection.ci:40: sizeOfBase: int32(12)
extras/Tests/lang.reflection.ci:41: fileOfBase: char[*]("extras/Tests/lang.reflection.ci")
extras/Tests/lang.reflection.ci:42: lineOfBase: int32(24)
extras/Tests/lang.reflection.ci:44: typeofBase1: typename(object)
extras/Tests/lang.reflection.ci:45: sizeofBase1: int32(4)
extras/Tests/lang.reflection.ci:47: typeofBase2: typename(typename)
extras/Tests/lang.reflection.ci:48: sizeofBase2: int32(136)
extras/Tests/lang.function.ci:11: funAddResult: int32(9)
extras/Tests/lang.function.ci:14: funAddRef: function(<funAdd @023d41>)
extras/Tests/lang.function.ci:17: funAddRefResult: int32(10)
extras/Tests/lang.function.ci:20: funMul: function(<funMul @023d4a>)
extras/Tests/lang.function.ci:23: funMulResult: int32(12)
extras/Tests/lang.function.ci:26: funMulRef: function(<funMul @023d4a>)
extras/Tests/lang.function.ci:29: funMulRefResult: int32(14)
extras/Tests/lang.function.ci:48: fibonacci_13: uint32(233)
extras/Tests/lang.useOperator.ci:5: shift: int32(2)
extras/Tests/lang.useOperator.ci:7: boolA: bool(1)
extras/Tests/lang.useOperator.ci:8: boolB: bool(1)
extras/Tests/lang.useOperator.ci:17: boolAnd: bool(1)
extras/Tests/lang.useOperator.ci:18: boolIor: bool(1)
extras/Tests/lang.useOperator.ci:19: boolXor: bool(0)
extras/Tests/lang.useOperator.ci:22: boolNot: bool(0)
extras/Tests/lang.useOperator.ci:23: boolCeq: bool(1)
extras/Tests/lang.useOperator.ci:24: boolCne: bool(0)
extras/Tests/lang.useOperator.ci:25: boolClt: bool(0)
extras/Tests/lang.useOperator.ci:26: boolCle: bool(1)
extras/Tests/lang.useOperator.ci:27: boolCgt: bool(0)
extras/Tests/lang.useOperator.ci:28: boolCge: bool(1)
extras/Tests/lang.useOperator.ci:30: chrA: char('a')
extras/Tests/lang.useOperator.ci:31: chrB: char('b')
extras/Tests/lang.useOperator.ci:32: chrPls: char('b')
extras/Tests/lang.useOperator.ci:33: chrNeg: char('�')
extras/Tests/lang.useOperator.ci:34: chrCmt: char('�')
extras/Tests/lang.useOperator.ci:35: chrAdd: char('�')
extras/Tests/lang.useOperator.ci:36: chrSub: char('�')
extras/Tests/lang.useOperator.ci:37: chrMul: char('\"')
extras/Tests/lang.useOperator.ci:38: chrDiv: char('')
extras/Tests/lang.useOperator.ci:39: chrMod: char('a')
extras/Tests/lang.useOperator.ci:40: chrAnd: char('`')
extras/Tests/lang.useOperator.ci:41: chrIor: char('c')
extras/Tests/lang.useOperator.ci:42: chrXor: char('')
extras/Tests/lang.useOperator.ci:43: chrShl: char('�')
extras/Tests/lang.useOperator.ci:44: chrShr: char('')
extras/Tests/lang.useOperator.ci:45: chrNot: bool(0)
extras/Tests/lang.useOperator.ci:46: chrCeq: bool(0)
extras/Tests/lang.useOperator.ci:47: chrCne: bool(1)
extras/Tests/lang.useOperator.ci:48: chrClt: bool(1)
extras/Tests/lang.useOperator.ci:49: chrCle: bool(1)
extras/Tests/lang.useOperator.ci:50: chrCgt: bool(0)
extras/Tests/lang.useOperator.ci:51: chrCge: bool(0)
extras/Tests/lang.useOperator.ci:53: i8A: int8(96)
extras/Tests/lang.useOperator.ci:54: i8B: int8(42)
extras/Tests/lang.useOperator.ci:55: i8Pls: int8(42)
extras/Tests/lang.useOperator.ci:56: i8Neg: int8(-42)
extras/Tests/lang.useOperator.ci:57: i8Cmt: int8(-43)
extras/Tests/lang.useOperator.ci:58: i8Add: int8(-118)
extras/Tests/lang.useOperator.ci:59: i8Sub: int8(54)
extras/Tests/lang.useOperator.ci:60: i8Mul: int8(-64)
extras/Tests/lang.useOperator.ci:61: i8Div: int8(2)
extras/Tests/lang.useOperator.ci:62: i8Mod: int8(12)
extras/Tests/lang.useOperator.ci:63: i8And: int8(32)
extras/Tests/lang.useOperator.ci:64: i8Ior: int8(106)
extras/Tests/lang.useOperator.ci:65: i8Xor: int8(74)
extras/Tests/lang.useOperator.ci:66: i8Shl: int8(-128)
extras/Tests/lang.useOperator.ci:67: i8Shr: int8(24)
extras/Tests/lang.useOperator.ci:68: i8Not: bool(0)
extras/Tests/lang.useOperator.ci:69: i8Ceq: bool(0)
extras/Tests/lang.useOperator.ci:70: i8Cne: bool(1)
extras/Tests/lang.useOperator.ci:71: i8Clt: bool(0)
extras/Tests/lang.useOperator.ci:72: i8Cle: bool(0)
extras/Tests/lang.useOperator.ci:73: i8Cgt: bool(1)
extras/Tests/lang.useOperator.ci:74: i8Cge: bool(1)
extras/Tests/lang.useOperator.ci:76: u8A: uint8(96)
extras/Tests/lang.useOperator.ci:77: u8B: uint8(42)
extras/Tests/lang.useOperator.ci:78: u8Pls: uint8(42)
extras/Tests/lang.useOperator.ci:79: u8Neg: uint8(214)
extras/Tests/lang.useOperator.ci:80: u8Cmt: uint8(213)
extras/Tests/lang.useOperator.ci:81: u8Add: uint8(138)
extras/Tests/lang.useOperator.ci:82: u8Sub: uint8(54)
extras/Tests/lang.useOperator.ci:83: u8Mul: uint8(192)
extras/Tests/lang.useOperator.ci:84: u8Div: uint8(2)
extras/Tests/lang.useOperator.ci:85: u8Mod: uint8(12)
extras/Tests/lang.useOperator.ci:86: u8And: uint8(32)
extras/Tests/lang.useOperator.ci:87: u8Ior: uint8(106)
extras/Tests/lang.useOperator.ci:88: u8Xor: uint8(74)
extras/Tests/lang.useOperator.ci:89: u8Shl: uint8(128)
extras/Tests/lang.useOperator.ci:90: u8Shr: uint8(24)
extras/Tests/lang.useOperator.ci:91: u8Not: bool(0)
extras/Tests/lang.useOperator.ci:92: u8Ceq: bool(0)
extras/Tests/lang.useOperator.ci:93: u8Cne: bool(1)
extras/Tests/lang.useOperator.ci:94: u8Clt: bool(0)
extras/Tests/lang.useOperator.ci:95: u8Cle: bool(0)
extras/Tests/lang.useOperator.ci:96: u8Cgt: bool(1)
extras/Tests/lang.useOperator.ci:97: u8Cge: bool(1)
extras/Tests/lang.useOperator.ci:99: i16A: int16(96)
extras/Tests/lang.useOperator.ci:100: i16B: int16(42)
extras/Tests/lang.useOperator.ci:101: i16Pls: int16(42)
extras/Tests/lang.useOperator.ci:102: i16Neg: int16(-42)
extras/Tests/lang.useOperator.ci:103: i16Cmt: int16(-43)
extras/Tests/lang.useOperator.ci:104: i16Add: int16(138)
extras/Tests/lang.useOperator.ci:105: i16Sub: int16(54)
extras/Tests/lang.useOperator.ci:106: i16Mul: int16(4032)
extras/Tests/lang.useOperator.ci:107: i16Div: int16(2)
extras/Tests/lang.useOperator.ci:108: i16Mod: int16(12)
extras/Tests/lang.useOperator.ci:109: i16And: int16(32)
extras/Tests/lang.useOperator.ci:110: i16Ior: int16(106)
extras/Tests/lang.useOperator.ci:111: i16Xor: int16(74)
extras/Tests/lang.useOperator.ci:112: i16Shl: int16(384)
extras/Tests/lang.useOperator.ci:113: i16Shr: int16(24)
extras/Tests/lang.useOperator.ci:114: i16Not: bool(0)
extras/Tests/lang.useOperator.ci:115: i16Ceq: bool(0)
extras/Tests/lang.useOperator.ci:116: i16Cne: bool(1)
extras/Tests/lang.useOperator.ci:117: i16Clt: bool(0)
extras/Tests/lang.useOperator.ci:118: i16Cle: bool(0)
extras/Tests/lang.useOperator.ci:119: i16Cgt: bool(1)
extras/Tests/lang.useOperator.ci:120: i16Cge: bool(1)
extras/Tests/lang.useOperator.ci:122: u16A: uint16(96)
extras/Tests/lang.useOperator.ci:123: u16B: uint16(42)
extras/Tests/lang.useOperator.ci:124: u16Pls: uint16(42)
extras/Tests/lang.useOperator.ci:125: u16Neg: uint16(65494)
extras/Tests/lang.useOperator.ci:126: u16Cmt: uint16(65493)
extras/Tests/lang.useOperator.ci:127: u16Add: uint16(138)
extras/Tests/lang.useOperator.ci:128: u16Sub: uint16(54)
extras/Tests/lang.useOperator.ci:129: u16Mul: uint16(4032)
extras/Tests/lang.useOperator.ci:130: u16Div: uint16(2)
extras/Tests/lang.useOperator.ci:131: u16Mod: uint16(12)
extras/Tests/lang.useOperator.ci:132: u16And: uint16(32)
extras/Tests/lang.useOperator.ci:133: u16Ior: uint16(106)
extras/Tests/lang.useOperator.ci:134: u16Xor: uint16(74)
extras/Tests/lang.useOperator.ci:135: u16Shl: uint16(384)
extras/Tests/lang.useOperator.ci:136: u16Shr: uint16(24)
extras/Tests/lang.useOperator.ci:137: u16Not: bool(0)
extras/Tests/lang.useOperator.ci:138: u16Ceq: bool(0)
extras/Tests/lang.useOperator.ci:139: u16Cne: bool(1)
extras/Tests/lang.useOperator.ci:140: u16Clt: bool(0)
extras/Tests/lang.useOperator.ci:141: u16Cle: bool(0)
extras/Tests/lang.useOperator.ci:142: u16Cgt: bool(1)
extras/Tests/lang.useOperator.ci:143: u16Cge: bool(1)
extras/Tests/lang.useOperator.ci:145: i32A: int32(96)
extras/Tests/lang.useOperator.ci:146: i32B: int32(42)
extras/Tests/lang.useOperator.ci:147: i32Pls: int32(42)
extras/Tests/lang.useOperator.ci:148: i32Neg: int32(-42)
extras/Tests/lang.useOperator.ci:149: i32Cmt: int32(-43)
extras/Tests/lang.useOperator.ci:150: i32Add: int32(138)
extras/Tests/lang.useOperator.ci:151: i32Sub: int32(54)
extras/Tests/lang.useOperator.ci:152: i32Mul: int32(4032)
extras/Tests/lang.useOperator.ci:153: i32Div: int32(2)
extras/Tests/lang.useOperator.ci:154: i32Mod: int32(12)
extras/Tests/lang.useOperator.ci:155: i32And: int32(32)
extras/Tests/lang.useOperator.ci:156: i32Ior: int32(106)
extras/Tests/lang.useOperator.ci:157: i32Xor: int32(74)
extras/Tests/lang.useOperator.ci:158: i32Shl: int32(384)
extras/Tests/lang.useOperator.ci:159: i32Shr: int32(24)
extras/Tests/lang.useOperator.ci:160: i32Not: bool(0)
extras/Tests/lang.useOperator.ci:161: i32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:162: i32Cne: bool(1)
extras/Tests/lang.useOperator.ci:163: i32Clt: bool(0)
extras/Tests/lang.useOperator.ci:164: i32Cle: bool(0)
extras/Tests/lang.useOperator.ci:165: i32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:166: i32Cge: bool(1)
extras/Tests/lang.useOperator.ci:168: u32A: uint32(96)
extras/Tests/lang.useOperator.ci:169: u32B: uint32(42)
extras/Tests/lang.useOperator.ci:170: u32Pls: uint32(42)
extras/Tests/lang.useOperator.ci:171: u32Neg: uint32(4294967254)
extras/Tests/lang.useOperator.ci:172: u32Cmt: uint32(4294967253)
extras/Tests/lang.useOperator.ci:173: u32Add: uint32(138)
extras/Tests/lang.useOperator.ci:174: u32Sub: uint32(54)
extras/Tests/lang.useOperator.ci:175: u32Mul: uint32(4032)
extras/Tests/lang.useOperator.ci:176: u32Div: uint32(2)
extras/Tests/lang.useOperator.ci:177: u32Mod: uint32(12)
extras/Tests/lang.useOperator.ci:178: u32And: uint32(32)
extras/Tests/lang.useOperator.ci:179: u32Ior: uint32(106)
extras/Tests/lang.useOperator.ci:180: u32Xor: uint32(74)
extras/Tests/lang.useOperator.ci:181: u32Shl: uint32(384)
extras/Tests/lang.useOperator.ci:182: u32Shr: uint32(24)
extras/Tests/lang.useOperator.ci:183: u32Not: bool(0)
extras/Tests/lang.useOperator.ci:184: u32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:185: u32Cne: bool(1)
extras/Tests/lang.useOperator.ci:186: u32Clt: bool(0)
extras/Tests/lang.useOperator.ci:187: u32Cle: bool(0)
extras/Tests/lang.useOperator.ci:188: u32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:189: u32Cge: bool(1)
extras/Tests/lang.useOperator.ci:191: i64A: int64(96)
extras/Tests/lang.useOperator.ci:192: i64B: int64(42)
extras/Tests/lang.useOperator.ci:193: i64Pls: int64(42)
extras/Tests/lang.useOperator.ci:194: i64Neg: int64(-42)
extras/Tests/lang.useOperator.ci:195: i64Cmt: int64(-43)
extras/Tests/lang.useOperator.ci:196: i64Add: int64(138)
extras/Tests/lang.useOperator.ci:197: i64Sub: int64(54)
extras/Tests/lang.useOperator.ci:198: i64Mul: int64(4032)
extras/Tests/lang.useOperator.ci:199: i64Div: int64(2)
extras/Tests/lang.useOperator.ci:200: i64Mod: int64(12)
extras/Tests/lang.useOperator.ci:201: i64And: int64(32)
extras/Tests/lang.useOperator.ci:202: i64Ior: int64(106)
extras/Tests/lang.useOperator.ci:203: i64Xor: int64(74)
extras/Tests/lang.useOperator.ci:204: i64Shl: int64(384)
extras/Tests/lang.useOperator.ci:205: i64Shr: int64(24)
extras/Tests/lang.useOperator.ci:206: i64Not: bool(0)
extras/Tests/lang.useOperator.ci:207: i64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:208: i64Cne: bool(1)
extras/Tests/lang.useOperator.ci:209: i64Clt: bool(0)
extras/Tests/lang.useOperator.ci:210: i64Cle: bool(0)
extras/Tests/lang.useOperator.ci:211: i64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:212: i64Cge: bool(1)
extras/Tests/lang.useOperator.ci:214: u64A: uint64(96)
extras/Tests/lang.useOperator.ci:215: u64B: uint64(42)
extras/Tests/lang.useOperator.ci:216: u64Pls: uint64(42)
extras/Tests/lang.useOperator.ci:217: u64Neg: uint64(18446744073709551574)
extras/Tests/lang.useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
extras/Tests/lang.useOperator.ci:219: u64Add: uint64(138)
extras/Tests/lang.useOperator.ci:220: u64Sub: uint64(54)
extras/Tests/lang.useOperator.ci:221: u64Mul: uint64(4032)
extras/Tests/lang.useOperator.ci:222: u64Div: uint64(2)
extras/Tests/lang.useOperator.ci:223: u64Mod: uint64(12)
extras/Tests/lang.useOperator.ci:224: u64And: uint64(32)
extras/Tests/lang.useOperator.ci:225: u64Ior: uint64(106)
extras/Tests/lang.useOperator.ci:226: u64Xor: uint64(74)
extras/Tests/lang.useOperator.ci:227: u64Shl: uint64(384)
extras/Tests/lang.useOperator.ci:228: u64Shr: uint64(24)
extras/Tests/lang.useOperator.ci:229: u64Not: bool(0)
extras/Tests/lang.useOperator.ci:230: u64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:231: u64Cne: bool(1)
extras/Tests/lang.useOperator.ci:232: u64Clt: bool(0)
extras/Tests/lang.useOperator.ci:233: u64Cle: bool(0)
extras/Tests/lang.useOperator.ci:234: u64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:235: u64Cge: bool(1)
extras/Tests/lang.useOperator.ci:237: f32A: float32(96.300003)
extras/Tests/lang.useOperator.ci:238: f32B: float32(42.139999)
extras/Tests/lang.useOperator.ci:239: f32Pls: float32(42.139999)
extras/Tests/lang.useOperator.ci:240: f32Neg: float32(-42.139999)
extras/Tests/lang.useOperator.ci:242: f32Add: float32(138.440002)
extras/Tests/lang.useOperator.ci:243: f32Sub: float32(54.160004)
extras/Tests/lang.useOperator.ci:244: f32Mul: float32(4058.082031)
extras/Tests/lang.useOperator.ci:245: f32Div: float32(2.285240)
extras/Tests/lang.useOperator.ci:246: f32Mod: float32(12.020004)
extras/Tests/lang.useOperator.ci:252: f32Not: bool(0)
extras/Tests/lang.useOperator.ci:253: f32Ceq: bool(0)
extras/Tests/lang.useOperator.ci:254: f32Cne: bool(1)
extras/Tests/lang.useOperator.ci:255: f32Clt: bool(0)
extras/Tests/lang.useOperator.ci:256: f32Cle: bool(0)
extras/Tests/lang.useOperator.ci:257: f32Cgt: bool(1)
extras/Tests/lang.useOperator.ci:258: f32Cge: bool(1)
extras/Tests/lang.useOperator.ci:260: f64A: float64(96.300000)
extras/Tests/lang.useOperator.ci:261: f64B: float64(42.140000)
extras/Tests/lang.useOperator.ci:262: f64Pls: float64(42.140000)
extras/Tests/lang.useOperator.ci:263: f64Neg: float64(-42.140000)
extras/Tests/lang.useOperator.ci:265: f64Add: float64(138.440000)
extras/Tests/lang.useOperator.ci:266: f64Sub: float64(54.160000)
extras/Tests/lang.useOperator.ci:267: f64Mul: float64(4058.082000)
extras/Tests/lang.useOperator.ci:268: f64Div: float64(2.285240)
extras/Tests/lang.useOperator.ci:269: f64Mod: float64(12.020000)
extras/Tests/lang.useOperator.ci:275: f64Not: bool(0)
extras/Tests/lang.useOperator.ci:276: f64Ceq: bool(0)
extras/Tests/lang.useOperator.ci:277: f64Cne: bool(1)
extras/Tests/lang.useOperator.ci:278: f64Clt: bool(0)
extras/Tests/lang.useOperator.ci:279: f64Cle: bool(0)
extras/Tests/lang.useOperator.ci:280: f64Cgt: bool(1)
extras/Tests/lang.useOperator.ci:281: f64Cge: bool(1)
extras/Tests/lang.useOperator.ci:283: ptrA: pointer(null)
extras/Tests/lang.useOperator.ci:284: ptrB: pointer({})
extras/Tests/lang.useOperator.ci:299: ptrCeq: bool(0)
extras/Tests/lang.useOperator.ci:300: ptrCne: bool(1)
extras/Tests/lang.varInitArray.ci:8: arrFixedNoInit: int64[7]([7] {FIXME: random values})
extras/Tests/lang.varInitArray.ci:9: arrSliceNoInit: int64[](null)
extras/Tests/lang.varInitArray.ci:10: arrPtrNoInit: int64[*](null)
extras/Tests/lang.varInitArray.ci:13: arrSliceInitNull: int64[](null)
extras/Tests/lang.varInitArray.ci:14: arrPtrInitNull: int64[*](null)
extras/Tests/lang.varInitArray.ci:17: arrSliceInitFixed: int64[]([7] {FIXME: random values})
extras/Tests/lang.varInitArray.ci:18: arrPtrInitFixed: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:21: arrSliceInitSlice: int64[]([7] {FIXME: random values})
extras/Tests/lang.varInitArray.ci:22: arrPtrInitSlice: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:26: arrPtrInitPtr: int64[*]([*] {...})
extras/Tests/lang.varInitArray.ci:37: arrSliceInitString: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
extras/Tests/lang.varInitArray.ci:38: arrPtrInitString: char[*]("string")
extras/Tests/lang.varInitByRef.ci:7: value: int64(42)
extras/Tests/lang.varInitByRef.ci:8: valueRef: int64(42)
extras/Tests/lang.varInitByRef.ci:9: valuePtr: pointer(<value @023db0>)
extras/Tests/lang.varInitByRef.ci:10: valueVar: variant({int64: 42})
extras/Tests/lang.varInitByRef.ci:12: fromRef: int64(42)
extras/Tests/lang.varInitByRef.ci:13: fromPtr: int64(42)
extras/Tests/lang.varInitByRef.ci:14: fromVar: int64(42)
extras/Tests/lang.varInitByRef.ci:16: nullRef: int64(null)
extras/Tests/lang.varInitByRef.ci:17: nullPtr: pointer(null)
extras/Tests/lang.varInitByRef.ci:18: nullVar: variant(null)
extras/Tests/lang.varInitByRef.ci:19: nullTyp: typename(null)
extras/Tests/lang.varInitByRef.ci:20: nullFun: function(null)
extras/Tests/lang.varInitByRef.ci:21: nullObj: object(null)
extras/Tests/lang.varInitByRef.ci:23: typePtr: pointer(<int64 @000400>)
extras/Tests/lang.varInitByRef.ci:24: typeVar: variant({typename: int64})
extras/Tests/lang.varInitByRef.ci:25: typeTyp: typename(int64)
extras/Tests/lang.varInitByRef.ci:27: local: int64(42)
extras/Tests/lang.varInitByRef.ci:28: copyVal: int64(42)
extras/Tests/lang.varInitByRef.ci:29: copyRef: int64(42)
extras/Tests/lang.varInitByRef.ci:30: copyPtr: pointer(<value @023db0>)
extras/Tests/lang.varInitByRef.ci:31: copyVar: variant({int64: 42})
extras/Tests/lang.varInitByRef.ci:32: copyTyp: typename(int64)
extras/Tests/lang.varInitByRef.ci:35: ptrVoid: pointer(<void @0000a0>)
extras/Tests/lang.varInitByRef.ci:36: ptrBool: pointer(<bool @000130>)
extras/Tests/lang.varInitByRef.ci:37: ptrChar: pointer(<char @0001c0>)
extras/Tests/lang.varInitByRef.ci:38: ptrInt8: pointer(<int8 @000250>)
extras/Tests/lang.varInitByRef.ci:39: ptrInt16: pointer(<int16 @0002e0>)
extras/Tests/lang.varInitByRef.ci:40: ptrInt32: pointer(<int32 @000370>)
extras/Tests/lang.varInitByRef.ci:41: ptrInt64: pointer(<int64 @000400>)
extras/Tests/lang.varInitByRef.ci:42: ptrUint8: pointer(<uint8 @000490>)
extras/Tests/lang.varInitByRef.ci:43: ptrUint16: pointer(<uint16 @000520>)
extras/Tests/lang.varInitByRef.ci:44: ptrUint32: pointer(<uint32 @0005b0>)
extras/Tests/lang.varInitByRef.ci:45: ptrUint64: pointer(<uint64 @000640>)
extras/Tests/lang.varInitByRef.ci:46: ptrFloat32: pointer(<float32 @0006d0>)
extras/Tests/lang.varInitByRef.ci:47: ptrFloat64: pointer(<float64 @000760>)
extras/Tests/lang.varInitByRef.ci:48: ptrTypename: pointer(<typename @000008>)
extras/Tests/lang.varInitByRef.ci:49: ptrFunction: pointer(<function @000910>)
extras/Tests/lang.varInitByRef.ci:50: ptrPointer: pointer(<pointer @0007f0>)
extras/Tests/lang.varInitByRef.ci:51: ptrVariant: pointer(<variant @000880>)
extras/Tests/lang.varInitByRef.ci:52: ptrObject: pointer(<object @0009a8>)
extras/Tests/lang.varInitByRef.ci:55: varVoid: variant({typename: void})
extras/Tests/lang.varInitByRef.ci:56: varBool: variant({typename: bool})
extras/Tests/lang.varInitByRef.ci:57: varChar: variant({typename: char})
extras/Tests/lang.varInitByRef.ci:58: varInt8: variant({typename: int8})
extras/Tests/lang.varInitByRef.ci:59: varInt16: variant({typename: int16})
extras/Tests/lang.varInitByRef.ci:60: varInt32: variant({typename: int32})
extras/Tests/lang.varInitByRef.ci:61: varInt64: variant({typename: int64})
extras/Tests/lang.varInitByRef.ci:62: varUint8: variant({typename: uint8})
extras/Tests/lang.varInitByRef.ci:63: varUint16: variant({typename: uint16})
extras/Tests/lang.varInitByRef.ci:64: varUint32: variant({typename: uint32})
extras/Tests/lang.varInitByRef.ci:65: varUint64: variant({typename: uint64})
extras/Tests/lang.varInitByRef.ci:66: varFloat32: variant({typename: float32})
extras/Tests/lang.varInitByRef.ci:67: varFloat64: variant({typename: float64})
extras/Tests/lang.varInitByRef.ci:68: varTypename: variant({typename: typename})
extras/Tests/lang.varInitByRef.ci:69: varFunction: variant({typename: function})
extras/Tests/lang.varInitByRef.ci:70: varPointer: variant({typename: pointer})
extras/Tests/lang.varInitByRef.ci:71: varVariant: variant({typename: variant})
extras/Tests/lang.varInitByRef.ci:72: varObject: variant({typename: object})
extras/Tests/lang.varInitByRef.ci:75: typVoid: typename(void)
extras/Tests/lang.varInitByRef.ci:76: typBool: typename(bool)
extras/Tests/lang.varInitByRef.ci:77: typChar: typename(char)
extras/Tests/lang.varInitByRef.ci:78: typInt8: typename(int8)
extras/Tests/lang.varInitByRef.ci:79: typInt16: typename(int16)
extras/Tests/lang.varInitByRef.ci:80: typInt32: typename(int32)
extras/Tests/lang.varInitByRef.ci:81: typInt64: typename(int64)
extras/Tests/lang.varInitByRef.ci:82: typUint8: typename(uint8)
extras/Tests/lang.varInitByRef.ci:83: typUint16: typename(uint16)
extras/Tests/lang.varInitByRef.ci:84: typUint32: typename(uint32)
extras/Tests/lang.varInitByRef.ci:85: typUint64: typename(uint64)
extras/Tests/lang.varInitByRef.ci:86: typFloat32: typename(float32)
extras/Tests/lang.varInitByRef.ci:87: typFloat64: typename(float64)
extras/Tests/lang.varInitByRef.ci:88: typTypename: typename(typename)
extras/Tests/lang.varInitByRef.ci:89: typFunction: typename(function)
extras/Tests/lang.varInitByRef.ci:90: typPointer: typename(pointer)
extras/Tests/lang.varInitByRef.ci:91: typVariant: typename(variant)
extras/Tests/lang.varInitByRef.ci:92: typObject: typename(object)
extras/Tests/lang.varInitByRef.ci:95: valueOfPtr: pointer(<value @023db0>)
extras/Tests/lang.varInitByRef.ci:96: valueOfVar: variant({int64: 42})
extras/Tests/lang.varInitByRef.ci:97: valueOfTyp: typename(int64)
extras/Tests/lang.varInitByRef.ci:99: typeOfValue: typename(int64)
extras/Tests/lang.varInitByRef.ci:105: copyPtrFloat64: variant({pointer: <float64 @000760>})
extras/Tests/lang.varInitByRef.ci:108: copyVarFloat64: pointer(<float64 @000760>)
extras/Tests/lang.varInitByVal.ci:7: localNoInit: int64(0)
extras/Tests/lang.varInitByVal.ci:8: globalNoInit: int64(0)
extras/Tests/lang.varInitByVal.ci:9: localInitValue: int64(42)
extras/Tests/lang.varInitByVal.ci:10: globalInitValue: int64(1024)
extras/Tests/lang.varInitByVal.ci:11: localInitLocal: int64(42)
extras/Tests/lang.varInitByVal.ci:12: globalInitLocal: int64(42)
extras/Tests/lang.varInitByVal.ci:13: localInitGlobal: int64(1024)
extras/Tests/lang.varInitByVal.ci:14: globalInitGlobal: int64(1024)
extras/Tests/stdc.nfcNumber.ci:3: pi64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:4: e64: float64(2.718282)
extras/Tests/stdc.nfcNumber.ci:6: pi32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:7: e32: float32(2.718282)
extras/Tests/stdc.nfcNumber.ci:14: r_comp: int32(112)
extras/Tests/stdc.nfcNumber.ci:15: g_comp: int32(252)
extras/Tests/stdc.nfcNumber.ci:16: b_comp: int32(248)
extras/Tests/stdc.nfcNumber.ci:18: r5g6b5: int32(30719)
extras/Tests/stdc.nfcNumber.ci:19: r8g8b8: int32(7404792)
extras/Tests/stdc.nfcNumber.ci:21: zxtR5: int32(14)
extras/Tests/stdc.nfcNumber.ci:22: zxtG6: int32(63)
extras/Tests/stdc.nfcNumber.ci:23: zxtB5: int32(31)
extras/Tests/stdc.nfcNumber.ci:25: sxtR5: int32(14)
extras/Tests/stdc.nfcNumber.ci:26: sxtG6: int32(-1)
extras/Tests/stdc.nfcNumber.ci:27: sxtB5: int32(-1)
extras/Tests/stdc.nfcNumber.ci:29: zxtR8: int32(112)
extras/Tests/stdc.nfcNumber.ci:30: zxtG8: int32(252)
extras/Tests/stdc.nfcNumber.ci:31: zxtB8: int32(248)
extras/Tests/stdc.nfcNumber.ci:33: sxtR8: int32(112)
extras/Tests/stdc.nfcNumber.ci:34: sxtG8: int32(-4)
extras/Tests/stdc.nfcNumber.ci:35: sxtB8: int32(-8)
extras/Tests/stdc.nfcNumber.ci:37: sinF64: float64(1.000000)
extras/Tests/stdc.nfcNumber.ci:38: cosF64: float64(0.000000)
extras/Tests/stdc.nfcNumber.ci:39: tanF64: float64(1.000000)
extras/Tests/stdc.nfcNumber.ci:40: logF64: float64(3.000000)
extras/Tests/stdc.nfcNumber.ci:41: expF64: float64(2.718282)
extras/Tests/stdc.nfcNumber.ci:42: powF64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:43: sqrtF64: float64(3.141593)
extras/Tests/stdc.nfcNumber.ci:44: atanF64: float64(1.262627)
extras/Tests/stdc.nfcNumber.ci:46: sinF32: float32(1.000000)
extras/Tests/stdc.nfcNumber.ci:47: cosF32: float32(-0.000000)
extras/Tests/stdc.nfcNumber.ci:48: tanF32: float32(1.000000)
extras/Tests/stdc.nfcNumber.ci:49: logF32: float32(3.000000)
extras/Tests/stdc.nfcNumber.ci:50: expF32: float32(2.718282)
extras/Tests/stdc.nfcNumber.ci:51: powF32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:52: sqrtF32: float32(3.141593)
extras/Tests/stdc.nfcNumber.ci:53: atanF32: float32(1.262627)
extras/Tests/stdc.nfcMemory.ci:6: p1: pointer({})
extras/Tests/stdc.nfcMemory.ci:7: p2: pointer({})
extras/Tests/stdc.nfcMemory.ci:8: p3: pointer({})
extras/Tests/stdc.nfcMemory.ci:9: p4: pointer({})
extras/Tests/stdc.nfcMemory.ci:22: val1: int64(0)
extras/Tests/stdc.nfcMemory.ci:23: val2: int64(42)
// */

/*-- Memory:
memory[meta] @000000; size: 146752(143.3 Kb)
memory[code] @000000; size: 151698(148.1 Kb)
memory[stck] @000000; size: 163778(159.9 Kb)
memory[heap] @025092; size: 339588(331.6 Kb)
memory[free] @0250a8; size: 339536(331.6 Kb)
// */
