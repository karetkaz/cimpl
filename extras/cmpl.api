typename
typename.size
typename.offset
typename.base(type: typename): typename
typename.file(type: typename): .cstr
typename.line(type: typename): int32
typename.name(type: typename): .cstr
void
bool
char
int8
int16
int32
int64
uint8
uint16
uint32
uint32.zxt(value: int32, offs: int32, count: int32): int32
uint32.sxt(value: int32, offs: int32, count: int32): int32
uint32.pop(value: int32): int32
uint32.swap(value: int32): int32
uint32.bsr(value: int32): int32
uint32.bsf(value: int32): int32
uint32.hib(value: int32): int32
uint32.lob(value: int32): int32
uint64
uint64.zxt(value: int64, offs: int32, count: int32): int64
uint64.sxt(value: int64, offs: int32, count: int32): int64
float32
float32.sin(x: float32): float32
float32.cos(x: float32): float32
float32.tan(x: float32): float32
float32.log(x: float32): float32
float32.exp(x: float32): float32
float32.pow(x: float32, y: float32): float32
float32.sqrt(x: float32): float32
float32.atan2(x: float32, y: float32): float32
float64
float64.sin(x: float64): float64
float64.cos(x: float64): float64
float64.tan(x: float64): float64
float64.log(x: float64): float64
float64.exp(x: float64): float64
float64.pow(x: float64, y: float64): float64
float64.sqrt(x: float64): float64
float64.atan2(x: float64, y: float64): float64
pointer
pointer.alloc(ptr: pointer, size: int32): pointer
pointer.fill(dst: pointer, value: int32, size: int32): pointer
pointer.copy(dst: pointer, src: pointer, size: int32): pointer
pointer.move(dst: pointer, src: pointer, size: int32): pointer
variant
function
object
null
true
false
int
byte
float
double
emit
emit.nop
emit.not
emit.set
emit.ret
emit.call
emit.p4x
emit.p4x.dp3
emit.p4x.dp4
emit.p4x.dph
emit.dup
emit.dup.x1
emit.dup.x2
emit.dup.x4
emit.load
emit.load.z32
emit.load.z64
emit.load.z128
emit.load.i8
emit.load.i16
emit.load.i32
emit.load.i64
emit.load.i128
emit.store
emit.store.i8
emit.store.i16
emit.store.i32
emit.store.i64
emit.store.i128
emit.cmt
emit.cmt.u32
emit.cmt.u64
emit.and
emit.and.u32
emit.and.u64
emit.or
emit.or.u32
emit.or.u64
emit.xor
emit.xor.u32
emit.xor.u64
emit.shl
emit.shl.u32
emit.shl.u64
emit.shr
emit.shr.i32
emit.shr.i64
emit.shr.u32
emit.shr.u64
emit.neg
emit.neg.i32
emit.neg.i64
emit.neg.f32
emit.neg.f64
emit.neg.p4f
emit.neg.p2d
emit.add
emit.add.i32
emit.add.i64
emit.add.f32
emit.add.f64
emit.add.p4f
emit.add.p2d
emit.sub
emit.sub.i32
emit.sub.i64
emit.sub.f32
emit.sub.f64
emit.sub.p4f
emit.sub.p2d
emit.mul
emit.mul.i32
emit.mul.i64
emit.mul.u32
emit.mul.u64
emit.mul.f32
emit.mul.f64
emit.mul.p4f
emit.mul.p2d
emit.div
emit.div.i32
emit.div.i64
emit.div.u32
emit.div.u64
emit.div.f32
emit.div.f64
emit.div.p4f
emit.div.p2d
emit.mod
emit.mod.i32
emit.mod.i64
emit.mod.u32
emit.mod.u64
emit.mod.f32
emit.mod.f64
emit.ceq
emit.ceq.i32
emit.ceq.i64
emit.ceq.f32
emit.ceq.f64
emit.ceq.p4f
emit.ceq.p2d
emit.clt
emit.clt.i32
emit.clt.i64
emit.clt.u32
emit.clt.u64
emit.clt.f32
emit.clt.f64
emit.cgt
emit.cgt.i32
emit.cgt.i64
emit.cgt.u32
emit.cgt.u64
emit.cgt.f32
emit.cgt.f64
emit.min
emit.min.p4f
emit.min.p2d
emit.max
emit.max.p4f
emit.max.p2d
halt(): void
CLOCKS_PER_SEC
RAND_MAX
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
raise.abort
raise.error
raise.warn
raise.info
raise.debug
raise.verbose
raise.noTrace
raise.defTrace
tryExec(args: pointer, action(args: pointer): void): int32
System
System.exit(code: int32): void
System.srand(seed: int32): void
System.rand(): int32
System.time(): int32
System.clock(): int32
System.millis(): int64
System.sleep(millis: int64): void
verbose(message: char[*], inspect: variant): void
verbose(message: char[*]): void
trace(message: char[*], inspect: variant): void
trace(message: char[*]): void
debug(message: char[*], inspect: variant): void
debug(message: char[*]): void
info(message: char[*], inspect: variant): void
info(message: char[*]): void
warn(message: char[*], inspect: variant): void
warn(message: char[*]): void
error(message: char[*], inspect: variant): void
error(message: char[*]): void
abort(message: char[*], inspect: variant): void
abort(message: char[*]): void
abort(): void
assert(condition: bool, message: char[*], inspect: variant): void
assert(condition: bool, message: char[*]): void
assert(condition: bool): void
NotEquals
NotEquals.expected
NotEquals.returned
NotEquals.message
assertEq(expected: int32, returned: int32, message: char[*]): void
assertEq(expected: int32, returned: int32): void
sizeof(type: typename): int32
Math
Math.pi
Math.e
Math.ln2
Math.log2E
Math.ln10
Math.log10E
Math.phi
Math.sqrt2
Math.sqrtE
Math.sqrtPi
Math.sqrtPhi
Math.nan
Math.inf
Math.modf(x: float64, intPart: float64): float64
Math.floor(x: float64): float64
Math.ceil(x: float64): float64
Math.round(x: float64): float64
Math.sign(x: float32): int32
Math.sign(x: float64): int32
Math.abs(x: float32): float32
Math.abs(x: float64): float64
Math.min(a: float32, b: float32): float32
Math.min(a: float64, b: float64): float64
Math.max(a: float32, b: float32): float32
Math.max(a: float64, b: float64): float64
Math.clamp(t: float32, a: float32, b: float32): float32
Math.clamp(t: float64, a: float64, b: float64): float64
Math.lerp(t: float32, a: float32, b: float32): float32
Math.lerp(t: float64, a: float64, b: float64): float64
Math.smooth(t: float32, a: float32, b: float32): float32
Math.smooth(t: float64, a: float64, b: float64): float64
Math.cmp(a: float32, b: float32, eps: float32): int32
Math.cmp(a: float64, b: float64, eps: float64): int32
Math.sinCos(arg: float64, quad: int32): float64
Math.sin(arg: float64): float64
Math.cos(arg: float64): float64
Math.tan(arg: float64): float64
Math.sinh(x: float64): float64
Math.cosh(x: float64): float64
Math.asin(x: float64): float64
Math.acos(x: float64): float64
Math.deg2rad(x: float64): float64
Math.rad2deg(x: float64): float64
Complex
Complex.re
Complex.im
Complex(re: float64): Complex
Complex(re: float64, im: float64): Complex
neg(a: Complex): Complex
add(a: Complex, b: Complex): Complex
add(a: Complex, b: float64): Complex
add(a: float64, b: Complex): Complex
sub(a: Complex, b: Complex): Complex
sub(a: Complex, b: float64): Complex
sub(a: float64, b: Complex): Complex
mul(a: Complex, b: Complex): Complex
mul(a: Complex, b: float64): Complex
mul(a: float64, b: Complex): Complex
div(a: Complex, b: Complex): Complex
div(a: Complex, b: float64): Complex
div(a: float64, b: Complex): Complex
abs(a: Complex): float64
arg(a: Complex): float64
inv(a: Complex): Complex
conj(a: Complex): Complex
exp(a: Complex): Complex
log(a: Complex): Complex
pow(a: Complex, b: Complex): Complex
pow(a: Complex, b: float64): Complex
sin(a: Complex): Complex
cos(a: Complex): Complex
tan(a: Complex): Complex
cot(a: Complex): Complex
sinh(a: Complex): Complex
cosh(a: Complex): Complex
tanh(a: Complex): Complex
coth(a: Complex): Complex
sec(a: Complex): Complex
csc(a: Complex): Complex
sech(a: Complex): Complex
csch(a: Complex): Complex
toCartesian(x: Complex): Complex
toPolar(x: Complex): Complex
length(str: char[*]): int32
indexOf(str: char[*], chr: char): int32
lastIndexOf(str: char[*], chr: char): int32
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
ignCaseCmp(chr: char, with: char): int32
caseCmp(chr: char, with: char): int32
startsWith(str: char[*], with: char[*]): bool
endsWith(str: char[*], with: char[*]): bool
compare(str: char[*], with: char[*]): int32
contains(str: char[*], chr: char): bool
FormatFlags
FormatFlags.radix
FormatFlags.sign
FormatFlags.padChr
FormatFlags.padLen
FormatFlags.precision
append(output: char[], pos: int32, value: char[*]): int32
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint32): int32
append(output: char[], pos: int32, value: int32, forceSign: bool, pad: int32): int32
