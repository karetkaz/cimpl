
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (20 -> 24)
lib/stdlib.ci:43: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:44: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:45: warn: adding implicit cast char[*](message: char[*])
lib/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/math.ci:72: warn: adding implicit cast float32(0: int32)
lib/math.ci:75: warn: adding implicit cast float32(0: int32)
lib/math.ci:81: warn: adding implicit cast float64(0: int32)
lib/math.ci:84: warn: adding implicit cast float64(0: int32)
lib/math.ci:91: warn: adding implicit cast float32(0: int32)
lib/math.ci:97: warn: adding implicit cast float64(0: int32)
lib/math.ci:157: warn: adding implicit cast float32(2: int32)
lib/math.ci:157: warn: adding implicit cast float32(3: int32)
lib/math.ci:161: warn: adding implicit cast float64(2: int32)
lib/math.ci:161: warn: adding implicit cast float64(3: int32)
lib/math.ci:281: warn: adding implicit cast float64(0: int32)
lib/math.ci:287: warn: adding implicit cast float64(1: int32)
lib/math.ci:288: warn: adding implicit cast float64(32764: int32)
lib/math.ci:291: warn: adding implicit cast float64(quad: int32)
lib/math.ci:295: warn: adding implicit cast float64(4: int32)
lib/math.ci:295: warn: adding implicit cast int32(e - (4) * f: float64)
lib/math.ci:299: warn: adding implicit cast float64(k: int32)
lib/math.ci:304: warn: adding implicit cast float64(1: int32)
lib/math.ci:339: warn: adding implicit cast float64(0: int32)
lib/math.ci:343: warn: adding implicit cast float64(2: int32)
lib/math.ci:351: warn: adding implicit cast float64(1: int32)
lib/math.ci:359: warn: adding implicit cast float64(1: int32)
lib/math.ci:358: warn: statement should be a block statement {if (i == 3)}
lib/math.ci:354: warn: statement should be a block statement {if (i == 2)}
lib/math.ci:350: warn: statement should be a block statement {if (i == 1)}
lib/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/math.ci:371: warn: adding implicit cast float64(1: int32)
lib/math.ci:393: warn: adding implicit cast float64(0: int32)
lib/math.ci:398: warn: adding implicit cast float64(21: int32)
lib/math.ci:399: warn: adding implicit cast float64(2: int32)
lib/math.ci:404: warn: adding implicit cast float64(2: int32)
lib/math.ci:420: warn: adding implicit cast float64(0: int32)
lib/math.ci:423: warn: adding implicit cast float64(21: int32)
lib/math.ci:424: warn: adding implicit cast float64(2: int32)
lib/math.ci:426: warn: adding implicit cast float64(2: int32)
lib/math.ci:436: warn: adding implicit cast float64(0: int32)
lib/math.ci:442: warn: adding implicit cast float64(0: int32)
lib/math.ci:447: warn: adding implicit cast float64(1: int32)
lib/math.ci:452: warn: adding implicit cast float64(1: int32)
lib/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/math.ci:470: warn: adding implicit cast float64(2: int32)
lib/math.ci:493: warn: adding implicit cast float64(180: int32)
lib/math.ci:494: warn: adding implicit cast float64(180: int32)
lib/math.Complex.ci:40: debug: using default field initializer: Complex.im := 0
lib/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/string.ci:97: warn: padding `FormatFlags.padLen` with 2 bytes: (6 -> 8)
lib/string.ci:103: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:110: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:111: warn: adding implicit cast uint32(1: int32)
lib/string.ci:111: warn: adding implicit cast int32(output.length - (1): uint32)
lib/string.ci:113: warn: adding implicit cast char(0: int32)
lib/string.ci:125: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/string.ci:128: warn: adding implicit cast uint32(0: int32)
lib/string.ci:128: warn: adding implicit cast uint32(radix: int32)
lib/string.ci:129: warn: adding implicit cast uint32(radix: int32)
lib/string.ci:148: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:153: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:160: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:167: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:172: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:173: warn: adding implicit cast uint32(1: int32)
lib/string.ci:173: warn: adding implicit cast int32(output.length - (1): uint32)
lib/string.ci:175: warn: adding implicit cast char(0: int32)
lib/string.ci:195: warn: statement should be a block statement {if (forceSign)}

---------- Compile: `out/libFile.so`

---------- Compile: `out/libGfx.so`

---------- Compile: `libGfx/gfxlib.ci`
libGfx/gfxlib.ci:2: warn: adding implicit cast pointer(null: typename)
libGfx/gfxlib.ci:5: warn: adding implicit cast pointer(null: typename)
libGfx/gfxlib.color.ci:3: warn: adding implicit cast uint32(255: int32)
libGfx/gfxlib.color.ci:17: warn: adding implicit cast uint32(255: int32)
libGfx/gfxlib.color.ci:25: warn: adding implicit cast float64(255: int32)
libGfx/gfxlib.color.ci:25: warn: adding implicit cast float64(255: int32)
libGfx/gfxlib.color.ci:25: warn: adding implicit cast float64(255: int32)
libGfx/gfxlib.color.ci:26: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.color.ci:26: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.color.ci:26: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.color.ci:27: warn: adding implicit cast float64(255: int32)
libGfx/gfxlib.color.ci:28: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.color.ci:101: warn: adding implicit cast float64((1 << 16): int32)
libGfx/gfxlib.ci:13: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.ci:13: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.ci:13: warn: adding implicit cast float32(255: int32)
libGfx/gfxlib.ci:20: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:24: warn: adding implicit cast float32(360 / 60: int32)
libGfx/gfxlib.ci:27: warn: adding implicit cast float32(i: int32)
libGfx/gfxlib.ci:30: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:31: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:32: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:32: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:131: warn: adding implicit cast pointer(roi: gxRect)
libGfx/gfxlib.ci:143: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:144: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:151: warn: adding implicit cast float32(y: int32)
libGfx/gfxlib.ci:153: warn: adding implicit cast float32(x: int32)
libGfx/gfxlib.ci:167: warn: adding implicit cast pointer(roi: gxRect)
libGfx/gfxlib.ci:198: warn: padding `show.Closure.offs` with 4 bytes: (4 -> 8)
libGfx/gfxlib.ci:196: warn: padding `show.Closure` with 4 bytes: (20 -> 24)
libGfx/gfxlib.color.ci:103: warn: empty statement `;`
libGfx/gfxlib.ci:217: warn: adding implicit cast float64(100: int32)
libGfx/gfxlib.ci:218: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:222: warn: adding implicit cast int32('l': char)
libGfx/gfxlib.ci:223: warn: adding implicit cast int64(closure.mode: int32)
libGfx/gfxlib.ci:223: warn: adding implicit cast int32((closure.mode) ^ gxMesh.useLights: int64)
libGfx/gfxlib.ci:225: warn: adding implicit cast int32('0': char)
libGfx/gfxlib.ci:228: warn: adding implicit cast int32('1': char)
libGfx/gfxlib.ci:231: warn: adding implicit cast int32('2': char)
libGfx/gfxlib.ci:234: warn: adding implicit cast int32('3': char)
libGfx/gfxlib.ci:237: warn: adding implicit cast int32('t': char)
libGfx/gfxlib.ci:238: warn: adding implicit cast int64(closure.mode: int32)
libGfx/gfxlib.ci:238: warn: adding implicit cast int32((closure.mode) ^ gxMesh.useTexture: int64)
libGfx/gfxlib.ci:240: warn: adding implicit cast int32('/': char)
libGfx/gfxlib.ci:243: warn: adding implicit cast int32('\t': char)
libGfx/gfxlib.ci:246: warn: adding implicit cast int32('\r': char)
libGfx/gfxlib.ci:247: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:247: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:247: warn: adding implicit cast float32(2: int32)
libGfx/gfxlib.ci:247: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:248: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:248: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:248: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:248: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:249: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:249: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:249: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:249: warn: adding implicit cast float32(1: int32)
libGfx/gfxlib.ci:246: warn: statement should be a block statement {if (button == ('\r'))}
libGfx/gfxlib.ci:243: warn: statement should be a block statement {if (button == ('\t'))}
libGfx/gfxlib.ci:240: warn: statement should be a block statement {if (button == ('/'))}
libGfx/gfxlib.ci:237: warn: statement should be a block statement {if (button == ('t'))}
libGfx/gfxlib.ci:234: warn: statement should be a block statement {if (button == ('3'))}
libGfx/gfxlib.ci:231: warn: statement should be a block statement {if (button == ('2'))}
libGfx/gfxlib.ci:228: warn: statement should be a block statement {if (button == ('1'))}
libGfx/gfxlib.ci:225: warn: statement should be a block statement {if (button == ('0'))}
libGfx/gfxlib.ci:222: warn: statement should be a block statement {if (button == ('l'))}
libGfx/gfxlib.ci:253: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:258: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:266: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:267: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:268: warn: adding implicit cast float32(0: int32)
libGfx/gfxlib.ci:271: warn: adding implicit cast float32(dx: int32)
libGfx/gfxlib.ci:273: warn: adding implicit cast float32(dy: int32)
libGfx/gfxlib.ci:278: warn: adding implicit cast float32(-dx: int32)
libGfx/gfxlib.ci:280: warn: adding implicit cast float32(-dy: int32)
libGfx/gfxlib.ci:285: warn: adding implicit cast float32(dy: int32)
libGfx/gfxlib.ci:290: warn: adding implicit cast float32(-dx: int32)
libGfx/gfxlib.ci:292: warn: adding implicit cast float32(dy: int32)
libGfx/gfxlib.ci:287: warn: statement should be a block statement {if (button == 4)}
libGfx/gfxlib.ci:282: warn: statement should be a block statement {if (button == 3)}
libGfx/gfxlib.ci:275: warn: statement should be a block statement {if (button == 2)}
libGfx/gfxlib.ci:258: warn: statement should be a block statement {if ((action) == Gui.MOUSE_MOTION)}
libGfx/gfxlib.ci:253: warn: statement should be a block statement {if ((action) == Gui.MOUSE_PRESS)}
libGfx/gfxlib.ci:312: warn: adding implicit cast int32(gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill: int64)
libGfx/gfxlib.ci:316: warn: adding implicit cast float32(w: int32)
libGfx/gfxlib.ci:326: warn: adding implicit cast pointer(onEvent: function)
libGfx/gfxlib.ci:337: warn: padding `showWindow.Closure` with 4 bytes: (28 -> 32)
libGfx/gfxlib.ci:345: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:349: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:354: warn: adding implicit cast int64(action: int32)
libGfx/gfxlib.ci:355: warn: adding implicit cast int32(' ': char)
libGfx/gfxlib.ci:356: warn: adding implicit cast float32((System.millis() - start): int64)
libGfx/gfxlib.ci:362: warn: adding implicit cast float32((System.millis() - start): int64)
libGfx/gfxlib.ci:373: warn: adding implicit cast float64(w: int32)

---------- Generate: byte-code
lib/math.ci:60: warn: using default type initializer: Math.floor.result := 0
lib/math.ci:286: warn: using default type initializer: Math.sinCos.y := 0
lib/math.ci:289: warn: using default type initializer: e := 0
lib/math.ci:293: warn: using default type initializer: f := 0
lib/math.ci:345: warn: using default type initializer: Math.tan.e := 0
lib/math.ci:402: warn: using default type initializer: Math.sinh.result := 0
lib/string.ci:72: warn: operators `&&` and `||` does not short-circuit yet
lib/string.ci:122: warn: uninitialized variable `append.digits`
lib/string.ci:125: warn: operators `&&` and `||` does not short-circuit yet
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
libGfx/gfxlib.mat4f.ci:29: warn: uninitialized variable `.result`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.mat4f.ci:29: warn: uninitialized variable `.result`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.mat4f.ci:29: warn: uninitialized variable `.result`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.mat4f.ci:29: warn: uninitialized variable `.result`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(rhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.vec4f.ci:24: warn: argument `vec4f(lhs)` is passed to emit without cast as `vec4f`
libGfx/gfxlib.ci:21: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:35: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:38: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:41: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:44: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:47: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:49: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:130: warn: uninitialized variable `eval.rect`
libGfx/gfxlib.ci:154: warn: uninitialized variable `.result`
libGfx/gfxlib.ci:259: warn: uninitialized variable `dir`
libGfx/gfxlib.ci:265: warn: uninitialized variable `orig`
libGfx/gfxlib.ci:300: warn: uninitialized variable `show.onEvent.text`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4 -> const variable)
.field offset: int32 (size: 4 -> const variable)
.field base: function (size: 0 -> static const inline)
.field file: function (size: 0 -> static const inline)
.field line: function (size: 0 -> static const inline)
.field name: function (size: 0 -> static const inline)
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(1)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(2)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(3)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(4)
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.field pop: function (size: 0 -> static const inline)
.field swap: function (size: 0 -> static const inline)
.field bsr: function (size: 0 -> static const inline)
.field bsf: function (size: 0 -> static const inline)
.field hib: function (size: 0 -> static const inline)
.field lob: function (size: 0 -> static const inline)
.value: 0
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(18)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(19)
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(20)
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(21)
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(22)
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(23)
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(24)
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(25)
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.value: 0
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(26)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(27)
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(28)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(29)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(30)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(31)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(32)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(33)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(34)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(35)
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(36)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(37)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(38)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(39)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(40)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(41)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(42)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(43)
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0 -> static const inline)
.field fill: function (size: 0 -> static const inline)
.field copy: function (size: 0 -> static const inline)
.field move: function (size: 0 -> static const inline)
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param ptr: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(7)
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param value: int32 (size: 4 -> variable(i32))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(8)
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(9)
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(10)
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'true'
.value: 1
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'false'
.value: 0
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'byte'
.value: uint8
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'float'
.value: float32
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'double'
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0 -> static const inline)
.field not: bool (size: 0 -> static const inline)
.field set: void (size: 0 -> static const inline)
.field ret: void (size: 0 -> static const inline)
.field call: void (size: 0 -> static const inline)
.field p4x: typename (size: 16 -> static const typename(val))
.field dup: void (size: 0 -> static const typename(void))
.field load: void (size: 0 -> static const typename(void))
.field store: void (size: 0 -> static const typename(void))
.field cmt: void (size: 0 -> static const typename(void))
.field and: void (size: 0 -> static const typename(void))
.field or: void (size: 0 -> static const typename(void))
.field xor: void (size: 0 -> static const typename(void))
.field shl: void (size: 0 -> static const typename(void))
.field shr: void (size: 0 -> static const typename(void))
.field neg: void (size: 0 -> static const typename(void))
.field add: void (size: 0 -> static const typename(void))
.field sub: void (size: 0 -> static const typename(void))
.field mul: void (size: 0 -> static const typename(void))
.field div: void (size: 0 -> static const typename(void))
.field mod: void (size: 0 -> static const typename(void))
.field ceq: void (size: 0 -> static const typename(void))
.field clt: void (size: 0 -> static const typename(void))
.field cgt: void (size: 0 -> static const typename(void))
.field min: void (size: 0 -> static const typename(void))
.field max: void (size: 0 -> static const typename(void))
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0 -> static const inline)
.field dp4: float32 (size: 0 -> static const inline)
.field dph: float32 (size: 0 -> static const inline)
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0 -> static const inline)
.field x2: int64 (size: 0 -> static const inline)
.field x4: emit.p4x (size: 0 -> static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0 -> static const inline)
.field z64: int64 (size: 0 -> static const inline)
.field z128: emit.p4x (size: 0 -> static const inline)
.field i8: int32 (size: 0 -> static const inline)
.field i16: int32 (size: 0 -> static const inline)
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field i128: emit.p4x (size: 0 -> static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0 -> static const inline)
.field i16: void (size: 0 -> static const inline)
.field i32: void (size: 0 -> static const inline)
.field i64: void (size: 0 -> static const inline)
.field i128: void (size: 0 -> static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
}
emit.mul: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
.field p4f: bool (size: 0 -> static const inline)
.field p2d: bool (size: 0 -> static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0 -> inline)
.value: nfc(0)
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0 -> static const i64)
.field error: int64 (size: 0 -> static const i64)
.field warn: int64 (size: 0 -> static const i64)
.field info: int64 (size: 0 -> static const i64)
.field debug: int64 (size: 0 -> static const i64)
.field verbose: int64 (size: 0 -> static const i64)
.field noTrace: int64 (size: 0 -> static const i64)
.field defTrace: int64 (size: 0 -> static const i64)
.param .result: void (size: 0 -> inline)
.param file: char[*] (size: 4 -> variable(ref))
.param line: int32 (size: 4 -> variable(i32))
.param level: int32 (size: 4 -> variable(i32))
.param trace: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.param inspect: variant (size: 8 -> variable(var))
.value: nfc(5)
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4 -> inline)
.param args: pointer (size: 4 -> variable(ref))
.param action: function (size: 4 -> variable(ref))
.value: nfc(6)
}
System: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'System'
.field exit: function (size: 0 -> static const inline)
.field srand: function (size: 0 -> static const inline)
.field rand: function (size: 0 -> static const inline)
.field time: function (size: 0 -> static const inline)
.field clock: function (size: 0 -> static const inline)
.field millis: function (size: 0 -> static const inline)
.field sleep: function (size: 0 -> static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0 -> inline)
.param code: int32 (size: 4 -> variable(i32))
.value: nfc(11)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0 -> inline)
.param seed: int32 (size: 4 -> variable(i32))
.value: nfc(12)
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(13)
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(14)
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(15)
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8 -> inline)
.value: nfc(16)
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0 -> inline)
.param millis: int64 (size: 8 -> variable(i64))
.value: nfc(17)
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.verbose, raise.noTrace, message, inspect)
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.verbose, raise.noTrace, message, null)
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.defTrace, message, inspect)
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.defTrace, message, null)
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.noTrace, message, inspect)
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.noTrace, message, null)
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.info, raise.noTrace, message, inspect)
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.info, raise.noTrace, message, null)
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.warn, raise.noTrace, message, inspect)
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.warn, raise.noTrace, message, null)
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.error, raise.defTrace, message, inspect)
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.error, raise.defTrace, message, null)
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.abort, raise.defTrace, message, inspect)
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.abort, raise.defTrace, message, null)
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0 -> void)
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: void(condition ? void(0) : abort(message, inspect))
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.value: void(condition ? void(0) : abort(message))
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8 -> const variable(var))
.field returned: variant (size: 8 -> const variable(var))
.field message: char[*] (size: 4 -> const variable(ref))
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'message'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 83
.name: 'assertEq'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0 -> variable(void))
.param expected: int32 (size: 4 -> variable(i32))
.param returned: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.value: {
	if (returned == expected) {
		return;
	}
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.message := (message);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (83 bytes)
	lib/stdlib.ci:39: (10 bytes): if (returned == expected)
	<assertEq+?>:    dup.x1 sp(2)
	<assertEq+?>:    dup.x1 sp(4)
	<assertEq+?>:    ceq.i32
	<assertEq+?>:    jz <assertEq+?>
	lib/stdlib.ci:40: (1 bytes): return;
	<assertEq+?>:    ret
	lib/stdlib.ci:42: (30 bytes): details: NotEquals := {...}
	<assertEq+?>:    inc.sp(+24)
	lib/stdlib.ci:43: (11 bytes): details.expected := (expected);
	<assertEq+?>:    load.ref .?????? ;int32
	<assertEq+?>:    load.sp(+40)
	<assertEq+?>:    set.x2 sp(2)
	lib/stdlib.ci:44: (11 bytes): details.returned := (returned);
	<assertEq+?>:    load.ref .?????? ;int32
	<assertEq+?>:    load.sp(+36)
	<assertEq+?>:    set.x2 sp(4)
	lib/stdlib.ci:45: (4 bytes): details.message := (message);
	<assertEq+?>:    dup.x1 sp(7)
	<assertEq+?>:    set.x1 sp(5)
	lib/stdlib.ci:47: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>:    load.ref .?????? ;"lib/stdlib.ci"
	<assertEq+?>:    load.c32 47
	<assertEq+?>:    load.c32 -2
	<assertEq+?>:    load.c32 128
	<assertEq+?>:    load.ref .?????? ;"assertion failed"
	<assertEq+?>:    load.ref .?????? ;NotEquals
	<assertEq+?>:    load.sp(+24)
	<assertEq+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>:    inc.sp(-24)
	<assertEq+?>:    ret
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0 -> void)
.param expected: int32 (size: 4 -> i32)
.param returned: int32 (size: 4 -> i32)
.value: assertEq(expected, returned, null)
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'lib/stdlib.ci:53'
.param .result: int32 (size: 4 -> i32)
.param type: typename (size: 4 -> ref)
.value: int32(type.size)
}
Math: typename {
.kind: static const typename(val)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'lib/math.ci:3'
.field pi: float64 (size: 8 -> static const val)
.field e: float64 (size: 8 -> static const val)
.field ln2: float64 (size: 8 -> static const val)
.field log2E: float64 (size: 8 -> static const val)
.field ln10: float64 (size: 8 -> static const val)
.field log10E: float64 (size: 8 -> static const val)
.field phi: float64 (size: 8 -> static const val)
.field sqrt2: float64 (size: 8 -> static const val)
.field sqrtE: float64 (size: 8 -> static const val)
.field sqrtPi: float64 (size: 8 -> static const val)
.field sqrtPhi: float64 (size: 8 -> static const val)
.field nan: float64 (size: 8 -> static const val)
.field inf: float64 (size: 8 -> static const val)
.field modf: function (size: 104 -> static const function)
.field floor: function (size: 35 -> static const function)
.field ceil: function (size: 0 -> static inline)
.field round: function (size: 0 -> static inline)
.field sign: function (size: 36 -> static const function)
.field sign: function (size: 36 -> static const function)
.field abs: function (size: 19 -> static const function)
.field abs: function (size: 19 -> static const function)
.field min: function (size: 19 -> static const function)
.field min: function (size: 19 -> static const function)
.field max: function (size: 19 -> static const function)
.field max: function (size: 19 -> static const function)
.field clamp: function (size: 33 -> static const function)
.field clamp: function (size: 33 -> static const function)
.field lerp: function (size: 14 -> static const function)
.field lerp: function (size: 14 -> static const function)
.field smooth: function (size: 57 -> static const function)
.field smooth: function (size: 73 -> static const function)
.field cmp: function (size: 57 -> static const function)
.field cmp: function (size: 57 -> static const function)
.field sinCos: function (size: 348 -> static const function)
.field sin: function (size: 0 -> static inline)
.field cos: function (size: 0 -> static inline)
.field tan: function (size: 387 -> static const function)
.field sinh: function (size: 248 -> static const function)
.field cosh: function (size: 75 -> static const function)
.field asin: function (size: 183 -> static const function)
.field acos: function (size: 0 -> static inline)
.field deg2rad: function (size: 0 -> static inline)
.field rad2deg: function (size: 0 -> static inline)
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'pi'
.file: 'lib/math.ci:7'
.owner: Math
.value: 3.141593
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'e'
.file: 'lib/math.ci:8'
.owner: Math
.value: 2.718282
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln2'
.file: 'lib/math.ci:9'
.owner: Math
.value: 0.693147
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log2E'
.file: 'lib/math.ci:10'
.owner: Math
.value: 1.000000 / ln2
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln10'
.file: 'lib/math.ci:11'
.owner: Math
.value: 2.302585
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log10E'
.file: 'lib/math.ci:12'
.owner: Math
.value: 1.000000 / ln10
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'phi'
.file: 'lib/math.ci:13'
.owner: Math
.value: 1.618034
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrt2'
.file: 'lib/math.ci:14'
.owner: Math
.value: 1.414214
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtE'
.file: 'lib/math.ci:15'
.owner: Math
.value: 1.648721
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPi'
.file: 'lib/math.ci:16'
.owner: Math
.value: 1.772454
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPhi'
.file: 'lib/math.ci:17'
.owner: Math
.value: 1.272020
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'nan'
.file: 'lib/math.ci:18'
.owner: Math
.value: (0) / 0.000000
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'inf'
.file: 'lib/math.ci:19'
.owner: Math
.value: (1) / 0.000000
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 104
.name: 'modf'
.file: 'lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.param intPart: float64 (size: 4 -> variable(ref))
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (104 bytes)
	lib/math.ci:23: (70 bytes): if (x < (1))
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.f64 1.000000
	<modf+?>:    clt.f64
	<modf+?>:    jz <modf+?>
	lib/math.ci:24: (45 bytes): if (x < (0))
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.z64
	<modf+?>:    clt.f64
	<modf+?>:    jz <modf+?>
	lib/math.ci:25: (17 bytes): result: float64 := -modf(-x, intPart)
	<modf+?>:    load.z64
	<modf+?>:    dup.x2 sp(4)
	<modf+?>:    neg.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>:    call
	<modf+?>:    inc.sp(-12)
	<modf+?>:    neg.f64
	lib/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>:    dup.x1 sp(3)
	<modf+?>:    load.i64
	<modf+?>:    neg.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    store.i64
	lib/math.ci:27: (9 bytes): return .result := result;
	<modf+?>:    dup.x2 sp(0)
	<modf+?>:    set.x2 sp(8)
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
	<modf+?>:    inc.sp(-8)
	lib/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>:    load.z64
	<modf+?>:    dup.x1 sp(3)
	<modf+?>:    store.i64
	lib/math.ci:30: (5 bytes): return .result := x;
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    set.x2 sp(6)
	<modf+?>:    ret
	lib/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.f64 1.000000
	<modf+?>:    mod.f64
	lib/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>:    dup.x2 sp(4)
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    sub.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    store.i64
	lib/math.ci:34: (9 bytes): return .result := result;
	<modf+?>:    dup.x2 sp(0)
	<modf+?>:    set.x2 sp(8)
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 35
.name: 'floor'
.file: 'lib/math.ci:59'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	result: float64;
	modf(x, result);
	return .result := result;
}
.instructions: (35 bytes)
	lib/math.ci:60: (1 bytes): result: float64
	<floor+?>:    load.z128
	lib/math.ci:61: (20 bytes): modf(x, result);
	<floor+?>:    dup.x2 sp(5)
	<floor+?>:    load.sp(+16)
	<floor+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>:    call
	<floor+?>:    inc.sp(-12)
	<floor+?>:    inc.sp(-8)
	lib/math.ci:62: (9 bytes): return .result := result;
	<floor+?>:    dup.x2 sp(0)
	<floor+?>:    set.x2 sp(7)
	<floor+?>:    inc.sp(-8)
	<floor+?>:    ret
	<floor+?>:    inc.sp(-8)
	<floor+?>:    ret
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'lib/math.ci:64'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: -floor(-x)
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'lib/math.ci:65'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: floor(x + 0.500000)
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/math.ci:71'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param x: float32 (size: 4 -> variable(f32))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/math.ci:72: (12 bytes): if (x == (0))
	<sign+?>:    dup.x1 sp(1)
	<sign+?>:    load.z32
	<sign+?>:    ceq.f32
	<sign+?>:    jz <sign+?>
	lib/math.ci:73: (4 bytes): return .result := 0;
	<sign+?>:    load.z32
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
	lib/math.ci:75: (16 bytes): if (x < (0))
	<sign+?>:    dup.x1 sp(1)
	<sign+?>:    load.z32
	<sign+?>:    clt.f32
	<sign+?>:    jz <sign+?>
	lib/math.ci:76: (8 bytes): return .result := -1;
	<sign+?>:    load.c32 -1
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
	lib/math.ci:78: (8 bytes): return .result := 1;
	<sign+?>:    load.c32 1
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/math.ci:80'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/math.ci:81: (12 bytes): if (x == (0))
	<sign+?>:    dup.x2 sp(1)
	<sign+?>:    load.z64
	<sign+?>:    ceq.f64
	<sign+?>:    jz <sign+?>
	lib/math.ci:82: (4 bytes): return .result := 0;
	<sign+?>:    load.z32
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
	lib/math.ci:84: (16 bytes): if (x < (0))
	<sign+?>:    dup.x2 sp(1)
	<sign+?>:    load.z64
	<sign+?>:    clt.f64
	<sign+?>:    jz <sign+?>
	lib/math.ci:85: (8 bytes): return .result := -1;
	<sign+?>:    load.c32 -1
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
	lib/math.ci:87: (8 bytes): return .result := 1;
	<sign+?>:    load.c32 1
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'abs'
.file: 'lib/math.ci:90'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param x: float32 (size: 4 -> variable(f32))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (19 bytes)
	lib/math.ci:91: (14 bytes): if (x < (0))
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    load.z32
	<abs+?>:    clt.f32
	<abs+?>:    jz <abs+?>
	lib/math.ci:92: (6 bytes): return .result := -x;
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    neg.f32
	<abs+?>:    set.x1 sp(3)
	<abs+?>:    ret
	lib/math.ci:94: (5 bytes): return .result := x;
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    set.x1 sp(3)
	<abs+?>:    ret
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'abs'
.file: 'lib/math.ci:96'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (19 bytes)
	lib/math.ci:97: (14 bytes): if (x < (0))
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    load.z64
	<abs+?>:    clt.f64
	<abs+?>:    jz <abs+?>
	lib/math.ci:98: (6 bytes): return .result := -x;
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    neg.f64
	<abs+?>:    set.x2 sp(5)
	<abs+?>:    ret
	lib/math.ci:100: (5 bytes): return .result := x;
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    set.x2 sp(5)
	<abs+?>:    ret
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'min'
.file: 'lib/math.ci:103'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:104: (14 bytes): if (a < b)
	<min+?>:    dup.x1 sp(2)
	<min+?>:    dup.x1 sp(2)
	<min+?>:    clt.f32
	<min+?>:    jz <min+?>
	lib/math.ci:105: (5 bytes): return .result := a;
	<min+?>:    dup.x1 sp(2)
	<min+?>:    set.x1 sp(4)
	<min+?>:    ret
	lib/math.ci:107: (5 bytes): return .result := b;
	<min+?>:    dup.x1 sp(1)
	<min+?>:    set.x1 sp(4)
	<min+?>:    ret
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'min'
.file: 'lib/math.ci:109'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:110: (14 bytes): if (a < b)
	<min+?>:    dup.x2 sp(3)
	<min+?>:    dup.x2 sp(3)
	<min+?>:    clt.f64
	<min+?>:    jz <min+?>
	lib/math.ci:111: (5 bytes): return .result := a;
	<min+?>:    dup.x2 sp(3)
	<min+?>:    set.x2 sp(7)
	<min+?>:    ret
	lib/math.ci:113: (5 bytes): return .result := b;
	<min+?>:    dup.x2 sp(1)
	<min+?>:    set.x2 sp(7)
	<min+?>:    ret
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'max'
.file: 'lib/math.ci:116'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:117: (14 bytes): if (a > b)
	<max+?>:    dup.x1 sp(2)
	<max+?>:    dup.x1 sp(2)
	<max+?>:    cgt.f32
	<max+?>:    jz <max+?>
	lib/math.ci:118: (5 bytes): return .result := a;
	<max+?>:    dup.x1 sp(2)
	<max+?>:    set.x1 sp(4)
	<max+?>:    ret
	lib/math.ci:120: (5 bytes): return .result := b;
	<max+?>:    dup.x1 sp(1)
	<max+?>:    set.x1 sp(4)
	<max+?>:    ret
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'max'
.file: 'lib/math.ci:122'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:123: (14 bytes): if (a > b)
	<max+?>:    dup.x2 sp(3)
	<max+?>:    dup.x2 sp(3)
	<max+?>:    cgt.f64
	<max+?>:    jz <max+?>
	lib/math.ci:124: (5 bytes): return .result := a;
	<max+?>:    dup.x2 sp(3)
	<max+?>:    set.x2 sp(7)
	<max+?>:    ret
	lib/math.ci:126: (5 bytes): return .result := b;
	<max+?>:    dup.x2 sp(1)
	<max+?>:    set.x2 sp(7)
	<max+?>:    ret
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 33
.name: 'clamp'
.file: 'lib/math.ci:129'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (33 bytes)
	lib/math.ci:130: (14 bytes): if (t < a)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    clt.f32
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:131: (5 bytes): return .result := a;
	<clamp+?>:    dup.x1 sp(2)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
	lib/math.ci:133: (14 bytes): if (t > b)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    dup.x1 sp(2)
	<clamp+?>:    cgt.f32
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:134: (5 bytes): return .result := b;
	<clamp+?>:    dup.x1 sp(1)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
	lib/math.ci:136: (5 bytes): return .result := t;
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 33
.name: 'clamp'
.file: 'lib/math.ci:138'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (33 bytes)
	lib/math.ci:139: (14 bytes): if (t < a)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    clt.f64
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:140: (5 bytes): return .result := a;
	<clamp+?>:    dup.x2 sp(3)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
	lib/math.ci:142: (14 bytes): if (t > b)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    dup.x2 sp(3)
	<clamp+?>:    cgt.f64
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:143: (5 bytes): return .result := b;
	<clamp+?>:    dup.x2 sp(1)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
	lib/math.ci:145: (5 bytes): return .result := t;
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'lerp'
.file: 'lib/math.ci:148'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	return .result := a + t * (b - a);
}
.instructions: (14 bytes)
	lib/math.ci:149: (14 bytes): return .result := a + t * (b - a);
	<lerp+?>:    dup.x1 sp(2)
	<lerp+?>:    dup.x1 sp(4)
	<lerp+?>:    dup.x1 sp(3)
	<lerp+?>:    dup.x1 sp(5)
	<lerp+?>:    sub.f32
	<lerp+?>:    mul.f32
	<lerp+?>:    add.f32
	<lerp+?>:    set.x1 sp(5)
	<lerp+?>:    ret
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'lerp'
.file: 'lib/math.ci:151'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	return .result := a + t * (b - a);
}
.instructions: (14 bytes)
	lib/math.ci:152: (14 bytes): return .result := a + t * (b - a);
	<lerp+?>:    dup.x2 sp(3)
	<lerp+?>:    dup.x2 sp(7)
	<lerp+?>:    dup.x2 sp(5)
	<lerp+?>:    dup.x2 sp(9)
	<lerp+?>:    sub.f64
	<lerp+?>:    mul.f64
	<lerp+?>:    add.f64
	<lerp+?>:    set.x2 sp(9)
	<lerp+?>:    ret
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'smooth'
.file: 'lib/math.ci:155'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	return .result := t * t * ((3) - (2) * t);
}
.instructions: (57 bytes)
	lib/math.ci:156: (34 bytes): t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	<smooth+?>:    load.z32
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    sub.f32
	<smooth+?>:    dup.x1 sp(3)
	<smooth+?>:    dup.x1 sp(5)
	<smooth+?>:    sub.f32
	<smooth+?>:    div.f32
	<smooth+?>:    load.f32 0.000000
	<smooth+?>:    load.f32 1.000000
	<smooth+?>:    load.ref .?????? ;Math.clamp(t: float32, a: float32, b: float32): float32
	<smooth+?>:    call
	<smooth+?>:    inc.sp(-12)
	<smooth+?>:    set.x1 sp(4)
	lib/math.ci:157: (23 bytes): return .result := t * t * ((3) - (2) * t);
	<smooth+?>:    dup.x1 sp(3)
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    mul.f32
	<smooth+?>:    load.f32 3.000000
	<smooth+?>:    load.f32 2.000000
	<smooth+?>:    dup.x1 sp(6)
	<smooth+?>:    mul.f32
	<smooth+?>:    sub.f32
	<smooth+?>:    mul.f32
	<smooth+?>:    set.x1 sp(5)
	<smooth+?>:    ret
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'smooth'
.file: 'lib/math.ci:159'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	return .result := t * t * ((3) - (2) * t);
}
.instructions: (73 bytes)
	lib/math.ci:160: (42 bytes): t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	<smooth+?>:    load.z64
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    sub.f64
	<smooth+?>:    dup.x2 sp(5)
	<smooth+?>:    dup.x2 sp(9)
	<smooth+?>:    sub.f64
	<smooth+?>:    div.f64
	<smooth+?>:    load.f64 0.000000
	<smooth+?>:    load.f64 1.000000
	<smooth+?>:    load.ref .?????? ;Math.clamp(t: float64, a: float64, b: float64): float64
	<smooth+?>:    call
	<smooth+?>:    inc.sp(-24)
	<smooth+?>:    set.x2 sp(7)
	lib/math.ci:161: (31 bytes): return .result := t * t * ((3) - (2) * t);
	<smooth+?>:    dup.x2 sp(5)
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    mul.f64
	<smooth+?>:    load.f64 3.000000
	<smooth+?>:    load.f64 2.000000
	<smooth+?>:    dup.x2 sp(11)
	<smooth+?>:    mul.f64
	<smooth+?>:    sub.f64
	<smooth+?>:    mul.f64
	<smooth+?>:    set.x2 sp(9)
	<smooth+?>:    ret
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/math.ci:239'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.param eps: float32 (size: 4 -> variable(f32))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/math.ci:240: (53 bytes): if (a < b)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:241: (20 bytes): if (eps < (b - a))
	<cmp+?>:    dup.x1 sp(1)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    dup.x1 sp(5)
	<cmp+?>:    sub.f32
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:242: (8 bytes): return .result := -1;
	<cmp+?>:    load.c32 -1
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
	<cmp+?>:    jmp <cmp+?>
	lib/math.ci:246: (20 bytes): if (eps < (a - b))
	<cmp+?>:    dup.x1 sp(1)
	<cmp+?>:    dup.x1 sp(4)
	<cmp+?>:    dup.x1 sp(4)
	<cmp+?>:    sub.f32
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:247: (8 bytes): return .result := +1;
	<cmp+?>:    load.c32 1
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
	lib/math.ci:250: (4 bytes): return .result := 0;
	<cmp+?>:    load.z32
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/math.ci:252'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.param eps: float64 (size: 8 -> variable(f64))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/math.ci:253: (53 bytes): if (a < b)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:254: (20 bytes): if (eps < (b - a))
	<cmp+?>:    dup.x2 sp(1)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    dup.x2 sp(9)
	<cmp+?>:    sub.f64
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:255: (8 bytes): return .result := -1;
	<cmp+?>:    load.c32 -1
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
	<cmp+?>:    jmp <cmp+?>
	lib/math.ci:259: (20 bytes): if (eps < (a - b))
	<cmp+?>:    dup.x2 sp(1)
	<cmp+?>:    dup.x2 sp(7)
	<cmp+?>:    dup.x2 sp(7)
	<cmp+?>:    sub.f64
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:260: (8 bytes): return .result := +1;
	<cmp+?>:    load.c32 1
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
	lib/math.ci:263: (4 bytes): return .result := 0;
	<cmp+?>:    load.z32
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 348
.name: 'sinCos'
.file: 'lib/math.ci:266'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param arg: float64 (size: 8 -> variable(f64))
.param quad: int32 (size: 4 -> variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (348 bytes)
	lib/math.ci:280: (2 bytes): x: float64 := arg
	<sinCos+?>:    dup.x2 sp(2)
	lib/math.ci:281: (21 bytes): if (x < (0))
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    load.z64
	<sinCos+?>:    clt.f64
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:282: (5 bytes): x := -x;
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    neg.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:283: (8 bytes): quad := quad + 2;
	<sinCos+?>:    dup.x1 sp(3)
	<sinCos+?>:    inc.i32(+2)
	<sinCos+?>:    set.x1 sp(4)
	lib/math.ci:286: (1 bytes): y: float64
	<sinCos+?>:    load.z64
	lib/math.ci:287: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 1.000000
	<sinCos+?>:    load.f64 1.570796
	<sinCos+?>:    div.f64
	<sinCos+?>:    mul.f64
	<sinCos+?>:    set.x2 sp(4)
	lib/math.ci:288: (124 bytes): if (x > (32764))
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 32764.000000
	<sinCos+?>:    cgt.f64
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:289: (1 bytes): e: float64
	<sinCos+?>:    load.z128
	lib/math.ci:290: (18 bytes): y := modf(x, e);
	<sinCos+?>:    dup.x2 sp(6)
	<sinCos+?>:    load.sp(+16)
	<sinCos+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>:    call
	<sinCos+?>:    inc.sp(-12)
	<sinCos+?>:    set.x2 sp(4)
	lib/math.ci:291: (4 bytes): e := e + (quad);
	<sinCos+?>:    dup.x1 sp(7)
	<sinCos+?>:    i32.2f64
	<sinCos+?>:    add.f64
	lib/math.ci:293: (1 bytes): f: float64
	<sinCos+?>:    load.z128
	lib/math.ci:294: (30 bytes): modf(0.250000 * e, f);
	<sinCos+?>:    load.f64 0.250000
	<sinCos+?>:    dup.x2 sp(6)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.sp(+16)
	<sinCos+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>:    call
	<sinCos+?>:    inc.sp(-12)
	<sinCos+?>:    inc.sp(-8)
	lib/math.ci:295: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 4.000000
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    sub.f64
	<sinCos+?>:    f64.2i32
	<sinCos+?>:    set.x1 sp(10)
	<sinCos+?>:    inc.sp(-16)
	<sinCos+?>:    jmp <sinCos+?>
	lib/math.ci:298: (3 bytes): k: int32 := x
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    f64.2i32
	lib/math.ci:299: (8 bytes): y := x - (k);
	<sinCos+?>:    dup.x2 sp(3)
	<sinCos+?>:    dup.x1 sp(2)
	<sinCos+?>:    i32.2f64
	<sinCos+?>:    sub.f64
	<sinCos+?>:    set.x2 sp(3)
	lib/math.ci:300: (7 bytes): quad := quad + k;
	<sinCos+?>:    dup.x1 sp(6)
	<sinCos+?>:    dup.x1 sp(1)
	<sinCos+?>:    add.i32
	<sinCos+?>:    set.x1 sp(7)
	lib/math.ci:301: (6 bytes): quad := quad & 3;
	<sinCos+?>:    dup.x1 sp(6)
	<sinCos+?>:    b32.and 0x003
	<sinCos+?>:    set.x1 sp(7)
	<sinCos+?>:    inc.sp(-4)
	lib/math.ci:303: (22 bytes): if (quad & 1)
	<sinCos+?>:    dup.x1 sp(5)
	<sinCos+?>:    b32.and 0x001
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:304: (14 bytes): y := (1) - y;
	<sinCos+?>:    load.f64 1.000000
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    sub.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:306: (17 bytes): if (quad > 1)
	<sinCos+?>:    dup.x1 sp(5)
	<sinCos+?>:    load.c32 1
	<sinCos+?>:    cgt.i32
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:307: (5 bytes): y := -y;
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    neg.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:310: (5 bytes): ysq: float64 := y * y
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	lib/math.ci:311: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>:    load.f64 145.968841
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 -13847.272500
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 440103.053538
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 -4942908.100903
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 13578840.978774
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	lib/math.ci:312: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 132.653491
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 9463.096102
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 408179.225234
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 8644558.652923
	<sinCos+?>:    add.f64
	lib/math.ci:313: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    div.f64
	<sinCos+?>:    set.x2 sp(16)
	<sinCos+?>:    inc.sp(-40)
	<sinCos+?>:    ret
	<sinCos+?>:    inc.sp(-40)
	<sinCos+?>:    ret
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/math.ci:317'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param arg: float64 (size: 8 -> f64)
.value: sinCos(arg, 0)
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/math.ci:320'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param arg: float64 (size: 8 -> f64)
.value: sinCos(abs(arg), 1)
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 387
.name: 'tan'
.file: 'lib/math.ci:323'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param arg: float64 (size: 8 -> variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else {
		if (i == 1) {
			x := (1) - x;
			complement := true;
		}
		else {
			if (i == 2) {
				negate := !negate;
				complement := true;
			}
			else {
				if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
			}
		}
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (387 bytes)
	lib/math.ci:336: (1 bytes): complement: bool := false
	<tan+?>:    load.z32
	lib/math.ci:337: (1 bytes): negate: bool := false
	<tan+?>:    load.z32
	lib/math.ci:339: (23 bytes): if (arg < (0))
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    load.z64
	<tan+?>:    clt.f64
	<tan+?>:    jz <tan+?>
	lib/math.ci:340: (5 bytes): arg := -arg;
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    neg.f64
	<tan+?>:    set.x2 sp(5)
	lib/math.ci:341: (10 bytes): negate := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+4)
	<tan+?>:    store.i8
	lib/math.ci:343: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>:    load.f64 2.000000
	<tan+?>:    dup.x2 sp(5)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 1.570796
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(5)
	lib/math.ci:345: (1 bytes): e: float64
	<tan+?>:    load.z128
	lib/math.ci:346: (16 bytes): x: float64 := modf(arg, e)
	<tan+?>:    dup.x2 sp(7)
	<tan+?>:    load.sp(+16)
	<tan+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>:    call
	<tan+?>:    inc.sp(-12)
	lib/math.ci:347: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    f64.2i32
	<tan+?>:    load.c32 4
	<tan+?>:    mod.i32
	lib/math.ci:349: (122 bytes): if (i == 0)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.z32
	<tan+?>:    ceq.i32
	<tan+?>:    jnz <tan+?>
	lib/math.ci:350: (114 bytes): if (i == 1)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 1
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:351: (14 bytes): x := (1) - x;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    sub.f64
	<tan+?>:    set.x2 sp(3)
	lib/math.ci:352: (10 bytes): complement := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+28)
	<tan+?>:    store.i8
	<tan+?>:    jmp <tan+?>
	lib/math.ci:354: (74 bytes): if (i == 2)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 2
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:355: (11 bytes): negate := !negate;
	<tan+?>:    load.sp(+20)
	<tan+?>:    load.i8
	<tan+?>:    not.b32
	<tan+?>:    load.sp(+24)
	<tan+?>:    store.i8
	lib/math.ci:356: (10 bytes): complement := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+28)
	<tan+?>:    store.i8
	<tan+?>:    jmp <tan+?>
	lib/math.ci:358: (37 bytes): if (i == 3)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 3
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:359: (14 bytes): x := (1) - x;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    sub.f64
	<tan+?>:    set.x2 sp(3)
	lib/math.ci:360: (11 bytes): negate := !negate;
	<tan+?>:    load.sp(+20)
	<tan+?>:    load.i8
	<tan+?>:    not.b32
	<tan+?>:    load.sp(+24)
	<tan+?>:    store.i8
	lib/math.ci:363: (5 bytes): xsq: float64 := x * x
	<tan+?>:    dup.x2 sp(1)
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    mul.f64
	lib/math.ci:364: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>:    load.f64 0.000034
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 0.034226
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -15.506857
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 1055.970902
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -13068.202648
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(5)
	<tan+?>:    mul.f64
	lib/math.ci:365: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    load.f64 -155.503316
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(4)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 4765.751363
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(4)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -16638.952389
	<tan+?>:    add.f64
	<tan+?>:    div.f64
	lib/math.ci:367: (49 bytes): if (complement)
	<tan+?>:    load.sp(+40)
	<tan+?>:    load.i8
	<tan+?>:    jz <tan+?>
	lib/math.ci:368: (26 bytes): if (result == (0))
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    load.z64
	<tan+?>:    ceq.f64
	<tan+?>:    jz <tan+?>
	lib/math.ci:369: (18 bytes): return .result := nan;
	<tan+?>:    load.z64
	<tan+?>:    load.f64 0.000000
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	lib/math.ci:371: (14 bytes): result := (1) / result;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(2)
	lib/math.ci:373: (19 bytes): if (negate)
	<tan+?>:    load.sp(+36)
	<tan+?>:    load.i8
	<tan+?>:    jz <tan+?>
	lib/math.ci:374: (10 bytes): return .result := -result;
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    neg.f64
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	lib/math.ci:376: (9 bytes): return .result := result;
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 248
.name: 'sinh'
.file: 'lib/math.ci:380'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (248 bytes)
	lib/math.ci:392: (1 bytes): negate: bool := false
	<sinh+?>:    load.z32
	lib/math.ci:393: (23 bytes): if (x < (0))
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.z64
	<sinh+?>:    clt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:394: (5 bytes): x := -x;
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    neg.f64
	<sinh+?>:    set.x2 sp(4)
	lib/math.ci:395: (10 bytes): negate := true;
	<sinh+?>:    load.c32 1
	<sinh+?>:    load.sp(+4)
	<sinh+?>:    store.i8
	lib/math.ci:398: (39 bytes): if (x > (21))
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.f64 21.000000
	<sinh+?>:    cgt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:399: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    load.f64 2.000000
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(6)
	<sinh+?>:    inc.sp(-4)
	<sinh+?>:    ret
	lib/math.ci:402: (1 bytes): result: float64
	<sinh+?>:    load.z64
	lib/math.ci:403: (151 bytes): if (x > 0.500000)
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    load.f64 0.500000
	<sinh+?>:    cgt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:404: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    dup.x2 sp(6)
	<sinh+?>:    neg.f64
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    sub.f64
	<sinh+?>:    load.f64 2.000000
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(2)
	<sinh+?>:    jmp <sinh+?>
	lib/math.ci:407: (5 bytes): sq: float64 := x * x
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    dup.x2 sp(6)
	<sinh+?>:    mul.f64
	lib/math.ci:408: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>:    load.f64 -26.305632
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -2894.211356
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -89912.720220
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -630767.364050
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(8)
	<sinh+?>:    mul.f64
	<sinh+?>:    set.x2 sp(4)
	lib/math.ci:409: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.f64 -173.678954
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 15215.173788
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -630767.364050
	<sinh+?>:    add.f64
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(4)
	<sinh+?>:    inc.sp(-8)
	lib/math.ci:412: (19 bytes): if (negate)
	<sinh+?>:    load.sp(+8)
	<sinh+?>:    load.i8
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:413: (10 bytes): return .result := -result;
	<sinh+?>:    dup.x2 sp(0)
	<sinh+?>:    neg.f64
	<sinh+?>:    set.x2 sp(8)
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
	lib/math.ci:415: (9 bytes): return .result := result;
	<sinh+?>:    dup.x2 sp(0)
	<sinh+?>:    set.x2 sp(8)
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'lib/math.ci:419'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	lib/math.ci:420: (13 bytes): if (x < (0))
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    load.z64
	<cosh+?>:    clt.f64
	<cosh+?>:    jz <cosh+?>
	lib/math.ci:421: (5 bytes): x := -x;
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    neg.f64
	<cosh+?>:    set.x2 sp(3)
	lib/math.ci:423: (35 bytes): if (x > (21))
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    load.f64 21.000000
	<cosh+?>:    cgt.f64
	<cosh+?>:    jz <cosh+?>
	lib/math.ci:424: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    load.f64 2.000000
	<cosh+?>:    div.f64
	<cosh+?>:    set.x2 sp(5)
	<cosh+?>:    ret
	lib/math.ci:426: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    dup.x2 sp(3)
	<cosh+?>:    neg.f64
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    add.f64
	<cosh+?>:    load.f64 2.000000
	<cosh+?>:    div.f64
	<cosh+?>:    set.x2 sp(5)
	<cosh+?>:    ret
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 183
.name: 'asin'
.file: 'lib/math.ci:435'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (183 bytes)
	lib/math.ci:436: (13 bytes): if (x == (0))
	<asin+?>:    dup.x2 sp(1)
	<asin+?>:    load.z64
	<asin+?>:    ceq.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:438: (5 bytes): return .result := x;
	<asin+?>:    dup.x2 sp(1)
	<asin+?>:    set.x2 sp(5)
	<asin+?>:    ret
	lib/math.ci:441: (1 bytes): negate: bool := false
	<asin+?>:    load.z32
	lib/math.ci:442: (23 bytes): if (x < (0))
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    load.z64
	<asin+?>:    clt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:443: (10 bytes): negate := true;
	<asin+?>:    load.c32 1
	<asin+?>:    load.sp(+4)
	<asin+?>:    store.i8
	lib/math.ci:444: (5 bytes): x := -x;
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    neg.f64
	<asin+?>:    set.x2 sp(4)
	lib/math.ci:447: (34 bytes): if (x > (1))
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    load.f64 1.000000
	<asin+?>:    cgt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:449: (18 bytes): return .result := nan;
	<asin+?>:    load.z64
	<asin+?>:    load.f64 0.000000
	<asin+?>:    div.f64
	<asin+?>:    set.x2 sp(6)
	<asin+?>:    inc.sp(-4)
	<asin+?>:    ret
	lib/math.ci:452: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>:    load.f64 1.000000
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    dup.x2 sp(6)
	<asin+?>:    mul.f64
	<asin+?>:    sub.f64
	<asin+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	lib/math.ci:453: (60 bytes): if (x > 0.700000)
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    load.f64 0.700000
	<asin+?>:    cgt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:454: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>:    load.f64 3.141593
	<asin+?>:    load.f64 2.000000
	<asin+?>:    div.f64
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    dup.x2 sp(8)
	<asin+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>:    sub.f64
	<asin+?>:    set.x2 sp(2)
	<asin+?>:    jmp <asin+?>
	lib/math.ci:457: (10 bytes): result := float64.atan2(x, result);
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>:    set.x2 sp(2)
	lib/math.ci:460: (19 bytes): if (negate)
	<asin+?>:    load.sp(+8)
	<asin+?>:    load.i8
	<asin+?>:    jz <asin+?>
	lib/math.ci:461: (10 bytes): return .result := -result;
	<asin+?>:    dup.x2 sp(0)
	<asin+?>:    neg.f64
	<asin+?>:    set.x2 sp(8)
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
	lib/math.ci:463: (9 bytes): return .result := result;
	<asin+?>:    dup.x2 sp(0)
	<asin+?>:    set.x2 sp(8)
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'lib/math.ci:470'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: (pi / (2) - asin(x))
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'deg2rad'
.file: 'lib/math.ci:493'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: float64(x * pi / (180))
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'rad2deg'
.file: 'lib/math.ci:494'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: float64(x * (180) / pi)
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'lib/math.Complex.ci:3'
.field re: float64 (size: 8 -> const variable(f64))
.field im: float64 (size: 8 -> const variable(f64))
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'lib/math.Complex.ci:4'
.owner: Complex
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'lib/math.Complex.ci:5'
.owner: Complex
.value: 0
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'Complex'
.file: 'lib/math.Complex.ci:40'
.param .result: Complex (size: 16 -> variable(val))
.param re: float64 (size: 8 -> variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (8 bytes)
	lib/math.Complex.ci:41: (8 bytes): return .result := {...};
	<Complex+?>:    dup.x2 sp(1)
	<Complex+?>:    set.x2 sp(5)
	:: (3 bytes): .result.im := (0)
	<Complex+?>:    load.z64
	<Complex+?>:    set.x2 sp(7)
	<Complex+?>:    ret
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 9
.name: 'Complex'
.file: 'lib/math.Complex.ci:45'
.param .result: Complex (size: 16 -> variable(val))
.param re: float64 (size: 8 -> variable(f64))
.param im: float64 (size: 8 -> variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (9 bytes)
	lib/math.Complex.ci:46: (9 bytes): return .result := {...};
	<Complex+?>:    dup.x2 sp(3)
	<Complex+?>:    set.x2 sp(7)
	lib/math.Complex.ci:48: (4 bytes): .result.im := im;
	<Complex+?>:    dup.x2 sp(1)
	<Complex+?>:    set.x2 sp(9)
	<Complex+?>:    ret
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/math.Complex.ci:52'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(-a.re, -a.im)
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:54'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re + b.re, a.im + b.im)
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:55'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> f64)
.value: Complex(a.re + b, a.im)
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:56'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a + b.re, b.im)
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:58'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re - b.re, a.im - b.im)
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:59'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> f64)
.value: Complex(a.re - b, a.im)
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:60'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a - b.re, b.im)
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:62'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:63'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> variable(f64))
.value: Complex(a.re * b, a.im * b)
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:64'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> variable(f64))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a * b.re, a * b.im)
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 128
.name: 'div'
.file: 'lib/math.Complex.ci:66'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (128 bytes)
	lib/math.Complex.ci:70: (79 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div+?>:    load.z64
	<div+?>:    dup.x2 sp(3)
	<div+?>:    load.ref .?????? ;Math.abs(x: float64): float64
	<div+?>:    call
	<div+?>:    inc.sp(-8)
	<div+?>:    load.z64
	<div+?>:    dup.x2 sp(7)
	<div+?>:    load.ref .?????? ;Math.abs(x: float64): float64
	<div+?>:    call
	<div+?>:    inc.sp(-8)
	<div+?>:    clt.f64
	<div+?>:    jnz <div+?>
	lib/math.Complex.ci:71: (5 bytes): r: float64 := b.im / b.re
	<div+?>:    dup.x2 sp(3)
	<div+?>:    dup.x2 sp(3)
	<div+?>:    div.f64
	lib/math.Complex.ci:72: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>:    dup.x2 sp(3)
	<div+?>:    dup.x2 sp(2)
	<div+?>:    dup.x2 sp(9)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	lib/math.Complex.ci:73: (31 bytes): return .result := {...};
	<div+?>:    dup.x2 sp(9)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    dup.x2 sp(15)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(15)
	lib/math.Complex.ci:75: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>:    dup.x2 sp(11)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    dup.x2 sp(13)
	<div+?>:    mul.f64
	<div+?>:    sub.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(17)
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
	<div+?>:    inc.sp(-16)
	lib/math.Complex.ci:78: (5 bytes): r: float64 := b.re / b.im
	<div+?>:    dup.x2 sp(1)
	<div+?>:    dup.x2 sp(5)
	<div+?>:    div.f64
	lib/math.Complex.ci:79: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>:    dup.x2 sp(5)
	<div+?>:    dup.x2 sp(2)
	<div+?>:    dup.x2 sp(7)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	lib/math.Complex.ci:80: (31 bytes): return .result := {...};
	<div+?>:    dup.x2 sp(9)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    mul.f64
	<div+?>:    dup.x2 sp(13)
	<div+?>:    add.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(15)
	lib/math.Complex.ci:82: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>:    dup.x2 sp(11)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    mul.f64
	<div+?>:    dup.x2 sp(11)
	<div+?>:    sub.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(17)
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/math.Complex.ci:86'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.param b: float64 (size: 8 -> f64)
.value: div(a, Complex(b))
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/math.Complex.ci:87'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> val)
.value: div(Complex(a), b)
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'lib/math.Complex.ci:89'
.param .result: float64 (size: 8 -> f64)
.param a: Complex (size: 16 -> variable(val))
.value: float64.sqrt(a.re * a.re + a.im * a.im)
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'lib/math.Complex.ci:90'
.param .result: float64 (size: 8 -> f64)
.param a: Complex (size: 16 -> variable(val))
.value: float64.atan2(a.re, a.im)
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'inv'
.file: 'lib/math.Complex.ci:93'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.value: {
	d: float64 := (a.re * a.re + a.im * a.im);
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (36 bytes)
	lib/math.Complex.ci:94: (11 bytes): d: float64 := (a.re * a.re + a.im * a.im)
	<inv+?>:    dup.x2 sp(1)
	<inv+?>:    dup.x2 sp(3)
	<inv+?>:    mul.f64
	<inv+?>:    dup.x2 sp(5)
	<inv+?>:    dup.x2 sp(7)
	<inv+?>:    mul.f64
	<inv+?>:    add.f64
	lib/math.Complex.ci:95: (20 bytes): return .result := {...};
	<inv+?>:    dup.x2 sp(3)
	<inv+?>:    dup.x2 sp(2)
	<inv+?>:    div.f64
	<inv+?>:    set.x2 sp(9)
	lib/math.Complex.ci:97: (8 bytes): .result.im := -a.im / d;
	<inv+?>:    dup.x2 sp(5)
	<inv+?>:    neg.f64
	<inv+?>:    dup.x2 sp(2)
	<inv+?>:    div.f64
	<inv+?>:    set.x2 sp(11)
	<inv+?>:    inc.sp(-8)
	<inv+?>:    ret
	<inv+?>:    inc.sp(-8)
	<inv+?>:    ret
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'lib/math.Complex.ci:101'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(a.re, -a.im)
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'lib/math.Complex.ci:103'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'lib/math.Complex.ci:105'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.log(abs(a)), arg(a))
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 105
.name: 'pow'
.file: 'lib/math.Complex.ci:107'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (105 bytes)
	lib/math.Complex.ci:108: (23 bytes): r: float64 := abs(a)
	<pow+?>:    dup.x4 sp(5)
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(2)
	<pow+?>:    mul.f64
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    mul.f64
	<pow+?>:    add.f64
	<pow+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	<pow+?>:    set.x2 sp(4)
	<pow+?>:    inc.sp(-8)
	lib/math.Complex.ci:109: (16 bytes): t: float64 := arg(a)
	<pow+?>:    dup.x4 sp(7)
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>:    set.x2 sp(4)
	<pow+?>:    inc.sp(-8)
	lib/math.Complex.ci:110: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>:    dup.x2 sp(5)
	<pow+?>:    dup.x2 sp(2)
	<pow+?>:    mul.f64
	<pow+?>:    dup.x2 sp(9)
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    nfc(39) ;float64.log(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    add.f64
	lib/math.Complex.ci:111: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    dup.x2 sp(9)
	<pow+?>:    nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+?>:    dup.x2 sp(11)
	<pow+?>:    neg.f64
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    mul.f64
	<pow+?>:    nfc(40) ;float64.exp(x: float64): float64
	<pow+?>:    mul.f64
	lib/math.Complex.ci:112: (27 bytes): return .result := {...};
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(37) ;float64.cos(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    set.x2 sp(19)
	lib/math.Complex.ci:114: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(36) ;float64.sin(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    set.x2 sp(21)
	<pow+?>:    inc.sp(-32)
	<pow+?>:    ret
	<pow+?>:    inc.sp(-32)
	<pow+?>:    ret
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'lib/math.Complex.ci:117'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.param b: float64 (size: 8 -> f64)
.value: pow(a, Complex(b))
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/math.Complex.ci:119'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/math.Complex.ci:120'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'lib/math.Complex.ci:121'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sin(a), cos(a))
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'lib/math.Complex.ci:122'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(cos(a), sin(a))
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'lib/math.Complex.ci:124'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sub(exp(a), exp(neg(a))), 2)
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'lib/math.Complex.ci:125'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(add(exp(a), exp(neg(a))), 2)
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'lib/math.Complex.ci:126'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'lib/math.Complex.ci:127'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'lib/math.Complex.ci:129'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(cos(a))
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'lib/math.Complex.ci:130'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(sin(a))
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'lib/math.Complex.ci:131'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(cosh(a))
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'lib/math.Complex.ci:132'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(sinh(a))
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'lib/math.Complex.ci:145'
.param .result: Complex (size: 16 -> val)
.param x: Complex (size: 16 -> variable(val))
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'lib/math.Complex.ci:146'
.param .result: Complex (size: 16 -> val)
.param x: Complex (size: 16 -> variable(val))
.value: Complex(abs(x), arg(x))
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'length'
.file: 'lib/string.ci:3'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (49 bytes)
	lib/string.ci:4: (16 bytes): if ((str) == null)
	<length+?>:    dup.x1 sp(1)
	<length+?>:    load.ref .?????? ;null
	<length+?>:    ceq.i32
	<length+?>:    jz <length+?>
	lib/string.ci:5: (4 bytes): return .result := 0;
	<length+?>:    load.z32
	<length+?>:    set.x1 sp(3)
	<length+?>:    ret
	lib/string.ci:7: (1 bytes): result: int32 := 0
	<length+?>:    load.z32
	lib/string.ci:8: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>:    jmp <length+?>
	lib/string.ci:8: (4 bytes): result := result + 1
	<length+?>:    inc.i32(+1)
	lib/string.ci:8: (10 bytes): str[result]
	<length+?>:    dup.x1 sp(2)
	<length+?>:    dup.x1 sp(1)
	<length+?>:    add.i32
	<length+?>:    load.i8
	<length+?>:    jnz <length+?>
	lib/string.ci:10: (9 bytes): return .result := result;
	<length+?>:    dup.x1 sp(0)
	<length+?>:    set.x1 sp(4)
	<length+?>:    inc.sp(-4)
	<length+?>:    ret
	<length+?>:    inc.sp(-4)
	<length+?>:    ret
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 56
.name: 'indexOf'
.file: 'lib/string.ci:14'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param chr: char (size: 4 -> variable(i32))
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (56 bytes)
	lib/string.ci:15: (48 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf+?>:    load.z32
	<indexOf+?>:    jmp <indexOf+?>
	lib/string.ci:16: (25 bytes): if (str[i] == chr)
	<indexOf+?>:    dup.x1 sp(3)
	<indexOf+?>:    dup.x1 sp(1)
	<indexOf+?>:    add.i32
	<indexOf+?>:    load.i8
	<indexOf+?>:    load.sp(+12)
	<indexOf+?>:    load.i8
	<indexOf+?>:    ceq.i32
	<indexOf+?>:    jz <indexOf+?>
	lib/string.ci:17: (9 bytes): return .result := i;
	<indexOf+?>:    dup.x1 sp(0)
	<indexOf+?>:    set.x1 sp(5)
	<indexOf+?>:    inc.sp(-4)
	<indexOf+?>:    ret
	lib/string.ci:15: (4 bytes): i := i + 1
	<indexOf+?>:    inc.i32(+1)
	lib/string.ci:15: (10 bytes): str[i]
	<indexOf+?>:    dup.x1 sp(3)
	<indexOf+?>:    dup.x1 sp(1)
	<indexOf+?>:    add.i32
	<indexOf+?>:    load.i8
	<indexOf+?>:    jnz <indexOf+?>
	<indexOf+?>:    inc.sp(-4)
	lib/string.ci:20: (8 bytes): return .result := -1;
	<indexOf+?>:    load.c32 -1
	<indexOf+?>:    set.x1 sp(4)
	<indexOf+?>:    ret
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 62
.name: 'lastIndexOf'
.file: 'lib/string.ci:24'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param chr: char (size: 4 -> variable(i32))
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (62 bytes)
	lib/string.ci:25: (5 bytes): result: int32 := -1
	<lastIndexOf+?>:    load.c32 -1
	lib/string.ci:26: (43 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>:    load.z32
	<lastIndexOf+?>:    jmp <lastIndexOf+?>
	lib/string.ci:27: (20 bytes): if (str[i] == chr)
	<lastIndexOf+?>:    dup.x1 sp(4)
	<lastIndexOf+?>:    dup.x1 sp(1)
	<lastIndexOf+?>:    add.i32
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    load.sp(+16)
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    ceq.i32
	<lastIndexOf+?>:    jz <lastIndexOf+?>
	lib/string.ci:28: (4 bytes): result := i;
	<lastIndexOf+?>:    dup.x1 sp(0)
	<lastIndexOf+?>:    set.x1 sp(2)
	lib/string.ci:26: (4 bytes): i := i + 1
	<lastIndexOf+?>:    inc.i32(+1)
	lib/string.ci:26: (10 bytes): str[i]
	<lastIndexOf+?>:    dup.x1 sp(4)
	<lastIndexOf+?>:    dup.x1 sp(1)
	<lastIndexOf+?>:    add.i32
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    jnz <lastIndexOf+?>
	<lastIndexOf+?>:    inc.sp(-4)
	lib/string.ci:31: (9 bytes): return .result := result;
	<lastIndexOf+?>:    dup.x1 sp(0)
	<lastIndexOf+?>:    set.x1 sp(5)
	<lastIndexOf+?>:    inc.sp(-4)
	<lastIndexOf+?>:    ret
	<lastIndexOf+?>:    inc.sp(-4)
	<lastIndexOf+?>:    ret
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'lib/string.ci:35'
.param .result: bool (size: 4 -> variable(bool))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	lib/string.ci:36: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith+?>:    load.z32
	<startsWith+?>:    jmp <startsWith+?>
	lib/string.ci:37: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>:    load.z32
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    dup.x1 sp(2)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    dup.x1 sp(3)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    call
	<startsWith+?>:    inc.sp(-8)
	<startsWith+?>:    load.z32
	<startsWith+?>:    ceq.i32
	<startsWith+?>:    jnz <startsWith+?>
	lib/string.ci:38: (11 bytes): return .result := false;
	<startsWith+?>:    load.z32
	<startsWith+?>:    load.sp(+24)
	<startsWith+?>:    store.i8
	<startsWith+?>:    inc.sp(-4)
	<startsWith+?>:    ret
	lib/string.ci:36: (4 bytes): i := i + 1
	<startsWith+?>:    inc.i32(+1)
	lib/string.ci:36: (12 bytes): (with[i]) != 0
	<startsWith+?>:    dup.x1 sp(3)
	<startsWith+?>:    dup.x1 sp(1)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    load.z32
	<startsWith+?>:    ceq.i32
	<startsWith+?>:    jz <startsWith+?>
	<startsWith+?>:    inc.sp(-4)
	lib/string.ci:41: (11 bytes): return .result := true;
	<startsWith+?>:    load.c32 1
	<startsWith+?>:    load.sp(+20)
	<startsWith+?>:    store.i8
	<startsWith+?>:    ret
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 131
.name: 'endsWith'
.file: 'lib/string.ci:44'
.param .result: bool (size: 4 -> variable(bool))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (131 bytes)
	lib/string.ci:45: (13 bytes): withLen: int32 := length(with)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    load.ref .?????? ;length(str: char[*]): int32
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:46: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(5)
	<endsWith+?>:    load.ref .?????? ;length(str: char[*]): int32
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:47: (20 bytes): if (strLen < withLen)
	<endsWith+?>:    dup.x1 sp(0)
	<endsWith+?>:    dup.x1 sp(2)
	<endsWith+?>:    clt.i32
	<endsWith+?>:    jz <endsWith+?>
	lib/string.ci:48: (11 bytes): return .result := false;
	<endsWith+?>:    load.z32
	<endsWith+?>:    load.sp(+28)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
	lib/string.ci:50: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>:    load.z32
	<endsWith+?>:    jmp <endsWith+?>
	lib/string.ci:51: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    dup.x1 sp(5)
	<endsWith+?>:    sub.i32
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    add.i32
	<endsWith+?>:    add.i32
	<endsWith+?>:    load.i8
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    add.i32
	<endsWith+?>:    load.i8
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    load.z32
	<endsWith+?>:    ceq.i32
	<endsWith+?>:    jnz <endsWith+?>
	lib/string.ci:52: (11 bytes): return .result := false;
	<endsWith+?>:    load.z32
	<endsWith+?>:    load.sp(+32)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-12)
	<endsWith+?>:    ret
	lib/string.ci:50: (4 bytes): i := i + 1
	<endsWith+?>:    inc.i32(+1)
	lib/string.ci:50: (9 bytes): i < withLen
	<endsWith+?>:    dup.x1 sp(0)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    clt.i32
	<endsWith+?>:    jnz <endsWith+?>
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:55: (15 bytes): return .result := true;
	<endsWith+?>:    load.c32 1
	<endsWith+?>:    load.sp(+28)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 74
.name: 'compare'
.file: 'lib/string.ci:58'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (74 bytes)
	lib/string.ci:59: (1 bytes): result: int32 := 0
	<compare+?>:    load.z32
	lib/string.ci:60: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>:    load.z32
	<compare+?>:    jmp <compare+?>
	lib/string.ci:61: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>:    load.z32
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    dup.x1 sp(2)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    dup.x1 sp(3)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    call
	<compare+?>:    inc.sp(-8)
	<compare+?>:    set.x1 sp(2)
	lib/string.ci:62: (16 bytes): if ((str[i]) == 0)
	<compare+?>:    dup.x1 sp(5)
	<compare+?>:    dup.x1 sp(1)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    load.z32
	<compare+?>:    ceq.i32
	<compare+?>:    jz <compare+?>
	lib/string.ci:63: (4 bytes): break;
	<compare+?>:    jmp <compare+?>
	lib/string.ci:60: (4 bytes): i := i + 1
	<compare+?>:    inc.i32(+1)
	lib/string.ci:60: (8 bytes): result == 0
	<compare+?>:    dup.x1 sp(1)
	<compare+?>:    load.z32
	<compare+?>:    ceq.i32
	<compare+?>:    jnz <compare+?>
	<compare+?>:    inc.sp(-4)
	lib/string.ci:66: (9 bytes): return .result := result;
	<compare+?>:    dup.x1 sp(0)
	<compare+?>:    set.x1 sp(6)
	<compare+?>:    inc.sp(-4)
	<compare+?>:    ret
	<compare+?>:    inc.sp(-4)
	<compare+?>:    ret
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'lib/string.ci:70'
.param .result: int32 (size: 4 -> variable(i32))
.param chr: char (size: 4 -> variable(i32))
.param with: char (size: 4 -> variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (chr >= 'A' && chr <= 'Z') {
			chr := chr - 'A';
			chr := chr + 'a';
		}
		return .result := chr;
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	lib/string.ci:79: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp+?>:    load.z32
	<ignCaseCmp+?>:    load.sp(+12)
	<ignCaseCmp+?>:    load.i8
	<ignCaseCmp+?>:    load.ref .?????? ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>:    call
	<ignCaseCmp+?>:    inc.sp(-4)
	<ignCaseCmp+?>:    load.z32
	<ignCaseCmp+?>:    load.sp(+12)
	<ignCaseCmp+?>:    load.i8
	<ignCaseCmp+?>:    load.ref .?????? ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>:    call
	<ignCaseCmp+?>:    inc.sp(-4)
	<ignCaseCmp+?>:    sub.i32
	<ignCaseCmp+?>:    set.x1 sp(4)
	<ignCaseCmp+?>:    ret
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'lib/string.ci:82'
.param .result: int32 (size: 4 -> variable(i32))
.param chr: char (size: 4 -> variable(i32))
.param with: char (size: 4 -> variable(i32))
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	lib/string.ci:83: (14 bytes): return .result := chr - with;
	<caseCmp+?>:    load.sp(+8)
	<caseCmp+?>:    load.i8
	<caseCmp+?>:    load.sp(+8)
	<caseCmp+?>:    load.i8
	<caseCmp+?>:    sub.i32
	<caseCmp+?>:    set.x1 sp(4)
	<caseCmp+?>:    ret
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'lib/string.ci:86'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: startsWith(str, with, caseCmp)
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'lib/string.ci:87'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: endsWith(str, with, caseCmp)
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'lib/string.ci:88'
.param .result: int32 (size: 4 -> i32)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: compare(str, with, caseCmp)
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'lib/string.ci:90'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param chr: char (size: 4 -> i32)
.value: indexOf(str, chr) >= 0
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'lib/string.ci:93'
.field radix: int32 (size: 4 -> const variable(i32))
.field sign: char (size: 1 -> const variable(i32))
.field padChr: char (size: 1 -> const variable(i32))
.field padLen: int32 (size: 4 -> const variable(i32))
.field precision: int32 (size: 4 -> const variable(i32))
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'radix'
.file: 'lib/string.ci:94'
.owner: FormatFlags
}
FormatFlags.sign: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'sign'
.file: 'lib/string.ci:95'
.owner: FormatFlags
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'lib/string.ci:96'
.owner: FormatFlags
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'lib/string.ci:97'
.owner: FormatFlags
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'lib/string.ci:98'
.owner: FormatFlags
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 85
.name: 'append'
.file: 'lib/string.ci:101'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: char[*] (size: 4 -> variable(ref))
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (85 bytes)
	lib/string.ci:102: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append+?>:    load.z32
	<append+?>:    jmp <append+?>
	lib/string.ci:103: (13 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(3)
	<append+?>:    dup.x1 sp(6)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:104: (4 bytes): break;
	<append+?>:    jmp <append+?>
	lib/string.ci:106: (12 bytes): output[pos] := value[i];
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(5)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:107: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(3)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(4)
	lib/string.ci:102: (4 bytes): i := i + 1
	<append+?>:    inc.i32(+1)
	lib/string.ci:102: (10 bytes): value[i]
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    jnz <append+?>
	<append+?>:    inc.sp(-4)
	lib/string.ci:110: (17 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:111: (8 bytes): pos := (output.length - (1));
	<append+?>:    dup.x1 sp(4)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(3)
	lib/string.ci:113: (7 bytes): output[pos] := (0);
	<append+?>:    load.z32
	<append+?>:    dup.x1 sp(4)
	<append+?>:    dup.x1 sp(4)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:114: (5 bytes): return .result := pos;
	<append+?>:    dup.x1 sp(2)
	<append+?>:    set.x1 sp(6)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 623
.name: 'append'
.file: 'lib/string.ci:117'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: uint32 (size: 4 -> variable(u32))
.param format: FormatFlags (size: 4 -> variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(radix > 1 && radix < (radixDigits.length));
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if (format.sign != '') {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := format.sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (623 bytes)
	lib/string.ci:121: (1 bytes): len: int32 := 0
	<append+?>:    load.z32
	lib/string.ci:122: (4 bytes): digits: char[80]
	<append+?>:    inc.sp(+80)
	lib/string.ci:124: (3 bytes): radix: int32 := format.radix
	<append+?>:    dup.x1 sp(22)
	<append+?>:    load.i32
	lib/string.ci:125: (63 bytes): assert(radix > 1 && radix < (radixDigits.length));
	<append+?>:    dup.x1 sp(0)
	<append+?>:    load.c32 1
	<append+?>:    cgt.i32
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.m32 .?????? ;append.radixDigits+4
	<append+?>:    clt.i32
	<append+?>:    and.b32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 125
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:128: (46 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>:    jmp <append+?>
	lib/string.ci:129: (27 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>:    load.m32 .?????? ;append.radixDigits
	<append+?>:    dup.x1 sp(25)
	<append+?>:    dup.x1 sp(2)
	<append+?>:    mod.u32
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    load.sp(+8)
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+1)
	<append+?>:    dup.x1 sp(0)
	<append+?>:    set.x1 sp(25)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:128: (7 bytes): value := value / (radix)
	<append+?>:    dup.x1 sp(24)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    div.u32
	<append+?>:    set.x1 sp(25)
	lib/string.ci:128: (8 bytes): value > (0)
	<append+?>:    dup.x1 sp(24)
	<append+?>:    load.z32
	<append+?>:    cgt.u32
	<append+?>:    jnz <append+?>
	lib/string.ci:131: (29 bytes): if (len == 0)
	<append+?>:    dup.x1 sp(21)
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jz <append+?>
	lib/string.ci:132: (21 bytes): digits[len := len + 1] := '0';
	<append+?>:    load.c32 48
	<append+?>:    load.sp(+8)
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+1)
	<append+?>:    dup.x1 sp(0)
	<append+?>:    set.x1 sp(25)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:135: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+8)
	<append+?>:    load.i32
	<append+?>:    dup.x1 sp(22)
	<append+?>:    sub.i32
	lib/string.ci:137: (7 bytes): padChr: char := format.padChr
	<append+?>:    dup.x1 sp(24)
	<append+?>:    inc.i32(+5)
	<append+?>:    load.i8
	lib/string.ci:138: (21 bytes): if (padChr == '')
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jz <append+?>
	lib/string.ci:139: (10 bytes): padChr := ' ';
	<append+?>:    load.c32 32
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	lib/string.ci:143: (211 bytes): if (format.sign != '')
	<append+?>:    dup.x1 sp(25)
	<append+?>:    inc.i32(+4)
	<append+?>:    load.i8
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:144: (8 bytes): maxLen := maxLen - 1;
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:145: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>:    load.z32
	<append+?>:    load.m32 .?????? ;append.whiteSpace
	<append+?>:    load.sp(+8)
	<append+?>:    load.i8
	<append+?>:    load.ref .?????? ;indexOf(str: char[*], chr: char): int32
	<append+?>:    call
	<append+?>:    inc.sp(-8)
	<append+?>:    load.z32
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:147: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>:    jmp <append+?>
	lib/string.ci:148: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 148
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:149: (11 bytes): output[pos] := padChr;
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:150: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:147: (8 bytes): maxLen := maxLen - 1
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:147: (8 bytes): maxLen > 0
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.z32
	<append+?>:    cgt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:153: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 153
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:154: (13 bytes): output[pos] := format.sign;
	<append+?>:    dup.x1 sp(25)
	<append+?>:    inc.i32(+4)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:155: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:159: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>:    jmp <append+?>
	lib/string.ci:160: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 160
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:161: (11 bytes): output[pos] := padChr;
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:162: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:159: (8 bytes): maxLen := maxLen - 1
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:159: (8 bytes): maxLen > 0
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.z32
	<append+?>:    cgt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:166: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>:    load.z32
	<append+?>:    jmp <append+?>
	lib/string.ci:167: (52 bytes): assert(i < (output.length));
	<append+?>:    dup.x1 sp(0)
	<append+?>:    dup.x1 sp(31)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 167
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:168: (17 bytes): output[pos] := digits[len - i];
	<append+?>:    load.sp(+16)
	<append+?>:    dup.x1 sp(25)
	<append+?>:    dup.x1 sp(2)
	<append+?>:    sub.i32
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(30)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:169: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(28)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(29)
	lib/string.ci:166: (4 bytes): i := i + 1
	<append+?>:    inc.i32(+1)
	lib/string.ci:166: (9 bytes): i < len
	<append+?>:    dup.x1 sp(0)
	<append+?>:    dup.x1 sp(25)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	<append+?>:    inc.sp(-4)
	lib/string.ci:172: (17 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:173: (8 bytes): pos := (output.length - (1));
	<append+?>:    dup.x1 sp(29)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:175: (7 bytes): output[pos] := (0);
	<append+?>:    load.z32
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:176: (9 bytes): return .result := pos;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    set.x1 sp(31)
	<append+?>:    inc.sp(-96)
	<append+?>:    ret
	<append+?>:    inc.sp(-96)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.name: 'append'
.file: 'lib/string.ci:179'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: uint32 (size: 4 -> variable(u32))
.value: {
	static const format: FormatFlags := {
		format.radix := 10;
		format.sign := '';
		format.padChr := ' ';
		format.padLen := 0;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (25 bytes)
	lib/string.ci:187: (25 bytes): return .result := append(output, pos, value, format);
	<append+?>:    load.z32
	<append+?>:    dup.x2 sp(4)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    load.ref .?????? ;append.format
	<append+?>:    load.ref .?????? ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>:    call
	<append+?>:    inc.sp(-20)
	<append+?>:    set.x1 sp(6)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: int32, forceSign: bool, pad: int32): int32: function {
.kind: static const function
.base: `function`
.size: 118
.name: 'append'
.file: 'lib/string.ci:189'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: int32 (size: 4 -> variable(i32))
.param forceSign: bool (size: 4 -> variable(bool))
.param pad: int32 (size: 4 -> variable(i32))
.value: {
	sign: char := 0;
	if (value < 0) {
		value := -value;
		sign := '-';
	}
	else {
		if (forceSign) {
			sign := '+';
		}
	}
	const format: FormatFlags := {
		format.radix := 10;
		format.sign := sign;
		format.padChr := '0';
		format.padLen := pad;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (118 bytes)
	lib/string.ci:190: (1 bytes): sign: char := 0
	<append+?>:    load.z32
	lib/string.ci:191: (46 bytes): if (value < 0)
	<append+?>:    dup.x1 sp(4)
	<append+?>:    load.z32
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	lib/string.ci:192: (5 bytes): value := -value;
	<append+?>:    dup.x1 sp(4)
	<append+?>:    neg.i32
	<append+?>:    set.x1 sp(5)
	lib/string.ci:193: (10 bytes): sign := '-';
	<append+?>:    load.c32 45
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	<append+?>:    jmp <append+?>
	lib/string.ci:195: (19 bytes): if (forceSign)
	<append+?>:    load.sp(+12)
	<append+?>:    load.i8
	<append+?>:    jz <append+?>
	lib/string.ci:196: (10 bytes): sign := '+';
	<append+?>:    load.c32 43
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	lib/string.ci:198: (38 bytes): const format: FormatFlags := {...}
	<append+?>:    inc.sp(+16)
	lib/string.ci:199: (7 bytes): format.radix := 10;
	<append+?>:    load.c32 10
	<append+?>:    set.x1 sp(1)
	lib/string.ci:200: (10 bytes): format.sign := sign;
	<append+?>:    load.sp(+16)
	<append+?>:    load.i8
	<append+?>:    load.sp(+8)
	<append+?>:    store.i8
	lib/string.ci:201: (10 bytes): format.padChr := '0';
	<append+?>:    load.c32 48
	<append+?>:    load.sp(+9)
	<append+?>:    store.i8
	lib/string.ci:202: (4 bytes): format.padLen := pad;
	<append+?>:    dup.x1 sp(6)
	<append+?>:    set.x1 sp(3)
	lib/string.ci:203: (3 bytes): format.precision := 0;
	<append+?>:    load.z32
	<append+?>:    set.x1 sp(4)
	lib/string.ci:205: (28 bytes): return .result := append(output, pos, value, format);
	<append+?>:    load.z32
	<append+?>:    dup.x2 sp(11)
	<append+?>:    dup.x1 sp(12)
	<append+?>:    dup.x1 sp(12)
	<append+?>:    load.sp(+20)
	<append+?>:    load.ref .?????? ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>:    call
	<append+?>:    inc.sp(-20)
	<append+?>:    set.x1 sp(13)
	<append+?>:    inc.sp(-20)
	<append+?>:    ret
	<append+?>:    inc.sp(-20)
	<append+?>:    ret
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0 -> static const inline)
.field create: function (size: 0 -> static const inline)
.field append: function (size: 0 -> static const inline)
.field read: function (size: 0 -> static const inline)
.field peek: function (size: 0 -> static const inline)
.field read: function (size: 0 -> static const inline)
.field readLine: function (size: 0 -> static const inline)
.field write: function (size: 0 -> static const inline)
.field write: function (size: 0 -> static const inline)
.field flush: function (size: 0 -> static const inline)
.field close: function (size: 0 -> static const inline)
.field in: File (size: 0 -> static const inline)
.field out: File (size: 0 -> static const inline)
.field err: File (size: 0 -> static const inline)
.field log: File (size: 0 -> static const inline)
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(44)
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(45)
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(46)
}
File.read(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.value: nfc(47)
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.value: nfc(48)
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.param buff: uint8[] (size: 8 -> variable(arr))
.value: nfc(49)
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readLine'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.param buff: uint8[] (size: 8 -> variable(arr))
.value: nfc(50)
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.param byte: uint8 (size: 4 -> variable(u32))
.value: nfc(51)
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4 -> inline)
.param file: File (size: 8 -> variable(val))
.param buff: uint8[] (size: 8 -> variable(arr))
.value: nfc(52)
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0 -> inline)
.param file: File (size: 8 -> variable(val))
.value: nfc(53)
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0 -> inline)
.param file: File (size: 8 -> variable(val))
.value: nfc(54)
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.value: nfc(55)
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.value: nfc(56)
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.value: nfc(57)
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.value: nfc(58)
}
gxRect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'gxRect'
.file: 'libGfx/src/gx_main.c:794'
.field x: int32 (size: 4 -> variable(i32))
.field y: int32 (size: 4 -> variable(i32))
.field w: int32 (size: 4 -> variable(i32))
.field h: int32 (size: 4 -> variable(i32))
}
gxRect.x: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.file: 'libGfx/src/gx_main.c:795'
.owner: gxRect
}
gxRect.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'libGfx/src/gx_main.c:796'
.owner: gxRect
}
gxRect.w: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'w'
.file: 'libGfx/src/gx_main.c:797'
.owner: gxRect
}
gxRect.h: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'h'
.file: 'libGfx/src/gx_main.c:798'
.owner: gxRect
}
gxSurf: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'gxSurf'
.field create: function (size: 0 -> static const inline)
.field create3d: function (size: 0 -> static const inline)
.field recycle: function (size: 0 -> static const inline)
.field destroy: function (size: 0 -> static const inline)
.field openBmp: function (size: 0 -> static const inline)
.field openPng: function (size: 0 -> static const inline)
.field openJpg: function (size: 0 -> static const inline)
.field openFnt: function (size: 0 -> static const inline)
.field saveBmp: function (size: 0 -> static const inline)
.field width: function (size: 0 -> static const inline)
.field height: function (size: 0 -> static const inline)
.field depth: function (size: 0 -> static const inline)
.field get: function (size: 0 -> static const inline)
.field set: function (size: 0 -> static const inline)
.field drawRect: function (size: 0 -> static const inline)
.field fillRect: function (size: 0 -> static const inline)
.field drawOval: function (size: 0 -> static const inline)
.field fillOval: function (size: 0 -> static const inline)
.field drawLine: function (size: 0 -> static const inline)
.field drawBezier: function (size: 0 -> static const inline)
.field drawBezier: function (size: 0 -> static const inline)
.field clipText: function (size: 0 -> static const inline)
.field drawText: function (size: 0 -> static const inline)
.field copy: function (size: 0 -> static const inline)
.field resize: function (size: 0 -> static const inline)
.field colorMap: function (size: 0 -> static const inline)
.field colorMat: function (size: 0 -> static const inline)
.field drawMesh: function (size: 0 -> static const inline)
}
gxSurf.create(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param width: int32 (size: 4 -> variable(i32))
.param height: int32 (size: 4 -> variable(i32))
.param depth: int32 (size: 4 -> variable(i32))
.value: nfc(72)
}
gxSurf.create3d(width: int32, height: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param width: int32 (size: 4 -> variable(i32))
.param height: int32 (size: 4 -> variable(i32))
.value: nfc(73)
}
gxSurf.recycle(recycle: gxSurf, width: int32, height: int32, depth: int32, flags: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param recycle: gxSurf (size: 8 -> variable(val))
.param width: int32 (size: 4 -> variable(i32))
.param height: int32 (size: 4 -> variable(i32))
.param depth: int32 (size: 4 -> variable(i32))
.param flags: int32 (size: 4 -> variable(i32))
.value: nfc(74)
}
gxSurf.destroy(surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.value: nfc(75)
}
gxSurf.openBmp(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.param depth: int32 (size: 4 -> variable(i32))
.value: nfc(76)
}
gxSurf.openPng(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.param depth: int32 (size: 4 -> variable(i32))
.value: nfc(77)
}
gxSurf.openJpg(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.param depth: int32 (size: 4 -> variable(i32))
.value: nfc(78)
}
gxSurf.openFnt(path: char[*]): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: gxSurf
.param .result: gxSurf (size: 8 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(79)
}
gxSurf.saveBmp(surf: gxSurf, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param path: char[*] (size: 4 -> variable(ref))
.param flags: int32 (size: 4 -> variable(i32))
.value: nfc(80)
}
gxSurf.width(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: gxSurf
.param .result: int32 (size: 4 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.value: nfc(81)
}
gxSurf.height(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: gxSurf
.param .result: int32 (size: 4 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.value: nfc(82)
}
gxSurf.depth(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: gxSurf
.param .result: int32 (size: 4 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.value: nfc(83)
}
gxSurf.get(surf: gxSurf, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: gxSurf
.param .result: int32 (size: 4 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: nfc(84)
}
gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.param color: uint32 (size: 4 -> variable(u32))
.value: nfc(85)
}
gxSurf.drawRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawRect'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(86)
}
gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(87)
}
gxSurf.drawOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawOval'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(88)
}
gxSurf.fillOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillOval'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(89)
}
gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawLine'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(90)
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param x3: int32 (size: 4 -> variable(i32))
.param y3: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(91)
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x1: int32 (size: 4 -> variable(i32))
.param y1: int32 (size: 4 -> variable(i32))
.param x2: int32 (size: 4 -> variable(i32))
.param y2: int32 (size: 4 -> variable(i32))
.param x3: int32 (size: 4 -> variable(i32))
.param y3: int32 (size: 4 -> variable(i32))
.param x4: int32 (size: 4 -> variable(i32))
.param y4: int32 (size: 4 -> variable(i32))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(92)
}
gxSurf.clipText(font: gxSurf, rect: gxRect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param font: gxSurf (size: 8 -> variable(val))
.param rect: gxRect (size: 4 -> variable(ref))
.param text: char[*] (size: 4 -> variable(ref))
.value: nfc(93)
}
gxSurf.drawText(surf: gxSurf, x: int32, y: int32, font: gxSurf, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.param font: gxSurf (size: 8 -> variable(val))
.param text: char[*] (size: 4 -> variable(ref))
.param color: int32 (size: 4 -> variable(i32))
.value: nfc(94)
}
gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.param src: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> const variable(ref))
.value: nfc(95)
}
gxSurf.resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'resize'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param rect: gxRect (size: 4 -> const variable(ref))
.param src: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> const variable(ref))
.param interpolate: int32 (size: 4 -> variable(i32))
.value: nfc(96)
}
gxSurf.colorMap(surf: gxSurf, roi: gxRect, lut: uint32[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> const variable(ref))
.param lut: uint32[] (size: 8 -> variable(arr))
.value: nfc(97)
}
gxSurf.colorMat(surf: gxSurf, roi: gxRect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: gxSurf
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> const variable(ref))
.param mat: float32[16] (size: 4 -> variable(ref))
.value: nfc(98)
}
gxSurf.drawMesh(surf: gxSurf, mesh: gxMesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: gxSurf
.param .result: int32 (size: 4 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param mesh: gxMesh (size: 4 -> variable(ref))
.param mode: int32 (size: 4 -> variable(i32))
.value: nfc(99)
}
gxMesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 176
.name: 'gxMesh'
.field create: function (size: 0 -> static const inline)
.field recycle: function (size: 0 -> static const inline)
.field destroy: function (size: 0 -> static const inline)
.field openObj: function (size: 0 -> static const inline)
.field open3ds: function (size: 0 -> static const inline)
.field saveObj: function (size: 0 -> static const inline)
.field normalize: function (size: 0 -> static const inline)
.field addVertex: function (size: 0 -> static const inline)
.field ambient: function (size: 0 -> static const inline)
.field diffuse: function (size: 0 -> static const inline)
.field specular: function (size: 0 -> static const inline)
.field shine: function (size: 0 -> static const inline)
.field texture: function (size: 0 -> static const inline)
.field clearDepth: int64 (size: 0 -> static const i64)
.field clearColor: int64 (size: 0 -> static const i64)
.field cullBack: int64 (size: 0 -> static const i64)
.field cullFront: int64 (size: 0 -> static const i64)
.field drawPlot: int64 (size: 0 -> static const i64)
.field drawWire: int64 (size: 0 -> static const i64)
.field drawFill: int64 (size: 0 -> static const i64)
.field drawMode: int64 (size: 0 -> static const i64)
.field useTexture: int64 (size: 0 -> static const i64)
.field useLights: int64 (size: 0 -> static const i64)
.field vertices: int64 (size: 8 -> const variable(i64))
.field triangles: int64 (size: 8 -> const variable(i64))
.field segments: int64 (size: 8 -> const variable(i64))
}
gxMesh.create(size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxMesh
.param .result: gxMesh (size: 4 -> inline)
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(59)
}
gxMesh.recycle(recycle: gxMesh, size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxMesh
.param .result: gxMesh (size: 4 -> inline)
.param recycle: gxMesh (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(60)
}
gxMesh.destroy(mesh: gxMesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.value: nfc(61)
}
gxMesh.openObj(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: gxMesh
.param .result: gxMesh (size: 4 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(62)
}
gxMesh.open3ds(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: gxMesh
.param .result: gxMesh (size: 4 -> inline)
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(63)
}
gxMesh.saveObj(mesh: gxMesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param path: char[*] (size: 4 -> variable(ref))
.value: nfc(64)
}
gxMesh.normalize(mesh: gxMesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param tolerance: float32 (size: 4 -> variable(f32))
.param center: float32[3] (size: 4 -> variable(ref))
.param resize: float32[3] (size: 4 -> variable(ref))
.value: nfc(65)
}
gxMesh.addVertex(mesh: gxMesh, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.param z: float32 (size: 4 -> variable(f32))
.value: nfc(66)
}
gxMesh.ambient(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(67)
}
gxMesh.diffuse(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(68)
}
gxMesh.specular(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(69)
}
gxMesh.shine(mesh: gxMesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param value: float32 (size: 4 -> variable(f32))
.value: nfc(70)
}
gxMesh.texture(mesh: gxMesh, surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: gxMesh
.param .result: void (size: 0 -> inline)
.param mesh: gxMesh (size: 4 -> variable(ref))
.param surf: gxSurf (size: 8 -> variable(val))
.value: nfc(71)
}
gxMesh.clearDepth: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearDepth'
.owner: gxMesh
.value: 8
}
gxMesh.clearColor: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearColor'
.owner: gxMesh
.value: 4
}
gxMesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: gxMesh
.value: 16
}
gxMesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: gxMesh
.value: 32
}
gxMesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: gxMesh
.value: 1
}
gxMesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: gxMesh
.value: 2
}
gxMesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: gxMesh
.value: 3
}
gxMesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: gxMesh
.value: 3
}
gxMesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: gxMesh
.value: 64
}
gxMesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: gxMesh
.value: 128
}
gxMesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: gxMesh
}
gxMesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: gxMesh
}
gxMesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: gxMesh
}
camera: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'camera'
.field projection: function (size: 0 -> static const inline)
.field lookAt: function (size: 0 -> static const inline)
.field readUp: function (size: 0 -> static const inline)
.field readRight: function (size: 0 -> static const inline)
.field readForward: function (size: 0 -> static const inline)
.field rotate: function (size: 0 -> static const inline)
.field move: function (size: 0 -> static const inline)
}
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'projection'
.owner: camera
.param .result: void (size: 0 -> inline)
.param fovy: float32 (size: 4 -> variable(f32))
.param aspect: float32 (size: 4 -> variable(f32))
.param near: float32 (size: 4 -> variable(f32))
.param far: float32 (size: 4 -> variable(f32))
.value: nfc(100)
}
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lookAt'
.owner: camera
.param .result: void (size: 0 -> inline)
.param eye: float32[3] (size: 4 -> variable(ref))
.param at: float32[3] (size: 4 -> variable(ref))
.param up: float32[3] (size: 4 -> variable(ref))
.value: nfc(101)
}
camera.readUp(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readUp'
.owner: camera
.param .result: void (size: 0 -> inline)
.param result: float32[3] (size: 4 -> variable(ref))
.value: nfc(102)
}
camera.readRight(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readRight'
.owner: camera
.param .result: void (size: 0 -> inline)
.param result: float32[3] (size: 4 -> variable(ref))
.value: nfc(103)
}
camera.readForward(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readForward'
.owner: camera
.param .result: void (size: 0 -> inline)
.param result: float32[3] (size: 4 -> variable(ref))
.value: nfc(104)
}
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rotate'
.owner: camera
.param .result: void (size: 0 -> inline)
.param direction: float32[3] (size: 4 -> variable(ref))
.param orbit: float32[3] (size: 4 -> variable(ref))
.param angle: float32 (size: 4 -> variable(f32))
.value: nfc(105)
}
camera.move(direction: float32[3], amount: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: camera
.param .result: void (size: 0 -> inline)
.param direction: float32[3] (size: 4 -> variable(ref))
.param amount: float32 (size: 4 -> variable(f32))
.value: nfc(106)
}
lights: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'lights'
.field enabled: function (size: 0 -> static const inline)
.field enable: function (size: 0 -> static const inline)
.field position: function (size: 0 -> static const inline)
.field ambient: function (size: 0 -> static const inline)
.field diffuse: function (size: 0 -> static const inline)
.field specular: function (size: 0 -> static const inline)
.field attenuation: function (size: 0 -> static const inline)
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.value: nfc(107)
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param on: bool (size: 4 -> variable(bool))
.value: nfc(108)
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.param z: float32 (size: 4 -> variable(f32))
.value: nfc(109)
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(110)
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(111)
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param r: float32 (size: 4 -> variable(f32))
.param g: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: nfc(112)
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0 -> inline)
.param light: int32 (size: 4 -> variable(i32))
.param constant: float32 (size: 4 -> variable(f32))
.param linear: float32 (size: 4 -> variable(f32))
.param quadratic: float32 (size: 4 -> variable(f32))
.value: nfc(113)
}
Gui: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'Gui'
.field KEY_PRESS: int64 (size: 0 -> static const i64)
.field KEY_RELEASE: int64 (size: 0 -> static const i64)
.field MOUSE_PRESS: int64 (size: 0 -> static const i64)
.field MOUSE_MOTION: int64 (size: 0 -> static const i64)
.field MOUSE_RELEASE: int64 (size: 0 -> static const i64)
.field EVENT_TIMEOUT: int64 (size: 0 -> static const i64)
.field WINDOW_CREATE: int64 (size: 0 -> static const i64)
.field WINDOW_CLOSE: int64 (size: 0 -> static const i64)
.field WINDOW_ENTER: int64 (size: 0 -> static const i64)
.field WINDOW_LEAVE: int64 (size: 0 -> static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0 -> static const i64)
.field KEY_MASK_CONTROL: int64 (size: 0 -> static const i64)
.field showWindow: function (size: 0 -> static const inline)
.field setTitle: function (size: 0 -> static const inline)
}
Gui.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Gui
.value: 1
}
Gui.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Gui
.value: 2
}
Gui.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Gui
.value: 3
}
Gui.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Gui
.value: 5
}
Gui.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Gui
.value: 4
}
Gui.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Gui
.value: 6
}
Gui.WINDOW_CREATE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CREATE'
.owner: Gui
.value: 100
}
Gui.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Gui
.value: 101
}
Gui.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Gui
.value: 102
}
Gui.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Gui
.value: 103
}
Gui.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Gui
.value: 1
}
Gui.KEY_MASK_CONTROL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CONTROL'
.owner: Gui
.value: 2
}
Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'showWindow'
.owner: Gui
.param .result: void (size: 0 -> inline)
.param surf: gxSurf (size: 8 -> variable(val))
.param closure: pointer (size: 4 -> variable(ref))
.param onEvent: function (size: 4 -> variable(ref))
.value: nfc(114)
}
Gui.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Gui
.param .result: void (size: 0 -> inline)
.param title: char[*] (size: 4 -> variable(ref))
.value: nfc(115)
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'libGfx/gfxlib.vec2d.ci:1'
.field x: float64 (size: 8 -> variable(f64))
.field y: float64 (size: 8 -> variable(f64))
}
vec2d.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'libGfx/gfxlib.vec2d.ci:2'
.owner: vec2d
}
vec2d.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'libGfx/gfxlib.vec2d.ci:3'
.owner: vec2d
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 9
.name: 'vec2d'
.file: 'libGfx/gfxlib.vec2d.ci:6'
.param .result: vec2d (size: 16 -> variable(val))
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (9 bytes)
	libGfx/gfxlib.vec2d.ci:7: (9 bytes): return .result := {...};
	<vec2d+?>:    dup.x2 sp(3)
	<vec2d+?>:    set.x2 sp(7)
	libGfx/gfxlib.vec2d.ci:9: (4 bytes): .result.y := y;
	<vec2d+?>:    dup.x2 sp(1)
	<vec2d+?>:    set.x2 sp(9)
	<vec2d+?>:    ret
}
vec2d(value: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec2d'
.file: 'libGfx/gfxlib.vec2d.ci:13'
.param .result: vec2d (size: 16 -> val)
.param value: vec2d (size: 16 -> val)
.value: value
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'libGfx/gfxlib.vec2d.ci:14'
.param .result: vec2d (size: 16 -> val)
.param a: vec2d (size: 16 -> val)
.param b: vec2d (size: 16 -> val)
.value: vec2d(emit(vec2d(a), vec2d(b), sub.p2d))
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'dot'
.file: 'libGfx/gfxlib.vec2d.ci:22'
.param .result: float64 (size: 8 -> variable(f64))
.param a: vec2d (size: 16 -> const variable(val))
.param b: vec2d (size: 16 -> const variable(val))
.value: {
	return .result := a.x * b.x + a.y * b.y;
}
.instructions: (14 bytes)
	libGfx/gfxlib.vec2d.ci:23: (14 bytes): return .result := a.x * b.x + a.y * b.y;
	<dot+?>:    dup.x2 sp(5)
	<dot+?>:    dup.x2 sp(3)
	<dot+?>:    mul.f64
	<dot+?>:    dup.x2 sp(9)
	<dot+?>:    dup.x2 sp(7)
	<dot+?>:    mul.f64
	<dot+?>:    add.f64
	<dot+?>:    set.x2 sp(11)
	<dot+?>:    ret
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'libGfx/gfxlib.vec4f.ci:2'
.field data: float32[4] (size: 16 -> variable(val))
.field .anonymous: vec4f..anonymous (size: 16 -> variable(val))
.field x: float32 (size: 0 -> inline)
.field y: float32 (size: 0 -> inline)
.field z: float32 (size: 0 -> inline)
.field w: float32 (size: 0 -> inline)
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'libGfx/gfxlib.vec4f.ci:3'
.owner: vec4f
}
vec4f..anonymous: vec4f..anonymous {
.kind: variable(val)
.base: `vec4f..anonymous`
.size: 16
.name: '.anonymous'
.file: 'libGfx/gfxlib.vec4f.ci:28'
.owner: vec4f
.field x: float32 (size: 4 -> variable(f32))
.field y: float32 (size: 4 -> variable(f32))
.field z: float32 (size: 4 -> variable(f32))
.field w: float32 (size: 4 -> variable(f32))
}
vec4f..anonymous.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'libGfx/gfxlib.vec4f.ci:5'
.owner: vec4f..anonymous
}
vec4f..anonymous.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'libGfx/gfxlib.vec4f.ci:6'
.owner: vec4f..anonymous
}
vec4f..anonymous.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'libGfx/gfxlib.vec4f.ci:7'
.owner: vec4f..anonymous
}
vec4f..anonymous.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'libGfx/gfxlib.vec4f.ci:8'
.owner: vec4f..anonymous
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'libGfx/gfxlib.vec4f.ci:5'
.owner: vec4f
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'libGfx/gfxlib.vec4f.ci:6'
.owner: vec4f
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'libGfx/gfxlib.vec4f.ci:7'
.owner: vec4f
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'libGfx/gfxlib.vec4f.ci:8'
.owner: vec4f
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'vec4f'
.file: 'libGfx/gfxlib.vec4f.ci:12'
.param .result: vec4f (size: 16 -> variable(val))
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.param z: float32 (size: 4 -> variable(f32))
.param w: float32 (size: 4 -> variable(f32))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (17 bytes)
	libGfx/gfxlib.vec4f.ci:13: (17 bytes): return .result := {...};
	<vec4f+?>:    dup.x1 sp(4)
	<vec4f+?>:    set.x1 sp(6)
	libGfx/gfxlib.vec4f.ci:13: (4 bytes): .result.y := y;
	<vec4f+?>:    dup.x1 sp(3)
	<vec4f+?>:    set.x1 sp(7)
	libGfx/gfxlib.vec4f.ci:13: (4 bytes): .result.z := z;
	<vec4f+?>:    dup.x1 sp(2)
	<vec4f+?>:    set.x1 sp(8)
	libGfx/gfxlib.vec4f.ci:13: (4 bytes): .result.w := w;
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(9)
	<vec4f+?>:    ret
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 20
.name: 'vec4f'
.file: 'libGfx/gfxlib.vec4f.ci:15'
.param .result: vec4f (size: 16 -> variable(val))
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.param z: float32 (size: 4 -> variable(f32))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := 0.000000;
		};
}
.instructions: (20 bytes)
	libGfx/gfxlib.vec4f.ci:16: (20 bytes): return .result := {...};
	<vec4f+?>:    dup.x1 sp(3)
	<vec4f+?>:    set.x1 sp(5)
	libGfx/gfxlib.vec4f.ci:16: (4 bytes): .result.y := y;
	<vec4f+?>:    dup.x1 sp(2)
	<vec4f+?>:    set.x1 sp(6)
	libGfx/gfxlib.vec4f.ci:16: (4 bytes): .result.z := z;
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(7)
	libGfx/gfxlib.vec4f.ci:16: (7 bytes): .result.w := 0.000000;
	<vec4f+?>:    load.f32 0.000000
	<vec4f+?>:    set.x1 sp(8)
	<vec4f+?>:    ret
}
vec4f(xyzw: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'vec4f'
.file: 'libGfx/gfxlib.vec4f.ci:18'
.param .result: vec4f (size: 16 -> variable(val))
.param xyzw: float32 (size: 4 -> variable(f32))
.value: {
	return .result := {
			.result.x := xyzw;
			.result.y := xyzw;
			.result.z := xyzw;
			.result.w := xyzw;
		};
}
.instructions: (17 bytes)
	libGfx/gfxlib.vec4f.ci:19: (17 bytes): return .result := {...};
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(3)
	libGfx/gfxlib.vec4f.ci:19: (4 bytes): .result.y := xyzw;
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(4)
	libGfx/gfxlib.vec4f.ci:19: (4 bytes): .result.z := xyzw;
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(5)
	libGfx/gfxlib.vec4f.ci:19: (4 bytes): .result.w := xyzw;
	<vec4f+?>:    dup.x1 sp(1)
	<vec4f+?>:    set.x1 sp(6)
	<vec4f+?>:    ret
}
vec4f(value: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'libGfx/gfxlib.vec4f.ci:22'
.param .result: vec4f (size: 16 -> val)
.param value: vec4f (size: 16 -> val)
.value: value
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'libGfx/gfxlib.vec4f.ci:23'
.param .result: float32 (size: 4 -> f32)
.param lhs: vec4f (size: 16 -> val)
.param rhs: vec4f (size: 16 -> val)
.value: float32(emit(vec4f(rhs), vec4f(lhs), p4x.dp3))
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'libGfx/gfxlib.vec4f.ci:24'
.param .result: float32 (size: 4 -> f32)
.param lhs: vec4f (size: 16 -> val)
.param rhs: vec4f (size: 16 -> val)
.value: float32(emit(vec4f(rhs), vec4f(lhs), p4x.dp4))
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'libGfx/gfxlib.vec4f.ci:25'
.param .result: float32 (size: 4 -> f32)
.param lhs: vec4f (size: 16 -> val)
.param rhs: vec4f (size: 16 -> val)
.value: float32(emit(vec4f(rhs), vec4f(lhs), p4x.dph))
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'libGfx/gfxlib.vec4f.ci:27'
.param .result: vec4f (size: 16 -> val)
.param a: vec4f (size: 16 -> variable(val))
.param b: vec4f (size: 16 -> variable(val))
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'libGfx/gfxlib.mat4f.ci:2'
.field data: float32[16] (size: 64 -> variable(val))
.field .anonymous: mat4f..anonymous (size: 64 -> variable(val))
.field x: vec4f (size: 0 -> inline)
.field y: vec4f (size: 0 -> inline)
.field z: vec4f (size: 0 -> inline)
.field w: vec4f (size: 0 -> inline)
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'libGfx/gfxlib.mat4f.ci:3'
.owner: mat4f
}
mat4f..anonymous: mat4f..anonymous {
.kind: variable(val)
.base: `mat4f..anonymous`
.size: 64
.name: '.anonymous'
.file: 'libGfx/gfxlib.mat4f.ci:48'
.owner: mat4f
.field x: vec4f (size: 16 -> variable(val))
.field y: vec4f (size: 16 -> variable(val))
.field z: vec4f (size: 16 -> variable(val))
.field w: vec4f (size: 16 -> variable(val))
}
mat4f..anonymous.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'libGfx/gfxlib.mat4f.ci:5'
.owner: mat4f..anonymous
}
mat4f..anonymous.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'libGfx/gfxlib.mat4f.ci:6'
.owner: mat4f..anonymous
}
mat4f..anonymous.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'libGfx/gfxlib.mat4f.ci:7'
.owner: mat4f..anonymous
}
mat4f..anonymous.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'libGfx/gfxlib.mat4f.ci:8'
.owner: mat4f..anonymous
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'libGfx/gfxlib.mat4f.ci:5'
.owner: mat4f
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'libGfx/gfxlib.mat4f.ci:6'
.owner: mat4f
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'libGfx/gfxlib.mat4f.ci:7'
.owner: mat4f
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'libGfx/gfxlib.mat4f.ci:8'
.owner: mat4f
.value: w: vec4f
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 65
.name: 'mat4f'
.file: 'libGfx/gfxlib.mat4f.ci:12'
.param .result: mat4f (size: 64 -> variable(val))
.param xx: float32 (size: 4 -> variable(f32))
.param xy: float32 (size: 4 -> variable(f32))
.param xz: float32 (size: 4 -> variable(f32))
.param xw: float32 (size: 4 -> variable(f32))
.param yx: float32 (size: 4 -> variable(f32))
.param yy: float32 (size: 4 -> variable(f32))
.param yz: float32 (size: 4 -> variable(f32))
.param yw: float32 (size: 4 -> variable(f32))
.param zx: float32 (size: 4 -> variable(f32))
.param zy: float32 (size: 4 -> variable(f32))
.param zz: float32 (size: 4 -> variable(f32))
.param zw: float32 (size: 4 -> variable(f32))
.param wx: float32 (size: 4 -> variable(f32))
.param wy: float32 (size: 4 -> variable(f32))
.param wz: float32 (size: 4 -> variable(f32))
.param ww: float32 (size: 4 -> variable(f32))
.value: {
	return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
}
.instructions: (65 bytes)
	libGfx/gfxlib.mat4f.ci:16: (65 bytes): return .result := {...};
	<mat4f+?>:    dup.x1 sp(16)
	<mat4f+?>:    set.x1 sp(18)
	libGfx/gfxlib.mat4f.ci:17: (4 bytes): .result.x.y := xy;
	<mat4f+?>:    dup.x1 sp(15)
	<mat4f+?>:    set.x1 sp(19)
	libGfx/gfxlib.mat4f.ci:17: (4 bytes): .result.x.z := xz;
	<mat4f+?>:    dup.x1 sp(14)
	<mat4f+?>:    set.x1 sp(20)
	libGfx/gfxlib.mat4f.ci:17: (4 bytes): .result.x.w := xw;
	<mat4f+?>:    dup.x1 sp(13)
	<mat4f+?>:    set.x1 sp(21)
	libGfx/gfxlib.mat4f.ci:18: (4 bytes): .result.y.x := yx;
	<mat4f+?>:    dup.x1 sp(12)
	<mat4f+?>:    set.x1 sp(22)
	libGfx/gfxlib.mat4f.ci:18: (4 bytes): .result.y.y := yy;
	<mat4f+?>:    dup.x1 sp(11)
	<mat4f+?>:    set.x1 sp(23)
	libGfx/gfxlib.mat4f.ci:18: (4 bytes): .result.y.z := yz;
	<mat4f+?>:    dup.x1 sp(10)
	<mat4f+?>:    set.x1 sp(24)
	libGfx/gfxlib.mat4f.ci:18: (4 bytes): .result.y.w := yw;
	<mat4f+?>:    dup.x1 sp(9)
	<mat4f+?>:    set.x1 sp(25)
	libGfx/gfxlib.mat4f.ci:19: (4 bytes): .result.z.x := zx;
	<mat4f+?>:    dup.x1 sp(8)
	<mat4f+?>:    set.x1 sp(26)
	libGfx/gfxlib.mat4f.ci:19: (4 bytes): .result.z.y := zy;
	<mat4f+?>:    dup.x1 sp(7)
	<mat4f+?>:    set.x1 sp(27)
	libGfx/gfxlib.mat4f.ci:19: (4 bytes): .result.z.z := zz;
	<mat4f+?>:    dup.x1 sp(6)
	<mat4f+?>:    set.x1 sp(28)
	libGfx/gfxlib.mat4f.ci:19: (4 bytes): .result.z.w := zw;
	<mat4f+?>:    dup.x1 sp(5)
	<mat4f+?>:    set.x1 sp(29)
	libGfx/gfxlib.mat4f.ci:20: (4 bytes): .result.w.x := wx;
	<mat4f+?>:    dup.x1 sp(4)
	<mat4f+?>:    set.x1 sp(30)
	libGfx/gfxlib.mat4f.ci:20: (4 bytes): .result.w.y := wy;
	<mat4f+?>:    dup.x1 sp(3)
	<mat4f+?>:    set.x1 sp(31)
	libGfx/gfxlib.mat4f.ci:20: (4 bytes): .result.w.z := wz;
	<mat4f+?>:    dup.x1 sp(2)
	<mat4f+?>:    set.x1 sp(32)
	libGfx/gfxlib.mat4f.ci:20: (4 bytes): .result.w.w := ww;
	<mat4f+?>:    dup.x1 sp(1)
	<mat4f+?>:    set.x1 sp(33)
	<mat4f+?>:    ret
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'mat4f'
.file: 'libGfx/gfxlib.mat4f.ci:24'
.param .result: mat4f (size: 64 -> variable(val))
.param x: vec4f (size: 16 -> variable(val))
.param y: vec4f (size: 16 -> variable(val))
.param z: vec4f (size: 16 -> variable(val))
.param w: vec4f (size: 16 -> variable(val))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (17 bytes)
	libGfx/gfxlib.mat4f.ci:25: (17 bytes): return .result := {...};
	<mat4f+?>:    dup.x4 sp(13)
	<mat4f+?>:    set.x4 sp(21)
	libGfx/gfxlib.mat4f.ci:25: (4 bytes): .result.y := y;
	<mat4f+?>:    dup.x4 sp(9)
	<mat4f+?>:    set.x4 sp(25)
	libGfx/gfxlib.mat4f.ci:25: (4 bytes): .result.z := z;
	<mat4f+?>:    dup.x4 sp(5)
	<mat4f+?>:    set.x4 sp(29)
	libGfx/gfxlib.mat4f.ci:25: (4 bytes): .result.w := w;
	<mat4f+?>:    dup.x4 sp(1)
	<mat4f+?>:    set.x4 sp(33)
	<mat4f+?>:    ret
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'libGfx/gfxlib.mat4f.ci:28'
.param .result: vec4f (size: 16 -> val)
.param mat: mat4f (size: 64 -> variable(val))
.param vec: vec4f (size: 16 -> variable(val))
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), float32(1))
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'libGfx/gfxlib.mat4f.ci:29'
.param .result: vec4f (size: 16 -> val)
.param mat: mat4f (size: 64 -> variable(val))
.param vec: vec4f (size: 16 -> variable(val))
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'libGfx/gfxlib.mat4f.ci:30'
.param .result: vec4f (size: 16 -> val)
.param mat: mat4f (size: 64 -> variable(val))
.param vec: vec4f (size: 16 -> variable(val))
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 410
.name: 'mul'
.file: 'libGfx/gfxlib.mat4f.ci:32'
.param .result: mat4f (size: 64 -> variable(val))
.param lhs: mat4f (size: 4 -> const variable(ref))
.param rhs: mat4f (size: 4 -> const variable(ref))
.value: {
	transposed: mat4f := {
		transposed.x.x := rhs.x.x;
		transposed.x.y := rhs.y.x;
		transposed.x.z := rhs.z.x;
		transposed.x.w := rhs.w.x;
		transposed.y.x := rhs.x.y;
		transposed.y.y := rhs.y.y;
		transposed.y.z := rhs.z.y;
		transposed.y.w := rhs.w.y;
		transposed.z.x := rhs.x.z;
		transposed.z.y := rhs.y.z;
		transposed.z.z := rhs.z.z;
		transposed.z.w := rhs.w.z;
		transposed.w.x := rhs.x.w;
		transposed.w.y := rhs.y.w;
		transposed.w.z := rhs.z.w;
		transposed.w.w := rhs.w.w;
	};
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (410 bytes)
	libGfx/gfxlib.mat4f.ci:33: (144 bytes): transposed: mat4f := {...}
	<mul+?>:    inc.sp(+64)
	libGfx/gfxlib.mat4f.ci:34: (5 bytes): transposed.x.x := rhs.x.x;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(1)
	libGfx/gfxlib.mat4f.ci:34: (9 bytes): transposed.x.y := rhs.y.x;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+16)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(2)
	libGfx/gfxlib.mat4f.ci:34: (9 bytes): transposed.x.z := rhs.z.x;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+32)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(3)
	libGfx/gfxlib.mat4f.ci:34: (9 bytes): transposed.x.w := rhs.w.x;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+48)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(4)
	libGfx/gfxlib.mat4f.ci:35: (9 bytes): transposed.y.x := rhs.x.y;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+4)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(5)
	libGfx/gfxlib.mat4f.ci:35: (9 bytes): transposed.y.y := rhs.y.y;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+20)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(6)
	libGfx/gfxlib.mat4f.ci:35: (9 bytes): transposed.y.z := rhs.z.y;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+36)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(7)
	libGfx/gfxlib.mat4f.ci:35: (9 bytes): transposed.y.w := rhs.w.y;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+52)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(8)
	libGfx/gfxlib.mat4f.ci:36: (9 bytes): transposed.z.x := rhs.x.z;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+8)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(9)
	libGfx/gfxlib.mat4f.ci:36: (9 bytes): transposed.z.y := rhs.y.z;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+24)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(10)
	libGfx/gfxlib.mat4f.ci:36: (9 bytes): transposed.z.z := rhs.z.z;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+40)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(11)
	libGfx/gfxlib.mat4f.ci:36: (9 bytes): transposed.z.w := rhs.w.z;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+56)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(12)
	libGfx/gfxlib.mat4f.ci:37: (9 bytes): transposed.w.x := rhs.x.w;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+12)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(13)
	libGfx/gfxlib.mat4f.ci:37: (9 bytes): transposed.w.y := rhs.y.w;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+28)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(14)
	libGfx/gfxlib.mat4f.ci:37: (9 bytes): transposed.w.z := rhs.z.w;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+44)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(15)
	libGfx/gfxlib.mat4f.ci:37: (9 bytes): transposed.w.w := rhs.w.w;
	<mul+?>:    dup.x1 sp(17)
	<mul+?>:    inc.i32(+60)
	<mul+?>:    load.i32
	<mul+?>:    set.x1 sp(16)
	libGfx/gfxlib.mat4f.ci:40: (261 bytes): return .result := {...};
	<mul+?>:    load.sp(+0)
	<mul+?>:    load.sp(-60)
	<mul+?>:    copy.mem -64
	<mul+?>:    inc.sp(+64)
	<mul+?>:    dup.x1 sp(34)
	<mul+?>:    load.i128
	<mul+?>:    inc.sp(+16)
	<mul+?>:    dup.x4 sp(4)
	<mul+?>:    dup.x4 sp(12)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(5)
	<mul+?>:    dup.x4 sp(17)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(6)
	<mul+?>:    dup.x4 sp(22)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(7)
	<mul+?>:    dup.x4 sp(27)
	<mul+?>:    dp4.v4f
	<mul+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>:    call
	<mul+?>:    inc.sp(-16)
	<mul+?>:    set.x4 sp(20)
	<mul+?>:    inc.sp(-64)
	<mul+?>:    set.x4 sp(23)
	libGfx/gfxlib.mat4f.ci:42: (65 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>:    load.sp(+0)
	<mul+?>:    load.sp(-60)
	<mul+?>:    copy.mem -64
	<mul+?>:    inc.sp(+64)
	<mul+?>:    dup.x1 sp(34)
	<mul+?>:    inc.i32(+16)
	<mul+?>:    load.i128
	<mul+?>:    inc.sp(+16)
	<mul+?>:    dup.x4 sp(4)
	<mul+?>:    dup.x4 sp(12)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(5)
	<mul+?>:    dup.x4 sp(17)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(6)
	<mul+?>:    dup.x4 sp(22)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(7)
	<mul+?>:    dup.x4 sp(27)
	<mul+?>:    dp4.v4f
	<mul+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>:    call
	<mul+?>:    inc.sp(-16)
	<mul+?>:    set.x4 sp(20)
	<mul+?>:    inc.sp(-64)
	<mul+?>:    set.x4 sp(27)
	libGfx/gfxlib.mat4f.ci:43: (65 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>:    load.sp(+0)
	<mul+?>:    load.sp(-60)
	<mul+?>:    copy.mem -64
	<mul+?>:    inc.sp(+64)
	<mul+?>:    dup.x1 sp(34)
	<mul+?>:    inc.i32(+32)
	<mul+?>:    load.i128
	<mul+?>:    inc.sp(+16)
	<mul+?>:    dup.x4 sp(4)
	<mul+?>:    dup.x4 sp(12)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(5)
	<mul+?>:    dup.x4 sp(17)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(6)
	<mul+?>:    dup.x4 sp(22)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(7)
	<mul+?>:    dup.x4 sp(27)
	<mul+?>:    dp4.v4f
	<mul+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>:    call
	<mul+?>:    inc.sp(-16)
	<mul+?>:    set.x4 sp(20)
	<mul+?>:    inc.sp(-64)
	<mul+?>:    set.x4 sp(31)
	libGfx/gfxlib.mat4f.ci:44: (65 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>:    load.sp(+0)
	<mul+?>:    load.sp(-60)
	<mul+?>:    copy.mem -64
	<mul+?>:    inc.sp(+64)
	<mul+?>:    dup.x1 sp(34)
	<mul+?>:    inc.i32(+48)
	<mul+?>:    load.i128
	<mul+?>:    inc.sp(+16)
	<mul+?>:    dup.x4 sp(4)
	<mul+?>:    dup.x4 sp(12)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(5)
	<mul+?>:    dup.x4 sp(17)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(6)
	<mul+?>:    dup.x4 sp(22)
	<mul+?>:    dp4.v4f
	<mul+?>:    dup.x4 sp(7)
	<mul+?>:    dup.x4 sp(27)
	<mul+?>:    dp4.v4f
	<mul+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>:    call
	<mul+?>:    inc.sp(-16)
	<mul+?>:    set.x4 sp(20)
	<mul+?>:    inc.sp(-64)
	<mul+?>:    set.x4 sp(35)
	<mul+?>:    inc.sp(-64)
	<mul+?>:    ret
	<mul+?>:    inc.sp(-64)
	<mul+?>:    ret
}
grayClamp(c: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 25
.name: 'grayClamp'
.file: 'libGfx/gfxlib.color.ci:2'
.param .result: uint32 (size: 4 -> variable(u32))
.param c: uint32 (size: 4 -> variable(u32))
.value: {
	if (c > (255)) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (25 bytes)
	libGfx/gfxlib.color.ci:3: (20 bytes): if (c > (255))
	<grayClamp+?>:    dup.x1 sp(1)
	<grayClamp+?>:    load.c32 255
	<grayClamp+?>:    cgt.u32
	<grayClamp+?>:    jz <grayClamp+?>
	libGfx/gfxlib.color.ci:4: (8 bytes): return .result := 255;
	<grayClamp+?>:    load.c32 255
	<grayClamp+?>:    set.x1 sp(3)
	<grayClamp+?>:    ret
	libGfx/gfxlib.color.ci:6: (5 bytes): return .result := c;
	<grayClamp+?>:    dup.x1 sp(1)
	<grayClamp+?>:    set.x1 sp(3)
	<grayClamp+?>:    ret
}
grayClamp(c: int32): uint32: function {
.kind: static const function
.base: `function`
.size: 37
.name: 'grayClamp'
.file: 'libGfx/gfxlib.color.ci:8'
.param .result: uint32 (size: 4 -> variable(u32))
.param c: int32 (size: 4 -> variable(i32))
.value: {
	if (c < 0) {
		return .result := 0;
	}
	if (c > 255) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (37 bytes)
	libGfx/gfxlib.color.ci:9: (12 bytes): if (c < 0)
	<grayClamp+?>:    dup.x1 sp(1)
	<grayClamp+?>:    load.z32
	<grayClamp+?>:    clt.i32
	<grayClamp+?>:    jz <grayClamp+?>
	libGfx/gfxlib.color.ci:10: (4 bytes): return .result := 0;
	<grayClamp+?>:    load.z32
	<grayClamp+?>:    set.x1 sp(3)
	<grayClamp+?>:    ret
	libGfx/gfxlib.color.ci:12: (20 bytes): if (c > 255)
	<grayClamp+?>:    dup.x1 sp(1)
	<grayClamp+?>:    load.c32 255
	<grayClamp+?>:    cgt.i32
	<grayClamp+?>:    jz <grayClamp+?>
	libGfx/gfxlib.color.ci:13: (8 bytes): return .result := 255;
	<grayClamp+?>:    load.c32 255
	<grayClamp+?>:    set.x1 sp(3)
	<grayClamp+?>:    ret
	libGfx/gfxlib.color.ci:15: (5 bytes): return .result := c;
	<grayClamp+?>:    dup.x1 sp(1)
	<grayClamp+?>:    set.x1 sp(3)
	<grayClamp+?>:    ret
}
grayAnd(c: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'grayAnd'
.file: 'libGfx/gfxlib.color.ci:17'
.param .result: uint32 (size: 4 -> u32)
.param c: uint32 (size: 4 -> u32)
.value: uint32(c & (255))
}
rgb(r: int32, g: int32, b: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'libGfx/gfxlib.color.ci:19'
.param .result: uint32 (size: 4 -> u32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: uint32((((r << 8) | g) << 8) | b)
}
rgb(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'libGfx/gfxlib.color.ci:20'
.param .result: uint32 (size: 4 -> u32)
.param r: uint32 (size: 4 -> u32)
.param g: uint32 (size: 4 -> u32)
.param b: uint32 (size: 4 -> u32)
.value: uint32((((r << 8) | g) << 8) | b)
}
rgbClamp(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbClamp'
.file: 'libGfx/gfxlib.color.ci:21'
.param .result: uint32 (size: 4 -> u32)
.param r: uint32 (size: 4 -> u32)
.param g: uint32 (size: 4 -> u32)
.param b: uint32 (size: 4 -> u32)
.value: rgb(grayClamp(r), grayClamp(g), grayClamp(b))
}
rgbClamp(r: int32, g: int32, b: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbClamp'
.file: 'libGfx/gfxlib.color.ci:22'
.param .result: uint32 (size: 4 -> u32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: rgb(grayClamp(r), grayClamp(g), grayClamp(b))
}
rgbAnd(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbAnd'
.file: 'libGfx/gfxlib.color.ci:23'
.param .result: uint32 (size: 4 -> u32)
.param r: uint32 (size: 4 -> u32)
.param g: uint32 (size: 4 -> u32)
.param b: uint32 (size: 4 -> u32)
.value: rgb(grayAnd(r), grayAnd(g), grayAnd(b))
}
rgb(r: float64, g: float64, b: float64): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'libGfx/gfxlib.color.ci:25'
.param .result: uint32 (size: 4 -> u32)
.param r: float64 (size: 8 -> f64)
.param g: float64 (size: 8 -> f64)
.param b: float64 (size: 8 -> f64)
.value: rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)))
}
rgb(r: float32, g: float32, b: float32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'libGfx/gfxlib.color.ci:26'
.param .result: uint32 (size: 4 -> u32)
.param r: float32 (size: 4 -> f32)
.param g: float32 (size: 4 -> f32)
.param b: float32 (size: 4 -> f32)
.value: rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)))
}
gray(c: float64): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'libGfx/gfxlib.color.ci:27'
.param .result: uint32 (size: 4 -> u32)
.param c: float64 (size: 8 -> f64)
.value: grayClamp(int32(c * (255)))
}
gray(c: float32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'libGfx/gfxlib.color.ci:28'
.param .result: uint32 (size: 4 -> u32)
.param c: float32 (size: 4 -> f32)
.value: grayClamp(int32(c * (255)))
}
rch(col: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'libGfx/gfxlib.color.ci:31'
.param .result: int32 (size: 4 -> i32)
.param col: int32 (size: 4 -> i32)
.value: int32((col >> 16) & 255)
}
gch(col: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'libGfx/gfxlib.color.ci:33'
.param .result: int32 (size: 4 -> i32)
.param col: int32 (size: 4 -> i32)
.value: int32((col >> 8) & 255)
}
bch(col: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'libGfx/gfxlib.color.ci:35'
.param .result: int32 (size: 4 -> i32)
.param col: int32 (size: 4 -> i32)
.value: int32(col & 255)
}
lum(c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'libGfx/gfxlib.color.ci:37'
.param .result: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> variable(i32))
.value: int32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8)
}
rgbOr(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbOr'
.file: 'libGfx/gfxlib.color.ci:51'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	return .result := c1 | c2;
}
.instructions: (8 bytes)
	libGfx/gfxlib.color.ci:52: (8 bytes): return .result := c1 | c2;
	<rgbOr+?>:    dup.x1 sp(2)
	<rgbOr+?>:    dup.x1 sp(2)
	<rgbOr+?>:    or.b32
	<rgbOr+?>:    set.x1 sp(4)
	<rgbOr+?>:    ret
}
rgbXor(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbXor'
.file: 'libGfx/gfxlib.color.ci:54'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	return .result := c1 ^ c2;
}
.instructions: (8 bytes)
	libGfx/gfxlib.color.ci:55: (8 bytes): return .result := c1 ^ c2;
	<rgbXor+?>:    dup.x1 sp(2)
	<rgbXor+?>:    dup.x1 sp(2)
	<rgbXor+?>:    xor.b32
	<rgbXor+?>:    set.x1 sp(4)
	<rgbXor+?>:    ret
}
rgbAnd(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbAnd'
.file: 'libGfx/gfxlib.color.ci:57'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	return .result := c1 & c2;
}
.instructions: (8 bytes)
	libGfx/gfxlib.color.ci:58: (8 bytes): return .result := c1 & c2;
	<rgbAnd+?>:    dup.x1 sp(2)
	<rgbAnd+?>:    dup.x1 sp(2)
	<rgbAnd+?>:    and.b32
	<rgbAnd+?>:    set.x1 sp(4)
	<rgbAnd+?>:    ret
}
rgbAdd(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 92
.name: 'rgbAdd'
.file: 'libGfx/gfxlib.color.ci:60'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	r: uint32 := rch(c1) + rch(c2);
	g: uint32 := gch(c1) + gch(c2);
	b: uint32 := bch(c1) + bch(c2);
	return .result := rgbClamp(r, g, b);
}
.instructions: (92 bytes)
	libGfx/gfxlib.color.ci:61: (13 bytes): r: uint32 := rch(c1) + rch(c2)
	<rgbAdd+?>:    dup.x1 sp(2)
	<rgbAdd+?>:    b32.sar 0x010
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    dup.x1 sp(2)
	<rgbAdd+?>:    b32.sar 0x010
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    add.i32
	libGfx/gfxlib.color.ci:62: (13 bytes): g: uint32 := gch(c1) + gch(c2)
	<rgbAdd+?>:    dup.x1 sp(3)
	<rgbAdd+?>:    b32.sar 0x008
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    dup.x1 sp(3)
	<rgbAdd+?>:    b32.sar 0x008
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    add.i32
	libGfx/gfxlib.color.ci:63: (9 bytes): b: uint32 := bch(c1) + bch(c2)
	<rgbAdd+?>:    dup.x1 sp(4)
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    dup.x1 sp(4)
	<rgbAdd+?>:    b32.and 0x0ff
	<rgbAdd+?>:    add.i32
	libGfx/gfxlib.color.ci:64: (52 bytes): return .result := rgbClamp(r, g, b);
	<rgbAdd+?>:    load.z32
	<rgbAdd+?>:    dup.x1 sp(3)
	<rgbAdd+?>:    load.ref .?????? ;grayClamp(c: uint32): uint32
	<rgbAdd+?>:    call
	<rgbAdd+?>:    inc.sp(-4)
	<rgbAdd+?>:    b32.shl 0x008
	<rgbAdd+?>:    load.z32
	<rgbAdd+?>:    dup.x1 sp(3)
	<rgbAdd+?>:    load.ref .?????? ;grayClamp(c: uint32): uint32
	<rgbAdd+?>:    call
	<rgbAdd+?>:    inc.sp(-4)
	<rgbAdd+?>:    or.b32
	<rgbAdd+?>:    b32.shl 0x008
	<rgbAdd+?>:    load.z32
	<rgbAdd+?>:    dup.x1 sp(2)
	<rgbAdd+?>:    load.ref .?????? ;grayClamp(c: uint32): uint32
	<rgbAdd+?>:    call
	<rgbAdd+?>:    inc.sp(-4)
	<rgbAdd+?>:    or.b32
	<rgbAdd+?>:    set.x1 sp(7)
	<rgbAdd+?>:    inc.sp(-12)
	<rgbAdd+?>:    ret
	<rgbAdd+?>:    inc.sp(-12)
	<rgbAdd+?>:    ret
}
rgbAvg(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 77
.name: 'rgbAvg'
.file: 'libGfx/gfxlib.color.ci:66'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	r: uint32 := (rch(c1) + rch(c2)) / 2;
	g: uint32 := (gch(c1) + gch(c2)) / 2;
	b: uint32 := (bch(c1) + bch(c2)) / 2;
	return .result := rgb(r, g, b);
}
.instructions: (77 bytes)
	libGfx/gfxlib.color.ci:67: (19 bytes): r: uint32 := (rch(c1) + rch(c2)) / 2
	<rgbAvg+?>:    dup.x1 sp(2)
	<rgbAvg+?>:    b32.sar 0x010
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    dup.x1 sp(2)
	<rgbAvg+?>:    b32.sar 0x010
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    add.i32
	<rgbAvg+?>:    load.c32 2
	<rgbAvg+?>:    div.i32
	libGfx/gfxlib.color.ci:68: (19 bytes): g: uint32 := (gch(c1) + gch(c2)) / 2
	<rgbAvg+?>:    dup.x1 sp(3)
	<rgbAvg+?>:    b32.sar 0x008
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    dup.x1 sp(3)
	<rgbAvg+?>:    b32.sar 0x008
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    add.i32
	<rgbAvg+?>:    load.c32 2
	<rgbAvg+?>:    div.i32
	libGfx/gfxlib.color.ci:69: (15 bytes): b: uint32 := (bch(c1) + bch(c2)) / 2
	<rgbAvg+?>:    dup.x1 sp(4)
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    dup.x1 sp(4)
	<rgbAvg+?>:    b32.and 0x0ff
	<rgbAvg+?>:    add.i32
	<rgbAvg+?>:    load.c32 2
	<rgbAvg+?>:    div.i32
	libGfx/gfxlib.color.ci:70: (19 bytes): return .result := rgb(r, g, b);
	<rgbAvg+?>:    dup.x1 sp(2)
	<rgbAvg+?>:    b32.shl 0x008
	<rgbAvg+?>:    dup.x1 sp(2)
	<rgbAvg+?>:    or.b32
	<rgbAvg+?>:    b32.shl 0x008
	<rgbAvg+?>:    dup.x1 sp(1)
	<rgbAvg+?>:    or.b32
	<rgbAvg+?>:    set.x1 sp(7)
	<rgbAvg+?>:    inc.sp(-12)
	<rgbAvg+?>:    ret
	<rgbAvg+?>:    inc.sp(-12)
	<rgbAvg+?>:    ret
}
rgbSub(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 92
.name: 'rgbSub'
.file: 'libGfx/gfxlib.color.ci:72'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	r: int32 := rch(c1) - rch(c2);
	g: int32 := gch(c1) - gch(c2);
	b: int32 := bch(c1) - bch(c2);
	return .result := rgbClamp(r, g, b);
}
.instructions: (92 bytes)
	libGfx/gfxlib.color.ci:73: (13 bytes): r: int32 := rch(c1) - rch(c2)
	<rgbSub+?>:    dup.x1 sp(2)
	<rgbSub+?>:    b32.sar 0x010
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    dup.x1 sp(2)
	<rgbSub+?>:    b32.sar 0x010
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    sub.i32
	libGfx/gfxlib.color.ci:74: (13 bytes): g: int32 := gch(c1) - gch(c2)
	<rgbSub+?>:    dup.x1 sp(3)
	<rgbSub+?>:    b32.sar 0x008
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    dup.x1 sp(3)
	<rgbSub+?>:    b32.sar 0x008
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    sub.i32
	libGfx/gfxlib.color.ci:75: (9 bytes): b: int32 := bch(c1) - bch(c2)
	<rgbSub+?>:    dup.x1 sp(4)
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    dup.x1 sp(4)
	<rgbSub+?>:    b32.and 0x0ff
	<rgbSub+?>:    sub.i32
	libGfx/gfxlib.color.ci:76: (52 bytes): return .result := rgbClamp(r, g, b);
	<rgbSub+?>:    load.z32
	<rgbSub+?>:    dup.x1 sp(3)
	<rgbSub+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<rgbSub+?>:    call
	<rgbSub+?>:    inc.sp(-4)
	<rgbSub+?>:    b32.shl 0x008
	<rgbSub+?>:    load.z32
	<rgbSub+?>:    dup.x1 sp(3)
	<rgbSub+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<rgbSub+?>:    call
	<rgbSub+?>:    inc.sp(-4)
	<rgbSub+?>:    or.b32
	<rgbSub+?>:    b32.shl 0x008
	<rgbSub+?>:    load.z32
	<rgbSub+?>:    dup.x1 sp(2)
	<rgbSub+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<rgbSub+?>:    call
	<rgbSub+?>:    inc.sp(-4)
	<rgbSub+?>:    or.b32
	<rgbSub+?>:    set.x1 sp(7)
	<rgbSub+?>:    inc.sp(-12)
	<rgbSub+?>:    ret
	<rgbSub+?>:    inc.sp(-12)
	<rgbSub+?>:    ret
}
rgbMul(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 77
.name: 'rgbMul'
.file: 'libGfx/gfxlib.color.ci:78'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	r: uint32 := (rch(c1) * (rch(c2) + 1)) >> 8;
	g: uint32 := (gch(c1) * (gch(c2) + 1)) >> 8;
	b: uint32 := (bch(c1) * (bch(c2) + 1)) >> 8;
	return .result := rgb(r, g, b);
}
.instructions: (77 bytes)
	libGfx/gfxlib.color.ci:79: (19 bytes): r: uint32 := (rch(c1) * (rch(c2) + 1)) >> 8
	<rgbMul+?>:    dup.x1 sp(2)
	<rgbMul+?>:    b32.sar 0x010
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    dup.x1 sp(2)
	<rgbMul+?>:    b32.sar 0x010
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    inc.i32(+1)
	<rgbMul+?>:    mul.i32
	<rgbMul+?>:    b32.sar 0x008
	libGfx/gfxlib.color.ci:80: (19 bytes): g: uint32 := (gch(c1) * (gch(c2) + 1)) >> 8
	<rgbMul+?>:    dup.x1 sp(3)
	<rgbMul+?>:    b32.sar 0x008
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    dup.x1 sp(3)
	<rgbMul+?>:    b32.sar 0x008
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    inc.i32(+1)
	<rgbMul+?>:    mul.i32
	<rgbMul+?>:    b32.sar 0x008
	libGfx/gfxlib.color.ci:81: (15 bytes): b: uint32 := (bch(c1) * (bch(c2) + 1)) >> 8
	<rgbMul+?>:    dup.x1 sp(4)
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    dup.x1 sp(4)
	<rgbMul+?>:    b32.and 0x0ff
	<rgbMul+?>:    inc.i32(+1)
	<rgbMul+?>:    mul.i32
	<rgbMul+?>:    b32.sar 0x008
	libGfx/gfxlib.color.ci:82: (19 bytes): return .result := rgb(r, g, b);
	<rgbMul+?>:    dup.x1 sp(2)
	<rgbMul+?>:    b32.shl 0x008
	<rgbMul+?>:    dup.x1 sp(2)
	<rgbMul+?>:    or.b32
	<rgbMul+?>:    b32.shl 0x008
	<rgbMul+?>:    dup.x1 sp(1)
	<rgbMul+?>:    or.b32
	<rgbMul+?>:    set.x1 sp(7)
	<rgbMul+?>:    inc.sp(-12)
	<rgbMul+?>:    ret
	<rgbMul+?>:    inc.sp(-12)
	<rgbMul+?>:    ret
}
rgbDiv(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 77
.name: 'rgbDiv'
.file: 'libGfx/gfxlib.color.ci:84'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.value: {
	r: uint32 := (rch(c1) << 8) / (rch(c2) + 1);
	g: uint32 := (gch(c1) << 8) / (gch(c2) + 1);
	b: uint32 := (bch(c1) << 8) / (bch(c2) + 1);
	return .result := rgb(r, g, b);
}
.instructions: (77 bytes)
	libGfx/gfxlib.color.ci:85: (19 bytes): r: uint32 := (rch(c1) << 8) / (rch(c2) + 1)
	<rgbDiv+?>:    dup.x1 sp(2)
	<rgbDiv+?>:    b32.sar 0x010
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    b32.shl 0x008
	<rgbDiv+?>:    dup.x1 sp(2)
	<rgbDiv+?>:    b32.sar 0x010
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    inc.i32(+1)
	<rgbDiv+?>:    div.i32
	libGfx/gfxlib.color.ci:86: (19 bytes): g: uint32 := (gch(c1) << 8) / (gch(c2) + 1)
	<rgbDiv+?>:    dup.x1 sp(3)
	<rgbDiv+?>:    b32.sar 0x008
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    b32.shl 0x008
	<rgbDiv+?>:    dup.x1 sp(3)
	<rgbDiv+?>:    b32.sar 0x008
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    inc.i32(+1)
	<rgbDiv+?>:    div.i32
	libGfx/gfxlib.color.ci:87: (15 bytes): b: uint32 := (bch(c1) << 8) / (bch(c2) + 1)
	<rgbDiv+?>:    dup.x1 sp(4)
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    b32.shl 0x008
	<rgbDiv+?>:    dup.x1 sp(4)
	<rgbDiv+?>:    b32.and 0x0ff
	<rgbDiv+?>:    inc.i32(+1)
	<rgbDiv+?>:    div.i32
	libGfx/gfxlib.color.ci:88: (19 bytes): return .result := rgb(r, g, b);
	<rgbDiv+?>:    dup.x1 sp(2)
	<rgbDiv+?>:    b32.shl 0x008
	<rgbDiv+?>:    dup.x1 sp(2)
	<rgbDiv+?>:    or.b32
	<rgbDiv+?>:    b32.shl 0x008
	<rgbDiv+?>:    dup.x1 sp(1)
	<rgbDiv+?>:    or.b32
	<rgbDiv+?>:    set.x1 sp(7)
	<rgbDiv+?>:    inc.sp(-12)
	<rgbDiv+?>:    ret
	<rgbDiv+?>:    inc.sp(-12)
	<rgbDiv+?>:    ret
}
rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 95
.name: 'rgbLerp16'
.file: 'libGfx/gfxlib.color.ci:91'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.param t: uint32 (size: 4 -> variable(u32))
.value: {
	lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
	r: uint32 := lrpfix16(rch(c1), rch(c2));
	g: uint32 := lrpfix16(gch(c1), gch(c2));
	b: uint32 := lrpfix16(bch(c1), bch(c2));
	return .result := rgb(r, g, b);
}
.instructions: (95 bytes)
	libGfx/gfxlib.color.ci:94: (25 bytes): r: uint32 := lrpfix16(rch(c1), rch(c2))
	<rgbLerp16+?>:    dup.x1 sp(3)
	<rgbLerp16+?>:    b32.sar 0x010
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(0)
	<rgbLerp16+?>:    dup.x1 sp(3)
	<rgbLerp16+?>:    dup.x1 sp(5)
	<rgbLerp16+?>:    b32.sar 0x010
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(3)
	<rgbLerp16+?>:    sub.i32
	<rgbLerp16+?>:    mul.u32
	<rgbLerp16+?>:    b32.shr 0x010
	<rgbLerp16+?>:    add.i32
	<rgbLerp16+?>:    set.x1 sp(1)
	libGfx/gfxlib.color.ci:95: (25 bytes): g: uint32 := lrpfix16(gch(c1), gch(c2))
	<rgbLerp16+?>:    dup.x1 sp(4)
	<rgbLerp16+?>:    b32.sar 0x008
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(0)
	<rgbLerp16+?>:    dup.x1 sp(4)
	<rgbLerp16+?>:    dup.x1 sp(6)
	<rgbLerp16+?>:    b32.sar 0x008
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(3)
	<rgbLerp16+?>:    sub.i32
	<rgbLerp16+?>:    mul.u32
	<rgbLerp16+?>:    b32.shr 0x010
	<rgbLerp16+?>:    add.i32
	<rgbLerp16+?>:    set.x1 sp(1)
	libGfx/gfxlib.color.ci:96: (21 bytes): b: uint32 := lrpfix16(bch(c1), bch(c2))
	<rgbLerp16+?>:    dup.x1 sp(5)
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(0)
	<rgbLerp16+?>:    dup.x1 sp(5)
	<rgbLerp16+?>:    dup.x1 sp(7)
	<rgbLerp16+?>:    b32.and 0x0ff
	<rgbLerp16+?>:    dup.x1 sp(3)
	<rgbLerp16+?>:    sub.i32
	<rgbLerp16+?>:    mul.u32
	<rgbLerp16+?>:    b32.shr 0x010
	<rgbLerp16+?>:    add.i32
	<rgbLerp16+?>:    set.x1 sp(1)
	libGfx/gfxlib.color.ci:97: (19 bytes): return .result := rgb(r, g, b);
	<rgbLerp16+?>:    dup.x1 sp(2)
	<rgbLerp16+?>:    b32.shl 0x008
	<rgbLerp16+?>:    dup.x1 sp(2)
	<rgbLerp16+?>:    or.b32
	<rgbLerp16+?>:    b32.shl 0x008
	<rgbLerp16+?>:    dup.x1 sp(1)
	<rgbLerp16+?>:    or.b32
	<rgbLerp16+?>:    set.x1 sp(8)
	<rgbLerp16+?>:    inc.sp(-12)
	<rgbLerp16+?>:    ret
	<rgbLerp16+?>:    inc.sp(-12)
	<rgbLerp16+?>:    ret
}
rgbLerp(c1: uint32, c2: uint32, t: float64): uint32: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'rgbLerp'
.file: 'libGfx/gfxlib.color.ci:100'
.param .result: uint32 (size: 4 -> variable(u32))
.param c1: uint32 (size: 4 -> variable(u32))
.param c2: uint32 (size: 4 -> variable(u32))
.param t: float64 (size: 8 -> variable(f64))
.value: {
	return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
}
.instructions: (30 bytes)
	libGfx/gfxlib.color.ci:101: (30 bytes): return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
	<rgbLerp+?>:    load.z32
	<rgbLerp+?>:    dup.x1 sp(5)
	<rgbLerp+?>:    dup.x1 sp(5)
	<rgbLerp+?>:    dup.x2 sp(4)
	<rgbLerp+?>:    load.c32 1
	<rgbLerp+?>:    b32.shl 0x010
	<rgbLerp+?>:    i32.2f64
	<rgbLerp+?>:    mul.f64
	<rgbLerp+?>:    f64.2i32
	<rgbLerp+?>:    load.ref .?????? ;rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32
	<rgbLerp+?>:    call
	<rgbLerp+?>:    inc.sp(-12)
	<rgbLerp+?>:    set.x1 sp(6)
	<rgbLerp+?>:    ret
}
rgb(vec: vec4f): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'libGfx/gfxlib.ci:13'
.param .result: uint32 (size: 4 -> u32)
.param vec: vec4f (size: 16 -> variable(val))
.value: rgbClamp(int32(vec.x * (255)), int32(vec.y * (255)), int32(vec.z * (255)))
}
Hsv2Rgb(hsv: vec4f): vec4f: function {
.kind: static const function
.base: `function`
.size: 333
.name: 'Hsv2Rgb'
.file: 'libGfx/gfxlib.ci:15'
.param .result: vec4f (size: 16 -> variable(val))
.param hsv: vec4f (size: 16 -> variable(val))
.value: {
	h: float32 := hsv.x;
	s: float32 := hsv.y;
	v: float32 := hsv.z;
	if (s == (0)) {
		return .result := vec4f(v);
	}
	h := h * (360 / 60);
	i: int32 := int32(h);
	f: float32 := h - (i);
	u: float32 := v;
	p: float32 := v * ((1) - s);
	q: float32 := v * ((1) - s * f);
	t: float32 := v * ((1) - s * ((1) - f));
	if (i == 0) {
		return .result := vec4f(u, t, p);
	}
	if (i == 1) {
		return .result := vec4f(q, u, p);
	}
	if (i == 2) {
		return .result := vec4f(p, u, t);
	}
	if (i == 3) {
		return .result := vec4f(p, q, u);
	}
	if (i == 4) {
		return .result := vec4f(t, p, u);
	}
	return .result := vec4f(u, p, q);
}
.instructions: (333 bytes)
	libGfx/gfxlib.ci:16: (2 bytes): h: float32 := hsv.x
	<Hsv2Rgb+?>:    dup.x1 sp(1)
	libGfx/gfxlib.ci:17: (2 bytes): s: float32 := hsv.y
	<Hsv2Rgb+?>:    dup.x1 sp(3)
	libGfx/gfxlib.ci:18: (2 bytes): v: float32 := hsv.z
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	libGfx/gfxlib.ci:20: (31 bytes): if (s == (0))
	<Hsv2Rgb+?>:    dup.x1 sp(1)
	<Hsv2Rgb+?>:    load.z32
	<Hsv2Rgb+?>:    ceq.f32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:21: (23 bytes): return .result := vec4f(v);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(4)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(xyzw: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-4)
	<Hsv2Rgb+?>:    set.x4 sp(12)
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:24: (17 bytes): h := h * (360 / 60);
	<Hsv2Rgb+?>:    dup.x1 sp(2)
	<Hsv2Rgb+?>:    load.c32 360
	<Hsv2Rgb+?>:    load.c32 60
	<Hsv2Rgb+?>:    div.i32
	<Hsv2Rgb+?>:    i32.2f32
	<Hsv2Rgb+?>:    mul.f32
	<Hsv2Rgb+?>:    set.x1 sp(3)
	libGfx/gfxlib.ci:26: (3 bytes): i: int32 := int32(h)
	<Hsv2Rgb+?>:    dup.x1 sp(2)
	<Hsv2Rgb+?>:    f32.2i32
	libGfx/gfxlib.ci:27: (6 bytes): f: float32 := h - (i)
	<Hsv2Rgb+?>:    dup.x1 sp(3)
	<Hsv2Rgb+?>:    dup.x1 sp(1)
	<Hsv2Rgb+?>:    i32.2f32
	<Hsv2Rgb+?>:    sub.f32
	libGfx/gfxlib.ci:29: (2 bytes): u: float32 := v
	<Hsv2Rgb+?>:    dup.x1 sp(2)
	libGfx/gfxlib.ci:30: (11 bytes): p: float32 := v * ((1) - s)
	<Hsv2Rgb+?>:    dup.x1 sp(3)
	<Hsv2Rgb+?>:    load.f32 1.000000
	<Hsv2Rgb+?>:    dup.x1 sp(6)
	<Hsv2Rgb+?>:    sub.f32
	<Hsv2Rgb+?>:    mul.f32
	libGfx/gfxlib.ci:31: (14 bytes): q: float32 := v * ((1) - s * f)
	<Hsv2Rgb+?>:    dup.x1 sp(4)
	<Hsv2Rgb+?>:    load.f32 1.000000
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    mul.f32
	<Hsv2Rgb+?>:    sub.f32
	<Hsv2Rgb+?>:    mul.f32
	libGfx/gfxlib.ci:32: (20 bytes): t: float32 := v * ((1) - s * ((1) - f))
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.f32 1.000000
	<Hsv2Rgb+?>:    dup.x1 sp(8)
	<Hsv2Rgb+?>:    load.f32 1.000000
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    sub.f32
	<Hsv2Rgb+?>:    mul.f32
	<Hsv2Rgb+?>:    sub.f32
	<Hsv2Rgb+?>:    mul.f32
	libGfx/gfxlib.ci:34: (35 bytes): if (i == 0)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.z32
	<Hsv2Rgb+?>:    ceq.i32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:35: (27 bytes): return .result := vec4f(u, t, p);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    dup.x1 sp(8)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:37: (39 bytes): if (i == 1)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.c32 1
	<Hsv2Rgb+?>:    ceq.i32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:38: (27 bytes): return .result := vec4f(q, u, p);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    dup.x1 sp(8)
	<Hsv2Rgb+?>:    dup.x1 sp(8)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:40: (39 bytes): if (i == 2)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.c32 2
	<Hsv2Rgb+?>:    ceq.i32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:41: (27 bytes): return .result := vec4f(p, u, t);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(6)
	<Hsv2Rgb+?>:    dup.x1 sp(8)
	<Hsv2Rgb+?>:    dup.x1 sp(6)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:43: (39 bytes): if (i == 3)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.c32 3
	<Hsv2Rgb+?>:    ceq.i32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:44: (27 bytes): return .result := vec4f(p, q, u);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(6)
	<Hsv2Rgb+?>:    dup.x1 sp(6)
	<Hsv2Rgb+?>:    dup.x1 sp(9)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:46: (39 bytes): if (i == 4)
	<Hsv2Rgb+?>:    dup.x1 sp(5)
	<Hsv2Rgb+?>:    load.c32 4
	<Hsv2Rgb+?>:    ceq.i32
	<Hsv2Rgb+?>:    jz <Hsv2Rgb+?>
	libGfx/gfxlib.ci:47: (27 bytes): return .result := vec4f(t, p, u);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(4)
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    dup.x1 sp(9)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	libGfx/gfxlib.ci:49: (27 bytes): return .result := vec4f(u, p, q);
	<Hsv2Rgb+?>:    inc.sp(+16)
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    dup.x1 sp(7)
	<Hsv2Rgb+?>:    load.ref .?????? ;vec4f(x: float32, y: float32, z: float32): vec4f
	<Hsv2Rgb+?>:    call
	<Hsv2Rgb+?>:    inc.sp(-12)
	<Hsv2Rgb+?>:    set.x4 sp(18)
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
	<Hsv2Rgb+?>:    inc.sp(-36)
	<Hsv2Rgb+?>:    ret
}
gxSurf(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'libGfx/gfxlib.ci:54'
.param .result: gxSurf (size: 8 -> val)
.param width: int32 (size: 4 -> i32)
.param height: int32 (size: 4 -> i32)
.param depth: int32 (size: 4 -> i32)
.value: gxSurf.create(width, height, depth)
}
gxSurf(fileName: char[*], depth: int32): gxSurf: function {
.kind: static const function
.base: `function`
.size: 189
.name: 'gxSurf'
.file: 'libGfx/gfxlib.ci:56'
.param .result: gxSurf (size: 8 -> variable(val))
.param fileName: char[*] (size: 4 -> variable(ref))
.param depth: int32 (size: 4 -> variable(i32))
.value: {
	if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".jpg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".png", ignCaseCmp)) {
		return .result := gxSurf.openPng(fileName, depth);
	}
	if (endsWith(fileName, ".bmp", ignCaseCmp)) {
		return .result := gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}
.instructions: (189 bytes)
	libGfx/gfxlib.ci:57: (38 bytes): if (endsWith(fileName, ".jpeg", ignCaseCmp))
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    dup.x1 sp(3)
	<gxSurf+?>:    load.ref .?????? ;".jpeg"
	<gxSurf+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>:    call
	<gxSurf+?>:    inc.sp(-12)
	<gxSurf+?>:    jz <gxSurf+?>
	libGfx/gfxlib.ci:58: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    nfc(78) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>:    set.x2 sp(5)
	<gxSurf+?>:    ret
	libGfx/gfxlib.ci:60: (38 bytes): if (endsWith(fileName, ".jpg", ignCaseCmp))
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    dup.x1 sp(3)
	<gxSurf+?>:    load.ref .?????? ;".jpg"
	<gxSurf+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>:    call
	<gxSurf+?>:    inc.sp(-12)
	<gxSurf+?>:    jz <gxSurf+?>
	libGfx/gfxlib.ci:61: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    nfc(78) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>:    set.x2 sp(5)
	<gxSurf+?>:    ret
	libGfx/gfxlib.ci:63: (38 bytes): if (endsWith(fileName, ".png", ignCaseCmp))
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    dup.x1 sp(3)
	<gxSurf+?>:    load.ref .?????? ;".png"
	<gxSurf+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>:    call
	<gxSurf+?>:    inc.sp(-12)
	<gxSurf+?>:    jz <gxSurf+?>
	libGfx/gfxlib.ci:64: (11 bytes): return .result := gxSurf.openPng(fileName, depth);
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    nfc(77) ;gxSurf.openPng(path: char[*], depth: int32): gxSurf
	<gxSurf+?>:    set.x2 sp(5)
	<gxSurf+?>:    ret
	libGfx/gfxlib.ci:66: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    dup.x1 sp(3)
	<gxSurf+?>:    load.ref .?????? ;".bmp"
	<gxSurf+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>:    call
	<gxSurf+?>:    inc.sp(-12)
	<gxSurf+?>:    jz <gxSurf+?>
	libGfx/gfxlib.ci:67: (11 bytes): return .result := gxSurf.openBmp(fileName, depth);
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    dup.x1 sp(2)
	<gxSurf+?>:    nfc(76) ;gxSurf.openBmp(path: char[*], depth: int32): gxSurf
	<gxSurf+?>:    set.x2 sp(5)
	<gxSurf+?>:    ret
	libGfx/gfxlib.ci:69: (36 bytes): abort("unknown file extension", fileName);
	<gxSurf+?>:    load.ref .?????? ;"libGfx/gfxlib.ci"
	<gxSurf+?>:    load.c32 69
	<gxSurf+?>:    load.c32 -2
	<gxSurf+?>:    load.c32 128
	<gxSurf+?>:    load.ref .?????? ;"unknown file extension"
	<gxSurf+?>:    load.ref .??????
	<gxSurf+?>:    dup.x1 sp(8)
	<gxSurf+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxSurf+?>:    ret
}
gxSurf(fileName: char[*]): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'libGfx/gfxlib.ci:72'
.param .result: gxSurf (size: 8 -> val)
.param fileName: char[*] (size: 4 -> ref)
.value: gxSurf(fileName, 32)
}
gxMesh(fileName: char[*]): gxMesh: function {
.kind: static const function
.base: `function`
.size: 109
.name: 'gxMesh'
.file: 'libGfx/gfxlib.ci:74'
.param .result: gxMesh (size: 4 -> variable(ref))
.param fileName: char[*] (size: 4 -> variable(ref))
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := gxMesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (109 bytes)
	libGfx/gfxlib.ci:75: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<gxMesh+?>:    load.z32
	<gxMesh+?>:    dup.x1 sp(2)
	<gxMesh+?>:    load.ref .?????? ;".obj"
	<gxMesh+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>:    call
	<gxMesh+?>:    inc.sp(-12)
	<gxMesh+?>:    jz <gxMesh+?>
	libGfx/gfxlib.ci:76: (9 bytes): return .result := gxMesh.openObj(fileName);
	<gxMesh+?>:    dup.x1 sp(1)
	<gxMesh+?>:    nfc(62) ;gxMesh.openObj(path: char[*]): gxMesh
	<gxMesh+?>:    set.x1 sp(3)
	<gxMesh+?>:    ret
	libGfx/gfxlib.ci:78: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<gxMesh+?>:    load.z32
	<gxMesh+?>:    dup.x1 sp(2)
	<gxMesh+?>:    load.ref .?????? ;".3ds"
	<gxMesh+?>:    load.ref .?????? ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>:    load.ref .?????? ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>:    call
	<gxMesh+?>:    inc.sp(-12)
	<gxMesh+?>:    jz <gxMesh+?>
	libGfx/gfxlib.ci:79: (9 bytes): return .result := gxMesh.open3ds(fileName);
	<gxMesh+?>:    dup.x1 sp(1)
	<gxMesh+?>:    nfc(63) ;gxMesh.open3ds(path: char[*]): gxMesh
	<gxMesh+?>:    set.x1 sp(3)
	<gxMesh+?>:    ret
	libGfx/gfxlib.ci:81: (36 bytes): abort("unknown file extension", fileName);
	<gxMesh+?>:    load.ref .?????? ;"libGfx/gfxlib.ci"
	<gxMesh+?>:    load.c32 81
	<gxMesh+?>:    load.c32 -2
	<gxMesh+?>:    load.c32 128
	<gxMesh+?>:    load.ref .?????? ;"unknown file extension"
	<gxMesh+?>:    load.ref .??????
	<gxMesh+?>:    dup.x1 sp(7)
	<gxMesh+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxMesh+?>:    ret
}
gxSurf(copy: gxSurf): gxSurf: function {
.kind: static const function
.base: `function`
.size: 51
.name: 'gxSurf'
.file: 'libGfx/gfxlib.ci:84'
.param .result: gxSurf (size: 8 -> variable(val))
.param copy: gxSurf (size: 8 -> variable(val))
.value: {
	result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
	result.copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (51 bytes)
	libGfx/gfxlib.ci:85: (22 bytes): result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy))
	<gxSurf+?>:    dup.x2 sp(1)
	<gxSurf+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>:    dup.x2 sp(2)
	<gxSurf+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>:    dup.x2 sp(3)
	<gxSurf+?>:    nfc(83) ;gxSurf.depth(surf: gxSurf): int32
	<gxSurf+?>:    nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	libGfx/gfxlib.ci:86: (15 bytes): result.copy(result, 0, 0, copy, null);
	<gxSurf+?>:    dup.x2 sp(0)
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    load.z32
	<gxSurf+?>:    dup.x2 sp(7)
	<gxSurf+?>:    load.ref .?????? ;null
	<gxSurf+?>:    nfc(95) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	libGfx/gfxlib.ci:87: (9 bytes): return .result := result;
	<gxSurf+?>:    dup.x2 sp(0)
	<gxSurf+?>:    set.x2 sp(7)
	<gxSurf+?>:    inc.sp(-8)
	<gxSurf+?>:    ret
	<gxSurf+?>:    inc.sp(-8)
	<gxSurf+?>:    ret
}
clip(src: gxSurf, roi: gxRect): bool: function {
.kind: static const function
.base: `function`
.size: 240
.name: 'clip'
.file: 'libGfx/gfxlib.ci:95'
.param .result: bool (size: 4 -> variable(bool))
.param src: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> variable(ref))
.value: {
	roi.w := roi.w + roi.x;
	roi.h := roi.h + roi.y;
	if (roi.x < 0) {
		roi.x := 0;
	}
	if (roi.y < 0) {
		roi.y := 0;
	}
	width: int32 := src.width(src);
	if (roi.w > width) {
		roi.w := width;
	}
	height: int32 := src.height(src);
	if (roi.h > height) {
		roi.h := height;
	}
	roi.w := roi.w - roi.x;
	roi.h := roi.h - roi.y;
	if (roi.w <= 0) {
		return .result := false;
	}
	if (roi.h <= 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (240 bytes)
	libGfx/gfxlib.ci:97: (18 bytes): roi.w := roi.w + roi.x;
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    load.i32
	<clip+?>:    add.i32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:98: (22 bytes): roi.h := roi.h + roi.y;
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    inc.i32(+4)
	<clip+?>:    load.i32
	<clip+?>:    add.i32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:100: (13 bytes): if (roi.x < 0)
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    load.i32
	<clip+?>:    load.z32
	<clip+?>:    clt.i32
	<clip+?>:    jz <clip+?>
	libGfx/gfxlib.ci:101: (4 bytes): roi.x := 0;
	<clip+?>:    load.z32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:104: (21 bytes): if (roi.y < 0)
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    inc.i32(+4)
	<clip+?>:    load.i32
	<clip+?>:    load.z32
	<clip+?>:    clt.i32
	<clip+?>:    jz <clip+?>
	libGfx/gfxlib.ci:105: (8 bytes): roi.y := 0;
	<clip+?>:    load.z32
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    inc.i32(+4)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:108: (6 bytes): width: int32 := src.width(src)
	<clip+?>:    dup.x2 sp(2)
	<clip+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	libGfx/gfxlib.ci:109: (23 bytes): if (roi.w > width)
	<clip+?>:    dup.x1 sp(2)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    cgt.i32
	<clip+?>:    jz <clip+?>
	libGfx/gfxlib.ci:110: (9 bytes): roi.w := width;
	<clip+?>:    dup.x1 sp(0)
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:113: (6 bytes): height: int32 := src.height(src)
	<clip+?>:    dup.x2 sp(3)
	<clip+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	libGfx/gfxlib.ci:114: (23 bytes): if (roi.h > height)
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(1)
	<clip+?>:    cgt.i32
	<clip+?>:    jz <clip+?>
	libGfx/gfxlib.ci:115: (9 bytes): roi.h := height;
	<clip+?>:    dup.x1 sp(0)
	<clip+?>:    dup.x1 sp(4)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:118: (18 bytes): roi.w := roi.w - roi.x;
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(4)
	<clip+?>:    load.i32
	<clip+?>:    sub.i32
	<clip+?>:    dup.x1 sp(4)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:119: (22 bytes): roi.h := roi.h - roi.y;
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    load.i32
	<clip+?>:    dup.x1 sp(4)
	<clip+?>:    inc.i32(+4)
	<clip+?>:    load.i32
	<clip+?>:    sub.i32
	<clip+?>:    dup.x1 sp(4)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    store.i32
	libGfx/gfxlib.ci:121: (24 bytes): if (roi.w <= 0)
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+8)
	<clip+?>:    load.i32
	<clip+?>:    load.z32
	<clip+?>:    cgt.i32
	<clip+?>:    jnz <clip+?>
	libGfx/gfxlib.ci:122: (11 bytes): return .result := false;
	<clip+?>:    load.z32
	<clip+?>:    load.sp(+28)
	<clip+?>:    store.i8
	<clip+?>:    inc.sp(-8)
	<clip+?>:    ret
	libGfx/gfxlib.ci:124: (24 bytes): if (roi.h <= 0)
	<clip+?>:    dup.x1 sp(3)
	<clip+?>:    inc.i32(+12)
	<clip+?>:    load.i32
	<clip+?>:    load.z32
	<clip+?>:    cgt.i32
	<clip+?>:    jnz <clip+?>
	libGfx/gfxlib.ci:125: (11 bytes): return .result := false;
	<clip+?>:    load.z32
	<clip+?>:    load.sp(+28)
	<clip+?>:    store.i8
	<clip+?>:    inc.sp(-8)
	<clip+?>:    ret
	libGfx/gfxlib.ci:127: (15 bytes): return .result := true;
	<clip+?>:    load.c32 1
	<clip+?>:    load.sp(+28)
	<clip+?>:    store.i8
	<clip+?>:    inc.sp(-8)
	<clip+?>:    ret
	<clip+?>:    inc.sp(-8)
	<clip+?>:    ret
}
eval(out: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 273
.name: 'eval'
.file: 'libGfx/gfxlib.ci:129'
.param .result: void (size: 0 -> variable(void))
.param out: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> variable(ref))
.param aspect: float32 (size: 4 -> variable(f32))
.param time: float32 (size: 4 -> variable(f32))
.param eval: function (size: 4 -> variable(ref))
.value: {
	rect: gxRect;
	if ((roi) == null) {
		rect.x := rect.y := 0;
		rect.w := out.width(out);
		rect.h := out.height(out);
	}
	else {
		rect := roi;
		if (!clip(out, rect)) {
			return;
		}
	}
	in: vec4f := {
		in.x := (0);
		in.y := (0);
		in.z := aspect;
		in.w := time;
	};
	w: float32 := out.width(out);
	h: float32 := out.height(out);
	for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
			in.x := (x) / w;
			out.set(out, x, y, rgb(eval(in)));
		}
	}
}
.instructions: (273 bytes)
	libGfx/gfxlib.ci:130: (4 bytes): rect: gxRect
	<eval+?>:    inc.sp(+16)
	libGfx/gfxlib.ci:131: (69 bytes): if ((roi) == null)
	<eval+?>:    dup.x1 sp(8)
	<eval+?>:    load.ref .?????? ;null
	<eval+?>:    ceq.i32
	<eval+?>:    jz <eval+?>
	libGfx/gfxlib.ci:132: (7 bytes): rect.x := rect.y := 0;
	<eval+?>:    load.z32
	<eval+?>:    dup.x1 sp(0)
	<eval+?>:    set.x1 sp(3)
	<eval+?>:    set.x1 sp(1)
	libGfx/gfxlib.ci:133: (8 bytes): rect.w := out.width(out);
	<eval+?>:    dup.x2 sp(9)
	<eval+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>:    set.x1 sp(3)
	libGfx/gfxlib.ci:134: (8 bytes): rect.h := out.height(out);
	<eval+?>:    dup.x2 sp(9)
	<eval+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>:    set.x1 sp(4)
	<eval+?>:    jmp <eval+?>
	libGfx/gfxlib.ci:137: (4 bytes): rect := roi;
	<eval+?>:    dup.x4 sp(8)
	<eval+?>:    set.x4 sp(4)
	libGfx/gfxlib.ci:138: (26 bytes): if (!clip(out, rect))
	<eval+?>:    load.z32
	<eval+?>:    dup.x2 sp(10)
	<eval+?>:    load.sp(+12)
	<eval+?>:    load.ref .?????? ;clip(src: gxSurf, roi: gxRect): bool
	<eval+?>:    call
	<eval+?>:    inc.sp(-12)
	<eval+?>:    jnz <eval+?>
	libGfx/gfxlib.ci:139: (5 bytes): return;
	<eval+?>:    inc.sp(-16)
	<eval+?>:    ret
	libGfx/gfxlib.ci:142: (18 bytes): in: vec4f := {...}
	<eval+?>:    inc.sp(+16)
	libGfx/gfxlib.ci:143: (3 bytes): in.x := (0);
	<eval+?>:    load.z32
	<eval+?>:    set.x1 sp(1)
	libGfx/gfxlib.ci:144: (3 bytes): in.y := (0);
	<eval+?>:    load.z32
	<eval+?>:    set.x1 sp(2)
	libGfx/gfxlib.ci:145: (4 bytes): in.z := aspect;
	<eval+?>:    dup.x1 sp(11)
	<eval+?>:    set.x1 sp(3)
	libGfx/gfxlib.ci:146: (4 bytes): in.w := time;
	<eval+?>:    dup.x1 sp(10)
	<eval+?>:    set.x1 sp(4)
	libGfx/gfxlib.ci:148: (7 bytes): w: float32 := out.width(out)
	<eval+?>:    dup.x2 sp(13)
	<eval+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>:    i32.2f32
	libGfx/gfxlib.ci:149: (7 bytes): h: float32 := out.height(out)
	<eval+?>:    dup.x2 sp(14)
	<eval+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>:    i32.2f32
	libGfx/gfxlib.ci:150: (163 bytes): for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1)
	<eval+?>:    dup.x1 sp(7)
	<eval+?>:    jmp <eval+?>
	libGfx/gfxlib.ci:151: (8 bytes): in.y := (y) / h;
	<eval+?>:    dup.x1 sp(0)
	<eval+?>:    i32.2f32
	<eval+?>:    dup.x1 sp(2)
	<eval+?>:    div.f32
	<eval+?>:    set.x1 sp(5)
	libGfx/gfxlib.ci:152: (129 bytes): for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1)
	<eval+?>:    dup.x1 sp(7)
	<eval+?>:    jmp <eval+?>
	libGfx/gfxlib.ci:153: (8 bytes): in.x := (x) / w;
	<eval+?>:    dup.x1 sp(0)
	<eval+?>:    i32.2f32
	<eval+?>:    dup.x1 sp(4)
	<eval+?>:    div.f32
	<eval+?>:    set.x1 sp(5)
	libGfx/gfxlib.ci:154: (95 bytes): out.set(out, x, y, rgb(eval(in)));
	<eval+?>:    dup.x2 sp(17)
	<eval+?>:    dup.x1 sp(2)
	<eval+?>:    dup.x1 sp(4)
	<eval+?>:    inc.sp(+16)
	<eval+?>:    dup.x4 sp(12)
	<eval+?>:    dup.x1 sp(25)
	<eval+?>:    call
	<eval+?>:    inc.sp(-16)
	<eval+?>:    load.z32
	<eval+?>:    dup.x1 sp(1)
	<eval+?>:    load.f32 255.000000
	<eval+?>:    mul.f32
	<eval+?>:    f32.2i32
	<eval+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<eval+?>:    call
	<eval+?>:    inc.sp(-4)
	<eval+?>:    b32.shl 0x008
	<eval+?>:    load.z32
	<eval+?>:    dup.x1 sp(3)
	<eval+?>:    load.f32 255.000000
	<eval+?>:    mul.f32
	<eval+?>:    f32.2i32
	<eval+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<eval+?>:    call
	<eval+?>:    inc.sp(-4)
	<eval+?>:    or.b32
	<eval+?>:    b32.shl 0x008
	<eval+?>:    load.z32
	<eval+?>:    dup.x1 sp(4)
	<eval+?>:    load.f32 255.000000
	<eval+?>:    mul.f32
	<eval+?>:    f32.2i32
	<eval+?>:    load.ref .?????? ;grayClamp(c: int32): uint32
	<eval+?>:    call
	<eval+?>:    inc.sp(-4)
	<eval+?>:    or.b32
	<eval+?>:    set.x1 sp(4)
	<eval+?>:    inc.sp(-12)
	<eval+?>:    nfc(85) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	libGfx/gfxlib.ci:152: (4 bytes): x := x + 1
	<eval+?>:    inc.i32(+1)
	libGfx/gfxlib.ci:152: (12 bytes): x < rect.x + rect.w
	<eval+?>:    dup.x1 sp(0)
	<eval+?>:    dup.x1 sp(9)
	<eval+?>:    dup.x1 sp(12)
	<eval+?>:    add.i32
	<eval+?>:    clt.i32
	<eval+?>:    jnz <eval+?>
	<eval+?>:    inc.sp(-4)
	libGfx/gfxlib.ci:150: (4 bytes): y := y + 1
	<eval+?>:    inc.i32(+1)
	libGfx/gfxlib.ci:150: (12 bytes): y < rect.y + rect.h
	<eval+?>:    dup.x1 sp(0)
	<eval+?>:    dup.x1 sp(9)
	<eval+?>:    dup.x1 sp(12)
	<eval+?>:    add.i32
	<eval+?>:    clt.i32
	<eval+?>:    jnz <eval+?>
	<eval+?>:    inc.sp(-4)
	<eval+?>:    inc.sp(-40)
	<eval+?>:    ret
}
tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const function
.base: `function`
.size: 207
.name: 'tile'
.file: 'libGfx/gfxlib.ci:159'
.param .result: void (size: 0 -> variable(void))
.param dst: gxSurf (size: 8 -> variable(val))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.param src: gxSurf (size: 8 -> variable(val))
.param roi: gxRect (size: 4 -> variable(ref))
.value: {
	rect: gxRect := {
		rect.x := 0;
		rect.y := 0;
		rect.w := src.width(src);
		rect.h := src.height(src);
	};
	if ((roi) != null) {
		rect.x := roi.x;
		rect.y := roi.y;
		rect.w := roi.w;
		rect.h := roi.h;
	}
	if (!clip(src, rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % rect.w);
	}
	if (y < 0) {
		y := -(-y % rect.h);
	}
	width: int32 := dst.width(dst);
	height: int32 := dst.height(dst);
	for (j: int32 := y; j < height; j := j + rect.h) {
		for (i: int32 := x; i < width; i := i + rect.w) {
			dst.copy(dst, i, j, src, rect);
		}
	}
}
.instructions: (207 bytes)
	libGfx/gfxlib.ci:160: (26 bytes): rect: gxRect := {...}
	<tile+?>:    inc.sp(+16)
	libGfx/gfxlib.ci:161: (3 bytes): rect.x := 0;
	<tile+?>:    load.z32
	<tile+?>:    set.x1 sp(1)
	libGfx/gfxlib.ci:162: (3 bytes): rect.y := 0;
	<tile+?>:    load.z32
	<tile+?>:    set.x1 sp(2)
	libGfx/gfxlib.ci:163: (8 bytes): rect.w := src.width(src);
	<tile+?>:    dup.x2 sp(6)
	<tile+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<tile+?>:    set.x1 sp(3)
	libGfx/gfxlib.ci:164: (8 bytes): rect.h := src.height(src);
	<tile+?>:    dup.x2 sp(6)
	<tile+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<tile+?>:    set.x1 sp(4)
	libGfx/gfxlib.ci:167: (44 bytes): if ((roi) != null)
	<tile+?>:    dup.x1 sp(5)
	<tile+?>:    load.ref .?????? ;null
	<tile+?>:    ceq.i32
	<tile+?>:    jnz <tile+?>
	libGfx/gfxlib.ci:169: (5 bytes): rect.x := roi.x;
	<tile+?>:    dup.x1 sp(5)
	<tile+?>:    load.i32
	<tile+?>:    set.x1 sp(1)
	libGfx/gfxlib.ci:170: (9 bytes): rect.y := roi.y;
	<tile+?>:    dup.x1 sp(5)
	<tile+?>:    inc.i32(+4)
	<tile+?>:    load.i32
	<tile+?>:    set.x1 sp(2)
	libGfx/gfxlib.ci:171: (9 bytes): rect.w := roi.w;
	<tile+?>:    dup.x1 sp(5)
	<tile+?>:    inc.i32(+8)
	<tile+?>:    load.i32
	<tile+?>:    set.x1 sp(3)
	libGfx/gfxlib.ci:172: (9 bytes): rect.h := roi.h;
	<tile+?>:    dup.x1 sp(5)
	<tile+?>:    inc.i32(+12)
	<tile+?>:    load.i32
	<tile+?>:    set.x1 sp(4)
	libGfx/gfxlib.ci:175: (26 bytes): if (!clip(src, rect))
	<tile+?>:    load.z32
	<tile+?>:    dup.x2 sp(7)
	<tile+?>:    load.sp(+12)
	<tile+?>:    load.ref .?????? ;clip(src: gxSurf, roi: gxRect): bool
	<tile+?>:    call
	<tile+?>:    inc.sp(-12)
	<tile+?>:    jnz <tile+?>
	libGfx/gfxlib.ci:176: (5 bytes): return;
	<tile+?>:    inc.sp(-16)
	<tile+?>:    ret
	libGfx/gfxlib.ci:179: (17 bytes): if (x < 0)
	<tile+?>:    dup.x1 sp(9)
	<tile+?>:    load.z32
	<tile+?>:    clt.i32
	<tile+?>:    jz <tile+?>
	libGfx/gfxlib.ci:180: (9 bytes): x := -(-x % rect.w);
	<tile+?>:    dup.x1 sp(9)
	<tile+?>:    neg.i32
	<tile+?>:    dup.x1 sp(3)
	<tile+?>:    mod.i32
	<tile+?>:    neg.i32
	<tile+?>:    set.x1 sp(10)
	libGfx/gfxlib.ci:182: (17 bytes): if (y < 0)
	<tile+?>:    dup.x1 sp(8)
	<tile+?>:    load.z32
	<tile+?>:    clt.i32
	<tile+?>:    jz <tile+?>
	libGfx/gfxlib.ci:183: (9 bytes): y := -(-y % rect.h);
	<tile+?>:    dup.x1 sp(8)
	<tile+?>:    neg.i32
	<tile+?>:    dup.x1 sp(4)
	<tile+?>:    mod.i32
	<tile+?>:    neg.i32
	<tile+?>:    set.x1 sp(9)
	libGfx/gfxlib.ci:185: (6 bytes): width: int32 := dst.width(dst)
	<tile+?>:    dup.x2 sp(10)
	<tile+?>:    nfc(81) ;gxSurf.width(surf: gxSurf): int32
	libGfx/gfxlib.ci:186: (6 bytes): height: int32 := dst.height(dst)
	<tile+?>:    dup.x2 sp(11)
	<tile+?>:    nfc(82) ;gxSurf.height(surf: gxSurf): int32
	libGfx/gfxlib.ci:187: (60 bytes): for (j: int32 := y; j < height; j := j + rect.h)
	<tile+?>:    dup.x1 sp(10)
	<tile+?>:    jmp <tile+?>
	libGfx/gfxlib.ci:188: (38 bytes): for (i: int32 := x; i < width; i := i + rect.w)
	<tile+?>:    dup.x1 sp(12)
	<tile+?>:    jmp <tile+?>
	libGfx/gfxlib.ci:189: (16 bytes): dst.copy(dst, i, j, src, rect);
	<tile+?>:    dup.x2 sp(14)
	<tile+?>:    dup.x1 sp(2)
	<tile+?>:    dup.x1 sp(4)
	<tile+?>:    dup.x2 sp(14)
	<tile+?>:    load.sp(+40)
	<tile+?>:    nfc(95) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	libGfx/gfxlib.ci:188: (3 bytes): i := i + rect.w
	<tile+?>:    dup.x1 sp(6)
	<tile+?>:    add.i32
	libGfx/gfxlib.ci:188: (9 bytes): i < width
	<tile+?>:    dup.x1 sp(0)
	<tile+?>:    dup.x1 sp(4)
	<tile+?>:    clt.i32
	<tile+?>:    jnz <tile+?>
	<tile+?>:    inc.sp(-4)
	libGfx/gfxlib.ci:187: (3 bytes): j := j + rect.h
	<tile+?>:    dup.x1 sp(6)
	<tile+?>:    add.i32
	libGfx/gfxlib.ci:187: (9 bytes): j < height
	<tile+?>:    dup.x1 sp(0)
	<tile+?>:    dup.x1 sp(2)
	<tile+?>:    clt.i32
	<tile+?>:    jnz <tile+?>
	<tile+?>:    inc.sp(-4)
	<tile+?>:    inc.sp(-24)
	<tile+?>:    ret
}
show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void: function {
.kind: static const function
.base: `function`
.size: 119
.name: 'show'
.file: 'libGfx/gfxlib.ci:194'
.param .result: void (size: 0 -> variable(void))
.param mesh: gxMesh (size: 4 -> variable(ref))
.param w: int32 (size: 4 -> variable(i32))
.param h: int32 (size: 4 -> variable(i32))
.param fovy: float32 (size: 4 -> variable(f32))
.value: {
	static const Closure: struct {
		mode: int32;
		offs: gxSurf;
		mesh: gxMesh;
	};
	static const next(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const speed: float32 := 1.000000 / (100);
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
			else {
				if (button == ('l')) {
					closure.mode := ((closure.mode) ^ gxMesh.useLights);
				}
				else {
					if (button == ('0')) {
						lights.enable(0, !lights.enabled(0));
					}
					else {
						if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else {
							if (button == ('2')) {
								lights.enable(2, !lights.enabled(2));
							}
							else {
								if (button == ('3')) {
									lights.enable(3, !lights.enabled(3));
								}
								else {
									if (button == ('t')) {
										closure.mode := ((closure.mode) ^ gxMesh.useTexture);
									}
									else {
										if (button == ('/')) {
											closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
										}
										else {
											if (button == ('\t')) {
												closure.mode := next(closure.mode, gxMesh.drawMode);
											}
											else {
												if (button == ('\r')) {
													eye: vec4f := {
														eye.x := (0);
														eye.y := (0);
														eye.z := (2);
														eye.w := (1);
													};
													at: vec4f := {
														at.x := (0);
														at.y := (0);
														at.z := (0);
														at.w := (1);
													};
													up: vec4f := {
														up.x := (0);
														up.y := (1);
														up.z := (0);
														up.w := (1);
													};
													camera.lookAt(eye.data, at.data, up.data);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else {
			if ((action) == Gui.MOUSE_PRESS) {
				ox := ex;
				oy := ey;
				return .result := 0;
			}
			else {
				if ((action) == Gui.MOUSE_MOTION) {
					dir: float32[3];
					dx: int32 := ex - ox;
					dy: int32 := ey - oy;
					if (button == 1) {
						orig: float32[3];
						orig[0] := (0);
						orig[1] := (0);
						orig[2] := (0);
						camera.readUp(dir);
						camera.rotate(dir, orig, (dx) * speed);
						camera.readRight(dir);
						camera.rotate(dir, orig, (dy) * speed);
					}
					else {
						if (button == 2) {
							camera.readUp(dir);
							camera.rotate(dir, null, (-dx) * speed);
							camera.readRight(dir);
							camera.rotate(dir, null, (-dy) * speed);
						}
						else {
							if (button == 3) {
								camera.readForward(dir);
								camera.move(dir, (dy) * speed);
							}
							else {
								if (button == 4) {
									camera.readRight(dir);
									camera.move(dir, (-dx) * speed);
									camera.readUp(dir);
									camera.move(dir, (dy) * speed);
								}
							}
						}
					}
					ox := ex;
					oy := ey;
				}
			}
		}
		rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
		text: char[256];
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, closure.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, closure.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		Gui.setTitle(text);
		return .result := 0;
	};
	closure: Closure := {
		closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
		closure.offs := gxSurf.create3d(w, h);
		closure.mesh := mesh;
	};
	camera.projection(fovy, (w) / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy(closure.offs);
}
.instructions: (119 bytes)
	libGfx/gfxlib.ci:311: (70 bytes): closure: Closure := {...}
	<show+?>:    inc.sp(+24)
	libGfx/gfxlib.ci:312: (52 bytes): closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
	<show+?>:    load.c64 8
	<show+?>:    load.c64 4
	<show+?>:    or.b64
	<show+?>:    load.c64 128
	<show+?>:    or.b64
	<show+?>:    load.c64 16
	<show+?>:    or.b64
	<show+?>:    load.c64 3
	<show+?>:    or.b64
	<show+?>:    i64.2i32
	<show+?>:    set.x1 sp(1)
	libGfx/gfxlib.ci:313: (10 bytes): closure.offs := gxSurf.create3d(w, h);
	<show+?>:    dup.x1 sp(9)
	<show+?>:    dup.x1 sp(9)
	<show+?>:    nfc(73) ;gxSurf.create3d(width: int32, height: int32): gxSurf
	<show+?>:    set.x2 sp(4)
	libGfx/gfxlib.ci:314: (4 bytes): closure.mesh := mesh;
	<show+?>:    dup.x1 sp(10)
	<show+?>:    set.x1 sp(5)
	libGfx/gfxlib.ci:316: (23 bytes): camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>:    dup.x1 sp(7)
	<show+?>:    dup.x1 sp(10)
	<show+?>:    i32.2f32
	<show+?>:    dup.x1 sp(10)
	<show+?>:    i32.2f32
	<show+?>:    div.f32
	<show+?>:    load.f32 1.000000
	<show+?>:    load.f32 100.000000
	<show+?>:    nfc(100) ;camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
	libGfx/gfxlib.ci:317: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>:    dup.x2 sp(2)
	<show+?>:    load.sp(+8)
	<show+?>:    load.ref .?????? ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>:    nfc(114) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	libGfx/gfxlib.ci:318: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>:    dup.x2 sp(2)
	<show+?>:    nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>:    inc.sp(-24)
	<show+?>:    ret
}
show(surf: gxSurf): void: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'show'
.file: 'libGfx/gfxlib.ci:321'
.param .result: void (size: 0 -> variable(void))
.param surf: gxSurf (size: 8 -> variable(val))
.value: {
	Gui.showWindow(surf, null, null);
}
.instructions: (17 bytes)
	libGfx/gfxlib.ci:322: (16 bytes): Gui.showWindow(surf, null, null);
	<show+?>:    dup.x2 sp(1)
	<show+?>:    load.ref .?????? ;null
	<show+?>:    load.ref .?????? ;null
	<show+?>:    nfc(114) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>:    ret
}
show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static const function
.base: `function`
.size: 43
.name: 'show'
.file: 'libGfx/gfxlib.ci:325'
.param .result: void (size: 0 -> variable(void))
.param surf: gxSurf (size: 8 -> variable(val))
.param onEvent: function (size: 4 -> variable(ref))
.value: {
	if ((onEvent) == null) {
		return .result := Gui.showWindow(surf, null, null);
	}
	static const delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Gui.showWindow(surf, onEvent, delegateEvent);
}
.instructions: (43 bytes)
	libGfx/gfxlib.ci:326: (29 bytes): if ((onEvent) == null)
	<show+?>:    dup.x1 sp(1)
	<show+?>:    load.ref .?????? ;null
	<show+?>:    ceq.i32
	<show+?>:    jz <show+?>
	libGfx/gfxlib.ci:327: (17 bytes): return .result := Gui.showWindow(surf, null, null);
	<show+?>:    dup.x2 sp(2)
	<show+?>:    load.ref .?????? ;null
	<show+?>:    load.ref .?????? ;null
	<show+?>:    nfc(114) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>:    ret
	libGfx/gfxlib.ci:332: (13 bytes): Gui.showWindow(surf, onEvent, delegateEvent);
	<show+?>:    dup.x2 sp(2)
	<show+?>:    dup.x1 sp(3)
	<show+?>:    load.ref .?????? ;show.delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>:    nfc(114) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>:    ret
}
showWindow(w: int32, h: int32, t: int32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 79
.name: 'showWindow'
.file: 'libGfx/gfxlib.ci:335'
.param .result: void (size: 0 -> variable(void))
.param w: int32 (size: 4 -> variable(i32))
.param h: int32 (size: 4 -> variable(i32))
.param t: int32 (size: 4 -> variable(i32))
.param eval: function (size: 4 -> variable(ref))
.value: {
	static const start: int64 := System.millis();
	static const Closure: struct {
		const offs: gxSurf;
		const thumb: gxSurf;
		const aspect: float64;
		const eval(in: vec4f): vec4f;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return .result := 0;
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.KEY_RELEASE) {
			if (button == (' ')) {
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.offs, null, closure.aspect, time, closure.eval);
				return .result := 0;
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(closure.thumb, null, closure.aspect, time, closure.eval);
		closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
		return .result := 1;
	};
	closure: Closure := {
		closure.offs := gxSurf(w, h, 32);
		closure.thumb := gxSurf(t, t, 32);
		closure.aspect := (w) / float64(h);
		closure.eval := eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy(closure.thumb);
	closure.offs.destroy(closure.offs);
}
.instructions: (79 bytes)
	libGfx/gfxlib.ci:370: (47 bytes): closure: Closure := {...}
	<showWindow+?>:    inc.sp(+32)
	libGfx/gfxlib.ci:371: (15 bytes): closure.offs := gxSurf(w, h, 32);
	<showWindow+?>:    dup.x1 sp(12)
	<showWindow+?>:    dup.x1 sp(12)
	<showWindow+?>:    load.c32 32
	<showWindow+?>:    nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<showWindow+?>:    set.x2 sp(2)
	libGfx/gfxlib.ci:372: (15 bytes): closure.thumb := gxSurf(t, t, 32);
	<showWindow+?>:    dup.x1 sp(10)
	<showWindow+?>:    dup.x1 sp(11)
	<showWindow+?>:    load.c32 32
	<showWindow+?>:    nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<showWindow+?>:    set.x2 sp(4)
	libGfx/gfxlib.ci:373: (9 bytes): closure.aspect := (w) / float64(h);
	<showWindow+?>:    dup.x1 sp(12)
	<showWindow+?>:    i32.2f64
	<showWindow+?>:    dup.x1 sp(13)
	<showWindow+?>:    i32.2f64
	<showWindow+?>:    div.f64
	<showWindow+?>:    set.x2 sp(6)
	libGfx/gfxlib.ci:374: (4 bytes): closure.eval := eval;
	<showWindow+?>:    dup.x1 sp(9)
	<showWindow+?>:    set.x1 sp(7)
	libGfx/gfxlib.ci:376: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showWindow+?>:    dup.x2 sp(0)
	<showWindow+?>:    load.sp(+8)
	<showWindow+?>:    load.ref .?????? ;showWindow.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showWindow+?>:    nfc(114) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	libGfx/gfxlib.ci:377: (6 bytes): closure.thumb.destroy(closure.thumb);
	<showWindow+?>:    dup.x2 sp(2)
	<showWindow+?>:    nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	libGfx/gfxlib.ci:378: (6 bytes): closure.offs.destroy(closure.offs);
	<showWindow+?>:    dup.x2 sp(0)
	<showWindow+?>:    nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	<showWindow+?>:    inc.sp(-32)
	<showWindow+?>:    ret
}
.main: function {
.kind: static function
.base: `function`
.size: 111
.name: '.main'
.print: '.main'
.field typename: typename (size: 136 -> static const typename(ref))
.field void: typename (size: 0 -> static const typename(void))
.field bool: typename (size: 1 -> static const typename(bool))
.field char: typename (size: 1 -> static const typename(i32))
.field int8: typename (size: 1 -> static const typename(i32))
.field int16: typename (size: 2 -> static const typename(i32))
.field int32: typename (size: 4 -> static const typename(i32))
.field int64: typename (size: 8 -> static const typename(i64))
.field uint8: typename (size: 1 -> static const typename(u32))
.field uint16: typename (size: 2 -> static const typename(u32))
.field uint32: typename (size: 4 -> static const typename(u32))
.field uint64: typename (size: 8 -> static const typename(u64))
.field float32: typename (size: 4 -> static const typename(f32))
.field float64: typename (size: 8 -> static const typename(f64))
.field pointer: typename (size: 4 -> static const typename(ref))
.field variant: typename (size: 8 -> static const typename(var))
.field function: typename (size: 4 -> static const typename(ref))
.field object: typename (size: 4 -> static const typename(ref))
.field null: pointer (size: 0 -> static const inline)
.field true: bool (size: 0 -> static const inline)
.field false: bool (size: 0 -> static const inline)
.field int: typename (size: 0 -> static const inline)
.field byte: typename (size: 0 -> static const inline)
.field float: typename (size: 0 -> static const inline)
.field double: typename (size: 0 -> static const inline)
.field .cstr: char (size: 4 -> static const typename(arr))
.field emit: function (size: 0 -> static const typename(void))
.field halt: function (size: 0 -> static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0 -> static const i64)
.field RAND_MAX: int64 (size: 0 -> static const i64)
.field raise: function (size: 0 -> static const inline)
.field tryExec: function (size: 0 -> static const inline)
.field System: void (size: 0 -> static const typename(void))
.field verbose: function (size: 0 -> inline)
.field verbose: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field NotEquals: typename (size: 24 -> static const typename(val))
.field assertEq: function (size: 83 -> static const function)
.field assertEq: function (size: 0 -> inline)
.field sizeof: function (size: 0 -> inline)
.field Math: typename (size: 0 -> static const typename(val))
.field Complex: typename (size: 16 -> static const typename(val))
.field Complex: function (size: 8 -> static const function)
.field Complex: function (size: 9 -> static const function)
.field neg: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field div: function (size: 128 -> static const function)
.field div: function (size: 0 -> inline)
.field div: function (size: 0 -> inline)
.field abs: function (size: 0 -> inline)
.field arg: function (size: 0 -> inline)
.field inv: function (size: 36 -> static const function)
.field conj: function (size: 0 -> inline)
.field exp: function (size: 0 -> inline)
.field log: function (size: 0 -> inline)
.field pow: function (size: 105 -> static const function)
.field pow: function (size: 0 -> inline)
.field sin: function (size: 0 -> inline)
.field cos: function (size: 0 -> inline)
.field tan: function (size: 0 -> inline)
.field cot: function (size: 0 -> inline)
.field sinh: function (size: 0 -> inline)
.field cosh: function (size: 0 -> inline)
.field tanh: function (size: 0 -> inline)
.field coth: function (size: 0 -> inline)
.field sec: function (size: 0 -> inline)
.field csc: function (size: 0 -> inline)
.field sech: function (size: 0 -> inline)
.field csch: function (size: 0 -> inline)
.field toCartesian: function (size: 0 -> inline)
.field toPolar: function (size: 0 -> inline)
.field length: function (size: 49 -> static const function)
.field indexOf: function (size: 56 -> static const function)
.field lastIndexOf: function (size: 62 -> static const function)
.field startsWith: function (size: 73 -> static const function)
.field endsWith: function (size: 131 -> static const function)
.field compare: function (size: 74 -> static const function)
.field ignCaseCmp: function (size: 36 -> static const function)
.field caseCmp: function (size: 14 -> static const function)
.field startsWith: function (size: 0 -> inline)
.field endsWith: function (size: 0 -> inline)
.field compare: function (size: 0 -> inline)
.field contains: function (size: 0 -> inline)
.field FormatFlags: typename (size: 16 -> static const typename(val))
.field append: function (size: 85 -> static const function)
.field append: function (size: 623 -> static const function)
.field append: function (size: 25 -> static const function)
.field append: function (size: 118 -> static const function)
.field File: typename (size: 8 -> static const typename(val))
.field gxRect: typename (size: 16 -> static const typename(val))
.field gxSurf: typename (size: 8 -> static const typename(val))
.field gxMesh: typename (size: 176 -> static const typename(ref))
.field camera: void (size: 0 -> static const typename(void))
.field lights: void (size: 0 -> static const typename(void))
.field Gui: void (size: 0 -> static const typename(void))
.field vec2d: typename (size: 16 -> static const typename(val))
.field vec2d: function (size: 9 -> static const function)
.field vec2d: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field dot: function (size: 14 -> static const function)
.field vec4f: typename (size: 16 -> static const typename(val))
.field vec4f: function (size: 17 -> static const function)
.field vec4f: function (size: 20 -> static const function)
.field vec4f: function (size: 17 -> static const function)
.field vec4f: function (size: 0 -> inline)
.field dp3: function (size: 0 -> inline)
.field dp4: function (size: 0 -> inline)
.field dph: function (size: 0 -> inline)
.field cross: function (size: 0 -> inline)
.field mat4f: typename (size: 64 -> static const typename(val))
.field mat4f: function (size: 65 -> static const function)
.field mat4f: function (size: 17 -> static const function)
.field dp3: function (size: 0 -> inline)
.field dp4: function (size: 0 -> inline)
.field dph: function (size: 0 -> inline)
.field mul: function (size: 410 -> static const function)
.field grayClamp: function (size: 25 -> static const function)
.field grayClamp: function (size: 37 -> static const function)
.field grayAnd: function (size: 0 -> inline)
.field rgb: function (size: 0 -> inline)
.field rgb: function (size: 0 -> inline)
.field rgbClamp: function (size: 0 -> inline)
.field rgbClamp: function (size: 0 -> inline)
.field rgbAnd: function (size: 0 -> inline)
.field rgb: function (size: 0 -> inline)
.field rgb: function (size: 0 -> inline)
.field gray: function (size: 0 -> inline)
.field gray: function (size: 0 -> inline)
.field rch: function (size: 0 -> inline)
.field gch: function (size: 0 -> inline)
.field bch: function (size: 0 -> inline)
.field lum: function (size: 0 -> inline)
.field rgbOr: function (size: 8 -> static const function)
.field rgbXor: function (size: 8 -> static const function)
.field rgbAnd: function (size: 8 -> static const function)
.field rgbAdd: function (size: 92 -> static const function)
.field rgbAvg: function (size: 77 -> static const function)
.field rgbSub: function (size: 92 -> static const function)
.field rgbMul: function (size: 77 -> static const function)
.field rgbDiv: function (size: 77 -> static const function)
.field rgbLerp16: function (size: 95 -> static const function)
.field rgbLerp: function (size: 30 -> static const function)
.field rgb: function (size: 0 -> inline)
.field Hsv2Rgb: function (size: 333 -> static const function)
.field gxSurf: function (size: 0 -> inline)
.field gxSurf: function (size: 189 -> static const function)
.field gxSurf: function (size: 0 -> inline)
.field gxMesh: function (size: 109 -> static const function)
.field gxSurf: function (size: 51 -> static const function)
.field clip: function (size: 240 -> static const function)
.field eval: function (size: 273 -> static const function)
.field tile: function (size: 207 -> static const function)
.field show: function (size: 119 -> static const function)
.field show: function (size: 17 -> static const function)
.field show: function (size: 43 -> static const function)
.field showWindow: function (size: 79 -> static const function)
.field .main: function (size: 111 -> static function)
.value: {
	{
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const message: char[*];
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.message := (message);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.000000 / ln2;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 1.000000 / ln10;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := (0) / 0.000000;
			static const inf: float64 := (1) / 0.000000;
			static const modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(x, result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static const sign(x: float32): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const sign(x: float64): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const abs(x: float32): float32 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const abs(x: float64): float64 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const min(a: float32, b: float32): float32 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const min(a: float64, b: float64): float64 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float32, b: float32): float32 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float64, b: float64): float64 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const lerp(t: float32, a: float32, b: float32): float32 := {
				return .result := a + t * (b - a);
			};
			static const lerp(t: float64, a: float64, b: float64): float64 := {
				return .result := a + t * (b - a);
			};
			static const smooth(t: float32, a: float32, b: float32): float32 := {
				t := clamp((t - a) / (b - a), 0.000000, 1.000000);
				return .result := t * t * ((3) - (2) * t);
			};
			static const smooth(t: float64, a: float64, b: float64): float64 := {
				t := clamp((t - a) / (b - a), 0.000000, 1.000000);
				return .result := t * t * ((3) - (2) * t);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else {
					if (i == 1) {
						x := (1) - x;
						complement := true;
					}
					else {
						if (i == 2) {
							negate := !negate;
							complement := true;
						}
						else {
							if (i == 3) {
								x := (1) - x;
								negate := !negate;
							}
						}
					}
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static const asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static deg2rad(x: float64): float64 := float64(x * pi / (180));
			static rad2deg(x: float64): float64 := float64(x * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static const Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(-a.re, -a.im);
		add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static const div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static const inv(a: Complex): Complex := {
			d: float64 := (a.re * a.re + a.im * a.im);
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const length(str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (chr >= 'A' && chr <= 'Z') {
					chr := chr - 'A';
					chr := chr + 'a';
				}
				return .result := chr;
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(str: char[*], with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(str: char[*], with: char[*]): int32 := compare(str, with, caseCmp);
		contains(str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const radix: int32;
			const sign: char;
			const padChr: char;
			const padLen: int32;
			const precision: int32;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(radix > 1 && radix < (radixDigits.length));
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if (format.sign != '') {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := format.sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				format.radix := 10;
				format.sign := '';
				format.padChr := ' ';
				format.padLen := 0;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
		static const append(output: char[], pos: int32, value: int32, forceSign: bool, pad: int32): int32 := {
			sign: char := 0;
			if (value < 0) {
				value := -value;
				sign := '-';
			}
			else {
				if (forceSign) {
					sign := '+';
				}
			}
			const format: FormatFlags := {
				format.radix := 10;
				format.sign := sign;
				format.padChr := '0';
				format.padLen := pad;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
	}
	{
		static const gxRect: struct {
			x: int32;
			y: int32;
			w: int32;
			h: int32;
		};
	}
	{
		static if ((null) == null) {
			static const vec2d: struct {
				x: float64;
				y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return .result := {
			.result.x := x;
			.result.y := y;
		};
			};
			vec2d(value: vec2d): vec2d := value;
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(vec2d(a), vec2d(b), sub.p2d));
			static const dot(const a: vec2d, const b: vec2d): float64 := {
				return .result := a.x * b.x + a.y * b.y;
			};
		}
		static if ((null) == null) {
			static const vec4f: struct {
				data: float32[4];
				.anonymous: .anonymous;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			static const vec4f(x: float32, y: float32, z: float32): vec4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := 0.000000;
		};
			};
			static const vec4f(xyzw: float32): vec4f := {
				return .result := {
			.result.x := xyzw;
			.result.y := xyzw;
			.result.z := xyzw;
			.result.w := xyzw;
		};
			};
			vec4f(value: vec4f): vec4f := value;
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(vec4f(rhs), vec4f(lhs), p4x.dp3));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(vec4f(rhs), vec4f(lhs), p4x.dp4));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(vec4f(rhs), vec4f(lhs), p4x.dph));
			cross(a: vec4f, b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
			static const mat4f: struct {
				data: float32[16];
				.anonymous: .anonymous;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
			};
			static const mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			dp3(mat: mat4f, vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), float32(1));
			dp4(mat: mat4f, vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
			dph(mat: mat4f, vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					transposed.x.x := rhs.x.x;
					transposed.x.y := rhs.y.x;
					transposed.x.z := rhs.z.x;
					transposed.x.w := rhs.w.x;
					transposed.y.x := rhs.x.y;
					transposed.y.y := rhs.y.y;
					transposed.y.z := rhs.z.y;
					transposed.y.w := rhs.w.y;
					transposed.z.x := rhs.x.z;
					transposed.z.y := rhs.y.z;
					transposed.z.z := rhs.z.z;
					transposed.z.w := rhs.w.z;
					transposed.w.x := rhs.x.w;
					transposed.w.y := rhs.y.w;
					transposed.w.z := rhs.z.w;
					transposed.w.w := rhs.w.w;
				};
				return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
			};
		}
		static if (true) {
			static const grayClamp(c: uint32): uint32 := {
				if (c > (255)) {
					return .result := 255;
				}
				return .result := c;
			};
			static const grayClamp(c: int32): uint32 := {
				if (c < 0) {
					return .result := 0;
				}
				if (c > 255) {
					return .result := 255;
				}
				return .result := c;
			};
			grayAnd(c: uint32): uint32 := uint32(c & (255));
			rgb(r: int32, g: int32, b: int32): uint32 := uint32((((r << 8) | g) << 8) | b);
			rgb(r: uint32, g: uint32, b: uint32): uint32 := uint32((((r << 8) | g) << 8) | b);
			rgbClamp(r: uint32, g: uint32, b: uint32): uint32 := rgb(grayClamp(r), grayClamp(g), grayClamp(b));
			rgbClamp(r: int32, g: int32, b: int32): uint32 := rgb(grayClamp(r), grayClamp(g), grayClamp(b));
			rgbAnd(r: uint32, g: uint32, b: uint32): uint32 := rgb(grayAnd(r), grayAnd(g), grayAnd(b));
			rgb(r: float64, g: float64, b: float64): uint32 := rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)));
			rgb(r: float32, g: float32, b: float32): uint32 := rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)));
			gray(c: float64): uint32 := grayClamp(int32(c * (255)));
			gray(c: float32): uint32 := grayClamp(int32(c * (255)));
			rch(col: int32): int32 := int32((col >> 16) & 255);
			gch(col: int32): int32 := int32((col >> 8) & 255);
			bch(col: int32): int32 := int32(col & 255);
			lum(c: int32): int32 := int32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);
			static const rgbOr(c1: uint32, c2: uint32): uint32 := {
				return .result := c1 | c2;
			};
			static const rgbXor(c1: uint32, c2: uint32): uint32 := {
				return .result := c1 ^ c2;
			};
			static const rgbAnd(c1: uint32, c2: uint32): uint32 := {
				return .result := c1 & c2;
			};
			static const rgbAdd(c1: uint32, c2: uint32): uint32 := {
				r: uint32 := rch(c1) + rch(c2);
				g: uint32 := gch(c1) + gch(c2);
				b: uint32 := bch(c1) + bch(c2);
				return .result := rgbClamp(r, g, b);
			};
			static const rgbAvg(c1: uint32, c2: uint32): uint32 := {
				r: uint32 := (rch(c1) + rch(c2)) / 2;
				g: uint32 := (gch(c1) + gch(c2)) / 2;
				b: uint32 := (bch(c1) + bch(c2)) / 2;
				return .result := rgb(r, g, b);
			};
			static const rgbSub(c1: uint32, c2: uint32): uint32 := {
				r: int32 := rch(c1) - rch(c2);
				g: int32 := gch(c1) - gch(c2);
				b: int32 := bch(c1) - bch(c2);
				return .result := rgbClamp(r, g, b);
			};
			static const rgbMul(c1: uint32, c2: uint32): uint32 := {
				r: uint32 := (rch(c1) * (rch(c2) + 1)) >> 8;
				g: uint32 := (gch(c1) * (gch(c2) + 1)) >> 8;
				b: uint32 := (bch(c1) * (bch(c2) + 1)) >> 8;
				return .result := rgb(r, g, b);
			};
			static const rgbDiv(c1: uint32, c2: uint32): uint32 := {
				r: uint32 := (rch(c1) << 8) / (rch(c2) + 1);
				g: uint32 := (gch(c1) << 8) / (gch(c2) + 1);
				b: uint32 := (bch(c1) << 8) / (bch(c2) + 1);
				return .result := rgb(r, g, b);
			};
			static const rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32 := {
				lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
				r: uint32 := lrpfix16(rch(c1), rch(c2));
				g: uint32 := lrpfix16(gch(c1), gch(c2));
				b: uint32 := lrpfix16(bch(c1), bch(c2));
				return .result := rgb(r, g, b);
			};
			static const rgbLerp(c1: uint32, c2: uint32, t: float64): uint32 := {
				return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
			};
			rgb(vec: vec4f): uint32 := rgbClamp(int32(vec.x * (255)), int32(vec.y * (255)), int32(vec.z * (255)));
			static const Hsv2Rgb(hsv: vec4f): vec4f := {
				h: float32 := hsv.x;
				s: float32 := hsv.y;
				v: float32 := hsv.z;
				if (s == (0)) {
					return .result := vec4f(v);
				}
				h := h * (360 / 60);
				i: int32 := int32(h);
				f: float32 := h - (i);
				u: float32 := v;
				p: float32 := v * ((1) - s);
				q: float32 := v * ((1) - s * f);
				t: float32 := v * ((1) - s * ((1) - f));
				if (i == 0) {
					return .result := vec4f(u, t, p);
				}
				if (i == 1) {
					return .result := vec4f(q, u, p);
				}
				if (i == 2) {
					return .result := vec4f(p, u, t);
				}
				if (i == 3) {
					return .result := vec4f(p, q, u);
				}
				if (i == 4) {
					return .result := vec4f(t, p, u);
				}
				return .result := vec4f(u, p, q);
			};
		}
		gxSurf(width: int32, height: int32, depth: int32): gxSurf := gxSurf.create(width, height, depth);
		static const gxSurf(fileName: char[*], depth: int32): gxSurf := {
			if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".jpg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".png", ignCaseCmp)) {
				return .result := gxSurf.openPng(fileName, depth);
			}
			if (endsWith(fileName, ".bmp", ignCaseCmp)) {
				return .result := gxSurf.openBmp(fileName, depth);
			}
			abort("unknown file extension", fileName);
		};
		gxSurf(fileName: char[*]): gxSurf := gxSurf(fileName, 32);
		static const gxMesh(fileName: char[*]): gxMesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := gxMesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := gxMesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const gxSurf(copy: gxSurf): gxSurf := {
			result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
			result.copy(result, 0, 0, copy, null);
			return .result := result;
		};
		static const clip(src: gxSurf, roi: gxRect): bool := {
			roi.w := roi.w + roi.x;
			roi.h := roi.h + roi.y;
			if (roi.x < 0) {
				roi.x := 0;
			}
			if (roi.y < 0) {
				roi.y := 0;
			}
			width: int32 := src.width(src);
			if (roi.w > width) {
				roi.w := width;
			}
			height: int32 := src.height(src);
			if (roi.h > height) {
				roi.h := height;
			}
			roi.w := roi.w - roi.x;
			roi.h := roi.h - roi.y;
			if (roi.w <= 0) {
				return .result := false;
			}
			if (roi.h <= 0) {
				return .result := false;
			}
			return .result := true;
		};
		static const eval(out: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: gxRect;
			if ((roi) == null) {
				rect.x := rect.y := 0;
				rect.w := out.width(out);
				rect.h := out.height(out);
			}
			else {
				rect := roi;
				if (!clip(out, rect)) {
					return;
				}
			}
			in: vec4f := {
				in.x := (0);
				in.y := (0);
				in.z := aspect;
				in.w := time;
			};
			w: float32 := out.width(out);
			h: float32 := out.height(out);
			for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
					in.x := (x) / w;
					out.set(out, x, y, rgb(eval(in)));
				}
			}
		};
		static const tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void := {
			rect: gxRect := {
				rect.x := 0;
				rect.y := 0;
				rect.w := src.width(src);
				rect.h := src.height(src);
			};
			if ((roi) != null) {
				rect.x := roi.x;
				rect.y := roi.y;
				rect.w := roi.w;
				rect.h := roi.h;
			}
			if (!clip(src, rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % rect.w);
			}
			if (y < 0) {
				y := -(-y % rect.h);
			}
			width: int32 := dst.width(dst);
			height: int32 := dst.height(dst);
			for (j: int32 := y; j < height; j := j + rect.h) {
				for (i: int32 := x; i < width; i := i + rect.w) {
					dst.copy(dst, i, j, src, rect);
				}
			}
		};
		static const show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void := {
			static const Closure: struct {
				mode: int32;
				offs: gxSurf;
				mesh: gxMesh;
			};
			static const next(x: int32, mask: int32): int32 := {
				next: int32 := x & mask;
				next := next + (mask & -mask);
				next := next & mask;
				return .result := next | (x & ~mask);
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				static ox: int32 := 0;
				static oy: int32 := 0;
				static const speed: float32 := 1.000000 / (100);
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
					else {
						if (button == ('l')) {
							closure.mode := ((closure.mode) ^ gxMesh.useLights);
						}
						else {
							if (button == ('0')) {
								lights.enable(0, !lights.enabled(0));
							}
							else {
								if (button == ('1')) {
									lights.enable(1, !lights.enabled(1));
								}
								else {
									if (button == ('2')) {
										lights.enable(2, !lights.enabled(2));
									}
									else {
										if (button == ('3')) {
											lights.enable(3, !lights.enabled(3));
										}
										else {
											if (button == ('t')) {
												closure.mode := ((closure.mode) ^ gxMesh.useTexture);
											}
											else {
												if (button == ('/')) {
													closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
												}
												else {
													if (button == ('\t')) {
														closure.mode := next(closure.mode, gxMesh.drawMode);
													}
													else {
														if (button == ('\r')) {
															eye: vec4f := {
																eye.x := (0);
																eye.y := (0);
																eye.z := (2);
																eye.w := (1);
															};
															at: vec4f := {
																at.x := (0);
																at.y := (0);
																at.z := (0);
																at.w := (1);
															};
															up: vec4f := {
																up.x := (0);
																up.y := (1);
																up.z := (0);
																up.w := (1);
															};
															camera.lookAt(eye.data, at.data, up.data);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					if ((action) == Gui.MOUSE_PRESS) {
						ox := ex;
						oy := ey;
						return .result := 0;
					}
					else {
						if ((action) == Gui.MOUSE_MOTION) {
							dir: float32[3];
							dx: int32 := ex - ox;
							dy: int32 := ey - oy;
							if (button == 1) {
								orig: float32[3];
								orig[0] := (0);
								orig[1] := (0);
								orig[2] := (0);
								camera.readUp(dir);
								camera.rotate(dir, orig, (dx) * speed);
								camera.readRight(dir);
								camera.rotate(dir, orig, (dy) * speed);
							}
							else {
								if (button == 2) {
									camera.readUp(dir);
									camera.rotate(dir, null, (-dx) * speed);
									camera.readRight(dir);
									camera.rotate(dir, null, (-dy) * speed);
								}
								else {
									if (button == 3) {
										camera.readForward(dir);
										camera.move(dir, (dy) * speed);
									}
									else {
										if (button == 4) {
											camera.readRight(dir);
											camera.move(dir, (-dx) * speed);
											camera.readUp(dir);
											camera.move(dir, (dy) * speed);
										}
									}
								}
							}
							ox := ex;
							oy := ey;
						}
					}
				}
				rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
				text: char[256];
				pos: int32 := append(text, 0, "Vertices: ");
				pos := append(text, pos, closure.mesh.vertices);
				pos := append(text, pos, ", Triangles: ");
				pos := append(text, pos, closure.mesh.triangles);
				pos := append(text, pos, "/");
				pos := append(text, pos, rendered);
				Gui.setTitle(text);
				return .result := 0;
			};
			closure: Closure := {
				closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
				closure.offs := gxSurf.create3d(w, h);
				closure.mesh := mesh;
			};
			camera.projection(fovy, (w) / float32(h), 1, 100);
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.offs.destroy(closure.offs);
		};
		static const show(surf: gxSurf): void := {
			Gui.showWindow(surf, null, null);
		};
		static const show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
			if ((onEvent) == null) {
				return .result := Gui.showWindow(surf, null, null);
			}
			static const delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				return .result := onEvent(action, button, ex, ey);
			};
			Gui.showWindow(surf, onEvent, delegateEvent);
		};
		static const showWindow(w: int32, h: int32, t: int32, eval(in: vec4f): vec4f): void := {
			static const start: int64 := System.millis();
			static const Closure: struct {
				const offs: gxSurf;
				const thumb: gxSurf;
				const aspect: float64;
				const eval(in: vec4f): vec4f;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.WINDOW_CLOSE) {
					trace("closing ...");
					return .result := 0;
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.KEY_RELEASE) {
					if (button == (' ')) {
						time: float32 := ((System.millis() - start)) / 1000.000000;
						eval(closure.offs, null, closure.aspect, time, closure.eval);
						return .result := 0;
					}
				}
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.thumb, null, closure.aspect, time, closure.eval);
				closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
				return .result := 1;
			};
			closure: Closure := {
				closure.offs := gxSurf(w, h, 32);
				closure.thumb := gxSurf(t, t, 32);
				closure.aspect := (w) / float64(h);
				closure.eval := eval;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.thumb.destroy(closure.thumb);
			closure.offs.destroy(closure.offs);
		};
	}
}
.instructions: (111 bytes)
	lib/string.ci:118: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main+?>:    load.c32 4
	<.main+?>:    load.ref .?????? ;" \t\n\r"
	<.main+?>:    store.m64 .?????? ;append.whiteSpace
	lib/string.ci:119: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>:    load.c32 36
	<.main+?>:    load.ref .?????? ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>:    store.m64 .?????? ;append.radixDigits
	lib/string.ci:180: (37 bytes): static const format: FormatFlags := {...}
	<.main+?>:    load.c32 10
	<.main+?>:    store.m32 .?????? ;append.format
	lib/string.ci:182: (7 bytes): format.sign := '';
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;append.format+4
	<.main+?>:    store.i8
	lib/string.ci:183: (11 bytes): format.padChr := ' ';
	<.main+?>:    load.c32 32
	<.main+?>:    load.ref .?????? ;append.format+5
	<.main+?>:    store.i8
	lib/string.ci:184: (5 bytes): format.padLen := 0;
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;append.format+8
	lib/string.ci:185: (5 bytes): format.precision := 0;
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;append.format+12
	libGfx/gfxlib.ci:215: (5 bytes): static ox: int32 := 0
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;show.onEvent.ox
	libGfx/gfxlib.ci:216: (5 bytes): static oy: int32 := 0
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;show.onEvent.oy
	libGfx/gfxlib.ci:217: (24 bytes): static const speed: float32 := 1.000000 / (100)
	<.main+?>:    load.f64 1.000000
	<.main+?>:    load.f64 100.000000
	<.main+?>:    div.f64
	<.main+?>:    f64.2f32
	<.main+?>:    store.m32 .?????? ;show.onEvent.speed
	libGfx/gfxlib.ci:336: (8 bytes): static const start: int64 := System.millis()
	<.main+?>:    nfc(16) ;System.millis(): int64
	<.main+?>:    store.m64 .?????? ;showWindow.start
	<.main+?>:    nfc(0) ;halt(): void
}

---------- Execute:

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:38: assertEq: function(<assertEq @03ae70>)
lib/math.ci:22: Math.modf: function(<Math.modf @03aec8>)
lib/math.ci:59: Math.floor: function(<Math.floor @03af30>)
lib/math.ci:71: Math.sign: function(<Math.sign @03af58>)
lib/math.ci:80: Math.sign: function(<Math.sign @03af80>)
lib/math.ci:90: Math.abs: function(<Math.abs @03afa8>)
lib/math.ci:96: Math.abs: function(<Math.abs @03afc0>)
lib/math.ci:103: Math.min: function(<Math.min @03afd8>)
lib/math.ci:109: Math.min: function(<Math.min @03aff0>)
lib/math.ci:116: Math.max: function(<Math.max @03b008>)
lib/math.ci:122: Math.max: function(<Math.max @03b020>)
lib/math.ci:129: Math.clamp: function(<Math.clamp @03b038>)
lib/math.ci:138: Math.clamp: function(<Math.clamp @03b060>)
lib/math.ci:148: Math.lerp: function(<Math.lerp @03b088>)
lib/math.ci:151: Math.lerp: function(<Math.lerp @03b098>)
lib/math.ci:155: Math.smooth: function(<Math.smooth @03b0a8>)
lib/math.ci:159: Math.smooth: function(<Math.smooth @03b0e8>)
lib/math.ci:239: Math.cmp: function(<Math.cmp @03b138>)
lib/math.ci:252: Math.cmp: function(<Math.cmp @03b178>)
lib/math.ci:266: Math.sinCos: function(<Math.sinCos @03b1b8>)
lib/math.ci:323: Math.tan: function(<Math.tan @03b318>)
lib/math.ci:380: Math.sinh: function(<Math.sinh @03b4a0>)
lib/math.ci:419: Math.cosh: function(<Math.cosh @03b598>)
lib/math.ci:435: Math.asin: function(<Math.asin @03b5e8>)
lib/math.ci:3: Math: typename(<Math>)
lib/math.Complex.ci:3: Complex: typename(<Complex>)
lib/math.Complex.ci:40: Complex: function(<Complex @03b6a0>)
lib/math.Complex.ci:45: Complex: function(<Complex @03b6a8>)
lib/math.Complex.ci:66: div: function(<div @03b6b8>)
lib/math.Complex.ci:93: inv: function(<inv @03b738>)
lib/math.Complex.ci:107: pow: function(<pow @03b760>)
lib/string.ci:3: length: function(<length @03b7d0>)
lib/string.ci:14: indexOf: function(<indexOf @03b808>)
lib/string.ci:24: lastIndexOf: function(<lastIndexOf @03b840>)
lib/string.ci:35: startsWith: function(<startsWith @03b880>)
lib/string.ci:44: endsWith: function(<endsWith @03b8d0>)
lib/string.ci:58: compare: function(<compare @03b958>)
lib/string.ci:70: ignCaseCmp: function(<ignCaseCmp @03b9f0>)
lib/string.ci:82: caseCmp: function(<caseCmp @03ba18>)
lib/string.ci:93: FormatFlags: typename(<FormatFlags>)
lib/string.ci:101: append: function(<append @03ba28>)
lib/string.ci:117: append: function(<append @03ba90>)
lib/string.ci:179: append: function(<append @03bd10>)
lib/string.ci:189: append: function(<append @03bd30>)
File: typename(<File>)
libGfx/src/gx_main.c:794: gxRect: typename(<gxRect>)
gxSurf: typename(<gxSurf>)
gxMesh: typename(<gxMesh>)
camera: typename(<camera>)
lights: typename(<lights>)
Gui: typename(<Gui>)
libGfx/gfxlib.vec2d.ci:1: vec2d: typename(<vec2d>)
libGfx/gfxlib.vec2d.ci:6: vec2d: function(<vec2d @03bda8>)
libGfx/gfxlib.vec2d.ci:22: dot: function(<dot @03bdb8>)
libGfx/gfxlib.vec4f.ci:2: vec4f: typename(<vec4f>)
libGfx/gfxlib.vec4f.ci:12: vec4f: function(<vec4f @03bdc8>)
libGfx/gfxlib.vec4f.ci:15: vec4f: function(<vec4f @03bde0>)
libGfx/gfxlib.vec4f.ci:18: vec4f: function(<vec4f @03bdf8>)
libGfx/gfxlib.mat4f.ci:2: mat4f: typename(<mat4f>)
libGfx/gfxlib.mat4f.ci:12: mat4f: function(<mat4f @03be10>)
libGfx/gfxlib.mat4f.ci:24: mat4f: function(<mat4f @03be58>)
libGfx/gfxlib.mat4f.ci:32: mul: function(<mul @03be70>)
libGfx/gfxlib.color.ci:2: grayClamp: function(<grayClamp @03c010>)
libGfx/gfxlib.color.ci:8: grayClamp: function(<grayClamp @03c030>)
libGfx/gfxlib.color.ci:51: rgbOr: function(<rgbOr @03c058>)
libGfx/gfxlib.color.ci:54: rgbXor: function(<rgbXor @03c060>)
libGfx/gfxlib.color.ci:57: rgbAnd: function(<rgbAnd @03c068>)
libGfx/gfxlib.color.ci:60: rgbAdd: function(<rgbAdd @03c070>)
libGfx/gfxlib.color.ci:66: rgbAvg: function(<rgbAvg @03c0d0>)
libGfx/gfxlib.color.ci:72: rgbSub: function(<rgbSub @03c120>)
libGfx/gfxlib.color.ci:78: rgbMul: function(<rgbMul @03c180>)
libGfx/gfxlib.color.ci:84: rgbDiv: function(<rgbDiv @03c1d0>)
libGfx/gfxlib.color.ci:91: rgbLerp16: function(<rgbLerp16 @03c220>)
libGfx/gfxlib.color.ci:100: rgbLerp: function(<rgbLerp @03c280>)
libGfx/gfxlib.ci:15: Hsv2Rgb: function(<Hsv2Rgb @03c2a0>)
libGfx/gfxlib.ci:56: gxSurf: function(<gxSurf @03c3f0>)
libGfx/gfxlib.ci:74: gxMesh: function(<gxMesh @03c4b0>)
libGfx/gfxlib.ci:84: gxSurf: function(<gxSurf @03c520>)
libGfx/gfxlib.ci:95: clip: function(<clip @03c558>)
libGfx/gfxlib.ci:129: eval: function(<eval @03c648>)
libGfx/gfxlib.ci:159: tile: function(<tile @03c760>)
libGfx/gfxlib.ci:194: show: function(<show @03cc70>)
libGfx/gfxlib.ci:321: show: function(<show @03cce8>)
libGfx/gfxlib.ci:325: show: function(<show @03cd18>)
libGfx/gfxlib.ci:335: showWindow: function(<showWindow @03ce78>)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 249654(243.8 Kb)
memory[heap] @03cf36; size: 1322952(1.3 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 241264(235.6 Kb)
memory[code] @000000; size: 8018(7.8 Kb)
memory[data] @000000; size: 52(52.0 bytes)

---------- heap memory:
memory[free] @03cf48; size: 1322912(1.3 Mb)
