
---------- Compile: `lib/stdlib.ci`

---------- Library: `bin/lnx.gcc/libFile.so`

---------- Library: `bin/lnx.gcc/libGfx.so`

---------- Compile: `lib/gfxlib.ci`

---------- Generate: byte-code
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/std/string.ci:249: warn: using signed cast for unsigned value: `value`
lib/std/string.ci:253: warn: using signed cast for unsigned value: `fract`
lib/gfx/color.ci:305: warn: uninitialized variable `drawHist.lut`
lib/gfxlib.ci:51: warn: operators `&&` and `||` does not short-circuit yet
lib/gfxlib.ci:72: warn: operators `&&` and `||` does not short-circuit yet
lib/gfxlib.ci:80: warn: operators `&&` and `||` does not short-circuit yet
lib/gfxlib.ci:313: warn: uninitialized variable `dir`
lib/gfxlib.ci:319: warn: uninitialized variable `orig`
lib/gfxlib.ci:354: warn: uninitialized variable `show.onEvent.text`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
.usages:
	lib/gfx/color.ci:188: referenced as `typename`
	lib/stdlib.ci:17: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 11
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
.usages:
	lib/stdlib.ci:17: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(3)
.usages:
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(4)
.usages:
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(5)
.usages:
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(6)
.usages:
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
.usages:
	lib/gfxlib.ci:423: referenced as `void`
	lib/gfxlib.ci:390: referenced as `void`
	lib/gfxlib.ci:379: referenced as `void`
	lib/gfxlib.ci:245: referenced as `void`
	lib/gfxlib.ci:217: referenced as `void`
	lib/gfxlib.ci:187: referenced as `void`
	lib/gfx/color.ci:304: referenced as `void`
	lib/gfx/color.ci:236: referenced as `void`
	lib/gfx/color.ci:178: referenced as `void`
	lib/std/debug.ci:64: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	internal usages: 51
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	lib/gfxlib.ci:426: referenced as `bool`
	lib/gfxlib.ci:141: referenced as `bool`
	lib/gfxlib.ci:49: referenced as `bool`
	lib/gfxlib.ci:48: referenced as `bool`
	lib/std/string.ci:113: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/std/debug.ci:45: referenced as `bool`
	lib/std/debug.ci:43: referenced as `bool`
	lib/std/debug.ci:41: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
	internal usages: 10
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
.usages:
	lib/gfxlib.ci:354: referenced as `char`
	lib/gfxlib.ci:106: referenced as `char`
	lib/gfxlib.ci:103: referenced as `char`
	lib/gfxlib.ci:100: referenced as `char`
	lib/gfxlib.ci:28: referenced as `char`
	lib/gfxlib.ci:25: referenced as `char`
	lib/gfxlib.ci:8: referenced as `char`
	lib/std/string.ci:261: referenced as `char`
	lib/std/string.ci:258: referenced as `char`
	lib/std/string.ci:247: referenced as `char`
	lib/std/string.ci:233: referenced as `char`
	lib/std/string.ci:230: referenced as `char`
	lib/std/string.ci:228: referenced as `char`
	lib/std/string.ci:226: referenced as `char`
	lib/std/string.ci:224: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:220: referenced as `char`
	lib/std/string.ci:218: referenced as `char`
	lib/std/string.ci:216: referenced as `char`
	lib/std/string.ci:173: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:119: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/std/debug.ci:64: referenced as `char`
	lib/std/debug.ci:59: referenced as `char`
	lib/std/debug.ci:43: referenced as `char`
	lib/std/debug.ci:41: referenced as `char`
	lib/std/debug.ci:36: referenced as `char`
	lib/std/debug.ci:34: referenced as `char`
	lib/std/debug.ci:31: referenced as `char`
	lib/std/debug.ci:29: referenced as `char`
	lib/std/debug.ci:26: referenced as `char`
	lib/std/debug.ci:24: referenced as `char`
	lib/std/debug.ci:21: referenced as `char`
	lib/std/debug.ci:19: referenced as `char`
	lib/std/debug.ci:16: referenced as `char`
	lib/std/debug.ci:14: referenced as `char`
	lib/std/debug.ci:11: referenced as `char`
	lib/std/debug.ci:9: referenced as `char`
	lib/std/debug.ci:6: referenced as `char`
	lib/std/debug.ci:4: referenced as `char`
	internal usages: 16
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	lib/std/string.ci:230: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	lib/std/string.ci:228: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	lib/gfxlib.ci:433: referenced as `int32`
	lib/gfxlib.ci:433: referenced as `int32`
	lib/gfxlib.ci:433: referenced as `int32`
	lib/gfxlib.ci:433: referenced as `int32`
	lib/gfxlib.ci:433: referenced as `int32`
	lib/gfxlib.ci:423: referenced as `int32`
	lib/gfxlib.ci:423: referenced as `int32`
	lib/gfxlib.ci:423: referenced as `int32`
	lib/gfxlib.ci:397: referenced as `int32`
	lib/gfxlib.ci:397: referenced as `int32`
	lib/gfxlib.ci:397: referenced as `int32`
	lib/gfxlib.ci:397: referenced as `int32`
	lib/gfxlib.ci:397: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:383: referenced as `int32`
	lib/gfxlib.ci:379: referenced as `int32`
	lib/gfxlib.ci:379: referenced as `int32`
	lib/gfxlib.ci:379: referenced as `int32`
	lib/gfxlib.ci:379: referenced as `int32`
	lib/gfxlib.ci:379: referenced as `int32`
	lib/gfxlib.ci:355: referenced as `int32`
	lib/gfxlib.ci:352: referenced as `int32`
	lib/gfxlib.ci:315: referenced as `int32`
	lib/gfxlib.ci:314: referenced as `int32`
	lib/gfxlib.ci:267: referenced as `int32`
	lib/gfxlib.ci:266: referenced as `int32`
	lib/gfxlib.ci:265: referenced as `int32`
	lib/gfxlib.ci:265: referenced as `int32`
	lib/gfxlib.ci:265: referenced as `int32`
	lib/gfxlib.ci:265: referenced as `int32`
	lib/gfxlib.ci:265: referenced as `int32`
	lib/gfxlib.ci:254: referenced as `int32`
	lib/gfxlib.ci:253: referenced as `int32`
	lib/gfxlib.ci:253: referenced as `int32`
	lib/gfxlib.ci:253: referenced as `int32`
	lib/gfxlib.ci:248: referenced as `int32`
	lib/gfxlib.ci:245: referenced as `int32`
	lib/gfxlib.ci:245: referenced as `int32`
	lib/gfxlib.ci:238: referenced as `int32`
	lib/gfxlib.ci:237: referenced as `int32`
	lib/gfxlib.ci:236: referenced as `int32`
	lib/gfxlib.ci:235: referenced as `int32`
	lib/gfxlib.ci:217: referenced as `int32`
	lib/gfxlib.ci:217: referenced as `int32`
	lib/gfxlib.ci:209: referenced as `int32`
	lib/gfxlib.ci:207: referenced as `int32`
	lib/gfxlib.ci:181: referenced as `int32`
	lib/gfxlib.ci:159: referenced as `int32`
	lib/gfxlib.ci:154: referenced as `int32`
	lib/gfxlib.ci:138: referenced as `int32`
	lib/gfxlib.ci:135: referenced as `int32`
	lib/gfxlib.ci:135: referenced as `int32`
	lib/gfxlib.ci:125: referenced as `int32`
	lib/gfxlib.ci:103: referenced as `int32`
	lib/gfxlib.ci:103: referenced as `int32`
	lib/gfxlib.ci:103: referenced as `int32`
	lib/gfxlib.ci:100: referenced as `int32`
	lib/gfxlib.ci:100: referenced as `int32`
	lib/gfxlib.ci:100: referenced as `int32`
	lib/gfxlib.ci:100: referenced as `int32`
	lib/gfxlib.ci:46: referenced as `int32`
	lib/gfxlib.ci:45: referenced as `int32`
	lib/gfxlib.ci:29: referenced as `int32`
	lib/gfxlib.ci:28: referenced as `int32`
	lib/gfxlib.ci:28: referenced as `int32`
	lib/gfxlib.ci:28: referenced as `int32`
	lib/gfxlib.ci:28: referenced as `int32`
	lib/gfxlib.ci:8: referenced as `int32`
	lib/gfxlib.ci:5: referenced as `int32`
	lib/gfxlib.ci:5: referenced as `int32`
	lib/gfxlib.ci:5: referenced as `int32`
	lib/gfx/color.ci:288: referenced as `int32`
	lib/gfx/color.ci:287: referenced as `int32`
	lib/gfx/color.ci:286: referenced as `int32`
	lib/gfx/color.ci:285: referenced as `int32`
	lib/gfx/color.ci:284: referenced as `int32`
	lib/gfx/color.ci:283: referenced as `int32`
	lib/gfx/color.ci:281: referenced as `int32`
	lib/gfx/color.ci:280: referenced as `int32`
	lib/gfx/color.ci:279: referenced as `int32`
	lib/gfx/color.ci:278: referenced as `int32`
	lib/gfx/color.ci:277: referenced as `int32`
	lib/gfx/color.ci:267: referenced as `int32`
	lib/gfx/color.ci:266: referenced as `int32`
	lib/gfx/color.ci:265: referenced as `int32`
	lib/gfx/color.ci:264: referenced as `int32`
	lib/gfx/color.ci:263: referenced as `int32`
	lib/gfx/color.ci:262: referenced as `int32`
	lib/gfx/color.ci:208: referenced as `int32`
	lib/gfx/color.ci:208: referenced as `int32`
	lib/gfx/color.ci:181: referenced as `int32`
	lib/gfx/color.ci:180: referenced as `int32`
	lib/gfx/color.ci:179: referenced as `int32`
	lib/gfx/color.ci:151: referenced as `int32`
	lib/gfx/color.ci:151: referenced as `int32`
	lib/gfx/color.ci:151: referenced as `int32`
	lib/gfx/color.ci:149: referenced as `int32`
	lib/gfx/color.ci:149: referenced as `int32`
	lib/gfx/color.ci:149: referenced as `int32`
	lib/gfx/color.ci:145: referenced as `int32`
	lib/gfx/color.ci:145: referenced as `int32`
	lib/gfx/color.ci:145: referenced as `int32`
	lib/gfx/color.ci:136: referenced as `int32`
	lib/gfx/color.ci:134: referenced as `int32`
	lib/gfx/color.ci:130: referenced as `int32`
	lib/gfx/color.ci:109: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:258: referenced as `int32`
	lib/std/string.ci:233: referenced as `int32`
	lib/std/string.ci:233: referenced as `int32`
	lib/std/string.ci:230: referenced as `int32`
	lib/std/string.ci:228: referenced as `int32`
	lib/std/string.ci:226: referenced as `int32`
	lib/std/string.ci:226: referenced as `int32`
	lib/std/string.ci:224: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:220: referenced as `int32`
	lib/std/string.ci:218: referenced as `int32`
	lib/std/string.ci:216: referenced as `int32`
	lib/std/string.ci:202: referenced as `int32`
	lib/std/string.ci:171: referenced as `int32`
	lib/std/string.ci:156: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:116: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:17: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	internal usages: 152
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	lib/gfxlib.ci:424: referenced as `int64`
	lib/std/string.ci:224: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	lib/gfx/color.ci:16: referenced as `uint8`
	lib/gfx/color.ci:13: referenced as `uint8`
	lib/gfx/color.ci:10: referenced as `uint8`
	lib/gfx/color.ci:7: referenced as `uint8`
	lib/std/string.ci:222: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
	internal usages: 4
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	lib/std/string.ci:220: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.value: 0
.usages:
	lib/gfxlib.ci:184: referenced as `uint32`
	lib/gfxlib.ci:181: referenced as `uint32`
	lib/gfxlib.ci:179: referenced as `uint32`
	lib/gfxlib.ci:177: referenced as `uint32`
	lib/gfx/color.ci:311: referenced as `uint32`
	lib/gfx/color.ci:305: referenced as `uint32`
	lib/gfx/color.ci:304: referenced as `uint32`
	lib/gfx/color.ci:304: referenced as `uint32`
	lib/gfx/color.ci:271: referenced as `uint32`
	lib/gfx/color.ci:271: referenced as `uint32`
	lib/gfx/color.ci:270: referenced as `uint32`
	lib/gfx/color.ci:270: referenced as `uint32`
	lib/gfx/color.ci:269: referenced as `uint32`
	lib/gfx/color.ci:269: referenced as `uint32`
	lib/gfx/color.ci:268: referenced as `uint32`
	lib/gfx/color.ci:268: referenced as `uint32`
	lib/gfx/color.ci:236: referenced as `uint32`
	lib/gfx/color.ci:236: referenced as `uint32`
	lib/gfx/color.ci:178: referenced as `uint32`
	lib/gfx/color.ci:175: referenced as `uint32`
	lib/gfx/color.ci:170: referenced as `uint32`
	lib/gfx/color.ci:169: referenced as `uint32`
	lib/gfx/color.ci:168: referenced as `uint32`
	lib/gfx/color.ci:167: referenced as `uint32`
	lib/gfx/color.ci:167: referenced as `uint32`
	lib/gfx/color.ci:167: referenced as `uint32`
	lib/gfx/color.ci:166: referenced as `uint32`
	lib/gfx/color.ci:163: referenced as `uint32`
	lib/gfx/color.ci:161: referenced as `uint32`
	lib/gfx/color.ci:159: referenced as `uint32`
	lib/gfx/color.ci:157: referenced as `uint32`
	lib/gfx/color.ci:155: referenced as `uint32`
	lib/gfx/color.ci:147: referenced as `uint32`
	lib/gfx/color.ci:147: referenced as `uint32`
	lib/gfx/color.ci:147: referenced as `uint32`
	lib/gfx/color.ci:142: referenced as `uint32`
	lib/gfx/color.ci:142: referenced as `uint32`
	lib/gfx/color.ci:142: referenced as `uint32`
	lib/gfx/color.ci:142: referenced as `uint32`
	lib/gfx/color.ci:142: referenced as `uint32`
	lib/gfx/color.ci:140: referenced as `uint32`
	lib/gfx/color.ci:140: referenced as `uint32`
	lib/gfx/color.ci:140: referenced as `uint32`
	lib/gfx/color.ci:140: referenced as `uint32`
	lib/gfx/color.ci:132: referenced as `uint32`
	lib/gfx/color.ci:128: referenced as `uint32`
	lib/gfx/color.ci:119: referenced as `uint32`
	lib/gfx/color.ci:119: referenced as `uint32`
	lib/gfx/color.ci:109: referenced as `uint32`
	lib/gfx/color.ci:105: referenced as `uint32`
	lib/gfx/color.ci:103: referenced as `uint32`
	lib/gfx/color.ci:103: referenced as `uint32`
	lib/gfx/color.ci:4: referenced as `uint32`
	lib/std/string.ci:218: referenced as `uint32`
	internal usages: 5
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(22)
.usages:
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(23)
.usages:
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(24)
.usages:
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(25)
.usages:
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(26)
.usages:
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(27)
.usages:
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(28)
.usages:
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(29)
.usages:
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.value: 0
.usages:
	lib/std/string.ci:253: referenced as `uint64`
	lib/std/string.ci:249: referenced as `uint64`
	lib/std/string.ci:230: referenced as `uint64`
	lib/std/string.ci:228: referenced as `uint64`
	lib/std/string.ci:226: referenced as `uint64`
	lib/std/string.ci:224: referenced as `uint64`
	lib/std/string.ci:222: referenced as `uint64`
	lib/std/string.ci:220: referenced as `uint64`
	lib/std/string.ci:218: referenced as `uint64`
	lib/std/string.ci:216: referenced as `uint64`
	lib/std/string.ci:216: referenced as `uint64`
	lib/std/string.ci:143: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(30)
.usages:
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(31)
.usages:
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	lib/gfxlib.ci:479: referenced as `float32`
	lib/gfxlib.ci:468: referenced as `float32`
	lib/gfxlib.ci:468: referenced as `float32`
	lib/gfxlib.ci:459: referenced as `float32`
	lib/gfxlib.ci:445: referenced as `float32`
	lib/gfxlib.ci:429: referenced as `float32`
	lib/gfxlib.ci:370: referenced as `float32`
	lib/gfxlib.ci:319: referenced as `float32`
	lib/gfxlib.ci:313: referenced as `float32`
	lib/gfxlib.ci:268: referenced as `float32`
	lib/gfxlib.ci:245: referenced as `float32`
	lib/gfxlib.ci:206: referenced as `float32`
	lib/gfxlib.ci:205: referenced as `float32`
	lib/gfxlib.ci:187: referenced as `float32`
	lib/gfxlib.ci:187: referenced as `float32`
	lib/gfx/color.ci:214: referenced as `float32`
	lib/gfx/color.ci:213: referenced as `float32`
	lib/gfx/color.ci:212: referenced as `float32`
	lib/gfx/color.ci:211: referenced as `float32`
	lib/gfx/color.ci:209: referenced as `float32`
	lib/gfx/color.ci:200: referenced as `float32`
	lib/gfx/color.ci:199: referenced as `float32`
	lib/gfx/color.ci:198: referenced as `float32`
	lib/gfx/color.ci:149: referenced as `float32`
	lib/gfx/color.ci:149: referenced as `float32`
	lib/gfx/color.ci:149: referenced as `float32`
	lib/gfx/color.ci:134: referenced as `float32`
	lib/std/string.ci:258: referenced as `float32`
	lib/std/math/Matrix4f.ci:169: referenced as `float32`
	lib/std/math/Matrix4f.ci:168: referenced as `float32`
	lib/std/math/Matrix4f.ci:158: referenced as `float32`
	lib/std/math/Matrix4f.ci:155: referenced as `float32`
	lib/std/math/Matrix4f.ci:132: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:128: referenced as `float32`
	lib/std/math/Matrix4f.ci:127: referenced as `float32`
	lib/std/math/Matrix4f.ci:126: referenced as `float32`
	lib/std/math/Matrix4f.ci:125: referenced as `float32`
	lib/std/math/Matrix4f.ci:124: referenced as `float32`
	lib/std/math/Matrix4f.ci:123: referenced as `float32`
	lib/std/math/Matrix4f.ci:122: referenced as `float32`
	lib/std/math/Matrix4f.ci:121: referenced as `float32`
	lib/std/math/Matrix4f.ci:120: referenced as `float32`
	lib/std/math/Matrix4f.ci:119: referenced as `float32`
	lib/std/math/Matrix4f.ci:118: referenced as `float32`
	lib/std/math/Matrix4f.ci:117: referenced as `float32`
	lib/std/math/Matrix4f.ci:107: referenced as `float32`
	lib/std/math/Matrix4f.ci:106: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:57: referenced as `float32`
	lib/std/math/Matrix4f.ci:55: referenced as `float32`
	lib/std/math/Matrix4f.ci:53: referenced as `float32`
	lib/std/math/Matrix4f.ci:51: referenced as `float32`
	lib/std/math/Matrix4f.ci:48: referenced as `float32`
	lib/std/math/Matrix4f.ci:46: referenced as `float32`
	lib/std/math/Matrix4f.ci:44: referenced as `float32`
	lib/std/math/Matrix4f.ci:42: referenced as `float32`
	lib/std/math/Matrix4f.ci:39: referenced as `float32`
	lib/std/math/Matrix4f.ci:37: referenced as `float32`
	lib/std/math/Matrix4f.ci:35: referenced as `float32`
	lib/std/math/Matrix4f.ci:33: referenced as `float32`
	lib/std/math/Matrix4f.ci:30: referenced as `float32`
	lib/std/math/Matrix4f.ci:28: referenced as `float32`
	lib/std/math/Matrix4f.ci:26: referenced as `float32`
	lib/std/math/Matrix4f.ci:24: referenced as `float32`
	lib/std/math/Matrix4f.ci:7: referenced as `float32`
	lib/std/math/Matrix4f.ci:4: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:102: referenced as `float32`
	lib/std/math/Vector4f.ci:96: referenced as `float32`
	lib/std/math/Vector4f.ci:92: referenced as `float32`
	lib/std/math/Vector4f.ci:88: referenced as `float32`
	lib/std/math/Vector4f.ci:84: referenced as `float32`
	lib/std/math/Vector4f.ci:82: referenced as `float32`
	lib/std/math/Vector4f.ci:40: referenced as `float32`
	lib/std/math/Vector4f.ci:37: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:13: referenced as `float32`
	lib/std/math/Vector4f.ci:11: referenced as `float32`
	lib/std/math/Vector4f.ci:9: referenced as `float32`
	lib/std/math/Vector4f.ci:7: referenced as `float32`
	lib/std/math/Vector4f.ci:4: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 76
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(32)
.usages:
	lib/std/math/Matrix4f.ci:130: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(33)
.usages:
	lib/std/math/Matrix4f.ci:131: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(34)
.usages:
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(35)
.usages:
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(36)
.usages:
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(37)
.usages:
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(38)
.usages:
	lib/std/math/Vector4f.ci:102: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(39)
.usages:
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	lib/gfxlib.ci:124: referenced as `float64`
	lib/gfxlib.ci:79: referenced as `float64`
	lib/gfxlib.ci:71: referenced as `float64`
	lib/gfxlib.ci:64: referenced as `float64`
	lib/gfxlib.ci:61: referenced as `float64`
	lib/gfxlib.ci:53: referenced as `float64`
	lib/gfxlib.ci:53: referenced as `float64`
	lib/gfxlib.ci:52: referenced as `float64`
	lib/gfxlib.ci:52: referenced as `float64`
	lib/gfxlib.ci:41: referenced as `float64`
	lib/gfxlib.ci:28: referenced as `float64`
	lib/gfx/color.ci:175: referenced as `float64`
	lib/gfx/color.ci:151: referenced as `float64`
	lib/gfx/color.ci:151: referenced as `float64`
	lib/gfx/color.ci:151: referenced as `float64`
	lib/gfx/color.ci:136: referenced as `float64`
	lib/std/string.ci:258: referenced as `float64`
	lib/std/string.ci:252: referenced as `float64`
	lib/std/string.ci:248: referenced as `float64`
	lib/std/string.ci:233: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:9: referenced as `float64`
	lib/std/math/Vector2d.ci:7: referenced as `float64`
	lib/std/math/Vector2d.ci:4: referenced as `float64`
	lib/std/math/Complex.ci:184: referenced as `float64`
	lib/std/math/Complex.ci:184: referenced as `float64`
	lib/std/math/Complex.ci:148: referenced as `float64`
	lib/std/math/Complex.ci:148: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:143: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:135: referenced as `float64`
	lib/std/math/Complex.ci:135: referenced as `float64`
	lib/std/math/Complex.ci:134: referenced as `float64`
	lib/std/math/Complex.ci:133: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:115: referenced as `float64`
	lib/std/math/Complex.ci:111: referenced as `float64`
	lib/std/math/Complex.ci:109: referenced as `float64`
	lib/std/math/Complex.ci:106: referenced as `float64`
	lib/std/math/Complex.ci:104: referenced as `float64`
	lib/std/math/Complex.ci:96: referenced as `float64`
	lib/std/math/Complex.ci:95: referenced as `float64`
	lib/std/math/Complex.ci:89: referenced as `float64`
	lib/std/math/Complex.ci:88: referenced as `float64`
	lib/std/math/Complex.ci:80: referenced as `float64`
	lib/std/math/Complex.ci:78: referenced as `float64`
	lib/std/math/Complex.ci:73: referenced as `float64`
	lib/std/math/Complex.ci:71: referenced as `float64`
	lib/std/math/Complex.ci:66: referenced as `float64`
	lib/std/math/Complex.ci:64: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:24: referenced as `float64`
	lib/std/math/Complex.ci:8: referenced as `float64`
	lib/std/math/Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 19
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(40)
.usages:
	lib/std/math/Complex.ci:184: referenced as `sin`
	lib/std/math/Complex.ci:148: referenced as `sin`
	lib/std/math/Complex.ci:146: referenced as `sin`
	lib/std/math/Complex.ci:139: referenced as `sin`
	lib/std/math/Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(41)
.usages:
	lib/std/math/Complex.ci:184: referenced as `cos`
	lib/std/math/Complex.ci:148: referenced as `cos`
	lib/std/math/Complex.ci:146: referenced as `cos`
	lib/std/math/Complex.ci:138: referenced as `cos`
	lib/std/math/Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(42)
.usages:
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(43)
.usages:
	lib/std/math/Complex.ci:135: referenced as `log`
	lib/std/math/Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(44)
.usages:
	lib/std/math/Complex.ci:136: referenced as `exp`
	lib/std/math/Complex.ci:126: referenced as `exp`
	lib/std/math/Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(45)
.usages:
	lib/std/string.ci:252: referenced as `pow`
	lib/std/math/Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(46)
.usages:
	lib/std/math/Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(47)
.usages:
	lib/std/math/Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.usages:
	internal usages: 17
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: int32 (size: 4, cast: variable(i32))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(13)
.usages:
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(14)
.usages:
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
.field is: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.usages:
	lib/std/debug.ci:56: referenced as `variant`
	lib/std/debug.ci:53: referenced as `variant`
	lib/std/debug.ci:50: referenced as `variant`
	lib/std/debug.ci:41: referenced as `variant`
	lib/std/debug.ci:34: referenced as `variant`
	lib/std/debug.ci:29: referenced as `variant`
	lib/std/debug.ci:24: referenced as `variant`
	lib/std/debug.ci:19: referenced as `variant`
	lib/std/debug.ci:14: referenced as `variant`
	lib/std/debug.ci:9: referenced as `variant`
	lib/std/debug.ci:4: referenced as `variant`
	internal usages: 3
}
variant.is(var: variant, type: typename): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'is'
.owner: variant
.param .result: bool (size: 4, cast: inline)
.param var: variant (size: 8, cast: variable(var))
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, cast: inline)
.param var: variant (size: 8, cast: variable(var))
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
.usages:
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.usages:
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param obj: object (size: 4, cast: variable(ref))
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
.usages:
	lib/gfxlib.ci:471: referenced as `null`
	lib/gfxlib.ci:470: referenced as `null`
	lib/gfxlib.ci:461: referenced as `null`
	lib/gfxlib.ci:461: referenced as `null`
	lib/gfxlib.ci:460: referenced as `null`
	lib/gfxlib.ci:446: referenced as `null`
	lib/gfxlib.ci:408: referenced as `null`
	lib/gfxlib.ci:404: referenced as `null`
	lib/gfxlib.ci:381: referenced as `null`
	lib/gfxlib.ci:381: referenced as `null`
	lib/gfxlib.ci:380: referenced as `null`
	lib/gfxlib.ci:376: referenced as `null`
	lib/gfxlib.ci:376: referenced as `null`
	lib/gfxlib.ci:334: referenced as `null`
	lib/gfxlib.ci:332: referenced as `null`
	lib/gfxlib.ci:222: referenced as `null`
	lib/gfxlib.ci:221: referenced as `null`
	lib/gfxlib.ci:220: referenced as `null`
	lib/gfxlib.ci:219: referenced as `null`
	lib/gfxlib.ci:192: referenced as `null`
	lib/gfxlib.ci:191: referenced as `null`
	lib/gfxlib.ci:190: referenced as `null`
	lib/gfxlib.ci:189: referenced as `null`
	lib/gfxlib.ci:138: referenced as `null`
	lib/gfxlib.ci:130: referenced as `null`
	lib/gfxlib.ci:130: referenced as `null`
	lib/gfxlib.ci:130: referenced as `null`
	lib/gfxlib.ci:119: referenced as `null`
	lib/gfxlib.ci:94: referenced as `null`
	lib/gfxlib.ci:94: referenced as `null`
	lib/gfx/color.ci:311: referenced as `null`
	lib/gfx/color.ci:276: referenced as `null`
	lib/gfx/color.ci:261: referenced as `null`
	lib/gfx/color.ci:250: referenced as `null`
	lib/gfx/color.ci:249: referenced as `null`
	lib/gfx/color.ci:248: referenced as `null`
	lib/gfx/color.ci:247: referenced as `null`
	lib/gfx/color.ci:188: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/std/debug.ci:76: referenced as `null`
	lib/std/debug.ci:59: referenced as `null`
	lib/std/debug.ci:56: referenced as `null`
	lib/std/debug.ci:38: referenced as `null`
	lib/std/debug.ci:36: referenced as `null`
	lib/std/debug.ci:31: referenced as `null`
	lib/std/debug.ci:26: referenced as `null`
	lib/std/debug.ci:21: referenced as `null`
	lib/std/debug.ci:16: referenced as `null`
	lib/std/debug.ci:11: referenced as `null`
	lib/std/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
.usages:
	lib/gfx/color.ci:105: referenced as `emit`
	lib/gfx/color.ci:103: referenced as `emit`
	lib/std/math/Vector2d.ci:22: referenced as `emit`
	lib/std/math/Vector4f.ci:96: referenced as `emit`
	lib/std/math/Vector4f.ci:92: referenced as `emit`
	lib/std/math/Vector4f.ci:88: referenced as `emit`
	lib/std/math/Vector4f.ci:84: referenced as `emit`
	lib/std/math/Vector4f.ci:82: referenced as `emit`
	lib/std/math/Vector4f.ci:79: referenced as `emit`
	lib/std/math/Vector4f.ci:77: referenced as `emit`
	lib/std/math/Vector4f.ci:75: referenced as `emit`
	lib/std/math/Vector4f.ci:73: referenced as `emit`
	lib/std/math/Vector4f.ci:71: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `p4x`
	lib/std/math/Vector4f.ci:92: referenced as `p4x`
	lib/std/math/Vector4f.ci:88: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/std/math/Vector4f.ci:88: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/std/math/Vector4f.ci:92: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:73: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/std/math/Vector4f.ci:73: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `sub`
	lib/std/math/Vector4f.ci:75: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/std/math/Vector4f.ci:75: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:79: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/std/math/Vector4f.ci:79: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.param inspect: variant (size: 8, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(9)
.usages:
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/std/debug.ci:73: referenced as `abort`
	lib/std/debug.ci:38: referenced as `abort`
	lib/std/debug.ci:36: referenced as `abort`
	lib/std/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/std/debug.ci:31: referenced as `error`
	lib/std/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/std/debug.ci:26: referenced as `warn`
	lib/std/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/std/debug.ci:21: referenced as `info`
	lib/std/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	lib/std/debug.ci:16: referenced as `debug`
	lib/std/debug.ci:14: referenced as `debug`
	lib/std/debug.ci:11: referenced as `debug`
	lib/std/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/std/debug.ci:6: referenced as `verbose`
	lib/std/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/std/debug.ci:26: referenced as `noTrace`
	lib/std/debug.ci:24: referenced as `noTrace`
	lib/std/debug.ci:21: referenced as `noTrace`
	lib/std/debug.ci:19: referenced as `noTrace`
	lib/std/debug.ci:11: referenced as `noTrace`
	lib/std/debug.ci:9: referenced as `noTrace`
	lib/std/debug.ci:6: referenced as `noTrace`
	lib/std/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/std/debug.ci:73: referenced as `defTrace`
	lib/std/debug.ci:38: referenced as `defTrace`
	lib/std/debug.ci:36: referenced as `defTrace`
	lib/std/debug.ci:34: referenced as `defTrace`
	lib/std/debug.ci:31: referenced as `defTrace`
	lib/std/debug.ci:29: referenced as `defTrace`
	lib/std/debug.ci:16: referenced as `defTrace`
	lib/std/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.value: nfc(10)
.usages:
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
.usages:
	lib/gfxlib.ci:459: referenced as `System`
	lib/gfxlib.ci:445: referenced as `System`
	lib/gfxlib.ci:424: referenced as `System`
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.value: nfc(15)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.value: nfc(16)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(17)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(18)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(19)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.value: nfc(20)
.usages:
	lib/gfxlib.ci:459: referenced as `millis`
	lib/gfxlib.ci:445: referenced as `millis`
	lib/gfxlib.ci:424: referenced as `millis`
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.value: nfc(21)
.usages:
	internal usages: 1
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	lib/gfxlib.ci:426: referenced as `true`
	lib/gfxlib.ci:173: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
	lib/stdlib.ci:4: defined as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	lib/gfxlib.ci:171: referenced as `false`
	lib/gfxlib.ci:168: referenced as `false`
	lib/std/string.ci:241: referenced as `false`
	lib/std/string.ci:113: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/stdlib.ci:5: defined as `false`
}
byte: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
	lib/stdlib.ci:8: defined as `byte`
}
float: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
	lib/stdlib.ci:9: defined as `float`
}
double: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
	lib/stdlib.ci:10: defined as `double`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/std/debug.ci:4'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, inspect)
.usages:
	lib/std/debug.ci:4: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/std/debug.ci:6'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, null)
.usages:
	lib/std/debug.ci:6: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/std/debug.ci:9'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, inspect)
.usages:
	lib/std/debug.ci:9: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/std/debug.ci:11'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, null)
.usages:
	lib/std/debug.ci:11: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/std/debug.ci:14'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, inspect)
.usages:
	lib/std/math/Matrix4f.ci:109: referenced as `trace`
	lib/std/debug.ci:14: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/std/debug.ci:16'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, null)
.usages:
	lib/gfxlib.ci:453: referenced as `trace`
	lib/gfxlib.ci:435: referenced as `trace`
	lib/std/debug.ci:16: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/std/debug.ci:19'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, inspect)
.usages:
	lib/std/debug.ci:19: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/std/debug.ci:21'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, null)
.usages:
	lib/std/debug.ci:21: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/std/debug.ci:24'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, inspect)
.usages:
	lib/std/debug.ci:24: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/std/debug.ci:26'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, null)
.usages:
	lib/std/debug.ci:26: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/std/debug.ci:29'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, inspect)
.usages:
	lib/std/debug.ci:29: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/std/debug.ci:31'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, null)
.usages:
	lib/std/debug.ci:31: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/std/debug.ci:34'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, inspect)
.usages:
	lib/gfxlib.ci:113: referenced as `abort`
	lib/gfxlib.ci:21: referenced as `abort`
	lib/std/debug.ci:41: referenced as `abort`
	lib/std/debug.ci:34: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/std/debug.ci:36'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, null)
.usages:
	lib/std/debug.ci:45: referenced as `abort`
	lib/std/debug.ci:43: referenced as `abort`
	lib/std/debug.ci:36: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/std/debug.ci:38'
.param .result: void (size: 0, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
.usages:
	lib/std/debug.ci:38: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/std/debug.ci:41'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message, inspect))
.usages:
	lib/std/string.ci:161: referenced as `assert`
	lib/std/string.ci:160: referenced as `assert`
	lib/std/debug.ci:41: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/std/debug.ci:43'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/std/debug.ci:43: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/std/debug.ci:45'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	lib/std/string.ci:203: referenced as `assert`
	lib/std/string.ci:196: referenced as `assert`
	lib/std/string.ci:189: referenced as `assert`
	lib/std/string.ci:184: referenced as `assert`
	lib/std/debug.ci:45: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'NotEquals'
.file: 'lib/std/debug.ci:48'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field argument: variant (size: 8, cast: const variable(var))
.field message: char[*] (size: 4, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/std/debug.ci:68: referenced as `NotEquals`
	lib/std/debug.ci:48: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'lib/std/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/std/debug.ci:69: referenced as `expected`
	lib/std/debug.ci:50: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'lib/std/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/std/debug.ci:70: referenced as `returned`
	lib/std/debug.ci:53: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'argument'
.file: 'lib/std/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:56: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'message'
.file: 'lib/std/debug.ci:59'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:71: referenced as `message`
	lib/std/debug.ci:59: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.name: 'assertEq'
.file: 'lib/std/debug.ci:64'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (returned == expected) {
		return;
	}
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.message := (message);
		details.argument := (null);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (94 bytes)
	lib/std/debug.ci:65: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x32 sp(2)
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	lib/std/debug.ci:66: (1 byte): return;
	<assertEq+?>: ret
	lib/std/debug.ci:68: (41 bytes): details: NotEquals := {...}
	<assertEq+?>: inc.sp(+32)
	lib/std/debug.ci:69: (11 bytes): details.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x64 sp(2)
	lib/std/debug.ci:70: (11 bytes): details.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x64 sp(4)
	lib/std/debug.ci:71: (3 bytes): details.message := (message);
	<assertEq+?>: mov.x32 sp(6, 9)
	:: (12 bytes): details.argument := (null)
	<assertEq+?>: load.ref <?> ;pointer
	<assertEq+?>: load.ref <?> ;null
	<assertEq+?>: set.x64 sp(6)
	lib/std/debug.ci:73: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>: load.ref <?> ;"lib/std/debug.ci"
	<assertEq+?>: load.c32 73
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+24)
	<assertEq+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
.usages:
	lib/std/debug.ci:76: referenced as `assertEq`
	lib/std/debug.ci:64: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'lib/std/debug.ci:76'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(expected, returned, null)
.usages:
	lib/std/debug.ci:76: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'lib/stdlib.ci:17'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	lib/stdlib.ci:17: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, cast: static const val)
.field e: float64 (size: 8, cast: static const val)
.field ln2: float64 (size: 8, cast: static const val)
.field log2E: float64 (size: 8, cast: static const val)
.field ln10: float64 (size: 8, cast: static const val)
.field log10E: float64 (size: 8, cast: static const val)
.field phi: float64 (size: 8, cast: static const val)
.field sqrt2: float64 (size: 8, cast: static const val)
.field sqrtE: float64 (size: 8, cast: static const val)
.field sqrtPi: float64 (size: 8, cast: static const val)
.field sqrtPhi: float64 (size: 8, cast: static const val)
.field nan: float64 (size: 8, cast: static const val)
.field inf: float64 (size: 8, cast: static const val)
.field modf: function (size: 86, cast: static const function)
.field floor: function (size: 24, cast: static const function)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field abs: function (size: 18, cast: static const function)
.field abs: function (size: 18, cast: static const function)
.field absMod: function (size: 27, cast: static const function)
.field absMod: function (size: 27, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field lerp: function (size: 0, cast: static inline)
.field lerp: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field min: function (size: 79, cast: static const function)
.field max: function (size: 79, cast: static const function)
.field sum: function (size: 40, cast: static const function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field sinCos: function (size: 335, cast: static const function)
.field sin: function (size: 0, cast: static inline)
.field cos: function (size: 0, cast: static inline)
.field tan: function (size: 378, cast: static const function)
.field sinh: function (size: 241, cast: static const function)
.field cosh: function (size: 75, cast: static const function)
.field asin: function (size: 173, cast: static const function)
.field acos: function (size: 0, cast: static inline)
.field radians: function (size: 0, cast: static inline)
.field degrees: function (size: 0, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	lib/gfxlib.ci:103: referenced as `Math`
	lib/gfxlib.ci:100: referenced as `Math`
	lib/gfxlib.ci:57: referenced as `Math`
	lib/gfxlib.ci:55: referenced as `Math`
	lib/std/string.ci:248: referenced as `Math`
	lib/std/string.ci:248: referenced as `Math`
	lib/std/math/Complex.ci:148: referenced as `Math`
	lib/std/math/Complex.ci:148: referenced as `Math`
	lib/std/math/Complex.ci:146: referenced as `Math`
	lib/std/math/Complex.ci:146: referenced as `Math`
	lib/std/math/Complex.ci:87: referenced as `Math`
	lib/std/math/Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	lib/gfxlib.ci:103: referenced as `inf`
	lib/gfxlib.ci:100: referenced as `inf`
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (86 bytes)
	lib/std/math.ci:23: (63 bytes): if (x < (1))
	<modf>  : dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +51
	lib/std/math.ci:24: (39 bytes): if (x < (0))
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +35
	lib/std/math.ci:25: (17 bytes): result: float64 := -modf(-x, intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x64 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	<modf+?>: neg.f64
	lib/std/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x32 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:27: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	lib/std/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x32 sp(3)
	<modf+?>: store.i64
	lib/std/math.ci:30: (4 bytes): return .result := x;
	<modf+?>: mov.x64 sp(4, 2)
	<modf+?>: ret
	lib/std/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	lib/std/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>: dup.x64 sp(4)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:34: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
.usages:
	lib/std/string.ci:248: referenced as `modf`
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(x, result);
	return .result := result;
}
.instructions: (24 bytes)
	lib/std/math.ci:48: (1 byte): result: float64
	<floor>  : load.z128
	lib/std/math.ci:49: (20 bytes): modf(x, result);
	<floor+?>: dup.x64 sp(5)
	<floor+?>: load.sp(+16)
	<floor+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>: call
	<floor+?>: inc.sp(-12)
	<floor+?>: inc.sp(-8)
	lib/std/math.ci:50: (3 bytes): return .result := result;
	<floor+?>: set.x64 sp(5)
	<floor+?>: ret
.usages:
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:78: (14 bytes): if (x < (0))
	<abs>  : dup.x32 sp(1)
	<abs+?>: load.z32
	<abs+?>: clt.f32
	<abs+?>: jz +10
	lib/std/math.ci:79: (6 bytes): return .result := -x;
	<abs+?>: dup.x32 sp(1)
	<abs+?>: neg.f32
	<abs+?>: set.x32 sp(3)
	<abs+?>: ret
	lib/std/math.ci:81: (4 bytes): return .result := x;
	<abs+?>: mov.x32 sp(2, 1)
	<abs+?>: ret
.usages:
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:86: (14 bytes): if (x < (0))
	<abs>  : dup.x64 sp(1)
	<abs+?>: load.z64
	<abs+?>: clt.f64
	<abs+?>: jz +10
	lib/std/math.ci:87: (6 bytes): return .result := -x;
	<abs+?>: dup.x64 sp(1)
	<abs+?>: neg.f64
	<abs+?>: set.x64 sp(5)
	<abs+?>: ret
	lib/std/math.ci:89: (4 bytes): return .result := x;
	<abs+?>: mov.x64 sp(3, 1)
	<abs+?>: ret
.usages:
	lib/std/string.ci:248: referenced as `abs`
	lib/std/math/Complex.ci:87: referenced as `abs`
	lib/std/math/Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param val: float32 (size: 4, cast: variable(f32))
.param mod: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	lib/std/math.ci:94: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: mod.f32
	<absMod+?>: dup.x32 sp(0)
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: load.z32
	<absMod+?>: clt.f32
	<absMod+?>: jz +12
	lib/std/math.ci:95: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: add.f32
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: ret
	lib/std/math.ci:97: (4 bytes): return .result := val;
	<absMod+?>: mov.x32 sp(3, 2)
	<absMod+?>: ret
.usages:
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param val: float64 (size: 8, cast: variable(f64))
.param mod: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	lib/std/math.ci:102: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: mod.f64
	<absMod+?>: dup.x64 sp(0)
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: load.z64
	<absMod+?>: clt.f64
	<absMod+?>: jz +12
	lib/std/math.ci:103: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: add.f64
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: ret
	lib/std/math.ci:105: (4 bytes): return .result := val;
	<absMod+?>: mov.x64 sp(5, 3)
	<absMod+?>: ret
.usages:
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:116: (13 bytes): if (a < b)
	<min>  : dup.x32 sp(2)
	<min+?>: dup.x32 sp(2)
	<min+?>: clt.f32
	<min+?>: jz +8
	lib/std/math.ci:117: (4 bytes): return .result := a;
	<min+?>: mov.x32 sp(3, 2)
	<min+?>: ret
	lib/std/math.ci:119: (4 bytes): return .result := b;
	<min+?>: mov.x32 sp(3, 1)
	<min+?>: ret
.usages:
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:124: (13 bytes): if (a < b)
	<min>  : dup.x64 sp(3)
	<min+?>: dup.x64 sp(3)
	<min+?>: clt.f64
	<min+?>: jz +8
	lib/std/math.ci:125: (4 bytes): return .result := a;
	<min+?>: mov.x64 sp(5, 3)
	<min+?>: ret
	lib/std/math.ci:127: (4 bytes): return .result := b;
	<min+?>: mov.x64 sp(5, 1)
	<min+?>: ret
.usages:
	lib/gfxlib.ci:57: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:138: (13 bytes): if (a > b)
	<max>  : dup.x32 sp(2)
	<max+?>: dup.x32 sp(2)
	<max+?>: cgt.f32
	<max+?>: jz +8
	lib/std/math.ci:139: (4 bytes): return .result := a;
	<max+?>: mov.x32 sp(3, 2)
	<max+?>: ret
	lib/std/math.ci:141: (4 bytes): return .result := b;
	<max+?>: mov.x32 sp(3, 1)
	<max+?>: ret
.usages:
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:146: (13 bytes): if (a > b)
	<max>  : dup.x64 sp(3)
	<max+?>: dup.x64 sp(3)
	<max+?>: cgt.f64
	<max+?>: jz +8
	lib/std/math.ci:147: (4 bytes): return .result := a;
	<max+?>: mov.x64 sp(5, 3)
	<max+?>: ret
	lib/std/math.ci:149: (4 bytes): return .result := b;
	<max+?>: mov.x64 sp(5, 1)
	<max+?>: ret
.usages:
	lib/gfxlib.ci:55: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:160: (13 bytes): if (t < a)
	<clamp>  : dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: clt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:161: (4 bytes): return .result := a;
	<clamp+?>: mov.x32 sp(4, 2)
	<clamp+?>: ret
	lib/std/math.ci:163: (13 bytes): if (t > b)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: cgt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:164: (4 bytes): return .result := b;
	<clamp+?>: mov.x32 sp(4, 1)
	<clamp+?>: ret
	lib/std/math.ci:166: (4 bytes): return .result := t;
	<clamp+?>: mov.x32 sp(4, 3)
	<clamp+?>: ret
.usages:
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:171: (13 bytes): if (t < a)
	<clamp>  : dup.x64 sp(5)
	<clamp+?>: dup.x64 sp(5)
	<clamp+?>: clt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:172: (4 bytes): return .result := a;
	<clamp+?>: mov.x64 sp(7, 3)
	<clamp+?>: ret
	lib/std/math.ci:174: (13 bytes): if (t > b)
	<clamp+?>: dup.x64 sp(5)
	<clamp+?>: dup.x64 sp(3)
	<clamp+?>: cgt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:175: (4 bytes): return .result := b;
	<clamp+?>: mov.x64 sp(7, 1)
	<clamp+?>: ret
	lib/std/math.ci:177: (4 bytes): return .result := t;
	<clamp+?>: mov.x64 sp(7, 5)
	<clamp+?>: ret
.usages:
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float32(0), float32(1)))
.usages:
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float64(0), float64(1)))
.usages:
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result > data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	lib/std/math.ci:202: (20 bytes): if (data.length == (0))
	<min>  : dup.x32 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +16
	lib/std/math.ci:203: (12 bytes): return .result := nan;
	<min+?>: load.f64 -nan
	<min+?>: set.x64 sp(5)
	<min+?>: ret
	lib/std/math.ci:205: (3 bytes): result: float64 := data[0]
	<min+?>: dup.x32 sp(1)
	<min+?>: load.i64
	lib/std/math.ci:206: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	lib/std/math.ci:207: (27 bytes): if (result > data[i])
	<min+?>: dup.x64 sp(1)
	<min+?>: dup.x32 sp(6)
	<min+?>: dup.x32 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	lib/std/math.ci:208: (11 bytes): result := data[i];
	<min+?>: dup.x32 sp(4)
	<min+?>: dup.x32 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	lib/std/math.ci:206: (9 bytes): i < (data.length)
	<min+?>: dup.x32 sp(0)
	<min+?>: dup.x32 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	lib/std/math.ci:211: (3 bytes): return .result := result;
	<min+?>: set.x64 sp(5)
	<min+?>: ret
.usages:
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result < data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	lib/std/math.ci:216: (20 bytes): if (data.length == (0))
	<max>  : dup.x32 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +16
	lib/std/math.ci:217: (12 bytes): return .result := nan;
	<max+?>: load.f64 -nan
	<max+?>: set.x64 sp(5)
	<max+?>: ret
	lib/std/math.ci:219: (3 bytes): result: float64 := data[0]
	<max+?>: dup.x32 sp(1)
	<max+?>: load.i64
	lib/std/math.ci:220: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	lib/std/math.ci:221: (27 bytes): if (result < data[i])
	<max+?>: dup.x64 sp(1)
	<max+?>: dup.x32 sp(6)
	<max+?>: dup.x32 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	lib/std/math.ci:222: (11 bytes): result := data[i];
	<max+?>: dup.x32 sp(4)
	<max+?>: dup.x32 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	lib/std/math.ci:220: (9 bytes): i < (data.length)
	<max+?>: dup.x32 sp(0)
	<max+?>: dup.x32 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	lib/std/math.ci:225: (3 bytes): return .result := result;
	<max+?>: set.x64 sp(5)
	<max+?>: ret
.usages:
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (data.length); i := i + 1) {
		result := result + data[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	lib/std/math.ci:230: (1 byte): result: float64 := 0
	<sum>  : load.z128
	lib/std/math.ci:231: (36 bytes): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	lib/std/math.ci:232: (14 bytes): result := result + data[i];
	<sum+?>: dup.x64 sp(1)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: dup.x32 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	lib/std/math.ci:231: (9 bytes): i < (data.length)
	<sum+?>: dup.x32 sp(0)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	lib/std/math.ci:234: (3 bytes): return .result := result;
	<sum+?>: set.x64 sp(5)
	<sum+?>: ret
.usages:
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * a1)
.usages:
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2))
.usages:
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2, a3))
.usages:
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	lib/std/math.ci:257: (1 byte): result: float64 := 0
	<eval>  : load.z64
	lib/std/math.ci:258: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	lib/std/math.ci:259: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x64 sp(1)
	<eval+?>: dup.x64 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x32 sp(6)
	<eval+?>: dup.x32 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x64 sp(3)
	lib/std/math.ci:258: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	lib/std/math.ci:258: (8 bytes): i >= 0
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	lib/std/math.ci:261: (3 bytes): return .result := result;
	<eval+?>: set.x64 sp(7)
	<eval+?>: ret
.usages:
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.param eps: float32 (size: 4, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:266: (53 bytes): if (a < b)
	<cmp>  : dup.x32 sp(3)
	<cmp+?>: dup.x32 sp(3)
	<cmp+?>: clt.f32
	<cmp+?>: jz +28
	lib/std/math.ci:267: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x32 sp(1)
	<cmp+?>: dup.x32 sp(3)
	<cmp+?>: dup.x32 sp(5)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:268: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:272: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x32 sp(1)
	<cmp+?>: dup.x32 sp(4)
	<cmp+?>: dup.x32 sp(4)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:273: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
	lib/std/math.ci:276: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
.usages:
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.param eps: float64 (size: 8, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:281: (53 bytes): if (a < b)
	<cmp>  : dup.x64 sp(5)
	<cmp+?>: dup.x64 sp(5)
	<cmp+?>: clt.f64
	<cmp+?>: jz +28
	lib/std/math.ci:282: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x64 sp(1)
	<cmp+?>: dup.x64 sp(5)
	<cmp+?>: dup.x64 sp(9)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:283: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:287: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x64 sp(1)
	<cmp+?>: dup.x64 sp(7)
	<cmp+?>: dup.x64 sp(7)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:288: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
	lib/std/math.ci:291: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
.usages:
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (335 bytes)
	lib/std/math.ci:309: (2 bytes): x: float64 := arg
	<sinCos>  : dup.x64 sp(2)
	lib/std/math.ci:310: (17 bytes): if (x < (0))
	<sinCos+?>: dup.x64 sp(0)
	<sinCos+?>: load.z64
	<sinCos+?>: clt.f64
	<sinCos+?>: jz +13
	lib/std/math.ci:311: (1 byte): x := -x;
	<sinCos+?>: neg.f64
	lib/std/math.ci:312: (8 bytes): quad := quad + 2;
	<sinCos+?>: dup.x32 sp(3)
	<sinCos+?>: inc.i32(+2)
	<sinCos+?>: set.x32 sp(4)
	lib/std/math.ci:315: (1 byte): y: float64
	<sinCos+?>: load.z64
	lib/std/math.ci:316: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: load.f64 1.570796
	<sinCos+?>: div.f64
	<sinCos+?>: mul.f64
	<sinCos+?>: set.x64 sp(4)
	lib/std/math.ci:317: (124 bytes): if (x > (32764))
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 32764.000000
	<sinCos+?>: cgt.f64
	<sinCos+?>: jz +84
	lib/std/math.ci:318: (1 byte): e: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:319: (18 bytes): y := modf(x, e);
	<sinCos+?>: dup.x64 sp(6)
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: set.x64 sp(4)
	lib/std/math.ci:320: (4 bytes): e := e + (quad);
	<sinCos+?>: dup.x32 sp(7)
	<sinCos+?>: i32.2f64
	<sinCos+?>: add.f64
	lib/std/math.ci:322: (1 byte): f: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:323: (30 bytes): modf(0.250000 * e, f);
	<sinCos+?>: load.f64 0.250000
	<sinCos+?>: dup.x64 sp(6)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: inc.sp(-8)
	lib/std/math.ci:324: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 4.000000
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: sub.f64
	<sinCos+?>: f64.2i32
	<sinCos+?>: set.x32 sp(10)
	<sinCos+?>: inc.sp(-16)
	<sinCos+?>: jmp +32
	lib/std/math.ci:327: (3 bytes): k: int32 := x
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: f64.2i32
	lib/std/math.ci:328: (8 bytes): y := x - (k);
	<sinCos+?>: dup.x64 sp(3)
	<sinCos+?>: dup.x32 sp(2)
	<sinCos+?>: i32.2f64
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x64 sp(3)
	lib/std/math.ci:329: (7 bytes): quad := quad + k;
	<sinCos+?>: dup.x32 sp(6)
	<sinCos+?>: dup.x32 sp(1)
	<sinCos+?>: add.i32
	<sinCos+?>: set.x32 sp(7)
	lib/std/math.ci:330: (6 bytes): quad := quad & 3;
	<sinCos+?>: dup.x32 sp(6)
	<sinCos+?>: b32.and 0x003
	<sinCos+?>: set.x32 sp(7)
	<sinCos+?>: inc.sp(-4)
	lib/std/math.ci:332: (22 bytes): if (quad & 1)
	<sinCos+?>: dup.x32 sp(5)
	<sinCos+?>: b32.and 0x001
	<sinCos+?>: jz +18
	lib/std/math.ci:333: (14 bytes): y := (1) - y;
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x64 sp(2)
	lib/std/math.ci:335: (13 bytes): if (quad > 1)
	<sinCos+?>: dup.x32 sp(5)
	<sinCos+?>: load.c32 1
	<sinCos+?>: cgt.i32
	<sinCos+?>: jz +5
	lib/std/math.ci:336: (1 byte): y := -y;
	<sinCos+?>: neg.f64
	lib/std/math.ci:339: (5 bytes): ysq: float64 := y * y
	<sinCos+?>: dup.x64 sp(0)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	lib/std/math.ci:340: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>: load.f64 145.968841
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -13847.272500
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 440103.053538
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -4942908.100903
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 13578840.978774
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	lib/std/math.ci:341: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 132.653491
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 9463.096102
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 408179.225234
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 8644558.652923
	<sinCos+?>: add.f64
	lib/std/math.ci:342: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: div.f64
	<sinCos+?>: set.x64 sp(16)
	<sinCos+?>: inc.sp(-40)
	<sinCos+?>: ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(arg, 0)
.usages:
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(abs(arg), 1)
.usages:
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else {
		if (i == 1) {
			x := (1) - x;
			complement := true;
		}
		else {
			if (i == 2) {
				negate := !negate;
				complement := true;
			}
			else {
				if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
			}
		}
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (378 bytes)
	lib/std/math.ci:365: (1 byte): complement: bool := false
	<tan>  : load.z32
	lib/std/math.ci:366: (1 byte): negate: bool := false
	<tan+?>: load.z32
	lib/std/math.ci:368: (23 bytes): if (arg < (0))
	<tan+?>: dup.x64 sp(3)
	<tan+?>: load.z64
	<tan+?>: clt.f64
	<tan+?>: jz +19
	lib/std/math.ci:369: (5 bytes): arg := -arg;
	<tan+?>: dup.x64 sp(3)
	<tan+?>: neg.f64
	<tan+?>: set.x64 sp(5)
	lib/std/math.ci:370: (10 bytes): negate := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+4)
	<tan+?>: store.i8
	lib/std/math.ci:372: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1.570796
	<tan+?>: div.f64
	<tan+?>: set.x64 sp(5)
	lib/std/math.ci:374: (1 byte): e: float64
	<tan+?>: load.z128
	lib/std/math.ci:375: (16 bytes): x: float64 := modf(arg, e)
	<tan+?>: dup.x64 sp(7)
	<tan+?>: load.sp(+16)
	<tan+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	lib/std/math.ci:376: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>: dup.x64 sp(2)
	<tan+?>: f64.2i32
	<tan+?>: load.c32 4
	<tan+?>: mod.i32
	lib/std/math.ci:378: (122 bytes): if (i == 0)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.z32
	<tan+?>: ceq.i32
	<tan+?>: jnz +118
	lib/std/math.ci:379: (114 bytes): if (i == 1)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 1
	<tan+?>: ceq.i32
	<tan+?>: jz +32
	lib/std/math.ci:380: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x64 sp(3)
	lib/std/math.ci:381: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +78
	lib/std/math.ci:383: (74 bytes): if (i == 2)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 2
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:384: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:385: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +41
	lib/std/math.ci:387: (37 bytes): if (i == 3)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 3
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:388: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x64 sp(3)
	lib/std/math.ci:389: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:392: (5 bytes): xsq: float64 := x * x
	<tan+?>: dup.x64 sp(1)
	<tan+?>: dup.x64 sp(3)
	<tan+?>: mul.f64
	lib/std/math.ci:393: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>: load.f64 0.000034
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 0.034226
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -15.506857
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1055.970902
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -13068.202648
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	lib/std/math.ci:394: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>: dup.x64 sp(2)
	<tan+?>: load.f64 -155.503316
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 4765.751363
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -16638.952389
	<tan+?>: add.f64
	<tan+?>: div.f64
	lib/std/math.ci:396: (47 bytes): if (complement)
	<tan+?>: load.sp(+40)
	<tan+?>: load.i8
	<tan+?>: jz +42
	lib/std/math.ci:397: (24 bytes): if (result == (0))
	<tan+?>: dup.x64 sp(0)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +20
	lib/std/math.ci:398: (16 bytes): return .result := nan;
	<tan+?>: load.f64 -nan
	<tan+?>: set.x64 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:400: (14 bytes): result := (1) / result;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(2)
	<tan+?>: div.f64
	<tan+?>: set.x64 sp(2)
	lib/std/math.ci:402: (19 bytes): if (negate)
	<tan+?>: load.sp(+36)
	<tan+?>: load.i8
	<tan+?>: jz +14
	lib/std/math.ci:403: (10 bytes): return .result := -result;
	<tan+?>: dup.x64 sp(0)
	<tan+?>: neg.f64
	<tan+?>: set.x64 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:405: (7 bytes): return .result := result;
	<tan+?>: set.x64 sp(14)
	<tan+?>: inc.sp(-36)
	<tan+?>: ret
.usages:
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (241 bytes)
	lib/std/math.ci:421: (1 byte): negate: bool := false
	<sinh>  : load.z32
	lib/std/math.ci:422: (23 bytes): if (x < (0))
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.z64
	<sinh+?>: clt.f64
	<sinh+?>: jz +19
	lib/std/math.ci:423: (5 bytes): x := -x;
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: neg.f64
	<sinh+?>: set.x64 sp(4)
	lib/std/math.ci:424: (10 bytes): negate := true;
	<sinh+?>: load.c32 1
	<sinh+?>: load.sp(+4)
	<sinh+?>: store.i8
	lib/std/math.ci:427: (39 bytes): if (x > (21))
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.f64 21.000000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +27
	lib/std/math.ci:428: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: nfc(44) ;float64.exp(x: float64): float64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
	lib/std/math.ci:431: (1 byte): result: float64
	<sinh+?>: load.z64
	lib/std/math.ci:432: (151 bytes): if (x > 0.500000)
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: load.f64 0.500000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +34
	lib/std/math.ci:433: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: nfc(44) ;float64.exp(x: float64): float64
	<sinh+?>: dup.x64 sp(6)
	<sinh+?>: neg.f64
	<sinh+?>: nfc(44) ;float64.exp(x: float64): float64
	<sinh+?>: sub.f64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(2)
	<sinh+?>: jmp +109
	lib/std/math.ci:436: (5 bytes): sq: float64 := x * x
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: dup.x64 sp(6)
	<sinh+?>: mul.f64
	lib/std/math.ci:437: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>: load.f64 -26.305632
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -2894.211356
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -89912.720220
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(8)
	<sinh+?>: mul.f64
	<sinh+?>: set.x64 sp(4)
	lib/std/math.ci:438: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.f64 -173.678954
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 15215.173788
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(4)
	<sinh+?>: inc.sp(-8)
	lib/std/math.ci:441: (19 bytes): if (negate)
	<sinh+?>: load.sp(+8)
	<sinh+?>: load.i8
	<sinh+?>: jz +14
	lib/std/math.ci:442: (10 bytes): return .result := -result;
	<sinh+?>: dup.x64 sp(0)
	<sinh+?>: neg.f64
	<sinh+?>: set.x64 sp(8)
	<sinh+?>: inc.sp(-12)
	<sinh+?>: ret
	lib/std/math.ci:444: (7 bytes): return .result := result;
	<sinh+?>: set.x64 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
.usages:
	lib/std/math/Complex.ci:148: referenced as `sinh`
	lib/std/math/Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	lib/std/math.ci:449: (13 bytes): if (x < (0))
	<cosh>  : dup.x64 sp(1)
	<cosh+?>: load.z64
	<cosh+?>: clt.f64
	<cosh+?>: jz +9
	lib/std/math.ci:450: (5 bytes): x := -x;
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: neg.f64
	<cosh+?>: set.x64 sp(3)
	lib/std/math.ci:452: (35 bytes): if (x > (21))
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: load.f64 21.000000
	<cosh+?>: cgt.f64
	<cosh+?>: jz +23
	lib/std/math.ci:453: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: nfc(44) ;float64.exp(x: float64): float64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x64 sp(5)
	<cosh+?>: ret
	lib/std/math.ci:455: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: nfc(44) ;float64.exp(x: float64): float64
	<cosh+?>: dup.x64 sp(3)
	<cosh+?>: neg.f64
	<cosh+?>: nfc(44) ;float64.exp(x: float64): float64
	<cosh+?>: add.f64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x64 sp(5)
	<cosh+?>: ret
.usages:
	lib/std/math/Complex.ci:148: referenced as `cosh`
	lib/std/math/Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(±0) = ±0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (173 bytes)
	lib/std/math.ci:464: (12 bytes): if (x == (0))
	<asin>  : dup.x64 sp(1)
	<asin+?>: load.z64
	<asin+?>: ceq.f64
	<asin+?>: jz +8
	lib/std/math.ci:466: (4 bytes): return .result := x;
	<asin+?>: mov.x64 sp(3, 1)
	<asin+?>: ret
	lib/std/math.ci:469: (1 byte): negate: bool := false
	<asin+?>: load.z32
	lib/std/math.ci:470: (23 bytes): if (x < (0))
	<asin+?>: dup.x64 sp(2)
	<asin+?>: load.z64
	<asin+?>: clt.f64
	<asin+?>: jz +19
	lib/std/math.ci:471: (10 bytes): negate := true;
	<asin+?>: load.c32 1
	<asin+?>: load.sp(+4)
	<asin+?>: store.i8
	lib/std/math.ci:472: (5 bytes): x := -x;
	<asin+?>: dup.x64 sp(2)
	<asin+?>: neg.f64
	<asin+?>: set.x64 sp(4)
	lib/std/math.ci:475: (32 bytes): if (x > (1))
	<asin+?>: dup.x64 sp(2)
	<asin+?>: load.f64 1.000000
	<asin+?>: cgt.f64
	<asin+?>: jz +20
	lib/std/math.ci:477: (16 bytes): return .result := nan;
	<asin+?>: load.f64 -nan
	<asin+?>: set.x64 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
	lib/std/math.ci:480: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>: load.f64 1.000000
	<asin+?>: dup.x64 sp(4)
	<asin+?>: dup.x64 sp(6)
	<asin+?>: mul.f64
	<asin+?>: sub.f64
	<asin+?>: nfc(46) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes): if (x > 0.700000)
	<asin+?>: dup.x64 sp(4)
	<asin+?>: load.f64 0.700000
	<asin+?>: cgt.f64
	<asin+?>: jz +38
	lib/std/math.ci:482: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>: load.f64 3.141593
	<asin+?>: load.f64 2.000000
	<asin+?>: div.f64
	<asin+?>: dup.x64 sp(2)
	<asin+?>: dup.x64 sp(8)
	<asin+?>: nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: sub.f64
	<asin+?>: set.x64 sp(2)
	<asin+?>: jmp +14
	lib/std/math.ci:485: (10 bytes): result := float64.atan2(x, result);
	<asin+?>: dup.x64 sp(4)
	<asin+?>: dup.x64 sp(2)
	<asin+?>: nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: set.x64 sp(2)
	lib/std/math.ci:488: (19 bytes): if (negate)
	<asin+?>: load.sp(+8)
	<asin+?>: load.i8
	<asin+?>: jz +14
	lib/std/math.ci:489: (10 bytes): return .result := -result;
	<asin+?>: dup.x64 sp(0)
	<asin+?>: neg.f64
	<asin+?>: set.x64 sp(8)
	<asin+?>: inc.sp(-12)
	<asin+?>: ret
	lib/std/math.ci:491: (7 bytes): return .result := result;
	<asin+?>: set.x64 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
.usages:
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (pi / (2) - asin(x))
.usages:
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param degrees: float64 (size: 8, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(degrees * pi / (180))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param radians: float64 (size: 8, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(radians * (180) / pi)
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:2'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math/Complex.ci:186: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:181: referenced as `Complex`
	lib/std/math/Complex.ci:179: referenced as `Complex`
	lib/std/math/Complex.ci:177: referenced as `Complex`
	lib/std/math/Complex.ci:175: referenced as `Complex`
	lib/std/math/Complex.ci:172: referenced as `Complex`
	lib/std/math/Complex.ci:170: referenced as `Complex`
	lib/std/math/Complex.ci:168: referenced as `Complex`
	lib/std/math/Complex.ci:166: referenced as `Complex`
	lib/std/math/Complex.ci:163: referenced as `Complex`
	lib/std/math/Complex.ci:161: referenced as `Complex`
	lib/std/math/Complex.ci:148: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:143: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:123: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:111: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:106: referenced as `Complex`
	lib/std/math/Complex.ci:104: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:80: referenced as `Complex`
	lib/std/math/Complex.ci:78: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: referenced as `Complex`
	lib/std/math/Complex.ci:24: referenced as `Complex`
	lib/std/math/Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'lib/std/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math/Complex.ci:184: referenced as `re`
	lib/std/math/Complex.ci:184: referenced as `re`
	lib/std/math/Complex.ci:148: referenced as `re`
	lib/std/math/Complex.ci:148: referenced as `re`
	lib/std/math/Complex.ci:146: referenced as `re`
	lib/std/math/Complex.ci:146: referenced as `re`
	lib/std/math/Complex.ci:138: referenced as `re`
	lib/std/math/Complex.ci:136: referenced as `re`
	lib/std/math/Complex.ci:135: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:123: referenced as `re`
	lib/std/math/Complex.ci:117: referenced as `re`
	lib/std/math/Complex.ci:117: referenced as `re`
	lib/std/math/Complex.ci:115: referenced as `re`
	lib/std/math/Complex.ci:115: referenced as `re`
	lib/std/math/Complex.ci:111: referenced as `re`
	lib/std/math/Complex.ci:109: referenced as `re`
	lib/std/math/Complex.ci:109: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:99: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:96: referenced as `re`
	lib/std/math/Complex.ci:95: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:92: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:89: referenced as `re`
	lib/std/math/Complex.ci:88: referenced as `re`
	lib/std/math/Complex.ci:87: referenced as `re`
	lib/std/math/Complex.ci:80: referenced as `re`
	lib/std/math/Complex.ci:78: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:73: referenced as `re`
	lib/std/math/Complex.ci:71: referenced as `re`
	lib/std/math/Complex.ci:69: referenced as `re`
	lib/std/math/Complex.ci:69: referenced as `re`
	lib/std/math/Complex.ci:66: referenced as `re`
	lib/std/math/Complex.ci:64: referenced as `re`
	lib/std/math/Complex.ci:62: referenced as `re`
	lib/std/math/Complex.ci:62: referenced as `re`
	lib/std/math/Complex.ci:59: referenced as `re`
	lib/std/math/Complex.ci:33: referenced as `re`
	lib/std/math/Complex.ci:26: referenced as `re`
	lib/std/math/Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'lib/std/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math/Complex.ci:184: referenced as `im`
	lib/std/math/Complex.ci:184: referenced as `im`
	lib/std/math/Complex.ci:148: referenced as `im`
	lib/std/math/Complex.ci:148: referenced as `im`
	lib/std/math/Complex.ci:146: referenced as `im`
	lib/std/math/Complex.ci:146: referenced as `im`
	lib/std/math/Complex.ci:139: referenced as `im`
	lib/std/math/Complex.ci:136: referenced as `im`
	lib/std/math/Complex.ci:135: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:123: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:115: referenced as `im`
	lib/std/math/Complex.ci:115: referenced as `im`
	lib/std/math/Complex.ci:111: referenced as `im`
	lib/std/math/Complex.ci:109: referenced as `im`
	lib/std/math/Complex.ci:109: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:98: referenced as `im`
	lib/std/math/Complex.ci:96: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:91: referenced as `im`
	lib/std/math/Complex.ci:89: referenced as `im`
	lib/std/math/Complex.ci:88: referenced as `im`
	lib/std/math/Complex.ci:87: referenced as `im`
	lib/std/math/Complex.ci:80: referenced as `im`
	lib/std/math/Complex.ci:78: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:73: referenced as `im`
	lib/std/math/Complex.ci:71: referenced as `im`
	lib/std/math/Complex.ci:69: referenced as `im`
	lib/std/math/Complex.ci:69: referenced as `im`
	lib/std/math/Complex.ci:66: referenced as `im`
	lib/std/math/Complex.ci:64: referenced as `im`
	lib/std/math/Complex.ci:62: referenced as `im`
	lib/std/math/Complex.ci:62: referenced as `im`
	lib/std/math/Complex.ci:59: referenced as `im`
	lib/std/math/Complex.ci:34: referenced as `im`
	lib/std/math/Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:24'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	lib/std/math/Complex.ci:25: (7 bytes): return .result := {...};
	<Complex>  : mov.x64 sp(3, 1)
	:: (3 bytes): .result.im := (0)
	<Complex+?>: load.z64
	<Complex+?>: set.x64 sp(7)
	<Complex+?>: ret
.usages:
	lib/std/math/Complex.ci:143: referenced as `Complex`
	lib/std/math/Complex.ci:106: referenced as `Complex`
	lib/std/math/Complex.ci:104: referenced as `Complex`
	lib/std/math/Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:31'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.param im: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (7 bytes)
	lib/std/math/Complex.ci:32: (7 bytes): return .result := {...};
	<Complex>  : mov.x64 sp(5, 3)
	lib/std/math/Complex.ci:34: (3 bytes): .result.im := im;
	<Complex+?>: mov.x64 sp(7, 1)
	<Complex+?>: ret
.usages:
	lib/std/math/Complex.ci:186: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:148: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:123: referenced as `Complex`
	lib/std/math/Complex.ci:80: referenced as `Complex`
	lib/std/math/Complex.ci:78: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/std/math/Complex.ci:59'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(-a.re, -a.im)
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `neg`
	lib/std/math/Complex.ci:168: referenced as `neg`
	lib/std/math/Complex.ci:166: referenced as `neg`
	lib/std/math/Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math/Complex.ci:62'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re + b.re, a.im + b.im)
.usages:
	lib/std/math/Complex.ci:168: referenced as `add`
	lib/std/math/Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math/Complex.ci:64'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re + b, a.im)
.usages:
	lib/std/math/Complex.ci:172: referenced as `add`
	lib/std/math/Complex.ci:170: referenced as `add`
	lib/std/math/Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math/Complex.ci:66'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a + b.re, b.im)
.usages:
	lib/std/math/Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math/Complex.ci:69'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re - b.re, a.im - b.im)
.usages:
	lib/std/math/Complex.ci:166: referenced as `sub`
	lib/std/math/Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math/Complex.ci:71'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re - b, a.im)
.usages:
	lib/std/math/Complex.ci:172: referenced as `sub`
	lib/std/math/Complex.ci:170: referenced as `sub`
	lib/std/math/Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math/Complex.ci:73'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a - b.re, b.im)
.usages:
	lib/std/math/Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math/Complex.ci:76'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
.usages:
	lib/std/math/Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math/Complex.ci:78'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: Complex(a.re * b, a.im * b)
.usages:
	lib/std/math/Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math/Complex.ci:80'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a * b.re, a * b.im)
.usages:
	lib/std/math/Complex.ci:172: referenced as `mul`
	lib/std/math/Complex.ci:172: referenced as `mul`
	lib/std/math/Complex.ci:170: referenced as `mul`
	lib/std/math/Complex.ci:170: referenced as `mul`
	lib/std/math/Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.name: 'div'
.file: 'lib/std/math/Complex.ci:83'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (123 bytes)
	lib/std/math/Complex.ci:87: (79 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : load.z64
	<div+?>: dup.x64 sp(3)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: load.z64
	<div+?>: dup.x64 sp(7)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: clt.f64
	<div+?>: jnz +52
	lib/std/math/Complex.ci:88: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(3)
	<div+?>: div.f64
	lib/std/math/Complex.ci:89: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math/Complex.ci:90: (31 bytes): return .result := {...};
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	lib/std/math/Complex.ci:92: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	lib/std/math/Complex.ci:95: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x64 sp(1)
	<div+?>: dup.x64 sp(5)
	<div+?>: div.f64
	lib/std/math/Complex.ci:96: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math/Complex.ci:97: (31 bytes): return .result := {...};
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	lib/std/math/Complex.ci:99: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
.usages:
	lib/std/math/Complex.ci:172: referenced as `div`
	lib/std/math/Complex.ci:170: referenced as `div`
	lib/std/math/Complex.ci:163: referenced as `div`
	lib/std/math/Complex.ci:161: referenced as `div`
	lib/std/math/Complex.ci:106: referenced as `div`
	lib/std/math/Complex.ci:104: referenced as `div`
	lib/std/math/Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math/Complex.ci:104'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: div(a, Complex(b))
.usages:
	lib/std/math/Complex.ci:168: referenced as `div`
	lib/std/math/Complex.ci:166: referenced as `div`
	lib/std/math/Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math/Complex.ci:106'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.doc: '@public'
.value: div(Complex(a), b)
.usages:
	lib/std/math/Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'lib/std/math/Complex.ci:109'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(a.re * a.re + a.im * a.im)
.usages:
	lib/std/math/Complex.ci:186: referenced as `abs`
	lib/std/math/Complex.ci:133: referenced as `abs`
	lib/std/math/Complex.ci:129: referenced as `abs`
	lib/std/math/Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'lib/std/math/Complex.ci:111'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.atan2(a.re, a.im)
.usages:
	lib/std/math/Complex.ci:186: referenced as `arg`
	lib/std/math/Complex.ci:134: referenced as `arg`
	lib/std/math/Complex.ci:129: referenced as `arg`
	lib/std/math/Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.name: 'inv'
.file: 'lib/std/math/Complex.ci:114'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (a.re * a.re + a.im * a.im);
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	lib/std/math/Complex.ci:115: (11 bytes): d: float64 := (a.re * a.re + a.im * a.im)
	<inv>  : dup.x64 sp(1)
	<inv+?>: dup.x64 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x64 sp(5)
	<inv+?>: dup.x64 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	lib/std/math/Complex.ci:116: (20 bytes): return .result := {...};
	<inv+?>: dup.x64 sp(3)
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(9)
	lib/std/math/Complex.ci:118: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x64 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	lib/std/math/Complex.ci:181: referenced as `inv`
	lib/std/math/Complex.ci:179: referenced as `inv`
	lib/std/math/Complex.ci:177: referenced as `inv`
	lib/std/math/Complex.ci:175: referenced as `inv`
	lib/std/math/Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'lib/std/math/Complex.ci:123'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re, -a.im)
.usages:
	lib/std/math/Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'lib/std/math/Complex.ci:126'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
.usages:
	lib/std/math/Complex.ci:172: referenced as `exp`
	lib/std/math/Complex.ci:172: referenced as `exp`
	lib/std/math/Complex.ci:170: referenced as `exp`
	lib/std/math/Complex.ci:170: referenced as `exp`
	lib/std/math/Complex.ci:168: referenced as `exp`
	lib/std/math/Complex.ci:168: referenced as `exp`
	lib/std/math/Complex.ci:166: referenced as `exp`
	lib/std/math/Complex.ci:166: referenced as `exp`
	lib/std/math/Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'lib/std/math/Complex.ci:129'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.log(abs(a)), arg(a))
.usages:
	lib/std/math/Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.name: 'pow'
.file: 'lib/std/math/Complex.ci:132'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (100 bytes)
	lib/std/math/Complex.ci:133: (23 bytes): r: float64 := abs(a)
	<pow>  : dup.x128 sp(5)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(4)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: nfc(46) ;float64.sqrt(x: float64): float64
	<pow+?>: set.x64 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math/Complex.ci:134: (16 bytes): t: float64 := arg(a)
	<pow+?>: dup.x128 sp(7)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>: set.x64 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math/Complex.ci:135: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(9)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: nfc(43) ;float64.log(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: add.f64
	lib/std/math/Complex.ci:136: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: dup.x64 sp(9)
	<pow+?>: nfc(45) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: dup.x64 sp(11)
	<pow+?>: neg.f64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: mul.f64
	<pow+?>: nfc(44) ;float64.exp(x: float64): float64
	<pow+?>: mul.f64
	lib/std/math/Complex.ci:137: (27 bytes): return .result := {...};
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(41) ;float64.cos(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(19)
	lib/std/math/Complex.ci:139: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(40) ;float64.sin(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
.usages:
	lib/std/math/Complex.ci:143: referenced as `pow`
	lib/std/math/Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'lib/std/math/Complex.ci:143'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: pow(a, Complex(b))
.usages:
	lib/std/math/Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math/Complex.ci:146'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
.usages:
	lib/std/math/Complex.ci:177: referenced as `sin`
	lib/std/math/Complex.ci:163: referenced as `sin`
	lib/std/math/Complex.ci:161: referenced as `sin`
	lib/std/math/Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math/Complex.ci:148'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
.usages:
	lib/std/math/Complex.ci:175: referenced as `cos`
	lib/std/math/Complex.ci:163: referenced as `cos`
	lib/std/math/Complex.ci:161: referenced as `cos`
	lib/std/math/Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'lib/std/math/Complex.ci:161'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sin(a), cos(a))
.usages:
	lib/std/math/Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'lib/std/math/Complex.ci:163'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(cos(a), sin(a))
.usages:
	lib/std/math/Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'lib/std/math/Complex.ci:166'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(a), exp(neg(a))), 2)
.usages:
	lib/std/math/Complex.ci:181: referenced as `sinh`
	lib/std/math/Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'lib/std/math/Complex.ci:168'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(a), exp(neg(a))), 2)
.usages:
	lib/std/math/Complex.ci:179: referenced as `cosh`
	lib/std/math/Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'lib/std/math/Complex.ci:170'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
.usages:
	lib/std/math/Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'lib/std/math/Complex.ci:172'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
.usages:
	lib/std/math/Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'lib/std/math/Complex.ci:175'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math/Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'lib/std/math/Complex.ci:177'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math/Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'lib/std/math/Complex.ci:179'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math/Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'lib/std/math/Complex.ci:181'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math/Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'lib/std/math/Complex.ci:184'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
.usages:
	lib/std/math/Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'lib/std/math/Complex.ci:186'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(abs(x), arg(x))
.usages:
	lib/std/math/Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:2'
.field data: float32[4] (size: 16, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/gfxlib.ci:430: referenced as `vec4f`
	lib/gfxlib.ci:430: referenced as `vec4f`
	lib/gfxlib.ci:423: referenced as `vec4f`
	lib/gfxlib.ci:423: referenced as `vec4f`
	lib/gfxlib.ci:303: referenced as `vec4f`
	lib/gfxlib.ci:302: referenced as `vec4f`
	lib/gfxlib.ci:301: referenced as `vec4f`
	lib/gfxlib.ci:199: referenced as `vec4f`
	lib/gfxlib.ci:187: referenced as `vec4f`
	lib/gfxlib.ci:187: referenced as `vec4f`
	lib/gfx/color.ci:197: referenced as `vec4f`
	lib/gfx/color.ci:197: referenced as `vec4f`
	lib/gfx/color.ci:194: referenced as `vec4f`
	lib/gfx/color.ci:191: referenced as `vec4f`
	lib/gfx/color.ci:188: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:168: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:158: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:106: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:106: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:20: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:18: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:16: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:14: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:10: referenced as `vec4f`
	lib/std/math/Vector4f.ci:107: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:102: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: referenced as `vec4f`
	lib/std/math/Vector4f.ci:2: defined as `vec4f`
	internal usages: 4
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'lib/std/math/Vector4f.ci:4'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/gfxlib.ci:304: referenced as `data`
	lib/gfxlib.ci:304: referenced as `data`
	lib/gfxlib.ci:304: referenced as `data`
	lib/std/math/Vector4f.ci:4: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.name: '<?>'
.file: 'lib/std/math/Vector4f.ci:108'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
.usages:
	lib/std/math/Vector4f.ci:108: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/gfxlib.ci:303: referenced as `x`
	lib/gfxlib.ci:302: referenced as `x`
	lib/gfxlib.ci:301: referenced as `x`
	lib/gfxlib.ci:210: referenced as `x`
	lib/gfxlib.ci:200: referenced as `x`
	lib/gfxlib.ci:91: referenced as `x`
	lib/gfxlib.ci:90: referenced as `x`
	lib/gfxlib.ci:89: referenced as `x`
	lib/gfxlib.ci:88: referenced as `x`
	lib/gfx/color.ci:198: referenced as `x`
	lib/gfx/color.ci:194: referenced as `x`
	lib/gfx/color.ci:191: referenced as `x`
	lib/std/math/Matrix4f.ci:174: referenced as `x`
	lib/std/math/Matrix4f.ci:173: referenced as `x`
	lib/std/math/Matrix4f.ci:172: referenced as `x`
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:163: referenced as `x`
	lib/std/math/Matrix4f.ci:162: referenced as `x`
	lib/std/math/Matrix4f.ci:161: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:120: referenced as `x`
	lib/std/math/Matrix4f.ci:117: referenced as `x`
	lib/std/math/Matrix4f.ci:92: referenced as `x`
	lib/std/math/Matrix4f.ci:91: referenced as `x`
	lib/std/math/Matrix4f.ci:90: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:70: referenced as `x`
	lib/std/math/Matrix4f.ci:69: referenced as `x`
	lib/std/math/Matrix4f.ci:68: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Vector4f.ci:107: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:37: referenced as `x`
	lib/std/math/Vector4f.ci:27: referenced as `x`
	lib/std/math/Vector4f.ci:7: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/gfxlib.ci:303: referenced as `y`
	lib/gfxlib.ci:302: referenced as `y`
	lib/gfxlib.ci:301: referenced as `y`
	lib/gfxlib.ci:208: referenced as `y`
	lib/gfxlib.ci:201: referenced as `y`
	lib/gfxlib.ci:91: referenced as `y`
	lib/gfxlib.ci:90: referenced as `y`
	lib/gfxlib.ci:89: referenced as `y`
	lib/gfxlib.ci:88: referenced as `y`
	lib/gfx/color.ci:199: referenced as `y`
	lib/gfx/color.ci:194: referenced as `y`
	lib/gfx/color.ci:191: referenced as `y`
	lib/std/math/Matrix4f.ci:174: referenced as `y`
	lib/std/math/Matrix4f.ci:173: referenced as `y`
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:171: referenced as `y`
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:163: referenced as `y`
	lib/std/math/Matrix4f.ci:162: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:160: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:121: referenced as `y`
	lib/std/math/Matrix4f.ci:118: referenced as `y`
	lib/std/math/Matrix4f.ci:92: referenced as `y`
	lib/std/math/Matrix4f.ci:91: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:89: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:70: referenced as `y`
	lib/std/math/Matrix4f.ci:69: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:67: referenced as `y`
	lib/std/math/Vector4f.ci:107: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:37: referenced as `y`
	lib/std/math/Vector4f.ci:27: referenced as `y`
	lib/std/math/Vector4f.ci:9: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/gfxlib.ci:303: referenced as `z`
	lib/gfxlib.ci:302: referenced as `z`
	lib/gfxlib.ci:301: referenced as `z`
	lib/gfxlib.ci:202: referenced as `z`
	lib/gfxlib.ci:91: referenced as `z`
	lib/gfxlib.ci:90: referenced as `z`
	lib/gfxlib.ci:89: referenced as `z`
	lib/gfxlib.ci:88: referenced as `z`
	lib/gfx/color.ci:200: referenced as `z`
	lib/gfx/color.ci:194: referenced as `z`
	lib/gfx/color.ci:191: referenced as `z`
	lib/std/math/Matrix4f.ci:174: referenced as `z`
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:172: referenced as `z`
	lib/std/math/Matrix4f.ci:171: referenced as `z`
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:163: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:161: referenced as `z`
	lib/std/math/Matrix4f.ci:160: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:122: referenced as `z`
	lib/std/math/Matrix4f.ci:119: referenced as `z`
	lib/std/math/Matrix4f.ci:92: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:90: referenced as `z`
	lib/std/math/Matrix4f.ci:89: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:70: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:68: referenced as `z`
	lib/std/math/Matrix4f.ci:67: referenced as `z`
	lib/std/math/Vector4f.ci:107: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:37: referenced as `z`
	lib/std/math/Vector4f.ci:27: referenced as `z`
	lib/std/math/Vector4f.ci:11: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/gfxlib.ci:303: referenced as `w`
	lib/gfxlib.ci:302: referenced as `w`
	lib/gfxlib.ci:301: referenced as `w`
	lib/gfxlib.ci:203: referenced as `w`
	lib/gfxlib.ci:91: referenced as `w`
	lib/gfxlib.ci:90: referenced as `w`
	lib/gfxlib.ci:89: referenced as `w`
	lib/gfxlib.ci:88: referenced as `w`
	lib/std/math/Matrix4f.ci:174: referenced as `w`
	lib/std/math/Matrix4f.ci:173: referenced as `w`
	lib/std/math/Matrix4f.ci:172: referenced as `w`
	lib/std/math/Matrix4f.ci:171: referenced as `w`
	lib/std/math/Matrix4f.ci:163: referenced as `w`
	lib/std/math/Matrix4f.ci:162: referenced as `w`
	lib/std/math/Matrix4f.ci:161: referenced as `w`
	lib/std/math/Matrix4f.ci:160: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:91: referenced as `w`
	lib/std/math/Matrix4f.ci:90: referenced as `w`
	lib/std/math/Matrix4f.ci:89: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:69: referenced as `w`
	lib/std/math/Matrix4f.ci:68: referenced as `w`
	lib/std/math/Matrix4f.ci:67: referenced as `w`
	lib/std/math/Vector4f.ci:107: referenced as `w`
	lib/std/math/Vector4f.ci:27: referenced as `w`
	lib/std/math/Vector4f.ci:13: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.param w: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (13 bytes)
	lib/std/math/Vector4f.ci:27: (13 bytes): return .result := {...};
	<vec4f>  : mov.x32 sp(5, 4)
	lib/std/math/Vector4f.ci:27: (3 bytes): .result.y := y;
	<vec4f+?>: mov.x32 sp(6, 3)
	lib/std/math/Vector4f.ci:27: (3 bytes): .result.z := z;
	<vec4f+?>: mov.x32 sp(7, 2)
	lib/std/math/Vector4f.ci:27: (3 bytes): .result.w := w;
	<vec4f+?>: mov.x32 sp(8, 1)
	<vec4f+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:150: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:114: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:113: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:112: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:34: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:31'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(x, y, z, 1.000000)
.usages:
	lib/gfx/color.ci:231: referenced as `vec4f`
	lib/gfx/color.ci:229: referenced as `vec4f`
	lib/gfx/color.ci:226: referenced as `vec4f`
	lib/gfx/color.ci:223: referenced as `vec4f`
	lib/gfx/color.ci:220: referenced as `vec4f`
	lib/gfx/color.ci:217: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:34'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(x, y, 0.000000, 1.000000)
.usages:
	lib/std/math/Vector4f.ci:34: defined as `vec4f(x: float32, y: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:37'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
.usages:
	lib/std/math/Vector4f.ci:37: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:40'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(val, val, val, val)
.usages:
	lib/gfx/color.ci:203: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/std/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(struct(rhs), neg.p4f))
.usages:
	lib/std/math/Vector4f.ci:71: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
.usages:
	lib/std/math/Vector4f.ci:73: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
.usages:
	lib/std/math/Vector4f.ci:75: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
.usages:
	lib/std/math/Vector4f.ci:77: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math/Vector4f.ci:79'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
.usages:
	lib/std/math/Vector4f.ci:104: referenced as `div`
	lib/std/math/Vector4f.ci:79: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'lib/std/math/Vector4f.ci:82'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(struct(lhs), struct(rhs), min.p4f))
.usages:
	lib/std/math/Vector4f.ci:82: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'lib/std/math/Vector4f.ci:84'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(struct(lhs), struct(rhs), max.p4f))
.usages:
	lib/std/math/Vector4f.ci:84: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/std/math/Vector4f.ci:88'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp3))
.usages:
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Vector4f.ci:102: referenced as `dp3`
	lib/std/math/Vector4f.ci:88: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/std/math/Vector4f.ci:92'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dph))
.usages:
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Vector4f.ci:92: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/std/math/Vector4f.ci:96'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp4))
.usages:
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Vector4f.ci:96: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'lib/std/math/Vector4f.ci:99'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
.usages:
	lib/std/math/Vector4f.ci:99: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
length(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'length'
.file: 'lib/std/math/Vector4f.ci:102'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(v, v))
.usages:
	lib/std/math/Matrix4f.ci:107: referenced as `length`
	lib/std/math/Vector4f.ci:104: referenced as `length`
	lib/std/math/Vector4f.ci:102: defined as `length(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'lib/std/math/Vector4f.ci:104'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(v, vec4f(length(v)))
.usages:
	lib/std/math/Vector4f.ci:104: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math/Vector4f.ci:107'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
.usages:
	lib/std/math/Vector4f.ci:107: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:2'
.field data: float32[16] (size: 64, cast: variable(val))
.field m: float32[4][4] (size: 64, cast: variable(val))
.field v: vec4f[4] (size: 64, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field xx: float32 (size: 0, cast: inline)
.field xy: float32 (size: 0, cast: inline)
.field xz: float32 (size: 0, cast: inline)
.field xw: float32 (size: 0, cast: inline)
.field yx: float32 (size: 0, cast: inline)
.field yy: float32 (size: 0, cast: inline)
.field yz: float32 (size: 0, cast: inline)
.field yw: float32 (size: 0, cast: inline)
.field zx: float32 (size: 0, cast: inline)
.field zy: float32 (size: 0, cast: inline)
.field zz: float32 (size: 0, cast: inline)
.field zw: float32 (size: 0, cast: inline)
.field wx: float32 (size: 0, cast: inline)
.field wy: float32 (size: 0, cast: inline)
.field wz: float32 (size: 0, cast: inline)
.field ww: float32 (size: 0, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/gfxlib.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:168: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:158: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:106: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:88: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:84: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:82: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:80: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:75: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:62: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:2: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'lib/std/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/gfxlib.ci:94: referenced as `data`
	lib/std/math/Matrix4f.ci:4: defined as `data`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.name: 'm'
.file: 'lib/std/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:7: defined as `m`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.name: 'v'
.file: 'lib/std/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:10: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:177'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
.usages:
	lib/std/math/Matrix4f.ci:177: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/gfxlib.ci:88: referenced as `x`
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:111: referenced as `x`
	lib/std/math/Matrix4f.ci:95: referenced as `x`
	lib/std/math/Matrix4f.ci:95: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:92: referenced as `x`
	lib/std/math/Matrix4f.ci:91: referenced as `x`
	lib/std/math/Matrix4f.ci:90: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:84: referenced as `x`
	lib/std/math/Matrix4f.ci:82: referenced as `x`
	lib/std/math/Matrix4f.ci:80: referenced as `x`
	lib/std/math/Matrix4f.ci:76: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Matrix4f.ci:14: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/gfxlib.ci:89: referenced as `y`
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:112: referenced as `y`
	lib/std/math/Matrix4f.ci:96: referenced as `y`
	lib/std/math/Matrix4f.ci:96: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:92: referenced as `y`
	lib/std/math/Matrix4f.ci:91: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:89: referenced as `y`
	lib/std/math/Matrix4f.ci:84: referenced as `y`
	lib/std/math/Matrix4f.ci:82: referenced as `y`
	lib/std/math/Matrix4f.ci:80: referenced as `y`
	lib/std/math/Matrix4f.ci:76: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:16: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/gfxlib.ci:90: referenced as `z`
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:113: referenced as `z`
	lib/std/math/Matrix4f.ci:97: referenced as `z`
	lib/std/math/Matrix4f.ci:97: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:92: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:90: referenced as `z`
	lib/std/math/Matrix4f.ci:89: referenced as `z`
	lib/std/math/Matrix4f.ci:84: referenced as `z`
	lib/std/math/Matrix4f.ci:82: referenced as `z`
	lib/std/math/Matrix4f.ci:80: referenced as `z`
	lib/std/math/Matrix4f.ci:76: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:18: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/gfxlib.ci:91: referenced as `w`
	lib/std/math/Matrix4f.ci:174: referenced as `w`
	lib/std/math/Matrix4f.ci:163: referenced as `w`
	lib/std/math/Matrix4f.ci:150: referenced as `w`
	lib/std/math/Matrix4f.ci:114: referenced as `w`
	lib/std/math/Matrix4f.ci:98: referenced as `w`
	lib/std/math/Matrix4f.ci:98: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:91: referenced as `w`
	lib/std/math/Matrix4f.ci:90: referenced as `w`
	lib/std/math/Matrix4f.ci:89: referenced as `w`
	lib/std/math/Matrix4f.ci:84: referenced as `w`
	lib/std/math/Matrix4f.ci:82: referenced as `w`
	lib/std/math/Matrix4f.ci:76: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:20: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:177'
.owner: mat4f
.field xx: float32 (size: 4, cast: variable(f32))
.field xy: float32 (size: 4, cast: variable(f32))
.field xz: float32 (size: 4, cast: variable(f32))
.field xw: float32 (size: 4, cast: variable(f32))
.field yx: float32 (size: 4, cast: variable(f32))
.field yy: float32 (size: 4, cast: variable(f32))
.field yz: float32 (size: 4, cast: variable(f32))
.field yw: float32 (size: 4, cast: variable(f32))
.field zx: float32 (size: 4, cast: variable(f32))
.field zy: float32 (size: 4, cast: variable(f32))
.field zz: float32 (size: 4, cast: variable(f32))
.field zw: float32 (size: 4, cast: variable(f32))
.field wx: float32 (size: 4, cast: variable(f32))
.field wy: float32 (size: 4, cast: variable(f32))
.field wz: float32 (size: 4, cast: variable(f32))
.field ww: float32 (size: 4, cast: variable(f32))
.usages:
	lib/std/math/Matrix4f.ci:177: defined as `<?>`
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:135: referenced as `xx`
	lib/std/math/Matrix4f.ci:24: defined as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:136: referenced as `xy`
	lib/std/math/Matrix4f.ci:26: defined as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:137: referenced as `xz`
	lib/std/math/Matrix4f.ci:28: defined as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:138: referenced as `xw`
	lib/std/math/Matrix4f.ci:30: defined as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:140: referenced as `yx`
	lib/std/math/Matrix4f.ci:33: defined as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:141: referenced as `yy`
	lib/std/math/Matrix4f.ci:35: defined as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:142: referenced as `yz`
	lib/std/math/Matrix4f.ci:37: defined as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:143: referenced as `yw`
	lib/std/math/Matrix4f.ci:39: defined as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:145: referenced as `zx`
	lib/std/math/Matrix4f.ci:42: defined as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:146: referenced as `zy`
	lib/std/math/Matrix4f.ci:44: defined as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:147: referenced as `zz`
	lib/std/math/Matrix4f.ci:46: defined as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:148: referenced as `zw`
	lib/std/math/Matrix4f.ci:48: defined as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:51: defined as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:53: defined as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:55: defined as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:57: defined as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
}
.instructions: (49 bytes)
	lib/std/math/Matrix4f.ci:66: (49 bytes): return .result := {...};
	<mat4f>  : mov.x32 sp(17, 16)
	lib/std/math/Matrix4f.ci:67: (3 bytes): .result.x.y := xy;
	<mat4f+?>: mov.x32 sp(18, 15)
	lib/std/math/Matrix4f.ci:67: (3 bytes): .result.x.z := xz;
	<mat4f+?>: mov.x32 sp(19, 14)
	lib/std/math/Matrix4f.ci:67: (3 bytes): .result.x.w := xw;
	<mat4f+?>: mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:68: (3 bytes): .result.y.x := yx;
	<mat4f+?>: mov.x32 sp(21, 12)
	lib/std/math/Matrix4f.ci:68: (3 bytes): .result.y.y := yy;
	<mat4f+?>: mov.x32 sp(22, 11)
	lib/std/math/Matrix4f.ci:68: (3 bytes): .result.y.z := yz;
	<mat4f+?>: mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:68: (3 bytes): .result.y.w := yw;
	<mat4f+?>: mov.x32 sp(24, 9)
	lib/std/math/Matrix4f.ci:69: (3 bytes): .result.z.x := zx;
	<mat4f+?>: mov.x32 sp(25, 8)
	lib/std/math/Matrix4f.ci:69: (3 bytes): .result.z.y := zy;
	<mat4f+?>: mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:69: (3 bytes): .result.z.z := zz;
	<mat4f+?>: mov.x32 sp(27, 6)
	lib/std/math/Matrix4f.ci:69: (3 bytes): .result.z.w := zw;
	<mat4f+?>: mov.x32 sp(28, 5)
	lib/std/math/Matrix4f.ci:70: (3 bytes): .result.w.x := wx;
	<mat4f+?>: mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:70: (3 bytes): .result.w.y := wy;
	<mat4f+?>: mov.x32 sp(30, 3)
	lib/std/math/Matrix4f.ci:70: (3 bytes): .result.w.z := wz;
	<mat4f+?>: mov.x32 sp(31, 2)
	lib/std/math/Matrix4f.ci:70: (3 bytes): .result.w.w := ww;
	<mat4f+?>: mov.x32 sp(32, 1)
	<mat4f+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:62: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	lib/std/math/Matrix4f.ci:76: (21 bytes): return .result := {...};
	<mat4f>  : dup.x32 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(9)
	lib/std/math/Matrix4f.ci:76: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x32 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(13)
	lib/std/math/Matrix4f.ci:76: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x32 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(17)
	lib/std/math/Matrix4f.ci:76: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x32 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(21)
	<mat4f+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:75: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/std/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
.usages:
	lib/std/math/Matrix4f.ci:80: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/std/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
.usages:
	lib/std/math/Matrix4f.ci:82: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/std/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
.usages:
	lib/std/math/Matrix4f.ci:98: referenced as `dp4`
	lib/std/math/Matrix4f.ci:97: referenced as `dp4`
	lib/std/math/Matrix4f.ci:96: referenced as `dp4`
	lib/std/math/Matrix4f.ci:95: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.name: 'mul'
.file: 'lib/std/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		transposed.x.x := rhs.x.x;
		transposed.x.y := rhs.y.x;
		transposed.x.z := rhs.z.x;
		transposed.x.w := rhs.w.x;
		transposed.y.x := rhs.x.y;
		transposed.y.y := rhs.y.y;
		transposed.y.z := rhs.z.y;
		transposed.y.w := rhs.w.y;
		transposed.z.x := rhs.x.z;
		transposed.z.y := rhs.y.z;
		transposed.z.z := rhs.z.z;
		transposed.z.w := rhs.w.z;
		transposed.w.x := rhs.x.w;
		transposed.w.y := rhs.y.w;
		transposed.w.z := rhs.z.w;
		transposed.w.w := rhs.w.w;
	};
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (417 bytes)
	lib/std/math/Matrix4f.ci:88: (144 bytes): transposed: mat4f := {...}
	<mul>  : inc.sp(+64)
	lib/std/math/Matrix4f.ci:89: (5 bytes): transposed.x.x := rhs.x.x;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(1)
	lib/std/math/Matrix4f.ci:89: (9 bytes): transposed.x.y := rhs.y.x;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(2)
	lib/std/math/Matrix4f.ci:89: (9 bytes): transposed.x.z := rhs.z.x;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(3)
	lib/std/math/Matrix4f.ci:89: (9 bytes): transposed.x.w := rhs.w.x;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(4)
	lib/std/math/Matrix4f.ci:90: (9 bytes): transposed.y.x := rhs.x.y;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+4)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(5)
	lib/std/math/Matrix4f.ci:90: (9 bytes): transposed.y.y := rhs.y.y;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+20)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(6)
	lib/std/math/Matrix4f.ci:90: (9 bytes): transposed.y.z := rhs.z.y;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+36)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(7)
	lib/std/math/Matrix4f.ci:90: (9 bytes): transposed.y.w := rhs.w.y;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+52)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(8)
	lib/std/math/Matrix4f.ci:91: (9 bytes): transposed.z.x := rhs.x.z;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(9)
	lib/std/math/Matrix4f.ci:91: (9 bytes): transposed.z.y := rhs.y.z;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+24)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(10)
	lib/std/math/Matrix4f.ci:91: (9 bytes): transposed.z.z := rhs.z.z;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+40)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(11)
	lib/std/math/Matrix4f.ci:91: (9 bytes): transposed.z.w := rhs.w.z;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+56)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(12)
	lib/std/math/Matrix4f.ci:92: (9 bytes): transposed.w.x := rhs.x.w;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+12)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(13)
	lib/std/math/Matrix4f.ci:92: (9 bytes): transposed.w.y := rhs.y.w;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+28)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(14)
	lib/std/math/Matrix4f.ci:92: (9 bytes): transposed.w.z := rhs.z.w;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+44)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(15)
	lib/std/math/Matrix4f.ci:92: (9 bytes): transposed.w.w := rhs.w.w;
	<mul+?>: dup.x32 sp(17)
	<mul+?>: inc.i32(+60)
	<mul+?>: load.i32
	<mul+?>: set.x32 sp(16)
	lib/std/math/Matrix4f.ci:94: (273 bytes): return .result := {...};
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(8)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(6)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(7)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(10)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(8)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(11)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(23)
	lib/std/math/Matrix4f.ci:96: (68 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(8)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(6)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(7)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(10)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(8)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(11)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(27)
	lib/std/math/Matrix4f.ci:97: (68 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(8)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(6)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(7)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(10)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(8)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(11)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(31)
	lib/std/math/Matrix4f.ci:98: (68 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(8)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(6)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(7)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(10)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(8)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(11)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:87: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 524
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:106'
.param .result: mat4f (size: 64, cast: variable(val))
.param center: vec4f (size: 4, cast: const variable(ref))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if ((len) < 0.000000) {
		trace("invalid direction of rotation", direction);
		return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
	}
	x: float32 := direction.x / len;
	y: float32 := direction.y / len;
	z: float32 := direction.z / len;
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := x * x;
	xy: float32 := x * y;
	xz: float32 := x * z;
	yy: float32 := y * y;
	yz: float32 := y * z;
	zz: float32 := z * z;
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := (1) - c;
	return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (524 bytes)
	lib/std/math/Matrix4f.ci:107: (18 bytes): len: float32 := length(direction)
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i128
	<rotation+?>: dup.x128 sp(0)
	<rotation+?>: dup.x128 sp(4)
	<rotation+?>: dp3.v4f
	<rotation+?>: nfc(38) ;float32.sqrt(x: float32): float32
	<rotation+?>: set.x32 sp(4)
	<rotation+?>: inc.sp(-12)
	lib/std/math/Matrix4f.ci:108: (138 bytes): if ((len) < 0.000000)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: f32.2f64
	<rotation+?>: load.f64 0.000000
	<rotation+?>: clt.f64
	<rotation+?>: jz +125
	lib/std/math/Matrix4f.ci:109: (36 bytes): trace("invalid direction of rotation", direction);
	<rotation+?>: load.ref <?> ;"lib/std/math/Matrix4f.ci"
	<rotation+?>: load.c32 109
	<rotation+?>: load.c32 14
	<rotation+?>: load.c32 128
	<rotation+?>: load.ref <?> ;"invalid direction of rotation"
	<rotation+?>: load.ref <?> ;vec4f
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/math/Matrix4f.ci:110: (85 bytes): return .result := {...};
	<rotation+?>: inc.sp(+16)
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+?>: call
	<rotation+?>: inc.sp(-16)
	<rotation+?>: set.x128 sp(9)
	lib/std/math/Matrix4f.ci:112: (20 bytes): .result.y := vec4f(0, 0, 0, 0);
	<rotation+?>: inc.sp(+16)
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+?>: call
	<rotation+?>: inc.sp(-16)
	<rotation+?>: set.x128 sp(13)
	lib/std/math/Matrix4f.ci:113: (20 bytes): .result.z := vec4f(0, 0, 0, 0);
	<rotation+?>: inc.sp(+16)
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+?>: call
	<rotation+?>: inc.sp(-16)
	<rotation+?>: set.x128 sp(17)
	lib/std/math/Matrix4f.ci:114: (20 bytes): .result.w := vec4f(0, 0, 0, 0);
	<rotation+?>: inc.sp(+16)
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+?>: call
	<rotation+?>: inc.sp(-16)
	<rotation+?>: set.x128 sp(21)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: ret
	lib/std/math/Matrix4f.ci:117: (6 bytes): x: float32 := direction.x / len
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: div.f32
	lib/std/math/Matrix4f.ci:118: (10 bytes): y: float32 := direction.y / len
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: div.f32
	lib/std/math/Matrix4f.ci:119: (10 bytes): z: float32 := direction.z / len
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: div.f32
	lib/std/math/Matrix4f.ci:120: (3 bytes): cx: float32 := center.x
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: load.i32
	lib/std/math/Matrix4f.ci:121: (7 bytes): cy: float32 := center.y
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	lib/std/math/Matrix4f.ci:122: (7 bytes): cz: float32 := center.z
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	lib/std/math/Matrix4f.ci:123: (5 bytes): xx: float32 := x * x
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:124: (5 bytes): xy: float32 := x * y
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:125: (5 bytes): xz: float32 := x * z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:126: (5 bytes): yy: float32 := y * y
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:127: (5 bytes): yz: float32 := y * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:128: (5 bytes): zz: float32 := z * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	lib/std/math/Matrix4f.ci:130: (6 bytes): s: float32 := float32.sin(angle)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: nfc(32) ;float32.sin(x: float32): float32
	lib/std/math/Matrix4f.ci:131: (6 bytes): c: float32 := float32.cos(angle)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: nfc(33) ;float32.cos(x: float32): float32
	lib/std/math/Matrix4f.ci:132: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	lib/std/math/Matrix4f.ci:134: (275 bytes): return .result := {...};
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	lib/std/math/Matrix4f.ci:136: (13 bytes): .result.xy := xy * k - z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(22)
	lib/std/math/Matrix4f.ci:137: (13 bytes): .result.xz := xz * k + y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(23)
	lib/std/math/Matrix4f.ci:138: (43 bytes): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(24)
	lib/std/math/Matrix4f.ci:140: (13 bytes): .result.yx := xy * k + z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(25)
	lib/std/math/Matrix4f.ci:141: (13 bytes): .result.yy := yy + (xx + zz) * c;
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	lib/std/math/Matrix4f.ci:142: (13 bytes): .result.yz := yz * k - x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(27)
	lib/std/math/Matrix4f.ci:143: (43 bytes): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(28)
	lib/std/math/Matrix4f.ci:145: (13 bytes): .result.zx := xz * k - y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(29)
	lib/std/math/Matrix4f.ci:146: (13 bytes): .result.zy := yz * k + x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(30)
	lib/std/math/Matrix4f.ci:147: (13 bytes): .result.zz := zz + (xx + yy) * c;
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(31)
	lib/std/math/Matrix4f.ci:148: (43 bytes): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(32)
	lib/std/math/Matrix4f.ci:150: (24 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: inc.sp(+16)
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+?>: call
	<rotation+?>: inc.sp(-16)
	<rotation+?>: set.x128 sp(36)
	<rotation+?>: inc.sp(-64)
	<rotation+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `rotation`
	lib/std/math/Matrix4f.ci:106: defined as `rotation(center: vec4f, direction: vec4f, angle: float32): mat4f`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:155'
.param .result: mat4f (size: 64, cast: val)
.param direction: vec4f (size: 4, cast: const ref)
.param angle: float32 (size: 4, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(vec4f(0), direction, angle)
.usages:
	lib/std/math/Matrix4f.ci:155: defined as `rotation(direction: vec4f, angle: float32): mat4f`
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 88
.name: 'translation'
.file: 'lib/std/math/Matrix4f.ci:158'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return .result := {
			.result.x.x := (1);
			.result.x.y := (0);
			.result.x.z := (0);
			.result.x.w := direction.x * amount;
			.result.y.x := (0);
			.result.y.y := (1);
			.result.y.z := (0);
			.result.y.w := direction.y * amount;
			.result.z.x := (0);
			.result.z.y := (0);
			.result.z.z := (1);
			.result.z.w := direction.z * amount;
			.result.w.x := (0);
			.result.w.y := (0);
			.result.w.z := (0);
			.result.w.w := (1);
		};
}
.instructions: (88 bytes)
	lib/std/math/Matrix4f.ci:159: (88 bytes): return .result := {...};
	<translation>  : load.f32 1.000000
	<translation+?>: set.x32 sp(4)
	lib/std/math/Matrix4f.ci:160: (3 bytes): .result.x.y := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(5)
	lib/std/math/Matrix4f.ci:160: (3 bytes): .result.x.z := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(6)
	lib/std/math/Matrix4f.ci:160: (8 bytes): .result.x.w := direction.x * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(7)
	lib/std/math/Matrix4f.ci:161: (3 bytes): .result.y.x := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(8)
	lib/std/math/Matrix4f.ci:161: (7 bytes): .result.y.y := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(9)
	lib/std/math/Matrix4f.ci:161: (3 bytes): .result.y.z := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(10)
	lib/std/math/Matrix4f.ci:161: (12 bytes): .result.y.w := direction.y * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+4)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(11)
	lib/std/math/Matrix4f.ci:162: (3 bytes): .result.z.x := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(12)
	lib/std/math/Matrix4f.ci:162: (3 bytes): .result.z.y := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(13)
	lib/std/math/Matrix4f.ci:162: (7 bytes): .result.z.z := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(14)
	lib/std/math/Matrix4f.ci:162: (12 bytes): .result.z.w := direction.z * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+8)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(15)
	lib/std/math/Matrix4f.ci:163: (3 bytes): .result.w.x := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(16)
	lib/std/math/Matrix4f.ci:163: (3 bytes): .result.w.y := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(17)
	lib/std/math/Matrix4f.ci:163: (3 bytes): .result.w.z := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(18)
	lib/std/math/Matrix4f.ci:163: (7 bytes): .result.w.w := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(19)
	<translation+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:158: defined as `translation(direction: vec4f, amount: float32): mat4f`
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 217
.name: 'scale'
.file: 'lib/std/math/Matrix4f.ci:168'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
	return .result := {
			.result.x.x := rcp(direction.x * amount);
			.result.x.y := (0);
			.result.x.z := (0);
			.result.x.w := (0);
			.result.y.x := (0);
			.result.y.y := rcp(direction.y * amount);
			.result.y.z := (0);
			.result.y.w := (0);
			.result.z.x := (0);
			.result.z.y := (0);
			.result.z.z := rcp(direction.z * amount);
			.result.z.w := (0);
			.result.w.x := (0);
			.result.w.y := (0);
			.result.w.z := (0);
			.result.w.w := (1);
		};
}
.instructions: (217 bytes)
	lib/std/math/Matrix4f.ci:170: (217 bytes): return .result := {...};
	<scale>  : dup.x32 sp(2)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(4)
	lib/std/math/Matrix4f.ci:171: (3 bytes): .result.x.y := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(5)
	lib/std/math/Matrix4f.ci:171: (3 bytes): .result.x.z := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(6)
	lib/std/math/Matrix4f.ci:171: (3 bytes): .result.x.w := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(7)
	lib/std/math/Matrix4f.ci:172: (3 bytes): .result.y.x := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(8)
	lib/std/math/Matrix4f.ci:172: (59 bytes): .result.y.y := rcp(direction.y * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+4)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(9)
	lib/std/math/Matrix4f.ci:172: (3 bytes): .result.y.z := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(10)
	lib/std/math/Matrix4f.ci:172: (3 bytes): .result.y.w := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(11)
	lib/std/math/Matrix4f.ci:173: (3 bytes): .result.z.x := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(12)
	lib/std/math/Matrix4f.ci:173: (3 bytes): .result.z.y := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(13)
	lib/std/math/Matrix4f.ci:173: (59 bytes): .result.z.z := rcp(direction.z * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+8)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(14)
	lib/std/math/Matrix4f.ci:173: (3 bytes): .result.z.w := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(15)
	lib/std/math/Matrix4f.ci:174: (3 bytes): .result.w.x := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(16)
	lib/std/math/Matrix4f.ci:174: (3 bytes): .result.w.y := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(17)
	lib/std/math/Matrix4f.ci:174: (3 bytes): .result.w.z := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(18)
	lib/std/math/Matrix4f.ci:174: (7 bytes): .result.w.w := (1);
	<scale+?>: load.f32 1.000000
	<scale+?>: set.x32 sp(19)
	<scale+?>: ret
.usages:
	lib/std/math/Matrix4f.ci:168: defined as `scale(direction: vec4f, amount: float32): mat4f`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:2'
.field data: float64[2] (size: 16, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, cast: variable(val))
.field x: float64 (size: 0, cast: inline)
.field y: float64 (size: 0, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:14: referenced as `vec2d`
	lib/std/math/Vector2d.ci:2: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.name: 'data'
.file: 'lib/std/math/Vector2d.ci:4'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/std/math/Vector2d.ci:4: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.name: '<?>'
.file: 'lib/std/math/Vector2d.ci:26'
.owner: vec2d
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
.usages:
	lib/std/math/Vector2d.ci:26: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `x`
	lib/std/math/Vector2d.ci:25: referenced as `x`
	lib/std/math/Vector2d.ci:16: referenced as `x`
	lib/std/math/Vector2d.ci:7: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `y`
	lib/std/math/Vector2d.ci:25: referenced as `y`
	lib/std/math/Vector2d.ci:17: referenced as `y`
	lib/std/math/Vector2d.ci:9: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	lib/std/math/Vector2d.ci:15: (7 bytes): return .result := {...};
	<vec2d>  : mov.x64 sp(5, 3)
	lib/std/math/Vector2d.ci:17: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x64 sp(7, 1)
	<vec2d+?>: ret
.usages:
	lib/std/math/Vector2d.ci:14: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
.usages:
	lib/std/math/Vector2d.ci:22: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'lib/std/math/Vector2d.ci:25'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.doc: 'Dot product'
.value: a.x * b.x + a.y * b.y
.usages:
	lib/std/math/Vector2d.ci:25: defined as `dot(a: vec2d, b: vec2d): float64`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	lib/std/string.ci:5: (16 bytes): if ((str) == null)
	<length>  : dup.x32 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	lib/std/string.ci:6: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x32 sp(3)
	<length+?>: ret
	lib/std/string.ci:8: (1 byte): result: int32 := 0
	<length+?>: load.z32
	lib/std/string.ci:9: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	lib/std/string.ci:9: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	lib/std/string.ci:9: (10 bytes): str[result]
	<length+?>: dup.x32 sp(2)
	<length+?>: dup.x32 sp(1)
	<length+?>: add.i32
	<length+?>: load.i8
	<length+?>: jnz -10
	lib/std/string.ci:11: (3 bytes): return .result := result;
	<length+?>: set.x32 sp(3)
	<length+?>: ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	lib/std/string.ci:16: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	lib/std/string.ci:17: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.i8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	lib/std/string.ci:18: (3 bytes): return .result := i;
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
	lib/std/string.ci:16: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	lib/std/string.ci:16: (10 bytes): str[i]
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	lib/std/string.ci:21: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	lib/std/string.ci:26: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	lib/std/string.ci:27: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	lib/std/string.ci:28: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	lib/std/string.ci:29: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	lib/std/string.ci:27: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	lib/std/string.ci:32: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x32 sp(4)
	<lastIndexOf+?>: ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	lib/std/string.ci:37: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	lib/std/string.ci:38: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	lib/std/string.ci:39: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	lib/std/string.ci:37: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	lib/std/string.ci:37: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: dup.x32 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	lib/std/string.ci:42: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	lib/std/string.ci:47: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:48: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:49: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	lib/std/string.ci:50: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	lib/std/string.ci:52: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	lib/std/string.ci:53: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	lib/std/string.ci:54: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	lib/std/string.ci:52: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	lib/std/string.ci:52: (9 bytes): i < withLen
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:57: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
.usages:
	lib/gfxlib.ci:110: referenced as `endsWith`
	lib/gfxlib.ci:107: referenced as `endsWith`
	lib/gfxlib.ci:18: referenced as `endsWith`
	lib/gfxlib.ci:15: referenced as `endsWith`
	lib/gfxlib.ci:12: referenced as `endsWith`
	lib/gfxlib.ci:9: referenced as `endsWith`
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	lib/std/string.ci:62: (1 byte): result: int32 := 0
	<compare>  : load.z32
	lib/std/string.ci:63: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	lib/std/string.ci:64: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x32 sp(5)
	<compare+?>: dup.x32 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	lib/std/string.ci:66: (4 bytes): break;
	<compare+?>: jmp +16
	lib/std/string.ci:63: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	lib/std/string.ci:63: (8 bytes): result == 0
	<compare+?>: dup.x32 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	lib/std/string.ci:69: (3 bytes): return .result := result;
	<compare+?>: set.x32 sp(5)
	<compare+?>: ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	lib/std/string.ci:84: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x32 sp(4)
	<ignCaseCmp+?>: ret
.usages:
	lib/gfxlib.ci:110: referenced as `ignCaseCmp`
	lib/gfxlib.ci:107: referenced as `ignCaseCmp`
	lib/gfxlib.ci:18: referenced as `ignCaseCmp`
	lib/gfxlib.ci:15: referenced as `ignCaseCmp`
	lib/gfxlib.ci:12: referenced as `ignCaseCmp`
	lib/gfxlib.ci:9: referenced as `ignCaseCmp`
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	lib/std/string.ci:89: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x32 sp(4)
	<caseCmp+?>: ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: startsWith(str, with, caseCmp)
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: endsWith(str, with, caseCmp)
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: compare(str, with, caseCmp)
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param chr: char (size: 4, cast: i32)
.doc: 'Check if a string contains the given character'
.value: indexOf(str, chr) >= 0
.usages:
	lib/std/string.ci:181: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field showSign: bool (size: 1, cast: const variable(bool))
.field precision: int32 (size: 4, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field padLen: int32 (size: 4, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:262: referenced as `FormatFlags`
	lib/std/string.ci:258: referenced as `FormatFlags`
	lib/std/string.ci:240: referenced as `FormatFlags`
	lib/std/string.ci:234: referenced as `FormatFlags`
	lib/std/string.ci:233: referenced as `FormatFlags`
	lib/std/string.ci:230: referenced as `FormatFlags`
	lib/std/string.ci:228: referenced as `FormatFlags`
	lib/std/string.ci:226: referenced as `FormatFlags`
	lib/std/string.ci:224: referenced as `FormatFlags`
	lib/std/string.ci:222: referenced as `FormatFlags`
	lib/std/string.ci:220: referenced as `FormatFlags`
	lib/std/string.ci:218: referenced as `FormatFlags`
	lib/std/string.ci:216: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'showSign'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	lib/std/string.ci:241: referenced as `showSign`
	lib/std/string.ci:235: referenced as `showSign`
	lib/std/string.ci:235: referenced as `showSign`
	lib/std/string.ci:150: referenced as `showSign`
	lib/std/string.ci:113: defined as `showSign`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	lib/std/string.ci:252: referenced as `precision`
	lib/std/string.ci:242: referenced as `precision`
	lib/std/string.ci:244: referenced as `precision`
	lib/std/string.ci:236: referenced as `precision`
	lib/std/string.ci:238: referenced as `precision`
	lib/std/string.ci:156: referenced as `precision`
	lib/std/string.ci:116: defined as `precision`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:243: referenced as `padChr`
	lib/std/string.ci:237: referenced as `padChr`
	lib/std/string.ci:237: referenced as `padChr`
	lib/std/string.ci:173: referenced as `padChr`
	lib/std/string.ci:119: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:244: referenced as `padLen`
	lib/std/string.ci:238: referenced as `padLen`
	lib/std/string.ci:238: referenced as `padLen`
	lib/std/string.ci:171: referenced as `padLen`
	lib/std/string.ci:122: defined as `padLen`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (84 bytes)
	lib/std/string.ci:127: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append>  : load.z32
	<append+?>: jmp +41
	lib/std/string.ci:128: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(3)
	<append+?>: dup.x32 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	lib/std/string.ci:129: (4 bytes): break;
	<append+?>: jmp +38
	lib/std/string.ci:131: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x32 sp(5)
	<append+?>: dup.x32 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:132: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(4)
	lib/std/string.ci:127: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:127: (10 bytes): value[i]
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	lib/std/string.ci:135: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:136: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(3)
	lib/std/string.ci:138: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:139: (4 bytes): return .result := pos;
	<append+?>: mov.x32 sp(5, 2)
	<append+?>: ret
.usages:
	lib/gfxlib.ci:359: referenced as `append`
	lib/gfxlib.ci:357: referenced as `append`
	lib/gfxlib.ci:355: referenced as `append`
	lib/std/string.ci:251: referenced as `append`
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 707
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param sign: char (size: 4, cast: variable(i32))
.param value: uint64 (size: 8, cast: variable(u64))
.param format: FormatFlags (size: 4, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	if (format.showSign) {
		if ((sign) == 0) {
			sign := '+';
		}
	}
	radix: int32 := format.precision;
	if (radix == 0) {
		radix := 10;
	}
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (707 bytes)
	lib/std/string.ci:147: (1 byte): len: int32 := 0
	<append>  : load.z32
	lib/std/string.ci:148: (4 bytes): digits: char[80]
	<append+?>: inc.sp(+80)
	lib/std/string.ci:150: (28 bytes): if (format.showSign)
	<append+?>: dup.x32 sp(22)
	<append+?>: load.i8
	<append+?>: jz +25
	lib/std/string.ci:151: (21 bytes): if ((sign) == 0)
	<append+?>: load.sp(+100)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	lib/std/string.ci:152: (10 bytes): sign := '+';
	<append+?>: load.c32 43
	<append+?>: load.sp(+104)
	<append+?>: store.i8
	lib/std/string.ci:156: (7 bytes): radix: int32 := format.precision
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	lib/std/string.ci:157: (15 bytes): if (radix == 0)
	<append+?>: dup.x32 sp(0)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +11
	lib/std/string.ci:158: (7 bytes): radix := 10;
	<append+?>: load.c32 10
	<append+?>: set.x32 sp(1)
	lib/std/string.ci:160: (54 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: dup.x32 sp(0)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 160
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:161: (53 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: dup.x32 sp(0)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 161
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:164: (49 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +41
	lib/std/string.ci:165: (29 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x64 sp(25)
	<append+?>: dup.x32 sp(3)
	<append+?>: i32.2i64
	<append+?>: mod.u64
	<append+?>: i64.2i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: load.sp(+8)
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:164: (8 bytes): value := value / (radix)
	<append+?>: dup.x64 sp(24)
	<append+?>: dup.x32 sp(2)
	<append+?>: i32.2i64
	<append+?>: div.u64
	<append+?>: set.x64 sp(26)
	lib/std/string.ci:164: (8 bytes): value > (0)
	<append+?>: dup.x64 sp(24)
	<append+?>: load.z64
	<append+?>: cgt.u64
	<append+?>: jnz -41
	lib/std/string.ci:167: (29 bytes): if (len == 0)
	<append+?>: dup.x32 sp(21)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	lib/std/string.ci:168: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+8)
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:171: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+12)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(22)
	<append+?>: sub.i32
	lib/std/string.ci:173: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x32 sp(24)
	<append+?>: inc.i32(+8)
	<append+?>: load.i8
	lib/std/string.ci:174: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	lib/std/string.ci:175: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	lib/std/string.ci:179: (207 bytes): if ((sign) != 0)
	<append+?>: load.sp(+112)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	lib/std/string.ci:180: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	lib/std/string.ci:181: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.i8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +95
	lib/std/string.ci:183: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:184: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 184
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:185: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:186: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	lib/std/string.ci:183: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	lib/std/string.ci:183: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:189: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 189
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:190: (11 bytes): output[pos] := sign;
	<append+?>: load.sp(+112)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:191: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	lib/std/string.ci:195: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:196: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 196
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:197: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:198: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	lib/std/string.ci:195: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	lib/std/string.ci:195: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:202: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +85
	lib/std/string.ci:203: (52 bytes): assert(i < (output.length));
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 203
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:204: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+16)
	<append+?>: dup.x32 sp(25)
	<append+?>: dup.x32 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x32 sp(32)
	<append+?>: dup.x32 sp(32)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:205: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(30)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(31)
	lib/std/string.ci:202: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:202: (9 bytes): i < len
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(25)
	<append+?>: clt.i32
	<append+?>: jnz -86
	<append+?>: inc.sp(-4)
	lib/std/string.ci:208: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:209: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(31)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(30)
	lib/std/string.ci:211: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:212: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(32, 29)
	<append+?>: inc.sp(-96)
	<append+?>: ret
.usages:
	lib/std/string.ci:253: referenced as `append`
	lib/std/string.ci:249: referenced as `append`
	lib/std/string.ci:230: referenced as `append`
	lib/std/string.ci:228: referenced as `append`
	lib/std/string.ci:226: referenced as `append`
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:222: referenced as `append`
	lib/std/string.ci:220: referenced as `append`
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:216: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:216'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint64 (size: 8, cast: u64)
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
	lib/std/string.ci:216: defined as `append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:218'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
	lib/std/string.ci:218: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:220'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
	lib/std/string.ci:220: defined as `append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:224'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int64 (size: 8, cast: variable(i64))
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, value < (0) ? ('-') : 0, uint64(value < (0) ? -value : value), format)
.usages:
	lib/std/string.ci:224: defined as `append(output: char[], pos: int32, value: int64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:226'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, value < 0 ? ('-') : 0, uint64(value < 0 ? -value : value), format)
.usages:
	lib/std/string.ci:263: referenced as `append`
	lib/std/string.ci:226: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:228'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int16 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format)
.usages:
	lib/std/string.ci:228: defined as `append(output: char[], pos: int32, value: int16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:230'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int8 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format)
.usages:
	lib/std/string.ci:230: defined as `append(output: char[], pos: int32, value: int8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 227
.name: 'append'
.file: 'lib/std/string.ci:233'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.param format: FormatFlags (size: 4, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		formatInt.showSign := format.showSign;
		formatInt.precision := 0;
		formatInt.padChr := format.padChr;
		formatInt.padLen := format.padLen - format.precision;
	};
	formatDec: FormatFlags := {
		formatDec.showSign := false;
		formatDec.precision := 0;
		formatDec.padChr := '0';
		formatDec.padLen := format.precision;
	};
	sign: char := value < (0) ? ('-') : 0;
	fract: float64 := Math.modf(Math.abs(value), value);
	pos := append(output, pos, sign, uint64(value), formatInt);
	pos := append(output, pos, ".");
	fract := fract * float64.pow(10, format.precision);
	pos := append(output, pos, 0, uint64(fract), formatDec);
	return .result := pos;
}
.instructions: (227 bytes)
	lib/std/string.ci:234: (44 bytes): formatInt: FormatFlags := {...}
	<append>  : inc.sp(+16)
	lib/std/string.ci:235: (8 bytes): formatInt.showSign := format.showSign;
	<append+?>: dup.x32 sp(5)
	<append+?>: load.i8
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	lib/std/string.ci:236: (3 bytes): formatInt.precision := 0;
	<append+?>: load.z32
	<append+?>: set.x32 sp(2)
	lib/std/string.ci:237: (12 bytes): formatInt.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+8)
	<append+?>: load.i8
	<append+?>: load.sp(+12)
	<append+?>: store.i8
	lib/std/string.ci:238: (17 bytes): formatInt.padLen := format.padLen - format.precision;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+12)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: sub.i32
	<append+?>: set.x32 sp(4)
	lib/std/string.ci:240: (32 bytes): formatDec: FormatFlags := {...}
	<append+?>: inc.sp(+16)
	lib/std/string.ci:241: (6 bytes): formatDec.showSign := false;
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	lib/std/string.ci:242: (3 bytes): formatDec.precision := 0;
	<append+?>: load.z32
	<append+?>: set.x32 sp(2)
	lib/std/string.ci:243: (10 bytes): formatDec.padChr := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+12)
	<append+?>: store.i8
	lib/std/string.ci:244: (9 bytes): formatDec.padLen := format.precision;
	<append+?>: dup.x32 sp(9)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: set.x32 sp(4)
	lib/std/string.ci:247: (18 bytes): sign: char := value < (0) ? ('-') : 0
	<append+?>: dup.x64 sp(10)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +5
	<append+?>: load.z32
	lib/std/string.ci:248: (27 bytes): fract: float64 := Math.modf(Math.abs(value), value)
	<append+?>: load.z128
	<append+?>: dup.x64 sp(15)
	<append+?>: load.ref <?> ;Math.abs(x: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.sp(+60)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	lib/std/string.ci:249: (29 bytes): pos := append(output, pos, sign, uint64(value), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.sp(+24)
	<append+?>: load.i8
	<append+?>: dup.x64 sp(18)
	<append+?>: f64.2i64
	<append+?>: load.sp(+56)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(16)
	lib/std/string.ci:251: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(16)
	lib/std/string.ci:252: (22 bytes): fract := fract * float64.pow(10, format.precision);
	<append+?>: load.f64 10.000000
	<append+?>: dup.x32 sp(14)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: i32.2f64
	<append+?>: nfc(45) ;float64.pow(x: float64, y: float64): float64
	<append+?>: mul.f64
	lib/std/string.ci:253: (25 bytes): pos := append(output, pos, 0, uint64(fract), formatDec);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.z32
	<append+?>: dup.x64 sp(5)
	<append+?>: f64.2i64
	<append+?>: load.sp(+40)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(16)
	lib/std/string.ci:254: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(18, 15)
	<append+?>: inc.sp(-44)
	<append+?>: ret
.usages:
	lib/std/string.ci:258: referenced as `append`
	lib/std/string.ci:233: defined as `append(output: char[], pos: int32, value: float64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'lib/std/string.ci:258'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.param format: FormatFlags (size: 4, cast: ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, float64(value), format)
.usages:
	lib/std/string.ci:258: defined as `append(output: char[], pos: int32, value: float32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.name: 'append'
.file: 'lib/std/string.ci:261'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		format.showSign := false;
		format.precision := 0;
		format.padChr := (0);
		format.padLen := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (63 bytes)
	lib/std/string.ci:263: (63 bytes): return .result := append(output, pos, value, format);
	<append>  : dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: dup.x64 sp(5)
	<append+?>: dup.x32 sp(6)
	<append+?>: dup.x32 sp(4)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +5
	<append+?>: load.z32
	<append+?>: dup.x32 sp(5)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +11
	<append+?>: dup.x32 sp(5)
	<append+?>: neg.i32
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(5)
	<append+?>: i32.2i64
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(1)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
.usages:
	lib/gfxlib.ci:360: referenced as `append`
	lib/gfxlib.ci:358: referenced as `append`
	lib/gfxlib.ci:356: referenced as `append`
	lib/std/string.ci:261: defined as `append(output: char[], pos: int32, value: int32): int32`
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0, cast: static const inline)
.field create: function (size: 0, cast: static const inline)
.field append: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field peek: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field readLine: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field flush: function (size: 0, cast: static const inline)
.field close: function (size: 0, cast: static const inline)
.field in: File (size: 0, cast: static const inline)
.field out: File (size: 0, cast: static const inline)
.field err: File (size: 0, cast: static const inline)
.field log: File (size: 0, cast: static const inline)
.usages:
	internal usages: 15
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(48)
.usages:
	internal usages: 1
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(49)
.usages:
	internal usages: 1
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(50)
.usages:
	internal usages: 1
}
File.read(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(51)
.usages:
	internal usages: 1
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(52)
.usages:
	internal usages: 1
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(53)
.usages:
	internal usages: 1
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readLine'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(54)
.usages:
	internal usages: 1
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param byte: uint8 (size: 4, cast: variable(u32))
.value: nfc(55)
.usages:
	internal usages: 1
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(56)
.usages:
	internal usages: 1
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(57)
.usages:
	internal usages: 1
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(58)
.usages:
	internal usages: 1
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.value: nfc(59)
.usages:
	internal usages: 1
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.value: nfc(60)
.usages:
	internal usages: 1
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.value: nfc(61)
.usages:
	internal usages: 1
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.value: nfc(62)
.usages:
	internal usages: 1
}
gxRect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'gxRect'
.field x: int32 (size: 4, cast: variable(i32))
.field y: int32 (size: 4, cast: variable(i32))
.field w: int32 (size: 4, cast: variable(i32))
.field h: int32 (size: 4, cast: variable(i32))
.usages:
	lib/gfxlib.ci:218: referenced as `gxRect`
	lib/gfxlib.ci:217: referenced as `gxRect`
	lib/gfxlib.ci:188: referenced as `gxRect`
	lib/gfxlib.ci:187: referenced as `gxRect`
	lib/gfxlib.ci:184: referenced as `gxRect`
	lib/gfxlib.ci:181: referenced as `gxRect`
	lib/gfxlib.ci:179: referenced as `gxRect`
	lib/gfxlib.ci:141: referenced as `gxRect`
	lib/gfxlib.ci:138: referenced as `gxRect`
	lib/gfxlib.ci:138: referenced as `gxRect`
	lib/gfx/color.ci:311: referenced as `gxRect`
	lib/gfx/color.ci:304: referenced as `gxRect`
	lib/gfx/color.ci:246: referenced as `gxRect`
	lib/gfx/color.ci:236: referenced as `gxRect`
	internal usages: 10
}
gxRect.x: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.owner: gxRect
.usages:
	lib/gfxlib.ci:219: referenced as `x`
	lib/gfxlib.ci:219: referenced as `x`
	lib/gfxlib.ci:209: referenced as `x`
	lib/gfxlib.ci:209: referenced as `x`
	lib/gfxlib.ci:189: referenced as `x`
	lib/gfxlib.ci:189: referenced as `x`
	lib/gfxlib.ci:184: referenced as `x`
	lib/gfxlib.ci:184: referenced as `x`
	lib/gfxlib.ci:181: referenced as `x`
	lib/gfxlib.ci:181: referenced as `x`
	lib/gfxlib.ci:179: referenced as `x`
	lib/gfxlib.ci:179: referenced as `x`
	lib/gfxlib.ci:164: referenced as `x`
	lib/gfxlib.ci:147: referenced as `x`
	lib/gfxlib.ci:146: referenced as `x`
	lib/gfxlib.ci:143: referenced as `x`
	lib/gfx/color.ci:284: referenced as `x`
	lib/gfx/color.ci:272: referenced as `x`
	lib/gfx/color.ci:256: referenced as `x`
	lib/gfx/color.ci:254: referenced as `x`
	lib/gfx/color.ci:250: referenced as `x`
	lib/gfx/color.ci:250: referenced as `x`
	internal usages: 1
}
gxRect.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.owner: gxRect
.usages:
	lib/gfxlib.ci:220: referenced as `y`
	lib/gfxlib.ci:220: referenced as `y`
	lib/gfxlib.ci:207: referenced as `y`
	lib/gfxlib.ci:207: referenced as `y`
	lib/gfxlib.ci:190: referenced as `y`
	lib/gfxlib.ci:190: referenced as `y`
	lib/gfxlib.ci:184: referenced as `y`
	lib/gfxlib.ci:184: referenced as `y`
	lib/gfxlib.ci:181: referenced as `y`
	lib/gfxlib.ci:181: referenced as `y`
	lib/gfxlib.ci:179: referenced as `y`
	lib/gfxlib.ci:179: referenced as `y`
	lib/gfxlib.ci:165: referenced as `y`
	lib/gfxlib.ci:151: referenced as `y`
	lib/gfxlib.ci:150: referenced as `y`
	lib/gfxlib.ci:144: referenced as `y`
	lib/gfx/color.ci:277: referenced as `y`
	lib/gfx/color.ci:272: referenced as `y`
	lib/gfx/color.ci:257: referenced as `y`
	lib/gfx/color.ci:255: referenced as `y`
	lib/gfx/color.ci:249: referenced as `y`
	lib/gfx/color.ci:249: referenced as `y`
	internal usages: 1
}
gxRect.w: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'w'
.owner: gxRect
.usages:
	lib/gfxlib.ci:238: referenced as `w`
	lib/gfxlib.ci:230: referenced as `w`
	lib/gfxlib.ci:221: referenced as `w`
	lib/gfxlib.ci:221: referenced as `w`
	lib/gfxlib.ci:209: referenced as `w`
	lib/gfxlib.ci:191: referenced as `w`
	lib/gfxlib.ci:191: referenced as `w`
	lib/gfxlib.ci:184: referenced as `w`
	lib/gfxlib.ci:181: referenced as `w`
	lib/gfxlib.ci:179: referenced as `w`
	lib/gfxlib.ci:167: referenced as `w`
	lib/gfxlib.ci:164: referenced as `w`
	lib/gfxlib.ci:156: referenced as `w`
	lib/gfxlib.ci:155: referenced as `w`
	lib/gfxlib.ci:143: referenced as `w`
	lib/gfx/color.ci:283: referenced as `w`
	lib/gfx/color.ci:262: referenced as `w`
	lib/gfx/color.ci:256: referenced as `w`
	lib/gfx/color.ci:247: referenced as `w`
	lib/gfx/color.ci:250: referenced as `w`
	lib/gfx/color.ci:247: referenced as `w`
	internal usages: 1
}
gxRect.h: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'h'
.owner: gxRect
.usages:
	lib/gfxlib.ci:237: referenced as `h`
	lib/gfxlib.ci:233: referenced as `h`
	lib/gfxlib.ci:222: referenced as `h`
	lib/gfxlib.ci:222: referenced as `h`
	lib/gfxlib.ci:207: referenced as `h`
	lib/gfxlib.ci:192: referenced as `h`
	lib/gfxlib.ci:192: referenced as `h`
	lib/gfxlib.ci:184: referenced as `h`
	lib/gfxlib.ci:181: referenced as `h`
	lib/gfxlib.ci:179: referenced as `h`
	lib/gfxlib.ci:170: referenced as `h`
	lib/gfxlib.ci:165: referenced as `h`
	lib/gfxlib.ci:161: referenced as `h`
	lib/gfxlib.ci:160: referenced as `h`
	lib/gfxlib.ci:144: referenced as `h`
	lib/gfx/color.ci:288: referenced as `h`
	lib/gfx/color.ci:287: referenced as `h`
	lib/gfx/color.ci:286: referenced as `h`
	lib/gfx/color.ci:285: referenced as `h`
	lib/gfx/color.ci:281: referenced as `h`
	lib/gfx/color.ci:280: referenced as `h`
	lib/gfx/color.ci:279: referenced as `h`
	lib/gfx/color.ci:278: referenced as `h`
	lib/gfx/color.ci:277: referenced as `h`
	lib/gfx/color.ci:272: referenced as `h`
	lib/gfx/color.ci:267: referenced as `h`
	lib/gfx/color.ci:266: referenced as `h`
	lib/gfx/color.ci:265: referenced as `h`
	lib/gfx/color.ci:264: referenced as `h`
	lib/gfx/color.ci:263: referenced as `h`
	lib/gfx/color.ci:257: referenced as `h`
	lib/gfx/color.ci:248: referenced as `h`
	lib/gfx/color.ci:248: referenced as `h`
	internal usages: 1
}
gxSurf: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'gxSurf'
.field create: function (size: 0, cast: static const inline)
.field create3d: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openBmp: function (size: 0, cast: static const inline)
.field openPng: function (size: 0, cast: static const inline)
.field openJpg: function (size: 0, cast: static const inline)
.field openFnt: function (size: 0, cast: static const inline)
.field saveBmp: function (size: 0, cast: static const inline)
.field width: function (size: 0, cast: static const inline)
.field height: function (size: 0, cast: static const inline)
.field depth: function (size: 0, cast: static const inline)
.field get: function (size: 0, cast: static const inline)
.field set: function (size: 0, cast: static const inline)
.field tex: function (size: 0, cast: static const inline)
.field drawRect: function (size: 0, cast: static const inline)
.field fillRect: function (size: 0, cast: static const inline)
.field drawOval: function (size: 0, cast: static const inline)
.field fillOval: function (size: 0, cast: static const inline)
.field drawLine: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field clipText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field blend: function (size: 0, cast: static const inline)
.field transform: function (size: 0, cast: static const inline)
.field blur: function (size: 0, cast: static const inline)
.field colorMap: function (size: 0, cast: static const inline)
.field colorMat: function (size: 0, cast: static const inline)
.field gradient: function (size: 0, cast: static const inline)
.field calcHist: function (size: 0, cast: static const inline)
.field drawMesh: function (size: 0, cast: static const inline)
.usages:
	lib/gfxlib.ci:469: referenced as `gxSurf`
	lib/gfxlib.ci:428: referenced as `gxSurf`
	lib/gfxlib.ci:427: referenced as `gxSurf`
	lib/gfxlib.ci:394: referenced as `gxSurf`
	lib/gfxlib.ci:393: referenced as `gxSurf`
	lib/gfxlib.ci:392: referenced as `gxSurf`
	lib/gfxlib.ci:390: referenced as `gxSurf`
	lib/gfxlib.ci:390: referenced as `gxSurf`
	lib/gfxlib.ci:379: referenced as `gxSurf`
	lib/gfxlib.ci:376: referenced as `gxSurf`
	lib/gfxlib.ci:367: referenced as `gxSurf`
	lib/gfxlib.ci:249: referenced as `gxSurf`
	lib/gfxlib.ci:217: referenced as `gxSurf`
	lib/gfxlib.ci:217: referenced as `gxSurf`
	lib/gfxlib.ci:187: referenced as `gxSurf`
	lib/gfxlib.ci:184: referenced as `gxSurf`
	lib/gfxlib.ci:181: referenced as `gxSurf`
	lib/gfxlib.ci:179: referenced as `gxSurf`
	lib/gfxlib.ci:177: referenced as `gxSurf`
	lib/gfxlib.ci:141: referenced as `gxSurf`
	lib/gfxlib.ci:138: referenced as `gxSurf`
	lib/gfxlib.ci:138: referenced as `gxSurf`
	lib/gfxlib.ci:138: referenced as `gxSurf`
	lib/gfxlib.ci:135: referenced as `gxSurf`
	lib/gfxlib.ci:135: referenced as `gxSurf`
	lib/gfxlib.ci:129: referenced as `gxSurf`
	lib/gfxlib.ci:129: referenced as `gxSurf`
	lib/gfxlib.ci:124: referenced as `gxSurf`
	lib/gfxlib.ci:124: referenced as `gxSurf`
	lib/gfxlib.ci:118: referenced as `gxSurf`
	lib/gfxlib.ci:118: referenced as `gxSurf`
	lib/gfxlib.ci:117: referenced as `gxSurf`
	lib/gfxlib.ci:117: referenced as `gxSurf`
	lib/gfxlib.ci:43: referenced as `gxSurf`
	lib/gfxlib.ci:42: referenced as `gxSurf`
	lib/gfxlib.ci:28: referenced as `gxSurf`
	lib/gfxlib.ci:19: referenced as `gxSurf`
	lib/gfxlib.ci:16: referenced as `gxSurf`
	lib/gfxlib.ci:13: referenced as `gxSurf`
	lib/gfxlib.ci:10: referenced as `gxSurf`
	lib/gfxlib.ci:8: referenced as `gxSurf`
	lib/gfxlib.ci:5: referenced as `gxSurf`
	lib/gfx/color.ci:311: referenced as `gxSurf`
	lib/gfx/color.ci:304: referenced as `gxSurf`
	lib/gfx/color.ci:236: referenced as `gxSurf`
	internal usages: 40
}
gxSurf.create(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(81)
.usages:
	lib/gfxlib.ci:129: referenced as `create`
	lib/gfxlib.ci:118: referenced as `create`
	lib/gfxlib.ci:5: referenced as `create`
	internal usages: 1
}
gxSurf.create3d(width: int32, height: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.value: nfc(82)
.usages:
	lib/gfxlib.ci:367: referenced as `create3d`
	internal usages: 1
}
gxSurf.recycle(recycle: gxSurf, width: int32, height: int32, depth: int32, flags: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param recycle: gxSurf (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(83)
.usages:
	internal usages: 1
}
gxSurf.destroy(surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(84)
.usages:
	lib/gfxlib.ci:484: referenced as `destroy`
	lib/gfxlib.ci:483: referenced as `destroy`
	lib/gfxlib.ci:472: referenced as `destroy`
	lib/gfxlib.ci:372: referenced as `destroy`
	lib/gfxlib.ci:95: referenced as `destroy`
	internal usages: 1
}
gxSurf.openBmp(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(85)
.usages:
	lib/gfxlib.ci:19: referenced as `openBmp`
	internal usages: 1
}
gxSurf.openPng(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(86)
.usages:
	lib/gfxlib.ci:16: referenced as `openPng`
	internal usages: 1
}
gxSurf.openJpg(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(87)
.usages:
	lib/gfxlib.ci:13: referenced as `openJpg`
	lib/gfxlib.ci:10: referenced as `openJpg`
	internal usages: 1
}
gxSurf.openFnt(path: char[*]): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(88)
.usages:
	internal usages: 1
}
gxSurf.saveBmp(surf: gxSurf, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param path: char[*] (size: 4, cast: variable(ref))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(89)
.usages:
	lib/gfxlib.ci:455: referenced as `saveBmp`
	lib/gfxlib.ci:454: referenced as `saveBmp`
	internal usages: 1
}
gxSurf.width(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(90)
.usages:
	lib/gfxlib.ci:235: referenced as `width`
	lib/gfxlib.ci:221: referenced as `width`
	lib/gfxlib.ci:205: referenced as `width`
	lib/gfxlib.ci:191: referenced as `width`
	lib/gfxlib.ci:154: referenced as `width`
	lib/gfxlib.ci:125: referenced as `width`
	lib/gfxlib.ci:118: referenced as `width`
	lib/gfxlib.ci:76: referenced as `width`
	lib/gfxlib.ci:73: referenced as `width`
	lib/gfxlib.ci:61: referenced as `width`
	lib/gfxlib.ci:52: referenced as `width`
	lib/gfx/color.ci:250: referenced as `width`
	internal usages: 1
}
gxSurf.height(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(91)
.usages:
	lib/gfxlib.ci:236: referenced as `height`
	lib/gfxlib.ci:222: referenced as `height`
	lib/gfxlib.ci:206: referenced as `height`
	lib/gfxlib.ci:192: referenced as `height`
	lib/gfxlib.ci:159: referenced as `height`
	lib/gfxlib.ci:129: referenced as `height`
	lib/gfxlib.ci:127: referenced as `height`
	lib/gfxlib.ci:118: referenced as `height`
	lib/gfxlib.ci:84: referenced as `height`
	lib/gfxlib.ci:81: referenced as `height`
	lib/gfxlib.ci:64: referenced as `height`
	lib/gfxlib.ci:53: referenced as `height`
	internal usages: 1
}
gxSurf.depth(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(92)
.usages:
	lib/gfxlib.ci:129: referenced as `depth`
	lib/gfxlib.ci:118: referenced as `depth`
	internal usages: 1
}
gxSurf.get(surf: gxSurf, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.value: nfc(93)
.usages:
	internal usages: 1
}
gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.value: nfc(94)
.usages:
	lib/gfxlib.ci:135: referenced as `set`
	lib/gfx/color.ci:272: referenced as `set`
	internal usages: 1
}
gxSurf.tex(surf: gxSurf, x: float32, y: float32): vec4f: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tex'
.owner: gxSurf
.param .result: vec4f (size: 16, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(95)
.usages:
	internal usages: 1
}
gxSurf.drawRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(96)
.usages:
	lib/gfxlib.ci:184: referenced as `drawRect`
	internal usages: 1
}
gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(97)
.usages:
	lib/gfxlib.ci:181: referenced as `fillRect`
	lib/gfxlib.ci:179: referenced as `fillRect`
	lib/gfxlib.ci:177: referenced as `fillRect`
	lib/gfx/color.ci:253: referenced as `fillRect`
	internal usages: 1
}
gxSurf.drawOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(98)
.usages:
	internal usages: 1
}
gxSurf.fillOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(99)
.usages:
	internal usages: 1
}
gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawLine'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(100)
.usages:
	lib/gfx/color.ci:293: referenced as `drawLine`
	lib/gfx/color.ci:292: referenced as `drawLine`
	lib/gfx/color.ci:291: referenced as `drawLine`
	lib/gfx/color.ci:290: referenced as `drawLine`
	internal usages: 1
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(101)
.usages:
	internal usages: 1
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param x4: int32 (size: 4, cast: variable(i32))
.param y4: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(102)
.usages:
	internal usages: 1
}
gxSurf.clipText(font: gxSurf, rect: gxRect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param font: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: variable(ref))
.value: nfc(103)
.usages:
	internal usages: 1
}
gxSurf.drawText(surf: gxSurf, x: int32, y: int32, font: gxSurf, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param font: gxSurf (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(104)
.usages:
	internal usages: 1
}
gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.value: nfc(105)
.usages:
	lib/gfxlib.ci:408: referenced as `copy`
	lib/gfxlib.ci:404: referenced as `copy`
	lib/gfxlib.ci:239: referenced as `copy`
	lib/gfxlib.ci:119: referenced as `copy`
	internal usages: 1
}
gxSurf.blend(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect, alpha: int32, dstAlpha: bool, blend(base: vec4f, with: vec4f): vec4f): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blend'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: const variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param alpha: int32 (size: 4, cast: variable(i32))
.param dstAlpha: bool (size: 4, cast: variable(bool))
.param blend: function (size: 4, cast: variable(ref))
.value: nfc(106)
.usages:
	internal usages: 1
}
gxSurf.transform(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'transform'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: const variable(ref))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.param mat: float32[16] (size: 4, cast: variable(ref))
.value: nfc(107)
.usages:
	lib/gfxlib.ci:138: referenced as `transform`
	lib/gfxlib.ci:130: referenced as `transform`
	lib/gfxlib.ci:94: referenced as `transform`
	internal usages: 1
}
gxSurf.blur(surf: gxSurf, radius: int32, sigma: float64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blur'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param radius: int32 (size: 4, cast: variable(i32))
.param sigma: float64 (size: 8, cast: variable(f64))
.value: nfc(108)
.usages:
	internal usages: 1
}
gxSurf.colorMap(surf: gxSurf, roi: gxRect, lut: uint32[256], useLuminosity: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: const variable(ref))
.param useLuminosity: bool (size: 4, cast: variable(bool))
.value: nfc(109)
.usages:
	internal usages: 1
}
gxSurf.colorMat(surf: gxSurf, roi: gxRect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.value: nfc(110)
.usages:
	internal usages: 1
}
gxSurf.gradient(surf: gxSurf, roi: gxRect, type: int32, alpha: int32, repeat: bool, invert: bool, lut: uint32[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'gradient'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param type: int32 (size: 4, cast: variable(i32))
.param alpha: int32 (size: 4, cast: variable(i32))
.param repeat: bool (size: 4, cast: variable(bool))
.param invert: bool (size: 4, cast: variable(bool))
.param lut: uint32[] (size: 8, cast: parallel variable(arr))
.value: nfc(111)
.usages:
	internal usages: 1
}
gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcHist'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param rgb: uint32 (size: 4, cast: variable(u32))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(112)
.usages:
	lib/gfx/color.ci:306: referenced as `calcHist`
	internal usages: 1
}
gxSurf.drawMesh(surf: gxSurf, mesh: gxMesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.value: nfc(113)
.usages:
	lib/gfxlib.ci:352: referenced as `drawMesh`
	internal usages: 1
}
gxMesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 176
.name: 'gxMesh'
.field create: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openObj: function (size: 0, cast: static const inline)
.field open3ds: function (size: 0, cast: static const inline)
.field saveObj: function (size: 0, cast: static const inline)
.field normalize: function (size: 0, cast: static const inline)
.field addVertex: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field setVertex: function (size: 0, cast: static const inline)
.field setNormal: function (size: 0, cast: static const inline)
.field setTexture: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field shine: function (size: 0, cast: static const inline)
.field texture: function (size: 0, cast: static const inline)
.field clearDepth: int64 (size: 0, cast: static const i64)
.field clearColor: int64 (size: 0, cast: static const i64)
.field cullBack: int64 (size: 0, cast: static const i64)
.field cullFront: int64 (size: 0, cast: static const i64)
.field drawPlot: int64 (size: 0, cast: static const i64)
.field drawWire: int64 (size: 0, cast: static const i64)
.field drawFill: int64 (size: 0, cast: static const i64)
.field drawMode: int64 (size: 0, cast: static const i64)
.field useTexture: int64 (size: 0, cast: static const i64)
.field useLights: int64 (size: 0, cast: static const i64)
.field vertices: int64 (size: 8, cast: const variable(i64))
.field triangles: int64 (size: 8, cast: const variable(i64))
.field segments: int64 (size: 8, cast: const variable(i64))
.usages:
	lib/gfxlib.ci:366: referenced as `gxMesh`
	lib/gfxlib.ci:366: referenced as `gxMesh`
	lib/gfxlib.ci:366: referenced as `gxMesh`
	lib/gfxlib.ci:366: referenced as `gxMesh`
	lib/gfxlib.ci:366: referenced as `gxMesh`
	lib/gfxlib.ci:298: referenced as `gxMesh`
	lib/gfxlib.ci:295: referenced as `gxMesh`
	lib/gfxlib.ci:295: referenced as `gxMesh`
	lib/gfxlib.ci:292: referenced as `gxMesh`
	lib/gfxlib.ci:277: referenced as `gxMesh`
	lib/gfxlib.ci:250: referenced as `gxMesh`
	lib/gfxlib.ci:245: referenced as `gxMesh`
	lib/gfxlib.ci:111: referenced as `gxMesh`
	lib/gfxlib.ci:108: referenced as `gxMesh`
	lib/gfxlib.ci:106: referenced as `gxMesh`
	internal usages: 20
}
gxMesh.create(size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(63)
.usages:
	internal usages: 1
}
gxMesh.recycle(recycle: gxMesh, size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param recycle: gxMesh (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(64)
.usages:
	internal usages: 1
}
gxMesh.destroy(mesh: gxMesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.value: nfc(65)
.usages:
	internal usages: 1
}
gxMesh.openObj(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(66)
.usages:
	lib/gfxlib.ci:108: referenced as `openObj`
	internal usages: 1
}
gxMesh.open3ds(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(67)
.usages:
	lib/gfxlib.ci:111: referenced as `open3ds`
	internal usages: 1
}
gxMesh.saveObj(mesh: gxMesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(68)
.usages:
	internal usages: 1
}
gxMesh.normalize(mesh: gxMesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param tolerance: float32 (size: 4, cast: variable(f32))
.param center: float32[3] (size: 4, cast: variable(ref))
.param resize: float32[3] (size: 4, cast: variable(ref))
.value: nfc(69)
.usages:
	internal usages: 1
}
gxMesh.addVertex(mesh: gxMesh, x: float32, y: float32, z: float32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(70)
.usages:
	internal usages: 1
}
gxMesh.addFace(mesh: gxMesh, v1: int32, v2: int32, v3: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.value: nfc(71)
.usages:
	internal usages: 1
}
gxMesh.addFace(mesh: gxMesh, v1: int32, v2: int32, v3: int32, v4: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.param v4: int32 (size: 4, cast: variable(i32))
.value: nfc(72)
.usages:
	internal usages: 1
}
gxMesh.setVertex(mesh: gxMesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setVertex'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(73)
.usages:
	internal usages: 1
}
gxMesh.setNormal(mesh: gxMesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setNormal'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(74)
.usages:
	internal usages: 1
}
gxMesh.setTexture(mesh: gxMesh, idx: int32, s: float32, t: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTexture'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param s: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.value: nfc(75)
.usages:
	internal usages: 1
}
gxMesh.ambient(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(76)
.usages:
	internal usages: 1
}
gxMesh.diffuse(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(77)
.usages:
	internal usages: 1
}
gxMesh.specular(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(78)
.usages:
	internal usages: 1
}
gxMesh.shine(mesh: gxMesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.value: nfc(79)
.usages:
	internal usages: 1
}
gxMesh.texture(mesh: gxMesh, surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(80)
.usages:
	internal usages: 1
}
gxMesh.clearDepth: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearDepth'
.owner: gxMesh
.value: 8
.usages:
	lib/gfxlib.ci:366: referenced as `clearDepth`
}
gxMesh.clearColor: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearColor'
.owner: gxMesh
.value: 4
.usages:
	lib/gfxlib.ci:366: referenced as `clearColor`
}
gxMesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: gxMesh
.value: 16
.usages:
	lib/gfxlib.ci:366: referenced as `cullBack`
	lib/gfxlib.ci:295: referenced as `cullBack`
}
gxMesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: gxMesh
.value: 32
.usages:
	lib/gfxlib.ci:295: referenced as `cullFront`
}
gxMesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: gxMesh
.value: 1
}
gxMesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: gxMesh
.value: 2
}
gxMesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: gxMesh
.value: 3
.usages:
	lib/gfxlib.ci:366: referenced as `drawFill`
}
gxMesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: gxMesh
.value: 3
.usages:
	lib/gfxlib.ci:298: referenced as `drawMode`
}
gxMesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: gxMesh
.value: 64
.usages:
	lib/gfxlib.ci:292: referenced as `useTexture`
}
gxMesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: gxMesh
.value: 128
.usages:
	lib/gfxlib.ci:366: referenced as `useLights`
	lib/gfxlib.ci:277: referenced as `useLights`
}
gxMesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: gxMesh
.usages:
	lib/gfxlib.ci:356: referenced as `vertices`
}
gxMesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: gxMesh
.usages:
	lib/gfxlib.ci:358: referenced as `triangles`
}
gxMesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: gxMesh
}
camera: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'camera'
.field projection: function (size: 0, cast: static const inline)
.field lookAt: function (size: 0, cast: static const inline)
.field readUp: function (size: 0, cast: static const inline)
.field readRight: function (size: 0, cast: static const inline)
.field readForward: function (size: 0, cast: static const inline)
.field rotate: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.usages:
	lib/gfxlib.ci:370: referenced as `camera`
	lib/gfxlib.ci:346: referenced as `camera`
	lib/gfxlib.ci:345: referenced as `camera`
	lib/gfxlib.ci:344: referenced as `camera`
	lib/gfxlib.ci:343: referenced as `camera`
	lib/gfxlib.ci:339: referenced as `camera`
	lib/gfxlib.ci:338: referenced as `camera`
	lib/gfxlib.ci:334: referenced as `camera`
	lib/gfxlib.ci:333: referenced as `camera`
	lib/gfxlib.ci:332: referenced as `camera`
	lib/gfxlib.ci:331: referenced as `camera`
	lib/gfxlib.ci:327: referenced as `camera`
	lib/gfxlib.ci:326: referenced as `camera`
	lib/gfxlib.ci:325: referenced as `camera`
	lib/gfxlib.ci:324: referenced as `camera`
	lib/gfxlib.ci:304: referenced as `camera`
}
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'projection'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param fovy: float32 (size: 4, cast: variable(f32))
.param aspect: float32 (size: 4, cast: variable(f32))
.param near: float32 (size: 4, cast: variable(f32))
.param far: float32 (size: 4, cast: variable(f32))
.value: nfc(114)
.usages:
	lib/gfxlib.ci:370: referenced as `projection`
	internal usages: 1
}
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lookAt'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param eye: float32[3] (size: 4, cast: variable(ref))
.param at: float32[3] (size: 4, cast: variable(ref))
.param up: float32[3] (size: 4, cast: variable(ref))
.value: nfc(115)
.usages:
	lib/gfxlib.ci:304: referenced as `lookAt`
	internal usages: 1
}
camera.readUp(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readUp'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(116)
.usages:
	lib/gfxlib.ci:345: referenced as `readUp`
	lib/gfxlib.ci:331: referenced as `readUp`
	lib/gfxlib.ci:324: referenced as `readUp`
	internal usages: 1
}
camera.readRight(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readRight'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(117)
.usages:
	lib/gfxlib.ci:343: referenced as `readRight`
	lib/gfxlib.ci:333: referenced as `readRight`
	lib/gfxlib.ci:326: referenced as `readRight`
	internal usages: 1
}
camera.readForward(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readForward'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(118)
.usages:
	lib/gfxlib.ci:338: referenced as `readForward`
	internal usages: 1
}
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rotate'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param orbit: float32[3] (size: 4, cast: variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.value: nfc(119)
.usages:
	lib/gfxlib.ci:334: referenced as `rotate`
	lib/gfxlib.ci:332: referenced as `rotate`
	lib/gfxlib.ci:327: referenced as `rotate`
	lib/gfxlib.ci:325: referenced as `rotate`
	internal usages: 1
}
camera.move(direction: float32[3], amount: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.value: nfc(120)
.usages:
	lib/gfxlib.ci:346: referenced as `move`
	lib/gfxlib.ci:344: referenced as `move`
	lib/gfxlib.ci:339: referenced as `move`
	internal usages: 1
}
lights: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'lights'
.field enabled: function (size: 0, cast: static const inline)
.field enable: function (size: 0, cast: static const inline)
.field position: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field attenuation: function (size: 0, cast: static const inline)
.usages:
	lib/gfxlib.ci:289: referenced as `lights`
	lib/gfxlib.ci:289: referenced as `lights`
	lib/gfxlib.ci:286: referenced as `lights`
	lib/gfxlib.ci:286: referenced as `lights`
	lib/gfxlib.ci:283: referenced as `lights`
	lib/gfxlib.ci:283: referenced as `lights`
	lib/gfxlib.ci:280: referenced as `lights`
	lib/gfxlib.ci:280: referenced as `lights`
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.value: nfc(121)
.usages:
	lib/gfxlib.ci:289: referenced as `enabled`
	lib/gfxlib.ci:286: referenced as `enabled`
	lib/gfxlib.ci:283: referenced as `enabled`
	lib/gfxlib.ci:280: referenced as `enabled`
	internal usages: 1
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param on: bool (size: 4, cast: variable(bool))
.value: nfc(122)
.usages:
	lib/gfxlib.ci:289: referenced as `enable`
	lib/gfxlib.ci:286: referenced as `enable`
	lib/gfxlib.ci:283: referenced as `enable`
	lib/gfxlib.ci:280: referenced as `enable`
	internal usages: 1
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(123)
.usages:
	internal usages: 1
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(124)
.usages:
	internal usages: 1
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(125)
.usages:
	internal usages: 1
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(126)
.usages:
	internal usages: 1
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param constant: float32 (size: 4, cast: variable(f32))
.param linear: float32 (size: 4, cast: variable(f32))
.param quadratic: float32 (size: 4, cast: variable(f32))
.value: nfc(127)
.usages:
	internal usages: 1
}
Gui: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Gui'
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field FINGER_PRESS: int64 (size: 0, cast: static const i64)
.field FINGER_MOTION: int64 (size: 0, cast: static const i64)
.field FINGER_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_INIT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CONTROL: int64 (size: 0, cast: static const i64)
.field showWindow: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.usages:
	lib/gfxlib.ci:482: referenced as `Gui`
	lib/gfxlib.ci:443: referenced as `Gui`
	lib/gfxlib.ci:438: referenced as `Gui`
	lib/gfxlib.ci:434: referenced as `Gui`
	lib/gfxlib.ci:419: referenced as `Gui`
	lib/gfxlib.ci:407: referenced as `Gui`
	lib/gfxlib.ci:403: referenced as `Gui`
	lib/gfxlib.ci:398: referenced as `Gui`
	lib/gfxlib.ci:386: referenced as `Gui`
	lib/gfxlib.ci:381: referenced as `Gui`
	lib/gfxlib.ci:376: referenced as `Gui`
	lib/gfxlib.ci:371: referenced as `Gui`
	lib/gfxlib.ci:361: referenced as `Gui`
	lib/gfxlib.ci:312: referenced as `Gui`
	lib/gfxlib.ci:307: referenced as `Gui`
	lib/gfxlib.ci:272: referenced as `Gui`
	lib/gfxlib.ci:270: referenced as `Gui`
	lib/gfxlib.ci:269: referenced as `Gui`
}
Gui.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Gui
.value: 1
.usages:
	lib/gfxlib.ci:438: referenced as `KEY_PRESS`
	lib/gfxlib.ci:398: referenced as `KEY_PRESS`
	lib/gfxlib.ci:272: referenced as `KEY_PRESS`
}
Gui.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Gui
.value: 2
.usages:
	lib/gfxlib.ci:443: referenced as `KEY_RELEASE`
}
Gui.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Gui
.value: 3
.usages:
	lib/gfxlib.ci:403: referenced as `MOUSE_PRESS`
	lib/gfxlib.ci:307: referenced as `MOUSE_PRESS`
}
Gui.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Gui
.value: 4
.usages:
	lib/gfxlib.ci:312: referenced as `MOUSE_MOTION`
	lib/gfxlib.ci:270: referenced as `MOUSE_MOTION`
}
Gui.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Gui
.value: 5
.usages:
	lib/gfxlib.ci:407: referenced as `MOUSE_RELEASE`
}
Gui.FINGER_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_PRESS'
.owner: Gui
.value: 6
}
Gui.FINGER_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_MOTION'
.owner: Gui
.value: 7
.usages:
	lib/gfxlib.ci:269: referenced as `FINGER_MOTION`
}
Gui.FINGER_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_RELEASE'
.owner: Gui
.value: 8
}
Gui.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Gui
.value: 10
}
Gui.WINDOW_INIT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_INIT'
.owner: Gui
.value: 100
}
Gui.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Gui
.value: 101
.usages:
	lib/gfxlib.ci:434: referenced as `WINDOW_CLOSE`
}
Gui.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Gui
.value: 102
}
Gui.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Gui
.value: 103
}
Gui.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Gui
.value: 1
}
Gui.KEY_MASK_CONTROL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CONTROL'
.owner: Gui
.value: 2
}
Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'showWindow'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param closure: pointer (size: 4, cast: variable(ref))
.param onEvent: function (size: 4, cast: variable(ref))
.value: nfc(128)
.usages:
	lib/gfxlib.ci:482: referenced as `showWindow`
	lib/gfxlib.ci:419: referenced as `showWindow`
	lib/gfxlib.ci:386: referenced as `showWindow`
	lib/gfxlib.ci:381: referenced as `showWindow`
	lib/gfxlib.ci:376: referenced as `showWindow`
	lib/gfxlib.ci:371: referenced as `showWindow`
	internal usages: 1
}
Gui.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param title: char[*] (size: 4, cast: variable(ref))
.value: nfc(129)
.usages:
	lib/gfxlib.ci:361: referenced as `setTitle`
	internal usages: 1
}
argb: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'argb'
.file: 'lib/gfx/color.ci:2'
.field v: uint32 (size: 4, cast: variable(u32))
.field <?>: argb.<?> (size: 4, cast: variable(val))
.field b: uint8 (size: 0, cast: inline)
.field g: uint8 (size: 0, cast: inline)
.field r: uint8 (size: 0, cast: inline)
.field a: uint8 (size: 0, cast: inline)
.doc: 'an 32 bit argb color'
.usages:
	lib/gfxlib.ci:135: referenced as `argb`
	lib/gfx/color.ci:183: referenced as `argb`
	lib/gfx/color.ci:182: referenced as `argb`
	lib/gfx/color.ci:178: referenced as `argb`
	lib/gfx/color.ci:175: referenced as `argb`
	lib/gfx/color.ci:175: referenced as `argb`
	lib/gfx/color.ci:166: referenced as `argb`
	lib/gfx/color.ci:166: referenced as `argb`
	lib/gfx/color.ci:166: referenced as `argb`
	lib/gfx/color.ci:163: referenced as `argb`
	lib/gfx/color.ci:161: referenced as `argb`
	lib/gfx/color.ci:159: referenced as `argb`
	lib/gfx/color.ci:157: referenced as `argb`
	lib/gfx/color.ci:155: referenced as `argb`
	lib/gfx/color.ci:105: referenced as `argb`
	lib/gfx/color.ci:103: referenced as `argb`
	lib/gfx/color.ci:2: defined as `argb`
}
argb.v: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'v'
.file: 'lib/gfx/color.ci:4'
.owner: argb
.doc: 'value of color'
.usages:
	lib/gfx/color.ci:4: defined as `v`
}
argb.<?>: argb.<?> {
.kind: variable(val)
.base: `argb.<?>`
.size: 4
.name: '<?>'
.file: 'lib/gfx/color.ci:312'
.owner: argb
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.field a: uint8 (size: 1, cast: variable(u32))
.usages:
	lib/gfx/color.ci:312: defined as `<?>`
}
argb.<?>.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'lib/gfx/color.ci:7'
.owner: argb.<?>
.doc: 'blue component'
.usages:
	lib/gfx/color.ci:7: defined as `b`
}
argb.<?>.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'lib/gfx/color.ci:10'
.owner: argb.<?>
.doc: 'green component'
.usages:
	lib/gfx/color.ci:10: defined as `g`
}
argb.<?>.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'lib/gfx/color.ci:13'
.owner: argb.<?>
.doc: 'red component'
.usages:
	lib/gfx/color.ci:13: defined as `r`
}
argb.<?>.a: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'a'
.file: 'lib/gfx/color.ci:16'
.owner: argb.<?>
.doc: 'alpha component'
.usages:
	lib/gfx/color.ci:16: defined as `a`
}
argb.b: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'b'
.file: 'lib/gfx/color.ci:7'
.owner: argb
.doc: 'blue component'
.value: b: uint8
}
argb.g: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'g'
.file: 'lib/gfx/color.ci:10'
.owner: argb
.doc: 'green component'
.value: g: uint8
}
argb.r: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'r'
.file: 'lib/gfx/color.ci:13'
.owner: argb
.doc: 'red component'
.value: r: uint8
}
argb.a: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'a'
.file: 'lib/gfx/color.ci:16'
.owner: argb
.doc: 'alpha component'
.value: a: uint8
}
argb(argb: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:103'
.param .result: argb (size: 4, cast: val)
.param argb: uint32 (size: 4, cast: u32)
.doc: 'cast unsigned integer to argb value'
.value: argb(emit(uint32(argb)))
.usages:
	lib/gfx/color.ci:288: referenced as `argb`
	lib/gfx/color.ci:287: referenced as `argb`
	lib/gfx/color.ci:286: referenced as `argb`
	lib/gfx/color.ci:285: referenced as `argb`
	lib/gfx/color.ci:281: referenced as `argb`
	lib/gfx/color.ci:280: referenced as `argb`
	lib/gfx/color.ci:279: referenced as `argb`
	lib/gfx/color.ci:278: referenced as `argb`
	lib/gfx/color.ci:266: referenced as `argb`
	lib/gfx/color.ci:265: referenced as `argb`
	lib/gfx/color.ci:264: referenced as `argb`
	lib/gfx/color.ci:263: referenced as `argb`
	lib/gfx/color.ci:142: referenced as `argb`
	lib/gfx/color.ci:140: referenced as `argb`
	lib/gfx/color.ci:128: referenced as `argb`
	lib/gfx/color.ci:103: defined as `argb(argb: uint32): argb`
}
uint32(value: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'uint32'
.file: 'lib/gfx/color.ci:105'
.param .result: uint32 (size: 4, cast: u32)
.param value: argb (size: 4, cast: val)
.doc: 'cast argb value to unsigned integer'
.value: uint32(emit(struct(value)))
.usages:
	lib/gfxlib.ci:135: referenced as `uint32`
	lib/gfx/color.ci:184: referenced as `uint32`
	lib/gfx/color.ci:161: referenced as `uint32`
	lib/gfx/color.ci:159: referenced as `uint32`
	lib/gfx/color.ci:157: referenced as `uint32`
	lib/gfx/color.ci:155: referenced as `uint32`
	lib/gfx/color.ci:105: defined as `uint32(value: argb): uint32`
}
grayClamp(c: int32): uint32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'grayClamp'
.file: 'lib/gfx/color.ci:109'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: int32 (size: 4, cast: variable(i32))
.doc: 'clamp signed gray or color component to fit in 8 bits (0 ... 255)'
.value: {
	if (c < 0) {
		return .result := 0;
	}
	if (c > 255) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (36 bytes)
	lib/gfx/color.ci:110: (12 bytes): if (c < 0)
	<grayClamp>  : dup.x32 sp(1)
	<grayClamp+?>: load.z32
	<grayClamp+?>: clt.i32
	<grayClamp+?>: jz +8
	lib/gfx/color.ci:111: (4 bytes): return .result := 0;
	<grayClamp+?>: load.z32
	<grayClamp+?>: set.x32 sp(3)
	<grayClamp+?>: ret
	lib/gfx/color.ci:113: (20 bytes): if (c > 255)
	<grayClamp+?>: dup.x32 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.i32
	<grayClamp+?>: jz +12
	lib/gfx/color.ci:114: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x32 sp(3)
	<grayClamp+?>: ret
	lib/gfx/color.ci:116: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x32 sp(2, 1)
	<grayClamp+?>: ret
.usages:
	lib/gfx/color.ci:145: referenced as `grayClamp`
	lib/gfx/color.ci:145: referenced as `grayClamp`
	lib/gfx/color.ci:145: referenced as `grayClamp`
	lib/gfx/color.ci:130: referenced as `grayClamp`
	lib/gfx/color.ci:109: defined as `grayClamp(c: int32): uint32`
}
grayClamp(c: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'grayClamp'
.file: 'lib/gfx/color.ci:119'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: uint32 (size: 4, cast: variable(u32))
.doc: 'clamp unsigned gray or color component to fit in 8 bits (0 ... 255)'
.value: {
	if (c > (255)) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (24 bytes)
	lib/gfx/color.ci:120: (20 bytes): if (c > (255))
	<grayClamp>  : dup.x32 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.u32
	<grayClamp+?>: jz +12
	lib/gfx/color.ci:121: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x32 sp(3)
	<grayClamp+?>: ret
	lib/gfx/color.ci:123: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x32 sp(2, 1)
	<grayClamp+?>: ret
.usages:
	lib/gfx/color.ci:147: referenced as `grayClamp`
	lib/gfx/color.ci:147: referenced as `grayClamp`
	lib/gfx/color.ci:147: referenced as `grayClamp`
	lib/gfx/color.ci:132: referenced as `grayClamp`
	lib/gfx/color.ci:119: defined as `grayClamp(c: uint32): uint32`
}
_gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_gray'
.file: 'lib/gfx/color.ci:128'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: variable(u32))
.value: argb((((c << 8) | c) << 8) | c)
.usages:
	lib/gfx/color.ci:132: referenced as `_gray`
	lib/gfx/color.ci:130: referenced as `_gray`
	lib/gfx/color.ci:128: defined as `_gray(c: uint32): argb`
}
gray(c: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'lib/gfx/color.ci:130'
.param .result: argb (size: 4, cast: val)
.param c: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(grayClamp(c))
.usages:
	lib/gfx/color.ci:136: referenced as `gray`
	lib/gfx/color.ci:134: referenced as `gray`
	lib/gfx/color.ci:130: defined as `gray(c: int32): argb`
}
gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'lib/gfx/color.ci:132'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(grayClamp(c))
.usages:
	lib/gfx/color.ci:132: defined as `gray(c: uint32): argb`
}
gray(c: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'lib/gfx/color.ci:134'
.param .result: argb (size: 4, cast: val)
.param c: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
	lib/gfx/color.ci:134: defined as `gray(c: float32): argb`
}
gray(c: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'lib/gfx/color.ci:136'
.param .result: argb (size: 4, cast: val)
.param c: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
	lib/gfx/color.ci:136: defined as `gray(c: float64): argb`
}
_argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'lib/gfx/color.ci:140'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((r << 8) | g) << 8) | b))
.usages:
	lib/gfx/color.ci:147: referenced as `_argb`
	lib/gfx/color.ci:145: referenced as `_argb`
	lib/gfx/color.ci:140: defined as `_argb(r: uint32, g: uint32, b: uint32): argb`
}
_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'lib/gfx/color.ci:142'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b))
.usages:
	lib/gfx/color.ci:142: defined as `_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb`
}
argb(r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:145'
.param .result: argb (size: 4, cast: val)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(grayClamp(r), grayClamp(g), grayClamp(b))
.usages:
	lib/gfx/color.ci:151: referenced as `argb`
	lib/gfx/color.ci:149: referenced as `argb`
	lib/gfx/color.ci:145: defined as `argb(r: int32, g: int32, b: int32): argb`
}
argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:147'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(grayClamp(r), grayClamp(g), grayClamp(b))
.usages:
	lib/gfx/color.ci:171: referenced as `argb`
	lib/gfx/color.ci:147: defined as `argb(r: uint32, g: uint32, b: uint32): argb`
}
argb(r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:149'
.param .result: argb (size: 4, cast: val)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	lib/gfx/color.ci:191: referenced as `argb`
	lib/gfx/color.ci:149: defined as `argb(r: float32, g: float32, b: float32): argb`
}
argb(r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:151'
.param .result: argb (size: 4, cast: val)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	lib/gfx/color.ci:151: defined as `argb(r: float64, g: float64, b: float64): argb`
}
ach(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ach'
.file: 'lib/gfx/color.ci:155'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Alpha channel of the color'
.value: uint32((uint32(col) >> 24) & (255))
.usages:
	lib/gfx/color.ci:288: referenced as `ach`
	lib/gfx/color.ci:281: referenced as `ach`
	lib/gfx/color.ci:266: referenced as `ach`
	lib/gfx/color.ci:155: defined as `ach(col: argb): uint32`
}
rch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'lib/gfx/color.ci:157'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Red channel of the color'
.value: uint32((uint32(col) >> 16) & (255))
.usages:
	lib/gfx/color.ci:287: referenced as `rch`
	lib/gfx/color.ci:280: referenced as `rch`
	lib/gfx/color.ci:265: referenced as `rch`
	lib/gfx/color.ci:168: referenced as `rch`
	lib/gfx/color.ci:168: referenced as `rch`
	lib/gfx/color.ci:163: referenced as `rch`
	lib/gfx/color.ci:157: defined as `rch(col: argb): uint32`
}
gch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'lib/gfx/color.ci:159'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Green channel of the color'
.value: uint32((uint32(col) >> 8) & (255))
.usages:
	lib/gfx/color.ci:286: referenced as `gch`
	lib/gfx/color.ci:279: referenced as `gch`
	lib/gfx/color.ci:264: referenced as `gch`
	lib/gfx/color.ci:169: referenced as `gch`
	lib/gfx/color.ci:169: referenced as `gch`
	lib/gfx/color.ci:163: referenced as `gch`
	lib/gfx/color.ci:159: defined as `gch(col: argb): uint32`
}
bch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'lib/gfx/color.ci:161'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Blue channel of the color'
.value: uint32(uint32(col) & (255))
.usages:
	lib/gfx/color.ci:285: referenced as `bch`
	lib/gfx/color.ci:278: referenced as `bch`
	lib/gfx/color.ci:263: referenced as `bch`
	lib/gfx/color.ci:170: referenced as `bch`
	lib/gfx/color.ci:170: referenced as `bch`
	lib/gfx/color.ci:163: referenced as `bch`
	lib/gfx/color.ci:161: defined as `bch(col: argb): uint32`
}
lum(c: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'lib/gfx/color.ci:163'
.param .result: uint32 (size: 4, cast: u32)
.param c: argb (size: 4, cast: variable(val))
.doc: 'get the luminosity of the color'
.value: uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8)
.usages:
	lib/gfx/color.ci:163: defined as `lum(c: argb): uint32`
}
rgbLerp16(c1: argb, c2: argb, t: uint32): argb: function {
.kind: static const function
.base: `function`
.size: 123
.name: 'rgbLerp16'
.file: 'lib/gfx/color.ci:166'
.param .result: argb (size: 4, cast: variable(val))
.param c1: argb (size: 4, cast: variable(val))
.param c2: argb (size: 4, cast: variable(val))
.param t: uint32 (size: 4, cast: variable(u32))
.doc: 'linear interpolation between `c1` and `c2` by `t`, where t is a 16 bit fixed point'
.value: {
	lerp(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
	r: uint32 := lerp(rch(c1), rch(c2));
	g: uint32 := lerp(gch(c1), gch(c2));
	b: uint32 := lerp(bch(c1), bch(c2));
	return .result := argb(r, g, b);
}
.instructions: (123 bytes)
	lib/gfx/color.ci:168: (25 bytes): r: uint32 := lerp(rch(c1), rch(c2))
	<rgbLerp16>  : dup.x32 sp(3)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(0)
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: dup.x32 sp(5)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x32 sp(1)
	lib/gfx/color.ci:169: (25 bytes): g: uint32 := lerp(gch(c1), gch(c2))
	<rgbLerp16+?>: dup.x32 sp(4)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(0)
	<rgbLerp16+?>: dup.x32 sp(4)
	<rgbLerp16+?>: dup.x32 sp(6)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x32 sp(1)
	lib/gfx/color.ci:170: (21 bytes): b: uint32 := lerp(bch(c1), bch(c2))
	<rgbLerp16+?>: dup.x32 sp(5)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(0)
	<rgbLerp16+?>: dup.x32 sp(5)
	<rgbLerp16+?>: dup.x32 sp(7)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x32 sp(1)
	lib/gfx/color.ci:171: (52 bytes): return .result := argb(r, g, b);
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x32 sp(3)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x32 sp(2)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: set.x32 sp(8)
	<rgbLerp16+?>: inc.sp(-12)
	<rgbLerp16+?>: ret
.usages:
	lib/gfx/color.ci:184: referenced as `rgbLerp16`
	lib/gfx/color.ci:175: referenced as `rgbLerp16`
	lib/gfx/color.ci:166: defined as `rgbLerp16(c1: argb, c2: argb, t: uint32): argb`
}
rgbLerp(c1: argb, c2: argb, t: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbLerp'
.file: 'lib/gfx/color.ci:175'
.param .result: argb (size: 4, cast: val)
.param c1: argb (size: 4, cast: val)
.param c2: argb (size: 4, cast: val)
.param t: float64 (size: 8, cast: f64)
.doc: 'linear interpolation between `c1` and `c2` by `t`, where t is between 0. and 1.'
.value: rgbLerp16(c1, c2, uint32(t * ((1 << 16))))
.usages:
	lib/gfx/color.ci:175: defined as `rgbLerp(c1: argb, c2: argb, t: float64): argb`
}
lerpLut(lut: uint32[], colors: argb[]): void: function {
.kind: static const function
.base: `function`
.size: 108
.name: 'lerpLut'
.file: 'lib/gfx/color.ci:178'
.param .result: void (size: 0, cast: variable(void))
.param lut: uint32[] (size: 8, cast: variable(arr))
.param colors: argb[] (size: 8, cast: parallel variable(arr))
.doc: 'linear interpolate a lookup-table with the given colors'
.value: {
	dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
	for (i: int32 := 0; i < (lut.length); i := i + 1) {
		t: int32 := i * dt;
		c1: argb := colors[t >> 16];
		c2: argb := colors[(t >> 16) + 1];
		lut[i] := uint32(rgbLerp16(c1, c2, t & 65535));
	}
}
.instructions: (108 bytes)
	lib/gfx/color.ci:179: (15 bytes): dt: int32 := (colors.length - (1) << 16) / (lut.length - (1))
	<lerpLut>  : dup.x32 sp(2)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: b32.shl 0x010
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: div.u32
	lib/gfx/color.ci:180: (88 bytes): for (i: int32 := 0; i < (lut.length); i := i + 1)
	<lerpLut+?>: load.z32
	<lerpLut+?>: jmp +74
	lib/gfx/color.ci:181: (5 bytes): t: int32 := i * dt
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: mul.i32
	lib/gfx/color.ci:182: (11 bytes): c1: argb := colors[t >> 16]
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: b32.sar 0x010
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	lib/gfx/color.ci:183: (15 bytes): c2: argb := colors[(t >> 16) + 1]
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.sar 0x010
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	lib/gfx/color.ci:184: (31 bytes): lut[i] := uint32(rgbLerp16(c1, c2, t & 65535));
	<lerpLut+?>: inc.sp(+4)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: load.ref <?> ;rgbLerp16(c1: argb, c2: argb, t: uint32): argb
	<lerpLut+?>: call
	<lerpLut+?>: inc.sp(-12)
	<lerpLut+?>: dup.x32 sp(9)
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: store.i32
	<lerpLut+?>: inc.sp(-12)
	lib/gfx/color.ci:180: (4 bytes): i := i + 1
	<lerpLut+?>: inc.i32(+1)
	lib/gfx/color.ci:180: (9 bytes): i < (lut.length)
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(7)
	<lerpLut+?>: clt.i32
	<lerpLut+?>: jnz -75
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: ret
.usages:
	lib/gfx/color.ci:178: defined as `lerpLut(lut: uint32[], colors: argb[]): void`
}
argb(vec: vec4f): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'lib/gfx/color.ci:191'
.param .result: argb (size: 4, cast: val)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'convert a floating point vector to rgb'
.value: argb(vec.x, vec.y, vec.z)
.usages:
	lib/gfxlib.ci:211: referenced as `argb`
	lib/gfx/color.ci:191: defined as `argb(vec: vec4f): argb`
}
lum(vec: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'lib/gfx/color.ci:194'
.param .result: float32 (size: 4, cast: f32)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'calculate the luminosity of a color'
.value: 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z
.usages:
	lib/gfx/color.ci:194: defined as `lum(vec: vec4f): float32`
}
hsv2rgb(hsv: vec4f): vec4f: function {
.kind: static const function
.base: `function`
.size: 368
.name: 'hsv2rgb'
.file: 'lib/gfx/color.ci:197'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsv: vec4f (size: 16, cast: variable(val))
.doc: 'convert from hsv color space to rgb color space'
.value: {
	h: float32 := hsv.x;
	s: float32 := hsv.y;
	v: float32 := hsv.z;
	if (s == (0)) {
		return .result := vec4f(v);
	}
	h := h * (360 / 60);
	i: int32 := int32(h);
	f: float32 := h - (i);
	u: float32 := v;
	p: float32 := v * ((1) - s);
	q: float32 := v * ((1) - s * f);
	t: float32 := v * ((1) - s * ((1) - f));
	if (i == 0) {
		return .result := vec4f(u, t, p);
	}
	if (i == 1) {
		return .result := vec4f(q, u, p);
	}
	if (i == 2) {
		return .result := vec4f(p, u, t);
	}
	if (i == 3) {
		return .result := vec4f(p, q, u);
	}
	if (i == 4) {
		return .result := vec4f(t, p, u);
	}
	return .result := vec4f(u, p, q);
}
.instructions: (368 bytes)
	lib/gfx/color.ci:198: (2 bytes): h: float32 := hsv.x
	<hsv2rgb>  : dup.x32 sp(1)
	lib/gfx/color.ci:199: (2 bytes): s: float32 := hsv.y
	<hsv2rgb+?>: dup.x32 sp(3)
	lib/gfx/color.ci:200: (2 bytes): v: float32 := hsv.z
	<hsv2rgb+?>: dup.x32 sp(5)
	lib/gfx/color.ci:202: (41 bytes): if (s == (0))
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.f32
	<hsv2rgb+?>: jz +37
	lib/gfx/color.ci:203: (33 bytes): return .result := vec4f(v);
	<hsv2rgb+?>: dup.x32 sp(0)
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(1)
	<hsv2rgb+?>: set.x128 sp(12)
	<hsv2rgb+?>: inc.sp(-12)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:206: (17 bytes): h := h * (360 / 60);
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: load.c32 360
	<hsv2rgb+?>: load.c32 60
	<hsv2rgb+?>: div.i32
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: set.x32 sp(3)
	lib/gfx/color.ci:208: (3 bytes): i: int32 := int32(h)
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: f32.2i32
	lib/gfx/color.ci:209: (6 bytes): f: float32 := h - (i)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: sub.f32
	lib/gfx/color.ci:211: (2 bytes): u: float32 := v
	<hsv2rgb+?>: dup.x32 sp(2)
	lib/gfx/color.ci:212: (11 bytes): p: float32 := v * ((1) - s)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	lib/gfx/color.ci:213: (14 bytes): q: float32 := v * ((1) - s * f)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	lib/gfx/color.ci:214: (20 bytes): t: float32 := v * ((1) - s * ((1) - f))
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	lib/gfx/color.ci:216: (40 bytes): if (i == 0)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +36
	lib/gfx/color.ci:217: (32 bytes): return .result := vec4f(u, t, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:219: (44 bytes): if (i == 1)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 1
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +36
	lib/gfx/color.ci:220: (32 bytes): return .result := vec4f(q, u, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:222: (44 bytes): if (i == 2)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 2
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +36
	lib/gfx/color.ci:223: (32 bytes): return .result := vec4f(p, u, t);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:225: (44 bytes): if (i == 3)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 3
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +36
	lib/gfx/color.ci:226: (32 bytes): return .result := vec4f(p, q, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: dup.x32 sp(9)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:228: (44 bytes): if (i == 4)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 4
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +36
	lib/gfx/color.ci:229: (32 bytes): return .result := vec4f(t, p, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(9)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	lib/gfx/color.ci:231: (32 bytes): return .result := vec4f(u, p, q);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
.usages:
	lib/gfx/color.ci:197: defined as `hsv2rgb(hsv: vec4f): vec4f`
}
drawLut(image: gxSurf, roi: gxRect, bars: uint32[256], lines: uint32[256]): void: function {
.kind: static const function
.base: `function`
.size: 734
.name: 'drawLut'
.file: 'lib/gfx/color.ci:236'
.param .result: void (size: 0, cast: variable(void))
.param image: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.param bars: uint32[256] (size: 4, cast: variable(ref))
.param lines: uint32[256] (size: 4, cast: variable(ref))
.doc: 'draw the given lookup table to the image'
.value: {
	rect: gxRect := {
		rect.w := (roi) != null ? roi.w : 256;
		rect.h := (roi) != null ? roi.h : 128;
		rect.y := (roi) != null ? roi.y : margin;
		rect.x := (roi) != null ? roi.x : image.width(image) - rect.w - margin;
	};
	image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	if ((bars) != null) {
		for (x: int32 := 0; x < rect.w; x := x + 1) {
			bv: int32 := bch(argb(bars[x])) * (rect.h) / (256);
			gv: int32 := gch(argb(bars[x])) * (rect.h) / (256);
			rv: int32 := rch(argb(bars[x])) * (rect.h) / (256);
			lv: int32 := ach(argb(bars[x])) * (rect.h) / (256);
			for (y: int32 := 0; y < rect.h; y := y + 1) {
				b: uint32 := colB * (uint32(y < bv));
				g: uint32 := colG * (uint32(y < gv));
				r: uint32 := colR * (uint32(y < rv));
				l: uint32 := colL * (uint32(y < lv));
				image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
			}
		}
	}
	if ((lines) != null) {
		y: int32 := rect.y + rect.h - 1;
		pb: int32 := bch(argb(lines[0])) * (rect.h) / (256);
		pg: int32 := gch(argb(lines[0])) * (rect.h) / (256);
		pr: int32 := rch(argb(lines[0])) * (rect.h) / (256);
		pl: int32 := ach(argb(lines[0])) * (rect.h) / (256);
		for (i: int32 := 1; i < rect.w; i := i + 1) {
			x: int32 := rect.x + i;
			bv: int32 := bch(argb(lines[i])) * (rect.h) / (256);
			gv: int32 := gch(argb(lines[i])) * (rect.h) / (256);
			rv: int32 := rch(argb(lines[i])) * (rect.h) / (256);
			lv: int32 := ach(argb(lines[i])) * (rect.h) / (256);
			image.drawLine(image, x - 1, y - pl, x, y - lv, colL);
			image.drawLine(image, x - 1, y - pb, x, y - bv, colB);
			image.drawLine(image, x - 1, y - pg, x, y - gv, colG);
			image.drawLine(image, x - 1, y - pr, x, y - rv, colR);
			pl := lv;
			pb := bv;
			pg := gv;
			pr := rv;
		}
	}
}
.instructions: (734 bytes)
	lib/gfx/color.ci:246: (128 bytes): rect: gxRect := {...}
	<drawLut>  : inc.sp(+16)
	lib/gfx/color.ci:247: (30 bytes): rect.w := (roi) != null ? roi.w : 256;
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +15
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: inc.i32(+8)
	<drawLut+?>: load.i32
	<drawLut+?>: jmp +9
	<drawLut+?>: load.c32 256
	<drawLut+?>: set.x32 sp(3)
	lib/gfx/color.ci:248: (30 bytes): rect.h := (roi) != null ? roi.h : 128;
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +15
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: inc.i32(+12)
	<drawLut+?>: load.i32
	<drawLut+?>: jmp +9
	<drawLut+?>: load.c32 128
	<drawLut+?>: set.x32 sp(4)
	lib/gfx/color.ci:249: (30 bytes): rect.y := (roi) != null ? roi.y : margin;
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +15
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: inc.i32(+4)
	<drawLut+?>: load.i32
	<drawLut+?>: jmp +9
	<drawLut+?>: load.c32 20
	<drawLut+?>: set.x32 sp(2)
	lib/gfx/color.ci:250: (34 bytes): rect.x := (roi) != null ? roi.x : image.width(image) - rect.w - margin;
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +11
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.i32
	<drawLut+?>: jmp +17
	<drawLut+?>: dup.x64 sp(8)
	<drawLut+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<drawLut+?>: dup.x32 sp(3)
	<drawLut+?>: sub.i32
	<drawLut+?>: inc.i32(-20)
	<drawLut+?>: set.x32 sp(1)
	lib/gfx/color.ci:253: (37 bytes): image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	<drawLut+?>: dup.x64 sp(8)
	<drawLut+?>: dup.x32 sp(2)
	<drawLut+?>: inc.i32(-7)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: inc.i32(-7)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: add.i32
	<drawLut+?>: inc.i32(+7)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: dup.x32 sp(9)
	<drawLut+?>: add.i32
	<drawLut+?>: inc.i32(+7)
	<drawLut+?>: load.z32
	<drawLut+?>: nfc(97) ;gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	lib/gfx/color.ci:261: (228 bytes): if ((bars) != null)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +220
	lib/gfx/color.ci:262: (216 bytes): for (x: int32 := 0; x < rect.w; x := x + 1)
	<drawLut+?>: load.z32
	<drawLut+?>: jmp +202
	lib/gfx/color.ci:263: (20 bytes): bv: int32 := bch(argb(bars[x])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: dup.x32 sp(1)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:264: (22 bytes): gv: int32 := gch(argb(bars[x])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: dup.x32 sp(2)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x008
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:265: (22 bytes): rv: int32 := rch(argb(bars[x])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(9)
	<drawLut+?>: dup.x32 sp(3)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x010
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:266: (22 bytes): lv: int32 := ach(argb(bars[x])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(10)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x018
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:267: (104 bytes): for (y: int32 := 0; y < rect.h; y := y + 1)
	<drawLut+?>: load.z32
	<drawLut+?>: jmp +90
	lib/gfx/color.ci:268: (11 bytes): b: uint32 := colB * (uint32(y < bv))
	<drawLut+?>: load.c32 4420038
	<drawLut+?>: dup.x32 sp(1)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: clt.i32
	<drawLut+?>: mul.i32
	lib/gfx/color.ci:269: (11 bytes): g: uint32 := colG * (uint32(y < gv))
	<drawLut+?>: load.c32 7526516
	<drawLut+?>: dup.x32 sp(2)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: clt.i32
	<drawLut+?>: mul.i32
	lib/gfx/color.ci:270: (11 bytes): r: uint32 := colR * (uint32(y < rv))
	<drawLut+?>: load.c32 16540005
	<drawLut+?>: dup.x32 sp(3)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: clt.i32
	<drawLut+?>: mul.i32
	lib/gfx/color.ci:271: (11 bytes): l: uint32 := colL * (uint32(y < lv))
	<drawLut+?>: load.c32 14342874
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: clt.i32
	<drawLut+?>: mul.i32
	lib/gfx/color.ci:272: (34 bytes): image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
	<drawLut+?>: dup.x64 sp(18)
	<drawLut+?>: dup.x32 sp(11)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: add.i32
	<drawLut+?>: dup.x32 sp(16)
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: sub.i32
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: add.i32
	<drawLut+?>: inc.i32(-1)
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: or.b32
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: or.b32
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: or.b32
	<drawLut+?>: nfc(94) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	<drawLut+?>: inc.sp(-16)
	lib/gfx/color.ci:267: (4 bytes): y := y + 1
	<drawLut+?>: inc.i32(+1)
	lib/gfx/color.ci:267: (9 bytes): y < rect.h
	<drawLut+?>: dup.x32 sp(0)
	<drawLut+?>: dup.x32 sp(10)
	<drawLut+?>: clt.i32
	<drawLut+?>: jnz -91
	<drawLut+?>: inc.sp(-4)
	<drawLut+?>: inc.sp(-16)
	lib/gfx/color.ci:262: (4 bytes): x := x + 1
	<drawLut+?>: inc.i32(+1)
	lib/gfx/color.ci:262: (9 bytes): x < rect.w
	<drawLut+?>: dup.x32 sp(0)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: clt.i32
	<drawLut+?>: jnz -203
	<drawLut+?>: inc.sp(-4)
	lib/gfx/color.ci:276: (336 bytes): if ((lines) != null)
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: load.ref <?> ;null
	<drawLut+?>: ceq.i32
	<drawLut+?>: jnz +328
	lib/gfx/color.ci:277: (9 bytes): y: int32 := rect.y + rect.h - 1
	<drawLut+?>: dup.x32 sp(1)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: add.i32
	<drawLut+?>: inc.i32(-1)
	lib/gfx/color.ci:278: (14 bytes): pb: int32 := bch(argb(lines[0])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: load.i32
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:279: (16 bytes): pg: int32 := gch(argb(lines[0])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x008
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:280: (16 bytes): pr: int32 := rch(argb(lines[0])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x010
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:281: (16 bytes): pl: int32 := ach(argb(lines[0])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(9)
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x018
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:283: (249 bytes): for (i: int32 := 1; i < rect.w; i := i + 1)
	<drawLut+?>: load.c32 1
	<drawLut+?>: jmp +231
	lib/gfx/color.ci:284: (5 bytes): x: int32 := rect.x + i
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: dup.x32 sp(1)
	<drawLut+?>: add.i32
	lib/gfx/color.ci:285: (20 bytes): bv: int32 := bch(argb(lines[i])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(12)
	<drawLut+?>: dup.x32 sp(2)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(11)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:286: (22 bytes): gv: int32 := gch(argb(lines[i])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: dup.x32 sp(3)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x008
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(12)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:287: (22 bytes): rv: int32 := rch(argb(lines[i])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(14)
	<drawLut+?>: dup.x32 sp(4)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x010
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:288: (22 bytes): lv: int32 := ach(argb(lines[i])) * (rect.h) / (256)
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: dup.x32 sp(5)
	<drawLut+?>: mad.u32 4
	<drawLut+?>: load.i32
	<drawLut+?>: b32.shr 0x018
	<drawLut+?>: b32.and 0x0ff
	<drawLut+?>: dup.x32 sp(14)
	<drawLut+?>: mul.u32
	<drawLut+?>: load.c32 256
	<drawLut+?>: div.u32
	lib/gfx/color.ci:290: (29 bytes): image.drawLine(image, x - 1, y - pl, x, y - lv, colL);
	<drawLut+?>: dup.x64 sp(19)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: inc.i32(-1)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: dup.x32 sp(10)
	<drawLut+?>: sub.i32
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: sub.i32
	<drawLut+?>: load.c32 14342874
	<drawLut+?>: nfc(100) ;gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	lib/gfx/color.ci:291: (29 bytes): image.drawLine(image, x - 1, y - pb, x, y - bv, colB);
	<drawLut+?>: dup.x64 sp(19)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: inc.i32(-1)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: sub.i32
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: dup.x32 sp(9)
	<drawLut+?>: sub.i32
	<drawLut+?>: load.c32 4420038
	<drawLut+?>: nfc(100) ;gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	lib/gfx/color.ci:292: (29 bytes): image.drawLine(image, x - 1, y - pg, x, y - gv, colG);
	<drawLut+?>: dup.x64 sp(19)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: inc.i32(-1)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: dup.x32 sp(12)
	<drawLut+?>: sub.i32
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: sub.i32
	<drawLut+?>: load.c32 7526516
	<drawLut+?>: nfc(100) ;gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	lib/gfx/color.ci:293: (29 bytes): image.drawLine(image, x - 1, y - pr, x, y - rv, colR);
	<drawLut+?>: dup.x64 sp(19)
	<drawLut+?>: dup.x32 sp(6)
	<drawLut+?>: inc.i32(-1)
	<drawLut+?>: dup.x32 sp(13)
	<drawLut+?>: dup.x32 sp(11)
	<drawLut+?>: sub.i32
	<drawLut+?>: dup.x32 sp(8)
	<drawLut+?>: dup.x32 sp(15)
	<drawLut+?>: dup.x32 sp(7)
	<drawLut+?>: sub.i32
	<drawLut+?>: load.c32 16540005
	<drawLut+?>: nfc(100) ;gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	lib/gfx/color.ci:295: (3 bytes): pl := lv;
	<drawLut+?>: mov.x32 sp(6, 0)
	lib/gfx/color.ci:296: (3 bytes): pb := bv;
	<drawLut+?>: mov.x32 sp(9, 3)
	lib/gfx/color.ci:297: (3 bytes): pg := gv;
	<drawLut+?>: mov.x32 sp(8, 2)
	lib/gfx/color.ci:298: (3 bytes): pr := rv;
	<drawLut+?>: mov.x32 sp(7, 1)
	<drawLut+?>: inc.sp(-20)
	lib/gfx/color.ci:283: (4 bytes): i := i + 1
	<drawLut+?>: inc.i32(+1)
	lib/gfx/color.ci:283: (9 bytes): i < rect.w
	<drawLut+?>: dup.x32 sp(0)
	<drawLut+?>: dup.x32 sp(9)
	<drawLut+?>: clt.i32
	<drawLut+?>: jnz -232
	<drawLut+?>: inc.sp(-4)
	<drawLut+?>: inc.sp(-20)
	<drawLut+?>: inc.sp(-16)
	<drawLut+?>: ret
.usages:
	lib/gfx/color.ci:307: referenced as `drawLut`
	lib/gfx/color.ci:236: defined as `drawLut(image: gxSurf, roi: gxRect, bars: uint32[256], lines: uint32[256]): void`
}
drawHist(image: gxSurf, roi: gxRect, hist: uint32, lut2: uint32[256]): void: function {
.kind: static const function
.base: `function`
.size: 61
.name: 'drawHist'
.file: 'lib/gfx/color.ci:304'
.param .result: void (size: 0, cast: variable(void))
.param image: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.param hist: uint32 (size: 4, cast: variable(u32))
.param lut2: uint32[256] (size: 4, cast: variable(ref))
.doc: 'calculate and draw the histogram of the image'
.value: {
	lut: uint32[256];
	image.calcHist(image, roi, hist, lut);
	drawLut(image, roi, lut, lut2);
}
.instructions: (61 bytes)
	lib/gfx/color.ci:305: (4 bytes): lut: uint32[256]
	<drawHist>  : inc.sp(+1024)
	lib/gfx/color.ci:306: (23 bytes): image.calcHist(image, roi, hist, lut);
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i64
	<drawHist+?>: load.sp(+1044)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+1044)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+16)
	<drawHist+?>: nfc(112) ;gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void
	lib/gfx/color.ci:307: (29 bytes): drawLut(image, roi, lut, lut2);
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i64
	<drawHist+?>: load.sp(+1044)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+12)
	<drawHist+?>: load.sp(+1044)
	<drawHist+?>: load.i32
	<drawHist+?>: load.ref <?> ;drawLut(image: gxSurf, roi: gxRect, bars: uint32[256], lines: uint32[256]): void
	<drawHist+?>: call
	<drawHist+?>: inc.sp(-20)
	<drawHist+?>: inc.sp(-1024)
	<drawHist+?>: ret
.usages:
	lib/gfx/color.ci:311: referenced as `drawHist`
	lib/gfx/color.ci:304: defined as `drawHist(image: gxSurf, roi: gxRect, hist: uint32, lut2: uint32[256]): void`
}
drawHist(image: gxSurf, roi: gxRect, hist: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawHist'
.file: 'lib/gfx/color.ci:311'
.param .result: void (size: 0, cast: void)
.param image: gxSurf (size: 8, cast: val)
.param roi: gxRect (size: 4, cast: ref)
.param hist: uint32 (size: 4, cast: u32)
.doc: 'calculate and draw the histogram of the image'
.value: drawHist(image, roi, hist, null)
.usages:
	lib/gfx/color.ci:311: defined as `drawHist(image: gxSurf, roi: gxRect, hist: uint32): void`
}
gxSurf(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:5'
.param .result: gxSurf (size: 8, cast: val)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create a surface with the given with, height and depth'
.value: gxSurf.create(width, height, depth)
.usages:
	lib/gfxlib.ci:478: referenced as `gxSurf`
	lib/gfxlib.ci:477: referenced as `gxSurf`
	lib/gfxlib.ci:469: referenced as `gxSurf`
	lib/gfxlib.ci:43: referenced as `gxSurf`
	lib/gfxlib.ci:5: defined as `gxSurf(width: int32, height: int32, depth: int32): gxSurf`
}
gxSurf(fileName: char[*], depth: int32): gxSurf: function {
.kind: static const function
.base: `function`
.size: 189
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:8'
.param .result: gxSurf (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: 'Create a surface by opening an image file'
.value: {
	if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".jpg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".png", ignCaseCmp)) {
		return .result := gxSurf.openPng(fileName, depth);
	}
	if (endsWith(fileName, ".bmp", ignCaseCmp)) {
		return .result := gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}
.instructions: (189 bytes)
	lib/gfxlib.ci:9: (38 bytes): if (endsWith(fileName, ".jpeg", ignCaseCmp))
	<gxSurf>  : load.z32
	<gxSurf+?>: dup.x32 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpeg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	lib/gfxlib.ci:10: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: nfc(87) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x64 sp(5)
	<gxSurf+?>: ret
	lib/gfxlib.ci:12: (38 bytes): if (endsWith(fileName, ".jpg", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x32 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	lib/gfxlib.ci:13: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: nfc(87) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x64 sp(5)
	<gxSurf+?>: ret
	lib/gfxlib.ci:15: (38 bytes): if (endsWith(fileName, ".png", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x32 sp(3)
	<gxSurf+?>: load.ref <?> ;".png"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	lib/gfxlib.ci:16: (11 bytes): return .result := gxSurf.openPng(fileName, depth);
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: nfc(86) ;gxSurf.openPng(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x64 sp(5)
	<gxSurf+?>: ret
	lib/gfxlib.ci:18: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x32 sp(3)
	<gxSurf+?>: load.ref <?> ;".bmp"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	lib/gfxlib.ci:19: (11 bytes): return .result := gxSurf.openBmp(fileName, depth);
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: dup.x32 sp(2)
	<gxSurf+?>: nfc(85) ;gxSurf.openBmp(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x64 sp(5)
	<gxSurf+?>: ret
	lib/gfxlib.ci:21: (36 bytes): abort("unknown file extension", fileName);
	<gxSurf+?>: load.ref <?> ;"lib/gfxlib.ci"
	<gxSurf+?>: load.c32 21
	<gxSurf+?>: load.c32 -2
	<gxSurf+?>: load.c32 128
	<gxSurf+?>: load.ref <?> ;"unknown file extension"
	<gxSurf+?>: load.ref <?>
	<gxSurf+?>: dup.x32 sp(8)
	<gxSurf+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxSurf+?>: ret
.usages:
	lib/gfxlib.ci:42: referenced as `gxSurf`
	lib/gfxlib.ci:25: referenced as `gxSurf`
	lib/gfxlib.ci:8: defined as `gxSurf(fileName: char[*], depth: int32): gxSurf`
}
gxSurf(fileName: char[*]): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:25'
.param .result: gxSurf (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: ref)
.doc: 'Create a surface by opening an image file'
.value: gxSurf(fileName, 32)
.usages:
	lib/gfxlib.ci:25: defined as `gxSurf(fileName: char[*]): gxSurf`
}
gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): gxSurf: function {
.kind: static const function
.base: `function`
.size: 528
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:28'
.param .result: gxSurf (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param align: int32 (size: 4, cast: variable(i32))
.param maxScale: float64 (size: 8, cast: variable(f64))
.doc: 'Create a surface by opening an image file with custom width and height'
.value: {
	scale: float64 := 1;
	surf: gxSurf := gxSurf(fileName, depth);
	result: gxSurf := gxSurf(width, height, depth);
	alignVertical: int32 := align & fitVertical;
	alignHorizontal: int32 := align & fitHorizontal;
	fitWidth: bool := alignVertical == fitVertical;
	fitHeight: bool := alignHorizontal == fitHorizontal;
	if (fitWidth && fitHeight) {
		widthScale: float64 := (width) / float64(surf.width(surf));
		heightScale: float64 := (height) / float64(surf.height(surf));
		if (align & fill) {
			scale := Math.max(widthScale, heightScale);
		}
		else {
			scale := Math.min(widthScale, heightScale);
		}
	}
	else {
		if (fitWidth) {
			scale := (width) / float64(surf.width(surf));
		}
		else {
			if (fitHeight) {
				scale := (height) / float64(surf.height(surf));
			}
		}
	}
	if (scale > maxScale) {
		scale := maxScale;
	}
	tx: float64 := 0;
	if (fitWidth || alignVertical == center) {
		tx := ((width) - (surf.width(surf)) * scale) / (2);
	}
	else {
		if (alignVertical == right) {
			tx := ((width) - (surf.width(surf)) * scale);
		}
	}
	ty: float64 := 0;
	if (fitHeight || alignHorizontal == center) {
		ty := ((height) - (surf.height(surf)) * scale) / (2);
	}
	else {
		if (alignHorizontal == bottom) {
			ty := ((height) - (surf.height(surf)) * scale);
		}
	}
	mat: mat4f := {
		mat.x.x := ((1) / scale);
		mat.x.y := (0);
		mat.x.z := (0);
		mat.x.w := (-tx / scale);
		mat.y.x := (0);
		mat.y.y := ((1) / scale);
		mat.y.z := (0);
		mat.y.w := (-ty / scale);
		mat.z.x := (0);
		mat.z.y := (0);
		mat.z.z := ((1) / scale);
		mat.z.w := (0);
		mat.w.x := (0);
		mat.w.y := (0);
		mat.w.z := (0);
		mat.w.w := (1);
	};
	result.transform(result, null, surf, null, (align & highRes) ? 1 : 0, mat.data);
	surf.destroy(surf);
	return .result := result;
}
.instructions: (528 bytes)
	lib/gfxlib.ci:41: (9 bytes): scale: float64 := 1
	<gxSurf>  : load.f64 1.000000
	lib/gfxlib.ci:42: (18 bytes): surf: gxSurf := gxSurf(fileName, depth)
	<gxSurf+?>: inc.sp(+8)
	<gxSurf+?>: dup.x32 sp(11)
	<gxSurf+?>: dup.x32 sp(9)
	<gxSurf+?>: load.ref <?> ;gxSurf(fileName: char[*], depth: int32): gxSurf
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-8)
	lib/gfxlib.ci:43: (10 bytes): result: gxSurf := gxSurf(width, height, depth)
	<gxSurf+?>: dup.x32 sp(10)
	<gxSurf+?>: dup.x32 sp(10)
	<gxSurf+?>: dup.x32 sp(10)
	<gxSurf+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	lib/gfxlib.ci:45: (4 bytes): alignVertical: int32 := align & fitVertical
	<gxSurf+?>: dup.x32 sp(9)
	<gxSurf+?>: b32.and 0x003
	lib/gfxlib.ci:46: (8 bytes): alignHorizontal: int32 := align & fitHorizontal
	<gxSurf+?>: dup.x32 sp(10)
	<gxSurf+?>: load.c32 12
	<gxSurf+?>: and.b32
	lib/gfxlib.ci:48: (8 bytes): fitWidth: bool := alignVertical == fitVertical
	<gxSurf+?>: dup.x32 sp(1)
	<gxSurf+?>: load.c32 3
	<gxSurf+?>: ceq.i32
	lib/gfxlib.ci:49: (8 bytes): fitHeight: bool := alignHorizontal == fitHorizontal
	<gxSurf+?>: dup.x32 sp(1)
	<gxSurf+?>: load.c32 12
	<gxSurf+?>: ceq.i32
	lib/gfxlib.ci:51: (143 bytes): if (fitWidth && fitHeight)
	<gxSurf+?>: load.sp(+4)
	<gxSurf+?>: load.i8
	<gxSurf+?>: load.sp(+4)
	<gxSurf+?>: load.i8
	<gxSurf+?>: and.b32
	<gxSurf+?>: jz +84
	lib/gfxlib.ci:52: (11 bytes): widthScale: float64 := (width) / float64(surf.width(surf))
	<gxSurf+?>: dup.x32 sp(16)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(8)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: div.f64
	lib/gfxlib.ci:53: (11 bytes): heightScale: float64 := (height) / float64(surf.height(surf))
	<gxSurf+?>: dup.x32 sp(17)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(10)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: div.f64
	lib/gfxlib.ci:54: (50 bytes): if (align & fill)
	<gxSurf+?>: dup.x32 sp(17)
	<gxSurf+?>: load.c32 16
	<gxSurf+?>: and.b32
	<gxSurf+?>: jz +25
	lib/gfxlib.ci:55: (17 bytes): scale := Math.max(widthScale, heightScale);
	<gxSurf+?>: load.z64
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: load.ref <?> ;Math.max(a: float64, b: float64): float64
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-16)
	<gxSurf+?>: set.x64 sp(14)
	<gxSurf+?>: jmp +21
	lib/gfxlib.ci:57: (17 bytes): scale := Math.min(widthScale, heightScale);
	<gxSurf+?>: load.z64
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: load.ref <?> ;Math.min(a: float64, b: float64): float64
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-16)
	<gxSurf+?>: set.x64 sp(14)
	<gxSurf+?>: inc.sp(-16)
	<gxSurf+?>: jmp +52
	lib/gfxlib.ci:60: (48 bytes): if (fitWidth)
	<gxSurf+?>: load.sp(+4)
	<gxSurf+?>: load.i8
	<gxSurf+?>: jz +21
	lib/gfxlib.ci:61: (13 bytes): scale := (width) / float64(surf.width(surf));
	<gxSurf+?>: dup.x32 sp(16)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(8)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: div.f64
	<gxSurf+?>: set.x64 sp(10)
	<gxSurf+?>: jmp +26
	lib/gfxlib.ci:63: (22 bytes): if (fitHeight)
	<gxSurf+?>: load.sp(+0)
	<gxSurf+?>: load.i8
	<gxSurf+?>: jz +17
	lib/gfxlib.ci:64: (13 bytes): scale := (height) / float64(surf.height(surf));
	<gxSurf+?>: dup.x32 sp(15)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(8)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: div.f64
	<gxSurf+?>: set.x64 sp(10)
	lib/gfxlib.ci:66: (12 bytes): if (scale > maxScale)
	<gxSurf+?>: dup.x64 sp(8)
	<gxSurf+?>: dup.x64 sp(13)
	<gxSurf+?>: cgt.f64
	<gxSurf+?>: jz +7
	lib/gfxlib.ci:67: (3 bytes): scale := maxScale;
	<gxSurf+?>: mov.x64 sp(8, 11)
	lib/gfxlib.ci:71: (1 byte): tx: float64 := 0
	<gxSurf+?>: load.z64
	lib/gfxlib.ci:72: (72 bytes): if (fitWidth || alignVertical == center)
	<gxSurf+?>: load.sp(+12)
	<gxSurf+?>: load.i8
	<gxSurf+?>: dup.x32 sp(6)
	<gxSurf+?>: load.z32
	<gxSurf+?>: ceq.i32
	<gxSurf+?>: or.b32
	<gxSurf+?>: jz +34
	lib/gfxlib.ci:73: (26 bytes): tx := ((width) - (surf.width(surf)) * scale) / (2);
	<gxSurf+?>: dup.x32 sp(18)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(10)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(14)
	<gxSurf+?>: mul.f64
	<gxSurf+?>: sub.f64
	<gxSurf+?>: load.f64 2.000000
	<gxSurf+?>: div.f64
	<gxSurf+?>: set.x64 sp(2)
	<gxSurf+?>: jmp +32
	lib/gfxlib.ci:75: (28 bytes): if (alignVertical == right)
	<gxSurf+?>: dup.x32 sp(5)
	<gxSurf+?>: load.c32 2
	<gxSurf+?>: ceq.i32
	<gxSurf+?>: jz +20
	lib/gfxlib.ci:76: (16 bytes): tx := ((width) - (surf.width(surf)) * scale);
	<gxSurf+?>: dup.x32 sp(18)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(10)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(14)
	<gxSurf+?>: mul.f64
	<gxSurf+?>: sub.f64
	<gxSurf+?>: set.x64 sp(2)
	lib/gfxlib.ci:79: (1 byte): ty: float64 := 0
	<gxSurf+?>: load.z64
	lib/gfxlib.ci:80: (72 bytes): if (fitHeight || alignHorizontal == center)
	<gxSurf+?>: load.sp(+16)
	<gxSurf+?>: load.i8
	<gxSurf+?>: dup.x32 sp(7)
	<gxSurf+?>: load.z32
	<gxSurf+?>: ceq.i32
	<gxSurf+?>: or.b32
	<gxSurf+?>: jz +34
	lib/gfxlib.ci:81: (26 bytes): ty := ((height) - (surf.height(surf)) * scale) / (2);
	<gxSurf+?>: dup.x32 sp(19)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(12)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(16)
	<gxSurf+?>: mul.f64
	<gxSurf+?>: sub.f64
	<gxSurf+?>: load.f64 2.000000
	<gxSurf+?>: div.f64
	<gxSurf+?>: set.x64 sp(2)
	<gxSurf+?>: jmp +32
	lib/gfxlib.ci:83: (28 bytes): if (alignHorizontal == bottom)
	<gxSurf+?>: dup.x32 sp(6)
	<gxSurf+?>: load.c32 8
	<gxSurf+?>: ceq.i32
	<gxSurf+?>: jz +20
	lib/gfxlib.ci:84: (16 bytes): ty := ((height) - (surf.height(surf)) * scale);
	<gxSurf+?>: dup.x32 sp(19)
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(12)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(16)
	<gxSurf+?>: mul.f64
	<gxSurf+?>: sub.f64
	<gxSurf+?>: set.x64 sp(2)
	lib/gfxlib.ci:87: (104 bytes): mat: mat4f := {...}
	<gxSurf+?>: inc.sp(+64)
	lib/gfxlib.ci:88: (15 bytes): mat.x.x := ((1) / scale);
	<gxSurf+?>: load.f64 1.000000
	<gxSurf+?>: dup.x64 sp(30)
	<gxSurf+?>: div.f64
	<gxSurf+?>: f64.2f32
	<gxSurf+?>: set.x32 sp(1)
	lib/gfxlib.ci:88: (3 bytes): mat.x.y := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(2)
	lib/gfxlib.ci:88: (3 bytes): mat.x.z := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(3)
	lib/gfxlib.ci:88: (9 bytes): mat.x.w := (-tx / scale);
	<gxSurf+?>: dup.x64 sp(18)
	<gxSurf+?>: neg.f64
	<gxSurf+?>: dup.x64 sp(30)
	<gxSurf+?>: div.f64
	<gxSurf+?>: f64.2f32
	<gxSurf+?>: set.x32 sp(4)
	lib/gfxlib.ci:89: (3 bytes): mat.y.x := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(5)
	lib/gfxlib.ci:89: (15 bytes): mat.y.y := ((1) / scale);
	<gxSurf+?>: load.f64 1.000000
	<gxSurf+?>: dup.x64 sp(30)
	<gxSurf+?>: div.f64
	<gxSurf+?>: f64.2f32
	<gxSurf+?>: set.x32 sp(6)
	lib/gfxlib.ci:89: (3 bytes): mat.y.z := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(7)
	lib/gfxlib.ci:89: (9 bytes): mat.y.w := (-ty / scale);
	<gxSurf+?>: dup.x64 sp(16)
	<gxSurf+?>: neg.f64
	<gxSurf+?>: dup.x64 sp(30)
	<gxSurf+?>: div.f64
	<gxSurf+?>: f64.2f32
	<gxSurf+?>: set.x32 sp(8)
	lib/gfxlib.ci:90: (3 bytes): mat.z.x := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(9)
	lib/gfxlib.ci:90: (3 bytes): mat.z.y := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(10)
	lib/gfxlib.ci:90: (15 bytes): mat.z.z := ((1) / scale);
	<gxSurf+?>: load.f64 1.000000
	<gxSurf+?>: dup.x64 sp(30)
	<gxSurf+?>: div.f64
	<gxSurf+?>: f64.2f32
	<gxSurf+?>: set.x32 sp(11)
	lib/gfxlib.ci:90: (3 bytes): mat.z.w := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(12)
	lib/gfxlib.ci:91: (3 bytes): mat.w.x := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(13)
	lib/gfxlib.ci:91: (3 bytes): mat.w.y := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(14)
	lib/gfxlib.ci:91: (3 bytes): mat.w.z := (0);
	<gxSurf+?>: load.z32
	<gxSurf+?>: set.x32 sp(15)
	lib/gfxlib.ci:91: (7 bytes): mat.w.w := (1);
	<gxSurf+?>: load.f32 1.000000
	<gxSurf+?>: set.x32 sp(16)
	lib/gfxlib.ci:94: (44 bytes): result.transform(result, null, surf, null, (align & highRes) ? 1 : 0, mat.data);
	<gxSurf+?>: dup.x64 sp(24)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: dup.x64 sp(29)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: dup.x32 sp(39)
	<gxSurf+?>: load.c32 32
	<gxSurf+?>: and.b32
	<gxSurf+?>: jz +13
	<gxSurf+?>: load.c32 1
	<gxSurf+?>: jmp +5
	<gxSurf+?>: load.z32
	<gxSurf+?>: load.sp(+28)
	<gxSurf+?>: nfc(107) ;gxSurf.transform(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32, mat: float32[16]): void
	lib/gfxlib.ci:95: (6 bytes): surf.destroy(surf);
	<gxSurf+?>: dup.x64 sp(26)
	<gxSurf+?>: nfc(84) ;gxSurf.destroy(surf: gxSurf): void
	lib/gfxlib.ci:96: (8 bytes): return .result := result;
	<gxSurf+?>: mov.x64 sp(38, 24)
	<gxSurf+?>: inc.sp(-120)
	<gxSurf+?>: ret
.usages:
	lib/gfxlib.ci:103: referenced as `gxSurf`
	lib/gfxlib.ci:100: referenced as `gxSurf`
	lib/gfxlib.ci:28: defined as `gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): gxSurf`
}
gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:100'
.param .result: gxSurf (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.param align: int32 (size: 4, cast: i32)
.doc: 'Create a surface by opening an image file with custom width and height'
.value: gxSurf(fileName, width, height, depth, align, Math.inf)
.usages:
	lib/gfxlib.ci:100: defined as `gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): gxSurf`
}
gxSurf(fileName: char[*], width: int32, height: int32, depth: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:103'
.param .result: gxSurf (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create a surface by opening an image file with custom width and height'
.value: gxSurf(fileName, width, height, depth, -1, Math.inf)
.usages:
	lib/gfxlib.ci:103: defined as `gxSurf(fileName: char[*], width: int32, height: int32, depth: int32): gxSurf`
}
gxMesh(fileName: char[*]): gxMesh: function {
.kind: static const function
.base: `function`
.size: 109
.name: 'gxMesh'
.file: 'lib/gfxlib.ci:106'
.param .result: gxMesh (size: 4, cast: variable(ref))
.param fileName: char[*] (size: 4, cast: variable(ref))
.doc: 'Create a mesh by opening a file'
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := gxMesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (109 bytes)
	lib/gfxlib.ci:107: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<gxMesh>  : load.z32
	<gxMesh+?>: dup.x32 sp(2)
	<gxMesh+?>: load.ref <?> ;".obj"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	lib/gfxlib.ci:108: (9 bytes): return .result := gxMesh.openObj(fileName);
	<gxMesh+?>: dup.x32 sp(1)
	<gxMesh+?>: nfc(66) ;gxMesh.openObj(path: char[*]): gxMesh
	<gxMesh+?>: set.x32 sp(3)
	<gxMesh+?>: ret
	lib/gfxlib.ci:110: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<gxMesh+?>: load.z32
	<gxMesh+?>: dup.x32 sp(2)
	<gxMesh+?>: load.ref <?> ;".3ds"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	lib/gfxlib.ci:111: (9 bytes): return .result := gxMesh.open3ds(fileName);
	<gxMesh+?>: dup.x32 sp(1)
	<gxMesh+?>: nfc(67) ;gxMesh.open3ds(path: char[*]): gxMesh
	<gxMesh+?>: set.x32 sp(3)
	<gxMesh+?>: ret
	lib/gfxlib.ci:113: (36 bytes): abort("unknown file extension", fileName);
	<gxMesh+?>: load.ref <?> ;"lib/gfxlib.ci"
	<gxMesh+?>: load.c32 113
	<gxMesh+?>: load.c32 -2
	<gxMesh+?>: load.c32 128
	<gxMesh+?>: load.ref <?> ;"unknown file extension"
	<gxMesh+?>: load.ref <?>
	<gxMesh+?>: dup.x32 sp(7)
	<gxMesh+?>: nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxMesh+?>: ret
.usages:
	lib/gfxlib.ci:106: defined as `gxMesh(fileName: char[*]): gxMesh`
}
gxSurf(copy: gxSurf): gxSurf: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:117'
.param .result: gxSurf (size: 8, cast: variable(val))
.param copy: gxSurf (size: 8, cast: variable(val))
.doc: 'Create a surface by cloning another one'
.value: {
	result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
	result.copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (40 bytes)
	lib/gfxlib.ci:118: (22 bytes): result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy))
	<gxSurf>  : dup.x64 sp(1)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: dup.x64 sp(2)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: dup.x64 sp(3)
	<gxSurf+?>: nfc(92) ;gxSurf.depth(surf: gxSurf): int32
	<gxSurf+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	lib/gfxlib.ci:119: (15 bytes): result.copy(result, 0, 0, copy, null);
	<gxSurf+?>: dup.x64 sp(0)
	<gxSurf+?>: load.z32
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x64 sp(7)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: nfc(105) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	lib/gfxlib.ci:120: (3 bytes): return .result := result;
	<gxSurf+?>: set.x64 sp(5)
	<gxSurf+?>: ret
.usages:
	lib/gfxlib.ci:415: referenced as `gxSurf`
	lib/gfxlib.ci:117: defined as `gxSurf(copy: gxSurf): gxSurf`
}
gxSurf(copy: gxSurf, aspect: float64): gxSurf: function {
.kind: static const function
.base: `function`
.size: 80
.name: 'gxSurf'
.file: 'lib/gfxlib.ci:124'
.param .result: gxSurf (size: 8, cast: variable(val))
.param copy: gxSurf (size: 8, cast: variable(val))
.param aspect: float64 (size: 8, cast: variable(f64))
.doc: 'Create a surface by cloning another one using a custom aspect ratio'
.value: {
	width: int32 := copy.width(copy);
	if (aspect > (0)) {
		width := ((copy.height(copy)) * aspect);
	}
	result: gxSurf := gxSurf.create(width, copy.height(copy), copy.depth(copy));
	result.transform(result, null, copy, null, 1, null);
	return .result := result;
}
.instructions: (80 bytes)
	lib/gfxlib.ci:125: (6 bytes): width: int32 := copy.width(copy)
	<gxSurf>  : dup.x64 sp(3)
	<gxSurf+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	lib/gfxlib.ci:126: (21 bytes): if (aspect > (0))
	<gxSurf+?>: dup.x64 sp(2)
	<gxSurf+?>: load.z64
	<gxSurf+?>: cgt.f64
	<gxSurf+?>: jz +17
	lib/gfxlib.ci:127: (13 bytes): width := ((copy.height(copy)) * aspect);
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: i32.2f64
	<gxSurf+?>: dup.x64 sp(4)
	<gxSurf+?>: mul.f64
	<gxSurf+?>: f64.2i32
	<gxSurf+?>: set.x32 sp(1)
	lib/gfxlib.ci:129: (18 bytes): result: gxSurf := gxSurf.create(width, copy.height(copy), copy.depth(copy))
	<gxSurf+?>: dup.x32 sp(0)
	<gxSurf+?>: dup.x64 sp(5)
	<gxSurf+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: dup.x64 sp(6)
	<gxSurf+?>: nfc(92) ;gxSurf.depth(surf: gxSurf): int32
	<gxSurf+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	lib/gfxlib.ci:130: (28 bytes): result.transform(result, null, copy, null, 1, null);
	<gxSurf+?>: dup.x64 sp(0)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: dup.x64 sp(9)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: load.c32 1
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: nfc(107) ;gxSurf.transform(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32, mat: float32[16]): void
	lib/gfxlib.ci:131: (7 bytes): return .result := result;
	<gxSurf+?>: set.x64 sp(8)
	<gxSurf+?>: inc.sp(-4)
	<gxSurf+?>: ret
.usages:
	lib/gfxlib.ci:124: defined as `gxSurf(copy: gxSurf, aspect: float64): gxSurf`
}
set(dst: gxSurf, x: int32, y: int32, color: argb): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'set'
.file: 'lib/gfxlib.ci:135'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param x: int32 (size: 4, cast: i32)
.param y: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'Set the the color of a pixel at the given position'
.value: gxSurf.set(dst, x, y, uint32(color))
.usages:
	lib/gfxlib.ci:211: referenced as `set`
	lib/gfxlib.ci:135: defined as `set(dst: gxSurf, x: int32, y: int32, color: argb): void`
}
resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'resize'
.file: 'lib/gfxlib.ci:138'
.param .result: void (size: 0, cast: void)
.param surf: gxSurf (size: 8, cast: val)
.param rect: gxRect (size: 4, cast: const ref)
.param src: gxSurf (size: 8, cast: const val)
.param roi: gxRect (size: 4, cast: const ref)
.param interpolate: int32 (size: 4, cast: i32)
.doc: '@public'
.value: gxSurf.transform(surf, rect, src, roi, interpolate, null)
.usages:
	lib/gfxlib.ci:461: referenced as `resize`
	lib/gfxlib.ci:138: defined as `resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void`
}
clip(src: gxSurf, roi: gxRect): bool: function {
.kind: static const function
.base: `function`
.size: 235
.name: 'clip'
.file: 'lib/gfxlib.ci:141'
.param .result: bool (size: 4, cast: variable(bool))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	roi.w := roi.w + roi.x;
	roi.h := roi.h + roi.y;
	if (roi.x < 0) {
		roi.x := 0;
	}
	if (roi.y < 0) {
		roi.y := 0;
	}
	width: int32 := src.width(src);
	if (roi.w > width) {
		roi.w := width;
	}
	height: int32 := src.height(src);
	if (roi.h > height) {
		roi.h := height;
	}
	roi.w := roi.w - roi.x;
	roi.h := roi.h - roi.y;
	if (roi.w <= 0) {
		return .result := false;
	}
	if (roi.h <= 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (235 bytes)
	lib/gfxlib.ci:143: (18 bytes): roi.w := roi.w + roi.x;
	<clip>  : dup.x32 sp(1)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	lib/gfxlib.ci:144: (22 bytes): roi.h := roi.h + roi.y;
	<clip+?>: dup.x32 sp(1)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	lib/gfxlib.ci:146: (13 bytes): if (roi.x < 0)
	<clip+?>: dup.x32 sp(1)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +8
	lib/gfxlib.ci:147: (4 bytes): roi.x := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: store.i32
	lib/gfxlib.ci:150: (21 bytes): if (roi.y < 0)
	<clip+?>: dup.x32 sp(1)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +12
	lib/gfxlib.ci:151: (8 bytes): roi.y := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: store.i32
	lib/gfxlib.ci:154: (6 bytes): width: int32 := src.width(src)
	<clip+?>: dup.x64 sp(2)
	<clip+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	lib/gfxlib.ci:155: (23 bytes): if (roi.w > width)
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	lib/gfxlib.ci:156: (9 bytes): roi.w := width;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	lib/gfxlib.ci:159: (6 bytes): height: int32 := src.height(src)
	<clip+?>: dup.x64 sp(3)
	<clip+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	lib/gfxlib.ci:160: (23 bytes): if (roi.h > height)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	lib/gfxlib.ci:161: (9 bytes): roi.h := height;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	lib/gfxlib.ci:164: (18 bytes): roi.w := roi.w - roi.x;
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	lib/gfxlib.ci:165: (22 bytes): roi.h := roi.h - roi.y;
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	lib/gfxlib.ci:167: (24 bytes): if (roi.w <= 0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	lib/gfxlib.ci:168: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	lib/gfxlib.ci:170: (24 bytes): if (roi.h <= 0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	lib/gfxlib.ci:171: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	lib/gfxlib.ci:173: (15 bytes): return .result := true;
	<clip+?>: load.c32 1
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
.usages:
	lib/gfxlib.ci:225: referenced as `clip`
	lib/gfxlib.ci:195: referenced as `clip`
	lib/gfxlib.ci:141: defined as `clip(src: gxSurf, roi: gxRect): bool`
}
fill(dst: gxSurf, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'lib/gfxlib.ci:177'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param col: uint32 (size: 4, cast: u32)
.doc: 'Fill the entire surface with the given color'
.value: dst.fillRect(dst, 0, 0, 65536, 65536, col)
.usages:
	lib/gfxlib.ci:177: defined as `fill(dst: gxSurf, col: uint32): void`
}
fill(dst: gxSurf, roi: gxRect, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'lib/gfxlib.ci:179'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param roi: gxRect (size: 4, cast: const variable(ref))
.param col: uint32 (size: 4, cast: u32)
.doc: 'Fill the given region with the given color'
.value: dst.fillRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col)
.usages:
	lib/gfxlib.ci:179: defined as `fill(dst: gxSurf, roi: gxRect, col: uint32): void`
}
fill(dst: gxSurf, roi: gxRect, pad: int32, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'lib/gfxlib.ci:181'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param roi: gxRect (size: 4, cast: const variable(ref))
.param pad: int32 (size: 4, cast: variable(i32))
.param col: uint32 (size: 4, cast: u32)
.doc: 'Fill the given region and padding with the given color'
.value: dst.fillRect(dst, roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, col)
.usages:
	lib/gfxlib.ci:181: defined as `fill(dst: gxSurf, roi: gxRect, pad: int32, col: uint32): void`
}
drawRect(dst: gxSurf, roi: gxRect, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawRect'
.file: 'lib/gfxlib.ci:184'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param roi: gxRect (size: 4, cast: const variable(ref))
.param col: uint32 (size: 4, cast: u32)
.doc: '@public'
.value: dst.drawRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col)
.usages:
	lib/gfxlib.ci:184: defined as `drawRect(dst: gxSurf, roi: gxRect, col: uint32): void`
}
eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 353
.name: 'eval'
.file: 'lib/gfxlib.ci:187'
.param .result: void (size: 0, cast: variable(void))
.param dst: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param aspect: float32 (size: 4, cast: variable(f32))
.param time: float32 (size: 4, cast: variable(f32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Fill the surface by evaluating the given function for each pixel'
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : dst.width(dst);
		rect.h := (roi) != null ? roi.h : dst.height(dst);
	};
	if (!clip(dst, rect)) {
		return;
	}
	in: vec4f := {
		in.x := (0);
		in.y := (0);
		in.z := aspect;
		in.w := time;
	};
	w: float32 := dst.width(dst);
	h: float32 := dst.height(dst);
	for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
			in.x := (x) / w;
			set(dst, x, y, argb(eval(in)));
		}
	}
}
.instructions: (353 bytes)
	lib/gfxlib.ci:188: (114 bytes): rect: gxRect := {...}
	<eval>  : inc.sp(+16)
	lib/gfxlib.ci:189: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +11
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(1)
	lib/gfxlib.ci:190: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(2)
	lib/gfxlib.ci:191: (31 bytes): rect.w := (roi) != null ? roi.w : dst.width(dst);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: set.x32 sp(3)
	lib/gfxlib.ci:192: (31 bytes): rect.h := (roi) != null ? roi.h : dst.height(dst);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: set.x32 sp(4)
	lib/gfxlib.ci:195: (26 bytes): if (!clip(dst, rect))
	<eval+?>: load.z32
	<eval+?>: dup.x64 sp(10)
	<eval+?>: load.sp(+12)
	<eval+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<eval+?>: call
	<eval+?>: inc.sp(-12)
	<eval+?>: jnz +9
	lib/gfxlib.ci:196: (5 bytes): return;
	<eval+?>: inc.sp(-16)
	<eval+?>: ret
	lib/gfxlib.ci:199: (16 bytes): in: vec4f := {...}
	<eval+?>: inc.sp(+16)
	lib/gfxlib.ci:200: (3 bytes): in.x := (0);
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(1)
	lib/gfxlib.ci:201: (3 bytes): in.y := (0);
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(2)
	lib/gfxlib.ci:202: (3 bytes): in.z := aspect;
	<eval+?>: mov.x32 sp(2, 11)
	lib/gfxlib.ci:203: (3 bytes): in.w := time;
	<eval+?>: mov.x32 sp(3, 10)
	lib/gfxlib.ci:205: (7 bytes): w: float32 := dst.width(dst)
	<eval+?>: dup.x64 sp(13)
	<eval+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: i32.2f32
	lib/gfxlib.ci:206: (7 bytes): h: float32 := dst.height(dst)
	<eval+?>: dup.x64 sp(14)
	<eval+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: i32.2f32
	lib/gfxlib.ci:207: (178 bytes): for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +160
	lib/gfxlib.ci:208: (8 bytes): in.y := (y) / h;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(2)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(5)
	lib/gfxlib.ci:209: (144 bytes): for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +126
	lib/gfxlib.ci:210: (8 bytes): in.x := (x) / w;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(4)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(5)
	lib/gfxlib.ci:211: (110 bytes): set(dst, x, y, argb(eval(in)));
	<eval+?>: dup.x64 sp(17)
	<eval+?>: dup.x32 sp(2)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.sp(+16)
	<eval+?>: dup.x128 sp(12)
	<eval+?>: dup.x32 sp(25)
	<eval+?>: call
	<eval+?>: inc.sp(-16)
	<eval+?>: load.sp(+0)
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(1)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(2)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(2)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: set.x32 sp(5)
	<eval+?>: inc.sp(-16)
	<eval+?>: nfc(94) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	lib/gfxlib.ci:209: (4 bytes): x := x + 1
	<eval+?>: inc.i32(+1)
	lib/gfxlib.ci:209: (12 bytes): x < rect.x + rect.w
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(9)
	<eval+?>: dup.x32 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -130
	<eval+?>: inc.sp(-4)
	lib/gfxlib.ci:207: (4 bytes): y := y + 1
	<eval+?>: inc.i32(+1)
	lib/gfxlib.ci:207: (12 bytes): y < rect.y + rect.h
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(9)
	<eval+?>: dup.x32 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -164
	<eval+?>: inc.sp(-4)
	<eval+?>: inc.sp(-40)
	<eval+?>: ret
.usages:
	lib/gfxlib.ci:470: referenced as `eval`
	lib/gfxlib.ci:460: referenced as `eval`
	lib/gfxlib.ci:446: referenced as `eval`
	lib/gfxlib.ci:187: defined as `eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void`
}
tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const function
.base: `function`
.size: 251
.name: 'tile'
.file: 'lib/gfxlib.ci:217'
.param .result: void (size: 0, cast: variable(void))
.param dst: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : src.width(src);
		rect.h := (roi) != null ? roi.h : src.height(src);
	};
	if (!clip(src, rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % rect.w);
	}
	if (y < 0) {
		y := -(-y % rect.h);
	}
	width: int32 := dst.width(dst);
	height: int32 := dst.height(dst);
	for (j: int32 := y; j < height; j := j + rect.h) {
		for (i: int32 := x; i < width; i := i + rect.w) {
			dst.copy(dst, i, j, src, rect);
		}
	}
}
.instructions: (251 bytes)
	lib/gfxlib.ci:218: (114 bytes): rect: gxRect := {...}
	<tile>  : inc.sp(+16)
	lib/gfxlib.ci:219: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +11
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(1)
	lib/gfxlib.ci:220: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(2)
	lib/gfxlib.ci:221: (31 bytes): rect.w := (roi) != null ? roi.w : src.width(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	<tile+?>: set.x32 sp(3)
	lib/gfxlib.ci:222: (31 bytes): rect.h := (roi) != null ? roi.h : src.height(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	<tile+?>: set.x32 sp(4)
	lib/gfxlib.ci:225: (26 bytes): if (!clip(src, rect))
	<tile+?>: load.z32
	<tile+?>: dup.x64 sp(7)
	<tile+?>: load.sp(+12)
	<tile+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<tile+?>: call
	<tile+?>: inc.sp(-12)
	<tile+?>: jnz +9
	lib/gfxlib.ci:226: (5 bytes): return;
	<tile+?>: inc.sp(-16)
	<tile+?>: ret
	lib/gfxlib.ci:229: (17 bytes): if (x < 0)
	<tile+?>: dup.x32 sp(9)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	lib/gfxlib.ci:230: (9 bytes): x := -(-x % rect.w);
	<tile+?>: dup.x32 sp(9)
	<tile+?>: neg.i32
	<tile+?>: dup.x32 sp(3)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(10)
	lib/gfxlib.ci:232: (17 bytes): if (y < 0)
	<tile+?>: dup.x32 sp(8)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	lib/gfxlib.ci:233: (9 bytes): y := -(-y % rect.h);
	<tile+?>: dup.x32 sp(8)
	<tile+?>: neg.i32
	<tile+?>: dup.x32 sp(4)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(9)
	lib/gfxlib.ci:235: (6 bytes): width: int32 := dst.width(dst)
	<tile+?>: dup.x64 sp(10)
	<tile+?>: nfc(90) ;gxSurf.width(surf: gxSurf): int32
	lib/gfxlib.ci:236: (6 bytes): height: int32 := dst.height(dst)
	<tile+?>: dup.x64 sp(11)
	<tile+?>: nfc(91) ;gxSurf.height(surf: gxSurf): int32
	lib/gfxlib.ci:237: (60 bytes): for (j: int32 := y; j < height; j := j + rect.h)
	<tile+?>: dup.x32 sp(10)
	<tile+?>: jmp +45
	lib/gfxlib.ci:238: (38 bytes): for (i: int32 := x; i < width; i := i + rect.w)
	<tile+?>: dup.x32 sp(12)
	<tile+?>: jmp +23
	lib/gfxlib.ci:239: (16 bytes): dst.copy(dst, i, j, src, rect);
	<tile+?>: dup.x64 sp(14)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: dup.x64 sp(14)
	<tile+?>: load.sp(+40)
	<tile+?>: nfc(105) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	lib/gfxlib.ci:238: (3 bytes): i := i + rect.w
	<tile+?>: dup.x32 sp(6)
	<tile+?>: add.i32
	lib/gfxlib.ci:238: (9 bytes): i < width
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: clt.i32
	<tile+?>: jnz -24
	<tile+?>: inc.sp(-4)
	lib/gfxlib.ci:237: (3 bytes): j := j + rect.h
	<tile+?>: dup.x32 sp(6)
	<tile+?>: add.i32
	lib/gfxlib.ci:237: (9 bytes): j < height
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: clt.i32
	<tile+?>: jnz -46
	<tile+?>: inc.sp(-4)
	<tile+?>: inc.sp(-24)
	<tile+?>: ret
.usages:
	lib/gfxlib.ci:217: defined as `tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void`
}
show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void: function {
.kind: static const function
.base: `function`
.size: 118
.name: 'show'
.file: 'lib/gfxlib.ci:245'
.param .result: void (size: 0, cast: variable(void))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param fovy: float32 (size: 4, cast: variable(f32))
.doc: 'Show the mesh in a window'
.value: {
	static const Closure: struct {
		mode: int32;
		offs: gxSurf;
		mesh: gxMesh;
	};
	static const next(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const speed: float32 := 1.000000 / (100);
		if ((action) == Gui.FINGER_MOTION) {
			action := (Gui.MOUSE_MOTION);
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
			else {
				if (button == ('l')) {
					closure.mode := ((closure.mode) ^ gxMesh.useLights);
				}
				else {
					if (button == ('0')) {
						lights.enable(0, !lights.enabled(0));
					}
					else {
						if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else {
							if (button == ('2')) {
								lights.enable(2, !lights.enabled(2));
							}
							else {
								if (button == ('3')) {
									lights.enable(3, !lights.enabled(3));
								}
								else {
									if (button == ('t')) {
										closure.mode := ((closure.mode) ^ gxMesh.useTexture);
									}
									else {
										if (button == ('/')) {
											closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
										}
										else {
											if (button == ('\t')) {
												closure.mode := next(closure.mode, gxMesh.drawMode);
											}
											else {
												if (button == ('\r')) {
													eye: vec4f := {
														eye.x := (0);
														eye.y := (0);
														eye.z := (2);
														eye.w := (1);
													};
													at: vec4f := {
														at.x := (0);
														at.y := (0);
														at.z := (0);
														at.w := (1);
													};
													up: vec4f := {
														up.x := (0);
														up.y := (1);
														up.z := (0);
														up.w := (1);
													};
													camera.lookAt(eye.data, at.data, up.data);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else {
			if ((action) == Gui.MOUSE_PRESS) {
				ox := ex;
				oy := ey;
				return .result := 0;
			}
			else {
				if ((action) == Gui.MOUSE_MOTION) {
					dir: float32[3];
					dx: int32 := ex - ox;
					dy: int32 := ey - oy;
					if (button == 1) {
						orig: float32[3];
						orig[0] := (0);
						orig[1] := (0);
						orig[2] := (0);
						camera.readUp(dir);
						camera.rotate(dir, orig, (dx) * speed);
						camera.readRight(dir);
						camera.rotate(dir, orig, (dy) * speed);
					}
					else {
						if (button == 2) {
							camera.readUp(dir);
							camera.rotate(dir, null, (-dx) * speed);
							camera.readRight(dir);
							camera.rotate(dir, null, (-dy) * speed);
						}
						else {
							if (button == 3) {
								camera.readForward(dir);
								camera.move(dir, (dy) * speed);
							}
							else {
								if (button == 4) {
									camera.readRight(dir);
									camera.move(dir, (-dx) * speed);
									camera.readUp(dir);
									camera.move(dir, (dy) * speed);
								}
							}
						}
					}
					ox := ex;
					oy := ey;
				}
			}
		}
		rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
		text: char[256];
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, closure.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, closure.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		Gui.setTitle(text);
		return .result := 0;
	};
	closure: Closure := {
		closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
		closure.offs := gxSurf.create3d(w, h);
		closure.mesh := mesh;
	};
	camera.projection(fovy, (w) / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy(closure.offs);
}
.instructions: (118 bytes)
	lib/gfxlib.ci:365: (69 bytes): closure: Closure := {...}
	<show>  : inc.sp(+24)
	lib/gfxlib.ci:366: (52 bytes): closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
	<show+?>: load.c64 8
	<show+?>: load.c64 4
	<show+?>: or.b64
	<show+?>: load.c64 128
	<show+?>: or.b64
	<show+?>: load.c64 16
	<show+?>: or.b64
	<show+?>: load.c64 3
	<show+?>: or.b64
	<show+?>: i64.2i32
	<show+?>: set.x32 sp(1)
	lib/gfxlib.ci:367: (10 bytes): closure.offs := gxSurf.create3d(w, h);
	<show+?>: dup.x32 sp(9)
	<show+?>: dup.x32 sp(9)
	<show+?>: nfc(82) ;gxSurf.create3d(width: int32, height: int32): gxSurf
	<show+?>: set.x64 sp(4)
	lib/gfxlib.ci:368: (3 bytes): closure.mesh := mesh;
	<show+?>: mov.x32 sp(4, 10)
	lib/gfxlib.ci:370: (23 bytes): camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>: dup.x32 sp(7)
	<show+?>: dup.x32 sp(10)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(10)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 100.000000
	<show+?>: nfc(114) ;camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
	lib/gfxlib.ci:371: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	lib/gfxlib.ci:372: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x64 sp(2)
	<show+?>: nfc(84) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
	lib/gfxlib.ci:245: defined as `show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void`
}
show(surf: gxSurf): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'show'
.file: 'lib/gfxlib.ci:376'
.param .result: void (size: 0, cast: void)
.param surf: gxSurf (size: 8, cast: val)
.doc: 'Show the surface in a window'
.value: Gui.showWindow(surf, null, null)
.usages:
	lib/gfxlib.ci:376: defined as `show(surf: gxSurf): void`
}
show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static const function
.base: `function`
.size: 43
.name: 'show'
.file: 'lib/gfxlib.ci:379'
.param .result: void (size: 0, cast: variable(void))
.param surf: gxSurf (size: 8, cast: variable(val))
.param onEvent: function (size: 4, cast: variable(ref))
.doc: 'Show the surface in a window'
.value: {
	if ((onEvent) == null) {
		return .result := Gui.showWindow(surf, null, null);
	}
	static const delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Gui.showWindow(surf, onEvent, delegate);
}
.instructions: (43 bytes)
	lib/gfxlib.ci:380: (29 bytes): if ((onEvent) == null)
	<show>  : dup.x32 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: ceq.i32
	<show+?>: jz +21
	lib/gfxlib.ci:381: (17 bytes): return .result := Gui.showWindow(surf, null, null);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(128) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
	lib/gfxlib.ci:386: (13 bytes): Gui.showWindow(surf, onEvent, delegate);
	<show+?>: dup.x64 sp(2)
	<show+?>: dup.x32 sp(3)
	<show+?>: load.ref <?> ;show.delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
.usages:
	lib/gfxlib.ci:471: referenced as `show`
	lib/gfxlib.ci:379: defined as `show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void`
}
showDiff(image1: gxSurf, image2: gxSurf): void: function {
.kind: static const function
.base: `function`
.size: 48
.name: 'showDiff'
.file: 'lib/gfxlib.ci:390'
.param .result: void (size: 0, cast: variable(void))
.param image1: gxSurf (size: 8, cast: variable(val))
.param image2: gxSurf (size: 8, cast: variable(val))
.doc: 'Show the surfaces in a window clicking on the window toggles the shown surface'
.value: {
	static const Closure: struct {
		offs: gxSurf;
		image1: gxSurf;
		image2: gxSurf;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.MOUSE_PRESS) {
			closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
			return .result := 0;
		}
		if ((action) == Gui.MOUSE_RELEASE) {
			closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
			return .result := 0;
		}
		return .result := 0;
	};
	closure: Closure := {
		closure.offs := gxSurf(image1);
		closure.image1 := image1;
		closure.image2 := image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}
.instructions: (48 bytes)
	lib/gfxlib.ci:414: (28 bytes): closure: Closure := {...}
	<showDiff>  : inc.sp(+24)
	lib/gfxlib.ci:415: (18 bytes): closure.offs := gxSurf(image1);
	<showDiff+?>: inc.sp(+8)
	<showDiff+?>: dup.x64 sp(11)
	<showDiff+?>: load.ref <?> ;gxSurf(copy: gxSurf): gxSurf
	<showDiff+?>: call
	<showDiff+?>: inc.sp(-8)
	<showDiff+?>: set.x64 sp(2)
	lib/gfxlib.ci:416: (3 bytes): closure.image1 := image1;
	<showDiff+?>: mov.x64 sp(2, 9)
	lib/gfxlib.ci:417: (3 bytes): closure.image2 := image2;
	<showDiff+?>: mov.x64 sp(4, 7)
	lib/gfxlib.ci:419: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showDiff+?>: dup.x64 sp(0)
	<showDiff+?>: load.sp(+8)
	<showDiff+?>: load.ref <?> ;showDiff.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showDiff+?>: nfc(128) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<showDiff+?>: inc.sp(-24)
	<showDiff+?>: ret
.usages:
	lib/gfxlib.ci:390: defined as `showDiff(image1: gxSurf, image2: gxSurf): void`
}
show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 170
.name: 'show'
.file: 'lib/gfxlib.ci:423'
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param animationResolution: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Show or animate the the procedural image generated by the `eval` function'
.value: {
	static const start: int64 := System.millis();
	static const Closure: struct {
		lerp: bool := true;
		const offs: gxSurf;
		const thumb: gxSurf;
		const aspect: float32;
		const eval(in: vec4f): vec4f;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return .result := 0;
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.KEY_RELEASE) {
			if (button == (' ')) {
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.offs, null, closure.aspect, time, closure.eval);
				return .result := 0;
			}
			if (button == ('\t')) {
				closure.lerp := !closure.lerp;
			}
			if (button == ('S')) {
				trace("dumping screen");
				closure.offs.saveBmp(closure.offs, "out/offs.bmp", 0);
				closure.thumb.saveBmp(closure.thumb, "out/thumb.bmp", 0);
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(closure.thumb, null, closure.aspect, time, closure.eval);
		resize(closure.offs, null, closure.thumb, null, closure.lerp ? 1 : 0);
		return .result := 1;
	};
	if (animationResolution == 0) {
		aspect: float32 := (width) / float32(height);
		surf: gxSurf := gxSurf(width, height, 32);
		eval(surf, null, aspect, 0.000000, eval);
		show(surf, null);
		surf.destroy(surf);
		return;
	}
	closure: Closure := {
		closure.offs := gxSurf(width, height, 32);
		closure.thumb := gxSurf(animationResolution, animationResolution, 32);
		closure.aspect := (width) / float32(height);
		closure.eval := eval;
		closure.lerp := true;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy(closure.thumb);
	closure.offs.destroy(closure.offs);
}
.instructions: (170 bytes)
	lib/gfxlib.ci:467: (82 bytes): if (animationResolution == 0)
	<show>  : dup.x32 sp(2)
	<show+?>: load.z32
	<show+?>: ceq.i32
	<show+?>: jz +78
	lib/gfxlib.ci:468: (7 bytes): aspect: float32 := (width) / float32(height)
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: div.f32
	lib/gfxlib.ci:469: (13 bytes): surf: gxSurf := gxSurf(width, height, 32)
	<show+?>: dup.x32 sp(5)
	<show+?>: dup.x32 sp(5)
	<show+?>: load.c32 32
	<show+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	lib/gfxlib.ci:470: (22 bytes): eval(surf, null, aspect, 0.000000, eval);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: dup.x32 sp(5)
	<show+?>: load.z32
	<show+?>: dup.x32 sp(9)
	<show+?>: load.ref <?> ;eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	lib/gfxlib.ci:471: (17 bytes): show(surf, null);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void
	<show+?>: call
	<show+?>: inc.sp(-12)
	lib/gfxlib.ci:472: (6 bytes): surf.destroy(surf);
	<show+?>: dup.x64 sp(0)
	<show+?>: nfc(84) ;gxSurf.destroy(surf: gxSurf): void
	lib/gfxlib.ci:473: (5 bytes): return;
	<show+?>: inc.sp(-12)
	<show+?>: ret
	<show+?>: inc.sp(-12)
	lib/gfxlib.ci:476: (56 bytes): closure: Closure := {...}
	<show+?>: inc.sp(+32)
	lib/gfxlib.ci:477: (15 bytes): closure.offs := gxSurf(width, height, 32);
	<show+?>: dup.x32 sp(12)
	<show+?>: dup.x32 sp(12)
	<show+?>: load.c32 32
	<show+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<show+?>: set.x64 sp(4)
	lib/gfxlib.ci:478: (15 bytes): closure.thumb := gxSurf(animationResolution, animationResolution, 32);
	<show+?>: dup.x32 sp(10)
	<show+?>: dup.x32 sp(11)
	<show+?>: load.c32 32
	<show+?>: nfc(81) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<show+?>: set.x64 sp(6)
	lib/gfxlib.ci:479: (9 bytes): closure.aspect := (width) / float32(height);
	<show+?>: dup.x32 sp(12)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(12)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: set.x32 sp(7)
	lib/gfxlib.ci:480: (3 bytes): closure.eval := eval;
	<show+?>: mov.x32 sp(7, 9)
	:: (10 bytes): closure.lerp := true
	<show+?>: load.c32 1
	<show+?>: load.sp(+4)
	<show+?>: store.i8
	lib/gfxlib.ci:482: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	lib/gfxlib.ci:483: (6 bytes): closure.thumb.destroy(closure.thumb);
	<show+?>: dup.x64 sp(4)
	<show+?>: nfc(84) ;gxSurf.destroy(surf: gxSurf): void
	lib/gfxlib.ci:484: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x64 sp(2)
	<show+?>: nfc(84) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>: inc.sp(-32)
	<show+?>: ret
.usages:
	lib/gfxlib.ci:423: defined as `show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void`
}
.main: function {
.kind: static function
.base: `function`
.size: 98
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, cast: static const i64)
.field RAND_MAX: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field true: bool (size: 1, cast: static const val)
.field false: bool (size: 1, cast: static const val)
.field byte: typename (size: 0, cast: inline)
.field float: typename (size: 0, cast: inline)
.field double: typename (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 32, cast: static const typename(val))
.field assertEq: function (size: 94, cast: static const function)
.field assertEq: function (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field Math: typename (size: 0, cast: static const typename(void))
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static const function)
.field Complex: function (size: 7, cast: static const function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 123, cast: static const function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static const function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 100, cast: static const function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 13, cast: static const function)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field length: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static const function)
.field mat4f: function (size: 21, cast: static const function)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field mul: function (size: 417, cast: static const function)
.field rotation: function (size: 524, cast: static const function)
.field rotation: function (size: 0, cast: inline)
.field translation: function (size: 88, cast: static const function)
.field scale: function (size: 217, cast: static const function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static const function)
.field sub: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field length: function (size: 38, cast: static const function)
.field indexOf: function (size: 50, cast: static const function)
.field lastIndexOf: function (size: 50, cast: static const function)
.field startsWith: function (size: 73, cast: static const function)
.field endsWith: function (size: 126, cast: static const function)
.field compare: function (size: 63, cast: static const function)
.field ignCaseCmp: function (size: 36, cast: static const function)
.field caseCmp: function (size: 14, cast: static const function)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 84, cast: static const function)
.field append: function (size: 707, cast: static const function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 227, cast: static const function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 63, cast: static const function)
.field File: typename (size: 8, cast: static const typename(val))
.field gxRect: typename (size: 16, cast: static const typename(val))
.field gxSurf: typename (size: 8, cast: static const typename(val))
.field gxMesh: typename (size: 176, cast: static const typename(ref))
.field camera: typename (size: 0, cast: static const typename(void))
.field lights: typename (size: 0, cast: static const typename(void))
.field Gui: typename (size: 0, cast: static const typename(void))
.field argb: typename (size: 4, cast: static const typename(val))
.field argb: function (size: 0, cast: inline)
.field uint32: function (size: 0, cast: inline)
.field grayClamp: function (size: 36, cast: static const function)
.field grayClamp: function (size: 24, cast: static const function)
.field _gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field ach: function (size: 0, cast: inline)
.field rch: function (size: 0, cast: inline)
.field gch: function (size: 0, cast: inline)
.field bch: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field rgbLerp16: function (size: 123, cast: static const function)
.field rgbLerp: function (size: 0, cast: inline)
.field lerpLut: function (size: 108, cast: static const function)
.field argb: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field hsv2rgb: function (size: 368, cast: static const function)
.field drawLut: function (size: 734, cast: static const function)
.field drawHist: function (size: 61, cast: static const function)
.field drawHist: function (size: 0, cast: inline)
.field gxSurf: function (size: 0, cast: inline)
.field gxSurf: function (size: 189, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxSurf: function (size: 528, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxSurf: function (size: 0, cast: inline)
.field gxMesh: function (size: 109, cast: static const function)
.field gxSurf: function (size: 40, cast: static const function)
.field gxSurf: function (size: 80, cast: static const function)
.field set: function (size: 0, cast: inline)
.field resize: function (size: 0, cast: inline)
.field clip: function (size: 235, cast: static const function)
.field fill: function (size: 0, cast: inline)
.field fill: function (size: 0, cast: inline)
.field fill: function (size: 0, cast: inline)
.field drawRect: function (size: 0, cast: inline)
.field eval: function (size: 353, cast: static const function)
.field tile: function (size: 251, cast: static const function)
.field show: function (size: 118, cast: static const function)
.field show: function (size: 0, cast: inline)
.field show: function (size: 43, cast: static const function)
.field showDiff: function (size: 48, cast: static const function)
.field show: function (size: 170, cast: static const function)
.field .main: function (size: 98, cast: static function)
.value: {
	{
		byte: typename := uint8;
		float: typename := float32;
		double: typename := float64;
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.message := (message);
					details.argument := (null);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(x, result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static sign(x: float32): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: float64): int32 := int32(x > (0)) - int32(x < (0));
			static const abs(x: float32): float32 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const abs(x: float64): float64 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static const min(a: float32, b: float32): float32 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const min(a: float64, b: float64): float64 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float32, b: float32): float32 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float64, b: float64): float64 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static lerp(t: float32, a: float32, b: float32): float32 := a + t * (b - a);
			static lerp(t: float64, a: float64, b: float64): float64 := a + t * (b - a);
			static smooth(t: float32): float32 := t * t * ((3) - (2) * t);
			static smooth(t: float64): float64 := t * t * ((3) - (2) * t);
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp((t - a) / (b - a), float32(0), float32(1)));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp((t - a) / (b - a), float64(0), float64(1)));
			static const min(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result > data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const max(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result < data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (data.length); i := i + 1) {
					result := result + data[i];
				}
				return .result := result;
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (a0 + x * a1);
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (a0 + x * eval(x, a1, a2));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (a0 + x * eval(x, a1, a2, a3));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else {
					if (i == 1) {
						x := (1) - x;
						complement := true;
					}
					else {
						if (i == 2) {
							negate := !negate;
							complement := true;
						}
						else {
							if (i == 3) {
								x := (1) - x;
								negate := !negate;
							}
						}
					}
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static const asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static radians(degrees: float64): float64 := float64(degrees * pi / (180));
			static degrees(radians: float64): float64 := float64(radians * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static const Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(-a.re, -a.im);
		add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static const div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static const inv(a: Complex): Complex := {
			d: float64 := (a.re * a.re + a.im * a.im);
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const vec4f: struct {
			data: float32[4];
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
		};
		static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
			return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
		};
		vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 1.000000);
		vec4f(x: float32, y: float32): vec4f := vec4f(x, y, 0.000000, 1.000000);
		vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
		vec4f(val: float32): vec4f := vec4f(val, val, val, val);
		neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
		add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
		sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
		mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
		div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
		min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), min.p4f));
		max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), max.p4f));
		dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp3));
		dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dph));
		dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp4));
		cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
		length(v: vec4f): float32 := float32.sqrt(dp3(v, v));
		normalize(const v: vec4f): vec4f := div(v, vec4f(length(v)));
		eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		static const mat4f: struct {
			data: float32[16];
			m: float32[4][4];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
		};
		static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
		};
		dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
		dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
		dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
		static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := {
				transposed.x.x := rhs.x.x;
				transposed.x.y := rhs.y.x;
				transposed.x.z := rhs.z.x;
				transposed.x.w := rhs.w.x;
				transposed.y.x := rhs.x.y;
				transposed.y.y := rhs.y.y;
				transposed.y.z := rhs.z.y;
				transposed.y.w := rhs.w.y;
				transposed.z.x := rhs.x.z;
				transposed.z.y := rhs.y.z;
				transposed.z.z := rhs.z.z;
				transposed.z.w := rhs.w.z;
				transposed.w.x := rhs.x.w;
				transposed.w.y := rhs.y.w;
				transposed.w.z := rhs.z.w;
				transposed.w.w := rhs.w.w;
			};
			return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
		};
		static const rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if ((len) < 0.000000) {
				trace("invalid direction of rotation", direction);
				return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
			}
			x: float32 := direction.x / len;
			y: float32 := direction.y / len;
			z: float32 := direction.z / len;
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := x * x;
			xy: float32 := x * y;
			xz: float32 := x * z;
			yy: float32 := y * y;
			yz: float32 := y * z;
			zz: float32 := z * z;
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := (1) - c;
			return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		rotation(const direction: vec4f, angle: float32): mat4f := rotation(vec4f(0), direction, angle);
		static const translation(const direction: vec4f, amount: float32): mat4f := {
			return .result := {
			.result.x.x := (1);
			.result.x.y := (0);
			.result.x.z := (0);
			.result.x.w := direction.x * amount;
			.result.y.x := (0);
			.result.y.y := (1);
			.result.y.z := (0);
			.result.y.w := direction.y * amount;
			.result.z.x := (0);
			.result.z.y := (0);
			.result.z.z := (1);
			.result.z.w := direction.z * amount;
			.result.w.x := (0);
			.result.w.y := (0);
			.result.w.z := (0);
			.result.w.w := (1);
		};
		};
		static const scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
			return .result := {
			.result.x.x := rcp(direction.x * amount);
			.result.x.y := (0);
			.result.x.z := (0);
			.result.x.w := (0);
			.result.y.x := (0);
			.result.y.y := rcp(direction.y * amount);
			.result.y.z := (0);
			.result.y.w := (0);
			.result.z.x := (0);
			.result.z.y := (0);
			.result.z.z := rcp(direction.z * amount);
			.result.z.w := (0);
			.result.w.x := (0);
			.result.w.y := (0);
			.result.w.z := (0);
			.result.w.w := (1);
		};
		};
		static const vec2d: struct {
			data: float64[2];
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
		};
		static const vec2d(x: float64, y: float64): vec2d := {
			return .result := {
			.result.x := x;
			.result.y := y;
		};
		};
		sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
		dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		static const length(str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(str: char[*], with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(str: char[*], with: char[*]): int32 := compare(str, with, caseCmp);
		contains(str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			if (format.showSign) {
				if ((sign) == 0) {
					sign := '+';
				}
			}
			radix: int32 := format.precision;
			if (radix == 0) {
				radix := 10;
			}
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: int64, format: FormatFlags): int32 := append(output, pos, value < (0) ? ('-') : 0, uint64(value < (0) ? -value : value), format);
		append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := append(output, pos, value < 0 ? ('-') : 0, uint64(value < 0 ? -value : value), format);
		append(output: char[], pos: int32, value: int16, format: FormatFlags): int32 := append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format);
		append(output: char[], pos: int32, value: int8, format: FormatFlags): int32 := append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format);
		static const append(output: char[], pos: int32, value: float64, format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				formatInt.showSign := format.showSign;
				formatInt.precision := 0;
				formatInt.padChr := format.padChr;
				formatInt.padLen := format.padLen - format.precision;
			};
			formatDec: FormatFlags := {
				formatDec.showSign := false;
				formatDec.precision := 0;
				formatDec.padChr := '0';
				formatDec.padLen := format.precision;
			};
			sign: char := value < (0) ? ('-') : 0;
			fract: float64 := Math.modf(Math.abs(value), value);
			pos := append(output, pos, sign, uint64(value), formatInt);
			pos := append(output, pos, ".");
			fract := fract * float64.pow(10, format.precision);
			pos := append(output, pos, 0, uint64(fract), formatDec);
			return .result := pos;
		};
		append(output: char[], pos: int32, value: float32, format: FormatFlags): int32 := append(output, pos, float64(value), format);
		static const append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				format.showSign := false;
				format.precision := 0;
				format.padChr := (0);
				format.padLen := 0;
			};
			return .result := append(output, pos, value, format);
		};
	}
	{
		static const gxRect: struct {
			x: int32;
			y: int32;
			w: int32;
			h: int32;
		};
	}
	{
		static const argb: struct {
			v: uint32;
			<?>: <?>;
			b: uint8 := b: uint8;
			g: uint8 := g: uint8;
			r: uint8 := r: uint8;
			a: uint8 := a: uint8;
		};
		argb(argb: uint32): argb := argb(emit(uint32(argb)));
		uint32(value: argb): uint32 := uint32(emit(struct(value)));
		static const grayClamp(c: int32): uint32 := {
			if (c < 0) {
				return .result := 0;
			}
			if (c > 255) {
				return .result := 255;
			}
			return .result := c;
		};
		static const grayClamp(c: uint32): uint32 := {
			if (c > (255)) {
				return .result := 255;
			}
			return .result := c;
		};
		_gray(c: uint32): argb := argb((((c << 8) | c) << 8) | c);
		gray(c: int32): argb := _gray(grayClamp(c));
		gray(c: uint32): argb := _gray(grayClamp(c));
		gray(c: float32): argb := gray(int32(c * (255)));
		gray(c: float64): argb := gray(int32(c * (255)));
		_argb(r: uint32, g: uint32, b: uint32): argb := argb(uint32((((r << 8) | g) << 8) | b));
		_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));
		argb(r: int32, g: int32, b: int32): argb := _argb(grayClamp(r), grayClamp(g), grayClamp(b));
		argb(r: uint32, g: uint32, b: uint32): argb := _argb(grayClamp(r), grayClamp(g), grayClamp(b));
		argb(r: float32, g: float32, b: float32): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(r: float64, g: float64, b: float64): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		ach(col: argb): uint32 := uint32((uint32(col) >> 24) & (255));
		rch(col: argb): uint32 := uint32((uint32(col) >> 16) & (255));
		gch(col: argb): uint32 := uint32((uint32(col) >> 8) & (255));
		bch(col: argb): uint32 := uint32(uint32(col) & (255));
		lum(c: argb): uint32 := uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8);
		static const rgbLerp16(c1: argb, c2: argb, t: uint32): argb := {
			lerp(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
			r: uint32 := lerp(rch(c1), rch(c2));
			g: uint32 := lerp(gch(c1), gch(c2));
			b: uint32 := lerp(bch(c1), bch(c2));
			return .result := argb(r, g, b);
		};
		rgbLerp(c1: argb, c2: argb, t: float64): argb := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
		static const lerpLut(lut: uint32[], colors: argb[]): void := {
			dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
			for (i: int32 := 0; i < (lut.length); i := i + 1) {
				t: int32 := i * dt;
				c1: argb := colors[t >> 16];
				c2: argb := colors[(t >> 16) + 1];
				lut[i] := uint32(rgbLerp16(c1, c2, t & 65535));
			}
		};
		static if ((typename(vec4f)) != null) {
			argb(const vec: vec4f): argb := argb(vec.x, vec.y, vec.z);
			lum(const vec: vec4f): float32 := 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z;
			static const hsv2rgb(hsv: vec4f): vec4f := {
				h: float32 := hsv.x;
				s: float32 := hsv.y;
				v: float32 := hsv.z;
				if (s == (0)) {
					return .result := vec4f(v);
				}
				h := h * (360 / 60);
				i: int32 := int32(h);
				f: float32 := h - (i);
				u: float32 := v;
				p: float32 := v * ((1) - s);
				q: float32 := v * ((1) - s * f);
				t: float32 := v * ((1) - s * ((1) - f));
				if (i == 0) {
					return .result := vec4f(u, t, p);
				}
				if (i == 1) {
					return .result := vec4f(q, u, p);
				}
				if (i == 2) {
					return .result := vec4f(p, u, t);
				}
				if (i == 3) {
					return .result := vec4f(p, q, u);
				}
				if (i == 4) {
					return .result := vec4f(t, p, u);
				}
				return .result := vec4f(u, p, q);
			};
		}
		static const drawLut(image: gxSurf, roi: gxRect, bars: uint32[256], lines: uint32[256]): void := {
			rect: gxRect := {
				rect.w := (roi) != null ? roi.w : 256;
				rect.h := (roi) != null ? roi.h : 128;
				rect.y := (roi) != null ? roi.y : margin;
				rect.x := (roi) != null ? roi.x : image.width(image) - rect.w - margin;
			};
			image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
			if ((bars) != null) {
				for (x: int32 := 0; x < rect.w; x := x + 1) {
					bv: int32 := bch(argb(bars[x])) * (rect.h) / (256);
					gv: int32 := gch(argb(bars[x])) * (rect.h) / (256);
					rv: int32 := rch(argb(bars[x])) * (rect.h) / (256);
					lv: int32 := ach(argb(bars[x])) * (rect.h) / (256);
					for (y: int32 := 0; y < rect.h; y := y + 1) {
						b: uint32 := colB * (uint32(y < bv));
						g: uint32 := colG * (uint32(y < gv));
						r: uint32 := colR * (uint32(y < rv));
						l: uint32 := colL * (uint32(y < lv));
						image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
					}
				}
			}
			if ((lines) != null) {
				y: int32 := rect.y + rect.h - 1;
				pb: int32 := bch(argb(lines[0])) * (rect.h) / (256);
				pg: int32 := gch(argb(lines[0])) * (rect.h) / (256);
				pr: int32 := rch(argb(lines[0])) * (rect.h) / (256);
				pl: int32 := ach(argb(lines[0])) * (rect.h) / (256);
				for (i: int32 := 1; i < rect.w; i := i + 1) {
					x: int32 := rect.x + i;
					bv: int32 := bch(argb(lines[i])) * (rect.h) / (256);
					gv: int32 := gch(argb(lines[i])) * (rect.h) / (256);
					rv: int32 := rch(argb(lines[i])) * (rect.h) / (256);
					lv: int32 := ach(argb(lines[i])) * (rect.h) / (256);
					image.drawLine(image, x - 1, y - pl, x, y - lv, colL);
					image.drawLine(image, x - 1, y - pb, x, y - bv, colB);
					image.drawLine(image, x - 1, y - pg, x, y - gv, colG);
					image.drawLine(image, x - 1, y - pr, x, y - rv, colR);
					pl := lv;
					pb := bv;
					pg := gv;
					pr := rv;
				}
			}
		};
		static const drawHist(image: gxSurf, roi: gxRect, hist: uint32, lut2: uint32[256]): void := {
			lut: uint32[256];
			image.calcHist(image, roi, hist, lut);
			drawLut(image, roi, lut, lut2);
		};
		drawHist(image: gxSurf, roi: gxRect, hist: uint32): void := drawHist(image, roi, hist, null);
		gxSurf(width: int32, height: int32, depth: int32): gxSurf := gxSurf.create(width, height, depth);
		static const gxSurf(fileName: char[*], depth: int32): gxSurf := {
			if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".jpg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".png", ignCaseCmp)) {
				return .result := gxSurf.openPng(fileName, depth);
			}
			if (endsWith(fileName, ".bmp", ignCaseCmp)) {
				return .result := gxSurf.openBmp(fileName, depth);
			}
			abort("unknown file extension", fileName);
		};
		gxSurf(fileName: char[*]): gxSurf := gxSurf(fileName, 32);
		static const gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): gxSurf := {
			scale: float64 := 1;
			surf: gxSurf := gxSurf(fileName, depth);
			result: gxSurf := gxSurf(width, height, depth);
			alignVertical: int32 := align & fitVertical;
			alignHorizontal: int32 := align & fitHorizontal;
			fitWidth: bool := alignVertical == fitVertical;
			fitHeight: bool := alignHorizontal == fitHorizontal;
			if (fitWidth && fitHeight) {
				widthScale: float64 := (width) / float64(surf.width(surf));
				heightScale: float64 := (height) / float64(surf.height(surf));
				if (align & fill) {
					scale := Math.max(widthScale, heightScale);
				}
				else {
					scale := Math.min(widthScale, heightScale);
				}
			}
			else {
				if (fitWidth) {
					scale := (width) / float64(surf.width(surf));
				}
				else {
					if (fitHeight) {
						scale := (height) / float64(surf.height(surf));
					}
				}
			}
			if (scale > maxScale) {
				scale := maxScale;
			}
			tx: float64 := 0;
			if (fitWidth || alignVertical == center) {
				tx := ((width) - (surf.width(surf)) * scale) / (2);
			}
			else {
				if (alignVertical == right) {
					tx := ((width) - (surf.width(surf)) * scale);
				}
			}
			ty: float64 := 0;
			if (fitHeight || alignHorizontal == center) {
				ty := ((height) - (surf.height(surf)) * scale) / (2);
			}
			else {
				if (alignHorizontal == bottom) {
					ty := ((height) - (surf.height(surf)) * scale);
				}
			}
			mat: mat4f := {
				mat.x.x := ((1) / scale);
				mat.x.y := (0);
				mat.x.z := (0);
				mat.x.w := (-tx / scale);
				mat.y.x := (0);
				mat.y.y := ((1) / scale);
				mat.y.z := (0);
				mat.y.w := (-ty / scale);
				mat.z.x := (0);
				mat.z.y := (0);
				mat.z.z := ((1) / scale);
				mat.z.w := (0);
				mat.w.x := (0);
				mat.w.y := (0);
				mat.w.z := (0);
				mat.w.w := (1);
			};
			result.transform(result, null, surf, null, (align & highRes) ? 1 : 0, mat.data);
			surf.destroy(surf);
			return .result := result;
		};
		gxSurf(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): gxSurf := gxSurf(fileName, width, height, depth, align, Math.inf);
		gxSurf(fileName: char[*], width: int32, height: int32, depth: int32): gxSurf := gxSurf(fileName, width, height, depth, -1, Math.inf);
		static const gxMesh(fileName: char[*]): gxMesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := gxMesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := gxMesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const gxSurf(copy: gxSurf): gxSurf := {
			result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
			result.copy(result, 0, 0, copy, null);
			return .result := result;
		};
		static const gxSurf(copy: gxSurf, aspect: float64): gxSurf := {
			width: int32 := copy.width(copy);
			if (aspect > (0)) {
				width := ((copy.height(copy)) * aspect);
			}
			result: gxSurf := gxSurf.create(width, copy.height(copy), copy.depth(copy));
			result.transform(result, null, copy, null, 1, null);
			return .result := result;
		};
		set(dst: gxSurf, x: int32, y: int32, color: argb): void := gxSurf.set(dst, x, y, uint32(color));
		resize(surf: gxSurf, const rect: gxRect, const src: gxSurf, const roi: gxRect, interpolate: int32): void := gxSurf.transform(surf, rect, src, roi, interpolate, null);
		static const clip(src: gxSurf, roi: gxRect): bool := {
			roi.w := roi.w + roi.x;
			roi.h := roi.h + roi.y;
			if (roi.x < 0) {
				roi.x := 0;
			}
			if (roi.y < 0) {
				roi.y := 0;
			}
			width: int32 := src.width(src);
			if (roi.w > width) {
				roi.w := width;
			}
			height: int32 := src.height(src);
			if (roi.h > height) {
				roi.h := height;
			}
			roi.w := roi.w - roi.x;
			roi.h := roi.h - roi.y;
			if (roi.w <= 0) {
				return .result := false;
			}
			if (roi.h <= 0) {
				return .result := false;
			}
			return .result := true;
		};
		fill(dst: gxSurf, col: uint32): void := dst.fillRect(dst, 0, 0, 65536, 65536, col);
		fill(dst: gxSurf, const roi: gxRect, col: uint32): void := dst.fillRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
		fill(dst: gxSurf, const roi: gxRect, pad: int32, col: uint32): void := dst.fillRect(dst, roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, col);
		drawRect(dst: gxSurf, const roi: gxRect, col: uint32): void := dst.drawRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
		static const eval(dst: gxSurf, const roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : dst.width(dst);
				rect.h := (roi) != null ? roi.h : dst.height(dst);
			};
			if (!clip(dst, rect)) {
				return;
			}
			in: vec4f := {
				in.x := (0);
				in.y := (0);
				in.z := aspect;
				in.w := time;
			};
			w: float32 := dst.width(dst);
			h: float32 := dst.height(dst);
			for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
					in.x := (x) / w;
					set(dst, x, y, argb(eval(in)));
				}
			}
		};
		static const tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : src.width(src);
				rect.h := (roi) != null ? roi.h : src.height(src);
			};
			if (!clip(src, rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % rect.w);
			}
			if (y < 0) {
				y := -(-y % rect.h);
			}
			width: int32 := dst.width(dst);
			height: int32 := dst.height(dst);
			for (j: int32 := y; j < height; j := j + rect.h) {
				for (i: int32 := x; i < width; i := i + rect.w) {
					dst.copy(dst, i, j, src, rect);
				}
			}
		};
		static const show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void := {
			static const Closure: struct {
				mode: int32;
				offs: gxSurf;
				mesh: gxMesh;
			};
			static const next(x: int32, mask: int32): int32 := {
				next: int32 := x & mask;
				next := next + (mask & -mask);
				next := next & mask;
				return .result := next | (x & ~mask);
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				static ox: int32 := 0;
				static oy: int32 := 0;
				static const speed: float32 := 1.000000 / (100);
				if ((action) == Gui.FINGER_MOTION) {
					action := (Gui.MOUSE_MOTION);
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
					else {
						if (button == ('l')) {
							closure.mode := ((closure.mode) ^ gxMesh.useLights);
						}
						else {
							if (button == ('0')) {
								lights.enable(0, !lights.enabled(0));
							}
							else {
								if (button == ('1')) {
									lights.enable(1, !lights.enabled(1));
								}
								else {
									if (button == ('2')) {
										lights.enable(2, !lights.enabled(2));
									}
									else {
										if (button == ('3')) {
											lights.enable(3, !lights.enabled(3));
										}
										else {
											if (button == ('t')) {
												closure.mode := ((closure.mode) ^ gxMesh.useTexture);
											}
											else {
												if (button == ('/')) {
													closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
												}
												else {
													if (button == ('\t')) {
														closure.mode := next(closure.mode, gxMesh.drawMode);
													}
													else {
														if (button == ('\r')) {
															eye: vec4f := {
																eye.x := (0);
																eye.y := (0);
																eye.z := (2);
																eye.w := (1);
															};
															at: vec4f := {
																at.x := (0);
																at.y := (0);
																at.z := (0);
																at.w := (1);
															};
															up: vec4f := {
																up.x := (0);
																up.y := (1);
																up.z := (0);
																up.w := (1);
															};
															camera.lookAt(eye.data, at.data, up.data);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					if ((action) == Gui.MOUSE_PRESS) {
						ox := ex;
						oy := ey;
						return .result := 0;
					}
					else {
						if ((action) == Gui.MOUSE_MOTION) {
							dir: float32[3];
							dx: int32 := ex - ox;
							dy: int32 := ey - oy;
							if (button == 1) {
								orig: float32[3];
								orig[0] := (0);
								orig[1] := (0);
								orig[2] := (0);
								camera.readUp(dir);
								camera.rotate(dir, orig, (dx) * speed);
								camera.readRight(dir);
								camera.rotate(dir, orig, (dy) * speed);
							}
							else {
								if (button == 2) {
									camera.readUp(dir);
									camera.rotate(dir, null, (-dx) * speed);
									camera.readRight(dir);
									camera.rotate(dir, null, (-dy) * speed);
								}
								else {
									if (button == 3) {
										camera.readForward(dir);
										camera.move(dir, (dy) * speed);
									}
									else {
										if (button == 4) {
											camera.readRight(dir);
											camera.move(dir, (-dx) * speed);
											camera.readUp(dir);
											camera.move(dir, (dy) * speed);
										}
									}
								}
							}
							ox := ex;
							oy := ey;
						}
					}
				}
				rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
				text: char[256];
				pos: int32 := append(text, 0, "Vertices: ");
				pos := append(text, pos, closure.mesh.vertices);
				pos := append(text, pos, ", Triangles: ");
				pos := append(text, pos, closure.mesh.triangles);
				pos := append(text, pos, "/");
				pos := append(text, pos, rendered);
				Gui.setTitle(text);
				return .result := 0;
			};
			closure: Closure := {
				closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
				closure.offs := gxSurf.create3d(w, h);
				closure.mesh := mesh;
			};
			camera.projection(fovy, (w) / float32(h), 1, 100);
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.offs.destroy(closure.offs);
		};
		show(surf: gxSurf): void := Gui.showWindow(surf, null, null);
		static const show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
			if ((onEvent) == null) {
				return .result := Gui.showWindow(surf, null, null);
			}
			static const delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				return .result := onEvent(action, button, ex, ey);
			};
			Gui.showWindow(surf, onEvent, delegate);
		};
		static const showDiff(image1: gxSurf, image2: gxSurf): void := {
			static const Closure: struct {
				offs: gxSurf;
				image1: gxSurf;
				image2: gxSurf;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.MOUSE_PRESS) {
					closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
					return .result := 0;
				}
				if ((action) == Gui.MOUSE_RELEASE) {
					closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
					return .result := 0;
				}
				return .result := 0;
			};
			closure: Closure := {
				closure.offs := gxSurf(image1);
				closure.image1 := image1;
				closure.image2 := image2;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
		};
		static const show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void := {
			static const start: int64 := System.millis();
			static const Closure: struct {
				lerp: bool := true;
				const offs: gxSurf;
				const thumb: gxSurf;
				const aspect: float32;
				const eval(in: vec4f): vec4f;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.WINDOW_CLOSE) {
					trace("closing ...");
					return .result := 0;
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.KEY_RELEASE) {
					if (button == (' ')) {
						time: float32 := ((System.millis() - start)) / 1000.000000;
						eval(closure.offs, null, closure.aspect, time, closure.eval);
						return .result := 0;
					}
					if (button == ('\t')) {
						closure.lerp := !closure.lerp;
					}
					if (button == ('S')) {
						trace("dumping screen");
						closure.offs.saveBmp(closure.offs, "out/offs.bmp", 0);
						closure.thumb.saveBmp(closure.thumb, "out/thumb.bmp", 0);
					}
				}
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.thumb, null, closure.aspect, time, closure.eval);
				resize(closure.offs, null, closure.thumb, null, closure.lerp ? 1 : 0);
				return .result := 1;
			};
			if (animationResolution == 0) {
				aspect: float32 := (width) / float32(height);
				surf: gxSurf := gxSurf(width, height, 32);
				eval(surf, null, aspect, 0.000000, eval);
				show(surf, null);
				surf.destroy(surf);
				return;
			}
			closure: Closure := {
				closure.offs := gxSurf(width, height, 32);
				closure.thumb := gxSurf(animationResolution, animationResolution, 32);
				closure.aspect := (width) / float32(height);
				closure.eval := eval;
				closure.lerp := true;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.thumb.destroy(closure.thumb);
			closure.offs.destroy(closure.offs);
		};
	}
}
.instructions: (98 bytes)
	lib/std/string.ci:144: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main>  : load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	lib/std/string.ci:262: (24 bytes): static const format: FormatFlags := {...}
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format
	<.main+?>: store.i8
	:: (5 bytes): format.precision := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+4
	:: (7 bytes): format.padChr := (0)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+8
	<.main+?>: store.i8
	:: (5 bytes): format.padLen := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+12
	lib/gfxlib.ci:266: (5 bytes): static ox: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.ox
	lib/gfxlib.ci:267: (5 bytes): static oy: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.oy
	lib/gfxlib.ci:268: (24 bytes): static const speed: float32 := 1.000000 / (100)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 100.000000
	<.main+?>: div.f64
	<.main+?>: f64.2f32
	<.main+?>: store.m32 <?> ;show.onEvent.speed
	lib/gfxlib.ci:424: (8 bytes): static const start: int64 := System.millis()
	<.main+?>: nfc(20) ;System.millis(): int64
	<.main+?>: store.m64 <?> ;show.start
	<.main+?>: nfc(0) ;halt(): void
}

---------- Execute: byte-code

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/std/debug.ci:48: NotEquals: typename(<NotEquals>)
lib/std/debug.ci:64: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math/Complex.ci:2: Complex: typename(<Complex>)
lib/std/math/Complex.ci:24: Complex: function(<Complex>)
lib/std/math/Complex.ci:31: Complex: function(<Complex>)
lib/std/math/Complex.ci:83: div: function(<div>)
lib/std/math/Complex.ci:114: inv: function(<inv>)
lib/std/math/Complex.ci:132: pow: function(<pow>)
lib/std/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
lib/std/math/Vector4f.ci:26: vec4f: function(<vec4f>)
lib/std/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
lib/std/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:87: mul: function(<mul>)
lib/std/math/Matrix4f.ci:106: rotation: function(<rotation>)
lib/std/math/Matrix4f.ci:158: translation: function(<translation>)
lib/std/math/Matrix4f.ci:168: scale: function(<scale>)
lib/std/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
lib/std/math/Vector2d.ci:14: vec2d: function(<vec2d>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:233: append: function(<append>)
lib/std/string.ci:261: append: function(<append>)
File: typename(<File>)
gxRect: typename(<gxRect>)
gxSurf: typename(<gxSurf>)
gxMesh: typename(<gxMesh>)
camera: typename(<camera>)
lights: typename(<lights>)
Gui: typename(<Gui>)
lib/gfx/color.ci:2: argb: typename(<argb>)
lib/gfx/color.ci:109: grayClamp: function(<grayClamp>)
lib/gfx/color.ci:119: grayClamp: function(<grayClamp>)
lib/gfx/color.ci:166: rgbLerp16: function(<rgbLerp16>)
lib/gfx/color.ci:178: lerpLut: function(<lerpLut>)
lib/gfx/color.ci:197: hsv2rgb: function(<hsv2rgb>)
lib/gfx/color.ci:236: drawLut: function(<drawLut>)
lib/gfx/color.ci:304: drawHist: function(<drawHist>)
lib/gfxlib.ci:8: gxSurf: function(<gxSurf>)
lib/gfxlib.ci:28: gxSurf: function(<gxSurf>)
lib/gfxlib.ci:106: gxMesh: function(<gxMesh>)
lib/gfxlib.ci:117: gxSurf: function(<gxSurf>)
lib/gfxlib.ci:124: gxSurf: function(<gxSurf>)
lib/gfxlib.ci:141: clip: function(<clip>)
lib/gfxlib.ci:187: eval: function(<eval>)
lib/gfxlib.ci:217: tile: function(<tile>)
lib/gfxlib.ci:245: show: function(<show>)
lib/gfxlib.ci:379: show: function(<show>)
lib/gfxlib.ci:390: showDiff: function(<showDiff>)
lib/gfxlib.ci:423: show: function(<show>)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 361684(353.2 Kb)
memory[heap] @0584d4; size: 1210922(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 350840(342.6 Kb)
memory[code] @000000; size: 10531(10.3 Kb)
memory[data] @000000; size: 52(52.0 bytes)

---------- heap memory:
memory[free] @0584e8; size: 1210880(1.2 Mb)

---------- Exitcode: 0, time: 0.000 ms
