
---------- Compile: `lib/stdlib.ci`

---------- Library: `bin/lnx.gcc/libFile.so`

---------- Library: `bin/lnx.gcc/libGfx.so`

---------- Compile: `cmplGfx/gfxlib.ci`

---------- Generate: byte-code
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
cmplGfx/lib/color.ci:145: warn: uninitialized variable `drawHist.lut`
cmplGfx/gfxlib.ci:211: warn: uninitialized variable `dir`
cmplGfx/gfxlib.ci:217: warn: uninitialized variable `orig`
cmplGfx/gfxlib.ci:252: warn: uninitialized variable `show.onEvent.text`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/lib/color.ci:96: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:83: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal usages: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
.usages:
	lib/stdlib.ci:83: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(3)
.usages:
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(4)
.usages:
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
.usages:
	cmplGfx/gfxlib.ci:321: referenced as `void`
	cmplGfx/gfxlib.ci:288: referenced as `void`
	cmplGfx/gfxlib.ci:277: referenced as `void`
	cmplGfx/gfxlib.ci:146: referenced as `void`
	cmplGfx/gfxlib.ci:118: referenced as `void`
	cmplGfx/gfxlib.ci:88: referenced as `void`
	cmplGfx/lib/color.ci:144: referenced as `void`
	lib/stdlib.ci:66: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	internal usages: 49
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:49: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:47: referenced as `bool`
	lib/stdlib.ci:45: referenced as `bool`
	lib/stdlib.ci:43: referenced as `bool`
	internal usages: 5
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:252: referenced as `char`
	cmplGfx/gfxlib.ci:28: referenced as `char`
	cmplGfx/gfxlib.ci:25: referenced as `char`
	cmplGfx/gfxlib.ci:8: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:66: referenced as `char`
	lib/stdlib.ci:61: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:43: referenced as `char`
	lib/stdlib.ci:38: referenced as `char`
	lib/stdlib.ci:36: referenced as `char`
	lib/stdlib.ci:33: referenced as `char`
	lib/stdlib.ci:31: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:26: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:16: referenced as `char`
	lib/stdlib.ci:13: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	internal usages: 16
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
.usages:
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
.usages:
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:330: referenced as `int32`
	cmplGfx/gfxlib.ci:330: referenced as `int32`
	cmplGfx/gfxlib.ci:330: referenced as `int32`
	cmplGfx/gfxlib.ci:330: referenced as `int32`
	cmplGfx/gfxlib.ci:330: referenced as `int32`
	cmplGfx/gfxlib.ci:321: referenced as `int32`
	cmplGfx/gfxlib.ci:321: referenced as `int32`
	cmplGfx/gfxlib.ci:321: referenced as `int32`
	cmplGfx/gfxlib.ci:295: referenced as `int32`
	cmplGfx/gfxlib.ci:295: referenced as `int32`
	cmplGfx/gfxlib.ci:295: referenced as `int32`
	cmplGfx/gfxlib.ci:295: referenced as `int32`
	cmplGfx/gfxlib.ci:295: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:281: referenced as `int32`
	cmplGfx/gfxlib.ci:277: referenced as `int32`
	cmplGfx/gfxlib.ci:277: referenced as `int32`
	cmplGfx/gfxlib.ci:277: referenced as `int32`
	cmplGfx/gfxlib.ci:277: referenced as `int32`
	cmplGfx/gfxlib.ci:277: referenced as `int32`
	cmplGfx/gfxlib.ci:253: referenced as `int32`
	cmplGfx/gfxlib.ci:250: referenced as `int32`
	cmplGfx/gfxlib.ci:213: referenced as `int32`
	cmplGfx/gfxlib.ci:212: referenced as `int32`
	cmplGfx/gfxlib.ci:168: referenced as `int32`
	cmplGfx/gfxlib.ci:167: referenced as `int32`
	cmplGfx/gfxlib.ci:166: referenced as `int32`
	cmplGfx/gfxlib.ci:166: referenced as `int32`
	cmplGfx/gfxlib.ci:166: referenced as `int32`
	cmplGfx/gfxlib.ci:166: referenced as `int32`
	cmplGfx/gfxlib.ci:166: referenced as `int32`
	cmplGfx/gfxlib.ci:155: referenced as `int32`
	cmplGfx/gfxlib.ci:154: referenced as `int32`
	cmplGfx/gfxlib.ci:154: referenced as `int32`
	cmplGfx/gfxlib.ci:154: referenced as `int32`
	cmplGfx/gfxlib.ci:149: referenced as `int32`
	cmplGfx/gfxlib.ci:146: referenced as `int32`
	cmplGfx/gfxlib.ci:146: referenced as `int32`
	cmplGfx/gfxlib.ci:139: referenced as `int32`
	cmplGfx/gfxlib.ci:138: referenced as `int32`
	cmplGfx/gfxlib.ci:137: referenced as `int32`
	cmplGfx/gfxlib.ci:136: referenced as `int32`
	cmplGfx/gfxlib.ci:118: referenced as `int32`
	cmplGfx/gfxlib.ci:118: referenced as `int32`
	cmplGfx/gfxlib.ci:110: referenced as `int32`
	cmplGfx/gfxlib.ci:108: referenced as `int32`
	cmplGfx/gfxlib.ci:67: referenced as `int32`
	cmplGfx/gfxlib.ci:62: referenced as `int32`
	cmplGfx/gfxlib.ci:46: referenced as `int32`
	cmplGfx/gfxlib.ci:46: referenced as `int32`
	cmplGfx/gfxlib.ci:8: referenced as `int32`
	cmplGfx/gfxlib.ci:5: referenced as `int32`
	cmplGfx/gfxlib.ci:5: referenced as `int32`
	cmplGfx/gfxlib.ci:5: referenced as `int32`
	cmplGfx/lib/color.ci:178: referenced as `int32`
	cmplGfx/lib/color.ci:176: referenced as `int32`
	cmplGfx/lib/color.ci:175: referenced as `int32`
	cmplGfx/lib/color.ci:174: referenced as `int32`
	cmplGfx/lib/color.ci:173: referenced as `int32`
	cmplGfx/lib/color.ci:172: referenced as `int32`
	cmplGfx/lib/color.ci:116: referenced as `int32`
	cmplGfx/lib/color.ci:116: referenced as `int32`
	cmplGfx/lib/color.ci:69: referenced as `int32`
	cmplGfx/lib/color.ci:69: referenced as `int32`
	cmplGfx/lib/color.ci:69: referenced as `int32`
	cmplGfx/lib/color.ci:67: referenced as `int32`
	cmplGfx/lib/color.ci:67: referenced as `int32`
	cmplGfx/lib/color.ci:67: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:54: referenced as `int32`
	cmplGfx/lib/color.ci:52: referenced as `int32`
	cmplGfx/lib/color.ci:48: referenced as `int32`
	cmplGfx/lib/color.ci:27: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:83: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	internal usages: 148
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:322: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplGfx/lib/color.ci:16: referenced as `uint8`
	cmplGfx/lib/color.ci:13: referenced as `uint8`
	cmplGfx/lib/color.ci:10: referenced as `uint8`
	cmplGfx/lib/color.ci:7: referenced as `uint8`
	internal usages: 4
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/gfxlib.ci:85: referenced as `uint32`
	cmplGfx/lib/color.ci:182: referenced as `uint32`
	cmplGfx/lib/color.ci:182: referenced as `uint32`
	cmplGfx/lib/color.ci:181: referenced as `uint32`
	cmplGfx/lib/color.ci:181: referenced as `uint32`
	cmplGfx/lib/color.ci:180: referenced as `uint32`
	cmplGfx/lib/color.ci:180: referenced as `uint32`
	cmplGfx/lib/color.ci:179: referenced as `uint32`
	cmplGfx/lib/color.ci:179: referenced as `uint32`
	cmplGfx/lib/color.ci:145: referenced as `uint32`
	cmplGfx/lib/color.ci:144: referenced as `uint32`
	cmplGfx/lib/color.ci:94: referenced as `uint32`
	cmplGfx/lib/color.ci:89: referenced as `uint32`
	cmplGfx/lib/color.ci:88: referenced as `uint32`
	cmplGfx/lib/color.ci:87: referenced as `uint32`
	cmplGfx/lib/color.ci:85: referenced as `uint32`
	cmplGfx/lib/color.ci:85: referenced as `uint32`
	cmplGfx/lib/color.ci:85: referenced as `uint32`
	cmplGfx/lib/color.ci:84: referenced as `uint32`
	cmplGfx/lib/color.ci:81: referenced as `uint32`
	cmplGfx/lib/color.ci:79: referenced as `uint32`
	cmplGfx/lib/color.ci:77: referenced as `uint32`
	cmplGfx/lib/color.ci:75: referenced as `uint32`
	cmplGfx/lib/color.ci:73: referenced as `uint32`
	cmplGfx/lib/color.ci:65: referenced as `uint32`
	cmplGfx/lib/color.ci:65: referenced as `uint32`
	cmplGfx/lib/color.ci:65: referenced as `uint32`
	cmplGfx/lib/color.ci:60: referenced as `uint32`
	cmplGfx/lib/color.ci:60: referenced as `uint32`
	cmplGfx/lib/color.ci:60: referenced as `uint32`
	cmplGfx/lib/color.ci:60: referenced as `uint32`
	cmplGfx/lib/color.ci:60: referenced as `uint32`
	cmplGfx/lib/color.ci:58: referenced as `uint32`
	cmplGfx/lib/color.ci:58: referenced as `uint32`
	cmplGfx/lib/color.ci:58: referenced as `uint32`
	cmplGfx/lib/color.ci:58: referenced as `uint32`
	cmplGfx/lib/color.ci:50: referenced as `uint32`
	cmplGfx/lib/color.ci:46: referenced as `uint32`
	cmplGfx/lib/color.ci:37: referenced as `uint32`
	cmplGfx/lib/color.ci:37: referenced as `uint32`
	cmplGfx/lib/color.ci:27: referenced as `uint32`
	cmplGfx/lib/color.ci:23: referenced as `uint32`
	cmplGfx/lib/color.ci:21: referenced as `uint32`
	cmplGfx/lib/color.ci:21: referenced as `uint32`
	cmplGfx/lib/color.ci:4: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
	internal usages: 4
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(18)
.usages:
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(19)
.usages:
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(20)
.usages:
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(21)
.usages:
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(22)
.usages:
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(23)
.usages:
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(24)
.usages:
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(25)
.usages:
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.value: 0
.usages:
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(26)
.usages:
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(27)
.usages:
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/gfxlib.ci:368: referenced as `float32`
	cmplGfx/gfxlib.ci:357: referenced as `float32`
	cmplGfx/gfxlib.ci:357: referenced as `float32`
	cmplGfx/gfxlib.ci:348: referenced as `float32`
	cmplGfx/gfxlib.ci:342: referenced as `float32`
	cmplGfx/gfxlib.ci:326: referenced as `float32`
	cmplGfx/gfxlib.ci:268: referenced as `float32`
	cmplGfx/gfxlib.ci:217: referenced as `float32`
	cmplGfx/gfxlib.ci:211: referenced as `float32`
	cmplGfx/gfxlib.ci:169: referenced as `float32`
	cmplGfx/gfxlib.ci:146: referenced as `float32`
	cmplGfx/gfxlib.ci:107: referenced as `float32`
	cmplGfx/gfxlib.ci:106: referenced as `float32`
	cmplGfx/gfxlib.ci:88: referenced as `float32`
	cmplGfx/gfxlib.ci:88: referenced as `float32`
	cmplGfx/lib/color.ci:122: referenced as `float32`
	cmplGfx/lib/color.ci:121: referenced as `float32`
	cmplGfx/lib/color.ci:120: referenced as `float32`
	cmplGfx/lib/color.ci:119: referenced as `float32`
	cmplGfx/lib/color.ci:117: referenced as `float32`
	cmplGfx/lib/color.ci:108: referenced as `float32`
	cmplGfx/lib/color.ci:107: referenced as `float32`
	cmplGfx/lib/color.ci:106: referenced as `float32`
	cmplGfx/lib/color.ci:67: referenced as `float32`
	cmplGfx/lib/color.ci:67: referenced as `float32`
	cmplGfx/lib/color.ci:67: referenced as `float32`
	cmplGfx/lib/color.ci:52: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	internal usages: 75
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(28)
.usages:
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(29)
.usages:
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(30)
.usages:
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(31)
.usages:
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(32)
.usages:
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(33)
.usages:
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(34)
.usages:
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(35)
.usages:
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/lib/color.ci:94: referenced as `float64`
	cmplGfx/lib/color.ci:69: referenced as `float64`
	cmplGfx/lib/color.ci:69: referenced as `float64`
	cmplGfx/lib/color.ci:69: referenced as `float64`
	cmplGfx/lib/color.ci:54: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(36)
.usages:
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(37)
.usages:
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(38)
.usages:
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(39)
.usages:
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(40)
.usages:
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(41)
.usages:
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(42)
.usages:
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(43)
.usages:
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.usages:
	internal usages: 14
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(7)
.usages:
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: int32 (size: 4, cast: variable(i32))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(8)
.usages:
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(9)
.usages:
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(10)
.usages:
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
.usages:
	lib/stdlib.ci:58: referenced as `variant`
	lib/stdlib.ci:55: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:43: referenced as `variant`
	lib/stdlib.ci:36: referenced as `variant`
	lib/stdlib.ci:31: referenced as `variant`
	lib/stdlib.ci:26: referenced as `variant`
	lib/stdlib.ci:21: referenced as `variant`
	lib/stdlib.ci:16: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:6: referenced as `variant`
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
.usages:
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
.usages:
	cmplGfx/gfxlib.ci:360: referenced as `null`
	cmplGfx/gfxlib.ci:359: referenced as `null`
	cmplGfx/gfxlib.ci:350: referenced as `null`
	cmplGfx/gfxlib.ci:350: referenced as `null`
	cmplGfx/gfxlib.ci:349: referenced as `null`
	cmplGfx/gfxlib.ci:343: referenced as `null`
	cmplGfx/gfxlib.ci:306: referenced as `null`
	cmplGfx/gfxlib.ci:302: referenced as `null`
	cmplGfx/gfxlib.ci:279: referenced as `null`
	cmplGfx/gfxlib.ci:279: referenced as `null`
	cmplGfx/gfxlib.ci:278: referenced as `null`
	cmplGfx/gfxlib.ci:274: referenced as `null`
	cmplGfx/gfxlib.ci:274: referenced as `null`
	cmplGfx/gfxlib.ci:232: referenced as `null`
	cmplGfx/gfxlib.ci:230: referenced as `null`
	cmplGfx/gfxlib.ci:123: referenced as `null`
	cmplGfx/gfxlib.ci:122: referenced as `null`
	cmplGfx/gfxlib.ci:121: referenced as `null`
	cmplGfx/gfxlib.ci:120: referenced as `null`
	cmplGfx/gfxlib.ci:93: referenced as `null`
	cmplGfx/gfxlib.ci:92: referenced as `null`
	cmplGfx/gfxlib.ci:91: referenced as `null`
	cmplGfx/gfxlib.ci:90: referenced as `null`
	cmplGfx/gfxlib.ci:41: referenced as `null`
	cmplGfx/lib/color.ci:96: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:78: referenced as `null`
	lib/stdlib.ci:61: referenced as `null`
	lib/stdlib.ci:58: referenced as `null`
	lib/stdlib.ci:40: referenced as `null`
	lib/stdlib.ci:38: referenced as `null`
	lib/stdlib.ci:33: referenced as `null`
	lib/stdlib.ci:28: referenced as `null`
	lib/stdlib.ci:23: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:13: referenced as `null`
	lib/stdlib.ci:8: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'true'
.value: 1
.usages:
	cmplGfx/gfxlib.ci:81: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'false'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:79: referenced as `false`
	cmplGfx/gfxlib.ci:76: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
.usages:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'byte'
.value: uint8
.usages:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'float'
.value: float32
.usages:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'double'
.value: float64
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
.usages:
	cmplGfx/lib/color.ci:23: referenced as `emit`
	cmplGfx/lib/color.ci:21: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
.usages:
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
.usages:
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.param inspect: variant (size: 8, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(5)
.usages:
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:75: referenced as `abort`
	lib/stdlib.ci:40: referenced as `abort`
	lib/stdlib.ci:38: referenced as `abort`
	lib/stdlib.ci:36: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:33: referenced as `error`
	lib/stdlib.ci:31: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:28: referenced as `warn`
	lib/stdlib.ci:26: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:23: referenced as `info`
	lib/stdlib.ci:21: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	lib/stdlib.ci:18: referenced as `debug`
	lib/stdlib.ci:16: referenced as `debug`
	lib/stdlib.ci:13: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:8: referenced as `verbose`
	lib/stdlib.ci:6: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:28: referenced as `noTrace`
	lib/stdlib.ci:26: referenced as `noTrace`
	lib/stdlib.ci:23: referenced as `noTrace`
	lib/stdlib.ci:21: referenced as `noTrace`
	lib/stdlib.ci:13: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:8: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:75: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:38: referenced as `defTrace`
	lib/stdlib.ci:36: referenced as `defTrace`
	lib/stdlib.ci:33: referenced as `defTrace`
	lib/stdlib.ci:31: referenced as `defTrace`
	lib/stdlib.ci:18: referenced as `defTrace`
	lib/stdlib.ci:16: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.value: nfc(6)
.usages:
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:348: referenced as `System`
	cmplGfx/gfxlib.ci:342: referenced as `System`
	cmplGfx/gfxlib.ci:322: referenced as `System`
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(13)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(14)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.value: nfc(16)
.usages:
	cmplGfx/gfxlib.ci:348: referenced as `millis`
	cmplGfx/gfxlib.ci:342: referenced as `millis`
	cmplGfx/gfxlib.ci:322: referenced as `millis`
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.value: nfc(17)
.usages:
	internal usages: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, inspect)
.usages:
	lib/stdlib.ci:6: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, null)
.usages:
	lib/stdlib.ci:8: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, inspect)
.usages:
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:13'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, null)
.usages:
	lib/stdlib.ci:13: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:16'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, inspect)
.usages:
	lib/stdlib.ci:16: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, null)
.usages:
	cmplGfx/gfxlib.ci:332: referenced as `trace`
	lib/stdlib.ci:18: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, inspect)
.usages:
	lib/stdlib.ci:21: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, null)
.usages:
	lib/stdlib.ci:23: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:26'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, inspect)
.usages:
	lib/stdlib.ci:26: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, null)
.usages:
	lib/stdlib.ci:28: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:31'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, inspect)
.usages:
	lib/stdlib.ci:31: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:33'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, null)
.usages:
	lib/stdlib.ci:33: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:36'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, inspect)
.usages:
	cmplGfx/gfxlib.ci:35: referenced as `abort`
	cmplGfx/gfxlib.ci:21: referenced as `abort`
	lib/stdlib.ci:43: referenced as `abort`
	lib/stdlib.ci:36: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, null)
.usages:
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
	lib/stdlib.ci:38: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
.usages:
	lib/stdlib.ci:40: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:43'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message, inspect))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:43: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:45: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:47: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'NotEquals'
.file: 'lib/stdlib.ci:50'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field argument: variant (size: 8, cast: const variable(var))
.field message: char[*] (size: 4, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:70: referenced as `NotEquals`
	lib/stdlib.ci:50: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'lib/stdlib.ci:52'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:71: referenced as `expected`
	lib/stdlib.ci:52: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'lib/stdlib.ci:55'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:72: referenced as `returned`
	lib/stdlib.ci:55: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'argument'
.file: 'lib/stdlib.ci:58'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:58: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'message'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:73: referenced as `message`
	lib/stdlib.ci:61: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.name: 'assertEq'
.file: 'lib/stdlib.ci:66'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (returned == expected) {
		return;
	}
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.message := (message);
		details.argument := (null);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (94 bytes)
	lib/stdlib.ci:67: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x1 sp(2)
	<assertEq+?>: dup.x1 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	lib/stdlib.ci:68: (1 byte): return;
	<assertEq+?>: ret
	lib/stdlib.ci:70: (41 bytes): details: NotEquals := {...}
	<assertEq+?>: inc.sp(+32)
	lib/stdlib.ci:71: (11 bytes): details.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x2 sp(2)
	lib/stdlib.ci:72: (11 bytes): details.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x2 sp(4)
	lib/stdlib.ci:73: (3 bytes): details.message := (message);
	<assertEq+?>: mov.x1 sp(6, 9)
	:: (12 bytes): details.argument := (null)
	<assertEq+?>: load.ref <?> ;pointer
	<assertEq+?>: load.ref <?> ;null
	<assertEq+?>: set.x2 sp(6)
	lib/stdlib.ci:75: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>: load.ref <?> ;"lib/stdlib.ci"
	<assertEq+?>: load.c32 75
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+24)
	<assertEq+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
.usages:
	lib/stdlib.ci:78: referenced as `assertEq`
	lib/stdlib.ci:66: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'lib/stdlib.ci:78'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(expected, returned, null)
.usages:
	lib/stdlib.ci:78: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'lib/stdlib.ci:83'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	lib/stdlib.ci:83: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, cast: static const val)
.field e: float64 (size: 8, cast: static const val)
.field ln2: float64 (size: 8, cast: static const val)
.field log2E: float64 (size: 8, cast: static const val)
.field ln10: float64 (size: 8, cast: static const val)
.field log10E: float64 (size: 8, cast: static const val)
.field phi: float64 (size: 8, cast: static const val)
.field sqrt2: float64 (size: 8, cast: static const val)
.field sqrtE: float64 (size: 8, cast: static const val)
.field sqrtPi: float64 (size: 8, cast: static const val)
.field sqrtPhi: float64 (size: 8, cast: static const val)
.field nan: float64 (size: 8, cast: static const val)
.field inf: float64 (size: 8, cast: static const val)
.field modf: function (size: 86, cast: static const function)
.field floor: function (size: 24, cast: static const function)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field abs: function (size: 18, cast: static const function)
.field abs: function (size: 18, cast: static const function)
.field absMod: function (size: 27, cast: static const function)
.field absMod: function (size: 27, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field lerp: function (size: 0, cast: static inline)
.field lerp: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field min: function (size: 72, cast: static const function)
.field max: function (size: 72, cast: static const function)
.field sum: function (size: 40, cast: static const function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field sinCos: function (size: 335, cast: static const function)
.field sin: function (size: 0, cast: static inline)
.field cos: function (size: 0, cast: static inline)
.field tan: function (size: 371, cast: static const function)
.field sinh: function (size: 241, cast: static const function)
.field cosh: function (size: 75, cast: static const function)
.field asin: function (size: 166, cast: static const function)
.field acos: function (size: 0, cast: static inline)
.field radians: function (size: 0, cast: static inline)
.field degrees: function (size: 0, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.000000 / ln2
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 1.000000 / ln10
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: (0) / 0.000000
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: (1) / 0.000000
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (86 bytes)
	lib/std/math.ci:23: (63 bytes): if (x < (1))
	<modf>  : dup.x2 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +51
	lib/std/math.ci:24: (39 bytes): if (x < (0))
	<modf+?>: dup.x2 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +35
	lib/std/math.ci:25: (17 bytes): result: float64 := -modf(-x, intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x2 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	<modf+?>: neg.f64
	lib/std/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x1 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:27: (3 bytes): return .result := result;
	<modf+?>: set.x2 sp(6)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	lib/std/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x1 sp(3)
	<modf+?>: store.i64
	lib/std/math.ci:30: (4 bytes): return .result := x;
	<modf+?>: mov.x2 sp(4, 2)
	<modf+?>: ret
	lib/std/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x2 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	lib/std/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>: dup.x2 sp(4)
	<modf+?>: dup.x2 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:34: (3 bytes): return .result := result;
	<modf+?>: set.x2 sp(6)
	<modf+?>: ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(x, result);
	return .result := result;
}
.instructions: (24 bytes)
	lib/std/math.ci:48: (1 byte): result: float64
	<floor>  : load.z128
	lib/std/math.ci:49: (20 bytes): modf(x, result);
	<floor+?>: dup.x2 sp(5)
	<floor+?>: load.sp(+16)
	<floor+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>: call
	<floor+?>: inc.sp(-12)
	<floor+?>: inc.sp(-8)
	lib/std/math.ci:50: (3 bytes): return .result := result;
	<floor+?>: set.x2 sp(5)
	<floor+?>: ret
.usages:
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:78: (14 bytes): if (x < (0))
	<abs>  : dup.x1 sp(1)
	<abs+?>: load.z32
	<abs+?>: clt.f32
	<abs+?>: jz +10
	lib/std/math.ci:79: (6 bytes): return .result := -x;
	<abs+?>: dup.x1 sp(1)
	<abs+?>: neg.f32
	<abs+?>: set.x1 sp(3)
	<abs+?>: ret
	lib/std/math.ci:81: (4 bytes): return .result := x;
	<abs+?>: mov.x1 sp(2, 1)
	<abs+?>: ret
.usages:
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:86: (14 bytes): if (x < (0))
	<abs>  : dup.x2 sp(1)
	<abs+?>: load.z64
	<abs+?>: clt.f64
	<abs+?>: jz +10
	lib/std/math.ci:87: (6 bytes): return .result := -x;
	<abs+?>: dup.x2 sp(1)
	<abs+?>: neg.f64
	<abs+?>: set.x2 sp(5)
	<abs+?>: ret
	lib/std/math.ci:89: (4 bytes): return .result := x;
	<abs+?>: mov.x2 sp(3, 1)
	<abs+?>: ret
.usages:
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param val: float32 (size: 4, cast: variable(f32))
.param mod: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	lib/std/math.ci:94: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x1 sp(2)
	<absMod+?>: dup.x1 sp(2)
	<absMod+?>: mod.f32
	<absMod+?>: dup.x1 sp(0)
	<absMod+?>: set.x1 sp(4)
	<absMod+?>: load.z32
	<absMod+?>: clt.f32
	<absMod+?>: jz +12
	lib/std/math.ci:95: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x1 sp(2)
	<absMod+?>: dup.x1 sp(2)
	<absMod+?>: add.f32
	<absMod+?>: set.x1 sp(4)
	<absMod+?>: ret
	lib/std/math.ci:97: (4 bytes): return .result := val;
	<absMod+?>: mov.x1 sp(3, 2)
	<absMod+?>: ret
.usages:
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param val: float64 (size: 8, cast: variable(f64))
.param mod: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	lib/std/math.ci:102: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x2 sp(3)
	<absMod+?>: dup.x2 sp(3)
	<absMod+?>: mod.f64
	<absMod+?>: dup.x2 sp(0)
	<absMod+?>: set.x2 sp(7)
	<absMod+?>: load.z64
	<absMod+?>: clt.f64
	<absMod+?>: jz +12
	lib/std/math.ci:103: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x2 sp(3)
	<absMod+?>: dup.x2 sp(3)
	<absMod+?>: add.f64
	<absMod+?>: set.x2 sp(7)
	<absMod+?>: ret
	lib/std/math.ci:105: (4 bytes): return .result := val;
	<absMod+?>: mov.x2 sp(5, 3)
	<absMod+?>: ret
.usages:
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:116: (13 bytes): if (a < b)
	<min>  : dup.x1 sp(2)
	<min+?>: dup.x1 sp(2)
	<min+?>: clt.f32
	<min+?>: jz +8
	lib/std/math.ci:117: (4 bytes): return .result := a;
	<min+?>: mov.x1 sp(3, 2)
	<min+?>: ret
	lib/std/math.ci:119: (4 bytes): return .result := b;
	<min+?>: mov.x1 sp(3, 1)
	<min+?>: ret
.usages:
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:124: (13 bytes): if (a < b)
	<min>  : dup.x2 sp(3)
	<min+?>: dup.x2 sp(3)
	<min+?>: clt.f64
	<min+?>: jz +8
	lib/std/math.ci:125: (4 bytes): return .result := a;
	<min+?>: mov.x2 sp(5, 3)
	<min+?>: ret
	lib/std/math.ci:127: (4 bytes): return .result := b;
	<min+?>: mov.x2 sp(5, 1)
	<min+?>: ret
.usages:
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:138: (13 bytes): if (a > b)
	<max>  : dup.x1 sp(2)
	<max+?>: dup.x1 sp(2)
	<max+?>: cgt.f32
	<max+?>: jz +8
	lib/std/math.ci:139: (4 bytes): return .result := a;
	<max+?>: mov.x1 sp(3, 2)
	<max+?>: ret
	lib/std/math.ci:141: (4 bytes): return .result := b;
	<max+?>: mov.x1 sp(3, 1)
	<max+?>: ret
.usages:
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:146: (13 bytes): if (a > b)
	<max>  : dup.x2 sp(3)
	<max+?>: dup.x2 sp(3)
	<max+?>: cgt.f64
	<max+?>: jz +8
	lib/std/math.ci:147: (4 bytes): return .result := a;
	<max+?>: mov.x2 sp(5, 3)
	<max+?>: ret
	lib/std/math.ci:149: (4 bytes): return .result := b;
	<max+?>: mov.x2 sp(5, 1)
	<max+?>: ret
.usages:
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:160: (13 bytes): if (t < a)
	<clamp>  : dup.x1 sp(3)
	<clamp+?>: dup.x1 sp(3)
	<clamp+?>: clt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:161: (4 bytes): return .result := a;
	<clamp+?>: mov.x1 sp(4, 2)
	<clamp+?>: ret
	lib/std/math.ci:163: (13 bytes): if (t > b)
	<clamp+?>: dup.x1 sp(3)
	<clamp+?>: dup.x1 sp(2)
	<clamp+?>: cgt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:164: (4 bytes): return .result := b;
	<clamp+?>: mov.x1 sp(4, 1)
	<clamp+?>: ret
	lib/std/math.ci:166: (4 bytes): return .result := t;
	<clamp+?>: mov.x1 sp(4, 3)
	<clamp+?>: ret
.usages:
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:171: (13 bytes): if (t < a)
	<clamp>  : dup.x2 sp(5)
	<clamp+?>: dup.x2 sp(5)
	<clamp+?>: clt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:172: (4 bytes): return .result := a;
	<clamp+?>: mov.x2 sp(7, 3)
	<clamp+?>: ret
	lib/std/math.ci:174: (13 bytes): if (t > b)
	<clamp+?>: dup.x2 sp(5)
	<clamp+?>: dup.x2 sp(3)
	<clamp+?>: cgt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:175: (4 bytes): return .result := b;
	<clamp+?>: mov.x2 sp(7, 1)
	<clamp+?>: ret
	lib/std/math.ci:177: (4 bytes): return .result := t;
	<clamp+?>: mov.x2 sp(7, 5)
	<clamp+?>: ret
.usages:
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float32(0), float32(1)))
.usages:
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float64(0), float64(1)))
.usages:
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result > data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (72 bytes)
	lib/std/math.ci:202: (13 bytes): if (data.length == (0))
	<min>  : dup.x1 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +9
	lib/std/math.ci:203: (5 bytes): return .result := nan;
	<min+?>: load.z128
	<min+?>: div.f64
	<min+?>: set.x2 sp(5)
	<min+?>: ret
	lib/std/math.ci:205: (3 bytes): result: float64 := data[0]
	<min+?>: dup.x1 sp(1)
	<min+?>: load.i64
	lib/std/math.ci:206: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	lib/std/math.ci:207: (27 bytes): if (result > data[i])
	<min+?>: dup.x2 sp(1)
	<min+?>: dup.x1 sp(6)
	<min+?>: dup.x1 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	lib/std/math.ci:208: (11 bytes): result := data[i];
	<min+?>: dup.x1 sp(4)
	<min+?>: dup.x1 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x2 sp(3)
	lib/std/math.ci:206: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	lib/std/math.ci:206: (9 bytes): i < (data.length)
	<min+?>: dup.x1 sp(0)
	<min+?>: dup.x1 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	lib/std/math.ci:211: (3 bytes): return .result := result;
	<min+?>: set.x2 sp(5)
	<min+?>: ret
.usages:
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result < data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (72 bytes)
	lib/std/math.ci:216: (13 bytes): if (data.length == (0))
	<max>  : dup.x1 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +9
	lib/std/math.ci:217: (5 bytes): return .result := nan;
	<max+?>: load.z128
	<max+?>: div.f64
	<max+?>: set.x2 sp(5)
	<max+?>: ret
	lib/std/math.ci:219: (3 bytes): result: float64 := data[0]
	<max+?>: dup.x1 sp(1)
	<max+?>: load.i64
	lib/std/math.ci:220: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	lib/std/math.ci:221: (27 bytes): if (result < data[i])
	<max+?>: dup.x2 sp(1)
	<max+?>: dup.x1 sp(6)
	<max+?>: dup.x1 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	lib/std/math.ci:222: (11 bytes): result := data[i];
	<max+?>: dup.x1 sp(4)
	<max+?>: dup.x1 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x2 sp(3)
	lib/std/math.ci:220: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	lib/std/math.ci:220: (9 bytes): i < (data.length)
	<max+?>: dup.x1 sp(0)
	<max+?>: dup.x1 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	lib/std/math.ci:225: (3 bytes): return .result := result;
	<max+?>: set.x2 sp(5)
	<max+?>: ret
.usages:
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (data.length); i := i + 1) {
		result := result + data[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	lib/std/math.ci:230: (1 byte): result: float64 := 0
	<sum>  : load.z128
	lib/std/math.ci:231: (36 bytes): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	lib/std/math.ci:232: (14 bytes): result := result + data[i];
	<sum+?>: dup.x2 sp(1)
	<sum+?>: dup.x1 sp(6)
	<sum+?>: dup.x1 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x2 sp(3)
	lib/std/math.ci:231: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	lib/std/math.ci:231: (9 bytes): i < (data.length)
	<sum+?>: dup.x1 sp(0)
	<sum+?>: dup.x1 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	lib/std/math.ci:234: (3 bytes): return .result := result;
	<sum+?>: set.x2 sp(5)
	<sum+?>: ret
.usages:
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * a1)
.usages:
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2))
.usages:
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2, a3))
.usages:
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	lib/std/math.ci:257: (1 byte): result: float64 := 0
	<eval>  : load.z64
	lib/std/math.ci:258: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x1 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	lib/std/math.ci:259: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x2 sp(1)
	<eval+?>: dup.x2 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x1 sp(6)
	<eval+?>: dup.x1 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x2 sp(3)
	lib/std/math.ci:258: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	lib/std/math.ci:258: (8 bytes): i >= 0
	<eval+?>: dup.x1 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	lib/std/math.ci:261: (3 bytes): return .result := result;
	<eval+?>: set.x2 sp(7)
	<eval+?>: ret
.usages:
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.param eps: float32 (size: 4, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:266: (53 bytes): if (a < b)
	<cmp>  : dup.x1 sp(3)
	<cmp+?>: dup.x1 sp(3)
	<cmp+?>: clt.f32
	<cmp+?>: jz +28
	lib/std/math.ci:267: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x1 sp(1)
	<cmp+?>: dup.x1 sp(3)
	<cmp+?>: dup.x1 sp(5)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:268: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:272: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x1 sp(1)
	<cmp+?>: dup.x1 sp(4)
	<cmp+?>: dup.x1 sp(4)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:273: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
	lib/std/math.ci:276: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
.usages:
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.param eps: float64 (size: 8, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:281: (53 bytes): if (a < b)
	<cmp>  : dup.x2 sp(5)
	<cmp+?>: dup.x2 sp(5)
	<cmp+?>: clt.f64
	<cmp+?>: jz +28
	lib/std/math.ci:282: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x2 sp(1)
	<cmp+?>: dup.x2 sp(5)
	<cmp+?>: dup.x2 sp(9)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:283: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:287: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x2 sp(1)
	<cmp+?>: dup.x2 sp(7)
	<cmp+?>: dup.x2 sp(7)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:288: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
	lib/std/math.ci:291: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
.usages:
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (335 bytes)
	lib/std/math.ci:309: (2 bytes): x: float64 := arg
	<sinCos>  : dup.x2 sp(2)
	lib/std/math.ci:310: (17 bytes): if (x < (0))
	<sinCos+?>: dup.x2 sp(0)
	<sinCos+?>: load.z64
	<sinCos+?>: clt.f64
	<sinCos+?>: jz +13
	lib/std/math.ci:311: (1 byte): x := -x;
	<sinCos+?>: neg.f64
	lib/std/math.ci:312: (8 bytes): quad := quad + 2;
	<sinCos+?>: dup.x1 sp(3)
	<sinCos+?>: inc.i32(+2)
	<sinCos+?>: set.x1 sp(4)
	lib/std/math.ci:315: (1 byte): y: float64
	<sinCos+?>: load.z64
	lib/std/math.ci:316: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: load.f64 1.570796
	<sinCos+?>: div.f64
	<sinCos+?>: mul.f64
	<sinCos+?>: set.x2 sp(4)
	lib/std/math.ci:317: (124 bytes): if (x > (32764))
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 32764.000000
	<sinCos+?>: cgt.f64
	<sinCos+?>: jz +84
	lib/std/math.ci:318: (1 byte): e: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:319: (18 bytes): y := modf(x, e);
	<sinCos+?>: dup.x2 sp(6)
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: set.x2 sp(4)
	lib/std/math.ci:320: (4 bytes): e := e + (quad);
	<sinCos+?>: dup.x1 sp(7)
	<sinCos+?>: i32.2f64
	<sinCos+?>: add.f64
	lib/std/math.ci:322: (1 byte): f: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:323: (30 bytes): modf(0.250000 * e, f);
	<sinCos+?>: load.f64 0.250000
	<sinCos+?>: dup.x2 sp(6)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: inc.sp(-8)
	lib/std/math.ci:324: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 4.000000
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: sub.f64
	<sinCos+?>: f64.2i32
	<sinCos+?>: set.x1 sp(10)
	<sinCos+?>: inc.sp(-16)
	<sinCos+?>: jmp +32
	lib/std/math.ci:327: (3 bytes): k: int32 := x
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: f64.2i32
	lib/std/math.ci:328: (8 bytes): y := x - (k);
	<sinCos+?>: dup.x2 sp(3)
	<sinCos+?>: dup.x1 sp(2)
	<sinCos+?>: i32.2f64
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x2 sp(3)
	lib/std/math.ci:329: (7 bytes): quad := quad + k;
	<sinCos+?>: dup.x1 sp(6)
	<sinCos+?>: dup.x1 sp(1)
	<sinCos+?>: add.i32
	<sinCos+?>: set.x1 sp(7)
	lib/std/math.ci:330: (6 bytes): quad := quad & 3;
	<sinCos+?>: dup.x1 sp(6)
	<sinCos+?>: b32.and 0x003
	<sinCos+?>: set.x1 sp(7)
	<sinCos+?>: inc.sp(-4)
	lib/std/math.ci:332: (22 bytes): if (quad & 1)
	<sinCos+?>: dup.x1 sp(5)
	<sinCos+?>: b32.and 0x001
	<sinCos+?>: jz +18
	lib/std/math.ci:333: (14 bytes): y := (1) - y;
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x2 sp(2)
	lib/std/math.ci:335: (13 bytes): if (quad > 1)
	<sinCos+?>: dup.x1 sp(5)
	<sinCos+?>: load.c32 1
	<sinCos+?>: cgt.i32
	<sinCos+?>: jz +5
	lib/std/math.ci:336: (1 byte): y := -y;
	<sinCos+?>: neg.f64
	lib/std/math.ci:339: (5 bytes): ysq: float64 := y * y
	<sinCos+?>: dup.x2 sp(0)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	lib/std/math.ci:340: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>: load.f64 145.968841
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -13847.272500
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 440103.053538
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -4942908.100903
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 13578840.978774
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	lib/std/math.ci:341: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 132.653491
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 9463.096102
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 408179.225234
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 8644558.652923
	<sinCos+?>: add.f64
	lib/std/math.ci:342: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: div.f64
	<sinCos+?>: set.x2 sp(16)
	<sinCos+?>: inc.sp(-40)
	<sinCos+?>: ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(arg, 0)
.usages:
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(abs(arg), 1)
.usages:
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else {
		if (i == 1) {
			x := (1) - x;
			complement := true;
		}
		else {
			if (i == 2) {
				negate := !negate;
				complement := true;
			}
			else {
				if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
			}
		}
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (371 bytes)
	lib/std/math.ci:365: (1 byte): complement: bool := false
	<tan>  : load.z32
	lib/std/math.ci:366: (1 byte): negate: bool := false
	<tan+?>: load.z32
	lib/std/math.ci:368: (23 bytes): if (arg < (0))
	<tan+?>: dup.x2 sp(3)
	<tan+?>: load.z64
	<tan+?>: clt.f64
	<tan+?>: jz +19
	lib/std/math.ci:369: (5 bytes): arg := -arg;
	<tan+?>: dup.x2 sp(3)
	<tan+?>: neg.f64
	<tan+?>: set.x2 sp(5)
	lib/std/math.ci:370: (10 bytes): negate := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+4)
	<tan+?>: store.i8
	lib/std/math.ci:372: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x2 sp(5)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1.570796
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(5)
	lib/std/math.ci:374: (1 byte): e: float64
	<tan+?>: load.z128
	lib/std/math.ci:375: (16 bytes): x: float64 := modf(arg, e)
	<tan+?>: dup.x2 sp(7)
	<tan+?>: load.sp(+16)
	<tan+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	lib/std/math.ci:376: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>: dup.x2 sp(2)
	<tan+?>: f64.2i32
	<tan+?>: load.c32 4
	<tan+?>: mod.i32
	lib/std/math.ci:378: (122 bytes): if (i == 0)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.z32
	<tan+?>: ceq.i32
	<tan+?>: jnz +118
	lib/std/math.ci:379: (114 bytes): if (i == 1)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 1
	<tan+?>: ceq.i32
	<tan+?>: jz +32
	lib/std/math.ci:380: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x2 sp(3)
	lib/std/math.ci:381: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +78
	lib/std/math.ci:383: (74 bytes): if (i == 2)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 2
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:384: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:385: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +41
	lib/std/math.ci:387: (37 bytes): if (i == 3)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 3
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:388: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x2 sp(3)
	lib/std/math.ci:389: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:392: (5 bytes): xsq: float64 := x * x
	<tan+?>: dup.x2 sp(1)
	<tan+?>: dup.x2 sp(3)
	<tan+?>: mul.f64
	lib/std/math.ci:393: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>: load.f64 0.000034
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 0.034226
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -15.506857
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1055.970902
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -13068.202648
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(5)
	<tan+?>: mul.f64
	lib/std/math.ci:394: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>: dup.x2 sp(2)
	<tan+?>: load.f64 -155.503316
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 4765.751363
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -16638.952389
	<tan+?>: add.f64
	<tan+?>: div.f64
	lib/std/math.ci:396: (40 bytes): if (complement)
	<tan+?>: load.sp(+40)
	<tan+?>: load.i8
	<tan+?>: jz +35
	lib/std/math.ci:397: (17 bytes): if (result == (0))
	<tan+?>: dup.x2 sp(0)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +13
	lib/std/math.ci:398: (9 bytes): return .result := nan;
	<tan+?>: load.z128
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:400: (14 bytes): result := (1) / result;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(2)
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(2)
	lib/std/math.ci:402: (19 bytes): if (negate)
	<tan+?>: load.sp(+36)
	<tan+?>: load.i8
	<tan+?>: jz +14
	lib/std/math.ci:403: (10 bytes): return .result := -result;
	<tan+?>: dup.x2 sp(0)
	<tan+?>: neg.f64
	<tan+?>: set.x2 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:405: (7 bytes): return .result := result;
	<tan+?>: set.x2 sp(14)
	<tan+?>: inc.sp(-36)
	<tan+?>: ret
.usages:
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (241 bytes)
	lib/std/math.ci:421: (1 byte): negate: bool := false
	<sinh>  : load.z32
	lib/std/math.ci:422: (23 bytes): if (x < (0))
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.z64
	<sinh+?>: clt.f64
	<sinh+?>: jz +19
	lib/std/math.ci:423: (5 bytes): x := -x;
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: neg.f64
	<sinh+?>: set.x2 sp(4)
	lib/std/math.ci:424: (10 bytes): negate := true;
	<sinh+?>: load.c32 1
	<sinh+?>: load.sp(+4)
	<sinh+?>: store.i8
	lib/std/math.ci:427: (39 bytes): if (x > (21))
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.f64 21.000000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +27
	lib/std/math.ci:428: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
	lib/std/math.ci:431: (1 byte): result: float64
	<sinh+?>: load.z64
	lib/std/math.ci:432: (151 bytes): if (x > 0.500000)
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: load.f64 0.500000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +34
	lib/std/math.ci:433: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: dup.x2 sp(6)
	<sinh+?>: neg.f64
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: sub.f64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(2)
	<sinh+?>: jmp +109
	lib/std/math.ci:436: (5 bytes): sq: float64 := x * x
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: dup.x2 sp(6)
	<sinh+?>: mul.f64
	lib/std/math.ci:437: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>: load.f64 -26.305632
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -2894.211356
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -89912.720220
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(8)
	<sinh+?>: mul.f64
	<sinh+?>: set.x2 sp(4)
	lib/std/math.ci:438: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.f64 -173.678954
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 15215.173788
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(4)
	<sinh+?>: inc.sp(-8)
	lib/std/math.ci:441: (19 bytes): if (negate)
	<sinh+?>: load.sp(+8)
	<sinh+?>: load.i8
	<sinh+?>: jz +14
	lib/std/math.ci:442: (10 bytes): return .result := -result;
	<sinh+?>: dup.x2 sp(0)
	<sinh+?>: neg.f64
	<sinh+?>: set.x2 sp(8)
	<sinh+?>: inc.sp(-12)
	<sinh+?>: ret
	lib/std/math.ci:444: (7 bytes): return .result := result;
	<sinh+?>: set.x2 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
.usages:
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	lib/std/math.ci:449: (13 bytes): if (x < (0))
	<cosh>  : dup.x2 sp(1)
	<cosh+?>: load.z64
	<cosh+?>: clt.f64
	<cosh+?>: jz +9
	lib/std/math.ci:450: (5 bytes): x := -x;
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: neg.f64
	<cosh+?>: set.x2 sp(3)
	lib/std/math.ci:452: (35 bytes): if (x > (21))
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: load.f64 21.000000
	<cosh+?>: cgt.f64
	<cosh+?>: jz +23
	lib/std/math.ci:453: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x2 sp(5)
	<cosh+?>: ret
	lib/std/math.ci:455: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: dup.x2 sp(3)
	<cosh+?>: neg.f64
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: add.f64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x2 sp(5)
	<cosh+?>: ret
.usages:
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (166 bytes)
	lib/std/math.ci:464: (12 bytes): if (x == (0))
	<asin>  : dup.x2 sp(1)
	<asin+?>: load.z64
	<asin+?>: ceq.f64
	<asin+?>: jz +8
	lib/std/math.ci:466: (4 bytes): return .result := x;
	<asin+?>: mov.x2 sp(3, 1)
	<asin+?>: ret
	lib/std/math.ci:469: (1 byte): negate: bool := false
	<asin+?>: load.z32
	lib/std/math.ci:470: (23 bytes): if (x < (0))
	<asin+?>: dup.x2 sp(2)
	<asin+?>: load.z64
	<asin+?>: clt.f64
	<asin+?>: jz +19
	lib/std/math.ci:471: (10 bytes): negate := true;
	<asin+?>: load.c32 1
	<asin+?>: load.sp(+4)
	<asin+?>: store.i8
	lib/std/math.ci:472: (5 bytes): x := -x;
	<asin+?>: dup.x2 sp(2)
	<asin+?>: neg.f64
	<asin+?>: set.x2 sp(4)
	lib/std/math.ci:475: (25 bytes): if (x > (1))
	<asin+?>: dup.x2 sp(2)
	<asin+?>: load.f64 1.000000
	<asin+?>: cgt.f64
	<asin+?>: jz +13
	lib/std/math.ci:477: (9 bytes): return .result := nan;
	<asin+?>: load.z128
	<asin+?>: div.f64
	<asin+?>: set.x2 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
	lib/std/math.ci:480: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>: load.f64 1.000000
	<asin+?>: dup.x2 sp(4)
	<asin+?>: dup.x2 sp(6)
	<asin+?>: mul.f64
	<asin+?>: sub.f64
	<asin+?>: nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes): if (x > 0.700000)
	<asin+?>: dup.x2 sp(4)
	<asin+?>: load.f64 0.700000
	<asin+?>: cgt.f64
	<asin+?>: jz +38
	lib/std/math.ci:482: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>: load.f64 3.141593
	<asin+?>: load.f64 2.000000
	<asin+?>: div.f64
	<asin+?>: dup.x2 sp(2)
	<asin+?>: dup.x2 sp(8)
	<asin+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: sub.f64
	<asin+?>: set.x2 sp(2)
	<asin+?>: jmp +14
	lib/std/math.ci:485: (10 bytes): result := float64.atan2(x, result);
	<asin+?>: dup.x2 sp(4)
	<asin+?>: dup.x2 sp(2)
	<asin+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: set.x2 sp(2)
	lib/std/math.ci:488: (19 bytes): if (negate)
	<asin+?>: load.sp(+8)
	<asin+?>: load.i8
	<asin+?>: jz +14
	lib/std/math.ci:489: (10 bytes): return .result := -result;
	<asin+?>: dup.x2 sp(0)
	<asin+?>: neg.f64
	<asin+?>: set.x2 sp(8)
	<asin+?>: inc.sp(-12)
	<asin+?>: ret
	lib/std/math.ci:491: (7 bytes): return .result := result;
	<asin+?>: set.x2 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
.usages:
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (pi / (2) - asin(x))
.usages:
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param degrees: float64 (size: 8, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(degrees * pi / (180))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param radians: float64 (size: 8, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(radians * (180) / pi)
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	lib/std/math.Complex.ci:25: (7 bytes): return .result := {...};
	<Complex>  : mov.x2 sp(3, 1)
	:: (3 bytes): .result.im := (0)
	<Complex+?>: load.z64
	<Complex+?>: set.x2 sp(7)
	<Complex+?>: ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.param im: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (7 bytes)
	lib/std/math.Complex.ci:32: (7 bytes): return .result := {...};
	<Complex>  : mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes): .result.im := im;
	<Complex+?>: mov.x2 sp(7, 1)
	<Complex+?>: ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(-a.re, -a.im)
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re + b.re, a.im + b.im)
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re + b, a.im)
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a + b.re, b.im)
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re - b.re, a.im - b.im)
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re - b, a.im)
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a - b.re, b.im)
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: Complex(a.re * b, a.im * b)
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a * b.re, a * b.im)
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (123 bytes)
	lib/std/math.Complex.ci:87: (79 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : load.z64
	<div+?>: dup.x2 sp(3)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: load.z64
	<div+?>: dup.x2 sp(7)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: clt.f64
	<div+?>: jnz +52
	lib/std/math.Complex.ci:88: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x2 sp(3)
	<div+?>: dup.x2 sp(3)
	<div+?>: div.f64
	lib/std/math.Complex.ci:89: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x2 sp(3)
	<div+?>: dup.x2 sp(2)
	<div+?>: dup.x2 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math.Complex.ci:90: (31 bytes): return .result := {...};
	<div+?>: dup.x2 sp(9)
	<div+?>: dup.x2 sp(4)
	<div+?>: dup.x2 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x2 sp(11)
	<div+?>: dup.x2 sp(4)
	<div+?>: dup.x2 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x2 sp(1)
	<div+?>: dup.x2 sp(5)
	<div+?>: div.f64
	lib/std/math.Complex.ci:96: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x2 sp(5)
	<div+?>: dup.x2 sp(2)
	<div+?>: dup.x2 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math.Complex.ci:97: (31 bytes): return .result := {...};
	<div+?>: dup.x2 sp(9)
	<div+?>: dup.x2 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x2 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x2 sp(11)
	<div+?>: dup.x2 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x2 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: div(a, Complex(b))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.doc: '@public'
.value: div(Complex(a), b)
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(a.re * a.re + a.im * a.im)
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.atan2(a.re, a.im)
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (a.re * a.re + a.im * a.im);
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	lib/std/math.Complex.ci:115: (11 bytes): d: float64 := (a.re * a.re + a.im * a.im)
	<inv>  : dup.x2 sp(1)
	<inv+?>: dup.x2 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x2 sp(5)
	<inv+?>: dup.x2 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	lib/std/math.Complex.ci:116: (20 bytes): return .result := {...};
	<inv+?>: dup.x2 sp(3)
	<inv+?>: dup.x2 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x2 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x2 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x2 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x2 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re, -a.im)
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.log(abs(a)), arg(a))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (100 bytes)
	lib/std/math.Complex.ci:133: (23 bytes): r: float64 := abs(a)
	<pow>  : dup.x4 sp(5)
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x2 sp(4)
	<pow+?>: dup.x2 sp(6)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: nfc(42) ;float64.sqrt(x: float64): float64
	<pow+?>: set.x2 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes): t: float64 := arg(a)
	<pow+?>: dup.x4 sp(7)
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>: set.x2 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>: dup.x2 sp(5)
	<pow+?>: dup.x2 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x2 sp(9)
	<pow+?>: dup.x2 sp(6)
	<pow+?>: nfc(39) ;float64.log(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: add.f64
	lib/std/math.Complex.ci:136: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: dup.x2 sp(9)
	<pow+?>: nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: dup.x2 sp(11)
	<pow+?>: neg.f64
	<pow+?>: dup.x2 sp(6)
	<pow+?>: mul.f64
	<pow+?>: nfc(40) ;float64.exp(x: float64): float64
	<pow+?>: mul.f64
	lib/std/math.Complex.ci:137: (27 bytes): return .result := {...};
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(37) ;float64.cos(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x2 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(36) ;float64.sin(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x2 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: pow(a, Complex(b))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sin(a), cos(a))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(cos(a), sin(a))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(a), exp(neg(a))), 2)
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(a), exp(neg(a))), 2)
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(abs(x), arg(x))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	lib/std/string.ci:5: (16 bytes): if ((str) == null)
	<length>  : dup.x1 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	lib/std/string.ci:6: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x1 sp(3)
	<length+?>: ret
	lib/std/string.ci:8: (1 byte): result: int32 := 0
	<length+?>: load.z32
	lib/std/string.ci:9: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	lib/std/string.ci:9: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	lib/std/string.ci:9: (10 bytes): str[result]
	<length+?>: dup.x1 sp(2)
	<length+?>: dup.x1 sp(1)
	<length+?>: add.i32
	<length+?>: load.i8
	<length+?>: jnz -10
	lib/std/string.ci:11: (3 bytes): return .result := result;
	<length+?>: set.x1 sp(3)
	<length+?>: ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	lib/std/string.ci:16: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	lib/std/string.ci:17: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x1 sp(3)
	<indexOf+?>: dup.x1 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.i8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	lib/std/string.ci:18: (3 bytes): return .result := i;
	<indexOf+?>: set.x1 sp(4)
	<indexOf+?>: ret
	lib/std/string.ci:16: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	lib/std/string.ci:16: (10 bytes): str[i]
	<indexOf+?>: dup.x1 sp(3)
	<indexOf+?>: dup.x1 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	lib/std/string.ci:21: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x1 sp(4)
	<indexOf+?>: ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	lib/std/string.ci:26: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	lib/std/string.ci:27: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	lib/std/string.ci:28: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x1 sp(4)
	<lastIndexOf+?>: dup.x1 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	lib/std/string.ci:29: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x1 sp(1, 0)
	lib/std/string.ci:27: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	lib/std/string.ci:27: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x1 sp(4)
	<lastIndexOf+?>: dup.x1 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	lib/std/string.ci:32: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x1 sp(4)
	<lastIndexOf+?>: ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	lib/std/string.ci:37: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	lib/std/string.ci:38: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: dup.x1 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: dup.x1 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	lib/std/string.ci:39: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	lib/std/string.ci:37: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	lib/std/string.ci:37: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x1 sp(3)
	<startsWith+?>: dup.x1 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	lib/std/string.ci:42: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	lib/std/string.ci:47: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:48: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x1 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:49: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x1 sp(0)
	<endsWith+?>: dup.x1 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	lib/std/string.ci:50: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	lib/std/string.ci:52: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	lib/std/string.ci:53: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: dup.x1 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	lib/std/string.ci:54: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	lib/std/string.ci:52: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	lib/std/string.ci:52: (9 bytes): i < withLen
	<endsWith+?>: dup.x1 sp(0)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:57: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
.usages:
	cmplGfx/gfxlib.ci:32: referenced as `endsWith`
	cmplGfx/gfxlib.ci:29: referenced as `endsWith`
	cmplGfx/gfxlib.ci:18: referenced as `endsWith`
	cmplGfx/gfxlib.ci:15: referenced as `endsWith`
	cmplGfx/gfxlib.ci:12: referenced as `endsWith`
	cmplGfx/gfxlib.ci:9: referenced as `endsWith`
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	lib/std/string.ci:62: (1 byte): result: int32 := 0
	<compare>  : load.z32
	lib/std/string.ci:63: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	lib/std/string.ci:64: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x1 sp(6)
	<compare+?>: dup.x1 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x1 sp(6)
	<compare+?>: dup.x1 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x1 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x1 sp(2)
	lib/std/string.ci:65: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x1 sp(5)
	<compare+?>: dup.x1 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	lib/std/string.ci:66: (4 bytes): break;
	<compare+?>: jmp +16
	lib/std/string.ci:63: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	lib/std/string.ci:63: (8 bytes): result == 0
	<compare+?>: dup.x1 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	lib/std/string.ci:69: (3 bytes): return .result := result;
	<compare+?>: set.x1 sp(5)
	<compare+?>: ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	lib/std/string.ci:84: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x1 sp(4)
	<ignCaseCmp+?>: ret
.usages:
	cmplGfx/gfxlib.ci:32: referenced as `ignCaseCmp`
	cmplGfx/gfxlib.ci:29: referenced as `ignCaseCmp`
	cmplGfx/gfxlib.ci:18: referenced as `ignCaseCmp`
	cmplGfx/gfxlib.ci:15: referenced as `ignCaseCmp`
	cmplGfx/gfxlib.ci:12: referenced as `ignCaseCmp`
	cmplGfx/gfxlib.ci:9: referenced as `ignCaseCmp`
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	lib/std/string.ci:89: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x1 sp(4)
	<caseCmp+?>: ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: startsWith(str, with, caseCmp)
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: endsWith(str, with, caseCmp)
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: compare(str, with, caseCmp)
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param chr: char (size: 4, cast: i32)
.doc: 'Check if a string contains the given character'
.value: indexOf(str, chr) >= 0
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field padLen: int32 (size: 4, cast: const variable(i32))
.field precision: int32 (size: 4, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (84 bytes)
	lib/std/string.ci:127: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append>  : load.z32
	<append+?>: jmp +41
	lib/std/string.ci:128: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(3)
	<append+?>: dup.x1 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	lib/std/string.ci:129: (4 bytes): break;
	<append+?>: jmp +38
	lib/std/string.ci:131: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x1 sp(5)
	<append+?>: dup.x1 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:132: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(4)
	lib/std/string.ci:127: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:127: (10 bytes): value[i]
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	lib/std/string.ci:135: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:136: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x1 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(3)
	lib/std/string.ci:138: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x1 sp(4)
	<append+?>: dup.x1 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:139: (4 bytes): return .result := pos;
	<append+?>: mov.x1 sp(5, 2)
	<append+?>: ret
.usages:
	cmplGfx/gfxlib.ci:257: referenced as `append`
	cmplGfx/gfxlib.ci:255: referenced as `append`
	cmplGfx/gfxlib.ci:253: referenced as `append`
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param sign: char (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (657 bytes)
	lib/std/string.ci:147: (1 byte): len: int32 := 0
	<append>  : load.z32
	lib/std/string.ci:148: (4 bytes): digits: char[80]
	<append+?>: inc.sp(+80)
	lib/std/string.ci:150: (3 bytes): radix: int32 := format.radix
	<append+?>: dup.x1 sp(22)
	<append+?>: load.i32
	lib/std/string.ci:151: (54 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: dup.x1 sp(0)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 151
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: dup.x1 sp(0)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 152
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +38
	lib/std/string.ci:156: (27 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x1 sp(25)
	<append+?>: dup.x1 sp(2)
	<append+?>: mod.u32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: load.sp(+8)
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x1 sp(0)
	<append+?>: set.x1 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:155: (7 bytes): value := value / (radix)
	<append+?>: dup.x1 sp(24)
	<append+?>: dup.x1 sp(1)
	<append+?>: div.u32
	<append+?>: set.x1 sp(25)
	lib/std/string.ci:155: (8 bytes): value > (0)
	<append+?>: dup.x1 sp(24)
	<append+?>: load.z32
	<append+?>: cgt.u32
	<append+?>: jnz -38
	lib/std/string.ci:158: (29 bytes): if (len == 0)
	<append+?>: dup.x1 sp(21)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	lib/std/string.ci:159: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+8)
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x1 sp(0)
	<append+?>: set.x1 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:162: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: dup.x1 sp(22)
	<append+?>: sub.i32
	lib/std/string.ci:164: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x1 sp(24)
	<append+?>: inc.i32(+4)
	<append+?>: load.i8
	lib/std/string.ci:165: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	lib/std/string.ci:166: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	lib/std/string.ci:170: (207 bytes): if ((sign) != 0)
	<append+?>: load.sp(+108)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	lib/std/string.ci:171: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:172: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.i8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +95
	lib/std/string.ci:174: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:175: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 175
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:177: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:174: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:174: (8 bytes): maxLen > 0
	<append+?>: dup.x1 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:180: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 180
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes): output[pos] := sign;
	<append+?>: load.sp(+108)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:182: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:186: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:187: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 187
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:189: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:186: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:186: (8 bytes): maxLen > 0
	<append+?>: dup.x1 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:193: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +85
	lib/std/string.ci:194: (52 bytes): assert(i < (output.length));
	<append+?>: dup.x1 sp(0)
	<append+?>: dup.x1 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 194
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+16)
	<append+?>: dup.x1 sp(25)
	<append+?>: dup.x1 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x1 sp(31)
	<append+?>: dup.x1 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:196: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(30)
	lib/std/string.ci:193: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:193: (9 bytes): i < len
	<append+?>: dup.x1 sp(0)
	<append+?>: dup.x1 sp(25)
	<append+?>: clt.i32
	<append+?>: jnz -86
	<append+?>: inc.sp(-4)
	lib/std/string.ci:199: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:200: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x1 sp(30)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:202: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:203: (8 bytes): return .result := pos;
	<append+?>: mov.x1 sp(31, 28)
	<append+?>: inc.sp(-96)
	<append+?>: ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return .result := append(output, pos, 0, value, format);
}
.instructions: (23 bytes)
	lib/std/string.ci:208: (23 bytes): return .result := append(output, pos, 0, value, format);
	<append>  : load.z32
	<append+?>: dup.x2 sp(5)
	<append+?>: dup.x1 sp(6)
	<append+?>: load.z32
	<append+?>: dup.x1 sp(7)
	<append+?>: dup.x1 sp(7)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-24)
	<append+?>: set.x1 sp(7)
	<append+?>: ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (value < 0) {
		sign := ('-');
		value := -value;
	}
	return .result := append(output, pos, sign, value, format);
}
.instructions: (49 bytes)
	lib/std/string.ci:213: (1 byte): sign: int32 := 0
	<append>  : load.z32
	lib/std/string.ci:214: (20 bytes): if (value < 0)
	<append+?>: dup.x1 sp(3)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +16
	lib/std/string.ci:215: (7 bytes): sign := ('-');
	<append+?>: load.c32 45
	<append+?>: set.x1 sp(1)
	lib/std/string.ci:216: (5 bytes): value := -value;
	<append+?>: dup.x1 sp(3)
	<append+?>: neg.i32
	<append+?>: set.x1 sp(4)
	lib/std/string.ci:218: (28 bytes): return .result := append(output, pos, sign, value, format);
	<append+?>: load.z32
	<append+?>: dup.x2 sp(6)
	<append+?>: dup.x1 sp(7)
	<append+?>: dup.x1 sp(4)
	<append+?>: dup.x1 sp(8)
	<append+?>: dup.x1 sp(8)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-24)
	<append+?>: set.x1 sp(8)
	<append+?>: inc.sp(-4)
	<append+?>: ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		format.radix := 10;
		format.padChr := (0);
		format.padLen := 0;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (25 bytes)
	lib/std/string.ci:224: (25 bytes): return .result := append(output, pos, value, format);
	<append>  : load.z32
	<append+?>: dup.x2 sp(4)
	<append+?>: dup.x1 sp(5)
	<append+?>: dup.x1 sp(5)
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-20)
	<append+?>: set.x1 sp(6)
	<append+?>: ret
.usages:
	cmplGfx/gfxlib.ci:258: referenced as `append`
	cmplGfx/gfxlib.ci:256: referenced as `append`
	cmplGfx/gfxlib.ci:254: referenced as `append`
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, cast: variable(val))
.field x: float64 (size: 0, cast: inline)
.field y: float64 (size: 0, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	lib/vec/vec2d.ci:17: (7 bytes): return .result := {...};
	<vec2d>  : mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x2 sp(7, 1)
	<vec2d+?>: ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.doc: 'Dot product'
.value: a.x * b.x + a.y * b.y
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplGfx/gfxlib.ci:327: referenced as `vec4f`
	cmplGfx/gfxlib.ci:327: referenced as `vec4f`
	cmplGfx/gfxlib.ci:321: referenced as `vec4f`
	cmplGfx/gfxlib.ci:321: referenced as `vec4f`
	cmplGfx/gfxlib.ci:201: referenced as `vec4f`
	cmplGfx/gfxlib.ci:200: referenced as `vec4f`
	cmplGfx/gfxlib.ci:199: referenced as `vec4f`
	cmplGfx/gfxlib.ci:100: referenced as `vec4f`
	cmplGfx/gfxlib.ci:88: referenced as `vec4f`
	cmplGfx/gfxlib.ci:88: referenced as `vec4f`
	cmplGfx/lib/color.ci:105: referenced as `vec4f`
	cmplGfx/lib/color.ci:105: referenced as `vec4f`
	cmplGfx/lib/color.ci:102: referenced as `vec4f`
	cmplGfx/lib/color.ci:99: referenced as `vec4f`
	cmplGfx/lib/color.ci:96: referenced as `vec4f`
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
	internal usages: 4
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	cmplGfx/gfxlib.ci:202: referenced as `data`
	cmplGfx/gfxlib.ci:202: referenced as `data`
	cmplGfx/gfxlib.ci:202: referenced as `data`
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplGfx/gfxlib.ci:201: referenced as `x`
	cmplGfx/gfxlib.ci:200: referenced as `x`
	cmplGfx/gfxlib.ci:199: referenced as `x`
	cmplGfx/gfxlib.ci:111: referenced as `x`
	cmplGfx/gfxlib.ci:101: referenced as `x`
	cmplGfx/lib/color.ci:106: referenced as `x`
	cmplGfx/lib/color.ci:102: referenced as `x`
	cmplGfx/lib/color.ci:99: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplGfx/gfxlib.ci:201: referenced as `y`
	cmplGfx/gfxlib.ci:200: referenced as `y`
	cmplGfx/gfxlib.ci:199: referenced as `y`
	cmplGfx/gfxlib.ci:109: referenced as `y`
	cmplGfx/gfxlib.ci:102: referenced as `y`
	cmplGfx/lib/color.ci:107: referenced as `y`
	cmplGfx/lib/color.ci:102: referenced as `y`
	cmplGfx/lib/color.ci:99: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplGfx/gfxlib.ci:201: referenced as `z`
	cmplGfx/gfxlib.ci:200: referenced as `z`
	cmplGfx/gfxlib.ci:199: referenced as `z`
	cmplGfx/gfxlib.ci:103: referenced as `z`
	cmplGfx/lib/color.ci:108: referenced as `z`
	cmplGfx/lib/color.ci:102: referenced as `z`
	cmplGfx/lib/color.ci:99: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplGfx/gfxlib.ci:201: referenced as `w`
	cmplGfx/gfxlib.ci:200: referenced as `w`
	cmplGfx/gfxlib.ci:199: referenced as `w`
	cmplGfx/gfxlib.ci:104: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.param w: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (13 bytes)
	lib/vec/vec4f.ci:29: (13 bytes): return .result := {...};
	<vec4f>  : mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes): .result.y := y;
	<vec4f+?>: mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes): .result.z := z;
	<vec4f+?>: mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes): .result.w := w;
	<vec4f+?>: mov.x1 sp(8, 1)
	<vec4f+?>: ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.doc: 'Initialize with given x, y, z components, and w with 0'
.value: vec4f(x, y, z, 0.000000)
.usages:
	cmplGfx/lib/color.ci:139: referenced as `vec4f`
	cmplGfx/lib/color.ci:137: referenced as `vec4f`
	cmplGfx/lib/color.ci:134: referenced as `vec4f`
	cmplGfx/lib/color.ci:131: referenced as `vec4f`
	cmplGfx/lib/color.ci:128: referenced as `vec4f`
	cmplGfx/lib/color.ci:125: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(val, val, val, val)
.usages:
	cmplGfx/lib/color.ci:111: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(struct(rhs), neg.p4f))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(struct(rhs), struct(lhs), min.p4f))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(struct(rhs), struct(lhs), max.p4f))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(struct(rhs), struct(lhs), p4x.dp3))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(struct(rhs), struct(lhs), p4x.dph))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product'
.value: float32(emit(struct(rhs), struct(lhs), p4x.dp4))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(v, v))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(v, vec4f(len(v)))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, cast: variable(val))
.field data: float32[16] (size: 64, cast: variable(val))
.field v: vec4f[4] (size: 64, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
}
.instructions: (49 bytes)
	lib/vec/mat4f.ci:31: (49 bytes): return .result := {...};
	<mat4f>  : mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes): .result.x.y := xy;
	<mat4f+?>: mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes): .result.x.z := xz;
	<mat4f+?>: mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes): .result.x.w := xw;
	<mat4f+?>: mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes): .result.y.x := yx;
	<mat4f+?>: mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes): .result.y.y := yy;
	<mat4f+?>: mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes): .result.y.z := yz;
	<mat4f+?>: mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes): .result.y.w := yw;
	<mat4f+?>: mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes): .result.z.x := zx;
	<mat4f+?>: mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes): .result.z.y := zy;
	<mat4f+?>: mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes): .result.z.z := zz;
	<mat4f+?>: mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes): .result.z.w := zw;
	<mat4f+?>: mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes): .result.w.x := wx;
	<mat4f+?>: mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes): .result.w.y := wy;
	<mat4f+?>: mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes): .result.w.z := wz;
	<mat4f+?>: mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes): .result.w.w := ww;
	<mat4f+?>: mov.x1 sp(32, 1)
	<mat4f+?>: ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	lib/vec/mat4f.ci:41: (21 bytes): return .result := {...};
	<mat4f>  : dup.x1 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x1 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x1 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x1 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(21)
	<mat4f+?>: ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		transposed.x.x := rhs.x.x;
		transposed.x.y := rhs.y.x;
		transposed.x.z := rhs.z.x;
		transposed.x.w := rhs.w.x;
		transposed.y.x := rhs.x.y;
		transposed.y.y := rhs.y.y;
		transposed.y.z := rhs.z.y;
		transposed.y.w := rhs.w.y;
		transposed.z.x := rhs.x.z;
		transposed.z.y := rhs.y.z;
		transposed.z.z := rhs.z.z;
		transposed.z.w := rhs.w.z;
		transposed.w.x := rhs.x.w;
		transposed.w.y := rhs.y.w;
		transposed.w.z := rhs.z.w;
		transposed.w.w := rhs.w.w;
	};
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (417 bytes)
	lib/vec/mat4f.ci:53: (144 bytes): transposed: mat4f := {...}
	<mul>  : inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes): transposed.x.x := rhs.x.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes): transposed.x.y := rhs.y.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes): transposed.x.z := rhs.z.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes): transposed.x.w := rhs.w.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes): transposed.y.x := rhs.x.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+4)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes): transposed.y.y := rhs.y.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+20)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes): transposed.y.z := rhs.z.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+36)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes): transposed.y.w := rhs.w.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+52)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes): transposed.z.x := rhs.x.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes): transposed.z.y := rhs.y.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+24)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes): transposed.z.z := rhs.z.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+40)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes): transposed.z.w := rhs.w.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+56)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes): transposed.w.x := rhs.x.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+12)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes): transposed.w.y := rhs.y.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+28)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes): transposed.w.z := rhs.z.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+44)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes): transposed.w.w := rhs.w.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+60)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes): return .result := {...};
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0, cast: static const inline)
.field create: function (size: 0, cast: static const inline)
.field append: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field peek: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field readLine: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field flush: function (size: 0, cast: static const inline)
.field close: function (size: 0, cast: static const inline)
.field in: File (size: 0, cast: static const inline)
.field out: File (size: 0, cast: static const inline)
.field err: File (size: 0, cast: static const inline)
.field log: File (size: 0, cast: static const inline)
.usages:
	internal usages: 15
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(44)
.usages:
	internal usages: 1
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(45)
.usages:
	internal usages: 1
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(46)
.usages:
	internal usages: 1
}
File.read(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(47)
.usages:
	internal usages: 1
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(48)
.usages:
	internal usages: 1
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(49)
.usages:
	internal usages: 1
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readLine'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(50)
.usages:
	internal usages: 1
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param byte: uint8 (size: 4, cast: variable(u32))
.value: nfc(51)
.usages:
	internal usages: 1
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(52)
.usages:
	internal usages: 1
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(53)
.usages:
	internal usages: 1
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(54)
.usages:
	internal usages: 1
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.value: nfc(55)
.usages:
	internal usages: 1
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.value: nfc(56)
.usages:
	internal usages: 1
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.value: nfc(57)
.usages:
	internal usages: 1
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.value: nfc(58)
.usages:
	internal usages: 1
}
gxRect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'gxRect'
.field x: int32 (size: 4, cast: variable(i32))
.field y: int32 (size: 4, cast: variable(i32))
.field w: int32 (size: 4, cast: variable(i32))
.field h: int32 (size: 4, cast: variable(i32))
.usages:
	cmplGfx/gfxlib.ci:119: referenced as `gxRect`
	cmplGfx/gfxlib.ci:118: referenced as `gxRect`
	cmplGfx/gfxlib.ci:89: referenced as `gxRect`
	cmplGfx/gfxlib.ci:88: referenced as `gxRect`
	cmplGfx/gfxlib.ci:49: referenced as `gxRect`
	cmplGfx/lib/color.ci:157: referenced as `gxRect`
	cmplGfx/lib/color.ci:144: referenced as `gxRect`
	internal usages: 9
}
gxRect.x: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.owner: gxRect
.usages:
	cmplGfx/gfxlib.ci:120: referenced as `x`
	cmplGfx/gfxlib.ci:120: referenced as `x`
	cmplGfx/gfxlib.ci:110: referenced as `x`
	cmplGfx/gfxlib.ci:110: referenced as `x`
	cmplGfx/gfxlib.ci:90: referenced as `x`
	cmplGfx/gfxlib.ci:90: referenced as `x`
	cmplGfx/gfxlib.ci:72: referenced as `x`
	cmplGfx/gfxlib.ci:55: referenced as `x`
	cmplGfx/gfxlib.ci:54: referenced as `x`
	cmplGfx/gfxlib.ci:51: referenced as `x`
	cmplGfx/lib/color.ci:183: referenced as `x`
	cmplGfx/lib/color.ci:167: referenced as `x`
	cmplGfx/lib/color.ci:165: referenced as `x`
	cmplGfx/lib/color.ci:161: referenced as `x`
	internal usages: 1
}
gxRect.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.owner: gxRect
.usages:
	cmplGfx/gfxlib.ci:121: referenced as `y`
	cmplGfx/gfxlib.ci:121: referenced as `y`
	cmplGfx/gfxlib.ci:108: referenced as `y`
	cmplGfx/gfxlib.ci:108: referenced as `y`
	cmplGfx/gfxlib.ci:91: referenced as `y`
	cmplGfx/gfxlib.ci:91: referenced as `y`
	cmplGfx/gfxlib.ci:73: referenced as `y`
	cmplGfx/gfxlib.ci:59: referenced as `y`
	cmplGfx/gfxlib.ci:58: referenced as `y`
	cmplGfx/gfxlib.ci:52: referenced as `y`
	cmplGfx/lib/color.ci:183: referenced as `y`
	cmplGfx/lib/color.ci:168: referenced as `y`
	cmplGfx/lib/color.ci:166: referenced as `y`
	cmplGfx/lib/color.ci:160: referenced as `y`
	internal usages: 1
}
gxRect.w: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'w'
.owner: gxRect
.usages:
	cmplGfx/gfxlib.ci:139: referenced as `w`
	cmplGfx/gfxlib.ci:131: referenced as `w`
	cmplGfx/gfxlib.ci:122: referenced as `w`
	cmplGfx/gfxlib.ci:122: referenced as `w`
	cmplGfx/gfxlib.ci:110: referenced as `w`
	cmplGfx/gfxlib.ci:92: referenced as `w`
	cmplGfx/gfxlib.ci:92: referenced as `w`
	cmplGfx/gfxlib.ci:75: referenced as `w`
	cmplGfx/gfxlib.ci:72: referenced as `w`
	cmplGfx/gfxlib.ci:64: referenced as `w`
	cmplGfx/gfxlib.ci:63: referenced as `w`
	cmplGfx/gfxlib.ci:51: referenced as `w`
	cmplGfx/lib/color.ci:172: referenced as `w`
	cmplGfx/lib/color.ci:167: referenced as `w`
	cmplGfx/lib/color.ci:158: referenced as `w`
	cmplGfx/lib/color.ci:161: referenced as `w`
	internal usages: 1
}
gxRect.h: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'h'
.owner: gxRect
.usages:
	cmplGfx/gfxlib.ci:138: referenced as `h`
	cmplGfx/gfxlib.ci:134: referenced as `h`
	cmplGfx/gfxlib.ci:123: referenced as `h`
	cmplGfx/gfxlib.ci:123: referenced as `h`
	cmplGfx/gfxlib.ci:108: referenced as `h`
	cmplGfx/gfxlib.ci:93: referenced as `h`
	cmplGfx/gfxlib.ci:93: referenced as `h`
	cmplGfx/gfxlib.ci:78: referenced as `h`
	cmplGfx/gfxlib.ci:73: referenced as `h`
	cmplGfx/gfxlib.ci:69: referenced as `h`
	cmplGfx/gfxlib.ci:68: referenced as `h`
	cmplGfx/gfxlib.ci:52: referenced as `h`
	cmplGfx/lib/color.ci:183: referenced as `h`
	cmplGfx/lib/color.ci:178: referenced as `h`
	cmplGfx/lib/color.ci:176: referenced as `h`
	cmplGfx/lib/color.ci:175: referenced as `h`
	cmplGfx/lib/color.ci:174: referenced as `h`
	cmplGfx/lib/color.ci:173: referenced as `h`
	cmplGfx/lib/color.ci:168: referenced as `h`
	cmplGfx/lib/color.ci:159: referenced as `h`
	internal usages: 1
}
gxSurf: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'gxSurf'
.field create: function (size: 0, cast: static const inline)
.field create3d: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openBmp: function (size: 0, cast: static const inline)
.field openPng: function (size: 0, cast: static const inline)
.field openJpg: function (size: 0, cast: static const inline)
.field openFnt: function (size: 0, cast: static const inline)
.field saveBmp: function (size: 0, cast: static const inline)
.field width: function (size: 0, cast: static const inline)
.field height: function (size: 0, cast: static const inline)
.field depth: function (size: 0, cast: static const inline)
.field get: function (size: 0, cast: static const inline)
.field set: function (size: 0, cast: static const inline)
.field tex: function (size: 0, cast: static const inline)
.field drawRect: function (size: 0, cast: static const inline)
.field fillRect: function (size: 0, cast: static const inline)
.field drawOval: function (size: 0, cast: static const inline)
.field fillOval: function (size: 0, cast: static const inline)
.field drawLine: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field clipText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field blend: function (size: 0, cast: static const inline)
.field resize: function (size: 0, cast: static const inline)
.field colorMap: function (size: 0, cast: static const inline)
.field colorMat: function (size: 0, cast: static const inline)
.field calcHist: function (size: 0, cast: static const inline)
.field drawMesh: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:358: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:325: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:324: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:292: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:291: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:290: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:288: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:288: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:277: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:274: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:265: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:150: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:118: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:118: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:88: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:85: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:49: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:46: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:46: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:40: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:40: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:39: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:39: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:19: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:16: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:13: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:10: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:8: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:5: referenced as `gxSurf`
	cmplGfx/lib/color.ci:144: referenced as `gxSurf`
	internal usages: 38
}
gxSurf.create(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(77)
.usages:
	cmplGfx/gfxlib.ci:40: referenced as `create`
	cmplGfx/gfxlib.ci:5: referenced as `create`
	internal usages: 1
}
gxSurf.create3d(width: int32, height: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.value: nfc(78)
.usages:
	cmplGfx/gfxlib.ci:265: referenced as `create3d`
	internal usages: 1
}
gxSurf.recycle(recycle: gxSurf, width: int32, height: int32, depth: int32, flags: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param recycle: gxSurf (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(79)
.usages:
	internal usages: 1
}
gxSurf.destroy(surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(80)
.usages:
	cmplGfx/gfxlib.ci:373: referenced as `destroy`
	cmplGfx/gfxlib.ci:372: referenced as `destroy`
	cmplGfx/gfxlib.ci:361: referenced as `destroy`
	cmplGfx/gfxlib.ci:270: referenced as `destroy`
	internal usages: 1
}
gxSurf.openBmp(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(81)
.usages:
	cmplGfx/gfxlib.ci:19: referenced as `openBmp`
	internal usages: 1
}
gxSurf.openPng(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(82)
.usages:
	cmplGfx/gfxlib.ci:16: referenced as `openPng`
	internal usages: 1
}
gxSurf.openJpg(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(83)
.usages:
	cmplGfx/gfxlib.ci:13: referenced as `openJpg`
	cmplGfx/gfxlib.ci:10: referenced as `openJpg`
	internal usages: 1
}
gxSurf.openFnt(path: char[*]): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(84)
.usages:
	internal usages: 1
}
gxSurf.saveBmp(surf: gxSurf, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param path: char[*] (size: 4, cast: variable(ref))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(85)
.usages:
	internal usages: 1
}
gxSurf.width(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(86)
.usages:
	cmplGfx/gfxlib.ci:136: referenced as `width`
	cmplGfx/gfxlib.ci:122: referenced as `width`
	cmplGfx/gfxlib.ci:106: referenced as `width`
	cmplGfx/gfxlib.ci:92: referenced as `width`
	cmplGfx/gfxlib.ci:62: referenced as `width`
	cmplGfx/gfxlib.ci:40: referenced as `width`
	cmplGfx/lib/color.ci:161: referenced as `width`
	internal usages: 1
}
gxSurf.height(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(87)
.usages:
	cmplGfx/gfxlib.ci:137: referenced as `height`
	cmplGfx/gfxlib.ci:123: referenced as `height`
	cmplGfx/gfxlib.ci:107: referenced as `height`
	cmplGfx/gfxlib.ci:93: referenced as `height`
	cmplGfx/gfxlib.ci:67: referenced as `height`
	cmplGfx/gfxlib.ci:40: referenced as `height`
	internal usages: 1
}
gxSurf.depth(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(88)
.usages:
	cmplGfx/gfxlib.ci:40: referenced as `depth`
	internal usages: 1
}
gxSurf.get(surf: gxSurf, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.value: nfc(89)
.usages:
	internal usages: 1
}
gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.value: nfc(90)
.usages:
	cmplGfx/gfxlib.ci:46: referenced as `set`
	cmplGfx/lib/color.ci:183: referenced as `set`
	internal usages: 1
}
gxSurf.tex(surf: gxSurf, x: float32, y: float32): vec4f: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tex'
.owner: gxSurf
.param .result: vec4f (size: 16, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(91)
.usages:
	internal usages: 1
}
gxSurf.drawRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(92)
.usages:
	internal usages: 1
}
gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(93)
.usages:
	cmplGfx/gfxlib.ci:85: referenced as `fillRect`
	cmplGfx/lib/color.ci:164: referenced as `fillRect`
	internal usages: 1
}
gxSurf.drawOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(94)
.usages:
	internal usages: 1
}
gxSurf.fillOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(95)
.usages:
	internal usages: 1
}
gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawLine'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(96)
.usages:
	internal usages: 1
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(97)
.usages:
	internal usages: 1
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param x4: int32 (size: 4, cast: variable(i32))
.param y4: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(98)
.usages:
	internal usages: 1
}
gxSurf.clipText(font: gxSurf, rect: gxRect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param font: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: variable(ref))
.value: nfc(99)
.usages:
	internal usages: 1
}
gxSurf.drawText(surf: gxSurf, x: int32, y: int32, font: gxSurf, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param font: gxSurf (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(100)
.usages:
	internal usages: 1
}
gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.value: nfc(101)
.usages:
	cmplGfx/gfxlib.ci:306: referenced as `copy`
	cmplGfx/gfxlib.ci:302: referenced as `copy`
	cmplGfx/gfxlib.ci:140: referenced as `copy`
	cmplGfx/gfxlib.ci:41: referenced as `copy`
	internal usages: 1
}
gxSurf.blend(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect, blend(base: vec4f, with: vec4f): vec4f): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blend'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: const variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param blend: function (size: 4, cast: variable(ref))
.value: nfc(102)
.usages:
	internal usages: 1
}
gxSurf.resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'resize'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: const variable(ref))
.param src: gxSurf (size: 8, cast: const variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.value: nfc(103)
.usages:
	cmplGfx/gfxlib.ci:350: referenced as `resize`
	internal usages: 1
}
gxSurf.colorMap(surf: gxSurf, roi: gxRect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: const variable(ref))
.value: nfc(104)
.usages:
	internal usages: 1
}
gxSurf.colorMat(surf: gxSurf, roi: gxRect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.value: nfc(105)
.usages:
	internal usages: 1
}
gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcHist'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param rgb: uint32 (size: 4, cast: variable(u32))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(106)
.usages:
	cmplGfx/lib/color.ci:146: referenced as `calcHist`
	internal usages: 1
}
gxSurf.drawMesh(surf: gxSurf, mesh: gxMesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.value: nfc(107)
.usages:
	cmplGfx/gfxlib.ci:250: referenced as `drawMesh`
	internal usages: 1
}
gxMesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 176
.name: 'gxMesh'
.field create: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openObj: function (size: 0, cast: static const inline)
.field open3ds: function (size: 0, cast: static const inline)
.field saveObj: function (size: 0, cast: static const inline)
.field normalize: function (size: 0, cast: static const inline)
.field addVertex: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field setVertex: function (size: 0, cast: static const inline)
.field setNormal: function (size: 0, cast: static const inline)
.field setTexture: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field shine: function (size: 0, cast: static const inline)
.field texture: function (size: 0, cast: static const inline)
.field clearDepth: int64 (size: 0, cast: static const i64)
.field clearColor: int64 (size: 0, cast: static const i64)
.field cullBack: int64 (size: 0, cast: static const i64)
.field cullFront: int64 (size: 0, cast: static const i64)
.field drawPlot: int64 (size: 0, cast: static const i64)
.field drawWire: int64 (size: 0, cast: static const i64)
.field drawFill: int64 (size: 0, cast: static const i64)
.field drawMode: int64 (size: 0, cast: static const i64)
.field useTexture: int64 (size: 0, cast: static const i64)
.field useLights: int64 (size: 0, cast: static const i64)
.field vertices: int64 (size: 8, cast: const variable(i64))
.field triangles: int64 (size: 8, cast: const variable(i64))
.field segments: int64 (size: 8, cast: const variable(i64))
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:264: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:264: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:264: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:264: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:196: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:193: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:193: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:190: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:175: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:151: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:146: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:33: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:30: referenced as `gxMesh`
	cmplGfx/gfxlib.ci:28: referenced as `gxMesh`
	internal usages: 20
}
gxMesh.create(size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(59)
.usages:
	internal usages: 1
}
gxMesh.recycle(recycle: gxMesh, size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param recycle: gxMesh (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(60)
.usages:
	internal usages: 1
}
gxMesh.destroy(mesh: gxMesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.value: nfc(61)
.usages:
	internal usages: 1
}
gxMesh.openObj(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(62)
.usages:
	cmplGfx/gfxlib.ci:30: referenced as `openObj`
	internal usages: 1
}
gxMesh.open3ds(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(63)
.usages:
	cmplGfx/gfxlib.ci:33: referenced as `open3ds`
	internal usages: 1
}
gxMesh.saveObj(mesh: gxMesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(64)
.usages:
	internal usages: 1
}
gxMesh.normalize(mesh: gxMesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param tolerance: float32 (size: 4, cast: variable(f32))
.param center: float32[3] (size: 4, cast: variable(ref))
.param resize: float32[3] (size: 4, cast: variable(ref))
.value: nfc(65)
.usages:
	internal usages: 1
}
gxMesh.addVertex(mesh: gxMesh, x: float32, y: float32, z: float32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(66)
.usages:
	internal usages: 1
}
gxMesh.addFace(mesh: gxMesh, v1: int32, v2: int32, v3: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.value: nfc(67)
.usages:
	internal usages: 1
}
gxMesh.addFace(mesh: gxMesh, v1: int32, v2: int32, v3: int32, v4: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: gxMesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.param v4: int32 (size: 4, cast: variable(i32))
.value: nfc(68)
.usages:
	internal usages: 1
}
gxMesh.setVertex(mesh: gxMesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setVertex'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(69)
.usages:
	internal usages: 1
}
gxMesh.setNormal(mesh: gxMesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setNormal'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(70)
.usages:
	internal usages: 1
}
gxMesh.setTexture(mesh: gxMesh, idx: int32, s: float32, t: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTexture'
.owner: gxMesh
.param .result: bool (size: 4, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param s: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.value: nfc(71)
.usages:
	internal usages: 1
}
gxMesh.ambient(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(72)
.usages:
	internal usages: 1
}
gxMesh.diffuse(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(73)
.usages:
	internal usages: 1
}
gxMesh.specular(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(74)
.usages:
	internal usages: 1
}
gxMesh.shine(mesh: gxMesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.value: nfc(75)
.usages:
	internal usages: 1
}
gxMesh.texture(mesh: gxMesh, surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(76)
.usages:
	internal usages: 1
}
gxMesh.clearDepth: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearDepth'
.owner: gxMesh
.value: 8
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `clearDepth`
}
gxMesh.clearColor: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearColor'
.owner: gxMesh
.value: 4
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `clearColor`
}
gxMesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: gxMesh
.value: 16
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `cullBack`
	cmplGfx/gfxlib.ci:193: referenced as `cullBack`
}
gxMesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: gxMesh
.value: 32
.usages:
	cmplGfx/gfxlib.ci:193: referenced as `cullFront`
}
gxMesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: gxMesh
.value: 1
.usages:
}
gxMesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: gxMesh
.value: 2
.usages:
}
gxMesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: gxMesh
.value: 3
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `drawFill`
}
gxMesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: gxMesh
.value: 3
.usages:
	cmplGfx/gfxlib.ci:196: referenced as `drawMode`
}
gxMesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: gxMesh
.value: 64
.usages:
	cmplGfx/gfxlib.ci:190: referenced as `useTexture`
}
gxMesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: gxMesh
.value: 128
.usages:
	cmplGfx/gfxlib.ci:264: referenced as `useLights`
	cmplGfx/gfxlib.ci:175: referenced as `useLights`
}
gxMesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: gxMesh
.usages:
	cmplGfx/gfxlib.ci:254: referenced as `vertices`
}
gxMesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: gxMesh
.usages:
	cmplGfx/gfxlib.ci:256: referenced as `triangles`
}
gxMesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: gxMesh
.usages:
}
camera: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'camera'
.field projection: function (size: 0, cast: static const inline)
.field lookAt: function (size: 0, cast: static const inline)
.field readUp: function (size: 0, cast: static const inline)
.field readRight: function (size: 0, cast: static const inline)
.field readForward: function (size: 0, cast: static const inline)
.field rotate: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:268: referenced as `camera`
	cmplGfx/gfxlib.ci:244: referenced as `camera`
	cmplGfx/gfxlib.ci:243: referenced as `camera`
	cmplGfx/gfxlib.ci:242: referenced as `camera`
	cmplGfx/gfxlib.ci:241: referenced as `camera`
	cmplGfx/gfxlib.ci:237: referenced as `camera`
	cmplGfx/gfxlib.ci:236: referenced as `camera`
	cmplGfx/gfxlib.ci:232: referenced as `camera`
	cmplGfx/gfxlib.ci:231: referenced as `camera`
	cmplGfx/gfxlib.ci:230: referenced as `camera`
	cmplGfx/gfxlib.ci:229: referenced as `camera`
	cmplGfx/gfxlib.ci:225: referenced as `camera`
	cmplGfx/gfxlib.ci:224: referenced as `camera`
	cmplGfx/gfxlib.ci:223: referenced as `camera`
	cmplGfx/gfxlib.ci:222: referenced as `camera`
	cmplGfx/gfxlib.ci:202: referenced as `camera`
}
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'projection'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param fovy: float32 (size: 4, cast: variable(f32))
.param aspect: float32 (size: 4, cast: variable(f32))
.param near: float32 (size: 4, cast: variable(f32))
.param far: float32 (size: 4, cast: variable(f32))
.value: nfc(108)
.usages:
	cmplGfx/gfxlib.ci:268: referenced as `projection`
	internal usages: 1
}
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lookAt'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param eye: float32[3] (size: 4, cast: variable(ref))
.param at: float32[3] (size: 4, cast: variable(ref))
.param up: float32[3] (size: 4, cast: variable(ref))
.value: nfc(109)
.usages:
	cmplGfx/gfxlib.ci:202: referenced as `lookAt`
	internal usages: 1
}
camera.readUp(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readUp'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(110)
.usages:
	cmplGfx/gfxlib.ci:243: referenced as `readUp`
	cmplGfx/gfxlib.ci:229: referenced as `readUp`
	cmplGfx/gfxlib.ci:222: referenced as `readUp`
	internal usages: 1
}
camera.readRight(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readRight'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(111)
.usages:
	cmplGfx/gfxlib.ci:241: referenced as `readRight`
	cmplGfx/gfxlib.ci:231: referenced as `readRight`
	cmplGfx/gfxlib.ci:224: referenced as `readRight`
	internal usages: 1
}
camera.readForward(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readForward'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(112)
.usages:
	cmplGfx/gfxlib.ci:236: referenced as `readForward`
	internal usages: 1
}
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rotate'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param orbit: float32[3] (size: 4, cast: variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.value: nfc(113)
.usages:
	cmplGfx/gfxlib.ci:232: referenced as `rotate`
	cmplGfx/gfxlib.ci:230: referenced as `rotate`
	cmplGfx/gfxlib.ci:225: referenced as `rotate`
	cmplGfx/gfxlib.ci:223: referenced as `rotate`
	internal usages: 1
}
camera.move(direction: float32[3], amount: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.value: nfc(114)
.usages:
	cmplGfx/gfxlib.ci:244: referenced as `move`
	cmplGfx/gfxlib.ci:242: referenced as `move`
	cmplGfx/gfxlib.ci:237: referenced as `move`
	internal usages: 1
}
lights: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'lights'
.field enabled: function (size: 0, cast: static const inline)
.field enable: function (size: 0, cast: static const inline)
.field position: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field attenuation: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:187: referenced as `lights`
	cmplGfx/gfxlib.ci:187: referenced as `lights`
	cmplGfx/gfxlib.ci:184: referenced as `lights`
	cmplGfx/gfxlib.ci:184: referenced as `lights`
	cmplGfx/gfxlib.ci:181: referenced as `lights`
	cmplGfx/gfxlib.ci:181: referenced as `lights`
	cmplGfx/gfxlib.ci:178: referenced as `lights`
	cmplGfx/gfxlib.ci:178: referenced as `lights`
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.value: nfc(115)
.usages:
	cmplGfx/gfxlib.ci:187: referenced as `enabled`
	cmplGfx/gfxlib.ci:184: referenced as `enabled`
	cmplGfx/gfxlib.ci:181: referenced as `enabled`
	cmplGfx/gfxlib.ci:178: referenced as `enabled`
	internal usages: 1
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param on: bool (size: 4, cast: variable(bool))
.value: nfc(116)
.usages:
	cmplGfx/gfxlib.ci:187: referenced as `enable`
	cmplGfx/gfxlib.ci:184: referenced as `enable`
	cmplGfx/gfxlib.ci:181: referenced as `enable`
	cmplGfx/gfxlib.ci:178: referenced as `enable`
	internal usages: 1
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(117)
.usages:
	internal usages: 1
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(118)
.usages:
	internal usages: 1
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(119)
.usages:
	internal usages: 1
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(120)
.usages:
	internal usages: 1
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param constant: float32 (size: 4, cast: variable(f32))
.param linear: float32 (size: 4, cast: variable(f32))
.param quadratic: float32 (size: 4, cast: variable(f32))
.value: nfc(121)
.usages:
	internal usages: 1
}
Gui: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Gui'
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CONTROL: int64 (size: 0, cast: static const i64)
.field showWindow: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:371: referenced as `Gui`
	cmplGfx/gfxlib.ci:340: referenced as `Gui`
	cmplGfx/gfxlib.ci:335: referenced as `Gui`
	cmplGfx/gfxlib.ci:331: referenced as `Gui`
	cmplGfx/gfxlib.ci:317: referenced as `Gui`
	cmplGfx/gfxlib.ci:305: referenced as `Gui`
	cmplGfx/gfxlib.ci:301: referenced as `Gui`
	cmplGfx/gfxlib.ci:296: referenced as `Gui`
	cmplGfx/gfxlib.ci:284: referenced as `Gui`
	cmplGfx/gfxlib.ci:279: referenced as `Gui`
	cmplGfx/gfxlib.ci:274: referenced as `Gui`
	cmplGfx/gfxlib.ci:269: referenced as `Gui`
	cmplGfx/gfxlib.ci:259: referenced as `Gui`
	cmplGfx/gfxlib.ci:210: referenced as `Gui`
	cmplGfx/gfxlib.ci:205: referenced as `Gui`
	cmplGfx/gfxlib.ci:170: referenced as `Gui`
}
Gui.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Gui
.value: 1
.usages:
	cmplGfx/gfxlib.ci:335: referenced as `KEY_PRESS`
	cmplGfx/gfxlib.ci:296: referenced as `KEY_PRESS`
	cmplGfx/gfxlib.ci:170: referenced as `KEY_PRESS`
}
Gui.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Gui
.value: 2
.usages:
	cmplGfx/gfxlib.ci:340: referenced as `KEY_RELEASE`
}
Gui.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Gui
.value: 3
.usages:
	cmplGfx/gfxlib.ci:301: referenced as `MOUSE_PRESS`
	cmplGfx/gfxlib.ci:205: referenced as `MOUSE_PRESS`
}
Gui.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Gui
.value: 5
.usages:
	cmplGfx/gfxlib.ci:210: referenced as `MOUSE_MOTION`
}
Gui.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Gui
.value: 4
.usages:
	cmplGfx/gfxlib.ci:305: referenced as `MOUSE_RELEASE`
}
Gui.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Gui
.value: 6
.usages:
}
Gui.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Gui
.value: 100
.usages:
	cmplGfx/gfxlib.ci:331: referenced as `WINDOW_CLOSE`
}
Gui.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Gui
.value: 101
.usages:
}
Gui.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Gui
.value: 102
.usages:
}
Gui.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Gui
.value: 1
.usages:
}
Gui.KEY_MASK_CONTROL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CONTROL'
.owner: Gui
.value: 2
.usages:
}
Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'showWindow'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param closure: pointer (size: 4, cast: variable(ref))
.param onEvent: function (size: 4, cast: variable(ref))
.value: nfc(122)
.usages:
	cmplGfx/gfxlib.ci:371: referenced as `showWindow`
	cmplGfx/gfxlib.ci:317: referenced as `showWindow`
	cmplGfx/gfxlib.ci:284: referenced as `showWindow`
	cmplGfx/gfxlib.ci:279: referenced as `showWindow`
	cmplGfx/gfxlib.ci:274: referenced as `showWindow`
	cmplGfx/gfxlib.ci:269: referenced as `showWindow`
	internal usages: 1
}
Gui.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param title: char[*] (size: 4, cast: variable(ref))
.value: nfc(123)
.usages:
	cmplGfx/gfxlib.ci:259: referenced as `setTitle`
	internal usages: 1
}
argb: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:2'
.field v: uint32 (size: 4, cast: variable(u32))
.field <?>: argb.<?> (size: 4, cast: variable(val))
.field b: uint8 (size: 0, cast: inline)
.field g: uint8 (size: 0, cast: inline)
.field r: uint8 (size: 0, cast: inline)
.field a: uint8 (size: 0, cast: inline)
.doc: 'an 32 bit argb color'
.usages:
	cmplGfx/gfxlib.ci:46: referenced as `argb`
	cmplGfx/lib/color.ci:94: referenced as `argb`
	cmplGfx/lib/color.ci:94: referenced as `argb`
	cmplGfx/lib/color.ci:84: referenced as `argb`
	cmplGfx/lib/color.ci:84: referenced as `argb`
	cmplGfx/lib/color.ci:84: referenced as `argb`
	cmplGfx/lib/color.ci:81: referenced as `argb`
	cmplGfx/lib/color.ci:79: referenced as `argb`
	cmplGfx/lib/color.ci:77: referenced as `argb`
	cmplGfx/lib/color.ci:75: referenced as `argb`
	cmplGfx/lib/color.ci:73: referenced as `argb`
	cmplGfx/lib/color.ci:23: referenced as `argb`
	cmplGfx/lib/color.ci:21: referenced as `argb`
	cmplGfx/lib/color.ci:2: defined as `argb`
}
argb.v: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'v'
.file: 'cmplGfx/lib/color.ci:4'
.owner: argb
.usages:
	cmplGfx/lib/color.ci:4: defined as `v`
}
argb.<?>: argb.<?> {
.kind: variable(val)
.base: `argb.<?>`
.size: 4
.name: '<?>'
.file: 'cmplGfx/lib/color.ci:187'
.owner: argb
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.field a: uint8 (size: 1, cast: variable(u32))
.usages:
	cmplGfx/lib/color.ci:187: defined as `<?>`
}
argb.<?>.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb.<?>
.doc: 'blue component'
.usages:
	cmplGfx/lib/color.ci:7: defined as `b`
}
argb.<?>.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb.<?>
.doc: 'green component'
.usages:
	cmplGfx/lib/color.ci:10: defined as `g`
}
argb.<?>.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb.<?>
.doc: 'red component'
.usages:
	cmplGfx/lib/color.ci:13: defined as `r`
}
argb.<?>.a: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb.<?>
.doc: 'alpha component'
.usages:
	cmplGfx/lib/color.ci:16: defined as `a`
}
argb.b: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb
.doc: 'blue component'
.value: b: uint8
.usages:
}
argb.g: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb
.doc: 'green component'
.value: g: uint8
.usages:
}
argb.r: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb
.doc: 'red component'
.value: r: uint8
.usages:
}
argb.a: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb
.doc: 'alpha component'
.value: a: uint8
.usages:
}
argb(argb: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:21'
.param .result: argb (size: 4, cast: val)
.param argb: uint32 (size: 4, cast: u32)
.doc: 'cast unsigned integer to argb value'
.value: argb(emit(uint32(argb)))
.usages:
	cmplGfx/lib/color.ci:176: referenced as `argb`
	cmplGfx/lib/color.ci:175: referenced as `argb`
	cmplGfx/lib/color.ci:174: referenced as `argb`
	cmplGfx/lib/color.ci:173: referenced as `argb`
	cmplGfx/lib/color.ci:60: referenced as `argb`
	cmplGfx/lib/color.ci:58: referenced as `argb`
	cmplGfx/lib/color.ci:46: referenced as `argb`
	cmplGfx/lib/color.ci:21: defined as `argb(argb: uint32): argb`
}
uint32(value: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'uint32'
.file: 'cmplGfx/lib/color.ci:23'
.param .result: uint32 (size: 4, cast: u32)
.param value: argb (size: 4, cast: val)
.doc: 'cast argb value to unsigned integer'
.value: uint32(emit(struct(value)))
.usages:
	cmplGfx/gfxlib.ci:46: referenced as `uint32`
	cmplGfx/lib/color.ci:79: referenced as `uint32`
	cmplGfx/lib/color.ci:77: referenced as `uint32`
	cmplGfx/lib/color.ci:75: referenced as `uint32`
	cmplGfx/lib/color.ci:73: referenced as `uint32`
	cmplGfx/lib/color.ci:23: defined as `uint32(value: argb): uint32`
}
grayClamp(c: int32): uint32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'grayClamp'
.file: 'cmplGfx/lib/color.ci:27'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: int32 (size: 4, cast: variable(i32))
.value: {
	if (c < 0) {
		return .result := 0;
	}
	if (c > 255) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (36 bytes)
	cmplGfx/lib/color.ci:28: (12 bytes): if (c < 0)
	<grayClamp>  : dup.x1 sp(1)
	<grayClamp+?>: load.z32
	<grayClamp+?>: clt.i32
	<grayClamp+?>: jz +8
	cmplGfx/lib/color.ci:29: (4 bytes): return .result := 0;
	<grayClamp+?>: load.z32
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/color.ci:31: (20 bytes): if (c > 255)
	<grayClamp+?>: dup.x1 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.i32
	<grayClamp+?>: jz +12
	cmplGfx/lib/color.ci:32: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/color.ci:34: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x1 sp(2, 1)
	<grayClamp+?>: ret
.usages:
	cmplGfx/lib/color.ci:63: referenced as `grayClamp`
	cmplGfx/lib/color.ci:63: referenced as `grayClamp`
	cmplGfx/lib/color.ci:63: referenced as `grayClamp`
	cmplGfx/lib/color.ci:48: referenced as `grayClamp`
	cmplGfx/lib/color.ci:27: defined as `grayClamp(c: int32): uint32`
}
grayClamp(c: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'grayClamp'
.file: 'cmplGfx/lib/color.ci:37'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: uint32 (size: 4, cast: variable(u32))
.value: {
	if (c > (255)) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (24 bytes)
	cmplGfx/lib/color.ci:38: (20 bytes): if (c > (255))
	<grayClamp>  : dup.x1 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.u32
	<grayClamp+?>: jz +12
	cmplGfx/lib/color.ci:39: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/color.ci:41: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x1 sp(2, 1)
	<grayClamp+?>: ret
.usages:
	cmplGfx/lib/color.ci:65: referenced as `grayClamp`
	cmplGfx/lib/color.ci:65: referenced as `grayClamp`
	cmplGfx/lib/color.ci:65: referenced as `grayClamp`
	cmplGfx/lib/color.ci:50: referenced as `grayClamp`
	cmplGfx/lib/color.ci:37: defined as `grayClamp(c: uint32): uint32`
}
_gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_gray'
.file: 'cmplGfx/lib/color.ci:46'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: variable(u32))
.value: argb((((c << 8) | c) << 8) | c)
.usages:
	cmplGfx/lib/color.ci:50: referenced as `_gray`
	cmplGfx/lib/color.ci:48: referenced as `_gray`
	cmplGfx/lib/color.ci:46: defined as `_gray(c: uint32): argb`
}
gray(c: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:48'
.param .result: argb (size: 4, cast: val)
.param c: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(grayClamp(c))
.usages:
	cmplGfx/lib/color.ci:54: referenced as `gray`
	cmplGfx/lib/color.ci:52: referenced as `gray`
	cmplGfx/lib/color.ci:48: defined as `gray(c: int32): argb`
}
gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:50'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(grayClamp(c))
.usages:
	cmplGfx/lib/color.ci:50: defined as `gray(c: uint32): argb`
}
gray(c: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:52'
.param .result: argb (size: 4, cast: val)
.param c: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
	cmplGfx/lib/color.ci:52: defined as `gray(c: float32): argb`
}
gray(c: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:54'
.param .result: argb (size: 4, cast: val)
.param c: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
	cmplGfx/lib/color.ci:54: defined as `gray(c: float64): argb`
}
_argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'cmplGfx/lib/color.ci:58'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((r << 8) | g) << 8) | b))
.usages:
	cmplGfx/lib/color.ci:65: referenced as `_argb`
	cmplGfx/lib/color.ci:63: referenced as `_argb`
	cmplGfx/lib/color.ci:58: defined as `_argb(r: uint32, g: uint32, b: uint32): argb`
}
_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'cmplGfx/lib/color.ci:60'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b))
.usages:
	cmplGfx/lib/color.ci:60: defined as `_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb`
}
argb(r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:63'
.param .result: argb (size: 4, cast: val)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(grayClamp(r), grayClamp(g), grayClamp(b))
.usages:
	cmplGfx/lib/color.ci:69: referenced as `argb`
	cmplGfx/lib/color.ci:67: referenced as `argb`
	cmplGfx/lib/color.ci:63: defined as `argb(r: int32, g: int32, b: int32): argb`
}
argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:65'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(grayClamp(r), grayClamp(g), grayClamp(b))
.usages:
	cmplGfx/lib/color.ci:90: referenced as `argb`
	cmplGfx/lib/color.ci:65: defined as `argb(r: uint32, g: uint32, b: uint32): argb`
}
argb(r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:67'
.param .result: argb (size: 4, cast: val)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	cmplGfx/lib/color.ci:99: referenced as `argb`
	cmplGfx/lib/color.ci:67: defined as `argb(r: float32, g: float32, b: float32): argb`
}
argb(r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:69'
.param .result: argb (size: 4, cast: val)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	cmplGfx/lib/color.ci:69: defined as `argb(r: float64, g: float64, b: float64): argb`
}
ach(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ach'
.file: 'cmplGfx/lib/color.ci:73'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Alpha channel of the color'
.value: uint32((uint32(col) >> 24) & (255))
.usages:
	cmplGfx/lib/color.ci:176: referenced as `ach`
	cmplGfx/lib/color.ci:73: defined as `ach(col: argb): uint32`
}
rch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'cmplGfx/lib/color.ci:75'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Red channel of the color'
.value: uint32((uint32(col) >> 16) & (255))
.usages:
	cmplGfx/lib/color.ci:175: referenced as `rch`
	cmplGfx/lib/color.ci:87: referenced as `rch`
	cmplGfx/lib/color.ci:87: referenced as `rch`
	cmplGfx/lib/color.ci:81: referenced as `rch`
	cmplGfx/lib/color.ci:75: defined as `rch(col: argb): uint32`
}
gch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'cmplGfx/lib/color.ci:77'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Green channel of the color'
.value: uint32((uint32(col) >> 8) & (255))
.usages:
	cmplGfx/lib/color.ci:174: referenced as `gch`
	cmplGfx/lib/color.ci:88: referenced as `gch`
	cmplGfx/lib/color.ci:88: referenced as `gch`
	cmplGfx/lib/color.ci:81: referenced as `gch`
	cmplGfx/lib/color.ci:77: defined as `gch(col: argb): uint32`
}
bch(col: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'cmplGfx/lib/color.ci:79'
.param .result: uint32 (size: 4, cast: u32)
.param col: argb (size: 4, cast: val)
.doc: 'get the Blue channel of the color'
.value: uint32(uint32(col) & (255))
.usages:
	cmplGfx/lib/color.ci:173: referenced as `bch`
	cmplGfx/lib/color.ci:89: referenced as `bch`
	cmplGfx/lib/color.ci:89: referenced as `bch`
	cmplGfx/lib/color.ci:81: referenced as `bch`
	cmplGfx/lib/color.ci:79: defined as `bch(col: argb): uint32`
}
lum(c: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:81'
.param .result: uint32 (size: 4, cast: u32)
.param c: argb (size: 4, cast: variable(val))
.doc: 'get the luminosity of the color'
.value: uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8)
.usages:
	cmplGfx/lib/color.ci:81: defined as `lum(c: argb): uint32`
}
rgbLerp16(c1: argb, c2: argb, t: uint32): argb: function {
.kind: static const function
.base: `function`
.size: 123
.name: 'rgbLerp16'
.file: 'cmplGfx/lib/color.ci:84'
.param .result: argb (size: 4, cast: variable(val))
.param c1: argb (size: 4, cast: variable(val))
.param c2: argb (size: 4, cast: variable(val))
.param t: uint32 (size: 4, cast: variable(u32))
.doc: 'linear interpolation between `c1` and `c2` by `t`, where t is a 16 bit fixed point'
.value: {
	lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
	r: uint32 := lrpfix16(rch(c1), rch(c2));
	g: uint32 := lrpfix16(gch(c1), gch(c2));
	b: uint32 := lrpfix16(bch(c1), bch(c2));
	return .result := argb(r, g, b);
}
.instructions: (123 bytes)
	cmplGfx/lib/color.ci:87: (25 bytes): r: uint32 := lrpfix16(rch(c1), rch(c2))
	<rgbLerp16>  : dup.x1 sp(3)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/color.ci:88: (25 bytes): g: uint32 := lrpfix16(gch(c1), gch(c2))
	<rgbLerp16+?>: dup.x1 sp(4)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(4)
	<rgbLerp16+?>: dup.x1 sp(6)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/color.ci:89: (21 bytes): b: uint32 := lrpfix16(bch(c1), bch(c2))
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: dup.x1 sp(7)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/color.ci:90: (52 bytes): return .result := argb(r, g, b);
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: load.z32
	<rgbLerp16+?>: dup.x1 sp(2)
	<rgbLerp16+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbLerp16+?>: call
	<rgbLerp16+?>: inc.sp(-4)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: set.x1 sp(8)
	<rgbLerp16+?>: inc.sp(-12)
	<rgbLerp16+?>: ret
.usages:
	cmplGfx/lib/color.ci:94: referenced as `rgbLerp16`
	cmplGfx/lib/color.ci:84: defined as `rgbLerp16(c1: argb, c2: argb, t: uint32): argb`
}
rgbLerp(c1: argb, c2: argb, t: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbLerp'
.file: 'cmplGfx/lib/color.ci:94'
.param .result: argb (size: 4, cast: val)
.param c1: argb (size: 4, cast: val)
.param c2: argb (size: 4, cast: val)
.param t: float64 (size: 8, cast: f64)
.doc: 'linear interpolation between `c1` and `c2` by `t`, where t is between 0. and 1.'
.value: rgbLerp16(c1, c2, uint32(t * ((1 << 16))))
.usages:
	cmplGfx/lib/color.ci:94: defined as `rgbLerp(c1: argb, c2: argb, t: float64): argb`
}
argb(vec: vec4f): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:99'
.param .result: argb (size: 4, cast: val)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'convert a floating point vector to rgb'
.value: argb(vec.x, vec.y, vec.z)
.usages:
	cmplGfx/gfxlib.ci:112: referenced as `argb`
	cmplGfx/lib/color.ci:99: defined as `argb(vec: vec4f): argb`
}
lum(vec: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:102'
.param .result: float32 (size: 4, cast: f32)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'calculate the luminosity of a color'
.value: 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z
.usages:
	cmplGfx/lib/color.ci:102: defined as `lum(vec: vec4f): float32`
}
hsv2rgb(hsv: vec4f): vec4f: function {
.kind: static const function
.base: `function`
.size: 344
.name: 'hsv2rgb'
.file: 'cmplGfx/lib/color.ci:105'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsv: vec4f (size: 16, cast: variable(val))
.doc: 'convert from hsv color space to rgb color space'
.value: {
	h: float32 := hsv.x;
	s: float32 := hsv.y;
	v: float32 := hsv.z;
	if (s == (0)) {
		return .result := vec4f(v);
	}
	h := h * (360 / 60);
	i: int32 := int32(h);
	f: float32 := h - (i);
	u: float32 := v;
	p: float32 := v * ((1) - s);
	q: float32 := v * ((1) - s * f);
	t: float32 := v * ((1) - s * ((1) - f));
	if (i == 0) {
		return .result := vec4f(u, t, p);
	}
	if (i == 1) {
		return .result := vec4f(q, u, p);
	}
	if (i == 2) {
		return .result := vec4f(p, u, t);
	}
	if (i == 3) {
		return .result := vec4f(p, q, u);
	}
	if (i == 4) {
		return .result := vec4f(t, p, u);
	}
	return .result := vec4f(u, p, q);
}
.instructions: (344 bytes)
	cmplGfx/lib/color.ci:106: (2 bytes): h: float32 := hsv.x
	<hsv2rgb>  : dup.x1 sp(1)
	cmplGfx/lib/color.ci:107: (2 bytes): s: float32 := hsv.y
	<hsv2rgb+?>: dup.x1 sp(3)
	cmplGfx/lib/color.ci:108: (2 bytes): v: float32 := hsv.z
	<hsv2rgb+?>: dup.x1 sp(5)
	cmplGfx/lib/color.ci:110: (41 bytes): if (s == (0))
	<hsv2rgb+?>: dup.x1 sp(1)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.f32
	<hsv2rgb+?>: jz +37
	cmplGfx/lib/color.ci:111: (33 bytes): return .result := vec4f(v);
	<hsv2rgb+?>: dup.x1 sp(0)
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(1)
	<hsv2rgb+?>: set.x4 sp(12)
	<hsv2rgb+?>: inc.sp(-12)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:114: (17 bytes): h := h * (360 / 60);
	<hsv2rgb+?>: dup.x1 sp(2)
	<hsv2rgb+?>: load.c32 360
	<hsv2rgb+?>: load.c32 60
	<hsv2rgb+?>: div.i32
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: set.x1 sp(3)
	cmplGfx/lib/color.ci:116: (3 bytes): i: int32 := int32(h)
	<hsv2rgb+?>: dup.x1 sp(2)
	<hsv2rgb+?>: f32.2i32
	cmplGfx/lib/color.ci:117: (6 bytes): f: float32 := h - (i)
	<hsv2rgb+?>: dup.x1 sp(3)
	<hsv2rgb+?>: dup.x1 sp(1)
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: sub.f32
	cmplGfx/lib/color.ci:119: (2 bytes): u: float32 := v
	<hsv2rgb+?>: dup.x1 sp(2)
	cmplGfx/lib/color.ci:120: (11 bytes): p: float32 := v * ((1) - s)
	<hsv2rgb+?>: dup.x1 sp(3)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.ci:121: (14 bytes): q: float32 := v * ((1) - s * f)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.ci:122: (20 bytes): t: float32 := v * ((1) - s * ((1) - f))
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.ci:124: (36 bytes): if (i == 0)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/lib/color.ci:125: (28 bytes): return .result := vec4f(u, t, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:127: (40 bytes): if (i == 1)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 1
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/lib/color.ci:128: (28 bytes): return .result := vec4f(q, u, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:130: (40 bytes): if (i == 2)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 2
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/lib/color.ci:131: (28 bytes): return .result := vec4f(p, u, t);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:133: (40 bytes): if (i == 3)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 3
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/lib/color.ci:134: (28 bytes): return .result := vec4f(p, q, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(9)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:136: (40 bytes): if (i == 4)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 4
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/lib/color.ci:137: (28 bytes): return .result := vec4f(t, p, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(9)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.ci:139: (28 bytes): return .result := vec4f(u, p, q);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
.usages:
	cmplGfx/lib/color.ci:105: defined as `hsv2rgb(hsv: vec4f): vec4f`
}
drawHist(image: gxSurf, roi: gxRect, hist: uint32): void: function {
.kind: static const function
.base: `function`
.size: 342
.name: 'drawHist'
.file: 'cmplGfx/lib/color.ci:144'
.param .result: void (size: 0, cast: variable(void))
.param image: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.param hist: uint32 (size: 4, cast: variable(u32))
.value: {
	lut: uint32[256];
	image.calcHist(image, roi, hist, lut);
	rect: gxRect := {
		rect.w := 256;
		rect.h := 128;
		rect.y := margin;
		rect.x := image.width(image) - rect.w - margin;
	};
	image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	for (x: int32 := 0; x < rect.w; x := x + 1) {
		bv: int32 := bch(argb(lut[x])) * (rect.h) / (256);
		gv: int32 := gch(argb(lut[x])) * (rect.h) / (256);
		rv: int32 := rch(argb(lut[x])) * (rect.h) / (256);
		lv: int32 := ach(argb(lut[x])) * (rect.h) / (256);
		for (y: int32 := 0; y < rect.h; y := y + 1) {
			b: uint32 := colB * (uint32(y < bv));
			g: uint32 := colG * (uint32(y < gv));
			r: uint32 := colR * (uint32(y < rv));
			l: uint32 := colL * (uint32(y < lv));
			image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
		}
	}
}
.instructions: (342 bytes)
	cmplGfx/lib/color.ci:145: (4 bytes): lut: uint32[256]
	<drawHist>  : inc.sp(+1024)
	cmplGfx/lib/color.ci:146: (23 bytes): image.calcHist(image, roi, hist, lut);
	<drawHist+?>: load.sp(+1036)
	<drawHist+?>: load.i64
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+16)
	<drawHist+?>: nfc(106) ;gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void
	cmplGfx/lib/color.ci:157: (43 bytes): rect: gxRect := {...}
	<drawHist+?>: inc.sp(+16)
	cmplGfx/lib/color.ci:158: (7 bytes): rect.w := 256;
	<drawHist+?>: load.c32 256
	<drawHist+?>: set.x1 sp(3)
	cmplGfx/lib/color.ci:159: (7 bytes): rect.h := 128;
	<drawHist+?>: load.c32 128
	<drawHist+?>: set.x1 sp(4)
	cmplGfx/lib/color.ci:160: (7 bytes): rect.y := margin;
	<drawHist+?>: load.c32 20
	<drawHist+?>: set.x1 sp(2)
	cmplGfx/lib/color.ci:161: (18 bytes): rect.x := image.width(image) - rect.w - margin;
	<drawHist+?>: load.sp(+1052)
	<drawHist+?>: load.i64
	<drawHist+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: sub.i32
	<drawHist+?>: inc.i32(-20)
	<drawHist+?>: set.x1 sp(1)
	cmplGfx/lib/color.ci:164: (40 bytes): image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	<drawHist+?>: load.sp(+1052)
	<drawHist+?>: load.i64
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: inc.i32(-7)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: inc.i32(-7)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(+7)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: dup.x1 sp(9)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(+7)
	<drawHist+?>: load.z32
	<drawHist+?>: nfc(93) ;gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	cmplGfx/lib/color.ci:172: (227 bytes): for (x: int32 := 0; x < rect.w; x := x + 1)
	<drawHist+?>: load.z32
	<drawHist+?>: jmp +213
	cmplGfx/lib/color.ci:173: (22 bytes): bv: int32 := bch(argb(lut[x])) * (rect.h) / (256)
	<drawHist+?>: load.sp(+20)
	<drawHist+?>: dup.x1 sp(1)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:174: (24 bytes): gv: int32 := gch(argb(lut[x])) * (rect.h) / (256)
	<drawHist+?>: load.sp(+24)
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x008
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:175: (24 bytes): rv: int32 := rch(argb(lut[x])) * (rect.h) / (256)
	<drawHist+?>: load.sp(+28)
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x010
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:176: (24 bytes): lv: int32 := ach(argb(lut[x])) * (rect.h) / (256)
	<drawHist+?>: load.sp(+32)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x018
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:178: (107 bytes): for (y: int32 := 0; y < rect.h; y := y + 1)
	<drawHist+?>: load.z32
	<drawHist+?>: jmp +93
	cmplGfx/lib/color.ci:179: (11 bytes): b: uint32 := colB * (uint32(y < bv))
	<drawHist+?>: load.c32 4420038
	<drawHist+?>: dup.x1 sp(1)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:180: (11 bytes): g: uint32 := colG * (uint32(y < gv))
	<drawHist+?>: load.c32 7526516
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:181: (11 bytes): r: uint32 := colR * (uint32(y < rv))
	<drawHist+?>: load.c32 16540005
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:182: (11 bytes): l: uint32 := colL * (uint32(y < lv))
	<drawHist+?>: load.c32 14342874
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:183: (37 bytes): image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
	<drawHist+?>: load.sp(+1092)
	<drawHist+?>: load.i64
	<drawHist+?>: dup.x1 sp(11)
	<drawHist+?>: dup.x1 sp(13)
	<drawHist+?>: add.i32
	<drawHist+?>: dup.x1 sp(16)
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: sub.i32
	<drawHist+?>: dup.x1 sp(15)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(-1)
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: or.b32
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: or.b32
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: or.b32
	<drawHist+?>: nfc(90) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	<drawHist+?>: inc.sp(-16)
	cmplGfx/lib/color.ci:178: (4 bytes): y := y + 1
	<drawHist+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:178: (9 bytes): y < rect.h
	<drawHist+?>: dup.x1 sp(0)
	<drawHist+?>: dup.x1 sp(10)
	<drawHist+?>: clt.i32
	<drawHist+?>: jnz -94
	<drawHist+?>: inc.sp(-4)
	<drawHist+?>: inc.sp(-16)
	cmplGfx/lib/color.ci:172: (4 bytes): x := x + 1
	<drawHist+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:172: (9 bytes): x < rect.w
	<drawHist+?>: dup.x1 sp(0)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: clt.i32
	<drawHist+?>: jnz -214
	<drawHist+?>: inc.sp(-4)
	<drawHist+?>: inc.sp(-1040)
	<drawHist+?>: ret
.usages:
	cmplGfx/lib/color.ci:144: defined as `drawHist(image: gxSurf, roi: gxRect, hist: uint32): void`
}
gxSurf(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:5'
.param .result: gxSurf (size: 8, cast: val)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create a surface with the given with, height and depth'
.value: gxSurf.create(width, height, depth)
.usages:
	cmplGfx/gfxlib.ci:367: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:366: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:358: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:5: defined as `gxSurf(width: int32, height: int32, depth: int32): gxSurf`
}
gxSurf(fileName: char[*], depth: int32): gxSurf: function {
.kind: static const function
.base: `function`
.size: 189
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:8'
.param .result: gxSurf (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: 'Create a surface by opening an image file'
.value: {
	if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".jpg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".png", ignCaseCmp)) {
		return .result := gxSurf.openPng(fileName, depth);
	}
	if (endsWith(fileName, ".bmp", ignCaseCmp)) {
		return .result := gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}
.instructions: (189 bytes)
	cmplGfx/gfxlib.ci:9: (38 bytes): if (endsWith(fileName, ".jpeg", ignCaseCmp))
	<gxSurf>  : load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpeg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:10: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(83) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:12: (38 bytes): if (endsWith(fileName, ".jpg", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:13: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(83) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:15: (38 bytes): if (endsWith(fileName, ".png", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".png"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:16: (11 bytes): return .result := gxSurf.openPng(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(82) ;gxSurf.openPng(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:18: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".bmp"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:19: (11 bytes): return .result := gxSurf.openBmp(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(81) ;gxSurf.openBmp(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:21: (36 bytes): abort("unknown file extension", fileName);
	<gxSurf+?>: load.ref <?> ;"cmplGfx/gfxlib.ci"
	<gxSurf+?>: load.c32 21
	<gxSurf+?>: load.c32 -2
	<gxSurf+?>: load.c32 128
	<gxSurf+?>: load.ref <?> ;"unknown file extension"
	<gxSurf+?>: load.ref <?>
	<gxSurf+?>: dup.x1 sp(8)
	<gxSurf+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxSurf+?>: ret
.usages:
	cmplGfx/gfxlib.ci:25: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:8: defined as `gxSurf(fileName: char[*], depth: int32): gxSurf`
}
gxSurf(fileName: char[*]): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:25'
.param .result: gxSurf (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: ref)
.doc: 'Create a surface by opening an image file'
.value: gxSurf(fileName, 32)
.usages:
	cmplGfx/gfxlib.ci:25: defined as `gxSurf(fileName: char[*]): gxSurf`
}
gxMesh(fileName: char[*]): gxMesh: function {
.kind: static const function
.base: `function`
.size: 109
.name: 'gxMesh'
.file: 'cmplGfx/gfxlib.ci:28'
.param .result: gxMesh (size: 4, cast: variable(ref))
.param fileName: char[*] (size: 4, cast: variable(ref))
.doc: 'Create a mesh by opening a file'
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := gxMesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (109 bytes)
	cmplGfx/gfxlib.ci:29: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<gxMesh>  : load.z32
	<gxMesh+?>: dup.x1 sp(2)
	<gxMesh+?>: load.ref <?> ;".obj"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	cmplGfx/gfxlib.ci:30: (9 bytes): return .result := gxMesh.openObj(fileName);
	<gxMesh+?>: dup.x1 sp(1)
	<gxMesh+?>: nfc(62) ;gxMesh.openObj(path: char[*]): gxMesh
	<gxMesh+?>: set.x1 sp(3)
	<gxMesh+?>: ret
	cmplGfx/gfxlib.ci:32: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<gxMesh+?>: load.z32
	<gxMesh+?>: dup.x1 sp(2)
	<gxMesh+?>: load.ref <?> ;".3ds"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	cmplGfx/gfxlib.ci:33: (9 bytes): return .result := gxMesh.open3ds(fileName);
	<gxMesh+?>: dup.x1 sp(1)
	<gxMesh+?>: nfc(63) ;gxMesh.open3ds(path: char[*]): gxMesh
	<gxMesh+?>: set.x1 sp(3)
	<gxMesh+?>: ret
	cmplGfx/gfxlib.ci:35: (36 bytes): abort("unknown file extension", fileName);
	<gxMesh+?>: load.ref <?> ;"cmplGfx/gfxlib.ci"
	<gxMesh+?>: load.c32 35
	<gxMesh+?>: load.c32 -2
	<gxMesh+?>: load.c32 128
	<gxMesh+?>: load.ref <?> ;"unknown file extension"
	<gxMesh+?>: load.ref <?>
	<gxMesh+?>: dup.x1 sp(7)
	<gxMesh+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxMesh+?>: ret
.usages:
	cmplGfx/gfxlib.ci:28: defined as `gxMesh(fileName: char[*]): gxMesh`
}
gxSurf(copy: gxSurf): gxSurf: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:39'
.param .result: gxSurf (size: 8, cast: variable(val))
.param copy: gxSurf (size: 8, cast: variable(val))
.doc: 'Create a surface by cloning another one'
.value: {
	result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
	result.copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (40 bytes)
	cmplGfx/gfxlib.ci:40: (22 bytes): result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy))
	<gxSurf>  : dup.x2 sp(1)
	<gxSurf+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: dup.x2 sp(2)
	<gxSurf+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: dup.x2 sp(3)
	<gxSurf+?>: nfc(88) ;gxSurf.depth(surf: gxSurf): int32
	<gxSurf+?>: nfc(77) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	cmplGfx/gfxlib.ci:41: (15 bytes): result.copy(result, 0, 0, copy, null);
	<gxSurf+?>: dup.x2 sp(0)
	<gxSurf+?>: load.z32
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x2 sp(7)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: nfc(101) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	cmplGfx/gfxlib.ci:42: (3 bytes): return .result := result;
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
.usages:
	cmplGfx/gfxlib.ci:313: referenced as `gxSurf`
	cmplGfx/gfxlib.ci:39: defined as `gxSurf(copy: gxSurf): gxSurf`
}
set(dst: gxSurf, x: int32, y: int32, color: argb): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'set'
.file: 'cmplGfx/gfxlib.ci:46'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param x: int32 (size: 4, cast: i32)
.param y: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'Set the the color of a pixel at the given position'
.value: gxSurf.set(dst, x, y, uint32(color))
.usages:
	cmplGfx/gfxlib.ci:112: referenced as `set`
	cmplGfx/gfxlib.ci:46: defined as `set(dst: gxSurf, x: int32, y: int32, color: argb): void`
}
clip(src: gxSurf, roi: gxRect): bool: function {
.kind: static const function
.base: `function`
.size: 235
.name: 'clip'
.file: 'cmplGfx/gfxlib.ci:49'
.param .result: bool (size: 4, cast: variable(bool))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	roi.w := roi.w + roi.x;
	roi.h := roi.h + roi.y;
	if (roi.x < 0) {
		roi.x := 0;
	}
	if (roi.y < 0) {
		roi.y := 0;
	}
	width: int32 := src.width(src);
	if (roi.w > width) {
		roi.w := width;
	}
	height: int32 := src.height(src);
	if (roi.h > height) {
		roi.h := height;
	}
	roi.w := roi.w - roi.x;
	roi.h := roi.h - roi.y;
	if (roi.w <= 0) {
		return .result := false;
	}
	if (roi.h <= 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (235 bytes)
	cmplGfx/gfxlib.ci:51: (18 bytes): roi.w := roi.w + roi.x;
	<clip>  : dup.x1 sp(1)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:52: (22 bytes): roi.h := roi.h + roi.y;
	<clip+?>: dup.x1 sp(1)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:54: (13 bytes): if (roi.x < 0)
	<clip+?>: dup.x1 sp(1)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +8
	cmplGfx/gfxlib.ci:55: (4 bytes): roi.x := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:58: (21 bytes): if (roi.y < 0)
	<clip+?>: dup.x1 sp(1)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +12
	cmplGfx/gfxlib.ci:59: (8 bytes): roi.y := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:62: (6 bytes): width: int32 := src.width(src)
	<clip+?>: dup.x2 sp(2)
	<clip+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:63: (23 bytes): if (roi.w > width)
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/gfxlib.ci:64: (9 bytes): roi.w := width;
	<clip+?>: dup.x1 sp(0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:67: (6 bytes): height: int32 := src.height(src)
	<clip+?>: dup.x2 sp(3)
	<clip+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:68: (23 bytes): if (roi.h > height)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/gfxlib.ci:69: (9 bytes): roi.h := height;
	<clip+?>: dup.x1 sp(0)
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:72: (18 bytes): roi.w := roi.w - roi.x;
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:73: (22 bytes): roi.h := roi.h - roi.y;
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:75: (24 bytes): if (roi.w <= 0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/gfxlib.ci:76: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/gfxlib.ci:78: (24 bytes): if (roi.h <= 0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/gfxlib.ci:79: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/gfxlib.ci:81: (15 bytes): return .result := true;
	<clip+?>: load.c32 1
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
.usages:
	cmplGfx/gfxlib.ci:126: referenced as `clip`
	cmplGfx/gfxlib.ci:96: referenced as `clip`
	cmplGfx/gfxlib.ci:49: defined as `clip(src: gxSurf, roi: gxRect): bool`
}
fill(dst: gxSurf, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'cmplGfx/gfxlib.ci:85'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: val)
.param col: uint32 (size: 4, cast: u32)
.doc: 'Fill the entire surface with the given color'
.value: dst.fillRect(dst, 0, 0, 65536, 65536, col)
.usages:
	cmplGfx/gfxlib.ci:85: defined as `fill(dst: gxSurf, col: uint32): void`
}
eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 353
.name: 'eval'
.file: 'cmplGfx/gfxlib.ci:88'
.param .result: void (size: 0, cast: variable(void))
.param dst: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param aspect: float32 (size: 4, cast: variable(f32))
.param time: float32 (size: 4, cast: variable(f32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Fill the surface by evaluating the given function for each pixel'
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : dst.width(dst);
		rect.h := (roi) != null ? roi.h : dst.height(dst);
	};
	if (!clip(dst, rect)) {
		return;
	}
	in: vec4f := {
		in.x := (0);
		in.y := (0);
		in.z := aspect;
		in.w := time;
	};
	w: float32 := dst.width(dst);
	h: float32 := dst.height(dst);
	for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
			in.x := (x) / w;
			set(dst, x, y, argb(eval(in)));
		}
	}
}
.instructions: (353 bytes)
	cmplGfx/gfxlib.ci:89: (114 bytes): rect: gxRect := {...}
	<eval>  : inc.sp(+16)
	cmplGfx/gfxlib.ci:90: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +11
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:91: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:92: (31 bytes): rect.w := (roi) != null ? roi.w : dst.width(dst);
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x2 sp(9)
	<eval+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: set.x1 sp(3)
	cmplGfx/gfxlib.ci:93: (31 bytes): rect.h := (roi) != null ? roi.h : dst.height(dst);
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x2 sp(9)
	<eval+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: set.x1 sp(4)
	cmplGfx/gfxlib.ci:96: (26 bytes): if (!clip(dst, rect))
	<eval+?>: load.z32
	<eval+?>: dup.x2 sp(10)
	<eval+?>: load.sp(+12)
	<eval+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<eval+?>: call
	<eval+?>: inc.sp(-12)
	<eval+?>: jnz +9
	cmplGfx/gfxlib.ci:97: (5 bytes): return;
	<eval+?>: inc.sp(-16)
	<eval+?>: ret
	cmplGfx/gfxlib.ci:100: (16 bytes): in: vec4f := {...}
	<eval+?>: inc.sp(+16)
	cmplGfx/gfxlib.ci:101: (3 bytes): in.x := (0);
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:102: (3 bytes): in.y := (0);
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:103: (3 bytes): in.z := aspect;
	<eval+?>: mov.x1 sp(2, 11)
	cmplGfx/gfxlib.ci:104: (3 bytes): in.w := time;
	<eval+?>: mov.x1 sp(3, 10)
	cmplGfx/gfxlib.ci:106: (7 bytes): w: float32 := dst.width(dst)
	<eval+?>: dup.x2 sp(13)
	<eval+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: i32.2f32
	cmplGfx/gfxlib.ci:107: (7 bytes): h: float32 := dst.height(dst)
	<eval+?>: dup.x2 sp(14)
	<eval+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: i32.2f32
	cmplGfx/gfxlib.ci:108: (178 bytes): for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1)
	<eval+?>: dup.x1 sp(7)
	<eval+?>: jmp +160
	cmplGfx/gfxlib.ci:109: (8 bytes): in.y := (y) / h;
	<eval+?>: dup.x1 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: div.f32
	<eval+?>: set.x1 sp(5)
	cmplGfx/gfxlib.ci:110: (144 bytes): for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1)
	<eval+?>: dup.x1 sp(7)
	<eval+?>: jmp +126
	cmplGfx/gfxlib.ci:111: (8 bytes): in.x := (x) / w;
	<eval+?>: dup.x1 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x1 sp(4)
	<eval+?>: div.f32
	<eval+?>: set.x1 sp(5)
	cmplGfx/gfxlib.ci:112: (110 bytes): set(dst, x, y, argb(eval(in)));
	<eval+?>: dup.x2 sp(17)
	<eval+?>: dup.x1 sp(2)
	<eval+?>: dup.x1 sp(4)
	<eval+?>: inc.sp(+16)
	<eval+?>: dup.x4 sp(12)
	<eval+?>: dup.x1 sp(25)
	<eval+?>: call
	<eval+?>: inc.sp(-16)
	<eval+?>: load.sp(+0)
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(1)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: set.x1 sp(5)
	<eval+?>: inc.sp(-16)
	<eval+?>: nfc(90) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	cmplGfx/gfxlib.ci:110: (4 bytes): x := x + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/gfxlib.ci:110: (12 bytes): x < rect.x + rect.w
	<eval+?>: dup.x1 sp(0)
	<eval+?>: dup.x1 sp(9)
	<eval+?>: dup.x1 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -130
	<eval+?>: inc.sp(-4)
	cmplGfx/gfxlib.ci:108: (4 bytes): y := y + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/gfxlib.ci:108: (12 bytes): y < rect.y + rect.h
	<eval+?>: dup.x1 sp(0)
	<eval+?>: dup.x1 sp(9)
	<eval+?>: dup.x1 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -164
	<eval+?>: inc.sp(-4)
	<eval+?>: inc.sp(-40)
	<eval+?>: ret
.usages:
	cmplGfx/gfxlib.ci:359: referenced as `eval`
	cmplGfx/gfxlib.ci:349: referenced as `eval`
	cmplGfx/gfxlib.ci:343: referenced as `eval`
	cmplGfx/gfxlib.ci:88: defined as `eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void`
}
tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const function
.base: `function`
.size: 251
.name: 'tile'
.file: 'cmplGfx/gfxlib.ci:118'
.param .result: void (size: 0, cast: variable(void))
.param dst: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : src.width(src);
		rect.h := (roi) != null ? roi.h : src.height(src);
	};
	if (!clip(src, rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % rect.w);
	}
	if (y < 0) {
		y := -(-y % rect.h);
	}
	width: int32 := dst.width(dst);
	height: int32 := dst.height(dst);
	for (j: int32 := y; j < height; j := j + rect.h) {
		for (i: int32 := x; i < width; i := i + rect.w) {
			dst.copy(dst, i, j, src, rect);
		}
	}
}
.instructions: (251 bytes)
	cmplGfx/gfxlib.ci:119: (114 bytes): rect: gxRect := {...}
	<tile>  : inc.sp(+16)
	cmplGfx/gfxlib.ci:120: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +11
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:121: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:122: (31 bytes): rect.w := (roi) != null ? roi.w : src.width(src);
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x2 sp(6)
	<tile+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	<tile+?>: set.x1 sp(3)
	cmplGfx/gfxlib.ci:123: (31 bytes): rect.h := (roi) != null ? roi.h : src.height(src);
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x2 sp(6)
	<tile+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	<tile+?>: set.x1 sp(4)
	cmplGfx/gfxlib.ci:126: (26 bytes): if (!clip(src, rect))
	<tile+?>: load.z32
	<tile+?>: dup.x2 sp(7)
	<tile+?>: load.sp(+12)
	<tile+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<tile+?>: call
	<tile+?>: inc.sp(-12)
	<tile+?>: jnz +9
	cmplGfx/gfxlib.ci:127: (5 bytes): return;
	<tile+?>: inc.sp(-16)
	<tile+?>: ret
	cmplGfx/gfxlib.ci:130: (17 bytes): if (x < 0)
	<tile+?>: dup.x1 sp(9)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/gfxlib.ci:131: (9 bytes): x := -(-x % rect.w);
	<tile+?>: dup.x1 sp(9)
	<tile+?>: neg.i32
	<tile+?>: dup.x1 sp(3)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x1 sp(10)
	cmplGfx/gfxlib.ci:133: (17 bytes): if (y < 0)
	<tile+?>: dup.x1 sp(8)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/gfxlib.ci:134: (9 bytes): y := -(-y % rect.h);
	<tile+?>: dup.x1 sp(8)
	<tile+?>: neg.i32
	<tile+?>: dup.x1 sp(4)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x1 sp(9)
	cmplGfx/gfxlib.ci:136: (6 bytes): width: int32 := dst.width(dst)
	<tile+?>: dup.x2 sp(10)
	<tile+?>: nfc(86) ;gxSurf.width(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:137: (6 bytes): height: int32 := dst.height(dst)
	<tile+?>: dup.x2 sp(11)
	<tile+?>: nfc(87) ;gxSurf.height(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:138: (60 bytes): for (j: int32 := y; j < height; j := j + rect.h)
	<tile+?>: dup.x1 sp(10)
	<tile+?>: jmp +45
	cmplGfx/gfxlib.ci:139: (38 bytes): for (i: int32 := x; i < width; i := i + rect.w)
	<tile+?>: dup.x1 sp(12)
	<tile+?>: jmp +23
	cmplGfx/gfxlib.ci:140: (16 bytes): dst.copy(dst, i, j, src, rect);
	<tile+?>: dup.x2 sp(14)
	<tile+?>: dup.x1 sp(2)
	<tile+?>: dup.x1 sp(4)
	<tile+?>: dup.x2 sp(14)
	<tile+?>: load.sp(+40)
	<tile+?>: nfc(101) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	cmplGfx/gfxlib.ci:139: (3 bytes): i := i + rect.w
	<tile+?>: dup.x1 sp(6)
	<tile+?>: add.i32
	cmplGfx/gfxlib.ci:139: (9 bytes): i < width
	<tile+?>: dup.x1 sp(0)
	<tile+?>: dup.x1 sp(4)
	<tile+?>: clt.i32
	<tile+?>: jnz -24
	<tile+?>: inc.sp(-4)
	cmplGfx/gfxlib.ci:138: (3 bytes): j := j + rect.h
	<tile+?>: dup.x1 sp(6)
	<tile+?>: add.i32
	cmplGfx/gfxlib.ci:138: (9 bytes): j < height
	<tile+?>: dup.x1 sp(0)
	<tile+?>: dup.x1 sp(2)
	<tile+?>: clt.i32
	<tile+?>: jnz -46
	<tile+?>: inc.sp(-4)
	<tile+?>: inc.sp(-24)
	<tile+?>: ret
.usages:
	cmplGfx/gfxlib.ci:118: defined as `tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void`
}
show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void: function {
.kind: static const function
.base: `function`
.size: 118
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:146'
.param .result: void (size: 0, cast: variable(void))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param fovy: float32 (size: 4, cast: variable(f32))
.doc: 'Show the mesh in a window'
.value: {
	static const Closure: struct {
		mode: int32;
		offs: gxSurf;
		mesh: gxMesh;
	};
	static const next(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const speed: float32 := 1.000000 / (100);
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
			else {
				if (button == ('l')) {
					closure.mode := ((closure.mode) ^ gxMesh.useLights);
				}
				else {
					if (button == ('0')) {
						lights.enable(0, !lights.enabled(0));
					}
					else {
						if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else {
							if (button == ('2')) {
								lights.enable(2, !lights.enabled(2));
							}
							else {
								if (button == ('3')) {
									lights.enable(3, !lights.enabled(3));
								}
								else {
									if (button == ('t')) {
										closure.mode := ((closure.mode) ^ gxMesh.useTexture);
									}
									else {
										if (button == ('/')) {
											closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
										}
										else {
											if (button == ('\t')) {
												closure.mode := next(closure.mode, gxMesh.drawMode);
											}
											else {
												if (button == ('\r')) {
													eye: vec4f := {
														eye.x := (0);
														eye.y := (0);
														eye.z := (2);
														eye.w := (1);
													};
													at: vec4f := {
														at.x := (0);
														at.y := (0);
														at.z := (0);
														at.w := (1);
													};
													up: vec4f := {
														up.x := (0);
														up.y := (1);
														up.z := (0);
														up.w := (1);
													};
													camera.lookAt(eye.data, at.data, up.data);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else {
			if ((action) == Gui.MOUSE_PRESS) {
				ox := ex;
				oy := ey;
				return .result := 0;
			}
			else {
				if ((action) == Gui.MOUSE_MOTION) {
					dir: float32[3];
					dx: int32 := ex - ox;
					dy: int32 := ey - oy;
					if (button == 1) {
						orig: float32[3];
						orig[0] := (0);
						orig[1] := (0);
						orig[2] := (0);
						camera.readUp(dir);
						camera.rotate(dir, orig, (dx) * speed);
						camera.readRight(dir);
						camera.rotate(dir, orig, (dy) * speed);
					}
					else {
						if (button == 2) {
							camera.readUp(dir);
							camera.rotate(dir, null, (-dx) * speed);
							camera.readRight(dir);
							camera.rotate(dir, null, (-dy) * speed);
						}
						else {
							if (button == 3) {
								camera.readForward(dir);
								camera.move(dir, (dy) * speed);
							}
							else {
								if (button == 4) {
									camera.readRight(dir);
									camera.move(dir, (-dx) * speed);
									camera.readUp(dir);
									camera.move(dir, (dy) * speed);
								}
							}
						}
					}
					ox := ex;
					oy := ey;
				}
			}
		}
		rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
		text: char[256];
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, closure.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, closure.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		Gui.setTitle(text);
		return .result := 0;
	};
	closure: Closure := {
		closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
		closure.offs := gxSurf.create3d(w, h);
		closure.mesh := mesh;
	};
	camera.projection(fovy, (w) / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy(closure.offs);
}
.instructions: (118 bytes)
	cmplGfx/gfxlib.ci:263: (69 bytes): closure: Closure := {...}
	<show>  : inc.sp(+24)
	cmplGfx/gfxlib.ci:264: (52 bytes): closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
	<show+?>: load.c64 8
	<show+?>: load.c64 4
	<show+?>: or.b64
	<show+?>: load.c64 128
	<show+?>: or.b64
	<show+?>: load.c64 16
	<show+?>: or.b64
	<show+?>: load.c64 3
	<show+?>: or.b64
	<show+?>: i64.2i32
	<show+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:265: (10 bytes): closure.offs := gxSurf.create3d(w, h);
	<show+?>: dup.x1 sp(9)
	<show+?>: dup.x1 sp(9)
	<show+?>: nfc(78) ;gxSurf.create3d(width: int32, height: int32): gxSurf
	<show+?>: set.x2 sp(4)
	cmplGfx/gfxlib.ci:266: (3 bytes): closure.mesh := mesh;
	<show+?>: mov.x1 sp(4, 10)
	cmplGfx/gfxlib.ci:268: (23 bytes): camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>: dup.x1 sp(7)
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 100.000000
	<show+?>: nfc(108) ;camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
	cmplGfx/gfxlib.ci:269: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x2 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(122) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:270: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x2 sp(2)
	<show+?>: nfc(80) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
	cmplGfx/gfxlib.ci:146: defined as `show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void`
}
show(surf: gxSurf): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:274'
.param .result: void (size: 0, cast: void)
.param surf: gxSurf (size: 8, cast: val)
.doc: 'Show the surface in a window'
.value: Gui.showWindow(surf, null, null)
.usages:
	cmplGfx/gfxlib.ci:274: defined as `show(surf: gxSurf): void`
}
show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static const function
.base: `function`
.size: 43
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:277'
.param .result: void (size: 0, cast: variable(void))
.param surf: gxSurf (size: 8, cast: variable(val))
.param onEvent: function (size: 4, cast: variable(ref))
.doc: 'Show the surface in a window'
.value: {
	if ((onEvent) == null) {
		return .result := Gui.showWindow(surf, null, null);
	}
	static const delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Gui.showWindow(surf, onEvent, delegate);
}
.instructions: (43 bytes)
	cmplGfx/gfxlib.ci:278: (29 bytes): if ((onEvent) == null)
	<show>  : dup.x1 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: ceq.i32
	<show+?>: jz +21
	cmplGfx/gfxlib.ci:279: (17 bytes): return .result := Gui.showWindow(surf, null, null);
	<show+?>: dup.x2 sp(2)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(122) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
	cmplGfx/gfxlib.ci:284: (13 bytes): Gui.showWindow(surf, onEvent, delegate);
	<show+?>: dup.x2 sp(2)
	<show+?>: dup.x1 sp(3)
	<show+?>: load.ref <?> ;show.delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(122) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
.usages:
	cmplGfx/gfxlib.ci:360: referenced as `show`
	cmplGfx/gfxlib.ci:277: defined as `show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void`
}
showDiff(image1: gxSurf, image2: gxSurf): void: function {
.kind: static const function
.base: `function`
.size: 48
.name: 'showDiff'
.file: 'cmplGfx/gfxlib.ci:288'
.param .result: void (size: 0, cast: variable(void))
.param image1: gxSurf (size: 8, cast: variable(val))
.param image2: gxSurf (size: 8, cast: variable(val))
.doc: 'Show the surfaces in a window clicking on the window toggles the shown surface'
.value: {
	static const Closure: struct {
		offs: gxSurf;
		image1: gxSurf;
		image2: gxSurf;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.MOUSE_PRESS) {
			closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
			return .result := 0;
		}
		if ((action) == Gui.MOUSE_RELEASE) {
			closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
			return .result := 0;
		}
		return .result := 0;
	};
	closure: Closure := {
		closure.offs := gxSurf(image1);
		closure.image1 := image1;
		closure.image2 := image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}
.instructions: (48 bytes)
	cmplGfx/gfxlib.ci:312: (28 bytes): closure: Closure := {...}
	<showDiff>  : inc.sp(+24)
	cmplGfx/gfxlib.ci:313: (18 bytes): closure.offs := gxSurf(image1);
	<showDiff+?>: inc.sp(+8)
	<showDiff+?>: dup.x2 sp(11)
	<showDiff+?>: load.ref <?> ;gxSurf(copy: gxSurf): gxSurf
	<showDiff+?>: call
	<showDiff+?>: inc.sp(-8)
	<showDiff+?>: set.x2 sp(2)
	cmplGfx/gfxlib.ci:314: (3 bytes): closure.image1 := image1;
	<showDiff+?>: mov.x2 sp(2, 9)
	cmplGfx/gfxlib.ci:315: (3 bytes): closure.image2 := image2;
	<showDiff+?>: mov.x2 sp(4, 7)
	cmplGfx/gfxlib.ci:317: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showDiff+?>: dup.x2 sp(0)
	<showDiff+?>: load.sp(+8)
	<showDiff+?>: load.ref <?> ;showDiff.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showDiff+?>: nfc(122) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<showDiff+?>: inc.sp(-24)
	<showDiff+?>: ret
.usages:
	cmplGfx/gfxlib.ci:288: defined as `showDiff(image1: gxSurf, image2: gxSurf): void`
}
show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 160
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:321'
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param animationResolution: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Show or animate the the procedural image generated by the `eval` function'
.value: {
	static const start: int64 := System.millis();
	static const Closure: struct {
		const offs: gxSurf;
		const thumb: gxSurf;
		const aspect: float32;
		const eval(in: vec4f): vec4f;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return .result := 0;
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.KEY_RELEASE) {
			if (button == (' ')) {
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.offs, null, closure.aspect, time, closure.eval);
				return .result := 0;
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(closure.thumb, null, closure.aspect, time, closure.eval);
		closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
		return .result := 1;
	};
	if (animationResolution == 0) {
		aspect: float32 := (width) / float32(height);
		surf: gxSurf := gxSurf(width, height, 32);
		eval(surf, null, aspect, 0.000000, eval);
		show(surf, null);
		surf.destroy(surf);
		return;
	}
	closure: Closure := {
		closure.offs := gxSurf(width, height, 32);
		closure.thumb := gxSurf(animationResolution, animationResolution, 32);
		closure.aspect := (width) / float32(height);
		closure.eval := eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy(closure.thumb);
	closure.offs.destroy(closure.offs);
}
.instructions: (160 bytes)
	cmplGfx/gfxlib.ci:356: (82 bytes): if (animationResolution == 0)
	<show>  : dup.x1 sp(2)
	<show+?>: load.z32
	<show+?>: ceq.i32
	<show+?>: jz +78
	cmplGfx/gfxlib.ci:357: (7 bytes): aspect: float32 := (width) / float32(height)
	<show+?>: dup.x1 sp(4)
	<show+?>: i32.2f32
	<show+?>: dup.x1 sp(4)
	<show+?>: i32.2f32
	<show+?>: div.f32
	cmplGfx/gfxlib.ci:358: (13 bytes): surf: gxSurf := gxSurf(width, height, 32)
	<show+?>: dup.x1 sp(5)
	<show+?>: dup.x1 sp(5)
	<show+?>: load.c32 32
	<show+?>: nfc(77) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	cmplGfx/gfxlib.ci:359: (22 bytes): eval(surf, null, aspect, 0.000000, eval);
	<show+?>: dup.x2 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: dup.x1 sp(5)
	<show+?>: load.z32
	<show+?>: dup.x1 sp(9)
	<show+?>: load.ref <?> ;eval(dst: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	cmplGfx/gfxlib.ci:360: (17 bytes): show(surf, null);
	<show+?>: dup.x2 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void
	<show+?>: call
	<show+?>: inc.sp(-12)
	cmplGfx/gfxlib.ci:361: (6 bytes): surf.destroy(surf);
	<show+?>: dup.x2 sp(0)
	<show+?>: nfc(80) ;gxSurf.destroy(surf: gxSurf): void
	cmplGfx/gfxlib.ci:362: (5 bytes): return;
	<show+?>: inc.sp(-12)
	<show+?>: ret
	<show+?>: inc.sp(-12)
	cmplGfx/gfxlib.ci:365: (46 bytes): closure: Closure := {...}
	<show+?>: inc.sp(+24)
	cmplGfx/gfxlib.ci:366: (15 bytes): closure.offs := gxSurf(width, height, 32);
	<show+?>: dup.x1 sp(10)
	<show+?>: dup.x1 sp(10)
	<show+?>: load.c32 32
	<show+?>: nfc(77) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<show+?>: set.x2 sp(2)
	cmplGfx/gfxlib.ci:367: (15 bytes): closure.thumb := gxSurf(animationResolution, animationResolution, 32);
	<show+?>: dup.x1 sp(8)
	<show+?>: dup.x1 sp(9)
	<show+?>: load.c32 32
	<show+?>: nfc(77) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<show+?>: set.x2 sp(4)
	cmplGfx/gfxlib.ci:368: (9 bytes): closure.aspect := (width) / float32(height);
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: set.x1 sp(5)
	cmplGfx/gfxlib.ci:369: (3 bytes): closure.eval := eval;
	<show+?>: mov.x1 sp(5, 7)
	cmplGfx/gfxlib.ci:371: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x2 sp(0)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(122) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:372: (6 bytes): closure.thumb.destroy(closure.thumb);
	<show+?>: dup.x2 sp(2)
	<show+?>: nfc(80) ;gxSurf.destroy(surf: gxSurf): void
	cmplGfx/gfxlib.ci:373: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x2 sp(0)
	<show+?>: nfc(80) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
	cmplGfx/gfxlib.ci:321: defined as `show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void`
}
.main: function {
.kind: static function
.base: `function`
.size: 100
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field true: bool (size: 0, cast: static const inline)
.field false: bool (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field byte: typename (size: 0, cast: static const inline)
.field float: typename (size: 0, cast: static const inline)
.field double: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, cast: static const i64)
.field RAND_MAX: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field verbose: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 32, cast: static const typename(val))
.field assertEq: function (size: 94, cast: static const function)
.field assertEq: function (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field Math: typename (size: 0, cast: static const typename(void))
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static const function)
.field Complex: function (size: 7, cast: static const function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 123, cast: static const function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static const function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 100, cast: static const function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field length: function (size: 38, cast: static const function)
.field indexOf: function (size: 50, cast: static const function)
.field lastIndexOf: function (size: 50, cast: static const function)
.field startsWith: function (size: 73, cast: static const function)
.field endsWith: function (size: 126, cast: static const function)
.field compare: function (size: 63, cast: static const function)
.field ignCaseCmp: function (size: 36, cast: static const function)
.field caseCmp: function (size: 14, cast: static const function)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 84, cast: static const function)
.field append: function (size: 657, cast: static const function)
.field append: function (size: 23, cast: static const function)
.field append: function (size: 49, cast: static const function)
.field append: function (size: 25, cast: static const function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static const function)
.field sub: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 13, cast: static const function)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field len: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static const function)
.field mat4f: function (size: 21, cast: static const function)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field mul: function (size: 417, cast: static const function)
.field File: typename (size: 8, cast: static const typename(val))
.field gxRect: typename (size: 16, cast: static const typename(val))
.field gxSurf: typename (size: 8, cast: static const typename(val))
.field gxMesh: typename (size: 176, cast: static const typename(ref))
.field camera: typename (size: 0, cast: static const typename(void))
.field lights: typename (size: 0, cast: static const typename(void))
.field Gui: typename (size: 0, cast: static const typename(void))
.field argb: typename (size: 4, cast: static const typename(val))
.field argb: function (size: 0, cast: inline)
.field uint32: function (size: 0, cast: inline)
.field grayClamp: function (size: 36, cast: static const function)
.field grayClamp: function (size: 24, cast: static const function)
.field _gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field ach: function (size: 0, cast: inline)
.field rch: function (size: 0, cast: inline)
.field gch: function (size: 0, cast: inline)
.field bch: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field rgbLerp16: function (size: 123, cast: static const function)
.field rgbLerp: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field hsv2rgb: function (size: 344, cast: static const function)
.field drawHist: function (size: 342, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxSurf: function (size: 189, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxMesh: function (size: 109, cast: static const function)
.field gxSurf: function (size: 40, cast: static const function)
.field set: function (size: 0, cast: inline)
.field clip: function (size: 235, cast: static const function)
.field fill: function (size: 0, cast: inline)
.field eval: function (size: 353, cast: static const function)
.field tile: function (size: 251, cast: static const function)
.field show: function (size: 118, cast: static const function)
.field show: function (size: 0, cast: inline)
.field show: function (size: 43, cast: static const function)
.field showDiff: function (size: 48, cast: static const function)
.field show: function (size: 160, cast: static const function)
.field .main: function (size: 100, cast: static function)
.value: {
	{
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.message := (message);
					details.argument := (null);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.000000 / ln2;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 1.000000 / ln10;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := (0) / 0.000000;
			static const inf: float64 := (1) / 0.000000;
			static const modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(x, result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static sign(x: float32): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: float64): int32 := int32(x > (0)) - int32(x < (0));
			static const abs(x: float32): float32 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const abs(x: float64): float64 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static const min(a: float32, b: float32): float32 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const min(a: float64, b: float64): float64 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float32, b: float32): float32 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float64, b: float64): float64 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static lerp(t: float32, a: float32, b: float32): float32 := a + t * (b - a);
			static lerp(t: float64, a: float64, b: float64): float64 := a + t * (b - a);
			static smooth(t: float32): float32 := t * t * ((3) - (2) * t);
			static smooth(t: float64): float64 := t * t * ((3) - (2) * t);
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp((t - a) / (b - a), float32(0), float32(1)));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp((t - a) / (b - a), float64(0), float64(1)));
			static const min(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result > data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const max(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result < data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (data.length); i := i + 1) {
					result := result + data[i];
				}
				return .result := result;
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (a0 + x * a1);
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (a0 + x * eval(x, a1, a2));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (a0 + x * eval(x, a1, a2, a3));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else {
					if (i == 1) {
						x := (1) - x;
						complement := true;
					}
					else {
						if (i == 2) {
							negate := !negate;
							complement := true;
						}
						else {
							if (i == 3) {
								x := (1) - x;
								negate := !negate;
							}
						}
					}
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static const asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static radians(degrees: float64): float64 := float64(degrees * pi / (180));
			static degrees(radians: float64): float64 := float64(radians * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static const Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(-a.re, -a.im);
		add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static const div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static const inv(a: Complex): Complex := {
			d: float64 := (a.re * a.re + a.im * a.im);
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const length(str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(str: char[*], with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(str: char[*], with: char[*]): int32 := compare(str, with, caseCmp);
		contains(str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return .result := append(output, pos, 0, value, format);
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (value < 0) {
				sign := ('-');
				value := -value;
			}
			return .result := append(output, pos, sign, value, format);
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				format.radix := 10;
				format.padChr := (0);
				format.padLen := 0;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
		static if ((null) == null) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return .result := {
			.result.x := x;
			.result.y := y;
		};
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
			dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		}
		static if ((null) == null) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 0.000000);
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
			vec4f(val: float32): vec4f := vec4f(val, val, val, val);
			neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), min.p4f));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), max.p4f));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dp3));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dph));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dp4));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
			len(v: vec4f): float32 := float32.sqrt(dp3(v, v));
			normalize(const v: vec4f): vec4f := div(v, vec4f(len(v)));
			eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		}
		static if ((null) == null) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					transposed.x.x := rhs.x.x;
					transposed.x.y := rhs.y.x;
					transposed.x.z := rhs.z.x;
					transposed.x.w := rhs.w.x;
					transposed.y.x := rhs.x.y;
					transposed.y.y := rhs.y.y;
					transposed.y.z := rhs.z.y;
					transposed.y.w := rhs.w.y;
					transposed.z.x := rhs.x.z;
					transposed.z.y := rhs.y.z;
					transposed.z.z := rhs.z.z;
					transposed.z.w := rhs.w.z;
					transposed.w.x := rhs.x.w;
					transposed.w.y := rhs.y.w;
					transposed.w.z := rhs.z.w;
					transposed.w.w := rhs.w.w;
				};
				return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
			};
		}
	}
	{
		static const gxRect: struct {
			x: int32;
			y: int32;
			w: int32;
			h: int32;
		};
	}
	{
		static const argb: struct {
			v: uint32;
			<?>: <?>;
			b: uint8 := b: uint8;
			g: uint8 := g: uint8;
			r: uint8 := r: uint8;
			a: uint8 := a: uint8;
		};
		argb(argb: uint32): argb := argb(emit(uint32(argb)));
		uint32(value: argb): uint32 := uint32(emit(struct(value)));
		static const grayClamp(c: int32): uint32 := {
			if (c < 0) {
				return .result := 0;
			}
			if (c > 255) {
				return .result := 255;
			}
			return .result := c;
		};
		static const grayClamp(c: uint32): uint32 := {
			if (c > (255)) {
				return .result := 255;
			}
			return .result := c;
		};
		_gray(c: uint32): argb := argb((((c << 8) | c) << 8) | c);
		gray(c: int32): argb := _gray(grayClamp(c));
		gray(c: uint32): argb := _gray(grayClamp(c));
		gray(c: float32): argb := gray(int32(c * (255)));
		gray(c: float64): argb := gray(int32(c * (255)));
		_argb(r: uint32, g: uint32, b: uint32): argb := argb(uint32((((r << 8) | g) << 8) | b));
		_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));
		argb(r: int32, g: int32, b: int32): argb := _argb(grayClamp(r), grayClamp(g), grayClamp(b));
		argb(r: uint32, g: uint32, b: uint32): argb := _argb(grayClamp(r), grayClamp(g), grayClamp(b));
		argb(r: float32, g: float32, b: float32): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(r: float64, g: float64, b: float64): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		ach(col: argb): uint32 := uint32((uint32(col) >> 24) & (255));
		rch(col: argb): uint32 := uint32((uint32(col) >> 16) & (255));
		gch(col: argb): uint32 := uint32((uint32(col) >> 8) & (255));
		bch(col: argb): uint32 := uint32(uint32(col) & (255));
		lum(c: argb): uint32 := uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8);
		static const rgbLerp16(c1: argb, c2: argb, t: uint32): argb := {
			lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
			r: uint32 := lrpfix16(rch(c1), rch(c2));
			g: uint32 := lrpfix16(gch(c1), gch(c2));
			b: uint32 := lrpfix16(bch(c1), bch(c2));
			return .result := argb(r, g, b);
		};
		rgbLerp(c1: argb, c2: argb, t: float64): argb := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
		static if ((typename(vec4f)) != null) {
			argb(const vec: vec4f): argb := argb(vec.x, vec.y, vec.z);
			lum(const vec: vec4f): float32 := 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z;
			static const hsv2rgb(hsv: vec4f): vec4f := {
				h: float32 := hsv.x;
				s: float32 := hsv.y;
				v: float32 := hsv.z;
				if (s == (0)) {
					return .result := vec4f(v);
				}
				h := h * (360 / 60);
				i: int32 := int32(h);
				f: float32 := h - (i);
				u: float32 := v;
				p: float32 := v * ((1) - s);
				q: float32 := v * ((1) - s * f);
				t: float32 := v * ((1) - s * ((1) - f));
				if (i == 0) {
					return .result := vec4f(u, t, p);
				}
				if (i == 1) {
					return .result := vec4f(q, u, p);
				}
				if (i == 2) {
					return .result := vec4f(p, u, t);
				}
				if (i == 3) {
					return .result := vec4f(p, q, u);
				}
				if (i == 4) {
					return .result := vec4f(t, p, u);
				}
				return .result := vec4f(u, p, q);
			};
		}
		static const drawHist(image: gxSurf, roi: gxRect, hist: uint32): void := {
			lut: uint32[256];
			image.calcHist(image, roi, hist, lut);
			rect: gxRect := {
				rect.w := 256;
				rect.h := 128;
				rect.y := margin;
				rect.x := image.width(image) - rect.w - margin;
			};
			image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
			for (x: int32 := 0; x < rect.w; x := x + 1) {
				bv: int32 := bch(argb(lut[x])) * (rect.h) / (256);
				gv: int32 := gch(argb(lut[x])) * (rect.h) / (256);
				rv: int32 := rch(argb(lut[x])) * (rect.h) / (256);
				lv: int32 := ach(argb(lut[x])) * (rect.h) / (256);
				for (y: int32 := 0; y < rect.h; y := y + 1) {
					b: uint32 := colB * (uint32(y < bv));
					g: uint32 := colG * (uint32(y < gv));
					r: uint32 := colR * (uint32(y < rv));
					l: uint32 := colL * (uint32(y < lv));
					image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
				}
			}
		};
		gxSurf(width: int32, height: int32, depth: int32): gxSurf := gxSurf.create(width, height, depth);
		static const gxSurf(fileName: char[*], depth: int32): gxSurf := {
			if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".jpg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".png", ignCaseCmp)) {
				return .result := gxSurf.openPng(fileName, depth);
			}
			if (endsWith(fileName, ".bmp", ignCaseCmp)) {
				return .result := gxSurf.openBmp(fileName, depth);
			}
			abort("unknown file extension", fileName);
		};
		gxSurf(fileName: char[*]): gxSurf := gxSurf(fileName, 32);
		static const gxMesh(fileName: char[*]): gxMesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := gxMesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := gxMesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const gxSurf(copy: gxSurf): gxSurf := {
			result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
			result.copy(result, 0, 0, copy, null);
			return .result := result;
		};
		set(dst: gxSurf, x: int32, y: int32, color: argb): void := gxSurf.set(dst, x, y, uint32(color));
		static const clip(src: gxSurf, roi: gxRect): bool := {
			roi.w := roi.w + roi.x;
			roi.h := roi.h + roi.y;
			if (roi.x < 0) {
				roi.x := 0;
			}
			if (roi.y < 0) {
				roi.y := 0;
			}
			width: int32 := src.width(src);
			if (roi.w > width) {
				roi.w := width;
			}
			height: int32 := src.height(src);
			if (roi.h > height) {
				roi.h := height;
			}
			roi.w := roi.w - roi.x;
			roi.h := roi.h - roi.y;
			if (roi.w <= 0) {
				return .result := false;
			}
			if (roi.h <= 0) {
				return .result := false;
			}
			return .result := true;
		};
		fill(dst: gxSurf, col: uint32): void := dst.fillRect(dst, 0, 0, 65536, 65536, col);
		static const eval(dst: gxSurf, const roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : dst.width(dst);
				rect.h := (roi) != null ? roi.h : dst.height(dst);
			};
			if (!clip(dst, rect)) {
				return;
			}
			in: vec4f := {
				in.x := (0);
				in.y := (0);
				in.z := aspect;
				in.w := time;
			};
			w: float32 := dst.width(dst);
			h: float32 := dst.height(dst);
			for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
					in.x := (x) / w;
					set(dst, x, y, argb(eval(in)));
				}
			}
		};
		static const tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : src.width(src);
				rect.h := (roi) != null ? roi.h : src.height(src);
			};
			if (!clip(src, rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % rect.w);
			}
			if (y < 0) {
				y := -(-y % rect.h);
			}
			width: int32 := dst.width(dst);
			height: int32 := dst.height(dst);
			for (j: int32 := y; j < height; j := j + rect.h) {
				for (i: int32 := x; i < width; i := i + rect.w) {
					dst.copy(dst, i, j, src, rect);
				}
			}
		};
		static const show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void := {
			static const Closure: struct {
				mode: int32;
				offs: gxSurf;
				mesh: gxMesh;
			};
			static const next(x: int32, mask: int32): int32 := {
				next: int32 := x & mask;
				next := next + (mask & -mask);
				next := next & mask;
				return .result := next | (x & ~mask);
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				static ox: int32 := 0;
				static oy: int32 := 0;
				static const speed: float32 := 1.000000 / (100);
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
					else {
						if (button == ('l')) {
							closure.mode := ((closure.mode) ^ gxMesh.useLights);
						}
						else {
							if (button == ('0')) {
								lights.enable(0, !lights.enabled(0));
							}
							else {
								if (button == ('1')) {
									lights.enable(1, !lights.enabled(1));
								}
								else {
									if (button == ('2')) {
										lights.enable(2, !lights.enabled(2));
									}
									else {
										if (button == ('3')) {
											lights.enable(3, !lights.enabled(3));
										}
										else {
											if (button == ('t')) {
												closure.mode := ((closure.mode) ^ gxMesh.useTexture);
											}
											else {
												if (button == ('/')) {
													closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
												}
												else {
													if (button == ('\t')) {
														closure.mode := next(closure.mode, gxMesh.drawMode);
													}
													else {
														if (button == ('\r')) {
															eye: vec4f := {
																eye.x := (0);
																eye.y := (0);
																eye.z := (2);
																eye.w := (1);
															};
															at: vec4f := {
																at.x := (0);
																at.y := (0);
																at.z := (0);
																at.w := (1);
															};
															up: vec4f := {
																up.x := (0);
																up.y := (1);
																up.z := (0);
																up.w := (1);
															};
															camera.lookAt(eye.data, at.data, up.data);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					if ((action) == Gui.MOUSE_PRESS) {
						ox := ex;
						oy := ey;
						return .result := 0;
					}
					else {
						if ((action) == Gui.MOUSE_MOTION) {
							dir: float32[3];
							dx: int32 := ex - ox;
							dy: int32 := ey - oy;
							if (button == 1) {
								orig: float32[3];
								orig[0] := (0);
								orig[1] := (0);
								orig[2] := (0);
								camera.readUp(dir);
								camera.rotate(dir, orig, (dx) * speed);
								camera.readRight(dir);
								camera.rotate(dir, orig, (dy) * speed);
							}
							else {
								if (button == 2) {
									camera.readUp(dir);
									camera.rotate(dir, null, (-dx) * speed);
									camera.readRight(dir);
									camera.rotate(dir, null, (-dy) * speed);
								}
								else {
									if (button == 3) {
										camera.readForward(dir);
										camera.move(dir, (dy) * speed);
									}
									else {
										if (button == 4) {
											camera.readRight(dir);
											camera.move(dir, (-dx) * speed);
											camera.readUp(dir);
											camera.move(dir, (dy) * speed);
										}
									}
								}
							}
							ox := ex;
							oy := ey;
						}
					}
				}
				rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
				text: char[256];
				pos: int32 := append(text, 0, "Vertices: ");
				pos := append(text, pos, closure.mesh.vertices);
				pos := append(text, pos, ", Triangles: ");
				pos := append(text, pos, closure.mesh.triangles);
				pos := append(text, pos, "/");
				pos := append(text, pos, rendered);
				Gui.setTitle(text);
				return .result := 0;
			};
			closure: Closure := {
				closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
				closure.offs := gxSurf.create3d(w, h);
				closure.mesh := mesh;
			};
			camera.projection(fovy, (w) / float32(h), 1, 100);
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.offs.destroy(closure.offs);
		};
		show(surf: gxSurf): void := Gui.showWindow(surf, null, null);
		static const show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
			if ((onEvent) == null) {
				return .result := Gui.showWindow(surf, null, null);
			}
			static const delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				return .result := onEvent(action, button, ex, ey);
			};
			Gui.showWindow(surf, onEvent, delegate);
		};
		static const showDiff(image1: gxSurf, image2: gxSurf): void := {
			static const Closure: struct {
				offs: gxSurf;
				image1: gxSurf;
				image2: gxSurf;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.MOUSE_PRESS) {
					closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
					return .result := 0;
				}
				if ((action) == Gui.MOUSE_RELEASE) {
					closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
					return .result := 0;
				}
				return .result := 0;
			};
			closure: Closure := {
				closure.offs := gxSurf(image1);
				closure.image1 := image1;
				closure.image2 := image2;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
		};
		static const show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void := {
			static const start: int64 := System.millis();
			static const Closure: struct {
				const offs: gxSurf;
				const thumb: gxSurf;
				const aspect: float32;
				const eval(in: vec4f): vec4f;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.WINDOW_CLOSE) {
					trace("closing ...");
					return .result := 0;
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.KEY_RELEASE) {
					if (button == (' ')) {
						time: float32 := ((System.millis() - start)) / 1000.000000;
						eval(closure.offs, null, closure.aspect, time, closure.eval);
						return .result := 0;
					}
				}
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.thumb, null, closure.aspect, time, closure.eval);
				closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
				return .result := 1;
			};
			if (animationResolution == 0) {
				aspect: float32 := (width) / float32(height);
				surf: gxSurf := gxSurf(width, height, 32);
				eval(surf, null, aspect, 0.000000, eval);
				show(surf, null);
				surf.destroy(surf);
				return;
			}
			closure: Closure := {
				closure.offs := gxSurf(width, height, 32);
				closure.thumb := gxSurf(animationResolution, animationResolution, 32);
				closure.aspect := (width) / float32(height);
				closure.eval := eval;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.thumb.destroy(closure.thumb);
			closure.offs.destroy(closure.offs);
		};
	}
}
.instructions: (100 bytes)
	lib/std/string.ci:144: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main>  : load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes): static const format: FormatFlags := {...}
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;append.format
	:: (7 bytes): format.padChr := (0)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+4
	<.main+?>: store.i8
	:: (5 bytes): format.padLen := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+8
	:: (5 bytes): format.precision := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+12
	cmplGfx/gfxlib.ci:167: (5 bytes): static ox: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.ox
	cmplGfx/gfxlib.ci:168: (5 bytes): static oy: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.oy
	cmplGfx/gfxlib.ci:169: (24 bytes): static const speed: float32 := 1.000000 / (100)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 100.000000
	<.main+?>: div.f64
	<.main+?>: f64.2f32
	<.main+?>: store.m32 <?> ;show.onEvent.speed
	cmplGfx/gfxlib.ci:322: (8 bytes): static const start: int64 := System.millis()
	<.main+?>: nfc(16) ;System.millis(): int64
	<.main+?>: store.m64 <?> ;show.start
	<.main+?>: nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:50: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:66: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
File: typename(<File>)
gxRect: typename(<gxRect>)
gxSurf: typename(<gxSurf>)
gxMesh: typename(<gxMesh>)
camera: typename(<camera>)
lights: typename(<lights>)
Gui: typename(<Gui>)
cmplGfx/lib/color.ci:2: argb: typename(<argb>)
cmplGfx/lib/color.ci:27: grayClamp: function(<grayClamp>)
cmplGfx/lib/color.ci:37: grayClamp: function(<grayClamp>)
cmplGfx/lib/color.ci:84: rgbLerp16: function(<rgbLerp16>)
cmplGfx/lib/color.ci:105: hsv2rgb: function(<hsv2rgb>)
cmplGfx/lib/color.ci:144: drawHist: function(<drawHist>)
cmplGfx/gfxlib.ci:8: gxSurf: function(<gxSurf>)
cmplGfx/gfxlib.ci:28: gxMesh: function(<gxMesh>)
cmplGfx/gfxlib.ci:39: gxSurf: function(<gxSurf>)
cmplGfx/gfxlib.ci:49: clip: function(<clip>)
cmplGfx/gfxlib.ci:88: eval: function(<eval>)
cmplGfx/gfxlib.ci:118: tile: function(<tile>)
cmplGfx/gfxlib.ci:146: show: function(<show>)
cmplGfx/gfxlib.ci:277: show: function(<show>)
cmplGfx/gfxlib.ci:288: showDiff: function(<showDiff>)
cmplGfx/gfxlib.ci:321: show: function(<show>)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 313780(306.4 Kb)
memory[heap] @04c9b4; size: 1258826(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 305400(298.2 Kb)
memory[code] @000000; size: 8077(7.9 Kb)
memory[data] @000000; size: 52(52.0 bytes)

---------- heap memory:
memory[free] @04c9c8; size: 1258784(1.2 Mb)

---------- Exitcode: 0, time: 0.000 ms
