
---------- Compile: `lib/stdlib.ci`

---------- Library: `bin/lnx.gcc/libFile.so`

---------- Library: `bin/lnx.gcc/libGfx.so`

---------- Compile: `cmplGfx/gfxlib.ci`

---------- Generate: byte-code
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
cmplGfx/lib/rgb.ci:103: warn: using signed cast for unsigned value: `t * ((1 << 16))`
cmplGfx/lib/color.ci:66: warn: uninitialized variable `drawHist.lut`
cmplGfx/gfxlib.ci:242: warn: uninitialized variable `dir`
cmplGfx/gfxlib.ci:248: warn: uninitialized variable `orig`
cmplGfx/gfxlib.ci:283: warn: uninitialized variable `show.onEvent.text`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(1)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(2)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(3)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(4)
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.value: 0
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(18)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(19)
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(20)
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(21)
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(22)
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(23)
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(24)
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(25)
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.value: 0
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(26)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(27)
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(28)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(29)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(30)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(31)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(32)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(33)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(34)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(35)
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(36)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(37)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(38)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(39)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(40)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(41)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(42)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(43)
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(7)
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: int32 (size: 4, cast: variable(i32))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(8)
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(9)
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(10)
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'true'
.value: 1
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'false'
.value: 0
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'byte'
.value: uint8
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'float'
.value: float32
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'double'
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.value: nfc(0)
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.param inspect: variant (size: 8, cast: variable(var))
.value: nfc(5)
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.value: nfc(6)
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.value: nfc(11)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.value: nfc(12)
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(13)
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(14)
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(15)
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.value: nfc(16)
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.value: nfc(17)
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.verbose, raise.noTrace, message, inspect)
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.verbose, raise.noTrace, message, null)
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.debug, raise.defTrace, message, inspect)
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.debug, raise.defTrace, message, null)
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.debug, raise.noTrace, message, inspect)
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.debug, raise.noTrace, message, null)
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.info, raise.noTrace, message, inspect)
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.info, raise.noTrace, message, null)
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.warn, raise.noTrace, message, inspect)
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.warn, raise.noTrace, message, null)
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.error, raise.defTrace, message, inspect)
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.error, raise.defTrace, message, null)
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: raise(raise.abort, raise.defTrace, message, inspect)
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: ref)
.value: raise(raise.abort, raise.defTrace, message, null)
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, cast: void)
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.param inspect: variant (size: 8, cast: var)
.value: void(condition ? void(0) : abort(message, inspect))
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: ref)
.value: void(condition ? void(0) : abort(message))
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field argument: variant (size: 8, cast: const variable(var))
.field message: char[*] (size: 4, cast: const variable(ref))
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'argument'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.value: null
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'message'
.file: 'lib/stdlib.ci:35'
.owner: NotEquals
.value: null
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.name: 'assertEq'
.file: 'lib/stdlib.ci:39'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: variable(ref))
.value: {
	if (returned == expected) {
		return;
	}
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.message := (message);
		details.argument := (null);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (94 bytes)
	lib/stdlib.ci:40: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x1 sp(2)
	<assertEq+?>: dup.x1 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	lib/stdlib.ci:41: (1 byte): return;
	<assertEq+?>: ret
	lib/stdlib.ci:43: (41 bytes): details: NotEquals := {...}
	<assertEq+?>: inc.sp(+32)
	lib/stdlib.ci:44: (11 bytes): details.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x2 sp(2)
	lib/stdlib.ci:45: (11 bytes): details.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x2 sp(4)
	lib/stdlib.ci:46: (3 bytes): details.message := (message);
	<assertEq+?>: mov.x1 sp(6, 9)
	:: (12 bytes): details.argument := (null)
	<assertEq+?>: load.ref <?> ;pointer
	<assertEq+?>: load.ref <?> ;null
	<assertEq+?>: set.x2 sp(6)
	lib/stdlib.ci:48: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>: load.ref <?> ;"lib/stdlib.ci"
	<assertEq+?>: load.c32 48
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+24)
	<assertEq+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'lib/stdlib.ci:50'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.value: assertEq(expected, returned, null)
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'lib/stdlib.ci:54'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.value: int32(type.size)
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, cast: static const val)
.field e: float64 (size: 8, cast: static const val)
.field ln2: float64 (size: 8, cast: static const val)
.field log2E: float64 (size: 8, cast: static const val)
.field ln10: float64 (size: 8, cast: static const val)
.field log10E: float64 (size: 8, cast: static const val)
.field phi: float64 (size: 8, cast: static const val)
.field sqrt2: float64 (size: 8, cast: static const val)
.field sqrtE: float64 (size: 8, cast: static const val)
.field sqrtPi: float64 (size: 8, cast: static const val)
.field sqrtPhi: float64 (size: 8, cast: static const val)
.field nan: float64 (size: 8, cast: static const val)
.field inf: float64 (size: 8, cast: static const val)
.field modf: function (size: 86, cast: static const function)
.field floor: function (size: 24, cast: static const function)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 36, cast: static const function)
.field sign: function (size: 36, cast: static const function)
.field abs: function (size: 18, cast: static const function)
.field abs: function (size: 18, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field min: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field max: function (size: 17, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field clamp: function (size: 30, cast: static const function)
.field lerp: function (size: 0, cast: static inline)
.field lerp: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field min: function (size: 72, cast: static const function)
.field max: function (size: 72, cast: static const function)
.field sum: function (size: 40, cast: static const function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field cmp: function (size: 57, cast: static const function)
.field sinCos: function (size: 335, cast: static const function)
.field sin: function (size: 0, cast: static inline)
.field cos: function (size: 0, cast: static inline)
.field tan: function (size: 371, cast: static const function)
.field sinh: function (size: 241, cast: static const function)
.field cosh: function (size: 75, cast: static const function)
.field asin: function (size: 166, cast: static const function)
.field acos: function (size: 0, cast: static inline)
.field deg2rad: function (size: 0, cast: static inline)
.field rad2deg: function (size: 0, cast: static inline)
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: 1.000000 / ln2
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: 1.000000 / ln10
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: (0) / 0.000000
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: (1) / 0.000000
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (86 bytes)
	lib/std/math.ci:23: (63 bytes): if (x < (1))
	<modf>  : dup.x2 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +51
	lib/std/math.ci:24: (39 bytes): if (x < (0))
	<modf+?>: dup.x2 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +35
	lib/std/math.ci:25: (17 bytes): result: float64 := -modf(-x, intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x2 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	<modf+?>: neg.f64
	lib/std/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x1 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:27: (3 bytes): return .result := result;
	<modf+?>: set.x2 sp(6)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	lib/std/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x1 sp(3)
	<modf+?>: store.i64
	lib/std/math.ci:30: (4 bytes): return .result := x;
	<modf+?>: mov.x2 sp(4, 2)
	<modf+?>: ret
	lib/std/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x2 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	lib/std/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>: dup.x2 sp(4)
	<modf+?>: dup.x2 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x1 sp(5)
	<modf+?>: store.i64
	lib/std/math.ci:34: (3 bytes): return .result := result;
	<modf+?>: set.x2 sp(6)
	<modf+?>: ret
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'floor'
.file: 'lib/std/math.ci:46'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	result: float64;
	modf(x, result);
	return .result := result;
}
.instructions: (24 bytes)
	lib/std/math.ci:47: (1 byte): result: float64
	<floor>  : load.z128
	lib/std/math.ci:48: (20 bytes): modf(x, result);
	<floor+?>: dup.x2 sp(5)
	<floor+?>: load.sp(+16)
	<floor+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>: call
	<floor+?>: inc.sp(-12)
	<floor+?>: inc.sp(-8)
	lib/std/math.ci:49: (3 bytes): return .result := result;
	<floor+?>: set.x2 sp(5)
	<floor+?>: ret
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'lib/std/math.ci:51'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.value: -floor(-x)
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'lib/std/math.ci:52'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.value: floor(x + 0.500000)
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/std/math.ci:58'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/std/math.ci:59: (12 bytes): if (x == (0))
	<sign>  : dup.x1 sp(1)
	<sign+?>: load.z32
	<sign+?>: ceq.f32
	<sign+?>: jz +8
	lib/std/math.ci:60: (4 bytes): return .result := 0;
	<sign+?>: load.z32
	<sign+?>: set.x1 sp(3)
	<sign+?>: ret
	lib/std/math.ci:62: (16 bytes): if (x < (0))
	<sign+?>: dup.x1 sp(1)
	<sign+?>: load.z32
	<sign+?>: clt.f32
	<sign+?>: jz +12
	lib/std/math.ci:63: (8 bytes): return .result := -1;
	<sign+?>: load.c32 -1
	<sign+?>: set.x1 sp(3)
	<sign+?>: ret
	lib/std/math.ci:65: (8 bytes): return .result := 1;
	<sign+?>: load.c32 1
	<sign+?>: set.x1 sp(3)
	<sign+?>: ret
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/std/math.ci:68: (12 bytes): if (x == (0))
	<sign>  : dup.x2 sp(1)
	<sign+?>: load.z64
	<sign+?>: ceq.f64
	<sign+?>: jz +8
	lib/std/math.ci:69: (4 bytes): return .result := 0;
	<sign+?>: load.z32
	<sign+?>: set.x1 sp(4)
	<sign+?>: ret
	lib/std/math.ci:71: (16 bytes): if (x < (0))
	<sign+?>: dup.x2 sp(1)
	<sign+?>: load.z64
	<sign+?>: clt.f64
	<sign+?>: jz +12
	lib/std/math.ci:72: (8 bytes): return .result := -1;
	<sign+?>: load.c32 -1
	<sign+?>: set.x1 sp(4)
	<sign+?>: ret
	lib/std/math.ci:74: (8 bytes): return .result := 1;
	<sign+?>: load.c32 1
	<sign+?>: set.x1 sp(4)
	<sign+?>: ret
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:83'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:84: (14 bytes): if (x < (0))
	<abs>  : dup.x1 sp(1)
	<abs+?>: load.z32
	<abs+?>: clt.f32
	<abs+?>: jz +10
	lib/std/math.ci:85: (6 bytes): return .result := -x;
	<abs+?>: dup.x1 sp(1)
	<abs+?>: neg.f32
	<abs+?>: set.x1 sp(3)
	<abs+?>: ret
	lib/std/math.ci:87: (4 bytes): return .result := x;
	<abs+?>: mov.x1 sp(2, 1)
	<abs+?>: ret
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.name: 'abs'
.file: 'lib/std/math.ci:89'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (18 bytes)
	lib/std/math.ci:90: (14 bytes): if (x < (0))
	<abs>  : dup.x2 sp(1)
	<abs+?>: load.z64
	<abs+?>: clt.f64
	<abs+?>: jz +10
	lib/std/math.ci:91: (6 bytes): return .result := -x;
	<abs+?>: dup.x2 sp(1)
	<abs+?>: neg.f64
	<abs+?>: set.x2 sp(5)
	<abs+?>: ret
	lib/std/math.ci:93: (4 bytes): return .result := x;
	<abs+?>: mov.x2 sp(3, 1)
	<abs+?>: ret
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:102: (13 bytes): if (a < b)
	<min>  : dup.x1 sp(2)
	<min+?>: dup.x1 sp(2)
	<min+?>: clt.f32
	<min+?>: jz +8
	lib/std/math.ci:103: (4 bytes): return .result := a;
	<min+?>: mov.x1 sp(3, 2)
	<min+?>: ret
	lib/std/math.ci:105: (4 bytes): return .result := b;
	<min+?>: mov.x1 sp(3, 1)
	<min+?>: ret
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'min'
.file: 'lib/std/math.ci:107'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:108: (13 bytes): if (a < b)
	<min>  : dup.x2 sp(3)
	<min+?>: dup.x2 sp(3)
	<min+?>: clt.f64
	<min+?>: jz +8
	lib/std/math.ci:109: (4 bytes): return .result := a;
	<min+?>: mov.x2 sp(5, 3)
	<min+?>: ret
	lib/std/math.ci:111: (4 bytes): return .result := b;
	<min+?>: mov.x2 sp(5, 1)
	<min+?>: ret
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:119'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:120: (13 bytes): if (a > b)
	<max>  : dup.x1 sp(2)
	<max+?>: dup.x1 sp(2)
	<max+?>: cgt.f32
	<max+?>: jz +8
	lib/std/math.ci:121: (4 bytes): return .result := a;
	<max+?>: mov.x1 sp(3, 2)
	<max+?>: ret
	lib/std/math.ci:123: (4 bytes): return .result := b;
	<max+?>: mov.x1 sp(3, 1)
	<max+?>: ret
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'max'
.file: 'lib/std/math.ci:125'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (17 bytes)
	lib/std/math.ci:126: (13 bytes): if (a > b)
	<max>  : dup.x2 sp(3)
	<max+?>: dup.x2 sp(3)
	<max+?>: cgt.f64
	<max+?>: jz +8
	lib/std/math.ci:127: (4 bytes): return .result := a;
	<max+?>: mov.x2 sp(5, 3)
	<max+?>: ret
	lib/std/math.ci:129: (4 bytes): return .result := b;
	<max+?>: mov.x2 sp(5, 1)
	<max+?>: ret
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:138: (13 bytes): if (t < a)
	<clamp>  : dup.x1 sp(3)
	<clamp+?>: dup.x1 sp(3)
	<clamp+?>: clt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:139: (4 bytes): return .result := a;
	<clamp+?>: mov.x1 sp(4, 2)
	<clamp+?>: ret
	lib/std/math.ci:141: (13 bytes): if (t > b)
	<clamp+?>: dup.x1 sp(3)
	<clamp+?>: dup.x1 sp(2)
	<clamp+?>: cgt.f32
	<clamp+?>: jz +8
	lib/std/math.ci:142: (4 bytes): return .result := b;
	<clamp+?>: mov.x1 sp(4, 1)
	<clamp+?>: ret
	lib/std/math.ci:144: (4 bytes): return .result := t;
	<clamp+?>: mov.x1 sp(4, 3)
	<clamp+?>: ret
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'lib/std/math.ci:146'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	lib/std/math.ci:147: (13 bytes): if (t < a)
	<clamp>  : dup.x2 sp(5)
	<clamp+?>: dup.x2 sp(5)
	<clamp+?>: clt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:148: (4 bytes): return .result := a;
	<clamp+?>: mov.x2 sp(7, 3)
	<clamp+?>: ret
	lib/std/math.ci:150: (13 bytes): if (t > b)
	<clamp+?>: dup.x2 sp(5)
	<clamp+?>: dup.x2 sp(3)
	<clamp+?>: cgt.f64
	<clamp+?>: jz +8
	lib/std/math.ci:151: (4 bytes): return .result := b;
	<clamp+?>: mov.x2 sp(7, 1)
	<clamp+?>: ret
	lib/std/math.ci:153: (4 bytes): return .result := t;
	<clamp+?>: mov.x2 sp(7, 5)
	<clamp+?>: ret
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:160'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.value: a + t * (b - a)
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'lib/std/math.ci:161'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.value: a + t * (b - a)
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:163'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:164'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:165'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.value: smooth(clamp((t - a) / (b - a), float32(0), float32(1)))
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'lib/std/math.ci:166'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.value: smooth(clamp((t - a) / (b - a), float64(0), float64(1)))
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'min'
.file: 'lib/std/math.ci:172'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result > data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (72 bytes)
	lib/std/math.ci:173: (13 bytes): if (data.length == (0))
	<min>  : dup.x1 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +9
	lib/std/math.ci:174: (5 bytes): return .result := nan;
	<min+?>: load.z128
	<min+?>: div.f64
	<min+?>: set.x2 sp(5)
	<min+?>: ret
	lib/std/math.ci:176: (3 bytes): result: float64 := data[0]
	<min+?>: dup.x1 sp(1)
	<min+?>: load.i64
	lib/std/math.ci:177: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	lib/std/math.ci:178: (27 bytes): if (result > data[i])
	<min+?>: dup.x2 sp(1)
	<min+?>: dup.x1 sp(6)
	<min+?>: dup.x1 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	lib/std/math.ci:179: (11 bytes): result := data[i];
	<min+?>: dup.x1 sp(4)
	<min+?>: dup.x1 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x2 sp(3)
	lib/std/math.ci:177: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	lib/std/math.ci:177: (9 bytes): i < (data.length)
	<min+?>: dup.x1 sp(0)
	<min+?>: dup.x1 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	lib/std/math.ci:182: (3 bytes): return .result := result;
	<min+?>: set.x2 sp(5)
	<min+?>: ret
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'max'
.file: 'lib/std/math.ci:184'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result < data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (72 bytes)
	lib/std/math.ci:185: (13 bytes): if (data.length == (0))
	<max>  : dup.x1 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +9
	lib/std/math.ci:186: (5 bytes): return .result := nan;
	<max+?>: load.z128
	<max+?>: div.f64
	<max+?>: set.x2 sp(5)
	<max+?>: ret
	lib/std/math.ci:188: (3 bytes): result: float64 := data[0]
	<max+?>: dup.x1 sp(1)
	<max+?>: load.i64
	lib/std/math.ci:189: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	lib/std/math.ci:190: (27 bytes): if (result < data[i])
	<max+?>: dup.x2 sp(1)
	<max+?>: dup.x1 sp(6)
	<max+?>: dup.x1 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	lib/std/math.ci:191: (11 bytes): result := data[i];
	<max+?>: dup.x1 sp(4)
	<max+?>: dup.x1 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x2 sp(3)
	lib/std/math.ci:189: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	lib/std/math.ci:189: (9 bytes): i < (data.length)
	<max+?>: dup.x1 sp(0)
	<max+?>: dup.x1 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	lib/std/math.ci:194: (3 bytes): return .result := result;
	<max+?>: set.x2 sp(5)
	<max+?>: ret
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'sum'
.file: 'lib/std/math.ci:197'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (data.length); i := i + 1) {
		result := result + data[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	lib/std/math.ci:198: (1 byte): result: float64 := 0
	<sum>  : load.z128
	lib/std/math.ci:199: (36 bytes): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	lib/std/math.ci:200: (14 bytes): result := result + data[i];
	<sum+?>: dup.x2 sp(1)
	<sum+?>: dup.x1 sp(6)
	<sum+?>: dup.x1 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x2 sp(3)
	lib/std/math.ci:199: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	lib/std/math.ci:199: (9 bytes): i < (data.length)
	<sum+?>: dup.x1 sp(0)
	<sum+?>: dup.x1 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	lib/std/math.ci:202: (3 bytes): return .result := result;
	<sum+?>: set.x2 sp(5)
	<sum+?>: ret
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:211'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.value: (a0)
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:212'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.value: (a0 + x * a1)
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:213'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.value: (a0 + x * eval(x, a1, a2))
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/std/math.ci:214'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.value: (a0 + x * eval(x, a1, a2, a3))
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.name: 'eval'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	lib/std/math.ci:216: (1 byte): result: float64 := 0
	<eval>  : load.z64
	lib/std/math.ci:217: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x1 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	lib/std/math.ci:218: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x2 sp(1)
	<eval+?>: dup.x2 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x1 sp(6)
	<eval+?>: dup.x1 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x2 sp(3)
	lib/std/math.ci:217: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	lib/std/math.ci:217: (8 bytes): i >= 0
	<eval+?>: dup.x1 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	lib/std/math.ci:220: (3 bytes): return .result := result;
	<eval+?>: set.x2 sp(7)
	<eval+?>: ret
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:223'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.param eps: float32 (size: 4, cast: variable(f32))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:224: (53 bytes): if (a < b)
	<cmp>  : dup.x1 sp(3)
	<cmp+?>: dup.x1 sp(3)
	<cmp+?>: clt.f32
	<cmp+?>: jz +28
	lib/std/math.ci:225: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x1 sp(1)
	<cmp+?>: dup.x1 sp(3)
	<cmp+?>: dup.x1 sp(5)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:226: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:230: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x1 sp(1)
	<cmp+?>: dup.x1 sp(4)
	<cmp+?>: dup.x1 sp(4)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	lib/std/math.ci:231: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
	lib/std/math.ci:234: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x1 sp(5)
	<cmp+?>: ret
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/std/math.ci:236'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.param eps: float64 (size: 8, cast: variable(f64))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/std/math.ci:237: (53 bytes): if (a < b)
	<cmp>  : dup.x2 sp(5)
	<cmp+?>: dup.x2 sp(5)
	<cmp+?>: clt.f64
	<cmp+?>: jz +28
	lib/std/math.ci:238: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x2 sp(1)
	<cmp+?>: dup.x2 sp(5)
	<cmp+?>: dup.x2 sp(9)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:239: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	lib/std/math.ci:243: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x2 sp(1)
	<cmp+?>: dup.x2 sp(7)
	<cmp+?>: dup.x2 sp(7)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	lib/std/math.ci:244: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
	lib/std/math.ci:247: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x1 sp(8)
	<cmp+?>: ret
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.name: 'sinCos'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (335 bytes)
	lib/std/math.ci:264: (2 bytes): x: float64 := arg
	<sinCos>  : dup.x2 sp(2)
	lib/std/math.ci:265: (17 bytes): if (x < (0))
	<sinCos+?>: dup.x2 sp(0)
	<sinCos+?>: load.z64
	<sinCos+?>: clt.f64
	<sinCos+?>: jz +13
	lib/std/math.ci:266: (1 byte): x := -x;
	<sinCos+?>: neg.f64
	lib/std/math.ci:267: (8 bytes): quad := quad + 2;
	<sinCos+?>: dup.x1 sp(3)
	<sinCos+?>: inc.i32(+2)
	<sinCos+?>: set.x1 sp(4)
	lib/std/math.ci:270: (1 byte): y: float64
	<sinCos+?>: load.z64
	lib/std/math.ci:271: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: load.f64 1.570796
	<sinCos+?>: div.f64
	<sinCos+?>: mul.f64
	<sinCos+?>: set.x2 sp(4)
	lib/std/math.ci:272: (124 bytes): if (x > (32764))
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 32764.000000
	<sinCos+?>: cgt.f64
	<sinCos+?>: jz +84
	lib/std/math.ci:273: (1 byte): e: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:274: (18 bytes): y := modf(x, e);
	<sinCos+?>: dup.x2 sp(6)
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: set.x2 sp(4)
	lib/std/math.ci:275: (4 bytes): e := e + (quad);
	<sinCos+?>: dup.x1 sp(7)
	<sinCos+?>: i32.2f64
	<sinCos+?>: add.f64
	lib/std/math.ci:277: (1 byte): f: float64
	<sinCos+?>: load.z128
	lib/std/math.ci:278: (30 bytes): modf(0.250000 * e, f);
	<sinCos+?>: load.f64 0.250000
	<sinCos+?>: dup.x2 sp(6)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: inc.sp(-8)
	lib/std/math.ci:279: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 4.000000
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: sub.f64
	<sinCos+?>: f64.2i32
	<sinCos+?>: set.x1 sp(10)
	<sinCos+?>: inc.sp(-16)
	<sinCos+?>: jmp +32
	lib/std/math.ci:282: (3 bytes): k: int32 := x
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: f64.2i32
	lib/std/math.ci:283: (8 bytes): y := x - (k);
	<sinCos+?>: dup.x2 sp(3)
	<sinCos+?>: dup.x1 sp(2)
	<sinCos+?>: i32.2f64
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x2 sp(3)
	lib/std/math.ci:284: (7 bytes): quad := quad + k;
	<sinCos+?>: dup.x1 sp(6)
	<sinCos+?>: dup.x1 sp(1)
	<sinCos+?>: add.i32
	<sinCos+?>: set.x1 sp(7)
	lib/std/math.ci:285: (6 bytes): quad := quad & 3;
	<sinCos+?>: dup.x1 sp(6)
	<sinCos+?>: b32.and 0x003
	<sinCos+?>: set.x1 sp(7)
	<sinCos+?>: inc.sp(-4)
	lib/std/math.ci:287: (22 bytes): if (quad & 1)
	<sinCos+?>: dup.x1 sp(5)
	<sinCos+?>: b32.and 0x001
	<sinCos+?>: jz +18
	lib/std/math.ci:288: (14 bytes): y := (1) - y;
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x2 sp(2)
	lib/std/math.ci:290: (13 bytes): if (quad > 1)
	<sinCos+?>: dup.x1 sp(5)
	<sinCos+?>: load.c32 1
	<sinCos+?>: cgt.i32
	<sinCos+?>: jz +5
	lib/std/math.ci:291: (1 byte): y := -y;
	<sinCos+?>: neg.f64
	lib/std/math.ci:294: (5 bytes): ysq: float64 := y * y
	<sinCos+?>: dup.x2 sp(0)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	lib/std/math.ci:295: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>: load.f64 145.968841
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -13847.272500
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 440103.053538
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -4942908.100903
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 13578840.978774
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	lib/std/math.ci:296: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: load.f64 132.653491
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 9463.096102
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 408179.225234
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x2 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 8644558.652923
	<sinCos+?>: add.f64
	lib/std/math.ci:297: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: dup.x2 sp(2)
	<sinCos+?>: div.f64
	<sinCos+?>: set.x2 sp(16)
	<sinCos+?>: inc.sp(-40)
	<sinCos+?>: ret
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math.ci:301'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.value: sinCos(arg, 0)
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math.ci:304'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.value: sinCos(abs(arg), 1)
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.name: 'tan'
.file: 'lib/std/math.ci:307'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else {
		if (i == 1) {
			x := (1) - x;
			complement := true;
		}
		else {
			if (i == 2) {
				negate := !negate;
				complement := true;
			}
			else {
				if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
			}
		}
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (371 bytes)
	lib/std/math.ci:320: (1 byte): complement: bool := false
	<tan>  : load.z32
	lib/std/math.ci:321: (1 byte): negate: bool := false
	<tan+?>: load.z32
	lib/std/math.ci:323: (23 bytes): if (arg < (0))
	<tan+?>: dup.x2 sp(3)
	<tan+?>: load.z64
	<tan+?>: clt.f64
	<tan+?>: jz +19
	lib/std/math.ci:324: (5 bytes): arg := -arg;
	<tan+?>: dup.x2 sp(3)
	<tan+?>: neg.f64
	<tan+?>: set.x2 sp(5)
	lib/std/math.ci:325: (10 bytes): negate := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+4)
	<tan+?>: store.i8
	lib/std/math.ci:327: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x2 sp(5)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1.570796
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(5)
	lib/std/math.ci:329: (1 byte): e: float64
	<tan+?>: load.z128
	lib/std/math.ci:330: (16 bytes): x: float64 := modf(arg, e)
	<tan+?>: dup.x2 sp(7)
	<tan+?>: load.sp(+16)
	<tan+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	lib/std/math.ci:331: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>: dup.x2 sp(2)
	<tan+?>: f64.2i32
	<tan+?>: load.c32 4
	<tan+?>: mod.i32
	lib/std/math.ci:333: (122 bytes): if (i == 0)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.z32
	<tan+?>: ceq.i32
	<tan+?>: jnz +118
	lib/std/math.ci:334: (114 bytes): if (i == 1)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 1
	<tan+?>: ceq.i32
	<tan+?>: jz +32
	lib/std/math.ci:335: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x2 sp(3)
	lib/std/math.ci:336: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +78
	lib/std/math.ci:338: (74 bytes): if (i == 2)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 2
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:339: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:340: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +41
	lib/std/math.ci:342: (37 bytes): if (i == 3)
	<tan+?>: dup.x1 sp(0)
	<tan+?>: load.c32 3
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	lib/std/math.ci:343: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x2 sp(3)
	lib/std/math.ci:344: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	lib/std/math.ci:347: (5 bytes): xsq: float64 := x * x
	<tan+?>: dup.x2 sp(1)
	<tan+?>: dup.x2 sp(3)
	<tan+?>: mul.f64
	lib/std/math.ci:348: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>: load.f64 0.000034
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 0.034226
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -15.506857
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1055.970902
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -13068.202648
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(5)
	<tan+?>: mul.f64
	lib/std/math.ci:349: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>: dup.x2 sp(2)
	<tan+?>: load.f64 -155.503316
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 4765.751363
	<tan+?>: add.f64
	<tan+?>: dup.x2 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -16638.952389
	<tan+?>: add.f64
	<tan+?>: div.f64
	lib/std/math.ci:351: (40 bytes): if (complement)
	<tan+?>: load.sp(+40)
	<tan+?>: load.i8
	<tan+?>: jz +35
	lib/std/math.ci:352: (17 bytes): if (result == (0))
	<tan+?>: dup.x2 sp(0)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +13
	lib/std/math.ci:353: (9 bytes): return .result := nan;
	<tan+?>: load.z128
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:355: (14 bytes): result := (1) / result;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x2 sp(2)
	<tan+?>: div.f64
	<tan+?>: set.x2 sp(2)
	lib/std/math.ci:357: (19 bytes): if (negate)
	<tan+?>: load.sp(+36)
	<tan+?>: load.i8
	<tan+?>: jz +14
	lib/std/math.ci:358: (10 bytes): return .result := -result;
	<tan+?>: dup.x2 sp(0)
	<tan+?>: neg.f64
	<tan+?>: set.x2 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	lib/std/math.ci:360: (7 bytes): return .result := result;
	<tan+?>: set.x2 sp(14)
	<tan+?>: inc.sp(-36)
	<tan+?>: ret
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.name: 'sinh'
.file: 'lib/std/math.ci:364'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (241 bytes)
	lib/std/math.ci:376: (1 byte): negate: bool := false
	<sinh>  : load.z32
	lib/std/math.ci:377: (23 bytes): if (x < (0))
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.z64
	<sinh+?>: clt.f64
	<sinh+?>: jz +19
	lib/std/math.ci:378: (5 bytes): x := -x;
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: neg.f64
	<sinh+?>: set.x2 sp(4)
	lib/std/math.ci:379: (10 bytes): negate := true;
	<sinh+?>: load.c32 1
	<sinh+?>: load.sp(+4)
	<sinh+?>: store.i8
	lib/std/math.ci:382: (39 bytes): if (x > (21))
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.f64 21.000000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +27
	lib/std/math.ci:383: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
	lib/std/math.ci:386: (1 byte): result: float64
	<sinh+?>: load.z64
	lib/std/math.ci:387: (151 bytes): if (x > 0.500000)
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: load.f64 0.500000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +34
	lib/std/math.ci:388: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: dup.x2 sp(6)
	<sinh+?>: neg.f64
	<sinh+?>: nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>: sub.f64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(2)
	<sinh+?>: jmp +109
	lib/std/math.ci:391: (5 bytes): sq: float64 := x * x
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: dup.x2 sp(6)
	<sinh+?>: mul.f64
	lib/std/math.ci:392: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>: load.f64 -26.305632
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -2894.211356
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -89912.720220
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(8)
	<sinh+?>: mul.f64
	<sinh+?>: set.x2 sp(4)
	lib/std/math.ci:393: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: dup.x2 sp(2)
	<sinh+?>: load.f64 -173.678954
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 15215.173788
	<sinh+?>: add.f64
	<sinh+?>: dup.x2 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: div.f64
	<sinh+?>: set.x2 sp(4)
	<sinh+?>: inc.sp(-8)
	lib/std/math.ci:396: (19 bytes): if (negate)
	<sinh+?>: load.sp(+8)
	<sinh+?>: load.i8
	<sinh+?>: jz +14
	lib/std/math.ci:397: (10 bytes): return .result := -result;
	<sinh+?>: dup.x2 sp(0)
	<sinh+?>: neg.f64
	<sinh+?>: set.x2 sp(8)
	<sinh+?>: inc.sp(-12)
	<sinh+?>: ret
	lib/std/math.ci:399: (7 bytes): return .result := result;
	<sinh+?>: set.x2 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'lib/std/math.ci:403'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	lib/std/math.ci:404: (13 bytes): if (x < (0))
	<cosh>  : dup.x2 sp(1)
	<cosh+?>: load.z64
	<cosh+?>: clt.f64
	<cosh+?>: jz +9
	lib/std/math.ci:405: (5 bytes): x := -x;
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: neg.f64
	<cosh+?>: set.x2 sp(3)
	lib/std/math.ci:407: (35 bytes): if (x > (21))
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: load.f64 21.000000
	<cosh+?>: cgt.f64
	<cosh+?>: jz +23
	lib/std/math.ci:408: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x2 sp(5)
	<cosh+?>: ret
	lib/std/math.ci:410: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>: dup.x2 sp(1)
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: dup.x2 sp(3)
	<cosh+?>: neg.f64
	<cosh+?>: nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>: add.f64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x2 sp(5)
	<cosh+?>: ret
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.name: 'asin'
.file: 'lib/std/math.ci:419'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (166 bytes)
	lib/std/math.ci:420: (12 bytes): if (x == (0))
	<asin>  : dup.x2 sp(1)
	<asin+?>: load.z64
	<asin+?>: ceq.f64
	<asin+?>: jz +8
	lib/std/math.ci:422: (4 bytes): return .result := x;
	<asin+?>: mov.x2 sp(3, 1)
	<asin+?>: ret
	lib/std/math.ci:425: (1 byte): negate: bool := false
	<asin+?>: load.z32
	lib/std/math.ci:426: (23 bytes): if (x < (0))
	<asin+?>: dup.x2 sp(2)
	<asin+?>: load.z64
	<asin+?>: clt.f64
	<asin+?>: jz +19
	lib/std/math.ci:427: (10 bytes): negate := true;
	<asin+?>: load.c32 1
	<asin+?>: load.sp(+4)
	<asin+?>: store.i8
	lib/std/math.ci:428: (5 bytes): x := -x;
	<asin+?>: dup.x2 sp(2)
	<asin+?>: neg.f64
	<asin+?>: set.x2 sp(4)
	lib/std/math.ci:431: (25 bytes): if (x > (1))
	<asin+?>: dup.x2 sp(2)
	<asin+?>: load.f64 1.000000
	<asin+?>: cgt.f64
	<asin+?>: jz +13
	lib/std/math.ci:433: (9 bytes): return .result := nan;
	<asin+?>: load.z128
	<asin+?>: div.f64
	<asin+?>: set.x2 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
	lib/std/math.ci:436: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>: load.f64 1.000000
	<asin+?>: dup.x2 sp(4)
	<asin+?>: dup.x2 sp(6)
	<asin+?>: mul.f64
	<asin+?>: sub.f64
	<asin+?>: nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:437: (60 bytes): if (x > 0.700000)
	<asin+?>: dup.x2 sp(4)
	<asin+?>: load.f64 0.700000
	<asin+?>: cgt.f64
	<asin+?>: jz +38
	lib/std/math.ci:438: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>: load.f64 3.141593
	<asin+?>: load.f64 2.000000
	<asin+?>: div.f64
	<asin+?>: dup.x2 sp(2)
	<asin+?>: dup.x2 sp(8)
	<asin+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: sub.f64
	<asin+?>: set.x2 sp(2)
	<asin+?>: jmp +14
	lib/std/math.ci:441: (10 bytes): result := float64.atan2(x, result);
	<asin+?>: dup.x2 sp(4)
	<asin+?>: dup.x2 sp(2)
	<asin+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: set.x2 sp(2)
	lib/std/math.ci:444: (19 bytes): if (negate)
	<asin+?>: load.sp(+8)
	<asin+?>: load.i8
	<asin+?>: jz +14
	lib/std/math.ci:445: (10 bytes): return .result := -result;
	<asin+?>: dup.x2 sp(0)
	<asin+?>: neg.f64
	<asin+?>: set.x2 sp(8)
	<asin+?>: inc.sp(-12)
	<asin+?>: ret
	lib/std/math.ci:447: (7 bytes): return .result := result;
	<asin+?>: set.x2 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'lib/std/math.ci:454'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.value: (pi / (2) - asin(x))
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'deg2rad'
.file: 'lib/std/math.ci:477'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.value: float64(x * pi / (180))
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'rad2deg'
.file: 'lib/std/math.ci:478'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.value: float64(x * (180) / pi)
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	lib/std/math.Complex.ci:21: (7 bytes): return .result := {...};
	<Complex>  : mov.x2 sp(3, 1)
	:: (3 bytes): .result.im := (0)
	<Complex+?>: load.z64
	<Complex+?>: set.x2 sp(7)
	<Complex+?>: ret
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.param im: float64 (size: 8, cast: variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (7 bytes)
	lib/std/math.Complex.ci:26: (7 bytes): return .result := {...};
	<Complex>  : mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:28: (3 bytes): .result.im := im;
	<Complex+?>: mov.x2 sp(7, 1)
	<Complex+?>: ret
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(-a.re, -a.im)
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re + b.re, a.im + b.im)
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.value: Complex(a.re + b, a.im)
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a + b.re, b.im)
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re - b.re, a.im - b.im)
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.value: Complex(a.re - b, a.im)
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a - b.re, b.im)
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.value: Complex(a.re * b, a.im * b)
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a * b.re, a * b.im)
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (123 bytes)
	lib/std/math.Complex.ci:70: (79 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : load.z64
	<div+?>: dup.x2 sp(3)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: load.z64
	<div+?>: dup.x2 sp(7)
	<div+?>: load.ref <?> ;Math.abs(x: float64): float64
	<div+?>: call
	<div+?>: inc.sp(-8)
	<div+?>: clt.f64
	<div+?>: jnz +52
	lib/std/math.Complex.ci:71: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x2 sp(3)
	<div+?>: dup.x2 sp(3)
	<div+?>: div.f64
	lib/std/math.Complex.ci:72: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x2 sp(3)
	<div+?>: dup.x2 sp(2)
	<div+?>: dup.x2 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math.Complex.ci:73: (31 bytes): return .result := {...};
	<div+?>: dup.x2 sp(9)
	<div+?>: dup.x2 sp(4)
	<div+?>: dup.x2 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x2 sp(11)
	<div+?>: dup.x2 sp(4)
	<div+?>: dup.x2 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x2 sp(1)
	<div+?>: dup.x2 sp(5)
	<div+?>: div.f64
	lib/std/math.Complex.ci:79: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x2 sp(5)
	<div+?>: dup.x2 sp(2)
	<div+?>: dup.x2 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	lib/std/math.Complex.ci:80: (31 bytes): return .result := {...};
	<div+?>: dup.x2 sp(9)
	<div+?>: dup.x2 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x2 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x2 sp(11)
	<div+?>: dup.x2 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x2 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x2 sp(2)
	<div+?>: div.f64
	<div+?>: set.x2 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.value: div(a, Complex(b))
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.value: div(Complex(a), b)
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.value: float64.sqrt(a.re * a.re + a.im * a.im)
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.value: float64.atan2(a.re, a.im)
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.value: {
	d: float64 := (a.re * a.re + a.im * a.im);
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	lib/std/math.Complex.ci:94: (11 bytes): d: float64 := (a.re * a.re + a.im * a.im)
	<inv>  : dup.x2 sp(1)
	<inv+?>: dup.x2 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x2 sp(5)
	<inv+?>: dup.x2 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	lib/std/math.Complex.ci:95: (20 bytes): return .result := {...};
	<inv+?>: dup.x2 sp(3)
	<inv+?>: dup.x2 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x2 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x2 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x2 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(a.re, -a.im)
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(float64.log(abs(a)), arg(a))
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (100 bytes)
	lib/std/math.Complex.ci:108: (23 bytes): r: float64 := abs(a)
	<pow>  : dup.x4 sp(5)
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x2 sp(4)
	<pow+?>: dup.x2 sp(6)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: nfc(42) ;float64.sqrt(x: float64): float64
	<pow+?>: set.x2 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes): t: float64 := arg(a)
	<pow+?>: dup.x4 sp(7)
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>: set.x2 sp(4)
	<pow+?>: inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>: dup.x2 sp(5)
	<pow+?>: dup.x2 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x2 sp(9)
	<pow+?>: dup.x2 sp(6)
	<pow+?>: nfc(39) ;float64.log(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: add.f64
	lib/std/math.Complex.ci:111: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: dup.x2 sp(9)
	<pow+?>: nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: dup.x2 sp(11)
	<pow+?>: neg.f64
	<pow+?>: dup.x2 sp(6)
	<pow+?>: mul.f64
	<pow+?>: nfc(40) ;float64.exp(x: float64): float64
	<pow+?>: mul.f64
	lib/std/math.Complex.ci:112: (27 bytes): return .result := {...};
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(37) ;float64.cos(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>: dup.x2 sp(0)
	<pow+?>: dup.x2 sp(4)
	<pow+?>: nfc(36) ;float64.sin(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x2 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.value: pow(a, Complex(b))
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(sin(a), cos(a))
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(cos(a), sin(a))
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(sub(exp(a), exp(neg(a))), 2)
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(add(exp(a), exp(neg(a))), 2)
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.value: inv(cos(a))
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.value: inv(sin(a))
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.value: inv(cosh(a))
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.value: inv(sinh(a))
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.value: Complex(abs(x), arg(x))
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	lib/std/string.ci:4: (16 bytes): if ((str) == null)
	<length>  : dup.x1 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	lib/std/string.ci:5: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x1 sp(3)
	<length+?>: ret
	lib/std/string.ci:7: (1 byte): result: int32 := 0
	<length+?>: load.z32
	lib/std/string.ci:8: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	lib/std/string.ci:8: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	lib/std/string.ci:8: (10 bytes): str[result]
	<length+?>: dup.x1 sp(2)
	<length+?>: dup.x1 sp(1)
	<length+?>: add.i32
	<length+?>: load.i8
	<length+?>: jnz -10
	lib/std/string.ci:10: (3 bytes): return .result := result;
	<length+?>: set.x1 sp(3)
	<length+?>: ret
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	lib/std/string.ci:15: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	lib/std/string.ci:16: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x1 sp(3)
	<indexOf+?>: dup.x1 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.i8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	lib/std/string.ci:17: (3 bytes): return .result := i;
	<indexOf+?>: set.x1 sp(4)
	<indexOf+?>: ret
	lib/std/string.ci:15: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	lib/std/string.ci:15: (10 bytes): str[i]
	<indexOf+?>: dup.x1 sp(3)
	<indexOf+?>: dup.x1 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	lib/std/string.ci:20: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x1 sp(4)
	<indexOf+?>: ret
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	lib/std/string.ci:25: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	lib/std/string.ci:26: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	lib/std/string.ci:27: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x1 sp(4)
	<lastIndexOf+?>: dup.x1 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	lib/std/string.ci:28: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x1 sp(1, 0)
	lib/std/string.ci:26: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	lib/std/string.ci:26: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x1 sp(4)
	<lastIndexOf+?>: dup.x1 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	lib/std/string.ci:31: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x1 sp(4)
	<lastIndexOf+?>: ret
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	lib/std/string.ci:36: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	lib/std/string.ci:37: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: dup.x1 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: dup.x1 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x1 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	lib/std/string.ci:38: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	lib/std/string.ci:36: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	lib/std/string.ci:36: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x1 sp(3)
	<startsWith+?>: dup.x1 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	lib/std/string.ci:41: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	lib/std/string.ci:45: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:46: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x1 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:47: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x1 sp(0)
	<endsWith+?>: dup.x1 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	lib/std/string.ci:48: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	lib/std/string.ci:50: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	lib/std/string.ci:51: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: dup.x1 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x1 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	lib/std/string.ci:52: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	lib/std/string.ci:50: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	lib/std/string.ci:50: (9 bytes): i < withLen
	<endsWith+?>: dup.x1 sp(0)
	<endsWith+?>: dup.x1 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	lib/std/string.ci:55: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: variable(ref))
.param with: char[*] (size: 4, cast: variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	lib/std/string.ci:59: (1 byte): result: int32 := 0
	<compare>  : load.z32
	lib/std/string.ci:60: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	lib/std/string.ci:61: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x1 sp(6)
	<compare+?>: dup.x1 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x1 sp(6)
	<compare+?>: dup.x1 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x1 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x1 sp(5)
	<compare+?>: dup.x1 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	lib/std/string.ci:63: (4 bytes): break;
	<compare+?>: jmp +16
	lib/std/string.ci:60: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	lib/std/string.ci:60: (8 bytes): result == 0
	<compare+?>: dup.x1 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	lib/std/string.ci:66: (3 bytes): return .result := result;
	<compare+?>: set.x1 sp(5)
	<compare+?>: ret
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	lib/std/string.ci:81: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x1 sp(4)
	<ignCaseCmp+?>: ret
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	lib/std/string.ci:85: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x1 sp(4)
	<caseCmp+?>: ret
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: startsWith(str, with, caseCmp)
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: endsWith(str, with, caseCmp)
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: ref)
.param with: char[*] (size: 4, cast: ref)
.value: compare(str, with, caseCmp)
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: ref)
.param chr: char (size: 4, cast: i32)
.value: indexOf(str, chr) >= 0
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field padLen: int32 (size: 4, cast: const variable(i32))
.field precision: int32 (size: 4, cast: const variable(i32))
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (84 bytes)
	lib/std/string.ci:114: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append>  : load.z32
	<append+?>: jmp +41
	lib/std/string.ci:115: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(3)
	<append+?>: dup.x1 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	lib/std/string.ci:116: (4 bytes): break;
	<append+?>: jmp +38
	lib/std/string.ci:118: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x1 sp(5)
	<append+?>: dup.x1 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:119: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:114: (10 bytes): value[i]
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	lib/std/string.ci:122: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(2)
	<append+?>: dup.x1 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:123: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x1 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x1 sp(4)
	<append+?>: dup.x1 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:126: (4 bytes): return .result := pos;
	<append+?>: mov.x1 sp(5, 2)
	<append+?>: ret
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param sign: char (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (657 bytes)
	lib/std/string.ci:133: (1 byte): len: int32 := 0
	<append>  : load.z32
	lib/std/string.ci:134: (4 bytes): digits: char[80]
	<append+?>: inc.sp(+80)
	lib/std/string.ci:136: (3 bytes): radix: int32 := format.radix
	<append+?>: dup.x1 sp(22)
	<append+?>: load.i32
	lib/std/string.ci:137: (54 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: dup.x1 sp(0)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 137
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: dup.x1 sp(0)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 138
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +38
	lib/std/string.ci:142: (27 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x1 sp(25)
	<append+?>: dup.x1 sp(2)
	<append+?>: mod.u32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: load.sp(+8)
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x1 sp(0)
	<append+?>: set.x1 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:141: (7 bytes): value := value / (radix)
	<append+?>: dup.x1 sp(24)
	<append+?>: dup.x1 sp(1)
	<append+?>: div.u32
	<append+?>: set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes): value > (0)
	<append+?>: dup.x1 sp(24)
	<append+?>: load.z32
	<append+?>: cgt.u32
	<append+?>: jnz -38
	lib/std/string.ci:144: (29 bytes): if (len == 0)
	<append+?>: dup.x1 sp(21)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	lib/std/string.ci:145: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+8)
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x1 sp(0)
	<append+?>: set.x1 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:148: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>: dup.x1 sp(23)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: dup.x1 sp(22)
	<append+?>: sub.i32
	lib/std/string.ci:150: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x1 sp(24)
	<append+?>: inc.i32(+4)
	<append+?>: load.i8
	lib/std/string.ci:151: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	lib/std/string.ci:152: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	lib/std/string.ci:156: (207 bytes): if ((sign) != 0)
	<append+?>: load.sp(+108)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	lib/std/string.ci:157: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.i8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +95
	lib/std/string.ci:160: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:161: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 161
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:163: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes): maxLen > 0
	<append+?>: dup.x1 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:166: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 166
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes): output[pos] := sign;
	<append+?>: load.sp(+108)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:168: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	lib/std/string.ci:173: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 173
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:175: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x1 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes): maxLen > 0
	<append+?>: dup.x1 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	lib/std/string.ci:179: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +85
	lib/std/string.ci:180: (52 bytes): assert(i < (output.length));
	<append+?>: dup.x1 sp(0)
	<append+?>: dup.x1 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"lib/std/string.ci"
	<append+?>: load.c32 180
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+16)
	<append+?>: dup.x1 sp(25)
	<append+?>: dup.x1 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x1 sp(31)
	<append+?>: dup.x1 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:182: (8 bytes): pos := pos + 1;
	<append+?>: dup.x1 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	lib/std/string.ci:179: (9 bytes): i < len
	<append+?>: dup.x1 sp(0)
	<append+?>: dup.x1 sp(25)
	<append+?>: clt.i32
	<append+?>: jnz -86
	<append+?>: inc.sp(-4)
	lib/std/string.ci:185: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x1 sp(28)
	<append+?>: dup.x1 sp(31)
	<append+?>: clt.i32
	<append+?>: jnz +12
	lib/std/string.ci:186: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x1 sp(30)
	<append+?>: inc.i32(-1)
	<append+?>: set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x1 sp(30)
	<append+?>: dup.x1 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	lib/std/string.ci:189: (8 bytes): return .result := pos;
	<append+?>: mov.x1 sp(31, 28)
	<append+?>: inc.sp(-96)
	<append+?>: ret
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.value: {
	return .result := append(output, pos, 0, value, format);
}
.instructions: (23 bytes)
	lib/std/string.ci:193: (23 bytes): return .result := append(output, pos, 0, value, format);
	<append>  : load.z32
	<append+?>: dup.x2 sp(5)
	<append+?>: dup.x1 sp(6)
	<append+?>: load.z32
	<append+?>: dup.x1 sp(7)
	<append+?>: dup.x1 sp(7)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-24)
	<append+?>: set.x1 sp(7)
	<append+?>: ret
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (value < 0) {
		sign := ('-');
		value := -value;
	}
	return .result := append(output, pos, sign, value, format);
}
.instructions: (49 bytes)
	lib/std/string.ci:197: (1 byte): sign: int32 := 0
	<append>  : load.z32
	lib/std/string.ci:198: (20 bytes): if (value < 0)
	<append+?>: dup.x1 sp(3)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +16
	lib/std/string.ci:199: (7 bytes): sign := ('-');
	<append+?>: load.c32 45
	<append+?>: set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes): value := -value;
	<append+?>: dup.x1 sp(3)
	<append+?>: neg.i32
	<append+?>: set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes): return .result := append(output, pos, sign, value, format);
	<append+?>: load.z32
	<append+?>: dup.x2 sp(6)
	<append+?>: dup.x1 sp(7)
	<append+?>: dup.x1 sp(4)
	<append+?>: dup.x1 sp(8)
	<append+?>: dup.x1 sp(8)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-24)
	<append+?>: set.x1 sp(8)
	<append+?>: inc.sp(-4)
	<append+?>: ret
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: uint32 (size: 4, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		format.radix := 10;
		format.padChr := (0);
		format.padLen := 0;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (25 bytes)
	lib/std/string.ci:207: (25 bytes): return .result := append(output, pos, value, format);
	<append>  : load.z32
	<append+?>: dup.x2 sp(4)
	<append+?>: dup.x1 sp(5)
	<append+?>: dup.x1 sp(5)
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-20)
	<append+?>: set.x1 sp(6)
	<append+?>: ret
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:3'
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
}
vec2d.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'lib/vec/vec2d.ci:4'
.owner: vec2d
}
vec2d.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'lib/vec/vec2d.ci:5'
.owner: vec2d
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:8'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	lib/vec/vec2d.ci:9: (7 bytes): return .result := {...};
	<vec2d>  : mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:11: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x2 sp(7, 1)
	<vec2d+?>: ret
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/vec/vec2d.ci:15'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'lib/vec/vec2d.ci:16'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.value: a.x * b.x + a.y * b.y
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:3'
.field data: float32[4] (size: 16, cast: variable(val))
.field .anonymous: vec4f..anonymous (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'lib/vec/vec4f.ci:4'
.owner: vec4f
}
vec4f..anonymous: vec4f..anonymous {
.kind: variable(val)
.base: `vec4f..anonymous`
.size: 16
.name: '.anonymous'
.file: 'lib/vec/vec4f.ci:84'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
}
vec4f..anonymous.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f..anonymous
}
vec4f..anonymous.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f..anonymous
}
vec4f..anonymous.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f..anonymous
}
vec4f..anonymous.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f..anonymous
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:21'
.param .result: vec4f (size: 16, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.param w: float32 (size: 4, cast: variable(f32))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (13 bytes)
	lib/vec/vec4f.ci:22: (13 bytes): return .result := {...};
	<vec4f>  : mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:22: (3 bytes): .result.y := y;
	<vec4f+?>: mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:22: (3 bytes): .result.z := z;
	<vec4f+?>: mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:22: (3 bytes): .result.w := w;
	<vec4f+?>: mov.x1 sp(8, 1)
	<vec4f+?>: ret
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:24'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.value: vec4f(x, y, z, 0.000000)
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:25'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:26'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.value: vec4f(val, val, val, val)
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/vec/vec4f.ci:56'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: vec4f(emit(struct(rhs), neg.p4f))
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/vec/vec4f.ci:57'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/vec/vec4f.ci:58'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/vec/vec4f.ci:59'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/vec/vec4f.ci:60'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'lib/vec/vec4f.ci:62'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: float32(emit(struct(rhs), struct(lhs), min.p4f))
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'lib/vec/vec4f.ci:63'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: float32(emit(struct(rhs), struct(lhs), max.p4f))
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:68'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: float32(emit(struct(rhs), struct(lhs), p4x.dp3))
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/vec/vec4f.ci:69'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: float32(emit(struct(rhs), struct(lhs), p4x.dph))
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:70'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.value: float32(emit(struct(rhs), struct(lhs), p4x.dp4))
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'lib/vec/vec4f.ci:72'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'len'
.file: 'lib/vec/vec4f.ci:74'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.value: float32.sqrt(dp3(v, v))
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.value: div(v, vec4f(len(v)))
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'lib/vec/vec4f.ci:77'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:3'
.field data: float32[16] (size: 64, cast: variable(val))
.field .anonymous: mat4f..anonymous (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'lib/vec/mat4f.ci:4'
.owner: mat4f
}
mat4f..anonymous: mat4f..anonymous {
.kind: variable(val)
.base: `mat4f..anonymous`
.size: 64
.name: '.anonymous'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
}
mat4f..anonymous.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f..anonymous
}
mat4f..anonymous.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f..anonymous
}
mat4f..anonymous.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f..anonymous
}
mat4f..anonymous.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f..anonymous
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.value: w: vec4f
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:13'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.value: {
	return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
}
.instructions: (49 bytes)
	lib/vec/mat4f.ci:17: (49 bytes): return .result := {...};
	<mat4f>  : mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:18: (3 bytes): .result.x.y := xy;
	<mat4f+?>: mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:18: (3 bytes): .result.x.z := xz;
	<mat4f+?>: mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:18: (3 bytes): .result.x.w := xw;
	<mat4f+?>: mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:19: (3 bytes): .result.y.x := yx;
	<mat4f+?>: mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:19: (3 bytes): .result.y.y := yy;
	<mat4f+?>: mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:19: (3 bytes): .result.y.z := yz;
	<mat4f+?>: mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:19: (3 bytes): .result.y.w := yw;
	<mat4f+?>: mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:20: (3 bytes): .result.z.x := zx;
	<mat4f+?>: mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:20: (3 bytes): .result.z.y := zy;
	<mat4f+?>: mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:20: (3 bytes): .result.z.z := zz;
	<mat4f+?>: mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:20: (3 bytes): .result.z.w := zw;
	<mat4f+?>: mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:21: (3 bytes): .result.w.x := wx;
	<mat4f+?>: mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:21: (3 bytes): .result.w.y := wy;
	<mat4f+?>: mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:21: (3 bytes): .result.w.z := wz;
	<mat4f+?>: mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:21: (3 bytes): .result.w.w := ww;
	<mat4f+?>: mov.x1 sp(32, 1)
	<mat4f+?>: ret
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:25'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	lib/vec/mat4f.ci:26: (21 bytes): return .result := {...};
	<mat4f>  : dup.x1 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(9)
	lib/vec/mat4f.ci:26: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x1 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(13)
	lib/vec/mat4f.ci:26: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x1 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(17)
	lib/vec/mat4f.ci:26: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x1 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x4 sp(21)
	<mat4f+?>: ret
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:29'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:30'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'lib/vec/mat4f.ci:31'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.name: 'mul'
.file: 'lib/vec/mat4f.ci:33'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.value: {
	transposed: mat4f := {
		transposed.x.x := rhs.x.x;
		transposed.x.y := rhs.y.x;
		transposed.x.z := rhs.z.x;
		transposed.x.w := rhs.w.x;
		transposed.y.x := rhs.x.y;
		transposed.y.y := rhs.y.y;
		transposed.y.z := rhs.z.y;
		transposed.y.w := rhs.w.y;
		transposed.z.x := rhs.x.z;
		transposed.z.y := rhs.y.z;
		transposed.z.z := rhs.z.z;
		transposed.z.w := rhs.w.z;
		transposed.w.x := rhs.x.w;
		transposed.w.y := rhs.y.w;
		transposed.w.z := rhs.z.w;
		transposed.w.w := rhs.w.w;
	};
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (417 bytes)
	lib/vec/mat4f.ci:34: (144 bytes): transposed: mat4f := {...}
	<mul>  : inc.sp(+64)
	lib/vec/mat4f.ci:35: (5 bytes): transposed.x.x := rhs.x.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(1)
	lib/vec/mat4f.ci:35: (9 bytes): transposed.x.y := rhs.y.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(2)
	lib/vec/mat4f.ci:35: (9 bytes): transposed.x.z := rhs.z.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(3)
	lib/vec/mat4f.ci:35: (9 bytes): transposed.x.w := rhs.w.x;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(4)
	lib/vec/mat4f.ci:36: (9 bytes): transposed.y.x := rhs.x.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+4)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(5)
	lib/vec/mat4f.ci:36: (9 bytes): transposed.y.y := rhs.y.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+20)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(6)
	lib/vec/mat4f.ci:36: (9 bytes): transposed.y.z := rhs.z.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+36)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(7)
	lib/vec/mat4f.ci:36: (9 bytes): transposed.y.w := rhs.w.y;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+52)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(8)
	lib/vec/mat4f.ci:37: (9 bytes): transposed.z.x := rhs.x.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(9)
	lib/vec/mat4f.ci:37: (9 bytes): transposed.z.y := rhs.y.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+24)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(10)
	lib/vec/mat4f.ci:37: (9 bytes): transposed.z.z := rhs.z.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+40)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(11)
	lib/vec/mat4f.ci:37: (9 bytes): transposed.z.w := rhs.w.z;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+56)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(12)
	lib/vec/mat4f.ci:38: (9 bytes): transposed.w.x := rhs.x.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+12)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(13)
	lib/vec/mat4f.ci:38: (9 bytes): transposed.w.y := rhs.y.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+28)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(14)
	lib/vec/mat4f.ci:38: (9 bytes): transposed.w.z := rhs.z.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+44)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(15)
	lib/vec/mat4f.ci:38: (9 bytes): transposed.w.w := rhs.w.w;
	<mul+?>: dup.x1 sp(17)
	<mul+?>: inc.i32(+60)
	<mul+?>: load.i32
	<mul+?>: set.x1 sp(16)
	lib/vec/mat4f.ci:41: (273 bytes): return .result := {...};
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(23)
	lib/vec/mat4f.ci:43: (68 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(27)
	lib/vec/mat4f.ci:44: (68 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(31)
	lib/vec/mat4f.ci:45: (68 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x1 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: inc.sp(+16)
	<mul+?>: dup.x1 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(9)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(5)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(10)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(6)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(11)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x1 sp(7)
	<mul+?>: load.i128
	<mul+?>: dup.x1 sp(12)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+?>: call
	<mul+?>: inc.sp(-16)
	<mul+?>: set.x4 sp(2)
	<mul+?>: set.x4 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0, cast: static const inline)
.field create: function (size: 0, cast: static const inline)
.field append: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field peek: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field readLine: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field flush: function (size: 0, cast: static const inline)
.field close: function (size: 0, cast: static const inline)
.field in: File (size: 0, cast: static const inline)
.field out: File (size: 0, cast: static const inline)
.field err: File (size: 0, cast: static const inline)
.field log: File (size: 0, cast: static const inline)
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(44)
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(45)
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(46)
}
File.read(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(47)
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(48)
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(49)
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readLine'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(50)
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param byte: uint8 (size: 4, cast: variable(u32))
.value: nfc(51)
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(52)
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(53)
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(54)
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.value: nfc(55)
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.value: nfc(56)
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.value: nfc(57)
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.value: nfc(58)
}
gxRect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'gxRect'
.file: 'cmplGfx/src/gx_main.c:1001'
.field x: int32 (size: 4, cast: variable(i32))
.field y: int32 (size: 4, cast: variable(i32))
.field w: int32 (size: 4, cast: variable(i32))
.field h: int32 (size: 4, cast: variable(i32))
}
gxRect.x: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.file: 'cmplGfx/src/gx_main.c:1002'
.owner: gxRect
}
gxRect.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'cmplGfx/src/gx_main.c:1003'
.owner: gxRect
}
gxRect.w: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'w'
.file: 'cmplGfx/src/gx_main.c:1004'
.owner: gxRect
}
gxRect.h: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'h'
.file: 'cmplGfx/src/gx_main.c:1005'
.owner: gxRect
}
gxSurf: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'gxSurf'
.field create: function (size: 0, cast: static const inline)
.field create3d: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openBmp: function (size: 0, cast: static const inline)
.field openPng: function (size: 0, cast: static const inline)
.field openJpg: function (size: 0, cast: static const inline)
.field openFnt: function (size: 0, cast: static const inline)
.field saveBmp: function (size: 0, cast: static const inline)
.field width: function (size: 0, cast: static const inline)
.field height: function (size: 0, cast: static const inline)
.field depth: function (size: 0, cast: static const inline)
.field get: function (size: 0, cast: static const inline)
.field set: function (size: 0, cast: static const inline)
.field drawRect: function (size: 0, cast: static const inline)
.field fillRect: function (size: 0, cast: static const inline)
.field drawOval: function (size: 0, cast: static const inline)
.field fillOval: function (size: 0, cast: static const inline)
.field drawLine: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field clipText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field resize: function (size: 0, cast: static const inline)
.field colorMap: function (size: 0, cast: static const inline)
.field colorMat: function (size: 0, cast: static const inline)
.field calcHist: function (size: 0, cast: static const inline)
.field drawMesh: function (size: 0, cast: static const inline)
}
gxSurf.create(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(72)
}
gxSurf.create3d(width: int32, height: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.value: nfc(73)
}
gxSurf.recycle(recycle: gxSurf, width: int32, height: int32, depth: int32, flags: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param recycle: gxSurf (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(74)
}
gxSurf.destroy(surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(75)
}
gxSurf.openBmp(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(76)
}
gxSurf.openPng(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(77)
}
gxSurf.openJpg(path: char[*], depth: int32): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(78)
}
gxSurf.openFnt(path: char[*]): gxSurf: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: gxSurf
.param .result: gxSurf (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(79)
}
gxSurf.saveBmp(surf: gxSurf, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param path: char[*] (size: 4, cast: variable(ref))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(80)
}
gxSurf.width(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(81)
}
gxSurf.height(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(82)
}
gxSurf.depth(surf: gxSurf): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(83)
}
gxSurf.get(surf: gxSurf, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.value: nfc(84)
}
gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.value: nfc(85)
}
gxSurf.drawRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(86)
}
gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(87)
}
gxSurf.drawOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(88)
}
gxSurf.fillOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillOval'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(89)
}
gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawLine'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(90)
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(91)
}
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param x4: int32 (size: 4, cast: variable(i32))
.param y4: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(92)
}
gxSurf.clipText(font: gxSurf, rect: gxRect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param font: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: variable(ref))
.value: nfc(93)
}
gxSurf.drawText(surf: gxSurf, x: int32, y: int32, font: gxSurf, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param font: gxSurf (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(94)
}
gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.value: nfc(95)
}
gxSurf.resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'resize'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param rect: gxRect (size: 4, cast: const variable(ref))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.value: nfc(96)
}
gxSurf.colorMap(surf: gxSurf, roi: gxRect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: const variable(ref))
.value: nfc(97)
}
gxSurf.colorMat(surf: gxSurf, roi: gxRect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.value: nfc(98)
}
gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcHist'
.owner: gxSurf
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: const variable(ref))
.param rgb: uint32 (size: 4, cast: variable(u32))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(99)
}
gxSurf.drawMesh(surf: gxSurf, mesh: gxMesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: gxSurf
.param .result: int32 (size: 4, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.value: nfc(100)
}
gxMesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 176
.name: 'gxMesh'
.field create: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openObj: function (size: 0, cast: static const inline)
.field open3ds: function (size: 0, cast: static const inline)
.field saveObj: function (size: 0, cast: static const inline)
.field normalize: function (size: 0, cast: static const inline)
.field addVertex: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field shine: function (size: 0, cast: static const inline)
.field texture: function (size: 0, cast: static const inline)
.field clearDepth: int64 (size: 0, cast: static const i64)
.field clearColor: int64 (size: 0, cast: static const i64)
.field cullBack: int64 (size: 0, cast: static const i64)
.field cullFront: int64 (size: 0, cast: static const i64)
.field drawPlot: int64 (size: 0, cast: static const i64)
.field drawWire: int64 (size: 0, cast: static const i64)
.field drawFill: int64 (size: 0, cast: static const i64)
.field drawMode: int64 (size: 0, cast: static const i64)
.field useTexture: int64 (size: 0, cast: static const i64)
.field useLights: int64 (size: 0, cast: static const i64)
.field vertices: int64 (size: 8, cast: const variable(i64))
.field triangles: int64 (size: 8, cast: const variable(i64))
.field segments: int64 (size: 8, cast: const variable(i64))
}
gxMesh.create(size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(59)
}
gxMesh.recycle(recycle: gxMesh, size: int32): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param recycle: gxMesh (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(60)
}
gxMesh.destroy(mesh: gxMesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.value: nfc(61)
}
gxMesh.openObj(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(62)
}
gxMesh.open3ds(path: char[*]): gxMesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: gxMesh
.param .result: gxMesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(63)
}
gxMesh.saveObj(mesh: gxMesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: variable(ref))
.value: nfc(64)
}
gxMesh.normalize(mesh: gxMesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param tolerance: float32 (size: 4, cast: variable(f32))
.param center: float32[3] (size: 4, cast: variable(ref))
.param resize: float32[3] (size: 4, cast: variable(ref))
.value: nfc(65)
}
gxMesh.addVertex(mesh: gxMesh, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(66)
}
gxMesh.ambient(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(67)
}
gxMesh.diffuse(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(68)
}
gxMesh.specular(mesh: gxMesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(69)
}
gxMesh.shine(mesh: gxMesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.value: nfc(70)
}
gxMesh.texture(mesh: gxMesh, surf: gxSurf): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: gxMesh
.param .result: void (size: 0, cast: inline)
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param surf: gxSurf (size: 8, cast: variable(val))
.value: nfc(71)
}
gxMesh.clearDepth: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearDepth'
.owner: gxMesh
.value: 8
}
gxMesh.clearColor: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearColor'
.owner: gxMesh
.value: 4
}
gxMesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: gxMesh
.value: 16
}
gxMesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: gxMesh
.value: 32
}
gxMesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: gxMesh
.value: 1
}
gxMesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: gxMesh
.value: 2
}
gxMesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: gxMesh
.value: 3
}
gxMesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: gxMesh
.value: 3
}
gxMesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: gxMesh
.value: 64
}
gxMesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: gxMesh
.value: 128
}
gxMesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: gxMesh
}
gxMesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: gxMesh
}
gxMesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: gxMesh
}
camera: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'camera'
.field projection: function (size: 0, cast: static const inline)
.field lookAt: function (size: 0, cast: static const inline)
.field readUp: function (size: 0, cast: static const inline)
.field readRight: function (size: 0, cast: static const inline)
.field readForward: function (size: 0, cast: static const inline)
.field rotate: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
}
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'projection'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param fovy: float32 (size: 4, cast: variable(f32))
.param aspect: float32 (size: 4, cast: variable(f32))
.param near: float32 (size: 4, cast: variable(f32))
.param far: float32 (size: 4, cast: variable(f32))
.value: nfc(101)
}
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lookAt'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param eye: float32[3] (size: 4, cast: variable(ref))
.param at: float32[3] (size: 4, cast: variable(ref))
.param up: float32[3] (size: 4, cast: variable(ref))
.value: nfc(102)
}
camera.readUp(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readUp'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(103)
}
camera.readRight(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readRight'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(104)
}
camera.readForward(result: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readForward'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param result: float32[3] (size: 4, cast: variable(ref))
.value: nfc(105)
}
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rotate'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param orbit: float32[3] (size: 4, cast: variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.value: nfc(106)
}
camera.move(direction: float32[3], amount: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: camera
.param .result: void (size: 0, cast: inline)
.param direction: float32[3] (size: 4, cast: variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.value: nfc(107)
}
lights: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'lights'
.field enabled: function (size: 0, cast: static const inline)
.field enable: function (size: 0, cast: static const inline)
.field position: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field attenuation: function (size: 0, cast: static const inline)
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.value: nfc(108)
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param on: bool (size: 4, cast: variable(bool))
.value: nfc(109)
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(110)
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(111)
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(112)
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(113)
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param constant: float32 (size: 4, cast: variable(f32))
.param linear: float32 (size: 4, cast: variable(f32))
.param quadratic: float32 (size: 4, cast: variable(f32))
.value: nfc(114)
}
Gui: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Gui'
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CONTROL: int64 (size: 0, cast: static const i64)
.field showWindow: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
}
Gui.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Gui
.value: 1
}
Gui.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Gui
.value: 2
}
Gui.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Gui
.value: 3
}
Gui.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Gui
.value: 5
}
Gui.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Gui
.value: 4
}
Gui.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Gui
.value: 6
}
Gui.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Gui
.value: 100
}
Gui.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Gui
.value: 101
}
Gui.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Gui
.value: 102
}
Gui.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Gui
.value: 1
}
Gui.KEY_MASK_CONTROL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CONTROL'
.owner: Gui
.value: 2
}
Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'showWindow'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param surf: gxSurf (size: 8, cast: variable(val))
.param closure: pointer (size: 4, cast: variable(ref))
.param onEvent: function (size: 4, cast: variable(ref))
.value: nfc(115)
}
Gui.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param title: char[*] (size: 4, cast: variable(ref))
.value: nfc(116)
}
grayClamp(c: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'grayClamp'
.file: 'cmplGfx/lib/rgb.ci:2'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: uint32 (size: 4, cast: variable(u32))
.value: {
	if (c > (255)) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (24 bytes)
	cmplGfx/lib/rgb.ci:3: (20 bytes): if (c > (255))
	<grayClamp>  : dup.x1 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.u32
	<grayClamp+?>: jz +12
	cmplGfx/lib/rgb.ci:4: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/rgb.ci:6: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x1 sp(2, 1)
	<grayClamp+?>: ret
}
grayClamp(c: int32): uint32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'grayClamp'
.file: 'cmplGfx/lib/rgb.ci:8'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: int32 (size: 4, cast: variable(i32))
.value: {
	if (c < 0) {
		return .result := 0;
	}
	if (c > 255) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (36 bytes)
	cmplGfx/lib/rgb.ci:9: (12 bytes): if (c < 0)
	<grayClamp>  : dup.x1 sp(1)
	<grayClamp+?>: load.z32
	<grayClamp+?>: clt.i32
	<grayClamp+?>: jz +8
	cmplGfx/lib/rgb.ci:10: (4 bytes): return .result := 0;
	<grayClamp+?>: load.z32
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/rgb.ci:12: (20 bytes): if (c > 255)
	<grayClamp+?>: dup.x1 sp(1)
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: cgt.i32
	<grayClamp+?>: jz +12
	cmplGfx/lib/rgb.ci:13: (8 bytes): return .result := 255;
	<grayClamp+?>: load.c32 255
	<grayClamp+?>: set.x1 sp(3)
	<grayClamp+?>: ret
	cmplGfx/lib/rgb.ci:15: (4 bytes): return .result := c;
	<grayClamp+?>: mov.x1 sp(2, 1)
	<grayClamp+?>: ret
}
grayAnd(c: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'grayAnd'
.file: 'cmplGfx/lib/rgb.ci:17'
.param .result: uint32 (size: 4, cast: u32)
.param c: uint32 (size: 4, cast: u32)
.value: uint32(c & (255))
}
rgb(r: int32, g: int32, b: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'cmplGfx/lib/rgb.ci:19'
.param .result: uint32 (size: 4, cast: u32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: uint32((((r << 8) | g) << 8) | b)
}
rgb(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'cmplGfx/lib/rgb.ci:20'
.param .result: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.value: uint32((((r << 8) | g) << 8) | b)
}
rgbClamp(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbClamp'
.file: 'cmplGfx/lib/rgb.ci:21'
.param .result: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.value: rgb(grayClamp(r), grayClamp(g), grayClamp(b))
}
rgbClamp(r: int32, g: int32, b: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbClamp'
.file: 'cmplGfx/lib/rgb.ci:22'
.param .result: uint32 (size: 4, cast: u32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: rgb(grayClamp(r), grayClamp(g), grayClamp(b))
}
rgbAnd(r: uint32, g: uint32, b: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgbAnd'
.file: 'cmplGfx/lib/rgb.ci:23'
.param .result: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.value: rgb(grayAnd(r), grayAnd(g), grayAnd(b))
}
rgb(r: float64, g: float64, b: float64): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'cmplGfx/lib/rgb.ci:25'
.param .result: uint32 (size: 4, cast: u32)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.value: rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)))
}
rgb(r: float32, g: float32, b: float32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'cmplGfx/lib/rgb.ci:26'
.param .result: uint32 (size: 4, cast: u32)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.value: rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)))
}
gray(c: float64): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/rgb.ci:27'
.param .result: uint32 (size: 4, cast: u32)
.param c: float64 (size: 8, cast: f64)
.value: grayClamp(int32(c * (255)))
}
gray(c: float32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/rgb.ci:28'
.param .result: uint32 (size: 4, cast: u32)
.param c: float32 (size: 4, cast: f32)
.value: grayClamp(int32(c * (255)))
}
ach(col: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ach'
.file: 'cmplGfx/lib/rgb.ci:31'
.param .result: uint32 (size: 4, cast: u32)
.param col: uint32 (size: 4, cast: u32)
.value: uint32((col >> 24) & (255))
}
rch(col: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'cmplGfx/lib/rgb.ci:33'
.param .result: uint32 (size: 4, cast: u32)
.param col: uint32 (size: 4, cast: u32)
.value: uint32((col >> 16) & (255))
}
gch(col: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'cmplGfx/lib/rgb.ci:35'
.param .result: uint32 (size: 4, cast: u32)
.param col: uint32 (size: 4, cast: u32)
.value: uint32((col >> 8) & (255))
}
bch(col: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'cmplGfx/lib/rgb.ci:37'
.param .result: uint32 (size: 4, cast: u32)
.param col: uint32 (size: 4, cast: u32)
.value: uint32(col & (255))
}
lum(c: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/rgb.ci:39'
.param .result: uint32 (size: 4, cast: u32)
.param c: uint32 (size: 4, cast: variable(u32))
.value: uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8)
}
argb: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'argb'
.file: 'cmplGfx/lib/rgb.ci:41'
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.field a: uint8 (size: 1, cast: variable(u32))
}
argb.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplGfx/lib/rgb.ci:42'
.owner: argb
}
argb.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplGfx/lib/rgb.ci:43'
.owner: argb
}
argb.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplGfx/lib/rgb.ci:44'
.owner: argb
}
argb.a: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'a'
.file: 'cmplGfx/lib/rgb.ci:45'
.owner: argb
}
uint32(value: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'uint32'
.file: 'cmplGfx/lib/rgb.ci:48'
.param .result: uint32 (size: 4, cast: u32)
.param value: argb (size: 4, cast: val)
.value: uint32(emit(struct(value)))
}
argb(argb: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/rgb.ci:49'
.param .result: argb (size: 4, cast: val)
.param argb: uint32 (size: 4, cast: u32)
.value: argb(emit(uint32(argb)))
}
argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/rgb.ci:50'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.value: argb(uint32((((r << 8) | g) << 8) | b))
}
argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/rgb.ci:51'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.value: argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b))
}
rgbOr(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbOr'
.file: 'cmplGfx/lib/rgb.ci:53'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	return .result := c1 | c2;
}
.instructions: (8 bytes)
	cmplGfx/lib/rgb.ci:54: (8 bytes): return .result := c1 | c2;
	<rgbOr>  : dup.x1 sp(2)
	<rgbOr+?>: dup.x1 sp(2)
	<rgbOr+?>: or.b32
	<rgbOr+?>: set.x1 sp(4)
	<rgbOr+?>: ret
}
rgbXor(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbXor'
.file: 'cmplGfx/lib/rgb.ci:56'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	return .result := c1 ^ c2;
}
.instructions: (8 bytes)
	cmplGfx/lib/rgb.ci:57: (8 bytes): return .result := c1 ^ c2;
	<rgbXor>  : dup.x1 sp(2)
	<rgbXor+?>: dup.x1 sp(2)
	<rgbXor+?>: xor.b32
	<rgbXor+?>: set.x1 sp(4)
	<rgbXor+?>: ret
}
rgbAnd(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'rgbAnd'
.file: 'cmplGfx/lib/rgb.ci:59'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	return .result := c1 & c2;
}
.instructions: (8 bytes)
	cmplGfx/lib/rgb.ci:60: (8 bytes): return .result := c1 & c2;
	<rgbAnd>  : dup.x1 sp(2)
	<rgbAnd+?>: dup.x1 sp(2)
	<rgbAnd+?>: and.b32
	<rgbAnd+?>: set.x1 sp(4)
	<rgbAnd+?>: ret
}
rgbAdd(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 87
.name: 'rgbAdd'
.file: 'cmplGfx/lib/rgb.ci:62'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	r: uint32 := rch(c1) + rch(c2);
	g: uint32 := gch(c1) + gch(c2);
	b: uint32 := bch(c1) + bch(c2);
	return .result := rgbClamp(r, g, b);
}
.instructions: (87 bytes)
	cmplGfx/lib/rgb.ci:63: (13 bytes): r: uint32 := rch(c1) + rch(c2)
	<rgbAdd>  : dup.x1 sp(2)
	<rgbAdd+?>: b32.shr 0x010
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: dup.x1 sp(2)
	<rgbAdd+?>: b32.shr 0x010
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: add.i32
	cmplGfx/lib/rgb.ci:64: (13 bytes): g: uint32 := gch(c1) + gch(c2)
	<rgbAdd+?>: dup.x1 sp(3)
	<rgbAdd+?>: b32.shr 0x008
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: dup.x1 sp(3)
	<rgbAdd+?>: b32.shr 0x008
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: add.i32
	cmplGfx/lib/rgb.ci:65: (9 bytes): b: uint32 := bch(c1) + bch(c2)
	<rgbAdd+?>: dup.x1 sp(4)
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: dup.x1 sp(4)
	<rgbAdd+?>: b32.and 0x0ff
	<rgbAdd+?>: add.i32
	cmplGfx/lib/rgb.ci:66: (52 bytes): return .result := rgbClamp(r, g, b);
	<rgbAdd+?>: load.z32
	<rgbAdd+?>: dup.x1 sp(3)
	<rgbAdd+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbAdd+?>: call
	<rgbAdd+?>: inc.sp(-4)
	<rgbAdd+?>: b32.shl 0x008
	<rgbAdd+?>: load.z32
	<rgbAdd+?>: dup.x1 sp(3)
	<rgbAdd+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbAdd+?>: call
	<rgbAdd+?>: inc.sp(-4)
	<rgbAdd+?>: or.b32
	<rgbAdd+?>: b32.shl 0x008
	<rgbAdd+?>: load.z32
	<rgbAdd+?>: dup.x1 sp(2)
	<rgbAdd+?>: load.ref <?> ;grayClamp(c: uint32): uint32
	<rgbAdd+?>: call
	<rgbAdd+?>: inc.sp(-4)
	<rgbAdd+?>: or.b32
	<rgbAdd+?>: set.x1 sp(7)
	<rgbAdd+?>: inc.sp(-12)
	<rgbAdd+?>: ret
}
rgbAvg(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'rgbAvg'
.file: 'cmplGfx/lib/rgb.ci:68'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	r: uint32 := (rch(c1) + rch(c2)) / (2);
	g: uint32 := (gch(c1) + gch(c2)) / (2);
	b: uint32 := (bch(c1) + bch(c2)) / (2);
	return .result := rgb(r, g, b);
}
.instructions: (72 bytes)
	cmplGfx/lib/rgb.ci:69: (19 bytes): r: uint32 := (rch(c1) + rch(c2)) / (2)
	<rgbAvg>  : dup.x1 sp(2)
	<rgbAvg+?>: b32.shr 0x010
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: dup.x1 sp(2)
	<rgbAvg+?>: b32.shr 0x010
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: add.i32
	<rgbAvg+?>: load.c32 2
	<rgbAvg+?>: div.u32
	cmplGfx/lib/rgb.ci:70: (19 bytes): g: uint32 := (gch(c1) + gch(c2)) / (2)
	<rgbAvg+?>: dup.x1 sp(3)
	<rgbAvg+?>: b32.shr 0x008
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: dup.x1 sp(3)
	<rgbAvg+?>: b32.shr 0x008
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: add.i32
	<rgbAvg+?>: load.c32 2
	<rgbAvg+?>: div.u32
	cmplGfx/lib/rgb.ci:71: (15 bytes): b: uint32 := (bch(c1) + bch(c2)) / (2)
	<rgbAvg+?>: dup.x1 sp(4)
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: dup.x1 sp(4)
	<rgbAvg+?>: b32.and 0x0ff
	<rgbAvg+?>: add.i32
	<rgbAvg+?>: load.c32 2
	<rgbAvg+?>: div.u32
	cmplGfx/lib/rgb.ci:72: (19 bytes): return .result := rgb(r, g, b);
	<rgbAvg+?>: dup.x1 sp(2)
	<rgbAvg+?>: b32.shl 0x008
	<rgbAvg+?>: dup.x1 sp(2)
	<rgbAvg+?>: or.b32
	<rgbAvg+?>: b32.shl 0x008
	<rgbAvg+?>: dup.x1 sp(1)
	<rgbAvg+?>: or.b32
	<rgbAvg+?>: set.x1 sp(7)
	<rgbAvg+?>: inc.sp(-12)
	<rgbAvg+?>: ret
}
rgbSub(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 87
.name: 'rgbSub'
.file: 'cmplGfx/lib/rgb.ci:74'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	r: int32 := rch(c1) - rch(c2);
	g: int32 := gch(c1) - gch(c2);
	b: int32 := bch(c1) - bch(c2);
	return .result := rgbClamp(r, g, b);
}
.instructions: (87 bytes)
	cmplGfx/lib/rgb.ci:75: (13 bytes): r: int32 := rch(c1) - rch(c2)
	<rgbSub>  : dup.x1 sp(2)
	<rgbSub+?>: b32.shr 0x010
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: dup.x1 sp(2)
	<rgbSub+?>: b32.shr 0x010
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: sub.i32
	cmplGfx/lib/rgb.ci:76: (13 bytes): g: int32 := gch(c1) - gch(c2)
	<rgbSub+?>: dup.x1 sp(3)
	<rgbSub+?>: b32.shr 0x008
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: dup.x1 sp(3)
	<rgbSub+?>: b32.shr 0x008
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: sub.i32
	cmplGfx/lib/rgb.ci:77: (9 bytes): b: int32 := bch(c1) - bch(c2)
	<rgbSub+?>: dup.x1 sp(4)
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: dup.x1 sp(4)
	<rgbSub+?>: b32.and 0x0ff
	<rgbSub+?>: sub.i32
	cmplGfx/lib/rgb.ci:78: (52 bytes): return .result := rgbClamp(r, g, b);
	<rgbSub+?>: load.z32
	<rgbSub+?>: dup.x1 sp(3)
	<rgbSub+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<rgbSub+?>: call
	<rgbSub+?>: inc.sp(-4)
	<rgbSub+?>: b32.shl 0x008
	<rgbSub+?>: load.z32
	<rgbSub+?>: dup.x1 sp(3)
	<rgbSub+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<rgbSub+?>: call
	<rgbSub+?>: inc.sp(-4)
	<rgbSub+?>: or.b32
	<rgbSub+?>: b32.shl 0x008
	<rgbSub+?>: load.z32
	<rgbSub+?>: dup.x1 sp(2)
	<rgbSub+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<rgbSub+?>: call
	<rgbSub+?>: inc.sp(-4)
	<rgbSub+?>: or.b32
	<rgbSub+?>: set.x1 sp(7)
	<rgbSub+?>: inc.sp(-12)
	<rgbSub+?>: ret
}
rgbMul(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'rgbMul'
.file: 'cmplGfx/lib/rgb.ci:80'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	r: uint32 := (rch(c1) * (rch(c2) + (1))) >> 8;
	g: uint32 := (gch(c1) * (gch(c2) + (1))) >> 8;
	b: uint32 := (bch(c1) * (bch(c2) + (1))) >> 8;
	return .result := rgb(r, g, b);
}
.instructions: (72 bytes)
	cmplGfx/lib/rgb.ci:81: (19 bytes): r: uint32 := (rch(c1) * (rch(c2) + (1))) >> 8
	<rgbMul>  : dup.x1 sp(2)
	<rgbMul+?>: b32.shr 0x010
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: dup.x1 sp(2)
	<rgbMul+?>: b32.shr 0x010
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: inc.i32(+1)
	<rgbMul+?>: mul.u32
	<rgbMul+?>: b32.shr 0x008
	cmplGfx/lib/rgb.ci:82: (19 bytes): g: uint32 := (gch(c1) * (gch(c2) + (1))) >> 8
	<rgbMul+?>: dup.x1 sp(3)
	<rgbMul+?>: b32.shr 0x008
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: dup.x1 sp(3)
	<rgbMul+?>: b32.shr 0x008
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: inc.i32(+1)
	<rgbMul+?>: mul.u32
	<rgbMul+?>: b32.shr 0x008
	cmplGfx/lib/rgb.ci:83: (15 bytes): b: uint32 := (bch(c1) * (bch(c2) + (1))) >> 8
	<rgbMul+?>: dup.x1 sp(4)
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: dup.x1 sp(4)
	<rgbMul+?>: b32.and 0x0ff
	<rgbMul+?>: inc.i32(+1)
	<rgbMul+?>: mul.u32
	<rgbMul+?>: b32.shr 0x008
	cmplGfx/lib/rgb.ci:84: (19 bytes): return .result := rgb(r, g, b);
	<rgbMul+?>: dup.x1 sp(2)
	<rgbMul+?>: b32.shl 0x008
	<rgbMul+?>: dup.x1 sp(2)
	<rgbMul+?>: or.b32
	<rgbMul+?>: b32.shl 0x008
	<rgbMul+?>: dup.x1 sp(1)
	<rgbMul+?>: or.b32
	<rgbMul+?>: set.x1 sp(7)
	<rgbMul+?>: inc.sp(-12)
	<rgbMul+?>: ret
}
rgbDiv(c1: uint32, c2: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 72
.name: 'rgbDiv'
.file: 'cmplGfx/lib/rgb.ci:86'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.value: {
	r: uint32 := (rch(c1) << 8) / (rch(c2) + (1));
	g: uint32 := (gch(c1) << 8) / (gch(c2) + (1));
	b: uint32 := (bch(c1) << 8) / (bch(c2) + (1));
	return .result := rgb(r, g, b);
}
.instructions: (72 bytes)
	cmplGfx/lib/rgb.ci:87: (19 bytes): r: uint32 := (rch(c1) << 8) / (rch(c2) + (1))
	<rgbDiv>  : dup.x1 sp(2)
	<rgbDiv+?>: b32.shr 0x010
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: b32.shl 0x008
	<rgbDiv+?>: dup.x1 sp(2)
	<rgbDiv+?>: b32.shr 0x010
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: inc.i32(+1)
	<rgbDiv+?>: div.u32
	cmplGfx/lib/rgb.ci:88: (19 bytes): g: uint32 := (gch(c1) << 8) / (gch(c2) + (1))
	<rgbDiv+?>: dup.x1 sp(3)
	<rgbDiv+?>: b32.shr 0x008
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: b32.shl 0x008
	<rgbDiv+?>: dup.x1 sp(3)
	<rgbDiv+?>: b32.shr 0x008
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: inc.i32(+1)
	<rgbDiv+?>: div.u32
	cmplGfx/lib/rgb.ci:89: (15 bytes): b: uint32 := (bch(c1) << 8) / (bch(c2) + (1))
	<rgbDiv+?>: dup.x1 sp(4)
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: b32.shl 0x008
	<rgbDiv+?>: dup.x1 sp(4)
	<rgbDiv+?>: b32.and 0x0ff
	<rgbDiv+?>: inc.i32(+1)
	<rgbDiv+?>: div.u32
	cmplGfx/lib/rgb.ci:90: (19 bytes): return .result := rgb(r, g, b);
	<rgbDiv+?>: dup.x1 sp(2)
	<rgbDiv+?>: b32.shl 0x008
	<rgbDiv+?>: dup.x1 sp(2)
	<rgbDiv+?>: or.b32
	<rgbDiv+?>: b32.shl 0x008
	<rgbDiv+?>: dup.x1 sp(1)
	<rgbDiv+?>: or.b32
	<rgbDiv+?>: set.x1 sp(7)
	<rgbDiv+?>: inc.sp(-12)
	<rgbDiv+?>: ret
}
rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 90
.name: 'rgbLerp16'
.file: 'cmplGfx/lib/rgb.ci:93'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.param t: uint32 (size: 4, cast: variable(u32))
.value: {
	lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
	r: uint32 := lrpfix16(rch(c1), rch(c2));
	g: uint32 := lrpfix16(gch(c1), gch(c2));
	b: uint32 := lrpfix16(bch(c1), bch(c2));
	return .result := rgb(r, g, b);
}
.instructions: (90 bytes)
	cmplGfx/lib/rgb.ci:96: (25 bytes): r: uint32 := lrpfix16(rch(c1), rch(c2))
	<rgbLerp16>  : dup.x1 sp(3)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/rgb.ci:97: (25 bytes): g: uint32 := lrpfix16(gch(c1), gch(c2))
	<rgbLerp16+?>: dup.x1 sp(4)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(4)
	<rgbLerp16+?>: dup.x1 sp(6)
	<rgbLerp16+?>: b32.shr 0x008
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/rgb.ci:98: (21 bytes): b: uint32 := lrpfix16(bch(c1), bch(c2))
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(0)
	<rgbLerp16+?>: dup.x1 sp(5)
	<rgbLerp16+?>: dup.x1 sp(7)
	<rgbLerp16+?>: b32.and 0x0ff
	<rgbLerp16+?>: dup.x1 sp(3)
	<rgbLerp16+?>: sub.i32
	<rgbLerp16+?>: mul.u32
	<rgbLerp16+?>: b32.shr 0x010
	<rgbLerp16+?>: add.i32
	<rgbLerp16+?>: set.x1 sp(1)
	cmplGfx/lib/rgb.ci:99: (19 bytes): return .result := rgb(r, g, b);
	<rgbLerp16+?>: dup.x1 sp(2)
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: dup.x1 sp(2)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: b32.shl 0x008
	<rgbLerp16+?>: dup.x1 sp(1)
	<rgbLerp16+?>: or.b32
	<rgbLerp16+?>: set.x1 sp(8)
	<rgbLerp16+?>: inc.sp(-12)
	<rgbLerp16+?>: ret
}
rgbLerp(c1: uint32, c2: uint32, t: float64): uint32: function {
.kind: static const function
.base: `function`
.size: 30
.name: 'rgbLerp'
.file: 'cmplGfx/lib/rgb.ci:102'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c1: uint32 (size: 4, cast: variable(u32))
.param c2: uint32 (size: 4, cast: variable(u32))
.param t: float64 (size: 8, cast: variable(f64))
.value: {
	return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
}
.instructions: (30 bytes)
	cmplGfx/lib/rgb.ci:103: (30 bytes): return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
	<rgbLerp>  : load.z32
	<rgbLerp+?>: dup.x1 sp(5)
	<rgbLerp+?>: dup.x1 sp(5)
	<rgbLerp+?>: dup.x2 sp(4)
	<rgbLerp+?>: load.c32 1
	<rgbLerp+?>: b32.shl 0x010
	<rgbLerp+?>: i32.2f64
	<rgbLerp+?>: mul.f64
	<rgbLerp+?>: f64.2i32
	<rgbLerp+?>: load.ref <?> ;rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32
	<rgbLerp+?>: call
	<rgbLerp+?>: inc.sp(-12)
	<rgbLerp+?>: set.x1 sp(6)
	<rgbLerp+?>: ret
}
brightnessContrastGamma(lut: uint32[256], brightness: int32, contrast: int32, gamma: float64): void: function {
.kind: static const function
.base: `function`
.size: 153
.name: 'brightnessContrastGamma'
.file: 'cmplGfx/lib/color.ci:1'
.param .result: void (size: 0, cast: variable(void))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.param brightness: int32 (size: 4, cast: variable(i32))
.param contrast: int32 (size: 4, cast: variable(i32))
.param gamma: float64 (size: 8, cast: variable(f64))
.value: {
	cval: float64 := ((256 + contrast)) / 256.000000;
	gval: float64 := 1.000000 / gamma;
	for (idx: int32 := 0; idx < lut.length; idx := idx + 1) {
		val: int32 := grayClamp(brightness + int32((256) * (cval * (float64.pow((idx) / 256.000000, gval) - 0.500000) + 0.500000)));
		lut[idx] := rgb(val, val, val);
	}
}
.instructions: (153 bytes)
	cmplGfx/lib/color.ci:2: (19 bytes): cval: float64 := ((256 + contrast)) / 256.000000
	<brightnessContrastGamma>  : load.c32 256
	<brightnessContrastGamma+?>: dup.x1 sp(4)
	<brightnessContrastGamma+?>: add.i32
	<brightnessContrastGamma+?>: i32.2f64
	<brightnessContrastGamma+?>: load.f64 256.000000
	<brightnessContrastGamma+?>: div.f64
	cmplGfx/lib/color.ci:3: (12 bytes): gval: float64 := 1.000000 / gamma
	<brightnessContrastGamma+?>: load.f64 1.000000
	<brightnessContrastGamma+?>: dup.x2 sp(5)
	<brightnessContrastGamma+?>: div.f64
	cmplGfx/lib/color.ci:5: (117 bytes): for (idx: int32 := 0; idx < lut.length; idx := idx + 1)
	<brightnessContrastGamma+?>: load.z32
	<brightnessContrastGamma+?>: jmp +100
	cmplGfx/lib/color.ci:6: (67 bytes): val: int32 := grayClamp(brightness + int32((256) * (cval * (float64.pow((idx) / 256.000000, gval) - 0.500000) + 0.500000)))
	<brightnessContrastGamma+?>: load.z32
	<brightnessContrastGamma+?>: dup.x1 sp(10)
	<brightnessContrastGamma+?>: load.f64 256.000000
	<brightnessContrastGamma+?>: dup.x2 sp(7)
	<brightnessContrastGamma+?>: dup.x1 sp(6)
	<brightnessContrastGamma+?>: i32.2f64
	<brightnessContrastGamma+?>: load.f64 256.000000
	<brightnessContrastGamma+?>: div.f64
	<brightnessContrastGamma+?>: dup.x2 sp(9)
	<brightnessContrastGamma+?>: nfc(41) ;float64.pow(x: float64, y: float64): float64
	<brightnessContrastGamma+?>: load.f64 0.500000
	<brightnessContrastGamma+?>: sub.f64
	<brightnessContrastGamma+?>: mul.f64
	<brightnessContrastGamma+?>: load.f64 0.500000
	<brightnessContrastGamma+?>: add.f64
	<brightnessContrastGamma+?>: mul.f64
	<brightnessContrastGamma+?>: f64.2i32
	<brightnessContrastGamma+?>: add.i32
	<brightnessContrastGamma+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<brightnessContrastGamma+?>: call
	<brightnessContrastGamma+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:7: (21 bytes): lut[idx] := rgb(val, val, val);
	<brightnessContrastGamma+?>: dup.x1 sp(0)
	<brightnessContrastGamma+?>: b32.shl 0x008
	<brightnessContrastGamma+?>: dup.x1 sp(1)
	<brightnessContrastGamma+?>: or.b32
	<brightnessContrastGamma+?>: b32.shl 0x008
	<brightnessContrastGamma+?>: dup.x1 sp(1)
	<brightnessContrastGamma+?>: or.b32
	<brightnessContrastGamma+?>: dup.x1 sp(12)
	<brightnessContrastGamma+?>: dup.x1 sp(3)
	<brightnessContrastGamma+?>: mad.u32 4
	<brightnessContrastGamma+?>: store.i32
	<brightnessContrastGamma+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:5: (4 bytes): idx := idx + 1
	<brightnessContrastGamma+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:5: (12 bytes): idx < lut.length
	<brightnessContrastGamma+?>: dup.x1 sp(0)
	<brightnessContrastGamma+?>: load.c32 256
	<brightnessContrastGamma+?>: clt.i32
	<brightnessContrastGamma+?>: jnz -104
	<brightnessContrastGamma+?>: inc.sp(-4)
	<brightnessContrastGamma+?>: inc.sp(-16)
	<brightnessContrastGamma+?>: ret
}
colorMatrix(luminosity: float32, saturation: float32, hue: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 341
.name: 'colorMatrix'
.file: 'cmplGfx/lib/color.ci:11'
.param .result: mat4f (size: 64, cast: variable(val))
.param luminosity: float32 (size: 4, cast: variable(f32))
.param saturation: float32 (size: 4, cast: variable(f32))
.param hue: float32 (size: 4, cast: variable(f32))
.value: {
	static const lumMatrix(val: float32): mat4f := {
		return .result := {
			.result.x := vec4f(1.000000, 0.000000, 0.000000, val);
			.result.y := vec4f(0.000000, 1.000000, 0.000000, val);
			.result.z := vec4f(0.000000, 0.000000, 1.000000, val);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
	};
	static const satMatrix(val: float32): mat4f := {
		const inv: float32 := (1) - val;
		const R: float32 := 0.213000 * inv;
		const G: float32 := 0.715000 * inv;
		const B: float32 := 0.072000 * inv;
		return .result := {
			.result.x := vec4f(R + val, G, B, 0.000000);
			.result.y := vec4f(R, G + val, B, 0.000000);
			.result.z := vec4f(R, G, B + val, 0.000000);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
	};
	static const hueMatrix(val: float32): mat4f := {
		lR: typename := 0.213000;
		lG: typename := 0.715000;
		lB: typename := 0.072000;
		cV: float32 := val.cos(val);
		sV: float32 := val.sin(val);
		return .result := {
			.result.x := vec4f(lR + (cV) * ((1) - lR) + (sV) * (-lR), lG + (cV) * (-lG) + (sV) * (-lG), lB + (cV) * (-lB) + (sV) * ((1) - lB), 0.000000);
			.result.y := vec4f(lR + (cV) * ((0) - lR) + (sV) * (0.143000), lG + (cV) * ((1) - lG) + (sV) * (0.140000), lB + (cV) * (-lB) + (sV) * (-0.283000), 0.000000);
			.result.z := vec4f(lR + (cV) * ((0) - lR) + (sV) * (lR - (1)), lG + (cV) * (-lG) + (sV) * (lG), lB + (cV) * ((1) - lB) + (sV) * (lB), 0.000000);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
	};
	result: mat4f := mat4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	result := mul(result, lumMatrix(luminosity));
	result := mul(result, satMatrix(saturation));
	result := mul(result, hueMatrix(hue));
	return .result := result;
}
.instructions: (341 bytes)
	cmplGfx/lib/color.ci:52: (46 bytes): result: mat4f := mat4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
	<colorMatrix>  : inc.sp(+64)
	<colorMatrix+?>: load.f32 1.000000
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.f32 1.000000
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.f32 1.000000
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.z32
	<colorMatrix+?>: load.f32 1.000000
	<colorMatrix+?>: load.ref <?> ;mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: inc.sp(-64)
	cmplGfx/lib/color.ci:59: (86 bytes): result := mul(result, lumMatrix(luminosity));
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: dup.x1 sp(35)
	<colorMatrix+?>: load.ref <?> ;colorMatrix.lumMatrix(val: float32): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: inc.sp(-4)
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+128)
	<colorMatrix+?>: load.sp(+68)
	<colorMatrix+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: load.sp(+8)
	<colorMatrix+?>: load.sp(-60)
	<colorMatrix+?>: copy.mem -64
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+136)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	<colorMatrix+?>: inc.sp(-72)
	<colorMatrix+?>: load.sp(+64)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	cmplGfx/lib/color.ci:60: (86 bytes): result := mul(result, satMatrix(saturation));
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: dup.x1 sp(34)
	<colorMatrix+?>: load.ref <?> ;colorMatrix.satMatrix(val: float32): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: inc.sp(-4)
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+128)
	<colorMatrix+?>: load.sp(+68)
	<colorMatrix+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: load.sp(+8)
	<colorMatrix+?>: load.sp(-60)
	<colorMatrix+?>: copy.mem -64
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+136)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	<colorMatrix+?>: inc.sp(-72)
	<colorMatrix+?>: load.sp(+64)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	cmplGfx/lib/color.ci:61: (86 bytes): result := mul(result, hueMatrix(hue));
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: dup.x1 sp(33)
	<colorMatrix+?>: load.ref <?> ;colorMatrix.hueMatrix(val: float32): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: inc.sp(-4)
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+128)
	<colorMatrix+?>: load.sp(+68)
	<colorMatrix+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<colorMatrix+?>: call
	<colorMatrix+?>: load.sp(+8)
	<colorMatrix+?>: load.sp(-60)
	<colorMatrix+?>: copy.mem -64
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+136)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	<colorMatrix+?>: inc.sp(-72)
	<colorMatrix+?>: load.sp(+64)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	cmplGfx/lib/color.ci:62: (37 bytes): return .result := result;
	<colorMatrix+?>: load.sp(+0)
	<colorMatrix+?>: load.sp(-60)
	<colorMatrix+?>: copy.mem -64
	<colorMatrix+?>: inc.sp(+64)
	<colorMatrix+?>: load.sp(+144)
	<colorMatrix+?>: load.sp(+4)
	<colorMatrix+?>: copy.mem 64
	<colorMatrix+?>: inc.sp(-64)
	<colorMatrix+?>: inc.sp(-64)
	<colorMatrix+?>: ret
}
drawHist(image: gxSurf, roi: gxRect, hist: uint32): void: function {
.kind: static const function
.base: `function`
.size: 342
.name: 'drawHist'
.file: 'cmplGfx/lib/color.ci:65'
.param .result: void (size: 0, cast: variable(void))
.param image: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.param hist: uint32 (size: 4, cast: variable(u32))
.value: {
	lut: uint32[256];
	image.calcHist(image, roi, hist, lut);
	rect: gxRect := {
		rect.w := 256;
		rect.h := 128;
		rect.y := margin;
		rect.x := image.width(image) - rect.w - margin;
	};
	image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	for (x: int32 := 0; x < rect.w; x := x + 1) {
		bv: int32 := bch(lut[x]) * (rect.h) / (256);
		gv: int32 := gch(lut[x]) * (rect.h) / (256);
		rv: int32 := rch(lut[x]) * (rect.h) / (256);
		lv: int32 := ach(lut[x]) * (rect.h) / (256);
		for (y: int32 := 0; y < rect.h; y := y + 1) {
			b: uint32 := colB * (uint32(y < bv));
			g: uint32 := colG * (uint32(y < gv));
			r: uint32 := colR * (uint32(y < rv));
			l: uint32 := colL * (uint32(y < lv));
			image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
		}
	}
}
.instructions: (342 bytes)
	cmplGfx/lib/color.ci:66: (4 bytes): lut: uint32[256]
	<drawHist>  : inc.sp(+1024)
	cmplGfx/lib/color.ci:67: (23 bytes): image.calcHist(image, roi, hist, lut);
	<drawHist+?>: load.sp(+1036)
	<drawHist+?>: load.i64
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+1040)
	<drawHist+?>: load.i32
	<drawHist+?>: load.sp(+16)
	<drawHist+?>: nfc(99) ;gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void
	cmplGfx/lib/color.ci:78: (43 bytes): rect: gxRect := {...}
	<drawHist+?>: inc.sp(+16)
	cmplGfx/lib/color.ci:79: (7 bytes): rect.w := 256;
	<drawHist+?>: load.c32 256
	<drawHist+?>: set.x1 sp(3)
	cmplGfx/lib/color.ci:80: (7 bytes): rect.h := 128;
	<drawHist+?>: load.c32 128
	<drawHist+?>: set.x1 sp(4)
	cmplGfx/lib/color.ci:81: (7 bytes): rect.y := margin;
	<drawHist+?>: load.c32 20
	<drawHist+?>: set.x1 sp(2)
	cmplGfx/lib/color.ci:82: (18 bytes): rect.x := image.width(image) - rect.w - margin;
	<drawHist+?>: load.sp(+1052)
	<drawHist+?>: load.i64
	<drawHist+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: sub.i32
	<drawHist+?>: inc.i32(-20)
	<drawHist+?>: set.x1 sp(1)
	cmplGfx/lib/color.ci:85: (40 bytes): image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
	<drawHist+?>: load.sp(+1052)
	<drawHist+?>: load.i64
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: inc.i32(-7)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: inc.i32(-7)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(+7)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: dup.x1 sp(9)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(+7)
	<drawHist+?>: load.z32
	<drawHist+?>: nfc(87) ;gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
	cmplGfx/lib/color.ci:93: (227 bytes): for (x: int32 := 0; x < rect.w; x := x + 1)
	<drawHist+?>: load.z32
	<drawHist+?>: jmp +213
	cmplGfx/lib/color.ci:94: (22 bytes): bv: int32 := bch(lut[x]) * (rect.h) / (256)
	<drawHist+?>: load.sp(+20)
	<drawHist+?>: dup.x1 sp(1)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:95: (24 bytes): gv: int32 := gch(lut[x]) * (rect.h) / (256)
	<drawHist+?>: load.sp(+24)
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x008
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:96: (24 bytes): rv: int32 := rch(lut[x]) * (rect.h) / (256)
	<drawHist+?>: load.sp(+28)
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x010
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:97: (24 bytes): lv: int32 := ach(lut[x]) * (rect.h) / (256)
	<drawHist+?>: load.sp(+32)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: mad.u32 4
	<drawHist+?>: load.i32
	<drawHist+?>: b32.shr 0x018
	<drawHist+?>: b32.and 0x0ff
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: mul.u32
	<drawHist+?>: load.c32 256
	<drawHist+?>: div.u32
	cmplGfx/lib/color.ci:99: (107 bytes): for (y: int32 := 0; y < rect.h; y := y + 1)
	<drawHist+?>: load.z32
	<drawHist+?>: jmp +93
	cmplGfx/lib/color.ci:100: (11 bytes): b: uint32 := colB * (uint32(y < bv))
	<drawHist+?>: load.c32 4420038
	<drawHist+?>: dup.x1 sp(1)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:101: (11 bytes): g: uint32 := colG * (uint32(y < gv))
	<drawHist+?>: load.c32 7526516
	<drawHist+?>: dup.x1 sp(2)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:102: (11 bytes): r: uint32 := colR * (uint32(y < rv))
	<drawHist+?>: load.c32 16540005
	<drawHist+?>: dup.x1 sp(3)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:103: (11 bytes): l: uint32 := colL * (uint32(y < lv))
	<drawHist+?>: load.c32 14342874
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: dup.x1 sp(6)
	<drawHist+?>: clt.i32
	<drawHist+?>: mul.i32
	cmplGfx/lib/color.ci:104: (37 bytes): image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
	<drawHist+?>: load.sp(+1092)
	<drawHist+?>: load.i64
	<drawHist+?>: dup.x1 sp(11)
	<drawHist+?>: dup.x1 sp(13)
	<drawHist+?>: add.i32
	<drawHist+?>: dup.x1 sp(16)
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: sub.i32
	<drawHist+?>: dup.x1 sp(15)
	<drawHist+?>: add.i32
	<drawHist+?>: inc.i32(-1)
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: dup.x1 sp(7)
	<drawHist+?>: or.b32
	<drawHist+?>: dup.x1 sp(8)
	<drawHist+?>: or.b32
	<drawHist+?>: dup.x1 sp(5)
	<drawHist+?>: or.b32
	<drawHist+?>: nfc(85) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	<drawHist+?>: inc.sp(-16)
	cmplGfx/lib/color.ci:99: (4 bytes): y := y + 1
	<drawHist+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:99: (9 bytes): y < rect.h
	<drawHist+?>: dup.x1 sp(0)
	<drawHist+?>: dup.x1 sp(10)
	<drawHist+?>: clt.i32
	<drawHist+?>: jnz -94
	<drawHist+?>: inc.sp(-4)
	<drawHist+?>: inc.sp(-16)
	cmplGfx/lib/color.ci:93: (4 bytes): x := x + 1
	<drawHist+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:93: (9 bytes): x < rect.w
	<drawHist+?>: dup.x1 sp(0)
	<drawHist+?>: dup.x1 sp(4)
	<drawHist+?>: clt.i32
	<drawHist+?>: jnz -214
	<drawHist+?>: inc.sp(-4)
	<drawHist+?>: inc.sp(-1040)
	<drawHist+?>: ret
}
rgb(vec: vec4f): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb'
.file: 'cmplGfx/gfxlib.ci:5'
.param .result: uint32 (size: 4, cast: u32)
.param vec: vec4f (size: 4, cast: const variable(ref))
.value: rgb(vec.x, vec.y, vec.z)
}
hsv2rgb(hsv: vec4f): vec4f: function {
.kind: static const function
.base: `function`
.size: 344
.name: 'hsv2rgb'
.file: 'cmplGfx/gfxlib.ci:6'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsv: vec4f (size: 16, cast: variable(val))
.value: {
	h: float32 := hsv.x;
	s: float32 := hsv.y;
	v: float32 := hsv.z;
	if (s == (0)) {
		return .result := vec4f(v);
	}
	h := h * (360 / 60);
	i: int32 := int32(h);
	f: float32 := h - (i);
	u: float32 := v;
	p: float32 := v * ((1) - s);
	q: float32 := v * ((1) - s * f);
	t: float32 := v * ((1) - s * ((1) - f));
	if (i == 0) {
		return .result := vec4f(u, t, p);
	}
	if (i == 1) {
		return .result := vec4f(q, u, p);
	}
	if (i == 2) {
		return .result := vec4f(p, u, t);
	}
	if (i == 3) {
		return .result := vec4f(p, q, u);
	}
	if (i == 4) {
		return .result := vec4f(t, p, u);
	}
	return .result := vec4f(u, p, q);
}
.instructions: (344 bytes)
	cmplGfx/gfxlib.ci:7: (2 bytes): h: float32 := hsv.x
	<hsv2rgb>  : dup.x1 sp(1)
	cmplGfx/gfxlib.ci:8: (2 bytes): s: float32 := hsv.y
	<hsv2rgb+?>: dup.x1 sp(3)
	cmplGfx/gfxlib.ci:9: (2 bytes): v: float32 := hsv.z
	<hsv2rgb+?>: dup.x1 sp(5)
	cmplGfx/gfxlib.ci:11: (41 bytes): if (s == (0))
	<hsv2rgb+?>: dup.x1 sp(1)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.f32
	<hsv2rgb+?>: jz +37
	cmplGfx/gfxlib.ci:12: (33 bytes): return .result := vec4f(v);
	<hsv2rgb+?>: dup.x1 sp(0)
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(1)
	<hsv2rgb+?>: set.x4 sp(12)
	<hsv2rgb+?>: inc.sp(-12)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:15: (17 bytes): h := h * (360 / 60);
	<hsv2rgb+?>: dup.x1 sp(2)
	<hsv2rgb+?>: load.c32 360
	<hsv2rgb+?>: load.c32 60
	<hsv2rgb+?>: div.i32
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: set.x1 sp(3)
	cmplGfx/gfxlib.ci:17: (3 bytes): i: int32 := int32(h)
	<hsv2rgb+?>: dup.x1 sp(2)
	<hsv2rgb+?>: f32.2i32
	cmplGfx/gfxlib.ci:18: (6 bytes): f: float32 := h - (i)
	<hsv2rgb+?>: dup.x1 sp(3)
	<hsv2rgb+?>: dup.x1 sp(1)
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: sub.f32
	cmplGfx/gfxlib.ci:20: (2 bytes): u: float32 := v
	<hsv2rgb+?>: dup.x1 sp(2)
	cmplGfx/gfxlib.ci:21: (11 bytes): p: float32 := v * ((1) - s)
	<hsv2rgb+?>: dup.x1 sp(3)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/gfxlib.ci:22: (14 bytes): q: float32 := v * ((1) - s * f)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/gfxlib.ci:23: (20 bytes): t: float32 := v * ((1) - s * ((1) - f))
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/gfxlib.ci:25: (36 bytes): if (i == 0)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/gfxlib.ci:26: (28 bytes): return .result := vec4f(u, t, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:28: (40 bytes): if (i == 1)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 1
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/gfxlib.ci:29: (28 bytes): return .result := vec4f(q, u, p);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:31: (40 bytes): if (i == 2)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 2
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/gfxlib.ci:32: (28 bytes): return .result := vec4f(p, u, t);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(8)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:34: (40 bytes): if (i == 3)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 3
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/gfxlib.ci:35: (28 bytes): return .result := vec4f(p, q, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(6)
	<hsv2rgb+?>: dup.x1 sp(9)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:37: (40 bytes): if (i == 4)
	<hsv2rgb+?>: dup.x1 sp(5)
	<hsv2rgb+?>: load.c32 4
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +32
	cmplGfx/gfxlib.ci:38: (28 bytes): return .result := vec4f(t, p, u);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(4)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(9)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/gfxlib.ci:40: (28 bytes): return .result := vec4f(u, p, q);
	<hsv2rgb+?>: inc.sp(+16)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: dup.x1 sp(7)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: load.ref <?> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<hsv2rgb+?>: call
	<hsv2rgb+?>: inc.sp(-16)
	<hsv2rgb+?>: set.x4 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
}
gxSurf(width: int32, height: int32, depth: int32): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:44'
.param .result: gxSurf (size: 8, cast: val)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.value: gxSurf.create(width, height, depth)
}
gxSurf(fileName: char[*], depth: int32): gxSurf: function {
.kind: static const function
.base: `function`
.size: 189
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:46'
.param .result: gxSurf (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: {
	if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".jpg", ignCaseCmp)) {
		return .result := gxSurf.openJpg(fileName, depth);
	}
	if (endsWith(fileName, ".png", ignCaseCmp)) {
		return .result := gxSurf.openPng(fileName, depth);
	}
	if (endsWith(fileName, ".bmp", ignCaseCmp)) {
		return .result := gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}
.instructions: (189 bytes)
	cmplGfx/gfxlib.ci:47: (38 bytes): if (endsWith(fileName, ".jpeg", ignCaseCmp))
	<gxSurf>  : load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpeg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:48: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(78) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:50: (38 bytes): if (endsWith(fileName, ".jpg", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".jpg"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:51: (11 bytes): return .result := gxSurf.openJpg(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(78) ;gxSurf.openJpg(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:53: (38 bytes): if (endsWith(fileName, ".png", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".png"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:54: (11 bytes): return .result := gxSurf.openPng(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(77) ;gxSurf.openPng(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:56: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x1 sp(3)
	<gxSurf+?>: load.ref <?> ;".bmp"
	<gxSurf+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxSurf+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxSurf+?>: call
	<gxSurf+?>: inc.sp(-12)
	<gxSurf+?>: jz +15
	cmplGfx/gfxlib.ci:57: (11 bytes): return .result := gxSurf.openBmp(fileName, depth);
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: dup.x1 sp(2)
	<gxSurf+?>: nfc(76) ;gxSurf.openBmp(path: char[*], depth: int32): gxSurf
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
	cmplGfx/gfxlib.ci:59: (36 bytes): abort("unknown file extension", fileName);
	<gxSurf+?>: load.ref <?> ;"cmplGfx/gfxlib.ci"
	<gxSurf+?>: load.c32 59
	<gxSurf+?>: load.c32 -2
	<gxSurf+?>: load.c32 128
	<gxSurf+?>: load.ref <?> ;"unknown file extension"
	<gxSurf+?>: load.ref <?>
	<gxSurf+?>: dup.x1 sp(8)
	<gxSurf+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxSurf+?>: ret
}
gxSurf(fileName: char[*]): gxSurf: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:62'
.param .result: gxSurf (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: ref)
.value: gxSurf(fileName, 32)
}
gxMesh(fileName: char[*]): gxMesh: function {
.kind: static const function
.base: `function`
.size: 109
.name: 'gxMesh'
.file: 'cmplGfx/gfxlib.ci:64'
.param .result: gxMesh (size: 4, cast: variable(ref))
.param fileName: char[*] (size: 4, cast: variable(ref))
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := gxMesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (109 bytes)
	cmplGfx/gfxlib.ci:65: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<gxMesh>  : load.z32
	<gxMesh+?>: dup.x1 sp(2)
	<gxMesh+?>: load.ref <?> ;".obj"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	cmplGfx/gfxlib.ci:66: (9 bytes): return .result := gxMesh.openObj(fileName);
	<gxMesh+?>: dup.x1 sp(1)
	<gxMesh+?>: nfc(62) ;gxMesh.openObj(path: char[*]): gxMesh
	<gxMesh+?>: set.x1 sp(3)
	<gxMesh+?>: ret
	cmplGfx/gfxlib.ci:68: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<gxMesh+?>: load.z32
	<gxMesh+?>: dup.x1 sp(2)
	<gxMesh+?>: load.ref <?> ;".3ds"
	<gxMesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<gxMesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<gxMesh+?>: call
	<gxMesh+?>: inc.sp(-12)
	<gxMesh+?>: jz +13
	cmplGfx/gfxlib.ci:69: (9 bytes): return .result := gxMesh.open3ds(fileName);
	<gxMesh+?>: dup.x1 sp(1)
	<gxMesh+?>: nfc(63) ;gxMesh.open3ds(path: char[*]): gxMesh
	<gxMesh+?>: set.x1 sp(3)
	<gxMesh+?>: ret
	cmplGfx/gfxlib.ci:71: (36 bytes): abort("unknown file extension", fileName);
	<gxMesh+?>: load.ref <?> ;"cmplGfx/gfxlib.ci"
	<gxMesh+?>: load.c32 71
	<gxMesh+?>: load.c32 -2
	<gxMesh+?>: load.c32 128
	<gxMesh+?>: load.ref <?> ;"unknown file extension"
	<gxMesh+?>: load.ref <?>
	<gxMesh+?>: dup.x1 sp(7)
	<gxMesh+?>: nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<gxMesh+?>: ret
}
gxSurf(copy: gxSurf): gxSurf: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'gxSurf'
.file: 'cmplGfx/gfxlib.ci:74'
.param .result: gxSurf (size: 8, cast: variable(val))
.param copy: gxSurf (size: 8, cast: variable(val))
.value: {
	result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
	result.copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (40 bytes)
	cmplGfx/gfxlib.ci:75: (22 bytes): result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy))
	<gxSurf>  : dup.x2 sp(1)
	<gxSurf+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<gxSurf+?>: dup.x2 sp(2)
	<gxSurf+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<gxSurf+?>: dup.x2 sp(3)
	<gxSurf+?>: nfc(83) ;gxSurf.depth(surf: gxSurf): int32
	<gxSurf+?>: nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	cmplGfx/gfxlib.ci:76: (15 bytes): result.copy(result, 0, 0, copy, null);
	<gxSurf+?>: dup.x2 sp(0)
	<gxSurf+?>: load.z32
	<gxSurf+?>: load.z32
	<gxSurf+?>: dup.x2 sp(7)
	<gxSurf+?>: load.ref <?> ;null
	<gxSurf+?>: nfc(95) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	cmplGfx/gfxlib.ci:77: (3 bytes): return .result := result;
	<gxSurf+?>: set.x2 sp(5)
	<gxSurf+?>: ret
}
fill(dst: gxSurf, col: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'cmplGfx/gfxlib.ci:85'
.param .result: void (size: 0, cast: void)
.param dst: gxSurf (size: 8, cast: variable(val))
.param col: uint32 (size: 4, cast: u32)
.value: dst.fillRect(dst, 0, 0, dst.width(dst), dst.height(dst), col)
}
clip(src: gxSurf, roi: gxRect): bool: function {
.kind: static const function
.base: `function`
.size: 235
.name: 'clip'
.file: 'cmplGfx/gfxlib.ci:87'
.param .result: bool (size: 4, cast: variable(bool))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.value: {
	roi.w := roi.w + roi.x;
	roi.h := roi.h + roi.y;
	if (roi.x < 0) {
		roi.x := 0;
	}
	if (roi.y < 0) {
		roi.y := 0;
	}
	width: int32 := src.width(src);
	if (roi.w > width) {
		roi.w := width;
	}
	height: int32 := src.height(src);
	if (roi.h > height) {
		roi.h := height;
	}
	roi.w := roi.w - roi.x;
	roi.h := roi.h - roi.y;
	if (roi.w <= 0) {
		return .result := false;
	}
	if (roi.h <= 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (235 bytes)
	cmplGfx/gfxlib.ci:89: (18 bytes): roi.w := roi.w + roi.x;
	<clip>  : dup.x1 sp(1)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:90: (22 bytes): roi.h := roi.h + roi.y;
	<clip+?>: dup.x1 sp(1)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:92: (13 bytes): if (roi.x < 0)
	<clip+?>: dup.x1 sp(1)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +8
	cmplGfx/gfxlib.ci:93: (4 bytes): roi.x := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:96: (21 bytes): if (roi.y < 0)
	<clip+?>: dup.x1 sp(1)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +12
	cmplGfx/gfxlib.ci:97: (8 bytes): roi.y := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:100: (6 bytes): width: int32 := src.width(src)
	<clip+?>: dup.x2 sp(2)
	<clip+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:101: (23 bytes): if (roi.w > width)
	<clip+?>: dup.x1 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/gfxlib.ci:102: (9 bytes): roi.w := width;
	<clip+?>: dup.x1 sp(0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:105: (6 bytes): height: int32 := src.height(src)
	<clip+?>: dup.x2 sp(3)
	<clip+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:106: (23 bytes): if (roi.h > height)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/gfxlib.ci:107: (9 bytes): roi.h := height;
	<clip+?>: dup.x1 sp(0)
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:110: (18 bytes): roi.w := roi.w - roi.x;
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:111: (22 bytes): roi.h := roi.h - roi.y;
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x1 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/gfxlib.ci:113: (24 bytes): if (roi.w <= 0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/gfxlib.ci:114: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/gfxlib.ci:116: (24 bytes): if (roi.h <= 0)
	<clip+?>: dup.x1 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/gfxlib.ci:117: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/gfxlib.ci:119: (15 bytes): return .result := true;
	<clip+?>: load.c32 1
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
}
eval(out: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 353
.name: 'eval'
.file: 'cmplGfx/gfxlib.ci:121'
.param .result: void (size: 0, cast: variable(void))
.param out: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.param aspect: float32 (size: 4, cast: variable(f32))
.param time: float32 (size: 4, cast: variable(f32))
.param eval: function (size: 4, cast: variable(ref))
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : out.width(out);
		rect.h := (roi) != null ? roi.h : out.height(out);
	};
	if (!clip(out, rect)) {
		return;
	}
	in: vec4f := {
		in.x := (0);
		in.y := (0);
		in.z := aspect;
		in.w := time;
	};
	w: float32 := out.width(out);
	h: float32 := out.height(out);
	for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
			in.x := (x) / w;
			out.set(out, x, y, rgb(eval(in)));
		}
	}
}
.instructions: (353 bytes)
	cmplGfx/gfxlib.ci:122: (114 bytes): rect: gxRect := {...}
	<eval>  : inc.sp(+16)
	cmplGfx/gfxlib.ci:123: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +11
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:124: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:125: (31 bytes): rect.w := (roi) != null ? roi.w : out.width(out);
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x2 sp(9)
	<eval+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: set.x1 sp(3)
	cmplGfx/gfxlib.ci:126: (31 bytes): rect.h := (roi) != null ? roi.h : out.height(out);
	<eval+?>: dup.x1 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x1 sp(8)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x2 sp(9)
	<eval+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: set.x1 sp(4)
	cmplGfx/gfxlib.ci:129: (26 bytes): if (!clip(out, rect))
	<eval+?>: load.z32
	<eval+?>: dup.x2 sp(10)
	<eval+?>: load.sp(+12)
	<eval+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<eval+?>: call
	<eval+?>: inc.sp(-12)
	<eval+?>: jnz +9
	cmplGfx/gfxlib.ci:130: (5 bytes): return;
	<eval+?>: inc.sp(-16)
	<eval+?>: ret
	cmplGfx/gfxlib.ci:133: (16 bytes): in: vec4f := {...}
	<eval+?>: inc.sp(+16)
	cmplGfx/gfxlib.ci:134: (3 bytes): in.x := (0);
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:135: (3 bytes): in.y := (0);
	<eval+?>: load.z32
	<eval+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:136: (3 bytes): in.z := aspect;
	<eval+?>: mov.x1 sp(2, 11)
	cmplGfx/gfxlib.ci:137: (3 bytes): in.w := time;
	<eval+?>: mov.x1 sp(3, 10)
	cmplGfx/gfxlib.ci:139: (7 bytes): w: float32 := out.width(out)
	<eval+?>: dup.x2 sp(13)
	<eval+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<eval+?>: i32.2f32
	cmplGfx/gfxlib.ci:140: (7 bytes): h: float32 := out.height(out)
	<eval+?>: dup.x2 sp(14)
	<eval+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<eval+?>: i32.2f32
	cmplGfx/gfxlib.ci:141: (178 bytes): for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1)
	<eval+?>: dup.x1 sp(7)
	<eval+?>: jmp +160
	cmplGfx/gfxlib.ci:142: (8 bytes): in.y := (y) / h;
	<eval+?>: dup.x1 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: div.f32
	<eval+?>: set.x1 sp(5)
	cmplGfx/gfxlib.ci:143: (144 bytes): for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1)
	<eval+?>: dup.x1 sp(7)
	<eval+?>: jmp +126
	cmplGfx/gfxlib.ci:144: (8 bytes): in.x := (x) / w;
	<eval+?>: dup.x1 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x1 sp(4)
	<eval+?>: div.f32
	<eval+?>: set.x1 sp(5)
	cmplGfx/gfxlib.ci:145: (110 bytes): out.set(out, x, y, rgb(eval(in)));
	<eval+?>: dup.x2 sp(17)
	<eval+?>: dup.x1 sp(2)
	<eval+?>: dup.x1 sp(4)
	<eval+?>: inc.sp(+16)
	<eval+?>: dup.x4 sp(12)
	<eval+?>: dup.x1 sp(25)
	<eval+?>: call
	<eval+?>: inc.sp(-16)
	<eval+?>: load.sp(+0)
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(1)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x008
	<eval+?>: load.z32
	<eval+?>: dup.x1 sp(2)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;grayClamp(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: set.x1 sp(5)
	<eval+?>: inc.sp(-16)
	<eval+?>: nfc(85) ;gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
	cmplGfx/gfxlib.ci:143: (4 bytes): x := x + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/gfxlib.ci:143: (12 bytes): x < rect.x + rect.w
	<eval+?>: dup.x1 sp(0)
	<eval+?>: dup.x1 sp(9)
	<eval+?>: dup.x1 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -130
	<eval+?>: inc.sp(-4)
	cmplGfx/gfxlib.ci:141: (4 bytes): y := y + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/gfxlib.ci:141: (12 bytes): y < rect.y + rect.h
	<eval+?>: dup.x1 sp(0)
	<eval+?>: dup.x1 sp(9)
	<eval+?>: dup.x1 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -164
	<eval+?>: inc.sp(-4)
	<eval+?>: inc.sp(-40)
	<eval+?>: ret
}
tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void: function {
.kind: static const function
.base: `function`
.size: 251
.name: 'tile'
.file: 'cmplGfx/gfxlib.ci:150'
.param .result: void (size: 0, cast: variable(void))
.param dst: gxSurf (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: gxSurf (size: 8, cast: variable(val))
.param roi: gxRect (size: 4, cast: variable(ref))
.value: {
	rect: gxRect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : src.width(src);
		rect.h := (roi) != null ? roi.h : src.height(src);
	};
	if (!clip(src, rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % rect.w);
	}
	if (y < 0) {
		y := -(-y % rect.h);
	}
	width: int32 := dst.width(dst);
	height: int32 := dst.height(dst);
	for (j: int32 := y; j < height; j := j + rect.h) {
		for (i: int32 := x; i < width; i := i + rect.w) {
			dst.copy(dst, i, j, src, rect);
		}
	}
}
.instructions: (251 bytes)
	cmplGfx/gfxlib.ci:151: (114 bytes): rect: gxRect := {...}
	<tile>  : inc.sp(+16)
	cmplGfx/gfxlib.ci:152: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +11
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:153: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x1 sp(2)
	cmplGfx/gfxlib.ci:154: (31 bytes): rect.w := (roi) != null ? roi.w : src.width(src);
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x2 sp(6)
	<tile+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	<tile+?>: set.x1 sp(3)
	cmplGfx/gfxlib.ci:155: (31 bytes): rect.h := (roi) != null ? roi.h : src.height(src);
	<tile+?>: dup.x1 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x1 sp(5)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x2 sp(6)
	<tile+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	<tile+?>: set.x1 sp(4)
	cmplGfx/gfxlib.ci:158: (26 bytes): if (!clip(src, rect))
	<tile+?>: load.z32
	<tile+?>: dup.x2 sp(7)
	<tile+?>: load.sp(+12)
	<tile+?>: load.ref <?> ;clip(src: gxSurf, roi: gxRect): bool
	<tile+?>: call
	<tile+?>: inc.sp(-12)
	<tile+?>: jnz +9
	cmplGfx/gfxlib.ci:159: (5 bytes): return;
	<tile+?>: inc.sp(-16)
	<tile+?>: ret
	cmplGfx/gfxlib.ci:162: (17 bytes): if (x < 0)
	<tile+?>: dup.x1 sp(9)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/gfxlib.ci:163: (9 bytes): x := -(-x % rect.w);
	<tile+?>: dup.x1 sp(9)
	<tile+?>: neg.i32
	<tile+?>: dup.x1 sp(3)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x1 sp(10)
	cmplGfx/gfxlib.ci:165: (17 bytes): if (y < 0)
	<tile+?>: dup.x1 sp(8)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/gfxlib.ci:166: (9 bytes): y := -(-y % rect.h);
	<tile+?>: dup.x1 sp(8)
	<tile+?>: neg.i32
	<tile+?>: dup.x1 sp(4)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x1 sp(9)
	cmplGfx/gfxlib.ci:168: (6 bytes): width: int32 := dst.width(dst)
	<tile+?>: dup.x2 sp(10)
	<tile+?>: nfc(81) ;gxSurf.width(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:169: (6 bytes): height: int32 := dst.height(dst)
	<tile+?>: dup.x2 sp(11)
	<tile+?>: nfc(82) ;gxSurf.height(surf: gxSurf): int32
	cmplGfx/gfxlib.ci:170: (60 bytes): for (j: int32 := y; j < height; j := j + rect.h)
	<tile+?>: dup.x1 sp(10)
	<tile+?>: jmp +45
	cmplGfx/gfxlib.ci:171: (38 bytes): for (i: int32 := x; i < width; i := i + rect.w)
	<tile+?>: dup.x1 sp(12)
	<tile+?>: jmp +23
	cmplGfx/gfxlib.ci:172: (16 bytes): dst.copy(dst, i, j, src, rect);
	<tile+?>: dup.x2 sp(14)
	<tile+?>: dup.x1 sp(2)
	<tile+?>: dup.x1 sp(4)
	<tile+?>: dup.x2 sp(14)
	<tile+?>: load.sp(+40)
	<tile+?>: nfc(95) ;gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
	cmplGfx/gfxlib.ci:171: (3 bytes): i := i + rect.w
	<tile+?>: dup.x1 sp(6)
	<tile+?>: add.i32
	cmplGfx/gfxlib.ci:171: (9 bytes): i < width
	<tile+?>: dup.x1 sp(0)
	<tile+?>: dup.x1 sp(4)
	<tile+?>: clt.i32
	<tile+?>: jnz -24
	<tile+?>: inc.sp(-4)
	cmplGfx/gfxlib.ci:170: (3 bytes): j := j + rect.h
	<tile+?>: dup.x1 sp(6)
	<tile+?>: add.i32
	cmplGfx/gfxlib.ci:170: (9 bytes): j < height
	<tile+?>: dup.x1 sp(0)
	<tile+?>: dup.x1 sp(2)
	<tile+?>: clt.i32
	<tile+?>: jnz -46
	<tile+?>: inc.sp(-4)
	<tile+?>: inc.sp(-24)
	<tile+?>: ret
}
show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void: function {
.kind: static const function
.base: `function`
.size: 118
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:177'
.param .result: void (size: 0, cast: variable(void))
.param mesh: gxMesh (size: 4, cast: variable(ref))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param fovy: float32 (size: 4, cast: variable(f32))
.value: {
	static const Closure: struct {
		mode: int32;
		offs: gxSurf;
		mesh: gxMesh;
	};
	static const next(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const speed: float32 := 1.000000 / (100);
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
			else {
				if (button == ('l')) {
					closure.mode := ((closure.mode) ^ gxMesh.useLights);
				}
				else {
					if (button == ('0')) {
						lights.enable(0, !lights.enabled(0));
					}
					else {
						if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else {
							if (button == ('2')) {
								lights.enable(2, !lights.enabled(2));
							}
							else {
								if (button == ('3')) {
									lights.enable(3, !lights.enabled(3));
								}
								else {
									if (button == ('t')) {
										closure.mode := ((closure.mode) ^ gxMesh.useTexture);
									}
									else {
										if (button == ('/')) {
											closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
										}
										else {
											if (button == ('\t')) {
												closure.mode := next(closure.mode, gxMesh.drawMode);
											}
											else {
												if (button == ('\r')) {
													eye: vec4f := {
														eye.x := (0);
														eye.y := (0);
														eye.z := (2);
														eye.w := (1);
													};
													at: vec4f := {
														at.x := (0);
														at.y := (0);
														at.z := (0);
														at.w := (1);
													};
													up: vec4f := {
														up.x := (0);
														up.y := (1);
														up.z := (0);
														up.w := (1);
													};
													camera.lookAt(eye.data, at.data, up.data);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else {
			if ((action) == Gui.MOUSE_PRESS) {
				ox := ex;
				oy := ey;
				return .result := 0;
			}
			else {
				if ((action) == Gui.MOUSE_MOTION) {
					dir: float32[3];
					dx: int32 := ex - ox;
					dy: int32 := ey - oy;
					if (button == 1) {
						orig: float32[3];
						orig[0] := (0);
						orig[1] := (0);
						orig[2] := (0);
						camera.readUp(dir);
						camera.rotate(dir, orig, (dx) * speed);
						camera.readRight(dir);
						camera.rotate(dir, orig, (dy) * speed);
					}
					else {
						if (button == 2) {
							camera.readUp(dir);
							camera.rotate(dir, null, (-dx) * speed);
							camera.readRight(dir);
							camera.rotate(dir, null, (-dy) * speed);
						}
						else {
							if (button == 3) {
								camera.readForward(dir);
								camera.move(dir, (dy) * speed);
							}
							else {
								if (button == 4) {
									camera.readRight(dir);
									camera.move(dir, (-dx) * speed);
									camera.readUp(dir);
									camera.move(dir, (dy) * speed);
								}
							}
						}
					}
					ox := ex;
					oy := ey;
				}
			}
		}
		rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
		text: char[256];
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, closure.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, closure.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		Gui.setTitle(text);
		return .result := 0;
	};
	closure: Closure := {
		closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
		closure.offs := gxSurf.create3d(w, h);
		closure.mesh := mesh;
	};
	camera.projection(fovy, (w) / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy(closure.offs);
}
.instructions: (118 bytes)
	cmplGfx/gfxlib.ci:294: (69 bytes): closure: Closure := {...}
	<show>  : inc.sp(+24)
	cmplGfx/gfxlib.ci:295: (52 bytes): closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
	<show+?>: load.c64 8
	<show+?>: load.c64 4
	<show+?>: or.b64
	<show+?>: load.c64 128
	<show+?>: or.b64
	<show+?>: load.c64 16
	<show+?>: or.b64
	<show+?>: load.c64 3
	<show+?>: or.b64
	<show+?>: i64.2i32
	<show+?>: set.x1 sp(1)
	cmplGfx/gfxlib.ci:296: (10 bytes): closure.offs := gxSurf.create3d(w, h);
	<show+?>: dup.x1 sp(9)
	<show+?>: dup.x1 sp(9)
	<show+?>: nfc(73) ;gxSurf.create3d(width: int32, height: int32): gxSurf
	<show+?>: set.x2 sp(4)
	cmplGfx/gfxlib.ci:297: (3 bytes): closure.mesh := mesh;
	<show+?>: mov.x1 sp(4, 10)
	cmplGfx/gfxlib.ci:299: (23 bytes): camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>: dup.x1 sp(7)
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: dup.x1 sp(10)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 100.000000
	<show+?>: nfc(101) ;camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
	cmplGfx/gfxlib.ci:300: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x2 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:301: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x2 sp(2)
	<show+?>: nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	<show+?>: inc.sp(-24)
	<show+?>: ret
}
show(surf: gxSurf): void: function {
.kind: static const function
.base: `function`
.size: 17
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:304'
.param .result: void (size: 0, cast: variable(void))
.param surf: gxSurf (size: 8, cast: variable(val))
.value: {
	Gui.showWindow(surf, null, null);
}
.instructions: (17 bytes)
	cmplGfx/gfxlib.ci:305: (16 bytes): Gui.showWindow(surf, null, null);
	<show>  : dup.x2 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
}
show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static const function
.base: `function`
.size: 43
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:308'
.param .result: void (size: 0, cast: variable(void))
.param surf: gxSurf (size: 8, cast: variable(val))
.param onEvent: function (size: 4, cast: variable(ref))
.value: {
	if ((onEvent) == null) {
		return .result := Gui.showWindow(surf, null, null);
	}
	static const delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Gui.showWindow(surf, onEvent, delegateEvent);
}
.instructions: (43 bytes)
	cmplGfx/gfxlib.ci:309: (29 bytes): if ((onEvent) == null)
	<show>  : dup.x1 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: ceq.i32
	<show+?>: jz +21
	cmplGfx/gfxlib.ci:310: (17 bytes): return .result := Gui.showWindow(surf, null, null);
	<show+?>: dup.x2 sp(2)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
	cmplGfx/gfxlib.ci:315: (13 bytes): Gui.showWindow(surf, onEvent, delegateEvent);
	<show+?>: dup.x2 sp(2)
	<show+?>: dup.x1 sp(3)
	<show+?>: load.ref <?> ;show.delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
}
showDiff(image1: gxSurf, image2: gxSurf): void: function {
.kind: static const function
.base: `function`
.size: 48
.name: 'showDiff'
.file: 'cmplGfx/gfxlib.ci:318'
.param .result: void (size: 0, cast: variable(void))
.param image1: gxSurf (size: 8, cast: variable(val))
.param image2: gxSurf (size: 8, cast: variable(val))
.value: {
	static const Closure: struct {
		offs: gxSurf;
		image1: gxSurf;
		image2: gxSurf;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.MOUSE_PRESS) {
			closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
			return .result := 0;
		}
		if ((action) == Gui.MOUSE_RELEASE) {
			closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
			return .result := 0;
		}
		return .result := 0;
	};
	closure: Closure := {
		closure.offs := gxSurf(image1);
		closure.image1 := image1;
		closure.image2 := image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}
.instructions: (48 bytes)
	cmplGfx/gfxlib.ci:342: (28 bytes): closure: Closure := {...}
	<showDiff>  : inc.sp(+24)
	cmplGfx/gfxlib.ci:343: (18 bytes): closure.offs := gxSurf(image1);
	<showDiff+?>: inc.sp(+8)
	<showDiff+?>: dup.x2 sp(11)
	<showDiff+?>: load.ref <?> ;gxSurf(copy: gxSurf): gxSurf
	<showDiff+?>: call
	<showDiff+?>: inc.sp(-8)
	<showDiff+?>: set.x2 sp(2)
	cmplGfx/gfxlib.ci:344: (3 bytes): closure.image1 := image1;
	<showDiff+?>: mov.x2 sp(2, 9)
	cmplGfx/gfxlib.ci:345: (3 bytes): closure.image2 := image2;
	<showDiff+?>: mov.x2 sp(4, 7)
	cmplGfx/gfxlib.ci:347: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showDiff+?>: dup.x2 sp(0)
	<showDiff+?>: load.sp(+8)
	<showDiff+?>: load.ref <?> ;showDiff.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showDiff+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<showDiff+?>: inc.sp(-24)
	<showDiff+?>: ret
}
showWindow(w: int32, h: int32, t: int32, eval(in: vec4f): vec4f): void: function {
.kind: static const function
.base: `function`
.size: 78
.name: 'showWindow'
.file: 'cmplGfx/gfxlib.ci:350'
.param .result: void (size: 0, cast: variable(void))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param t: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.value: {
	static const start: int64 := System.millis();
	static const Closure: struct {
		const offs: gxSurf;
		const thumb: gxSurf;
		const aspect: float64;
		const eval(in: vec4f): vec4f;
	};
	static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return .result := 0;
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.KEY_RELEASE) {
			if (button == (' ')) {
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.offs, null, closure.aspect, time, closure.eval);
				return .result := 0;
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(closure.thumb, null, closure.aspect, time, closure.eval);
		closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
		return .result := 1;
	};
	closure: Closure := {
		closure.offs := gxSurf(w, h, 32);
		closure.thumb := gxSurf(t, t, 32);
		closure.aspect := (w) / float64(h);
		closure.eval := eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy(closure.thumb);
	closure.offs.destroy(closure.offs);
}
.instructions: (78 bytes)
	cmplGfx/gfxlib.ci:385: (46 bytes): closure: Closure := {...}
	<showWindow>  : inc.sp(+32)
	cmplGfx/gfxlib.ci:386: (15 bytes): closure.offs := gxSurf(w, h, 32);
	<showWindow+?>: dup.x1 sp(12)
	<showWindow+?>: dup.x1 sp(12)
	<showWindow+?>: load.c32 32
	<showWindow+?>: nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<showWindow+?>: set.x2 sp(2)
	cmplGfx/gfxlib.ci:387: (15 bytes): closure.thumb := gxSurf(t, t, 32);
	<showWindow+?>: dup.x1 sp(10)
	<showWindow+?>: dup.x1 sp(11)
	<showWindow+?>: load.c32 32
	<showWindow+?>: nfc(72) ;gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
	<showWindow+?>: set.x2 sp(4)
	cmplGfx/gfxlib.ci:388: (9 bytes): closure.aspect := (w) / float64(h);
	<showWindow+?>: dup.x1 sp(12)
	<showWindow+?>: i32.2f64
	<showWindow+?>: dup.x1 sp(13)
	<showWindow+?>: i32.2f64
	<showWindow+?>: div.f64
	<showWindow+?>: set.x2 sp(6)
	cmplGfx/gfxlib.ci:389: (3 bytes): closure.eval := eval;
	<showWindow+?>: mov.x1 sp(6, 9)
	cmplGfx/gfxlib.ci:391: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showWindow+?>: dup.x2 sp(0)
	<showWindow+?>: load.sp(+8)
	<showWindow+?>: load.ref <?> ;showWindow.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showWindow+?>: nfc(115) ;Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:392: (6 bytes): closure.thumb.destroy(closure.thumb);
	<showWindow+?>: dup.x2 sp(2)
	<showWindow+?>: nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	cmplGfx/gfxlib.ci:393: (6 bytes): closure.offs.destroy(closure.offs);
	<showWindow+?>: dup.x2 sp(0)
	<showWindow+?>: nfc(75) ;gxSurf.destroy(surf: gxSurf): void
	<showWindow+?>: inc.sp(-32)
	<showWindow+?>: ret
}
.main: function {
.kind: static function
.base: `function`
.size: 100
.name: '.main'
.print: '.main'
.field typename: typename (size: 136, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field true: bool (size: 0, cast: static const inline)
.field false: bool (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field byte: typename (size: 0, cast: static const inline)
.field float: typename (size: 0, cast: static const inline)
.field double: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, cast: static const i64)
.field RAND_MAX: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field verbose: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 32, cast: static const typename(val))
.field assertEq: function (size: 94, cast: static const function)
.field assertEq: function (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field Math: typename (size: 0, cast: static const typename(void))
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static const function)
.field Complex: function (size: 7, cast: static const function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 123, cast: static const function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static const function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 100, cast: static const function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field length: function (size: 38, cast: static const function)
.field indexOf: function (size: 50, cast: static const function)
.field lastIndexOf: function (size: 50, cast: static const function)
.field startsWith: function (size: 73, cast: static const function)
.field endsWith: function (size: 126, cast: static const function)
.field compare: function (size: 63, cast: static const function)
.field ignCaseCmp: function (size: 36, cast: static const function)
.field caseCmp: function (size: 14, cast: static const function)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 84, cast: static const function)
.field append: function (size: 657, cast: static const function)
.field append: function (size: 23, cast: static const function)
.field append: function (size: 49, cast: static const function)
.field append: function (size: 25, cast: static const function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static const function)
.field sub: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 13, cast: static const function)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field len: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static const function)
.field mat4f: function (size: 21, cast: static const function)
.field dp3: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field mul: function (size: 417, cast: static const function)
.field File: typename (size: 8, cast: static const typename(val))
.field gxRect: typename (size: 16, cast: static const typename(val))
.field gxSurf: typename (size: 8, cast: static const typename(val))
.field gxMesh: typename (size: 176, cast: static const typename(ref))
.field camera: typename (size: 0, cast: static const typename(void))
.field lights: typename (size: 0, cast: static const typename(void))
.field Gui: typename (size: 0, cast: static const typename(void))
.field grayClamp: function (size: 24, cast: static const function)
.field grayClamp: function (size: 36, cast: static const function)
.field grayAnd: function (size: 0, cast: inline)
.field rgb: function (size: 0, cast: inline)
.field rgb: function (size: 0, cast: inline)
.field rgbClamp: function (size: 0, cast: inline)
.field rgbClamp: function (size: 0, cast: inline)
.field rgbAnd: function (size: 0, cast: inline)
.field rgb: function (size: 0, cast: inline)
.field rgb: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field ach: function (size: 0, cast: inline)
.field rch: function (size: 0, cast: inline)
.field gch: function (size: 0, cast: inline)
.field bch: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field argb: typename (size: 4, cast: static const typename(val))
.field uint32: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field rgbOr: function (size: 8, cast: static const function)
.field rgbXor: function (size: 8, cast: static const function)
.field rgbAnd: function (size: 8, cast: static const function)
.field rgbAdd: function (size: 87, cast: static const function)
.field rgbAvg: function (size: 72, cast: static const function)
.field rgbSub: function (size: 87, cast: static const function)
.field rgbMul: function (size: 72, cast: static const function)
.field rgbDiv: function (size: 72, cast: static const function)
.field rgbLerp16: function (size: 90, cast: static const function)
.field rgbLerp: function (size: 30, cast: static const function)
.field brightnessContrastGamma: function (size: 153, cast: static const function)
.field colorMatrix: function (size: 341, cast: static const function)
.field drawHist: function (size: 342, cast: static const function)
.field rgb: function (size: 0, cast: inline)
.field hsv2rgb: function (size: 344, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxSurf: function (size: 189, cast: static const function)
.field gxSurf: function (size: 0, cast: inline)
.field gxMesh: function (size: 109, cast: static const function)
.field gxSurf: function (size: 40, cast: static const function)
.field fill: function (size: 0, cast: inline)
.field clip: function (size: 235, cast: static const function)
.field eval: function (size: 353, cast: static const function)
.field tile: function (size: 251, cast: static const function)
.field show: function (size: 118, cast: static const function)
.field show: function (size: 17, cast: static const function)
.field show: function (size: 43, cast: static const function)
.field showDiff: function (size: 48, cast: static const function)
.field showWindow: function (size: 78, cast: static const function)
.field .main: function (size: 100, cast: static function)
.value: {
	{
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.message := (message);
					details.argument := (null);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.000000 / ln2;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 1.000000 / ln10;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := (0) / 0.000000;
			static const inf: float64 := (1) / 0.000000;
			static const modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(x, result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static const sign(x: float32): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const sign(x: float64): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const abs(x: float32): float32 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const abs(x: float64): float64 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const min(a: float32, b: float32): float32 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const min(a: float64, b: float64): float64 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float32, b: float32): float32 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float64, b: float64): float64 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static lerp(t: float32, a: float32, b: float32): float32 := a + t * (b - a);
			static lerp(t: float64, a: float64, b: float64): float64 := a + t * (b - a);
			static smooth(t: float32): float32 := t * t * ((3) - (2) * t);
			static smooth(t: float64): float64 := t * t * ((3) - (2) * t);
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp((t - a) / (b - a), float32(0), float32(1)));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp((t - a) / (b - a), float64(0), float64(1)));
			static const min(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result > data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const max(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result < data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (data.length); i := i + 1) {
					result := result + data[i];
				}
				return .result := result;
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (a0 + x * a1);
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (a0 + x * eval(x, a1, a2));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (a0 + x * eval(x, a1, a2, a3));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else {
					if (i == 1) {
						x := (1) - x;
						complement := true;
					}
					else {
						if (i == 2) {
							negate := !negate;
							complement := true;
						}
						else {
							if (i == 3) {
								x := (1) - x;
								negate := !negate;
							}
						}
					}
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static const asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static deg2rad(x: float64): float64 := float64(x * pi / (180));
			static rad2deg(x: float64): float64 := float64(x * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static const Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(-a.re, -a.im);
		add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static const div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static const inv(a: Complex): Complex := {
			d: float64 := (a.re * a.re + a.im * a.im);
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const length(str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(str: char[*], with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(str: char[*], with: char[*]): int32 := compare(str, with, caseCmp);
		contains(str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return .result := append(output, pos, 0, value, format);
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (value < 0) {
				sign := ('-');
				value := -value;
			}
			return .result := append(output, pos, sign, value, format);
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				format.radix := 10;
				format.padChr := (0);
				format.padLen := 0;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
		static if ((null) == null) {
			static const vec2d: struct {
				x: float64;
				y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return .result := {
			.result.x := x;
			.result.y := y;
		};
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
			dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		}
		static if ((null) == null) {
			static const vec4f: struct {
				data: float32[4];
				.anonymous: .anonymous;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 0.000000);
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
			vec4f(val: float32): vec4f := vec4f(val, val, val, val);
			neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), min.p4f));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), max.p4f));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dp3));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dph));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(rhs), struct(lhs), p4x.dp4));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
			len(v: vec4f): float32 := float32.sqrt(dp3(v, v));
			normalize(const v: vec4f): vec4f := div(v, vec4f(len(v)));
			eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		}
		static if ((null) == null) {
			static const mat4f: struct {
				data: float32[16];
				.anonymous: .anonymous;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return .result := {
			.result.x.x := xx;
			.result.x.y := xy;
			.result.x.z := xz;
			.result.x.w := xw;
			.result.y.x := yx;
			.result.y.y := yy;
			.result.y.z := yz;
			.result.y.w := yw;
			.result.z.x := zx;
			.result.z.y := zy;
			.result.z.z := zz;
			.result.z.w := zw;
			.result.w.x := wx;
			.result.w.y := wy;
			.result.w.z := wz;
			.result.w.w := ww;
		};
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					transposed.x.x := rhs.x.x;
					transposed.x.y := rhs.y.x;
					transposed.x.z := rhs.z.x;
					transposed.x.w := rhs.w.x;
					transposed.y.x := rhs.x.y;
					transposed.y.y := rhs.y.y;
					transposed.y.z := rhs.z.y;
					transposed.y.w := rhs.w.y;
					transposed.z.x := rhs.x.z;
					transposed.z.y := rhs.y.z;
					transposed.z.z := rhs.z.z;
					transposed.z.w := rhs.w.z;
					transposed.w.x := rhs.x.w;
					transposed.w.y := rhs.y.w;
					transposed.w.z := rhs.z.w;
					transposed.w.w := rhs.w.w;
				};
				return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
			};
		}
	}
	{
		static const gxRect: struct {
			x: int32;
			y: int32;
			w: int32;
			h: int32;
		};
	}
	{
		static const grayClamp(c: uint32): uint32 := {
			if (c > (255)) {
				return .result := 255;
			}
			return .result := c;
		};
		static const grayClamp(c: int32): uint32 := {
			if (c < 0) {
				return .result := 0;
			}
			if (c > 255) {
				return .result := 255;
			}
			return .result := c;
		};
		grayAnd(c: uint32): uint32 := uint32(c & (255));
		rgb(r: int32, g: int32, b: int32): uint32 := uint32((((r << 8) | g) << 8) | b);
		rgb(r: uint32, g: uint32, b: uint32): uint32 := uint32((((r << 8) | g) << 8) | b);
		rgbClamp(r: uint32, g: uint32, b: uint32): uint32 := rgb(grayClamp(r), grayClamp(g), grayClamp(b));
		rgbClamp(r: int32, g: int32, b: int32): uint32 := rgb(grayClamp(r), grayClamp(g), grayClamp(b));
		rgbAnd(r: uint32, g: uint32, b: uint32): uint32 := rgb(grayAnd(r), grayAnd(g), grayAnd(b));
		rgb(r: float64, g: float64, b: float64): uint32 := rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		rgb(r: float32, g: float32, b: float32): uint32 := rgbClamp(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		gray(c: float64): uint32 := grayClamp(int32(c * (255)));
		gray(c: float32): uint32 := grayClamp(int32(c * (255)));
		ach(col: uint32): uint32 := uint32((col >> 24) & (255));
		rch(col: uint32): uint32 := uint32((col >> 16) & (255));
		gch(col: uint32): uint32 := uint32((col >> 8) & (255));
		bch(col: uint32): uint32 := uint32(col & (255));
		lum(c: uint32): uint32 := uint32((rch(c) * (76) + gch(c) * (150) + bch(c) * (29)) >> 8);
		static const argb: struct {
			b: uint8;
			g: uint8;
			r: uint8;
			a: uint8;
		};
		uint32(value: argb): uint32 := uint32(emit(struct(value)));
		argb(argb: uint32): argb := argb(emit(uint32(argb)));
		argb(r: uint32, g: uint32, b: uint32): argb := argb(uint32((((r << 8) | g) << 8) | b));
		argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));
		static const rgbOr(c1: uint32, c2: uint32): uint32 := {
			return .result := c1 | c2;
		};
		static const rgbXor(c1: uint32, c2: uint32): uint32 := {
			return .result := c1 ^ c2;
		};
		static const rgbAnd(c1: uint32, c2: uint32): uint32 := {
			return .result := c1 & c2;
		};
		static const rgbAdd(c1: uint32, c2: uint32): uint32 := {
			r: uint32 := rch(c1) + rch(c2);
			g: uint32 := gch(c1) + gch(c2);
			b: uint32 := bch(c1) + bch(c2);
			return .result := rgbClamp(r, g, b);
		};
		static const rgbAvg(c1: uint32, c2: uint32): uint32 := {
			r: uint32 := (rch(c1) + rch(c2)) / (2);
			g: uint32 := (gch(c1) + gch(c2)) / (2);
			b: uint32 := (bch(c1) + bch(c2)) / (2);
			return .result := rgb(r, g, b);
		};
		static const rgbSub(c1: uint32, c2: uint32): uint32 := {
			r: int32 := rch(c1) - rch(c2);
			g: int32 := gch(c1) - gch(c2);
			b: int32 := bch(c1) - bch(c2);
			return .result := rgbClamp(r, g, b);
		};
		static const rgbMul(c1: uint32, c2: uint32): uint32 := {
			r: uint32 := (rch(c1) * (rch(c2) + (1))) >> 8;
			g: uint32 := (gch(c1) * (gch(c2) + (1))) >> 8;
			b: uint32 := (bch(c1) * (bch(c2) + (1))) >> 8;
			return .result := rgb(r, g, b);
		};
		static const rgbDiv(c1: uint32, c2: uint32): uint32 := {
			r: uint32 := (rch(c1) << 8) / (rch(c2) + (1));
			g: uint32 := (gch(c1) << 8) / (gch(c2) + (1));
			b: uint32 := (bch(c1) << 8) / (bch(c2) + (1));
			return .result := rgb(r, g, b);
		};
		static const rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32 := {
			lrpfix16(x: uint32, y: uint32): uint32 := uint32(x + (t * (y - x) >> 16));
			r: uint32 := lrpfix16(rch(c1), rch(c2));
			g: uint32 := lrpfix16(gch(c1), gch(c2));
			b: uint32 := lrpfix16(bch(c1), bch(c2));
			return .result := rgb(r, g, b);
		};
		static const rgbLerp(c1: uint32, c2: uint32, t: float64): uint32 := {
			return .result := rgbLerp16(c1, c2, uint32(t * ((1 << 16))));
		};
		static const brightnessContrastGamma(lut: uint32[256], brightness: int32, contrast: int32, gamma: float64): void := {
			cval: float64 := ((256 + contrast)) / 256.000000;
			gval: float64 := 1.000000 / gamma;
			for (idx: int32 := 0; idx < lut.length; idx := idx + 1) {
				val: int32 := grayClamp(brightness + int32((256) * (cval * (float64.pow((idx) / 256.000000, gval) - 0.500000) + 0.500000)));
				lut[idx] := rgb(val, val, val);
			}
		};
		static const colorMatrix(luminosity: float32, saturation: float32, hue: float32): mat4f := {
			static const lumMatrix(val: float32): mat4f := {
				return .result := {
			.result.x := vec4f(1.000000, 0.000000, 0.000000, val);
			.result.y := vec4f(0.000000, 1.000000, 0.000000, val);
			.result.z := vec4f(0.000000, 0.000000, 1.000000, val);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
			};
			static const satMatrix(val: float32): mat4f := {
				const inv: float32 := (1) - val;
				const R: float32 := 0.213000 * inv;
				const G: float32 := 0.715000 * inv;
				const B: float32 := 0.072000 * inv;
				return .result := {
			.result.x := vec4f(R + val, G, B, 0.000000);
			.result.y := vec4f(R, G + val, B, 0.000000);
			.result.z := vec4f(R, G, B + val, 0.000000);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
			};
			static const hueMatrix(val: float32): mat4f := {
				lR: typename := 0.213000;
				lG: typename := 0.715000;
				lB: typename := 0.072000;
				cV: float32 := val.cos(val);
				sV: float32 := val.sin(val);
				return .result := {
			.result.x := vec4f(lR + (cV) * ((1) - lR) + (sV) * (-lR), lG + (cV) * (-lG) + (sV) * (-lG), lB + (cV) * (-lB) + (sV) * ((1) - lB), 0.000000);
			.result.y := vec4f(lR + (cV) * ((0) - lR) + (sV) * (0.143000), lG + (cV) * ((1) - lG) + (sV) * (0.140000), lB + (cV) * (-lB) + (sV) * (-0.283000), 0.000000);
			.result.z := vec4f(lR + (cV) * ((0) - lR) + (sV) * (lR - (1)), lG + (cV) * (-lG) + (sV) * (lG), lB + (cV) * ((1) - lB) + (sV) * (lB), 0.000000);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
			};
			result: mat4f := mat4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			result := mul(result, lumMatrix(luminosity));
			result := mul(result, satMatrix(saturation));
			result := mul(result, hueMatrix(hue));
			return .result := result;
		};
		static const drawHist(image: gxSurf, roi: gxRect, hist: uint32): void := {
			lut: uint32[256];
			image.calcHist(image, roi, hist, lut);
			rect: gxRect := {
				rect.w := 256;
				rect.h := 128;
				rect.y := margin;
				rect.x := image.width(image) - rect.w - margin;
			};
			image.fillRect(image, rect.x - padding, rect.y - padding, rect.x + rect.w + padding, rect.y + rect.h + padding, 0);
			for (x: int32 := 0; x < rect.w; x := x + 1) {
				bv: int32 := bch(lut[x]) * (rect.h) / (256);
				gv: int32 := gch(lut[x]) * (rect.h) / (256);
				rv: int32 := rch(lut[x]) * (rect.h) / (256);
				lv: int32 := ach(lut[x]) * (rect.h) / (256);
				for (y: int32 := 0; y < rect.h; y := y + 1) {
					b: uint32 := colB * (uint32(y < bv));
					g: uint32 := colG * (uint32(y < gv));
					r: uint32 := colR * (uint32(y < rv));
					l: uint32 := colL * (uint32(y < lv));
					image.set(image, x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
				}
			}
		};
		static if ((typename(vec4f)) != null) {
			rgb(const vec: vec4f): uint32 := rgb(vec.x, vec.y, vec.z);
			static const hsv2rgb(hsv: vec4f): vec4f := {
				h: float32 := hsv.x;
				s: float32 := hsv.y;
				v: float32 := hsv.z;
				if (s == (0)) {
					return .result := vec4f(v);
				}
				h := h * (360 / 60);
				i: int32 := int32(h);
				f: float32 := h - (i);
				u: float32 := v;
				p: float32 := v * ((1) - s);
				q: float32 := v * ((1) - s * f);
				t: float32 := v * ((1) - s * ((1) - f));
				if (i == 0) {
					return .result := vec4f(u, t, p);
				}
				if (i == 1) {
					return .result := vec4f(q, u, p);
				}
				if (i == 2) {
					return .result := vec4f(p, u, t);
				}
				if (i == 3) {
					return .result := vec4f(p, q, u);
				}
				if (i == 4) {
					return .result := vec4f(t, p, u);
				}
				return .result := vec4f(u, p, q);
			};
		}
		gxSurf(width: int32, height: int32, depth: int32): gxSurf := gxSurf.create(width, height, depth);
		static const gxSurf(fileName: char[*], depth: int32): gxSurf := {
			if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".jpg", ignCaseCmp)) {
				return .result := gxSurf.openJpg(fileName, depth);
			}
			if (endsWith(fileName, ".png", ignCaseCmp)) {
				return .result := gxSurf.openPng(fileName, depth);
			}
			if (endsWith(fileName, ".bmp", ignCaseCmp)) {
				return .result := gxSurf.openBmp(fileName, depth);
			}
			abort("unknown file extension", fileName);
		};
		gxSurf(fileName: char[*]): gxSurf := gxSurf(fileName, 32);
		static const gxMesh(fileName: char[*]): gxMesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := gxMesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := gxMesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const gxSurf(copy: gxSurf): gxSurf := {
			result: gxSurf := gxSurf.create(copy.width(copy), copy.height(copy), copy.depth(copy));
			result.copy(result, 0, 0, copy, null);
			return .result := result;
		};
		fill(dst: gxSurf, col: uint32): void := dst.fillRect(dst, 0, 0, dst.width(dst), dst.height(dst), col);
		static const clip(src: gxSurf, roi: gxRect): bool := {
			roi.w := roi.w + roi.x;
			roi.h := roi.h + roi.y;
			if (roi.x < 0) {
				roi.x := 0;
			}
			if (roi.y < 0) {
				roi.y := 0;
			}
			width: int32 := src.width(src);
			if (roi.w > width) {
				roi.w := width;
			}
			height: int32 := src.height(src);
			if (roi.h > height) {
				roi.h := height;
			}
			roi.w := roi.w - roi.x;
			roi.h := roi.h - roi.y;
			if (roi.w <= 0) {
				return .result := false;
			}
			if (roi.h <= 0) {
				return .result := false;
			}
			return .result := true;
		};
		static const eval(out: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : out.width(out);
				rect.h := (roi) != null ? roi.h : out.height(out);
			};
			if (!clip(out, rect)) {
				return;
			}
			in: vec4f := {
				in.x := (0);
				in.y := (0);
				in.z := aspect;
				in.w := time;
			};
			w: float32 := out.width(out);
			h: float32 := out.height(out);
			for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
					in.x := (x) / w;
					out.set(out, x, y, rgb(eval(in)));
				}
			}
		};
		static const tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void := {
			rect: gxRect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : src.width(src);
				rect.h := (roi) != null ? roi.h : src.height(src);
			};
			if (!clip(src, rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % rect.w);
			}
			if (y < 0) {
				y := -(-y % rect.h);
			}
			width: int32 := dst.width(dst);
			height: int32 := dst.height(dst);
			for (j: int32 := y; j < height; j := j + rect.h) {
				for (i: int32 := x; i < width; i := i + rect.w) {
					dst.copy(dst, i, j, src, rect);
				}
			}
		};
		static const show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void := {
			static const Closure: struct {
				mode: int32;
				offs: gxSurf;
				mesh: gxMesh;
			};
			static const next(x: int32, mask: int32): int32 := {
				next: int32 := x & mask;
				next := next + (mask & -mask);
				next := next & mask;
				return .result := next | (x & ~mask);
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				static ox: int32 := 0;
				static oy: int32 := 0;
				static const speed: float32 := 1.000000 / (100);
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
					else {
						if (button == ('l')) {
							closure.mode := ((closure.mode) ^ gxMesh.useLights);
						}
						else {
							if (button == ('0')) {
								lights.enable(0, !lights.enabled(0));
							}
							else {
								if (button == ('1')) {
									lights.enable(1, !lights.enabled(1));
								}
								else {
									if (button == ('2')) {
										lights.enable(2, !lights.enabled(2));
									}
									else {
										if (button == ('3')) {
											lights.enable(3, !lights.enabled(3));
										}
										else {
											if (button == ('t')) {
												closure.mode := ((closure.mode) ^ gxMesh.useTexture);
											}
											else {
												if (button == ('/')) {
													closure.mode := next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
												}
												else {
													if (button == ('\t')) {
														closure.mode := next(closure.mode, gxMesh.drawMode);
													}
													else {
														if (button == ('\r')) {
															eye: vec4f := {
																eye.x := (0);
																eye.y := (0);
																eye.z := (2);
																eye.w := (1);
															};
															at: vec4f := {
																at.x := (0);
																at.y := (0);
																at.z := (0);
																at.w := (1);
															};
															up: vec4f := {
																up.x := (0);
																up.y := (1);
																up.z := (0);
																up.w := (1);
															};
															camera.lookAt(eye.data, at.data, up.data);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					if ((action) == Gui.MOUSE_PRESS) {
						ox := ex;
						oy := ey;
						return .result := 0;
					}
					else {
						if ((action) == Gui.MOUSE_MOTION) {
							dir: float32[3];
							dx: int32 := ex - ox;
							dy: int32 := ey - oy;
							if (button == 1) {
								orig: float32[3];
								orig[0] := (0);
								orig[1] := (0);
								orig[2] := (0);
								camera.readUp(dir);
								camera.rotate(dir, orig, (dx) * speed);
								camera.readRight(dir);
								camera.rotate(dir, orig, (dy) * speed);
							}
							else {
								if (button == 2) {
									camera.readUp(dir);
									camera.rotate(dir, null, (-dx) * speed);
									camera.readRight(dir);
									camera.rotate(dir, null, (-dy) * speed);
								}
								else {
									if (button == 3) {
										camera.readForward(dir);
										camera.move(dir, (dy) * speed);
									}
									else {
										if (button == 4) {
											camera.readRight(dir);
											camera.move(dir, (-dx) * speed);
											camera.readUp(dir);
											camera.move(dir, (dy) * speed);
										}
									}
								}
							}
							ox := ex;
							oy := ey;
						}
					}
				}
				rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
				text: char[256];
				pos: int32 := append(text, 0, "Vertices: ");
				pos := append(text, pos, closure.mesh.vertices);
				pos := append(text, pos, ", Triangles: ");
				pos := append(text, pos, closure.mesh.triangles);
				pos := append(text, pos, "/");
				pos := append(text, pos, rendered);
				Gui.setTitle(text);
				return .result := 0;
			};
			closure: Closure := {
				closure.mode := (gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill);
				closure.offs := gxSurf.create3d(w, h);
				closure.mesh := mesh;
			};
			camera.projection(fovy, (w) / float32(h), 1, 100);
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.offs.destroy(closure.offs);
		};
		static const show(surf: gxSurf): void := {
			Gui.showWindow(surf, null, null);
		};
		static const show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
			if ((onEvent) == null) {
				return .result := Gui.showWindow(surf, null, null);
			}
			static const delegateEvent(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				return .result := onEvent(action, button, ex, ey);
			};
			Gui.showWindow(surf, onEvent, delegateEvent);
		};
		static const showDiff(image1: gxSurf, image2: gxSurf): void := {
			static const Closure: struct {
				offs: gxSurf;
				image1: gxSurf;
				image2: gxSurf;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.MOUSE_PRESS) {
					closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
					return .result := 0;
				}
				if ((action) == Gui.MOUSE_RELEASE) {
					closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
					return .result := 0;
				}
				return .result := 0;
			};
			closure: Closure := {
				closure.offs := gxSurf(image1);
				closure.image1 := image1;
				closure.image2 := image2;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
		};
		static const showWindow(w: int32, h: int32, t: int32, eval(in: vec4f): vec4f): void := {
			static const start: int64 := System.millis();
			static const Closure: struct {
				const offs: gxSurf;
				const thumb: gxSurf;
				const aspect: float64;
				const eval(in: vec4f): vec4f;
			};
			static const onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.WINDOW_CLOSE) {
					trace("closing ...");
					return .result := 0;
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.KEY_RELEASE) {
					if (button == (' ')) {
						time: float32 := ((System.millis() - start)) / 1000.000000;
						eval(closure.offs, null, closure.aspect, time, closure.eval);
						return .result := 0;
					}
				}
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.thumb, null, closure.aspect, time, closure.eval);
				closure.offs.resize(closure.offs, null, closure.thumb, null, 1);
				return .result := 1;
			};
			closure: Closure := {
				closure.offs := gxSurf(w, h, 32);
				closure.thumb := gxSurf(t, t, 32);
				closure.aspect := (w) / float64(h);
				closure.eval := eval;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.thumb.destroy(closure.thumb);
			closure.offs.destroy(closure.offs);
		};
	}
}
.instructions: (100 bytes)
	lib/std/string.ci:130: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main>  : load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes): static const format: FormatFlags := {...}
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;append.format
	:: (7 bytes): format.padChr := (0)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+4
	<.main+?>: store.i8
	:: (5 bytes): format.padLen := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+8
	:: (5 bytes): format.precision := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+12
	cmplGfx/gfxlib.ci:198: (5 bytes): static ox: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.ox
	cmplGfx/gfxlib.ci:199: (5 bytes): static oy: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.oy
	cmplGfx/gfxlib.ci:200: (24 bytes): static const speed: float32 := 1.000000 / (100)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 100.000000
	<.main+?>: div.f64
	<.main+?>: f64.2f32
	<.main+?>: store.m32 <?> ;show.onEvent.speed
	cmplGfx/gfxlib.ci:351: (8 bytes): static const start: int64 := System.millis()
	<.main+?>: nfc(16) ;System.millis(): int64
	<.main+?>: store.m64 <?> ;showWindow.start
	<.main+?>: nfc(0) ;halt(): void
}

---------- Execute: byte-code

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:39: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:46: Math.floor: function(<Math.floor>)
lib/std/math.ci:58: Math.sign: function(<Math.sign>)
lib/std/math.ci:67: Math.sign: function(<Math.sign>)
lib/std/math.ci:83: Math.abs: function(<Math.abs>)
lib/std/math.ci:89: Math.abs: function(<Math.abs>)
lib/std/math.ci:101: Math.min: function(<Math.min>)
lib/std/math.ci:107: Math.min: function(<Math.min>)
lib/std/math.ci:119: Math.max: function(<Math.max>)
lib/std/math.ci:125: Math.max: function(<Math.max>)
lib/std/math.ci:137: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:146: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:172: Math.min: function(<Math.min>)
lib/std/math.ci:184: Math.max: function(<Math.max>)
lib/std/math.ci:197: Math.sum: function(<Math.sum>)
lib/std/math.ci:215: Math.eval: function(<Math.eval>)
lib/std/math.ci:223: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:236: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:250: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:307: Math.tan: function(<Math.tan>)
lib/std/math.ci:364: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:403: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:419: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
lib/vec/vec2d.ci:3: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:8: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:3: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:21: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:3: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:13: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:25: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:33: mul: function(<mul>)
File: typename(<File>)
cmplGfx/src/gx_main.c:1001: gxRect: typename(<gxRect>)
gxSurf: typename(<gxSurf>)
gxMesh: typename(<gxMesh>)
camera: typename(<camera>)
lights: typename(<lights>)
Gui: typename(<Gui>)
cmplGfx/lib/rgb.ci:2: grayClamp: function(<grayClamp>)
cmplGfx/lib/rgb.ci:8: grayClamp: function(<grayClamp>)
cmplGfx/lib/rgb.ci:41: argb: typename(<argb>)
cmplGfx/lib/rgb.ci:53: rgbOr: function(<rgbOr>)
cmplGfx/lib/rgb.ci:56: rgbXor: function(<rgbXor>)
cmplGfx/lib/rgb.ci:59: rgbAnd: function(<rgbAnd>)
cmplGfx/lib/rgb.ci:62: rgbAdd: function(<rgbAdd>)
cmplGfx/lib/rgb.ci:68: rgbAvg: function(<rgbAvg>)
cmplGfx/lib/rgb.ci:74: rgbSub: function(<rgbSub>)
cmplGfx/lib/rgb.ci:80: rgbMul: function(<rgbMul>)
cmplGfx/lib/rgb.ci:86: rgbDiv: function(<rgbDiv>)
cmplGfx/lib/rgb.ci:93: rgbLerp16: function(<rgbLerp16>)
cmplGfx/lib/rgb.ci:102: rgbLerp: function(<rgbLerp>)
cmplGfx/lib/color.ci:1: brightnessContrastGamma: function(<brightnessContrastGamma>)
cmplGfx/lib/color.ci:11: colorMatrix: function(<colorMatrix>)
cmplGfx/lib/color.ci:65: drawHist: function(<drawHist>)
cmplGfx/gfxlib.ci:6: hsv2rgb: function(<hsv2rgb>)
cmplGfx/gfxlib.ci:46: gxSurf: function(<gxSurf>)
cmplGfx/gfxlib.ci:64: gxMesh: function(<gxMesh>)
cmplGfx/gfxlib.ci:74: gxSurf: function(<gxSurf>)
cmplGfx/gfxlib.ci:87: clip: function(<clip>)
cmplGfx/gfxlib.ci:121: eval: function(<eval>)
cmplGfx/gfxlib.ci:150: tile: function(<tile>)
cmplGfx/gfxlib.ci:177: show: function(<show>)
cmplGfx/gfxlib.ci:304: show: function(<show>)
cmplGfx/gfxlib.ci:308: show: function(<show>)
cmplGfx/gfxlib.ci:318: showDiff: function(<showDiff>)
cmplGfx/gfxlib.ci:350: showWindow: function(<showWindow>)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 279930(273.4 Kb)
memory[heap] @04457a; size: 1292676(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 269936(263.6 Kb)
memory[code] @000000; size: 9664(9.4 Kb)
memory[data] @000000; size: 52(52.0 bytes)

---------- heap memory:
memory[free] @044598; size: 1292624(1.2 Mb)

---------- Exitcode: 0, time: 0.000 ms
