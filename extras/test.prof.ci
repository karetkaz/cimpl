
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:44: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:45: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:46: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:43: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:34: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:56: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:59: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:62: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:68: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:71: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:84: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:90: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:96: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:176: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:176: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:177: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:177: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:186: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:190: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:198: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:202: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:212: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:230: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:278: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:284: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:285: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:286: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:288: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:292: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:292: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:296: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:301: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:336: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:340: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:342: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:348: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:356: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:355: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:351: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:347: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:365: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:390: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:395: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:396: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:401: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:417: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:420: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:421: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:423: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:439: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:444: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:451: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:467: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:490: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:491: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:498: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:57: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:109: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:115: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:122: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:123: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:123: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:125: warn: adding implicit cast char(0: int32)
lib/std/string.ci:138: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:141: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:141: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:142: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:166: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:173: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:186: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:186: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:188: warn: adding implicit cast char(0: int32)
lib/std/string.ci:199: warn: adding implicit cast int32('-': char)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:108: warn: adding implicit cast char(0: int32)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:59: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:60: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:61: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:3: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:64: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:70: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:59: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:62: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:63: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:47: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:283: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:286: warn: using default type initializer: e := 0
lib/std/math.ci:290: warn: using default type initializer: f := 0
lib/std/math.ci:342: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:399: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang/method.ci:58: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 144
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+24>, cast: const variable)
.field offset: int32 (size: 4, offs: <+32>, cast: const variable)
.field base: function (size: 0, offs: <@005a88>, cast: static const inline)
.field file: function (size: 0, offs: <@005c70>, cast: static const inline)
.field line: function (size: 0, offs: <@005e58>, cast: static const inline)
.field name: function (size: 0, offs: <@006040>, cast: static const inline)
.references:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:54: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal references: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+24>
.name: 'size'
.owner: typename
.references:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:54: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'offset'
.print: '@%06x'
.owner: typename
.references:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005a88>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.references:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal references: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005c70>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.references:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal references: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005e58>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.references:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal references: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006040>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.references:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal references: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000a8>
.name: 'void'
.references:
	test/lang/method.ci:68: referenced as `void`
	test/lang/method.ci:62: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:30: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:19: referenced as `void`
	test/lang/method.ci:15: referenced as `void`
	test/lang/method.ci:11: referenced as `void`
	test/lang/method.ci:6: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:39: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	internal references: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000140>
.name: 'bool'
.print: '%d'
.value: 0
.references:
	test/stdc/test.math.ci:70: referenced as `bool`
	test/stdc/test.math.ci:69: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:44: referenced as `bool`
	lib/std/string.ci:35: referenced as `bool`
	lib/std/math.ci:438: referenced as `bool`
	lib/std/math.ci:389: referenced as `bool`
	lib/std/math.ci:334: referenced as `bool`
	lib/std/math.ci:333: referenced as `bool`
	lib/stdlib.ci:29: referenced as `bool`
	lib/stdlib.ci:28: referenced as `bool`
	lib/stdlib.ci:27: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001d8>
.name: 'char'
.print: '%c'
.value: 0
.references:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:205: referenced as `char`
	lib/std/string.ci:196: referenced as `char`
	lib/std/string.ci:192: referenced as `char`
	lib/std/string.ci:150: referenced as `char`
	lib/std/string.ci:134: referenced as `char`
	lib/std/string.ci:131: referenced as `char`
	lib/std/string.ci:130: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:108: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:3: referenced as `char`
	lib/stdlib.ci:39: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:24: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	lib/stdlib.ci:14: referenced as `char`
	lib/stdlib.ci:12: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:9: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	lib/stdlib.ci:5: referenced as `char`
	internal references: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000270>
.name: 'int8'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000308>
.name: 'int16'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003a0>
.name: 'int32'
.print: '%d'
.value: 0
.references:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:68: referenced as `int32`
	test/lang/method.ci:62: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:30: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:19: referenced as `int32`
	test/lang/method.ci:15: referenced as `int32`
	test/lang/method.ci:11: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:197: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:179: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:136: referenced as `int32`
	lib/std/string.ci:133: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:114: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:110: referenced as `int32`
	lib/std/string.ci:109: referenced as `int32`
	lib/std/string.ci:107: referenced as `int32`
	lib/std/string.ci:84: referenced as `int32`
	lib/std/string.ci:70: referenced as `int32`
	lib/std/string.ci:60: referenced as `int32`
	lib/std/string.ci:59: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:50: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:45: referenced as `int32`
	lib/std/string.ci:44: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:35: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:24: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:14: referenced as `int32`
	lib/std/string.ci:7: referenced as `int32`
	lib/std/string.ci:3: referenced as `int32`
	lib/std/math.ci:344: referenced as `int32`
	lib/std/math.ci:344: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:263: referenced as `int32`
	lib/std/math.ci:249: referenced as `int32`
	lib/std/math.ci:236: referenced as `int32`
	lib/std/math.ci:230: referenced as `int32`
	lib/std/math.ci:212: referenced as `int32`
	lib/std/math.ci:202: referenced as `int32`
	lib/std/math.ci:190: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:58: referenced as `int32`
	lib/stdlib.ci:54: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	internal references: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000438>
.name: 'int64'
.print: '%D'
.value: 0
.references:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal references: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@0004d0>
.name: 'uint8'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@000568>
.name: 'uint16'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000600>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@008a60>, cast: static const inline)
.field sxt: function (size: 0, offs: <@008d68>, cast: static const inline)
.field pop: function (size: 0, offs: <@008f50>, cast: static const inline)
.field swap: function (size: 0, offs: <@009138>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009320>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009508>, cast: static const inline)
.field hib: function (size: 0, offs: <@0096f0>, cast: static const inline)
.field lob: function (size: 0, offs: <@0098d8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:205: referenced as `uint32`
	lib/std/string.ci:192: referenced as `uint32`
	lib/std/string.ci:129: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008a60>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.references:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal references: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d68>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.references:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal references: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f50>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.references:
	test/stdc/number.ci:55: referenced as `pop`
	internal references: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009138>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.references:
	test/stdc/number.ci:56: referenced as `swap`
	internal references: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009320>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.references:
	test/stdc/number.ci:57: referenced as `bsr`
	internal references: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009508>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.references:
	test/stdc/number.ci:58: referenced as `bsf`
	internal references: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096f0>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.references:
	test/stdc/number.ci:59: referenced as `hib`
	internal references: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098d8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.references:
	test/stdc/number.ci:60: referenced as `lob`
	internal references: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000698>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@009bd8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009ed8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009bd8>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.references:
	test/stdc/number.ci:65: referenced as `zxt`
	internal references: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ed8>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.references:
	test/stdc/number.ci:66: referenced as `sxt`
	internal references: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000730>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00a0c0>, cast: static const inline)
.field cos: function (size: 0, offs: <@00a2a8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00a490>, cast: static const inline)
.field log: function (size: 0, offs: <@00a678>, cast: static const inline)
.field exp: function (size: 0, offs: <@00a860>, cast: static const inline)
.field pow: function (size: 0, offs: <@00aad8>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00acc0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00af38>, cast: static const inline)
.value: 0
.references:
	test/stdc/test.math.ci:98: referenced as `float32`
	test/stdc/test.math.ci:97: referenced as `float32`
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:92: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:87: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:4: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:74: referenced as `float32`
	lib/vec/vec4f.ci:70: referenced as `float32`
	lib/vec/vec4f.ci:69: referenced as `float32`
	lib/vec/vec4f.ci:68: referenced as `float32`
	lib/vec/vec4f.ci:63: referenced as `float32`
	lib/vec/vec4f.ci:62: referenced as `float32`
	lib/vec/vec4f.ci:26: referenced as `float32`
	lib/vec/vec4f.ci:25: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:8: referenced as `float32`
	lib/vec/vec4f.ci:7: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:4: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:176: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:58: referenced as `float32`
	internal references: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0c0>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.references:
	test/stdc/number.ci:46: referenced as `sin`
	internal references: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2a8>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.references:
	test/stdc/number.ci:47: referenced as `cos`
	internal references: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a490>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.references:
	test/stdc/number.ci:48: referenced as `tan`
	internal references: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a678>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.references:
	test/stdc/number.ci:49: referenced as `log`
	internal references: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a860>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.references:
	test/stdc/number.ci:50: referenced as `exp`
	internal references: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00aad8>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.references:
	test/stdc/number.ci:51: referenced as `pow`
	internal references: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00acc0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.references:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:74: referenced as `sqrt`
	internal references: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af38>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.references:
	test/stdc/number.ci:53: referenced as `atan2`
	internal references: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@0007c8>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00b118>, cast: static const inline)
.field cos: function (size: 0, offs: <@00b2f8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00b4d8>, cast: static const inline)
.field log: function (size: 0, offs: <@00b6b8>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b898>, cast: static const inline)
.field pow: function (size: 0, offs: <@00bb08>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00bce8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00bf58>, cast: static const inline)
.value: 0
.references:
	test/stdc/test.math.ci:84: referenced as `float64`
	test/stdc/test.math.ci:83: referenced as `float64`
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:78: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:73: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:66: referenced as `float64`
	test/stdc/test.math.ci:65: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:62: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:56: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:47: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:42: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:37: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:5: referenced as `float64`
	lib/vec/vec2d.ci:4: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:117: referenced as `float64`
	lib/std/math.Complex.ci:114: referenced as `float64`
	lib/std/math.Complex.ci:113: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:108: referenced as `float64`
	lib/std/math.Complex.ci:105: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:94: referenced as `float64`
	lib/std/math.Complex.ci:90: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:87: referenced as `float64`
	lib/std/math.Complex.ci:86: referenced as `float64`
	lib/std/math.Complex.ci:79: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:72: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:63: referenced as `float64`
	lib/std/math.Complex.ci:60: referenced as `float64`
	lib/std/math.Complex.ci:59: referenced as `float64`
	lib/std/math.Complex.ci:56: referenced as `float64`
	lib/std/math.Complex.ci:55: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:20: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.Complex.ci:4: referenced as `float64`
	lib/std/math.ci:491: referenced as `float64`
	lib/std/math.ci:491: referenced as `float64`
	lib/std/math.ci:490: referenced as `float64`
	lib/std/math.ci:490: referenced as `float64`
	lib/std/math.ci:467: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:451: referenced as `float64`
	lib/std/math.ci:449: referenced as `float64`
	lib/std/math.ci:449: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:423: referenced as `float64`
	lib/std/math.ci:423: referenced as `float64`
	lib/std/math.ci:421: referenced as `float64`
	lib/std/math.ci:416: referenced as `float64`
	lib/std/math.ci:416: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:401: referenced as `float64`
	lib/std/math.ci:401: referenced as `float64`
	lib/std/math.ci:399: referenced as `float64`
	lib/std/math.ci:396: referenced as `float64`
	lib/std/math.ci:379: referenced as `float64`
	lib/std/math.ci:377: referenced as `float64`
	lib/std/math.ci:377: referenced as `float64`
	lib/std/math.ci:361: referenced as `float64`
	lib/std/math.ci:360: referenced as `float64`
	lib/std/math.ci:343: referenced as `float64`
	lib/std/math.ci:342: referenced as `float64`
	lib/std/math.ci:321: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:314: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:308: referenced as `float64`
	lib/std/math.ci:307: referenced as `float64`
	lib/std/math.ci:290: referenced as `float64`
	lib/std/math.ci:286: referenced as `float64`
	lib/std/math.ci:283: referenced as `float64`
	lib/std/math.ci:277: referenced as `float64`
	lib/std/math.ci:264: referenced as `float64`
	lib/std/math.ci:263: referenced as `float64`
	lib/std/math.ci:263: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:224: referenced as `float64`
	lib/std/math.ci:224: referenced as `float64`
	lib/std/math.ci:211: referenced as `float64`
	lib/std/math.ci:210: referenced as `float64`
	lib/std/math.ci:210: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:177: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:52: referenced as `float64`
	lib/std/math.ci:51: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:6: referenced as `float64`
	internal references: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b118>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.references:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:145: referenced as `sin`
	lib/std/math.Complex.ci:120: referenced as `sin`
	lib/std/math.Complex.ci:119: referenced as `sin`
	lib/std/math.Complex.ci:114: referenced as `sin`
	lib/std/math.Complex.ci:103: referenced as `sin`
	internal references: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b2f8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.references:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:145: referenced as `cos`
	lib/std/math.Complex.ci:120: referenced as `cos`
	lib/std/math.Complex.ci:119: referenced as `cos`
	lib/std/math.Complex.ci:113: referenced as `cos`
	lib/std/math.Complex.ci:103: referenced as `cos`
	internal references: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b4d8>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.references:
	test/stdc/number.ci:39: referenced as `tan`
	internal references: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b6b8>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.references:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:110: referenced as `log`
	lib/std/math.Complex.ci:105: referenced as `log`
	internal references: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b898>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.references:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:111: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.ci:423: referenced as `exp`
	lib/std/math.ci:423: referenced as `exp`
	lib/std/math.ci:421: referenced as `exp`
	lib/std/math.ci:401: referenced as `exp`
	lib/std/math.ci:401: referenced as `exp`
	lib/std/math.ci:396: referenced as `exp`
	internal references: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bb08>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.references:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:111: referenced as `pow`
	internal references: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bce8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.references:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:89: referenced as `sqrt`
	lib/std/math.ci:449: referenced as `sqrt`
	internal references: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bf58>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.references:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:90: referenced as `atan2`
	lib/std/math.ci:454: referenced as `atan2`
	lib/std/math.ci:451: referenced as `atan2`
	internal references: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000860>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007268>, cast: static const inline)
.field fill: function (size: 0, offs: <@007578>, cast: static const inline)
.field copy: function (size: 0, offs: <@007888>, cast: static const inline)
.field move: function (size: 0, offs: <@007b90>, cast: static const inline)
.references:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal references: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007268>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.references:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal references: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007578>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.references:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal references: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007888>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.references:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal references: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007b90>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.references:
	test/stdc/memory.ci:29: referenced as `move`
	internal references: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@0008f8>
.name: 'variant'
.references:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:34: referenced as `variant`
	lib/stdlib.ci:33: referenced as `variant`
	lib/stdlib.ci:32: referenced as `variant`
	lib/stdlib.ci:27: referenced as `variant`
	lib/stdlib.ci:23: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:17: referenced as `variant`
	lib/stdlib.ci:14: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:8: referenced as `variant`
	lib/stdlib.ci:5: referenced as `variant`
	internal references: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000990>
.name: 'function'
.references:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a30>
.name: 'object'
.references:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.references:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:70: referenced as `null`
	test/lang/method.ci:64: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:4: referenced as `null`
	lib/stdlib.ci:50: referenced as `null`
	lib/stdlib.ci:35: referenced as `null`
	lib/stdlib.ci:34: referenced as `null`
	lib/stdlib.ci:25: referenced as `null`
	lib/stdlib.ci:24: referenced as `null`
	lib/stdlib.ci:21: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:15: referenced as `null`
	lib/stdlib.ci:12: referenced as `null`
	lib/stdlib.ci:9: referenced as `null`
	lib/stdlib.ci:6: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.references:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:55: referenced as `true`
	lib/std/string.ci:41: referenced as `true`
	lib/std/math.ci:440: referenced as `true`
	lib/std/math.ci:392: referenced as `true`
	lib/std/math.ci:353: referenced as `true`
	lib/std/math.ci:349: referenced as `true`
	lib/std/math.ci:338: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.references:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:52: referenced as `false`
	lib/std/string.ci:48: referenced as `false`
	lib/std/string.ci:38: referenced as `false`
	lib/std/math.ci:438: referenced as `false`
	lib/std/math.ci:389: referenced as `false`
	lib/std/math.ci:334: referenced as `false`
	lib/std/math.ci:333: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.references:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.references:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.references:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.references:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000f88>
.name: '.cstr'
.print: '%s'
.references:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@001020>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0013b0>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001448>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0016a8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001c00>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001f68>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@002130>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0022e8>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@0024a0>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002658>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002810>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002ae8>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002f00>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@0032f8>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036f0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c08>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004120>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004518>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004910>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004d08>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005100>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@0052b8>, cast: static const typename(void))
.references:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:70: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:68: referenced as `emit`
	lib/vec/vec4f.ci:63: referenced as `emit`
	lib/vec/vec4f.ci:62: referenced as `emit`
	lib/vec/vec4f.ci:60: referenced as `emit`
	lib/vec/vec4f.ci:59: referenced as `emit`
	lib/vec/vec4f.ci:58: referenced as `emit`
	lib/vec/vec4f.ci:57: referenced as `emit`
	lib/vec/vec4f.ci:56: referenced as `emit`
	lib/vec/vec2d.ci:15: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.references:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.references:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.references:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.references:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.references:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0013b0>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:70: referenced as `p4x`
	lib/vec/vec4f.ci:69: referenced as `p4x`
	lib/vec/vec4f.ci:68: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.references:
	lib/vec/vec4f.ci:68: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.references:
	lib/vec/vec4f.ci:70: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.references:
	lib/vec/vec4f.ci:69: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001448>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.references:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.references:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.references:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0016a8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.references:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.references:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.references:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.references:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.references:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.references:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.references:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.references:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001c00>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.references:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.references:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.references:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.references:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.references:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f68>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.references:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.references:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002130>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.references:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.references:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022e8>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.references:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.references:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0024a0>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.references:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.references:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002658>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.references:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.references:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002810>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.references:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.references:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.references:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.references:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002ae8>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.references:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.references:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.references:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.references:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.references:
	lib/vec/vec4f.ci:56: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.references:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002f00>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:57: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.references:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.references:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.references:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.references:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.references:
	lib/vec/vec4f.ci:57: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.references:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0032f8>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:58: referenced as `sub`
	lib/vec/vec2d.ci:15: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.references:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.references:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.references:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.references:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.references:
	lib/vec/vec4f.ci:58: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.references:
	lib/vec/vec2d.ci:15: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036f0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:59: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.references:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.references:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.references:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.references:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.references:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.references:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.references:
	lib/vec/vec4f.ci:59: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.references:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c08>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:60: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.references:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.references:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.references:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.references:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.references:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.references:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.references:
	lib/vec/vec4f.ci:60: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.references:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004120>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.references:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.references:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.references:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.references:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.references:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.references:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004518>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.references:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.references:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.references:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.references:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.references:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.references:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004910>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.references:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.references:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.references:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.references:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.references:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.references:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004d08>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.references:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.references:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.references:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.references:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.references:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.references:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005100>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:62: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.references:
	lib/vec/vec4f.ci:62: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.references:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0052b8>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:63: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.references:
	lib/vec/vec4f.ci:63: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.references:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005768>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.references:
	internal references: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.references:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.references:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006778>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.value: nfc(5)
.references:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal references: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.references:
	lib/stdlib.ci:48: referenced as `abort`
	lib/stdlib.ci:25: referenced as `abort`
	lib/stdlib.ci:24: referenced as `abort`
	lib/stdlib.ci:23: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.references:
	lib/stdlib.ci:21: referenced as `error`
	lib/stdlib.ci:20: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.references:
	lib/stdlib.ci:18: referenced as `warn`
	lib/stdlib.ci:17: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.references:
	lib/stdlib.ci:15: referenced as `info`
	lib/stdlib.ci:14: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.references:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:12: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
	lib/stdlib.ci:9: referenced as `debug`
	lib/stdlib.ci:8: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.references:
	lib/stdlib.ci:6: referenced as `verbose`
	lib/stdlib.ci:5: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.references:
	lib/stdlib.ci:18: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
	lib/stdlib.ci:14: referenced as `noTrace`
	lib/stdlib.ci:12: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
	lib/stdlib.ci:5: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.references:
	lib/stdlib.ci:48: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
	lib/stdlib.ci:24: referenced as `defTrace`
	lib/stdlib.ci:23: referenced as `defTrace`
	lib/stdlib.ci:21: referenced as `defTrace`
	lib/stdlib.ci:20: referenced as `defTrace`
	lib/stdlib.ci:9: referenced as `defTrace`
	lib/stdlib.ci:8: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006fe8>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.references:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal references: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@007bc0>
.name: 'System'
.field exit: function (size: 0, offs: <@007e18>, cast: static const inline)
.field srand: function (size: 0, offs: <@008008>, cast: static const inline)
.field rand: function (size: 0, offs: <@008160>, cast: static const inline)
.field time: function (size: 0, offs: <@0082b8>, cast: static const inline)
.field clock: function (size: 0, offs: <@008410>, cast: static const inline)
.field millis: function (size: 0, offs: <@008568>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008750>, cast: static const inline)
.references:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e18>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.references:
	internal references: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008008>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.references:
	internal references: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008160>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.references:
	internal references: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0082b8>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.references:
	internal references: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008410>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.references:
	internal references: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008568>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.references:
	internal references: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008750>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.references:
	internal references: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:5: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:6: defined as `verbose(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.references:
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:31: referenced as `trace`
	test/lang/method.ci:26: referenced as `trace`
	test/lang/method.ci:7: referenced as `trace`
	lib/stdlib.ci:8: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:9: defined as `trace(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.references:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.references:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:69: referenced as `debug`
	test/lang/method.ci:63: referenced as `debug`
	lib/stdlib.ci:12: defined as `debug(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:14: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:15: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:17: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:18: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:20: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.references:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:21: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.references:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:27: referenced as `abort`
	lib/stdlib.ci:23: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:29: referenced as `abort`
	lib/stdlib.ci:28: referenced as `abort`
	lib/stdlib.ci:24: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.references:
	lib/stdlib.ci:25: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.value: void(condition ? void(0) : abort(void(message, inspect)))
.references:
	lib/std/string.ci:138: referenced as `assert`
	lib/std/string.ci:137: referenced as `assert`
	lib/stdlib.ci:27: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.value: void(condition ? void(0) : abort(message))
.references:
	lib/stdlib.ci:28: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
.references:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:173: referenced as `assert`
	lib/std/string.ci:166: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/stdlib.ci:29: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00ecd0>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.references:
	lib/stdlib.ci:43: referenced as `NotEquals`
	lib/stdlib.ci:31: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
.references:
	lib/stdlib.ci:44: referenced as `expected`
	lib/stdlib.ci:32: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
.references:
	lib/stdlib.ci:45: referenced as `returned`
	lib/stdlib.ci:33: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:34: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:35'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:46: referenced as `message`
	lib/stdlib.ci:35: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@04a6b8>
.name: 'assertEq'
.file: 'lib/stdlib.ci:39'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@04a6b8> - <@04a716>)
	lib/stdlib.ci:40: (10 bytes: <@04a6b8> - <@04a6c2>): if (bool(returned == expected))
	<assertEq @04a6b8>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @04a6ba>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @04a6bc>    : 57                         ceq.i32
	<assertEq+5 @04a6bd>    : 06 05 00 00                jz <assertEq+10 @04a6c2>
	lib/stdlib.ci:41: (1 byte: <@04a6c1> - <@04a6c2>): return;
	<assertEq+9 @04a6c1>    : 03                         ret
	lib/stdlib.ci:43: (41 bytes: <@04a6c2> - <@04a6eb>): details: NotEquals := {...}
	<assertEq+10 @04a6c2>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:44: (11 bytes: <@04a6c6> - <@04a6d1>): void(details.expected := (expected));
	<assertEq+14 @04a6c6>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<assertEq+19 @04a6cb>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @04a6cf>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:45: (11 bytes: <@04a6d1> - <@04a6dc>): void(details.returned := (returned));
	<assertEq+25 @04a6d1>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<assertEq+30 @04a6d6>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @04a6da>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:46: (3 bytes: <@04a6dc> - <@04a6df>): void(details.message := (message));
	<assertEq+36 @04a6dc>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@04a6df> - <@04a6eb>): void(details.argument := (null))
	<assertEq+39 @04a6df>   : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<assertEq+44 @04a6e4>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @04a6e9>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:48: (38 bytes: <@04a6eb> - <@04a711>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @04a6eb>   : 1f 88 bf 00 00             load.ref <@00bf88> ;"lib/stdlib.ci"
	<assertEq+56 @04a6f0>   : 1c 30 00 00 00             load.c32 48
	<assertEq+61 @04a6f5>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @04a6fa>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @04a6ff>   : 1f 02 c0 00 00             load.ref <@00c002> ;"assertion failed"
	<assertEq+76 @04a704>   : 1f d0 ec 00 00             load.ref <@00ecd0> ;NotEquals
	<assertEq+81 @04a709>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @04a70d>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @04a711>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @04a715>   : 03                         ret
.references:
	lib/stdlib.ci:50: referenced as `assertEq`
	lib/stdlib.ci:39: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:50'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.value: assertEq(void(void(expected, returned), null))
.references:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:50: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:54'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.value: int32(type.size)
.references:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:54: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@00fa10>
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@04a718>, cast: static const function)
.field floor: function (size: 24, offs: <@04a770>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 36, offs: <@04a788>, cast: static const function)
.field sign: function (size: 36, offs: <@04a7b0>, cast: static const function)
.field abs: function (size: 18, offs: <@04a7d8>, cast: static const function)
.field abs: function (size: 18, offs: <@04a7f0>, cast: static const function)
.field absMod: function (size: 27, offs: <@04a808>, cast: static const function)
.field absMod: function (size: 27, offs: <@04a828>, cast: static const function)
.field min: function (size: 17, offs: <@04a848>, cast: static const function)
.field min: function (size: 17, offs: <@04a860>, cast: static const function)
.field max: function (size: 17, offs: <@04a878>, cast: static const function)
.field max: function (size: 17, offs: <@04a890>, cast: static const function)
.field clamp: function (size: 30, offs: <@04a8a8>, cast: static const function)
.field clamp: function (size: 30, offs: <@04a8c8>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@04a8e8>, cast: static const function)
.field max: function (size: 72, offs: <@04a930>, cast: static const function)
.field sum: function (size: 40, offs: <@04a978>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@04a9a0>, cast: static const function)
.field cmp: function (size: 57, offs: <@04a9d0>, cast: static const function)
.field cmp: function (size: 57, offs: <@04aa10>, cast: static const function)
.field sinCos: function (size: 335, offs: <@04aa50>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@04aba0>, cast: static const function)
.field sinh: function (size: 241, offs: <@04ad18>, cast: static const function)
.field cosh: function (size: 75, offs: <@04ae10>, cast: static const function)
.field asin: function (size: 166, offs: <@04ae60>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field deg2rad: function (size: 0, offs: <@000000>, cast: static inline)
.field rad2deg: function (size: 0, offs: <@000000>, cast: static inline)
.references:
	test/stdc/test.math.ci:98: referenced as `Math`
	test/stdc/test.math.ci:97: referenced as `Math`
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:92: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:87: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:83: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:78: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:73: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:69: referenced as `Math`
	test/stdc/test.math.ci:66: referenced as `Math`
	test/stdc/test.math.ci:65: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:56: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:48: referenced as `Math`
	test/stdc/test.math.ci:47: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:42: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:37: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.ci:3: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
.references:
	test/stdc/test.math.ci:63: referenced as `pi`
	test/stdc/test.math.ci:62: referenced as `pi`
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	lib/std/math.ci:491: referenced as `pi`
	lib/std/math.ci:490: referenced as `pi`
	lib/std/math.ci:467: referenced as `pi`
	lib/std/math.ci:451: referenced as `pi`
	lib/std/math.ci:7: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
.references:
	lib/std/math.ci:8: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
.references:
	lib/std/math.ci:10: referenced as `ln2`
	lib/std/math.ci:9: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: float64(1.000000 / ln2)
.references:
	lib/std/math.ci:10: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
.references:
	lib/std/math.ci:12: referenced as `ln10`
	lib/std/math.ci:11: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: float64(1.000000 / ln10)
.references:
	lib/std/math.ci:12: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
.references:
	lib/std/math.ci:13: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
.references:
	lib/std/math.ci:14: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
.references:
	lib/std/math.ci:15: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
.references:
	lib/std/math.ci:16: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
.references:
	lib/std/math.ci:17: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: float64((0) / 0.000000)
.references:
	lib/std/math.ci:446: referenced as `nan`
	lib/std/math.ci:366: referenced as `nan`
	lib/std/math.ci:199: referenced as `nan`
	lib/std/math.ci:187: referenced as `nan`
	lib/std/math.ci:18: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: float64((1) / 0.000000)
.references:
	lib/std/math.ci:19: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@04a718>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@04a718> - <@04a76e>)
	lib/std/math.ci:23: (63 bytes: <@04a718> - <@04a757>): if (bool(x < (1)))
	<modf @04a718>      : 11 02                      dup.x2 sp(2)
	<modf+2 @04a71a>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @04a723>   : 88                         clt.f64
	<modf+12 @04a724>   : 06 33 00 00                jz <modf+63 @04a757>
	lib/std/math.ci:24: (39 bytes: <@04a728> - <@04a74f>): if (bool(x < (0)))
	<modf+16 @04a728>   : 11 02                      dup.x2 sp(2)
	<modf+18 @04a72a>   : 1a                         load.z64
	<modf+19 @04a72b>   : 88                         clt.f64
	<modf+20 @04a72c>   : 06 23 00 00                jz <modf+55 @04a74f>
	lib/std/math.ci:25: (17 bytes: <@04a730> - <@04a741>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @04a730>   : 1a                         load.z64
	<modf+25 @04a731>   : 11 04                      dup.x2 sp(4)
	<modf+27 @04a733>   : 80                         neg.f64
	<modf+28 @04a734>   : 10 05                      dup.x1 sp(5)
	<modf+30 @04a736>   : 1f 18 a7 04 00             load.ref <@04a718> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @04a73b>   : 02                         call
	<modf+36 @04a73c>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @04a740>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@04a741> - <@04a748>): float64(intPart := float64(-intPart));
	<modf+41 @04a741>   : 10 03                      dup.x1 sp(3)
	<modf+43 @04a743>   : 23                         load.i64
	<modf+44 @04a744>   : 80                         neg.f64
	<modf+45 @04a745>   : 10 05                      dup.x1 sp(5)
	<modf+47 @04a747>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@04a748> - <@04a74b>): return float64(.result := result);
	<modf+48 @04a748>   : 14 06                      set.x2 sp(6)
	<modf+50 @04a74a>   : 03                         ret
	<modf+51 @04a74b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@04a74f> - <@04a753>): float64(intPart := (0));
	<modf+55 @04a74f>   : 1a                         load.z64
	<modf+56 @04a750>   : 10 03                      dup.x1 sp(3)
	<modf+58 @04a752>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@04a753> - <@04a757>): return float64(.result := x);
	<modf+59 @04a753>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @04a756>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@04a757> - <@04a763>): result: float64 := float64(x % (1))
	<modf+63 @04a757>   : 11 02                      dup.x2 sp(2)
	<modf+65 @04a759>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @04a762>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@04a763> - <@04a76b>): float64(intPart := float64(x - result));
	<modf+75 @04a763>   : 11 04                      dup.x2 sp(4)
	<modf+77 @04a765>   : 11 02                      dup.x2 sp(2)
	<modf+79 @04a767>   : 82                         sub.f64
	<modf+80 @04a768>   : 10 05                      dup.x1 sp(5)
	<modf+82 @04a76a>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@04a76b> - <@04a76e>): return float64(.result := result);
	<modf+83 @04a76b>   : 14 06                      set.x2 sp(6)
	<modf+85 @04a76d>   : 03                         ret
.references:
	lib/std/math.ci:343: referenced as `modf`
	lib/std/math.ci:291: referenced as `modf`
	lib/std/math.ci:287: referenced as `modf`
	lib/std/math.ci:48: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@04a770>
.name: 'floor'
.file: 'lib/std/math.ci:46'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@04a770> - <@04a788>)
	lib/std/math.ci:47: (1 byte: <@04a770> - <@04a771>): result: float64
	<floor @04a770>      : 1b                         load.z128
	lib/std/math.ci:48: (20 bytes: <@04a771> - <@04a785>): modf(void(x, result));
	<floor+1 @04a771>    : 11 05                      dup.x2 sp(5)
	<floor+3 @04a773>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @04a777>    : 1f 18 a7 04 00             load.ref <@04a718> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @04a77c>   : 02                         call
	<floor+13 @04a77d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @04a781>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:49: (3 bytes: <@04a785> - <@04a788>): return float64(.result := result);
	<floor+21 @04a785>   : 14 05                      set.x2 sp(5)
	<floor+23 @04a787>   : 03                         ret
.references:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:52: referenced as `floor`
	lib/std/math.ci:51: referenced as `floor`
	lib/std/math.ci:46: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:51'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(-floor(float64(-x)))
.references:
	lib/std/math.ci:51: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:52'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: floor(float64(x + 0.500000))
.references:
	lib/std/math.ci:52: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@04a788>
.name: 'sign'
.file: 'lib/std/math.ci:58'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@04a788> - <@04a7ac>)
	lib/std/math.ci:59: (12 bytes: <@04a788> - <@04a794>): if (bool(x == (0)))
	<sign @04a788>      : 10 01                      dup.x1 sp(1)
	<sign+2 @04a78a>    : 19                         load.z32
	<sign+3 @04a78b>    : 77                         ceq.f32
	<sign+4 @04a78c>    : 06 08 00 00                jz <sign+12 @04a794>
	lib/std/math.ci:60: (4 bytes: <@04a790> - <@04a794>): return int32(.result := 0);
	<sign+8 @04a790>    : 19                         load.z32
	<sign+9 @04a791>    : 13 03                      set.x1 sp(3)
	<sign+11 @04a793>   : 03                         ret
	lib/std/math.ci:62: (16 bytes: <@04a794> - <@04a7a4>): if (bool(x < (0)))
	<sign+12 @04a794>   : 10 01                      dup.x1 sp(1)
	<sign+14 @04a796>   : 19                         load.z32
	<sign+15 @04a797>   : 78                         clt.f32
	<sign+16 @04a798>   : 06 0c 00 00                jz <sign+28 @04a7a4>
	lib/std/math.ci:63: (8 bytes: <@04a79c> - <@04a7a4>): return int32(.result := int32(-1));
	<sign+20 @04a79c>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @04a7a1>   : 13 03                      set.x1 sp(3)
	<sign+27 @04a7a3>   : 03                         ret
	lib/std/math.ci:65: (8 bytes: <@04a7a4> - <@04a7ac>): return int32(.result := 1);
	<sign+28 @04a7a4>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @04a7a9>   : 13 03                      set.x1 sp(3)
	<sign+35 @04a7ab>   : 03                         ret
.references:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:58: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@04a7b0>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float64 (size: 8, offs: <+12>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@04a7b0> - <@04a7d4>)
	lib/std/math.ci:68: (12 bytes: <@04a7b0> - <@04a7bc>): if (bool(x == (0)))
	<sign @04a7b0>      : 11 01                      dup.x2 sp(1)
	<sign+2 @04a7b2>    : 1a                         load.z64
	<sign+3 @04a7b3>    : 87                         ceq.f64
	<sign+4 @04a7b4>    : 06 08 00 00                jz <sign+12 @04a7bc>
	lib/std/math.ci:69: (4 bytes: <@04a7b8> - <@04a7bc>): return int32(.result := 0);
	<sign+8 @04a7b8>    : 19                         load.z32
	<sign+9 @04a7b9>    : 13 04                      set.x1 sp(4)
	<sign+11 @04a7bb>   : 03                         ret
	lib/std/math.ci:71: (16 bytes: <@04a7bc> - <@04a7cc>): if (bool(x < (0)))
	<sign+12 @04a7bc>   : 11 01                      dup.x2 sp(1)
	<sign+14 @04a7be>   : 1a                         load.z64
	<sign+15 @04a7bf>   : 88                         clt.f64
	<sign+16 @04a7c0>   : 06 0c 00 00                jz <sign+28 @04a7cc>
	lib/std/math.ci:72: (8 bytes: <@04a7c4> - <@04a7cc>): return int32(.result := int32(-1));
	<sign+20 @04a7c4>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @04a7c9>   : 13 04                      set.x1 sp(4)
	<sign+27 @04a7cb>   : 03                         ret
	lib/std/math.ci:74: (8 bytes: <@04a7cc> - <@04a7d4>): return int32(.result := 1);
	<sign+28 @04a7cc>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @04a7d1>   : 13 04                      set.x1 sp(4)
	<sign+35 @04a7d3>   : 03                         ret
.references:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04a7d8>
.name: 'abs'
.file: 'lib/std/math.ci:83'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@04a7d8> - <@04a7ea>)
	lib/std/math.ci:84: (14 bytes: <@04a7d8> - <@04a7e6>): if (bool(x < (0)))
	<abs @04a7d8>      : 10 01                      dup.x1 sp(1)
	<abs+2 @04a7da>    : 19                         load.z32
	<abs+3 @04a7db>    : 78                         clt.f32
	<abs+4 @04a7dc>    : 06 0a 00 00                jz <abs+14 @04a7e6>
	lib/std/math.ci:85: (6 bytes: <@04a7e0> - <@04a7e6>): return float32(.result := float32(-x));
	<abs+8 @04a7e0>    : 10 01                      dup.x1 sp(1)
	<abs+10 @04a7e2>   : 70                         neg.f32
	<abs+11 @04a7e3>   : 13 03                      set.x1 sp(3)
	<abs+13 @04a7e5>   : 03                         ret
	lib/std/math.ci:87: (4 bytes: <@04a7e6> - <@04a7ea>): return float32(.result := x);
	<abs+14 @04a7e6>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @04a7e9>   : 03                         ret
.references:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:83: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04a7f0>
.name: 'abs'
.file: 'lib/std/math.ci:89'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@04a7f0> - <@04a802>)
	lib/std/math.ci:90: (14 bytes: <@04a7f0> - <@04a7fe>): if (bool(x < (0)))
	<abs @04a7f0>      : 11 01                      dup.x2 sp(1)
	<abs+2 @04a7f2>    : 1a                         load.z64
	<abs+3 @04a7f3>    : 88                         clt.f64
	<abs+4 @04a7f4>    : 06 0a 00 00                jz <abs+14 @04a7fe>
	lib/std/math.ci:91: (6 bytes: <@04a7f8> - <@04a7fe>): return float64(.result := float64(-x));
	<abs+8 @04a7f8>    : 11 01                      dup.x2 sp(1)
	<abs+10 @04a7fa>   : 80                         neg.f64
	<abs+11 @04a7fb>   : 14 05                      set.x2 sp(5)
	<abs+13 @04a7fd>   : 03                         ret
	lib/std/math.ci:93: (4 bytes: <@04a7fe> - <@04a802>): return float64(.result := x);
	<abs+14 @04a7fe>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @04a801>   : 03                         ret
.references:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.ci:317: referenced as `abs`
	lib/std/math.ci:89: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04a808>
.name: 'absMod'
.file: 'lib/std/math.ci:95'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@04a808> - <@04a823>)
	lib/std/math.ci:96: (23 bytes: <@04a808> - <@04a81f>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @04a808>      : 10 02                      dup.x1 sp(2)
	<absMod+2 @04a80a>    : 10 02                      dup.x1 sp(2)
	<absMod+4 @04a80c>    : 75                         mod.f32
	<absMod+5 @04a80d>    : 10 00                      dup.x1 sp(0)
	<absMod+7 @04a80f>    : 13 04                      set.x1 sp(4)
	<absMod+9 @04a811>    : 19                         load.z32
	<absMod+10 @04a812>   : 78                         clt.f32
	<absMod+11 @04a813>   : 06 0c 00 00                jz <absMod+23 @04a81f>
	lib/std/math.ci:97: (8 bytes: <@04a817> - <@04a81f>): return float32(.result := float32(val + mod));
	<absMod+15 @04a817>   : 10 02                      dup.x1 sp(2)
	<absMod+17 @04a819>   : 10 02                      dup.x1 sp(2)
	<absMod+19 @04a81b>   : 71                         add.f32
	<absMod+20 @04a81c>   : 13 04                      set.x1 sp(4)
	<absMod+22 @04a81e>   : 03                         ret
	lib/std/math.ci:99: (4 bytes: <@04a81f> - <@04a823>): return float32(.result := val);
	<absMod+23 @04a81f>   : 16 03 02                   mov.x1 sp(3, 2)
	<absMod+26 @04a822>   : 03                         ret
.references:
	test/stdc/test.math.ci:98: referenced as `absMod`
	test/stdc/test.math.ci:97: referenced as `absMod`
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:92: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:87: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	lib/std/math.ci:95: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04a828>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@04a828> - <@04a843>)
	lib/std/math.ci:102: (23 bytes: <@04a828> - <@04a83f>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @04a828>      : 11 03                      dup.x2 sp(3)
	<absMod+2 @04a82a>    : 11 03                      dup.x2 sp(3)
	<absMod+4 @04a82c>    : 85                         mod.f64
	<absMod+5 @04a82d>    : 11 00                      dup.x2 sp(0)
	<absMod+7 @04a82f>    : 14 07                      set.x2 sp(7)
	<absMod+9 @04a831>    : 1a                         load.z64
	<absMod+10 @04a832>   : 88                         clt.f64
	<absMod+11 @04a833>   : 06 0c 00 00                jz <absMod+23 @04a83f>
	lib/std/math.ci:103: (8 bytes: <@04a837> - <@04a83f>): return float64(.result := float64(val + mod));
	<absMod+15 @04a837>   : 11 03                      dup.x2 sp(3)
	<absMod+17 @04a839>   : 11 03                      dup.x2 sp(3)
	<absMod+19 @04a83b>   : 81                         add.f64
	<absMod+20 @04a83c>   : 14 07                      set.x2 sp(7)
	<absMod+22 @04a83e>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@04a83f> - <@04a843>): return float64(.result := val);
	<absMod+23 @04a83f>   : 17 05 03                   mov.x2 sp(5, 3)
	<absMod+26 @04a842>   : 03                         ret
.references:
	test/stdc/test.math.ci:84: referenced as `absMod`
	test/stdc/test.math.ci:83: referenced as `absMod`
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:78: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:73: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04a848>
.name: 'min'
.file: 'lib/std/math.ci:114'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04a848> - <@04a859>)
	lib/std/math.ci:115: (13 bytes: <@04a848> - <@04a855>): if (bool(a < b))
	<min @04a848>      : 10 02                      dup.x1 sp(2)
	<min+2 @04a84a>    : 10 02                      dup.x1 sp(2)
	<min+4 @04a84c>    : 78                         clt.f32
	<min+5 @04a84d>    : 06 08 00 00                jz <min+13 @04a855>
	lib/std/math.ci:116: (4 bytes: <@04a851> - <@04a855>): return float32(.result := a);
	<min+9 @04a851>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @04a854>   : 03                         ret
	lib/std/math.ci:118: (4 bytes: <@04a855> - <@04a859>): return float32(.result := b);
	<min+13 @04a855>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @04a858>   : 03                         ret
.references:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:114: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04a860>
.name: 'min'
.file: 'lib/std/math.ci:120'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04a860> - <@04a871>)
	lib/std/math.ci:121: (13 bytes: <@04a860> - <@04a86d>): if (bool(a < b))
	<min @04a860>      : 11 03                      dup.x2 sp(3)
	<min+2 @04a862>    : 11 03                      dup.x2 sp(3)
	<min+4 @04a864>    : 88                         clt.f64
	<min+5 @04a865>    : 06 08 00 00                jz <min+13 @04a86d>
	lib/std/math.ci:122: (4 bytes: <@04a869> - <@04a86d>): return float64(.result := a);
	<min+9 @04a869>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @04a86c>   : 03                         ret
	lib/std/math.ci:124: (4 bytes: <@04a86d> - <@04a871>): return float64(.result := b);
	<min+13 @04a86d>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @04a870>   : 03                         ret
.references:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:120: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04a878>
.name: 'max'
.file: 'lib/std/math.ci:132'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04a878> - <@04a889>)
	lib/std/math.ci:133: (13 bytes: <@04a878> - <@04a885>): if (bool(a > b))
	<max @04a878>      : 10 02                      dup.x1 sp(2)
	<max+2 @04a87a>    : 10 02                      dup.x1 sp(2)
	<max+4 @04a87c>    : 79                         cgt.f32
	<max+5 @04a87d>    : 06 08 00 00                jz <max+13 @04a885>
	lib/std/math.ci:134: (4 bytes: <@04a881> - <@04a885>): return float32(.result := a);
	<max+9 @04a881>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @04a884>   : 03                         ret
	lib/std/math.ci:136: (4 bytes: <@04a885> - <@04a889>): return float32(.result := b);
	<max+13 @04a885>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @04a888>   : 03                         ret
.references:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:132: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04a890>
.name: 'max'
.file: 'lib/std/math.ci:138'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04a890> - <@04a8a1>)
	lib/std/math.ci:139: (13 bytes: <@04a890> - <@04a89d>): if (bool(a > b))
	<max @04a890>      : 11 03                      dup.x2 sp(3)
	<max+2 @04a892>    : 11 03                      dup.x2 sp(3)
	<max+4 @04a894>    : 89                         cgt.f64
	<max+5 @04a895>    : 06 08 00 00                jz <max+13 @04a89d>
	lib/std/math.ci:140: (4 bytes: <@04a899> - <@04a89d>): return float64(.result := a);
	<max+9 @04a899>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @04a89c>   : 03                         ret
	lib/std/math.ci:142: (4 bytes: <@04a89d> - <@04a8a1>): return float64(.result := b);
	<max+13 @04a89d>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @04a8a0>   : 03                         ret
.references:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:138: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04a8a8>
.name: 'clamp'
.file: 'lib/std/math.ci:150'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@04a8a8> - <@04a8c6>)
	lib/std/math.ci:151: (13 bytes: <@04a8a8> - <@04a8b5>): if (bool(t < a))
	<clamp @04a8a8>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @04a8aa>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @04a8ac>    : 78                         clt.f32
	<clamp+5 @04a8ad>    : 06 08 00 00                jz <clamp+13 @04a8b5>
	lib/std/math.ci:152: (4 bytes: <@04a8b1> - <@04a8b5>): return float32(.result := a);
	<clamp+9 @04a8b1>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @04a8b4>   : 03                         ret
	lib/std/math.ci:154: (13 bytes: <@04a8b5> - <@04a8c2>): if (bool(t > b))
	<clamp+13 @04a8b5>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @04a8b7>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @04a8b9>   : 79                         cgt.f32
	<clamp+18 @04a8ba>   : 06 08 00 00                jz <clamp+26 @04a8c2>
	lib/std/math.ci:155: (4 bytes: <@04a8be> - <@04a8c2>): return float32(.result := b);
	<clamp+22 @04a8be>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @04a8c1>   : 03                         ret
	lib/std/math.ci:157: (4 bytes: <@04a8c2> - <@04a8c6>): return float32(.result := t);
	<clamp+26 @04a8c2>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @04a8c5>   : 03                         ret
.references:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:178: referenced as `clamp`
	lib/std/math.ci:150: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04a8c8>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@04a8c8> - <@04a8e6>)
	lib/std/math.ci:160: (13 bytes: <@04a8c8> - <@04a8d5>): if (bool(t < a))
	<clamp @04a8c8>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @04a8ca>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @04a8cc>    : 88                         clt.f64
	<clamp+5 @04a8cd>    : 06 08 00 00                jz <clamp+13 @04a8d5>
	lib/std/math.ci:161: (4 bytes: <@04a8d1> - <@04a8d5>): return float64(.result := a);
	<clamp+9 @04a8d1>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @04a8d4>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@04a8d5> - <@04a8e2>): if (bool(t > b))
	<clamp+13 @04a8d5>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @04a8d7>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @04a8d9>   : 89                         cgt.f64
	<clamp+18 @04a8da>   : 06 08 00 00                jz <clamp+26 @04a8e2>
	lib/std/math.ci:164: (4 bytes: <@04a8de> - <@04a8e2>): return float64(.result := b);
	<clamp+22 @04a8de>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @04a8e1>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@04a8e2> - <@04a8e6>): return float64(.result := t);
	<clamp+26 @04a8e2>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @04a8e5>   : 03                         ret
.references:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:179: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:173'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: float32(a + float32(t * (float32(b - a))))
.references:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:173: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:174'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: float64(a + float64(t * (float64(b - a))))
.references:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:174: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:176'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.references:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:178: referenced as `smooth`
	lib/std/math.ci:176: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:177'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.references:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:179: referenced as `smooth`
	lib/std/math.ci:177: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:178'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.references:
	test/stdc/test.math.ci:37: referenced as `smooth`
	lib/std/math.ci:178: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:179'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.references:
	test/stdc/test.math.ci:38: referenced as `smooth`
	lib/std/math.ci:179: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04a8e8>
.name: 'min'
.file: 'lib/std/math.ci:185'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04a8e8> - <@04a930>)
	lib/std/math.ci:186: (13 bytes: <@04a8e8> - <@04a8f5>): if (bool(data.length == (0)))
	<min @04a8e8>      : 10 02                      dup.x1 sp(2)
	<min+2 @04a8ea>    : 19                         load.z32
	<min+3 @04a8eb>    : 57                         ceq.i32
	<min+4 @04a8ec>    : 06 09 00 00                jz <min+13 @04a8f5>
	lib/std/math.ci:187: (5 bytes: <@04a8f0> - <@04a8f5>): return float64(.result := nan);
	<min+8 @04a8f0>    : 1b                         load.z128
	<min+9 @04a8f1>    : 84                         div.f64
	<min+10 @04a8f2>   : 14 05                      set.x2 sp(5)
	<min+12 @04a8f4>   : 03                         ret
	lib/std/math.ci:189: (3 bytes: <@04a8f5> - <@04a8f8>): result: float64 := data[0]
	<min+13 @04a8f5>   : 10 01                      dup.x1 sp(1)
	<min+15 @04a8f7>   : 23                         load.i64
	lib/std/math.ci:190: (53 bytes: <@04a8f8> - <@04a92d>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @04a8f8>   : 1c 01 00 00 00             load.c32 1
	<min+21 @04a8fd>   : 04 23 00 00                jmp <min+56 @04a920>
	lib/std/math.ci:191: (27 bytes: <@04a901> - <@04a91c>): if (bool(result > data[i]))
	<min+25 @04a901>   : 11 01                      dup.x2 sp(1)
	<min+27 @04a903>   : 10 06                      dup.x1 sp(6)
	<min+29 @04a905>   : 10 03                      dup.x1 sp(3)
	<min+31 @04a907>   : 0d 08 00 00                mad.u32 8
	<min+35 @04a90b>   : 23                         load.i64
	<min+36 @04a90c>   : 89                         cgt.f64
	<min+37 @04a90d>   : 06 0f 00 00                jz <min+52 @04a91c>
	lib/std/math.ci:192: (11 bytes: <@04a911> - <@04a91c>): float64(result := data[i]);
	<min+41 @04a911>   : 10 04                      dup.x1 sp(4)
	<min+43 @04a913>   : 10 01                      dup.x1 sp(1)
	<min+45 @04a915>   : 0d 08 00 00                mad.u32 8
	<min+49 @04a919>   : 23                         load.i64
	<min+50 @04a91a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:190: (4 bytes: <@04a91c> - <@04a920>): int32(i := int32(i + 1))
	<min+52 @04a91c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:190: (9 bytes: <@04a920> - <@04a929>): bool(i < (data.length))
	<min+56 @04a920>   : 10 00                      dup.x1 sp(0)
	<min+58 @04a922>   : 10 06                      dup.x1 sp(6)
	<min+60 @04a924>   : 58                         clt.i32
	<min+61 @04a925>   : 05 dc ff ff                jnz <min+25 @04a901>
	<min+65 @04a929>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:195: (3 bytes: <@04a92d> - <@04a930>): return float64(.result := result);
	<min+69 @04a92d>   : 14 05                      set.x2 sp(5)
	<min+71 @04a92f>   : 03                         ret
.references:
	test/stdc/test.math.ci:41: referenced as `min`
	test/stdc/test.math.ci:40: referenced as `min`
	lib/std/math.ci:185: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04a930>
.name: 'max'
.file: 'lib/std/math.ci:197'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04a930> - <@04a978>)
	lib/std/math.ci:198: (13 bytes: <@04a930> - <@04a93d>): if (bool(data.length == (0)))
	<max @04a930>      : 10 02                      dup.x1 sp(2)
	<max+2 @04a932>    : 19                         load.z32
	<max+3 @04a933>    : 57                         ceq.i32
	<max+4 @04a934>    : 06 09 00 00                jz <max+13 @04a93d>
	lib/std/math.ci:199: (5 bytes: <@04a938> - <@04a93d>): return float64(.result := nan);
	<max+8 @04a938>    : 1b                         load.z128
	<max+9 @04a939>    : 84                         div.f64
	<max+10 @04a93a>   : 14 05                      set.x2 sp(5)
	<max+12 @04a93c>   : 03                         ret
	lib/std/math.ci:201: (3 bytes: <@04a93d> - <@04a940>): result: float64 := data[0]
	<max+13 @04a93d>   : 10 01                      dup.x1 sp(1)
	<max+15 @04a93f>   : 23                         load.i64
	lib/std/math.ci:202: (53 bytes: <@04a940> - <@04a975>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @04a940>   : 1c 01 00 00 00             load.c32 1
	<max+21 @04a945>   : 04 23 00 00                jmp <max+56 @04a968>
	lib/std/math.ci:203: (27 bytes: <@04a949> - <@04a964>): if (bool(result < data[i]))
	<max+25 @04a949>   : 11 01                      dup.x2 sp(1)
	<max+27 @04a94b>   : 10 06                      dup.x1 sp(6)
	<max+29 @04a94d>   : 10 03                      dup.x1 sp(3)
	<max+31 @04a94f>   : 0d 08 00 00                mad.u32 8
	<max+35 @04a953>   : 23                         load.i64
	<max+36 @04a954>   : 88                         clt.f64
	<max+37 @04a955>   : 06 0f 00 00                jz <max+52 @04a964>
	lib/std/math.ci:204: (11 bytes: <@04a959> - <@04a964>): float64(result := data[i]);
	<max+41 @04a959>   : 10 04                      dup.x1 sp(4)
	<max+43 @04a95b>   : 10 01                      dup.x1 sp(1)
	<max+45 @04a95d>   : 0d 08 00 00                mad.u32 8
	<max+49 @04a961>   : 23                         load.i64
	<max+50 @04a962>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:202: (4 bytes: <@04a964> - <@04a968>): int32(i := int32(i + 1))
	<max+52 @04a964>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:202: (9 bytes: <@04a968> - <@04a971>): bool(i < (data.length))
	<max+56 @04a968>   : 10 00                      dup.x1 sp(0)
	<max+58 @04a96a>   : 10 06                      dup.x1 sp(6)
	<max+60 @04a96c>   : 58                         clt.i32
	<max+61 @04a96d>   : 05 dc ff ff                jnz <max+25 @04a949>
	<max+65 @04a971>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:207: (3 bytes: <@04a975> - <@04a978>): return float64(.result := result);
	<max+69 @04a975>   : 14 05                      set.x2 sp(5)
	<max+71 @04a977>   : 03                         ret
.references:
	test/stdc/test.math.ci:43: referenced as `max`
	test/stdc/test.math.ci:42: referenced as `max`
	lib/std/math.ci:197: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@04a978>
.name: 'sum'
.file: 'lib/std/math.ci:210'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@04a978> - <@04a9a0>)
	lib/std/math.ci:211: (1 byte: <@04a978> - <@04a979>): result: float64 := 0
	<sum @04a978>      : 1b                         load.z128
	lib/std/math.ci:212: (36 bytes: <@04a979> - <@04a99d>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @04a979>    : 6a                         i64.2i32
	<sum+2 @04a97a>    : 04 16 00 00                jmp <sum+24 @04a990>
	lib/std/math.ci:213: (14 bytes: <@04a97e> - <@04a98c>): float64(result := float64(result + data[i]));
	<sum+6 @04a97e>    : 11 01                      dup.x2 sp(1)
	<sum+8 @04a980>    : 10 06                      dup.x1 sp(6)
	<sum+10 @04a982>   : 10 03                      dup.x1 sp(3)
	<sum+12 @04a984>   : 0d 08 00 00                mad.u32 8
	<sum+16 @04a988>   : 23                         load.i64
	<sum+17 @04a989>   : 81                         add.f64
	<sum+18 @04a98a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:212: (4 bytes: <@04a98c> - <@04a990>): int32(i := int32(i + 1))
	<sum+20 @04a98c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:212: (9 bytes: <@04a990> - <@04a999>): bool(i < (data.length))
	<sum+24 @04a990>   : 10 00                      dup.x1 sp(0)
	<sum+26 @04a992>   : 10 06                      dup.x1 sp(6)
	<sum+28 @04a994>   : 58                         clt.i32
	<sum+29 @04a995>   : 05 e9 ff ff                jnz <sum+6 @04a97e>
	<sum+33 @04a999>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:215: (3 bytes: <@04a99d> - <@04a9a0>): return float64(.result := result);
	<sum+37 @04a99d>   : 14 05                      set.x2 sp(5)
	<sum+39 @04a99f>   : 03                         ret
.references:
	test/stdc/test.math.ci:48: referenced as `sum`
	test/stdc/test.math.ci:47: referenced as `sum`
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	lib/std/math.ci:210: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:224'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.value: (a0)
.references:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:224: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:225'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.value: (float64(a0 + float64(x * a1)))
.references:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:226: referenced as `eval`
	lib/std/math.ci:225: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:226'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.references:
	test/stdc/test.math.ci:54: referenced as `eval`
	lib/std/math.ci:227: referenced as `eval`
	lib/std/math.ci:226: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:227'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.references:
	test/stdc/test.math.ci:55: referenced as `eval`
	lib/std/math.ci:227: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@04a9a0>
.name: 'eval'
.file: 'lib/std/math.ci:228'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@04a9a0> - <@04a9cf>)
	lib/std/math.ci:229: (1 byte: <@04a9a0> - <@04a9a1>): result: float64 := 0
	<eval @04a9a0>      : 1a                         load.z64
	lib/std/math.ci:230: (43 bytes: <@04a9a1> - <@04a9cc>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @04a9a1>    : 10 04                      dup.x1 sp(4)
	<eval+3 @04a9a3>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @04a9a7>    : 04 19 00 00                jmp <eval+32 @04a9c0>
	lib/std/math.ci:231: (17 bytes: <@04a9ab> - <@04a9bc>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @04a9ab>   : 11 01                      dup.x2 sp(1)
	<eval+13 @04a9ad>   : 11 08                      dup.x2 sp(8)
	<eval+15 @04a9af>   : 83                         mul.f64
	<eval+16 @04a9b0>   : 10 06                      dup.x1 sp(6)
	<eval+18 @04a9b2>   : 10 03                      dup.x1 sp(3)
	<eval+20 @04a9b4>   : 0d 08 00 00                mad.u32 8
	<eval+24 @04a9b8>   : 23                         load.i64
	<eval+25 @04a9b9>   : 81                         add.f64
	<eval+26 @04a9ba>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:230: (4 bytes: <@04a9bc> - <@04a9c0>): int32(i := int32(i - 1))
	<eval+28 @04a9bc>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:230: (8 bytes: <@04a9c0> - <@04a9c8>): bool(i >= 0)
	<eval+32 @04a9c0>   : 10 00                      dup.x1 sp(0)
	<eval+34 @04a9c2>   : 19                         load.z32
	<eval+35 @04a9c3>   : 58                         clt.i32
	<eval+36 @04a9c4>   : 06 e7 ff ff                jz <eval+11 @04a9ab>
	<eval+40 @04a9c8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:233: (3 bytes: <@04a9cc> - <@04a9cf>): return float64(.result := result);
	<eval+44 @04a9cc>   : 14 07                      set.x2 sp(7)
	<eval+46 @04a9ce>   : 03                         ret
.references:
	test/stdc/test.math.ci:57: referenced as `eval`
	test/stdc/test.math.ci:56: referenced as `eval`
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:228: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@04a9d0>
.name: 'cmp'
.file: 'lib/std/math.ci:236'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@04a9d0> - <@04aa09>)
	lib/std/math.ci:237: (53 bytes: <@04a9d0> - <@04aa05>): if (bool(a < b))
	<cmp @04a9d0>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @04a9d2>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @04a9d4>    : 78                         clt.f32
	<cmp+5 @04a9d5>    : 06 1c 00 00                jz <cmp+33 @04a9f1>
	lib/std/math.ci:238: (20 bytes: <@04a9d9> - <@04a9ed>): if (bool(eps < (float32(b - a))))
	<cmp+9 @04a9d9>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @04a9db>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @04a9dd>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @04a9df>   : 72                         sub.f32
	<cmp+16 @04a9e0>   : 78                         clt.f32
	<cmp+17 @04a9e1>   : 06 0c 00 00                jz <cmp+29 @04a9ed>
	lib/std/math.ci:239: (8 bytes: <@04a9e5> - <@04a9ed>): return int32(.result := int32(-1));
	<cmp+21 @04a9e5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04a9ea>   : 13 05                      set.x1 sp(5)
	<cmp+28 @04a9ec>   : 03                         ret
	<cmp+29 @04a9ed>   : 04 18 00 00                jmp <cmp+53 @04aa05>
	lib/std/math.ci:243: (20 bytes: <@04a9f1> - <@04aa05>): if (bool(eps < (float32(a - b))))
	<cmp+33 @04a9f1>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @04a9f3>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @04a9f5>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @04a9f7>   : 72                         sub.f32
	<cmp+40 @04a9f8>   : 78                         clt.f32
	<cmp+41 @04a9f9>   : 06 0c 00 00                jz <cmp+53 @04aa05>
	lib/std/math.ci:244: (8 bytes: <@04a9fd> - <@04aa05>): return int32(.result := int32(+1));
	<cmp+45 @04a9fd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @04aa02>   : 13 05                      set.x1 sp(5)
	<cmp+52 @04aa04>   : 03                         ret
	lib/std/math.ci:247: (4 bytes: <@04aa05> - <@04aa09>): return int32(.result := 0);
	<cmp+53 @04aa05>   : 19                         load.z32
	<cmp+54 @04aa06>   : 13 05                      set.x1 sp(5)
	<cmp+56 @04aa08>   : 03                         ret
.references:
	test/stdc/test.math.ci:69: referenced as `cmp`
	lib/std/math.ci:236: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@04aa10>
.name: 'cmp'
.file: 'lib/std/math.ci:249'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@04aa10> - <@04aa49>)
	lib/std/math.ci:250: (53 bytes: <@04aa10> - <@04aa45>): if (bool(a < b))
	<cmp @04aa10>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @04aa12>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @04aa14>    : 88                         clt.f64
	<cmp+5 @04aa15>    : 06 1c 00 00                jz <cmp+33 @04aa31>
	lib/std/math.ci:251: (20 bytes: <@04aa19> - <@04aa2d>): if (bool(eps < (float64(b - a))))
	<cmp+9 @04aa19>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @04aa1b>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @04aa1d>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @04aa1f>   : 82                         sub.f64
	<cmp+16 @04aa20>   : 88                         clt.f64
	<cmp+17 @04aa21>   : 06 0c 00 00                jz <cmp+29 @04aa2d>
	lib/std/math.ci:252: (8 bytes: <@04aa25> - <@04aa2d>): return int32(.result := int32(-1));
	<cmp+21 @04aa25>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04aa2a>   : 13 08                      set.x1 sp(8)
	<cmp+28 @04aa2c>   : 03                         ret
	<cmp+29 @04aa2d>   : 04 18 00 00                jmp <cmp+53 @04aa45>
	lib/std/math.ci:256: (20 bytes: <@04aa31> - <@04aa45>): if (bool(eps < (float64(a - b))))
	<cmp+33 @04aa31>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @04aa33>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @04aa35>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @04aa37>   : 82                         sub.f64
	<cmp+40 @04aa38>   : 88                         clt.f64
	<cmp+41 @04aa39>   : 06 0c 00 00                jz <cmp+53 @04aa45>
	lib/std/math.ci:257: (8 bytes: <@04aa3d> - <@04aa45>): return int32(.result := int32(+1));
	<cmp+45 @04aa3d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @04aa42>   : 13 08                      set.x1 sp(8)
	<cmp+52 @04aa44>   : 03                         ret
	lib/std/math.ci:260: (4 bytes: <@04aa45> - <@04aa49>): return int32(.result := 0);
	<cmp+53 @04aa45>   : 19                         load.z32
	<cmp+54 @04aa46>   : 13 08                      set.x1 sp(8)
	<cmp+56 @04aa48>   : 03                         ret
.references:
	test/stdc/test.math.ci:70: referenced as `cmp`
	lib/std/math.ci:249: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@04aa50>
.name: 'sinCos'
.file: 'lib/std/math.ci:263'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@04aa50> - <@04ab9f>)
	lib/std/math.ci:277: (2 bytes: <@04aa50> - <@04aa52>): x: float64 := arg
	<sinCos @04aa50>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:278: (17 bytes: <@04aa52> - <@04aa63>): if (bool(x < (0)))
	<sinCos+2 @04aa52>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @04aa54>    : 1a                         load.z64
	<sinCos+5 @04aa55>    : 88                         clt.f64
	<sinCos+6 @04aa56>    : 06 0d 00 00                jz <sinCos+19 @04aa63>
	lib/std/math.ci:279: (1 byte: <@04aa5a> - <@04aa5b>): float64(x := float64(-x));
	<sinCos+10 @04aa5a>   : 80                         neg.f64
	lib/std/math.ci:280: (8 bytes: <@04aa5b> - <@04aa63>): int32(quad := int32(quad + 2));
	<sinCos+11 @04aa5b>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @04aa5d>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @04aa61>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:283: (1 byte: <@04aa63> - <@04aa64>): y: float64
	<sinCos+19 @04aa63>   : 1a                         load.z64
	lib/std/math.ci:284: (24 bytes: <@04aa64> - <@04aa7c>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @04aa64>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @04aa66>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @04aa6f>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @04aa78>   : 84                         div.f64
	<sinCos+41 @04aa79>   : 83                         mul.f64
	<sinCos+42 @04aa7a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:285: (124 bytes: <@04aa7c> - <@04aaf8>): if (bool(x > (32764)))
	<sinCos+44 @04aa7c>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @04aa7e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @04aa87>   : 89                         cgt.f64
	<sinCos+56 @04aa88>   : 06 54 00 00                jz <sinCos+140 @04aadc>
	lib/std/math.ci:286: (1 byte: <@04aa8c> - <@04aa8d>): e: float64
	<sinCos+60 @04aa8c>   : 1b                         load.z128
	lib/std/math.ci:287: (18 bytes: <@04aa8d> - <@04aa9f>): float64(y := modf(void(x, e)));
	<sinCos+61 @04aa8d>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @04aa8f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @04aa93>   : 1f 18 a7 04 00             load.ref <@04a718> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @04aa98>   : 02                         call
	<sinCos+73 @04aa99>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @04aa9d>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:288: (4 bytes: <@04aa9f> - <@04aaa3>): float64(e := float64(e + (quad)));
	<sinCos+79 @04aa9f>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @04aaa1>   : 5d                         i32.2f64
	<sinCos+82 @04aaa2>   : 81                         add.f64
	lib/std/math.ci:290: (1 byte: <@04aaa3> - <@04aaa4>): f: float64
	<sinCos+83 @04aaa3>   : 1b                         load.z128
	lib/std/math.ci:291: (30 bytes: <@04aaa4> - <@04aac2>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @04aaa4>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @04aaad>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @04aaaf>   : 83                         mul.f64
	<sinCos+96 @04aab0>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @04aab4>  : 1f 18 a7 04 00             load.ref <@04a718> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @04aab9>  : 02                         call
	<sinCos+106 @04aaba>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @04aabe>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:292: (18 bytes: <@04aac2> - <@04aad4>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @04aac2>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @04aac4>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @04aacd>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @04aacf>  : 83                         mul.f64
	<sinCos+128 @04aad0>  : 82                         sub.f64
	<sinCos+129 @04aad1>  : 8a                         f64.2i32
	<sinCos+130 @04aad2>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @04aad4>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @04aad8>  : 04 20 00 00                jmp <sinCos+168 @04aaf8>
	lib/std/math.ci:295: (3 bytes: <@04aadc> - <@04aadf>): k: int32 := x
	<sinCos+140 @04aadc>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @04aade>  : 8a                         f64.2i32
	lib/std/math.ci:296: (8 bytes: <@04aadf> - <@04aae7>): float64(y := float64(x - (k)));
	<sinCos+143 @04aadf>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @04aae1>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @04aae3>  : 5d                         i32.2f64
	<sinCos+148 @04aae4>  : 82                         sub.f64
	<sinCos+149 @04aae5>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:297: (7 bytes: <@04aae7> - <@04aaee>): int32(quad := int32(quad + k));
	<sinCos+151 @04aae7>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @04aae9>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @04aaeb>  : 51                         add.i32
	<sinCos+156 @04aaec>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:298: (6 bytes: <@04aaee> - <@04aaf4>): int32(quad := int32(quad & 3));
	<sinCos+158 @04aaee>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @04aaf0>  : 3f 02                      b32.and 0x003
	<sinCos+162 @04aaf2>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @04aaf4>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:300: (22 bytes: <@04aaf8> - <@04ab0e>): if (int32(quad & 1))
	<sinCos+168 @04aaf8>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @04aafa>  : 3f 01                      b32.and 0x001
	<sinCos+172 @04aafc>  : 06 12 00 00                jz <sinCos+190 @04ab0e>
	lib/std/math.ci:301: (14 bytes: <@04ab00> - <@04ab0e>): float64(y := float64((1) - y));
	<sinCos+176 @04ab00>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @04ab09>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @04ab0b>  : 82                         sub.f64
	<sinCos+188 @04ab0c>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:303: (13 bytes: <@04ab0e> - <@04ab1b>): if (bool(quad > 1))
	<sinCos+190 @04ab0e>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @04ab10>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @04ab15>  : 59                         cgt.i32
	<sinCos+198 @04ab16>  : 06 05 00 00                jz <sinCos+203 @04ab1b>
	lib/std/math.ci:304: (1 byte: <@04ab1a> - <@04ab1b>): float64(y := float64(-y));
	<sinCos+202 @04ab1a>  : 80                         neg.f64
	lib/std/math.ci:307: (5 bytes: <@04ab1b> - <@04ab20>): ysq: float64 := float64(y * y)
	<sinCos+203 @04ab1b>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @04ab1d>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @04ab1f>  : 83                         mul.f64
	lib/std/math.ci:308: (64 bytes: <@04ab20> - <@04ab60>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @04ab20>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @04ab29>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @04ab2b>  : 83                         mul.f64
	<sinCos+220 @04ab2c>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @04ab35>  : 81                         add.f64
	<sinCos+230 @04ab36>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @04ab38>  : 83                         mul.f64
	<sinCos+233 @04ab39>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @04ab42>  : 81                         add.f64
	<sinCos+243 @04ab43>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @04ab45>  : 83                         mul.f64
	<sinCos+246 @04ab46>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @04ab4f>  : 81                         add.f64
	<sinCos+256 @04ab50>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @04ab52>  : 83                         mul.f64
	<sinCos+259 @04ab53>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @04ab5c>  : 81                         add.f64
	<sinCos+269 @04ab5d>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @04ab5f>  : 83                         mul.f64
	lib/std/math.ci:309: (51 bytes: <@04ab60> - <@04ab93>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @04ab60>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @04ab62>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @04ab6b>  : 81                         add.f64
	<sinCos+284 @04ab6c>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @04ab6e>  : 83                         mul.f64
	<sinCos+287 @04ab6f>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @04ab78>  : 81                         add.f64
	<sinCos+297 @04ab79>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @04ab7b>  : 83                         mul.f64
	<sinCos+300 @04ab7c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @04ab85>  : 81                         add.f64
	<sinCos+310 @04ab86>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @04ab88>  : 83                         mul.f64
	<sinCos+313 @04ab89>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @04ab92>  : 81                         add.f64
	lib/std/math.ci:310: (12 bytes: <@04ab93> - <@04ab9f>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @04ab93>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @04ab95>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @04ab97>  : 84                         div.f64
	<sinCos+328 @04ab98>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @04ab9a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @04ab9e>  : 03                         ret
.references:
	lib/std/math.ci:317: referenced as `sinCos`
	lib/std/math.ci:314: referenced as `sinCos`
	lib/std/math.ci:263: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:314'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(arg, 0))
.references:
	test/stdc/test.math.ci:59: referenced as `sin`
	lib/std/math.ci:314: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:317'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(abs(arg), 1))
.references:
	test/stdc/test.math.ci:60: referenced as `cos`
	lib/std/math.ci:317: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@04aba0>
.name: 'tan'
.file: 'lib/std/math.ci:320'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@04aba0> - <@04ad13>)
	lib/std/math.ci:333: (1 byte: <@04aba0> - <@04aba1>): complement: bool := false
	<tan @04aba0>      : 19                         load.z32
	lib/std/math.ci:334: (1 byte: <@04aba1> - <@04aba2>): negate: bool := false
	<tan+1 @04aba1>    : 19                         load.z32
	lib/std/math.ci:336: (23 bytes: <@04aba2> - <@04abb9>): if (bool(arg < (0)))
	<tan+2 @04aba2>    : 11 03                      dup.x2 sp(3)
	<tan+4 @04aba4>    : 1a                         load.z64
	<tan+5 @04aba5>    : 88                         clt.f64
	<tan+6 @04aba6>    : 06 13 00 00                jz <tan+25 @04abb9>
	lib/std/math.ci:337: (5 bytes: <@04abaa> - <@04abaf>): float64(arg := float64(-arg));
	<tan+10 @04abaa>   : 11 03                      dup.x2 sp(3)
	<tan+12 @04abac>   : 80                         neg.f64
	<tan+13 @04abad>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:338: (10 bytes: <@04abaf> - <@04abb9>): bool(negate := true);
	<tan+15 @04abaf>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @04abb4>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @04abb8>   : 25                         store.i8
	lib/std/math.ci:340: (24 bytes: <@04abb9> - <@04abd1>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @04abb9>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @04abc2>   : 11 05                      dup.x2 sp(5)
	<tan+36 @04abc4>   : 83                         mul.f64
	<tan+37 @04abc5>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @04abce>   : 84                         div.f64
	<tan+47 @04abcf>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:342: (1 byte: <@04abd1> - <@04abd2>): e: float64
	<tan+49 @04abd1>   : 1b                         load.z128
	lib/std/math.ci:343: (16 bytes: <@04abd2> - <@04abe2>): x: float64 := modf(void(arg, e))
	<tan+50 @04abd2>   : 11 07                      dup.x2 sp(7)
	<tan+52 @04abd4>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @04abd8>   : 1f 18 a7 04 00             load.ref <@04a718> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @04abdd>   : 02                         call
	<tan+62 @04abde>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:344: (9 bytes: <@04abe2> - <@04abeb>): i: int32 := int32(int32(e) % 4)
	<tan+66 @04abe2>   : 11 02                      dup.x2 sp(2)
	<tan+68 @04abe4>   : 8a                         f64.2i32
	<tan+69 @04abe5>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @04abea>   : 55                         mod.i32
	lib/std/math.ci:346: (122 bytes: <@04abeb> - <@04ac65>): if (bool(i == 0))
	<tan+75 @04abeb>   : 10 00                      dup.x1 sp(0)
	<tan+77 @04abed>   : 19                         load.z32
	<tan+78 @04abee>   : 57                         ceq.i32
	<tan+79 @04abef>   : 05 76 00 00                jnz <tan+197 @04ac65>
	lib/std/math.ci:347: (114 bytes: <@04abf3> - <@04ac65>): if (bool(i == 1))
	<tan+83 @04abf3>   : 10 00                      dup.x1 sp(0)
	<tan+85 @04abf5>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @04abfa>   : 57                         ceq.i32
	<tan+91 @04abfb>   : 06 20 00 00                jz <tan+123 @04ac1b>
	lib/std/math.ci:348: (14 bytes: <@04abff> - <@04ac0d>): float64(x := float64((1) - x));
	<tan+95 @04abff>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @04ac08>  : 11 03                      dup.x2 sp(3)
	<tan+106 @04ac0a>  : 82                         sub.f64
	<tan+107 @04ac0b>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:349: (10 bytes: <@04ac0d> - <@04ac17>): bool(complement := true);
	<tan+109 @04ac0d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @04ac12>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @04ac16>  : 25                         store.i8
	<tan+119 @04ac17>  : 04 4e 00 00                jmp <tan+197 @04ac65>
	lib/std/math.ci:351: (74 bytes: <@04ac1b> - <@04ac65>): if (bool(i == 2))
	<tan+123 @04ac1b>  : 10 00                      dup.x1 sp(0)
	<tan+125 @04ac1d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @04ac22>  : 57                         ceq.i32
	<tan+131 @04ac23>  : 06 1d 00 00                jz <tan+160 @04ac40>
	lib/std/math.ci:352: (11 bytes: <@04ac27> - <@04ac32>): bool(negate := bool(!negate));
	<tan+135 @04ac27>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @04ac2b>  : 20                         load.i8
	<tan+140 @04ac2c>  : 0b                         not.b32
	<tan+141 @04ac2d>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @04ac31>  : 25                         store.i8
	lib/std/math.ci:353: (10 bytes: <@04ac32> - <@04ac3c>): bool(complement := true);
	<tan+146 @04ac32>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @04ac37>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @04ac3b>  : 25                         store.i8
	<tan+156 @04ac3c>  : 04 29 00 00                jmp <tan+197 @04ac65>
	lib/std/math.ci:355: (37 bytes: <@04ac40> - <@04ac65>): if (bool(i == 3))
	<tan+160 @04ac40>  : 10 00                      dup.x1 sp(0)
	<tan+162 @04ac42>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @04ac47>  : 57                         ceq.i32
	<tan+168 @04ac48>  : 06 1d 00 00                jz <tan+197 @04ac65>
	lib/std/math.ci:356: (14 bytes: <@04ac4c> - <@04ac5a>): float64(x := float64((1) - x));
	<tan+172 @04ac4c>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @04ac55>  : 11 03                      dup.x2 sp(3)
	<tan+183 @04ac57>  : 82                         sub.f64
	<tan+184 @04ac58>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:357: (11 bytes: <@04ac5a> - <@04ac65>): bool(negate := bool(!negate));
	<tan+186 @04ac5a>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @04ac5e>  : 20                         load.i8
	<tan+191 @04ac5f>  : 0b                         not.b32
	<tan+192 @04ac60>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @04ac64>  : 25                         store.i8
	lib/std/math.ci:360: (5 bytes: <@04ac65> - <@04ac6a>): xsq: float64 := float64(x * x)
	<tan+197 @04ac65>  : 11 01                      dup.x2 sp(1)
	<tan+199 @04ac67>  : 11 03                      dup.x2 sp(3)
	<tan+201 @04ac69>  : 83                         mul.f64
	lib/std/math.ci:361: (64 bytes: <@04ac6a> - <@04acaa>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @04ac6a>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @04ac73>  : 11 02                      dup.x2 sp(2)
	<tan+213 @04ac75>  : 83                         mul.f64
	<tan+214 @04ac76>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @04ac7f>  : 81                         add.f64
	<tan+224 @04ac80>  : 11 02                      dup.x2 sp(2)
	<tan+226 @04ac82>  : 83                         mul.f64
	<tan+227 @04ac83>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @04ac8c>  : 81                         add.f64
	<tan+237 @04ac8d>  : 11 02                      dup.x2 sp(2)
	<tan+239 @04ac8f>  : 83                         mul.f64
	<tan+240 @04ac90>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @04ac99>  : 81                         add.f64
	<tan+250 @04ac9a>  : 11 02                      dup.x2 sp(2)
	<tan+252 @04ac9c>  : 83                         mul.f64
	<tan+253 @04ac9d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @04aca6>  : 81                         add.f64
	<tan+263 @04aca7>  : 11 05                      dup.x2 sp(5)
	<tan+265 @04aca9>  : 83                         mul.f64
	lib/std/math.ci:362: (39 bytes: <@04acaa> - <@04acd1>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @04acaa>  : 11 02                      dup.x2 sp(2)
	<tan+268 @04acac>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @04acb5>  : 81                         add.f64
	<tan+278 @04acb6>  : 11 04                      dup.x2 sp(4)
	<tan+280 @04acb8>  : 83                         mul.f64
	<tan+281 @04acb9>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @04acc2>  : 81                         add.f64
	<tan+291 @04acc3>  : 11 04                      dup.x2 sp(4)
	<tan+293 @04acc5>  : 83                         mul.f64
	<tan+294 @04acc6>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @04accf>  : 81                         add.f64
	<tan+304 @04acd0>  : 84                         div.f64
	lib/std/math.ci:364: (40 bytes: <@04acd1> - <@04acf9>): if (complement)
	<tan+305 @04acd1>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @04acd5>  : 20                         load.i8
	<tan+310 @04acd6>  : 06 23 00 00                jz <tan+345 @04acf9>
	lib/std/math.ci:365: (17 bytes: <@04acda> - <@04aceb>): if (bool(result == (0)))
	<tan+314 @04acda>  : 11 00                      dup.x2 sp(0)
	<tan+316 @04acdc>  : 1a                         load.z64
	<tan+317 @04acdd>  : 87                         ceq.f64
	<tan+318 @04acde>  : 06 0d 00 00                jz <tan+331 @04aceb>
	lib/std/math.ci:366: (9 bytes: <@04ace2> - <@04aceb>): return float64(.result := nan);
	<tan+322 @04ace2>  : 1b                         load.z128
	<tan+323 @04ace3>  : 84                         div.f64
	<tan+324 @04ace4>  : 14 10                      set.x2 sp(16)
	<tan+326 @04ace6>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @04acea>  : 03                         ret
	lib/std/math.ci:368: (14 bytes: <@04aceb> - <@04acf9>): float64(result := float64((1) / result));
	<tan+331 @04aceb>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @04acf4>  : 11 02                      dup.x2 sp(2)
	<tan+342 @04acf6>  : 84                         div.f64
	<tan+343 @04acf7>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:370: (19 bytes: <@04acf9> - <@04ad0c>): if (negate)
	<tan+345 @04acf9>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @04acfd>  : 20                         load.i8
	<tan+350 @04acfe>  : 06 0e 00 00                jz <tan+364 @04ad0c>
	lib/std/math.ci:371: (10 bytes: <@04ad02> - <@04ad0c>): return float64(.result := float64(-result));
	<tan+354 @04ad02>  : 11 00                      dup.x2 sp(0)
	<tan+356 @04ad04>  : 80                         neg.f64
	<tan+357 @04ad05>  : 14 10                      set.x2 sp(16)
	<tan+359 @04ad07>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @04ad0b>  : 03                         ret
	lib/std/math.ci:373: (7 bytes: <@04ad0c> - <@04ad13>): return float64(.result := result);
	<tan+364 @04ad0c>  : 14 0e                      set.x2 sp(14)
	<tan+366 @04ad0e>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @04ad12>  : 03                         ret
.references:
	test/stdc/test.math.ci:61: referenced as `tan`
	lib/std/math.ci:320: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@04ad18>
.name: 'sinh'
.file: 'lib/std/math.ci:377'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@04ad18> - <@04ae09>)
	lib/std/math.ci:389: (1 byte: <@04ad18> - <@04ad19>): negate: bool := false
	<sinh @04ad18>      : 19                         load.z32
	lib/std/math.ci:390: (23 bytes: <@04ad19> - <@04ad30>): if (bool(x < (0)))
	<sinh+1 @04ad19>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @04ad1b>    : 1a                         load.z64
	<sinh+4 @04ad1c>    : 88                         clt.f64
	<sinh+5 @04ad1d>    : 06 13 00 00                jz <sinh+24 @04ad30>
	lib/std/math.ci:391: (5 bytes: <@04ad21> - <@04ad26>): float64(x := float64(-x));
	<sinh+9 @04ad21>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @04ad23>   : 80                         neg.f64
	<sinh+12 @04ad24>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:392: (10 bytes: <@04ad26> - <@04ad30>): bool(negate := true);
	<sinh+14 @04ad26>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @04ad2b>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @04ad2f>   : 25                         store.i8
	lib/std/math.ci:395: (39 bytes: <@04ad30> - <@04ad57>): if (bool(x > (21)))
	<sinh+24 @04ad30>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @04ad32>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @04ad3b>   : 89                         cgt.f64
	<sinh+36 @04ad3c>   : 06 1b 00 00                jz <sinh+63 @04ad57>
	lib/std/math.ci:396: (23 bytes: <@04ad40> - <@04ad57>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @04ad40>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @04ad42>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @04ad46>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @04ad4f>   : 84                         div.f64
	<sinh+56 @04ad50>   : 14 06                      set.x2 sp(6)
	<sinh+58 @04ad52>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @04ad56>   : 03                         ret
	lib/std/math.ci:399: (1 byte: <@04ad57> - <@04ad58>): result: float64
	<sinh+63 @04ad57>   : 1a                         load.z64
	lib/std/math.ci:400: (151 bytes: <@04ad58> - <@04adef>): if (bool(x > 0.500000))
	<sinh+64 @04ad58>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @04ad5a>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @04ad63>   : 89                         cgt.f64
	<sinh+76 @04ad64>   : 06 22 00 00                jz <sinh+110 @04ad86>
	lib/std/math.ci:401: (26 bytes: <@04ad68> - <@04ad82>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @04ad68>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @04ad6a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @04ad6e>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @04ad70>   : 80                         neg.f64
	<sinh+89 @04ad71>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @04ad75>   : 82                         sub.f64
	<sinh+94 @04ad76>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @04ad7f>  : 84                         div.f64
	<sinh+104 @04ad80>  : 14 02                      set.x2 sp(2)
	<sinh+106 @04ad82>  : 04 6d 00 00                jmp <sinh+215 @04adef>
	lib/std/math.ci:404: (5 bytes: <@04ad86> - <@04ad8b>): sq: float64 := float64(x * x)
	<sinh+110 @04ad86>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @04ad88>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @04ad8a>  : 83                         mul.f64
	lib/std/math.ci:405: (53 bytes: <@04ad8b> - <@04adc0>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @04ad8b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @04ad94>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @04ad96>  : 83                         mul.f64
	<sinh+127 @04ad97>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @04ada0>  : 81                         add.f64
	<sinh+137 @04ada1>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @04ada3>  : 83                         mul.f64
	<sinh+140 @04ada4>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @04adad>  : 81                         add.f64
	<sinh+150 @04adae>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @04adb0>  : 83                         mul.f64
	<sinh+153 @04adb1>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @04adba>  : 81                         add.f64
	<sinh+163 @04adbb>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @04adbd>  : 83                         mul.f64
	<sinh+166 @04adbe>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:406: (43 bytes: <@04adc0> - <@04adeb>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @04adc0>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @04adc2>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @04adc4>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @04adcd>  : 81                         add.f64
	<sinh+182 @04adce>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @04add0>  : 83                         mul.f64
	<sinh+185 @04add1>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @04adda>  : 81                         add.f64
	<sinh+195 @04addb>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @04addd>  : 83                         mul.f64
	<sinh+198 @04adde>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @04ade7>  : 81                         add.f64
	<sinh+208 @04ade8>  : 84                         div.f64
	<sinh+209 @04ade9>  : 14 04                      set.x2 sp(4)
	<sinh+211 @04adeb>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:409: (19 bytes: <@04adef> - <@04ae02>): if (negate)
	<sinh+215 @04adef>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @04adf3>  : 20                         load.i8
	<sinh+220 @04adf4>  : 06 0e 00 00                jz <sinh+234 @04ae02>
	lib/std/math.ci:410: (10 bytes: <@04adf8> - <@04ae02>): return float64(.result := float64(-result));
	<sinh+224 @04adf8>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @04adfa>  : 80                         neg.f64
	<sinh+227 @04adfb>  : 14 08                      set.x2 sp(8)
	<sinh+229 @04adfd>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @04ae01>  : 03                         ret
	lib/std/math.ci:412: (7 bytes: <@04ae02> - <@04ae09>): return float64(.result := result);
	<sinh+234 @04ae02>  : 14 06                      set.x2 sp(6)
	<sinh+236 @04ae04>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @04ae08>  : 03                         ret
.references:
	test/stdc/test.math.ci:62: referenced as `sinh`
	lib/std/math.Complex.ci:120: referenced as `sinh`
	lib/std/math.Complex.ci:119: referenced as `sinh`
	lib/std/math.ci:377: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@04ae10>
.name: 'cosh'
.file: 'lib/std/math.ci:416'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@04ae10> - <@04ae5b>)
	lib/std/math.ci:417: (13 bytes: <@04ae10> - <@04ae1d>): if (bool(x < (0)))
	<cosh @04ae10>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @04ae12>    : 1a                         load.z64
	<cosh+3 @04ae13>    : 88                         clt.f64
	<cosh+4 @04ae14>    : 06 09 00 00                jz <cosh+13 @04ae1d>
	lib/std/math.ci:418: (5 bytes: <@04ae18> - <@04ae1d>): float64(x := float64(-x));
	<cosh+8 @04ae18>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @04ae1a>   : 80                         neg.f64
	<cosh+11 @04ae1b>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:420: (35 bytes: <@04ae1d> - <@04ae40>): if (bool(x > (21)))
	<cosh+13 @04ae1d>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @04ae1f>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @04ae28>   : 89                         cgt.f64
	<cosh+25 @04ae29>   : 06 17 00 00                jz <cosh+48 @04ae40>
	lib/std/math.ci:421: (19 bytes: <@04ae2d> - <@04ae40>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @04ae2d>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @04ae2f>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @04ae33>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @04ae3c>   : 84                         div.f64
	<cosh+45 @04ae3d>   : 14 05                      set.x2 sp(5)
	<cosh+47 @04ae3f>   : 03                         ret
	lib/std/math.ci:423: (27 bytes: <@04ae40> - <@04ae5b>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @04ae40>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @04ae42>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @04ae46>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @04ae48>   : 80                         neg.f64
	<cosh+57 @04ae49>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @04ae4d>   : 81                         add.f64
	<cosh+62 @04ae4e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @04ae57>   : 84                         div.f64
	<cosh+72 @04ae58>   : 14 05                      set.x2 sp(5)
	<cosh+74 @04ae5a>   : 03                         ret
.references:
	test/stdc/test.math.ci:63: referenced as `cosh`
	lib/std/math.Complex.ci:120: referenced as `cosh`
	lib/std/math.Complex.ci:119: referenced as `cosh`
	lib/std/math.ci:416: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@04ae60>
.name: 'asin'
.file: 'lib/std/math.ci:432'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: '
	 * Asin returns the arcsine of x.
	 *   Special cases are:
	 *     Asin(0) = 0
	 *     Asin(x) = NaN if x < -1 or x > 1
	 '
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@04ae60> - <@04af06>)
	lib/std/math.ci:433: (12 bytes: <@04ae60> - <@04ae6c>): if (bool(x == (0)))
	<asin @04ae60>      : 11 01                      dup.x2 sp(1)
	<asin+2 @04ae62>    : 1a                         load.z64
	<asin+3 @04ae63>    : 87                         ceq.f64
	<asin+4 @04ae64>    : 06 08 00 00                jz <asin+12 @04ae6c>
	lib/std/math.ci:435: (4 bytes: <@04ae68> - <@04ae6c>): return float64(.result := x);
	<asin+8 @04ae68>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @04ae6b>   : 03                         ret
	lib/std/math.ci:438: (1 byte: <@04ae6c> - <@04ae6d>): negate: bool := false
	<asin+12 @04ae6c>   : 19                         load.z32
	lib/std/math.ci:439: (23 bytes: <@04ae6d> - <@04ae84>): if (bool(x < (0)))
	<asin+13 @04ae6d>   : 11 02                      dup.x2 sp(2)
	<asin+15 @04ae6f>   : 1a                         load.z64
	<asin+16 @04ae70>   : 88                         clt.f64
	<asin+17 @04ae71>   : 06 13 00 00                jz <asin+36 @04ae84>
	lib/std/math.ci:440: (10 bytes: <@04ae75> - <@04ae7f>): bool(negate := true);
	<asin+21 @04ae75>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @04ae7a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @04ae7e>   : 25                         store.i8
	lib/std/math.ci:441: (5 bytes: <@04ae7f> - <@04ae84>): float64(x := float64(-x));
	<asin+31 @04ae7f>   : 11 02                      dup.x2 sp(2)
	<asin+33 @04ae81>   : 80                         neg.f64
	<asin+34 @04ae82>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:444: (25 bytes: <@04ae84> - <@04ae9d>): if (bool(x > (1)))
	<asin+36 @04ae84>   : 11 02                      dup.x2 sp(2)
	<asin+38 @04ae86>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @04ae8f>   : 89                         cgt.f64
	<asin+48 @04ae90>   : 06 0d 00 00                jz <asin+61 @04ae9d>
	lib/std/math.ci:446: (9 bytes: <@04ae94> - <@04ae9d>): return float64(.result := nan);
	<asin+52 @04ae94>   : 1b                         load.z128
	<asin+53 @04ae95>   : 84                         div.f64
	<asin+54 @04ae96>   : 14 06                      set.x2 sp(6)
	<asin+56 @04ae98>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @04ae9c>   : 03                         ret
	lib/std/math.ci:449: (19 bytes: <@04ae9d> - <@04aeb0>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @04ae9d>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @04aea6>   : 11 04                      dup.x2 sp(4)
	<asin+72 @04aea8>   : 11 06                      dup.x2 sp(6)
	<asin+74 @04aeaa>   : 83                         mul.f64
	<asin+75 @04aeab>   : 82                         sub.f64
	<asin+76 @04aeac>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:450: (60 bytes: <@04aeb0> - <@04aeec>): if (bool(x > 0.700000))
	<asin+80 @04aeb0>   : 11 04                      dup.x2 sp(4)
	<asin+82 @04aeb2>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @04aebb>   : 89                         cgt.f64
	<asin+92 @04aebc>   : 06 26 00 00                jz <asin+130 @04aee2>
	lib/std/math.ci:451: (30 bytes: <@04aec0> - <@04aede>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @04aec0>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @04aec9>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @04aed2>  : 84                         div.f64
	<asin+115 @04aed3>  : 11 02                      dup.x2 sp(2)
	<asin+117 @04aed5>  : 11 08                      dup.x2 sp(8)
	<asin+119 @04aed7>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @04aedb>  : 82                         sub.f64
	<asin+124 @04aedc>  : 14 02                      set.x2 sp(2)
	<asin+126 @04aede>  : 04 0e 00 00                jmp <asin+140 @04aeec>
	lib/std/math.ci:454: (10 bytes: <@04aee2> - <@04aeec>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @04aee2>  : 11 04                      dup.x2 sp(4)
	<asin+132 @04aee4>  : 11 02                      dup.x2 sp(2)
	<asin+134 @04aee6>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @04aeea>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:457: (19 bytes: <@04aeec> - <@04aeff>): if (negate)
	<asin+140 @04aeec>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @04aef0>  : 20                         load.i8
	<asin+145 @04aef1>  : 06 0e 00 00                jz <asin+159 @04aeff>
	lib/std/math.ci:458: (10 bytes: <@04aef5> - <@04aeff>): return float64(.result := float64(-result));
	<asin+149 @04aef5>  : 11 00                      dup.x2 sp(0)
	<asin+151 @04aef7>  : 80                         neg.f64
	<asin+152 @04aef8>  : 14 08                      set.x2 sp(8)
	<asin+154 @04aefa>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @04aefe>  : 03                         ret
	lib/std/math.ci:460: (7 bytes: <@04aeff> - <@04af06>): return float64(.result := result);
	<asin+159 @04aeff>  : 14 06                      set.x2 sp(6)
	<asin+161 @04af01>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @04af05>  : 03                         ret
.references:
	test/stdc/test.math.ci:65: referenced as `asin`
	lib/std/math.ci:467: referenced as `asin`
	lib/std/math.ci:432: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:467'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: (float64(float64(pi / (2)) - asin(x)))
.references:
	test/stdc/test.math.ci:66: referenced as `acos`
	lib/std/math.ci:467: defined as `acos(x: float64): float64`
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'deg2rad'
.file: 'lib/std/math.ci:490'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * pi) / (180)))
.references:
	lib/std/math.ci:490: defined as `deg2rad(x: float64): float64`
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rad2deg'
.file: 'lib/std/math.ci:491'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * (180)) / pi))
.references:
	lib/std/math.ci:491: defined as `rad2deg(x: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@017f40>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:142: referenced as `Complex`
	lib/std/math.Complex.ci:141: referenced as `Complex`
	lib/std/math.Complex.ci:140: referenced as `Complex`
	lib/std/math.Complex.ci:138: referenced as `Complex`
	lib/std/math.Complex.ci:137: referenced as `Complex`
	lib/std/math.Complex.ci:136: referenced as `Complex`
	lib/std/math.Complex.ci:135: referenced as `Complex`
	lib/std/math.Complex.ci:133: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:90: referenced as `Complex`
	lib/std/math.Complex.ci:89: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: referenced as `Complex`
	lib/std/math.Complex.ci:20: referenced as `Complex`
	lib/std/math.Complex.ci:3: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
.references:
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:113: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:110: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:101: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:90: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:82: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:79: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:75: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:72: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:70: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:63: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:60: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:56: referenced as `re`
	lib/std/math.Complex.ci:55: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:52: referenced as `re`
	lib/std/math.Complex.ci:27: referenced as `re`
	lib/std/math.Complex.ci:22: referenced as `re`
	lib/std/math.Complex.ci:4: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
.references:
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:114: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:110: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:101: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:90: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:81: referenced as `im`
	lib/std/math.Complex.ci:79: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:74: referenced as `im`
	lib/std/math.Complex.ci:72: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:70: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:63: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:60: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:56: referenced as `im`
	lib/std/math.Complex.ci:55: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:52: referenced as `im`
	lib/std/math.Complex.ci:28: referenced as `im`
	lib/std/math.Complex.ci:5: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@04af08>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@04af08> - <@04af0f>)
	lib/std/math.Complex.ci:21: (7 bytes: <@04af08> - <@04af0f>): return void(.result := {...});
	<Complex @04af08>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@04af0b> - <@04af0e>): void(.result.im := (0))
	<Complex+3 @04af0b>    : 1a                         load.z64
	<Complex+4 @04af0c>    : 14 07                      set.x2 sp(7)
	<Complex+6 @04af0e>    : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:20: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@04af10>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@04af10> - <@04af17>)
	lib/std/math.Complex.ci:26: (7 bytes: <@04af10> - <@04af17>): return void(.result := {...});
	<Complex @04af10>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:28: (3 bytes: <@04af13> - <@04af16>): void(.result.im := im);
	<Complex+3 @04af13>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @04af16>    : 03                         ret
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(-a.re), float64(-a.im)))
.references:
	lib/vec/vec4f.ci:56: referenced as `neg`
	lib/std/math.Complex.ci:136: referenced as `neg`
	lib/std/math.Complex.ci:135: referenced as `neg`
	lib/std/math.Complex.ci:52: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `add`
	lib/std/math.Complex.ci:54: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re + b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `add`
	lib/std/math.Complex.ci:137: referenced as `add`
	lib/std/math.Complex.ci:55: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a + b.re), b.im))
.references:
	lib/std/math.Complex.ci:56: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.references:
	lib/std/math.Complex.ci:135: referenced as `sub`
	lib/std/math.Complex.ci:58: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re - b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `sub`
	lib/std/math.Complex.ci:137: referenced as `sub`
	lib/std/math.Complex.ci:59: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a - b.re), b.im))
.references:
	lib/std/math.Complex.ci:60: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.references:
	lib/std/math.Complex.ci:62: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.references:
	lib/std/math.Complex.ci:63: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.references:
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:64: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@04af18>
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@04af18> - <@04af93>)
	lib/std/math.Complex.ci:70: (79 bytes: <@04af18> - <@04af67>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @04af18>      : 1a                         load.z64
	<div+1 @04af19>    : 11 03                      dup.x2 sp(3)
	<div+3 @04af1b>    : 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<div+8 @04af20>    : 02                         call
	<div+9 @04af21>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @04af25>   : 1a                         load.z64
	<div+14 @04af26>   : 11 07                      dup.x2 sp(7)
	<div+16 @04af28>   : 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<div+21 @04af2d>   : 02                         call
	<div+22 @04af2e>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @04af32>   : 88                         clt.f64
	<div+27 @04af33>   : 05 34 00 00                jnz <div+79 @04af67>
	lib/std/math.Complex.ci:71: (5 bytes: <@04af37> - <@04af3c>): r: float64 := float64(b.im / b.re)
	<div+31 @04af37>   : 11 03                      dup.x2 sp(3)
	<div+33 @04af39>   : 11 03                      dup.x2 sp(3)
	<div+35 @04af3b>   : 84                         div.f64
	lib/std/math.Complex.ci:72: (8 bytes: <@04af3c> - <@04af44>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @04af3c>   : 11 03                      dup.x2 sp(3)
	<div+38 @04af3e>   : 11 02                      dup.x2 sp(2)
	<div+40 @04af40>   : 11 09                      dup.x2 sp(9)
	<div+42 @04af42>   : 83                         mul.f64
	<div+43 @04af43>   : 81                         add.f64
	lib/std/math.Complex.ci:73: (31 bytes: <@04af44> - <@04af63>): return void(.result := {...});
	<div+44 @04af44>   : 11 09                      dup.x2 sp(9)
	<div+46 @04af46>   : 11 04                      dup.x2 sp(4)
	<div+48 @04af48>   : 11 0f                      dup.x2 sp(15)
	<div+50 @04af4a>   : 83                         mul.f64
	<div+51 @04af4b>   : 81                         add.f64
	<div+52 @04af4c>   : 11 02                      dup.x2 sp(2)
	<div+54 @04af4e>   : 84                         div.f64
	<div+55 @04af4f>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes: <@04af51> - <@04af5e>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @04af51>   : 11 0b                      dup.x2 sp(11)
	<div+59 @04af53>   : 11 04                      dup.x2 sp(4)
	<div+61 @04af55>   : 11 0d                      dup.x2 sp(13)
	<div+63 @04af57>   : 83                         mul.f64
	<div+64 @04af58>   : 82                         sub.f64
	<div+65 @04af59>   : 11 02                      dup.x2 sp(2)
	<div+67 @04af5b>   : 84                         div.f64
	<div+68 @04af5c>   : 14 11                      set.x2 sp(17)
	<div+70 @04af5e>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @04af62>   : 03                         ret
	<div+75 @04af63>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes: <@04af67> - <@04af6c>): r: float64 := float64(b.re / b.im)
	<div+79 @04af67>   : 11 01                      dup.x2 sp(1)
	<div+81 @04af69>   : 11 05                      dup.x2 sp(5)
	<div+83 @04af6b>   : 84                         div.f64
	lib/std/math.Complex.ci:79: (8 bytes: <@04af6c> - <@04af74>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @04af6c>   : 11 05                      dup.x2 sp(5)
	<div+86 @04af6e>   : 11 02                      dup.x2 sp(2)
	<div+88 @04af70>   : 11 07                      dup.x2 sp(7)
	<div+90 @04af72>   : 83                         mul.f64
	<div+91 @04af73>   : 81                         add.f64
	lib/std/math.Complex.ci:80: (31 bytes: <@04af74> - <@04af93>): return void(.result := {...});
	<div+92 @04af74>   : 11 09                      dup.x2 sp(9)
	<div+94 @04af76>   : 11 04                      dup.x2 sp(4)
	<div+96 @04af78>   : 83                         mul.f64
	<div+97 @04af79>   : 11 0d                      dup.x2 sp(13)
	<div+99 @04af7b>   : 81                         add.f64
	<div+100 @04af7c>  : 11 02                      dup.x2 sp(2)
	<div+102 @04af7e>  : 84                         div.f64
	<div+103 @04af7f>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes: <@04af81> - <@04af8e>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @04af81>  : 11 0b                      dup.x2 sp(11)
	<div+107 @04af83>  : 11 04                      dup.x2 sp(4)
	<div+109 @04af85>  : 83                         mul.f64
	<div+110 @04af86>  : 11 0b                      dup.x2 sp(11)
	<div+112 @04af88>  : 82                         sub.f64
	<div+113 @04af89>  : 11 02                      dup.x2 sp(2)
	<div+115 @04af8b>  : 84                         div.f64
	<div+116 @04af8c>  : 14 11                      set.x2 sp(17)
	<div+118 @04af8e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @04af92>  : 03                         ret
.references:
	lib/std/math.Complex.ci:138: referenced as `div`
	lib/std/math.Complex.ci:137: referenced as `div`
	lib/std/math.Complex.ci:133: referenced as `div`
	lib/std/math.Complex.ci:132: referenced as `div`
	lib/std/math.Complex.ci:87: referenced as `div`
	lib/std/math.Complex.ci:86: referenced as `div`
	lib/std/math.Complex.ci:66: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: div(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:136: referenced as `div`
	lib/std/math.Complex.ci:135: referenced as `div`
	lib/std/math.Complex.ci:86: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.value: div(void(Complex(a), b))
.references:
	lib/std/math.Complex.ci:87: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.references:
	lib/std/math.Complex.ci:146: referenced as `abs`
	lib/std/math.Complex.ci:108: referenced as `abs`
	lib/std/math.Complex.ci:105: referenced as `abs`
	lib/std/math.Complex.ci:89: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.atan2(void(a.re, a.im))
.references:
	lib/std/math.Complex.ci:146: referenced as `arg`
	lib/std/math.Complex.ci:109: referenced as `arg`
	lib/std/math.Complex.ci:105: referenced as `arg`
	lib/std/math.Complex.ci:90: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@04af98>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@04af98> - <@04afb7>)
	lib/std/math.Complex.ci:94: (11 bytes: <@04af98> - <@04afa3>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @04af98>      : 11 01                      dup.x2 sp(1)
	<inv+2 @04af9a>    : 11 03                      dup.x2 sp(3)
	<inv+4 @04af9c>    : 83                         mul.f64
	<inv+5 @04af9d>    : 11 05                      dup.x2 sp(5)
	<inv+7 @04af9f>    : 11 07                      dup.x2 sp(7)
	<inv+9 @04afa1>    : 83                         mul.f64
	<inv+10 @04afa2>   : 81                         add.f64
	lib/std/math.Complex.ci:95: (20 bytes: <@04afa3> - <@04afb7>): return void(.result := {...});
	<inv+11 @04afa3>   : 11 03                      dup.x2 sp(3)
	<inv+13 @04afa5>   : 11 02                      dup.x2 sp(2)
	<inv+15 @04afa7>   : 84                         div.f64
	<inv+16 @04afa8>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes: <@04afaa> - <@04afb2>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @04afaa>   : 11 05                      dup.x2 sp(5)
	<inv+20 @04afac>   : 80                         neg.f64
	<inv+21 @04afad>   : 11 02                      dup.x2 sp(2)
	<inv+23 @04afaf>   : 84                         div.f64
	<inv+24 @04afb0>   : 14 0b                      set.x2 sp(11)
	<inv+26 @04afb2>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @04afb6>   : 03                         ret
.references:
	lib/std/math.Complex.ci:143: referenced as `inv`
	lib/std/math.Complex.ci:142: referenced as `inv`
	lib/std/math.Complex.ci:141: referenced as `inv`
	lib/std/math.Complex.ci:140: referenced as `inv`
	lib/std/math.Complex.ci:93: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(a.re, float64(-a.im)))
.references:
	lib/std/math.Complex.ci:101: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.references:
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:103: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64.log(abs(a)), arg(a)))
.references:
	lib/std/math.Complex.ci:105: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@04afb8>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@04afb8> - <@04b01c>)
	lib/std/math.Complex.ci:108: (23 bytes: <@04afb8> - <@04afcf>): r: float64 := abs(a)
	<pow @04afb8>      : 12 05                      dup.x4 sp(5)
	<pow+2 @04afba>    : 11 00                      dup.x2 sp(0)
	<pow+4 @04afbc>    : 11 02                      dup.x2 sp(2)
	<pow+6 @04afbe>    : 83                         mul.f64
	<pow+7 @04afbf>    : 11 04                      dup.x2 sp(4)
	<pow+9 @04afc1>    : 11 06                      dup.x2 sp(6)
	<pow+11 @04afc3>   : 83                         mul.f64
	<pow+12 @04afc4>   : 81                         add.f64
	<pow+13 @04afc5>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @04afc9>   : 14 04                      set.x2 sp(4)
	<pow+19 @04afcb>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes: <@04afcf> - <@04afdf>): t: float64 := arg(a)
	<pow+23 @04afcf>   : 12 07                      dup.x4 sp(7)
	<pow+25 @04afd1>   : 11 00                      dup.x2 sp(0)
	<pow+27 @04afd3>   : 11 04                      dup.x2 sp(4)
	<pow+29 @04afd5>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @04afd9>   : 14 04                      set.x2 sp(4)
	<pow+35 @04afdb>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes: <@04afdf> - <@04afee>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @04afdf>   : 11 05                      dup.x2 sp(5)
	<pow+41 @04afe1>   : 11 02                      dup.x2 sp(2)
	<pow+43 @04afe3>   : 83                         mul.f64
	<pow+44 @04afe4>   : 11 09                      dup.x2 sp(9)
	<pow+46 @04afe6>   : 11 06                      dup.x2 sp(6)
	<pow+48 @04afe8>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @04afec>   : 83                         mul.f64
	<pow+53 @04afed>   : 81                         add.f64
	lib/std/math.Complex.ci:111: (19 bytes: <@04afee> - <@04b001>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @04afee>   : 11 04                      dup.x2 sp(4)
	<pow+56 @04aff0>   : 11 09                      dup.x2 sp(9)
	<pow+58 @04aff2>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @04aff6>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @04aff8>   : 80                         neg.f64
	<pow+65 @04aff9>   : 11 06                      dup.x2 sp(6)
	<pow+67 @04affb>   : 83                         mul.f64
	<pow+68 @04affc>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @04b000>   : 83                         mul.f64
	lib/std/math.Complex.ci:112: (27 bytes: <@04b001> - <@04b01c>): return void(.result := {...});
	<pow+73 @04b001>   : 11 00                      dup.x2 sp(0)
	<pow+75 @04b003>   : 11 04                      dup.x2 sp(4)
	<pow+77 @04b005>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @04b009>   : 83                         mul.f64
	<pow+82 @04b00a>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes: <@04b00c> - <@04b017>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @04b00c>   : 11 00                      dup.x2 sp(0)
	<pow+86 @04b00e>   : 11 04                      dup.x2 sp(4)
	<pow+88 @04b010>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @04b014>   : 83                         mul.f64
	<pow+93 @04b015>   : 14 15                      set.x2 sp(21)
	<pow+95 @04b017>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @04b01b>   : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `pow`
	lib/std/math.Complex.ci:107: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: pow(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:117: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:141: referenced as `sin`
	lib/std/math.Complex.ci:133: referenced as `sin`
	lib/std/math.Complex.ci:132: referenced as `sin`
	lib/std/math.Complex.ci:119: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:140: referenced as `cos`
	lib/std/math.Complex.ci:133: referenced as `cos`
	lib/std/math.Complex.ci:132: referenced as `cos`
	lib/std/math.Complex.ci:120: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sin(a), cos(a)))
.references:
	lib/std/math.Complex.ci:132: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(cos(a), sin(a)))
.references:
	lib/std/math.Complex.ci:133: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:143: referenced as `sinh`
	lib/std/math.Complex.ci:135: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:142: referenced as `cosh`
	lib/std/math.Complex.ci:136: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:137: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:138: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cos(a))
.references:
	lib/std/math.Complex.ci:140: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sin(a))
.references:
	lib/std/math.Complex.ci:141: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cosh(a))
.references:
	lib/std/math.Complex.ci:142: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sinh(a))
.references:
	lib/std/math.Complex.ci:143: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.references:
	lib/std/math.Complex.ci:145: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(abs(x), arg(x)))
.references:
	lib/std/math.Complex.ci:146: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@04b020>
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@04b020> - <@04b046>)
	lib/std/string.ci:4: (16 bytes: <@04b020> - <@04b030>): if (bool((str) == null))
	<length @04b020>      : 10 01                      dup.x1 sp(1)
	<length+2 @04b022>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @04b027>    : 57                         ceq.i32
	<length+8 @04b028>    : 06 08 00 00                jz <length+16 @04b030>
	lib/std/string.ci:5: (4 bytes: <@04b02c> - <@04b030>): return int32(.result := 0);
	<length+12 @04b02c>   : 19                         load.z32
	<length+13 @04b02d>   : 13 03                      set.x1 sp(3)
	<length+15 @04b02f>   : 03                         ret
	lib/std/string.ci:7: (1 byte: <@04b030> - <@04b031>): result: int32 := 0
	<length+16 @04b030>   : 19                         load.z32
	lib/std/string.ci:8: (18 bytes: <@04b031> - <@04b043>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @04b031>   : 04 08 00 00                jmp <length+25 @04b039>
	lib/std/string.ci:8: (4 bytes: <@04b035> - <@04b039>): int32(result := int32(result + 1))
	<length+21 @04b035>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:8: (10 bytes: <@04b039> - <@04b043>): str[result]
	<length+25 @04b039>   : 10 02                      dup.x1 sp(2)
	<length+27 @04b03b>   : 10 01                      dup.x1 sp(1)
	<length+29 @04b03d>   : 51                         add.i32
	<length+30 @04b03e>   : 20                         load.i8
	<length+31 @04b03f>   : 05 f6 ff ff                jnz <length+21 @04b035>
	lib/std/string.ci:10: (3 bytes: <@04b043> - <@04b046>): return int32(.result := result);
	<length+35 @04b043>   : 13 03                      set.x1 sp(3)
	<length+37 @04b045>   : 03                         ret
.references:
	lib/std/string.ci:46: referenced as `length`
	lib/std/string.ci:45: referenced as `length`
	lib/std/string.ci:3: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@04b048>
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' the first occurrence of a char in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@04b048> - <@04b07a>)
	lib/std/string.ci:15: (42 bytes: <@04b048> - <@04b072>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @04b048>      : 19                         load.z32
	<indexOf+1 @04b049>    : 04 1b 00 00                jmp <indexOf+28 @04b064>
	lib/std/string.ci:16: (19 bytes: <@04b04d> - <@04b060>): if (bool(str[i] == chr))
	<indexOf+5 @04b04d>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @04b04f>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @04b051>    : 51                         add.i32
	<indexOf+10 @04b052>   : 20                         load.i8
	<indexOf+11 @04b053>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @04b057>   : 20                         load.i8
	<indexOf+16 @04b058>   : 57                         ceq.i32
	<indexOf+17 @04b059>   : 06 07 00 00                jz <indexOf+24 @04b060>
	lib/std/string.ci:17: (3 bytes: <@04b05d> - <@04b060>): return int32(.result := i);
	<indexOf+21 @04b05d>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @04b05f>   : 03                         ret
	lib/std/string.ci:15: (4 bytes: <@04b060> - <@04b064>): int32(i := int32(i + 1))
	<indexOf+24 @04b060>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:15: (10 bytes: <@04b064> - <@04b06e>): str[i]
	<indexOf+28 @04b064>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @04b066>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @04b068>   : 51                         add.i32
	<indexOf+33 @04b069>   : 20                         load.i8
	<indexOf+34 @04b06a>   : 05 e3 ff ff                jnz <indexOf+5 @04b04d>
	<indexOf+38 @04b06e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:20: (8 bytes: <@04b072> - <@04b07a>): return int32(.result := int32(-1));
	<indexOf+42 @04b072>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @04b077>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @04b079>   : 03                         ret
.references:
	lib/std/string.ci:92: referenced as `indexOf`
	lib/std/string.ci:14: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@04b080>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' the last occurrence of a char in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@04b080> - <@04b0b2>)
	lib/std/string.ci:25: (5 bytes: <@04b080> - <@04b085>): result: int32 := int32(-1)
	<lastIndexOf @04b080>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:26: (42 bytes: <@04b085> - <@04b0af>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @04b085>    : 19                         load.z32
	<lastIndexOf+6 @04b086>    : 04 1b 00 00                jmp <lastIndexOf+33 @04b0a1>
	lib/std/string.ci:27: (19 bytes: <@04b08a> - <@04b09d>): if (bool(str[i] == chr))
	<lastIndexOf+10 @04b08a>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @04b08c>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @04b08e>   : 51                         add.i32
	<lastIndexOf+15 @04b08f>   : 20                         load.i8
	<lastIndexOf+16 @04b090>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @04b094>   : 20                         load.i8
	<lastIndexOf+21 @04b095>   : 57                         ceq.i32
	<lastIndexOf+22 @04b096>   : 06 07 00 00                jz <lastIndexOf+29 @04b09d>
	lib/std/string.ci:28: (3 bytes: <@04b09a> - <@04b09d>): int32(result := i);
	<lastIndexOf+26 @04b09a>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:26: (4 bytes: <@04b09d> - <@04b0a1>): int32(i := int32(i + 1))
	<lastIndexOf+29 @04b09d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:26: (10 bytes: <@04b0a1> - <@04b0ab>): str[i]
	<lastIndexOf+33 @04b0a1>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @04b0a3>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @04b0a5>   : 51                         add.i32
	<lastIndexOf+38 @04b0a6>   : 20                         load.i8
	<lastIndexOf+39 @04b0a7>   : 05 e3 ff ff                jnz <lastIndexOf+10 @04b08a>
	<lastIndexOf+43 @04b0ab>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:31: (3 bytes: <@04b0af> - <@04b0b2>): return int32(.result := result);
	<lastIndexOf+47 @04b0af>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @04b0b1>   : 03                         ret
.references:
	lib/std/string.ci:24: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@04b0b8>
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@04b0b8> - <@04b101>)
	lib/std/string.ci:36: (62 bytes: <@04b0b8> - <@04b0f6>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @04b0b8>      : 19                         load.z32
	<startsWith+1 @04b0b9>    : 04 2d 00 00                jmp <startsWith+46 @04b0e6>
	lib/std/string.ci:37: (37 bytes: <@04b0bd> - <@04b0e2>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @04b0bd>    : 19                         load.z32
	<startsWith+6 @04b0be>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @04b0c0>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @04b0c2>   : 51                         add.i32
	<startsWith+11 @04b0c3>   : 20                         load.i8
	<startsWith+12 @04b0c4>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @04b0c6>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @04b0c8>   : 51                         add.i32
	<startsWith+17 @04b0c9>   : 20                         load.i8
	<startsWith+18 @04b0ca>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @04b0cc>   : 02                         call
	<startsWith+21 @04b0cd>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @04b0d1>   : 19                         load.z32
	<startsWith+26 @04b0d2>   : 57                         ceq.i32
	<startsWith+27 @04b0d3>   : 05 0f 00 00                jnz <startsWith+42 @04b0e2>
	lib/std/string.ci:38: (11 bytes: <@04b0d7> - <@04b0e2>): return bool(.result := false);
	<startsWith+31 @04b0d7>   : 19                         load.z32
	<startsWith+32 @04b0d8>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @04b0dc>   : 25                         store.i8
	<startsWith+37 @04b0dd>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @04b0e1>   : 03                         ret
	lib/std/string.ci:36: (4 bytes: <@04b0e2> - <@04b0e6>): int32(i := int32(i + 1))
	<startsWith+42 @04b0e2>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:36: (12 bytes: <@04b0e6> - <@04b0f2>): bool((with[i]) != 0)
	<startsWith+46 @04b0e6>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @04b0e8>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @04b0ea>   : 51                         add.i32
	<startsWith+51 @04b0eb>   : 20                         load.i8
	<startsWith+52 @04b0ec>   : 19                         load.z32
	<startsWith+53 @04b0ed>   : 57                         ceq.i32
	<startsWith+54 @04b0ee>   : 06 cf ff ff                jz <startsWith+5 @04b0bd>
	<startsWith+58 @04b0f2>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:41: (11 bytes: <@04b0f6> - <@04b101>): return bool(.result := true);
	<startsWith+62 @04b0f6>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @04b0fb>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @04b0ff>   : 25                         store.i8
	<startsWith+72 @04b100>   : 03                         ret
.references:
	lib/std/string.ci:88: referenced as `startsWith`
	lib/std/string.ci:35: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@04b108>
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@04b108> - <@04b186>)
	lib/std/string.ci:45: (13 bytes: <@04b108> - <@04b115>): withLen: int32 := length(with)
	<endsWith @04b108>      : 19                         load.z32
	<endsWith+1 @04b109>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @04b10b>    : 1f 20 b0 04 00             load.ref <@04b020> ;length(str: char[*]): int32
	<endsWith+8 @04b110>    : 02                         call
	<endsWith+9 @04b111>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:46: (13 bytes: <@04b115> - <@04b122>): strLen: int32 := length(str)
	<endsWith+13 @04b115>   : 19                         load.z32
	<endsWith+14 @04b116>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @04b118>   : 1f 20 b0 04 00             load.ref <@04b020> ;length(str: char[*]): int32
	<endsWith+21 @04b11d>   : 02                         call
	<endsWith+22 @04b11e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:47: (20 bytes: <@04b122> - <@04b136>): if (bool(strLen < withLen))
	<endsWith+26 @04b122>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @04b124>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @04b126>   : 58                         clt.i32
	<endsWith+31 @04b127>   : 06 0f 00 00                jz <endsWith+46 @04b136>
	lib/std/string.ci:48: (11 bytes: <@04b12b> - <@04b136>): return bool(.result := false);
	<endsWith+35 @04b12b>   : 19                         load.z32
	<endsWith+36 @04b12c>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @04b130>   : 25                         store.i8
	<endsWith+41 @04b131>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @04b135>   : 03                         ret
	lib/std/string.ci:50: (65 bytes: <@04b136> - <@04b177>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @04b136>   : 19                         load.z32
	<endsWith+47 @04b137>   : 04 33 00 00                jmp <endsWith+98 @04b16a>
	lib/std/string.ci:51: (43 bytes: <@04b13b> - <@04b166>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @04b13b>   : 19                         load.z32
	<endsWith+52 @04b13c>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @04b13e>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @04b140>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @04b142>   : 52                         sub.i32
	<endsWith+59 @04b143>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @04b145>   : 51                         add.i32
	<endsWith+62 @04b146>   : 51                         add.i32
	<endsWith+63 @04b147>   : 20                         load.i8
	<endsWith+64 @04b148>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @04b14a>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @04b14c>   : 51                         add.i32
	<endsWith+69 @04b14d>   : 20                         load.i8
	<endsWith+70 @04b14e>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @04b150>   : 02                         call
	<endsWith+73 @04b151>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @04b155>   : 19                         load.z32
	<endsWith+78 @04b156>   : 57                         ceq.i32
	<endsWith+79 @04b157>   : 05 0f 00 00                jnz <endsWith+94 @04b166>
	lib/std/string.ci:52: (11 bytes: <@04b15b> - <@04b166>): return bool(.result := false);
	<endsWith+83 @04b15b>   : 19                         load.z32
	<endsWith+84 @04b15c>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @04b160>   : 25                         store.i8
	<endsWith+89 @04b161>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @04b165>   : 03                         ret
	lib/std/string.ci:50: (4 bytes: <@04b166> - <@04b16a>): int32(i := int32(i + 1))
	<endsWith+94 @04b166>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:50: (9 bytes: <@04b16a> - <@04b173>): bool(i < withLen)
	<endsWith+98 @04b16a>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @04b16c>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @04b16e>  : 58                         clt.i32
	<endsWith+103 @04b16f>  : 05 cc ff ff                jnz <endsWith+51 @04b13b>
	<endsWith+107 @04b173>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:55: (15 bytes: <@04b177> - <@04b186>): return bool(.result := true);
	<endsWith+111 @04b177>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @04b17c>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @04b180>  : 25                         store.i8
	<endsWith+121 @04b181>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @04b185>  : 03                         ret
.references:
	lib/std/string.ci:89: referenced as `endsWith`
	lib/std/string.ci:44: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@04b188>
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@04b188> - <@04b1c7>)
	lib/std/string.ci:59: (1 byte: <@04b188> - <@04b189>): result: int32 := 0
	<compare @04b188>      : 19                         load.z32
	lib/std/string.ci:60: (59 bytes: <@04b189> - <@04b1c4>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @04b189>    : 19                         load.z32
	<compare+2 @04b18a>    : 04 2e 00 00                jmp <compare+48 @04b1b8>
	lib/std/string.ci:61: (22 bytes: <@04b18e> - <@04b1a4>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @04b18e>    : 19                         load.z32
	<compare+7 @04b18f>    : 10 06                      dup.x1 sp(6)
	<compare+9 @04b191>    : 10 02                      dup.x1 sp(2)
	<compare+11 @04b193>   : 51                         add.i32
	<compare+12 @04b194>   : 20                         load.i8
	<compare+13 @04b195>   : 10 06                      dup.x1 sp(6)
	<compare+15 @04b197>   : 10 03                      dup.x1 sp(3)
	<compare+17 @04b199>   : 51                         add.i32
	<compare+18 @04b19a>   : 20                         load.i8
	<compare+19 @04b19b>   : 10 06                      dup.x1 sp(6)
	<compare+21 @04b19d>   : 02                         call
	<compare+22 @04b19e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @04b1a2>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes: <@04b1a4> - <@04b1b4>): if (bool((str[i]) == 0))
	<compare+28 @04b1a4>   : 10 05                      dup.x1 sp(5)
	<compare+30 @04b1a6>   : 10 01                      dup.x1 sp(1)
	<compare+32 @04b1a8>   : 51                         add.i32
	<compare+33 @04b1a9>   : 20                         load.i8
	<compare+34 @04b1aa>   : 19                         load.z32
	<compare+35 @04b1ab>   : 57                         ceq.i32
	<compare+36 @04b1ac>   : 06 08 00 00                jz <compare+44 @04b1b4>
	lib/std/string.ci:63: (4 bytes: <@04b1b0> - <@04b1b4>): break;
	<compare+40 @04b1b0>   : 04 10 00 00                jmp <compare+56 @04b1c0>
	lib/std/string.ci:60: (4 bytes: <@04b1b4> - <@04b1b8>): int32(i := int32(i + 1))
	<compare+44 @04b1b4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:60: (8 bytes: <@04b1b8> - <@04b1c0>): bool(result == 0)
	<compare+48 @04b1b8>   : 10 01                      dup.x1 sp(1)
	<compare+50 @04b1ba>   : 19                         load.z32
	<compare+51 @04b1bb>   : 57                         ceq.i32
	<compare+52 @04b1bc>   : 05 d2 ff ff                jnz <compare+6 @04b18e>
	<compare+56 @04b1c0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:66: (3 bytes: <@04b1c4> - <@04b1c7>): return int32(.result := result);
	<compare+60 @04b1c4>   : 13 05                      set.x1 sp(5)
	<compare+62 @04b1c6>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `compare`
	lib/std/string.ci:58: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@04b210>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@04b210> - <@04b234>)
	lib/std/string.ci:81: (36 bytes: <@04b210> - <@04b234>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @04b210>      : 19                         load.z32
	<ignCaseCmp+1 @04b211>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @04b215>    : 20                         load.i8
	<ignCaseCmp+6 @04b216>    : 1f c8 b1 04 00             load.ref <@04b1c8> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @04b21b>   : 02                         call
	<ignCaseCmp+12 @04b21c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @04b220>   : 19                         load.z32
	<ignCaseCmp+17 @04b221>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @04b225>   : 20                         load.i8
	<ignCaseCmp+22 @04b226>   : 1f c8 b1 04 00             load.ref <@04b1c8> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @04b22b>   : 02                         call
	<ignCaseCmp+28 @04b22c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @04b230>   : 52                         sub.i32
	<ignCaseCmp+33 @04b231>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @04b233>   : 03                         ret
.references:
	lib/std/string.ci:70: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@04b238>
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@04b238> - <@04b246>)
	lib/std/string.ci:85: (14 bytes: <@04b238> - <@04b246>): return char(.result := char(chr - with));
	<caseCmp @04b238>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @04b23c>    : 20                         load.i8
	<caseCmp+5 @04b23d>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @04b241>    : 20                         load.i8
	<caseCmp+10 @04b242>   : 52                         sub.i32
	<caseCmp+11 @04b243>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @04b245>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `caseCmp`
	lib/std/string.ci:89: referenced as `caseCmp`
	lib/std/string.ci:88: referenced as `caseCmp`
	lib/std/string.ci:84: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:88: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:89: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:90: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.value: bool(indexOf(void(str, chr)) >= 0)
.references:
	lib/std/string.ci:158: referenced as `contains`
	lib/std/string.ci:92: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01fff0>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.references:
	lib/std/string.ci:206: referenced as `FormatFlags`
	lib/std/string.ci:196: referenced as `FormatFlags`
	lib/std/string.ci:192: referenced as `FormatFlags`
	lib/std/string.ci:129: referenced as `FormatFlags`
	lib/std/string.ci:106: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
.references:
	lib/std/string.ci:136: referenced as `radix`
	lib/std/string.ci:107: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:150: referenced as `padChr`
	lib/std/string.ci:108: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:148: referenced as `padLen`
	lib/std/string.ci:109: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:110: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@04b248>
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@04b248> - <@04b29c>)
	lib/std/string.ci:114: (56 bytes: <@04b248> - <@04b280>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @04b248>      : 19                         load.z32
	<append+1 @04b249>    : 04 29 00 00                jmp <append+42 @04b272>
	lib/std/string.ci:115: (13 bytes: <@04b24d> - <@04b25a>): if (bool(pos >= (output.length)))
	<append+5 @04b24d>    : 10 03                      dup.x1 sp(3)
	<append+7 @04b24f>    : 10 06                      dup.x1 sp(6)
	<append+9 @04b251>    : 58                         clt.i32
	<append+10 @04b252>   : 05 08 00 00                jnz <append+18 @04b25a>
	lib/std/string.ci:116: (4 bytes: <@04b256> - <@04b25a>): break;
	<append+14 @04b256>   : 04 26 00 00                jmp <append+52 @04b27c>
	lib/std/string.ci:118: (12 bytes: <@04b25a> - <@04b266>): char(output[pos] := value[i]);
	<append+18 @04b25a>   : 10 02                      dup.x1 sp(2)
	<append+20 @04b25c>   : 10 01                      dup.x1 sp(1)
	<append+22 @04b25e>   : 51                         add.i32
	<append+23 @04b25f>   : 20                         load.i8
	<append+24 @04b260>   : 10 05                      dup.x1 sp(5)
	<append+26 @04b262>   : 10 05                      dup.x1 sp(5)
	<append+28 @04b264>   : 51                         add.i32
	<append+29 @04b265>   : 25                         store.i8
	lib/std/string.ci:119: (8 bytes: <@04b266> - <@04b26e>): int32(pos := int32(pos + 1));
	<append+30 @04b266>   : 10 03                      dup.x1 sp(3)
	<append+32 @04b268>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @04b26c>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes: <@04b26e> - <@04b272>): int32(i := int32(i + 1))
	<append+38 @04b26e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:114: (10 bytes: <@04b272> - <@04b27c>): value[i]
	<append+42 @04b272>   : 10 02                      dup.x1 sp(2)
	<append+44 @04b274>   : 10 01                      dup.x1 sp(1)
	<append+46 @04b276>   : 51                         add.i32
	<append+47 @04b277>   : 20                         load.i8
	<append+48 @04b278>   : 05 d5 ff ff                jnz <append+5 @04b24d>
	<append+52 @04b27c>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:122: (17 bytes: <@04b280> - <@04b291>): if (bool(pos >= (output.length)))
	<append+56 @04b280>   : 10 02                      dup.x1 sp(2)
	<append+58 @04b282>   : 10 05                      dup.x1 sp(5)
	<append+60 @04b284>   : 58                         clt.i32
	<append+61 @04b285>   : 05 0c 00 00                jnz <append+73 @04b291>
	lib/std/string.ci:123: (8 bytes: <@04b289> - <@04b291>): int32(pos := (uint32(output.length - (1))));
	<append+65 @04b289>   : 10 04                      dup.x1 sp(4)
	<append+67 @04b28b>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @04b28f>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes: <@04b291> - <@04b298>): char(output[pos] := (0));
	<append+73 @04b291>   : 19                         load.z32
	<append+74 @04b292>   : 10 04                      dup.x1 sp(4)
	<append+76 @04b294>   : 10 04                      dup.x1 sp(4)
	<append+78 @04b296>   : 51                         add.i32
	<append+79 @04b297>   : 25                         store.i8
	lib/std/string.ci:126: (4 bytes: <@04b298> - <@04b29c>): return int32(.result := pos);
	<append+80 @04b298>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @04b29b>   : 03                         ret
.references:
	lib/std/string.ci:113: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@04b2b0>
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@04b2b0> - <@04b541>)
	lib/std/string.ci:133: (1 byte: <@04b2b0> - <@04b2b1>): len: int32 := 0
	<append @04b2b0>      : 19                         load.z32
	lib/std/string.ci:134: (4 bytes: <@04b2b1> - <@04b2b5>): digits: char[80]
	<append+1 @04b2b1>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:136: (3 bytes: <@04b2b5> - <@04b2b8>): radix: int32 := format.radix
	<append+5 @04b2b5>    : 10 16                      dup.x1 sp(22)
	<append+7 @04b2b7>    : 22                         load.i32
	lib/std/string.ci:137: (54 bytes: <@04b2b8> - <@04b2ee>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @04b2b8>    : 10 00                      dup.x1 sp(0)
	<append+10 @04b2ba>   : 1c 01 00 00 00             load.c32 1
	<append+15 @04b2bf>   : 59                         cgt.i32
	<append+16 @04b2c0>   : 06 08 00 00                jz <append+24 @04b2c8>
	<append+20 @04b2c4>   : 04 2a 00 00                jmp <append+62 @04b2ee>
	<append+24 @04b2c8>   : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+29 @04b2cd>   : 1c 89 00 00 00             load.c32 137
	<append+34 @04b2d2>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @04b2d7>   : 1c 80 00 00 00             load.c32 128
	<append+44 @04b2dc>   : 1f 44 ce 01 00             load.ref <@01ce44> ;"radix is too small"
	<append+49 @04b2e1>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<append+54 @04b2e6>   : 0a 18 00 00                load.sp(+24)
	<append+58 @04b2ea>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes: <@04b2ee> - <@04b323>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @04b2ee>   : 10 00                      dup.x1 sp(0)
	<append+64 @04b2f0>   : 2a ac b2 04                load.m32 <@04b2ac> ;append.radixDigits+4
	<append+68 @04b2f4>   : 58                         clt.i32
	<append+69 @04b2f5>   : 06 08 00 00                jz <append+77 @04b2fd>
	<append+73 @04b2f9>   : 04 2a 00 00                jmp <append+115 @04b323>
	<append+77 @04b2fd>   : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+82 @04b302>   : 1c 8a 00 00 00             load.c32 138
	<append+87 @04b307>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @04b30c>   : 1c 80 00 00 00             load.c32 128
	<append+97 @04b311>   : 1f 57 ce 01 00             load.ref <@01ce57> ;"radix is too big"
	<append+102 @04b316>  : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<append+107 @04b31b>  : 0a 18 00 00                load.sp(+24)
	<append+111 @04b31f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes: <@04b323> - <@04b351>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @04b323>  : 04 26 00 00                jmp <append+153 @04b349>
	lib/std/string.ci:142: (27 bytes: <@04b327> - <@04b342>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @04b327>  : 2a a8 b2 04                load.m32 <@04b2a8> ;append.radixDigits
	<append+123 @04b32b>  : 10 19                      dup.x1 sp(25)
	<append+125 @04b32d>  : 10 02                      dup.x1 sp(2)
	<append+127 @04b32f>  : 35                         mod.u32
	<append+128 @04b330>  : 51                         add.i32
	<append+129 @04b331>  : 20                         load.i8
	<append+130 @04b332>  : 0a 08 00 00                load.sp(+8)
	<append+134 @04b336>  : 10 17                      dup.x1 sp(23)
	<append+136 @04b338>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @04b33c>  : 10 00                      dup.x1 sp(0)
	<append+142 @04b33e>  : 13 19                      set.x1 sp(25)
	<append+144 @04b340>  : 51                         add.i32
	<append+145 @04b341>  : 25                         store.i8
	lib/std/string.ci:141: (7 bytes: <@04b342> - <@04b349>): uint32(value := uint32(value / (radix)))
	<append+146 @04b342>  : 10 18                      dup.x1 sp(24)
	<append+148 @04b344>  : 10 01                      dup.x1 sp(1)
	<append+150 @04b346>  : 34                         div.u32
	<append+151 @04b347>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes: <@04b349> - <@04b351>): bool(value > (0))
	<append+153 @04b349>  : 10 18                      dup.x1 sp(24)
	<append+155 @04b34b>  : 19                         load.z32
	<append+156 @04b34c>  : 39                         cgt.u32
	<append+157 @04b34d>  : 05 da ff ff                jnz <append+119 @04b327>
	lib/std/string.ci:144: (29 bytes: <@04b351> - <@04b36e>): if (bool(len == 0))
	<append+161 @04b351>  : 10 15                      dup.x1 sp(21)
	<append+163 @04b353>  : 19                         load.z32
	<append+164 @04b354>  : 57                         ceq.i32
	<append+165 @04b355>  : 06 19 00 00                jz <append+190 @04b36e>
	lib/std/string.ci:145: (21 bytes: <@04b359> - <@04b36e>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @04b359>  : 1c 30 00 00 00             load.c32 48
	<append+174 @04b35e>  : 0a 08 00 00                load.sp(+8)
	<append+178 @04b362>  : 10 17                      dup.x1 sp(23)
	<append+180 @04b364>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @04b368>  : 10 00                      dup.x1 sp(0)
	<append+186 @04b36a>  : 13 19                      set.x1 sp(25)
	<append+188 @04b36c>  : 51                         add.i32
	<append+189 @04b36d>  : 25                         store.i8
	lib/std/string.ci:148: (10 bytes: <@04b36e> - <@04b378>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @04b36e>  : 10 17                      dup.x1 sp(23)
	<append+192 @04b370>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @04b374>  : 22                         load.i32
	<append+197 @04b375>  : 10 16                      dup.x1 sp(22)
	<append+199 @04b377>  : 52                         sub.i32
	lib/std/string.ci:150: (7 bytes: <@04b378> - <@04b37f>): padChr: char := format.padChr
	<append+200 @04b378>  : 10 18                      dup.x1 sp(24)
	<append+202 @04b37a>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @04b37e>  : 20                         load.i8
	lib/std/string.ci:151: (21 bytes: <@04b37f> - <@04b394>): if (bool(padChr == ''))
	<append+207 @04b37f>  : 0a 00 00 00                load.sp(+0)
	<append+211 @04b383>  : 20                         load.i8
	<append+212 @04b384>  : 19                         load.z32
	<append+213 @04b385>  : 57                         ceq.i32
	<append+214 @04b386>  : 06 0e 00 00                jz <append+228 @04b394>
	lib/std/string.ci:152: (10 bytes: <@04b38a> - <@04b394>): char(padChr := ' ');
	<append+218 @04b38a>  : 1c 20 00 00 00             load.c32 32
	<append+223 @04b38f>  : 0a 04 00 00                load.sp(+4)
	<append+227 @04b393>  : 25                         store.i8
	lib/std/string.ci:156: (207 bytes: <@04b394> - <@04b463>): if (bool((sign) != 0))
	<append+228 @04b394>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @04b398>  : 20                         load.i8
	<append+233 @04b399>  : 19                         load.z32
	<append+234 @04b39a>  : 57                         ceq.i32
	<append+235 @04b39b>  : 05 c8 00 00                jnz <append+435 @04b463>
	lib/std/string.ci:157: (8 bytes: <@04b39f> - <@04b3a7>): int32(maxLen := int32(maxLen - 1));
	<append+239 @04b39f>  : 10 01                      dup.x1 sp(1)
	<append+241 @04b3a1>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @04b3a5>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes: <@04b3a7> - <@04b41c>): if (contains(void(whiteSpace, padChr)))
	<append+247 @04b3a7>  : 19                         load.z32
	<append+248 @04b3a8>  : 2a a0 b2 04                load.m32 <@04b2a0> ;append.whiteSpace
	<append+252 @04b3ac>  : 0a 08 00 00                load.sp(+8)
	<append+256 @04b3b0>  : 20                         load.i8
	<append+257 @04b3b1>  : 1f 48 b0 04 00             load.ref <@04b048> ;indexOf(str: char[*], chr: char): int32
	<append+262 @04b3b6>  : 02                         call
	<append+263 @04b3b7>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @04b3bb>  : 19                         load.z32
	<append+268 @04b3bc>  : 58                         clt.i32
	<append+269 @04b3bd>  : 05 5f 00 00                jnz <append+364 @04b41c>
	lib/std/string.ci:160: (91 bytes: <@04b3c1> - <@04b41c>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @04b3c1>  : 04 53 00 00                jmp <append+356 @04b414>
	lib/std/string.ci:161: (52 bytes: <@04b3c5> - <@04b3f9>): assert(bool(pos < (output.length)));
	<append+277 @04b3c5>  : 10 1c                      dup.x1 sp(28)
	<append+279 @04b3c7>  : 10 1f                      dup.x1 sp(31)
	<append+281 @04b3c9>  : 58                         clt.i32
	<append+282 @04b3ca>  : 06 08 00 00                jz <append+290 @04b3d2>
	<append+286 @04b3ce>  : 04 2b 00 00                jmp <append+329 @04b3f9>
	<append+290 @04b3d2>  : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+295 @04b3d7>  : 1c a1 00 00 00             load.c32 161
	<append+300 @04b3dc>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @04b3e1>  : 1c 80 00 00 00             load.c32 128
	<append+310 @04b3e6>  : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<append+315 @04b3eb>  : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<append+320 @04b3f0>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @04b3f5>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes: <@04b3f9> - <@04b404>): char(output[pos] := padChr);
	<append+329 @04b3f9>  : 0a 00 00 00                load.sp(+0)
	<append+333 @04b3fd>  : 20                         load.i8
	<append+334 @04b3fe>  : 10 1e                      dup.x1 sp(30)
	<append+336 @04b400>  : 10 1e                      dup.x1 sp(30)
	<append+338 @04b402>  : 51                         add.i32
	<append+339 @04b403>  : 25                         store.i8
	lib/std/string.ci:163: (8 bytes: <@04b404> - <@04b40c>): int32(pos := int32(pos + 1));
	<append+340 @04b404>  : 10 1c                      dup.x1 sp(28)
	<append+342 @04b406>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @04b40a>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes: <@04b40c> - <@04b414>): int32(maxLen := int32(maxLen - 1))
	<append+348 @04b40c>  : 10 01                      dup.x1 sp(1)
	<append+350 @04b40e>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @04b412>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes: <@04b414> - <@04b41c>): bool(maxLen > 0)
	<append+356 @04b414>  : 10 01                      dup.x1 sp(1)
	<append+358 @04b416>  : 19                         load.z32
	<append+359 @04b417>  : 59                         cgt.i32
	<append+360 @04b418>  : 05 ad ff ff                jnz <append+277 @04b3c5>
	lib/std/string.ci:166: (52 bytes: <@04b41c> - <@04b450>): assert(bool(pos < (output.length)));
	<append+364 @04b41c>  : 10 1c                      dup.x1 sp(28)
	<append+366 @04b41e>  : 10 1f                      dup.x1 sp(31)
	<append+368 @04b420>  : 58                         clt.i32
	<append+369 @04b421>  : 06 08 00 00                jz <append+377 @04b429>
	<append+373 @04b425>  : 04 2b 00 00                jmp <append+416 @04b450>
	<append+377 @04b429>  : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+382 @04b42e>  : 1c a6 00 00 00             load.c32 166
	<append+387 @04b433>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @04b438>  : 1c 80 00 00 00             load.c32 128
	<append+397 @04b43d>  : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<append+402 @04b442>  : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<append+407 @04b447>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @04b44c>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes: <@04b450> - <@04b45b>): char(output[pos] := sign);
	<append+416 @04b450>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @04b454>  : 20                         load.i8
	<append+421 @04b455>  : 10 1e                      dup.x1 sp(30)
	<append+423 @04b457>  : 10 1e                      dup.x1 sp(30)
	<append+425 @04b459>  : 51                         add.i32
	<append+426 @04b45a>  : 25                         store.i8
	lib/std/string.ci:168: (8 bytes: <@04b45b> - <@04b463>): int32(pos := int32(pos + 1));
	<append+427 @04b45b>  : 10 1c                      dup.x1 sp(28)
	<append+429 @04b45d>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @04b461>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes: <@04b463> - <@04b4be>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @04b463>  : 04 53 00 00                jmp <append+518 @04b4b6>
	lib/std/string.ci:173: (52 bytes: <@04b467> - <@04b49b>): assert(bool(pos < (output.length)));
	<append+439 @04b467>  : 10 1c                      dup.x1 sp(28)
	<append+441 @04b469>  : 10 1f                      dup.x1 sp(31)
	<append+443 @04b46b>  : 58                         clt.i32
	<append+444 @04b46c>  : 06 08 00 00                jz <append+452 @04b474>
	<append+448 @04b470>  : 04 2b 00 00                jmp <append+491 @04b49b>
	<append+452 @04b474>  : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+457 @04b479>  : 1c ad 00 00 00             load.c32 173
	<append+462 @04b47e>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @04b483>  : 1c 80 00 00 00             load.c32 128
	<append+472 @04b488>  : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<append+477 @04b48d>  : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<append+482 @04b492>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @04b497>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes: <@04b49b> - <@04b4a6>): char(output[pos] := padChr);
	<append+491 @04b49b>  : 0a 00 00 00                load.sp(+0)
	<append+495 @04b49f>  : 20                         load.i8
	<append+496 @04b4a0>  : 10 1e                      dup.x1 sp(30)
	<append+498 @04b4a2>  : 10 1e                      dup.x1 sp(30)
	<append+500 @04b4a4>  : 51                         add.i32
	<append+501 @04b4a5>  : 25                         store.i8
	lib/std/string.ci:175: (8 bytes: <@04b4a6> - <@04b4ae>): int32(pos := int32(pos + 1));
	<append+502 @04b4a6>  : 10 1c                      dup.x1 sp(28)
	<append+504 @04b4a8>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @04b4ac>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes: <@04b4ae> - <@04b4b6>): int32(maxLen := int32(maxLen - 1))
	<append+510 @04b4ae>  : 10 01                      dup.x1 sp(1)
	<append+512 @04b4b0>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @04b4b4>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes: <@04b4b6> - <@04b4be>): bool(maxLen > 0)
	<append+518 @04b4b6>  : 10 01                      dup.x1 sp(1)
	<append+520 @04b4b8>  : 19                         load.z32
	<append+521 @04b4b9>  : 59                         cgt.i32
	<append+522 @04b4ba>  : 05 ad ff ff                jnz <append+439 @04b467>
	lib/std/string.ci:179: (99 bytes: <@04b4be> - <@04b521>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @04b4be>  : 19                         load.z32
	<append+527 @04b4bf>  : 04 55 00 00                jmp <append+612 @04b514>
	lib/std/string.ci:180: (52 bytes: <@04b4c3> - <@04b4f7>): assert(bool(i < (output.length)));
	<append+531 @04b4c3>  : 10 00                      dup.x1 sp(0)
	<append+533 @04b4c5>  : 10 20                      dup.x1 sp(32)
	<append+535 @04b4c7>  : 58                         clt.i32
	<append+536 @04b4c8>  : 06 08 00 00                jz <append+544 @04b4d0>
	<append+540 @04b4cc>  : 04 2b 00 00                jmp <append+583 @04b4f7>
	<append+544 @04b4d0>  : 1f e0 cc 01 00             load.ref <@01cce0> ;"lib/std/string.ci"
	<append+549 @04b4d5>  : 1c b4 00 00 00             load.c32 180
	<append+554 @04b4da>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @04b4df>  : 1c 80 00 00 00             load.c32 128
	<append+564 @04b4e4>  : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<append+569 @04b4e9>  : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<append+574 @04b4ee>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @04b4f3>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes: <@04b4f7> - <@04b508>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @04b4f7>  : 0a 10 00 00                load.sp(+16)
	<append+587 @04b4fb>  : 10 19                      dup.x1 sp(25)
	<append+589 @04b4fd>  : 10 02                      dup.x1 sp(2)
	<append+591 @04b4ff>  : 52                         sub.i32
	<append+592 @04b500>  : 51                         add.i32
	<append+593 @04b501>  : 20                         load.i8
	<append+594 @04b502>  : 10 1f                      dup.x1 sp(31)
	<append+596 @04b504>  : 10 1f                      dup.x1 sp(31)
	<append+598 @04b506>  : 51                         add.i32
	<append+599 @04b507>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@04b508> - <@04b510>): int32(pos := int32(pos + 1));
	<append+600 @04b508>  : 10 1d                      dup.x1 sp(29)
	<append+602 @04b50a>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @04b50e>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes: <@04b510> - <@04b514>): int32(i := int32(i + 1))
	<append+608 @04b510>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:179: (9 bytes: <@04b514> - <@04b51d>): bool(i < len)
	<append+612 @04b514>  : 10 00                      dup.x1 sp(0)
	<append+614 @04b516>  : 10 19                      dup.x1 sp(25)
	<append+616 @04b518>  : 58                         clt.i32
	<append+617 @04b519>  : 05 aa ff ff                jnz <append+531 @04b4c3>
	<append+621 @04b51d>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:185: (17 bytes: <@04b521> - <@04b532>): if (bool(pos >= (output.length)))
	<append+625 @04b521>  : 10 1c                      dup.x1 sp(28)
	<append+627 @04b523>  : 10 1f                      dup.x1 sp(31)
	<append+629 @04b525>  : 58                         clt.i32
	<append+630 @04b526>  : 05 0c 00 00                jnz <append+642 @04b532>
	lib/std/string.ci:186: (8 bytes: <@04b52a> - <@04b532>): int32(pos := (uint32(output.length - (1))));
	<append+634 @04b52a>  : 10 1e                      dup.x1 sp(30)
	<append+636 @04b52c>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @04b530>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes: <@04b532> - <@04b539>): char(output[pos] := (0));
	<append+642 @04b532>  : 19                         load.z32
	<append+643 @04b533>  : 10 1e                      dup.x1 sp(30)
	<append+645 @04b535>  : 10 1e                      dup.x1 sp(30)
	<append+647 @04b537>  : 51                         add.i32
	<append+648 @04b538>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@04b539> - <@04b541>): return int32(.result := pos);
	<append+649 @04b539>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @04b53c>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @04b540>  : 03                         ret
.references:
	lib/std/string.ci:202: referenced as `append`
	lib/std/string.ci:193: referenced as `append`
	lib/std/string.ci:129: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@04b548>
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@04b548> - <@04b55f>)
	lib/std/string.ci:193: (23 bytes: <@04b548> - <@04b55f>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @04b548>      : 19                         load.z32
	<append+1 @04b549>    : 11 05                      dup.x2 sp(5)
	<append+3 @04b54b>    : 10 06                      dup.x1 sp(6)
	<append+5 @04b54d>    : 19                         load.z32
	<append+6 @04b54e>    : 10 07                      dup.x1 sp(7)
	<append+8 @04b550>    : 10 07                      dup.x1 sp(7)
	<append+10 @04b552>   : 1f b0 b2 04 00             load.ref <@04b2b0> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @04b557>   : 02                         call
	<append+16 @04b558>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @04b55c>   : 13 07                      set.x1 sp(7)
	<append+22 @04b55e>   : 03                         ret
.references:
	lib/std/string.ci:207: referenced as `append`
	lib/std/string.ci:192: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@04b560>
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@04b560> - <@04b591>)
	lib/std/string.ci:197: (1 byte: <@04b560> - <@04b561>): sign: int32 := 0
	<append @04b560>      : 19                         load.z32
	lib/std/string.ci:198: (20 bytes: <@04b561> - <@04b575>): if (bool(value < 0))
	<append+1 @04b561>    : 10 03                      dup.x1 sp(3)
	<append+3 @04b563>    : 19                         load.z32
	<append+4 @04b564>    : 58                         clt.i32
	<append+5 @04b565>    : 06 10 00 00                jz <append+21 @04b575>
	lib/std/string.ci:199: (7 bytes: <@04b569> - <@04b570>): int32(sign := ('-'));
	<append+9 @04b569>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @04b56e>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes: <@04b570> - <@04b575>): int32(value := int32(-value));
	<append+16 @04b570>   : 10 03                      dup.x1 sp(3)
	<append+18 @04b572>   : 50                         neg.i32
	<append+19 @04b573>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes: <@04b575> - <@04b591>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @04b575>   : 19                         load.z32
	<append+22 @04b576>   : 11 06                      dup.x2 sp(6)
	<append+24 @04b578>   : 10 07                      dup.x1 sp(7)
	<append+26 @04b57a>   : 10 04                      dup.x1 sp(4)
	<append+28 @04b57c>   : 10 08                      dup.x1 sp(8)
	<append+30 @04b57e>   : 10 08                      dup.x1 sp(8)
	<append+32 @04b580>   : 1f b0 b2 04 00             load.ref <@04b2b0> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @04b585>   : 02                         call
	<append+38 @04b586>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @04b58a>   : 13 08                      set.x1 sp(8)
	<append+44 @04b58c>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @04b590>   : 03                         ret
.references:
	lib/std/string.ci:196: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@04b5a8>
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@04b5a8> - <@04b5c1>)
	lib/std/string.ci:207: (25 bytes: <@04b5a8> - <@04b5c1>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @04b5a8>      : 19                         load.z32
	<append+1 @04b5a9>    : 11 04                      dup.x2 sp(4)
	<append+3 @04b5ab>    : 10 05                      dup.x1 sp(5)
	<append+5 @04b5ad>    : 10 05                      dup.x1 sp(5)
	<append+7 @04b5af>    : 1f 98 b5 04 00             load.ref <@04b598> ;append.format
	<append+12 @04b5b4>   : 1f 48 b5 04 00             load.ref <@04b548> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @04b5b9>   : 02                         call
	<append+18 @04b5ba>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @04b5be>   : 13 06                      set.x1 sp(6)
	<append+24 @04b5c0>   : 03                         ret
.references:
	lib/std/string.ci:205: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@021f00>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:3'
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.references:
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:8: referenced as `vec2d`
	lib/vec/vec2d.ci:3: defined as `vec2d`
}
vec2d.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:4'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:10: referenced as `x`
	lib/vec/vec2d.ci:4: defined as `x`
}
vec2d.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:5'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:11: referenced as `y`
	lib/vec/vec2d.ci:5: defined as `y`
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@04b5c8>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:8'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@04b5c8> - <@04b5cf>)
	lib/vec/vec2d.ci:9: (7 bytes: <@04b5c8> - <@04b5cf>): return void(.result := {...});
	<vec2d @04b5c8>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:11: (3 bytes: <@04b5cb> - <@04b5ce>): void(.result.y := y);
	<vec2d+3 @04b5cb>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @04b5ce>    : 03                         ret
.references:
	lib/vec/vec2d.ci:8: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:15'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.references:
	lib/vec/vec2d.ci:15: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:16'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.references:
	lib/vec/vec2d.ci:16: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0227a8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:3'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field .anonymous: vec4f..anonymous (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:9: referenced as `vec4f`
	lib/vec/mat4f.ci:8: referenced as `vec4f`
	lib/vec/mat4f.ci:7: referenced as `vec4f`
	lib/vec/mat4f.ci:6: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:74: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:21: referenced as `vec4f`
	lib/vec/vec4f.ci:3: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:4'
.owner: vec4f
.references:
	lib/vec/vec4f.ci:4: defined as `data`
}
vec4f..anonymous: vec4f..anonymous {
.kind: variable(val)
.base: `vec4f..anonymous`
.size: 16
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/vec4f.ci:84'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.references:
	lib/vec/vec4f.ci:84: defined as `.anonymous`
}
vec4f..anonymous.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:21: referenced as `x`
	lib/vec/mat4f.ci:20: referenced as `x`
	lib/vec/mat4f.ci:19: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/vec4f.ci:77: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:25: referenced as `x`
	lib/vec/vec4f.ci:22: referenced as `x`
	lib/vec/vec4f.ci:6: defined as `x`
}
vec4f..anonymous.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:21: referenced as `y`
	lib/vec/mat4f.ci:20: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:18: referenced as `y`
	lib/vec/vec4f.ci:77: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:25: referenced as `y`
	lib/vec/vec4f.ci:22: referenced as `y`
	lib/vec/vec4f.ci:7: defined as `y`
}
vec4f..anonymous.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:21: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:19: referenced as `z`
	lib/vec/mat4f.ci:18: referenced as `z`
	lib/vec/vec4f.ci:77: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:25: referenced as `z`
	lib/vec/vec4f.ci:22: referenced as `z`
	lib/vec/vec4f.ci:8: defined as `z`
}
vec4f..anonymous.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:20: referenced as `w`
	lib/vec/mat4f.ci:19: referenced as `w`
	lib/vec/mat4f.ci:18: referenced as `w`
	lib/vec/vec4f.ci:77: referenced as `w`
	lib/vec/vec4f.ci:22: referenced as `w`
	lib/vec/vec4f.ci:9: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.value: x: float32
.references:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f
.value: y: float32
.references:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f
.value: z: float32
.references:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.value: w: float32
.references:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@04b5d0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:21'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@04b5d0> - <@04b5dd>)
	lib/vec/vec4f.ci:22: (13 bytes: <@04b5d0> - <@04b5dd>): return void(.result := {...});
	<vec4f @04b5d0>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:22: (3 bytes: <@04b5d3> - <@04b5d6>): void(.result.y := y);
	<vec4f+3 @04b5d3>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:22: (3 bytes: <@04b5d6> - <@04b5d9>): void(.result.z := z);
	<vec4f+6 @04b5d6>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:22: (3 bytes: <@04b5d9> - <@04b5dc>): void(.result.w := w);
	<vec4f+9 @04b5d9>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @04b5dc>   : 03                         ret
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/vec4f.ci:26: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:24: referenced as `vec4f`
	lib/vec/vec4f.ci:21: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:24'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.value: vec4f(void(void(void(x, y), z), 0.000000))
.references:
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:24: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:25'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.references:
	lib/vec/vec4f.ci:25: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: vec4f(void(void(void(val, val), val), val))
.references:
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:26: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:56'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.references:
	lib/vec/vec4f.ci:56: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:57'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.references:
	lib/vec/vec4f.ci:57: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:58'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.references:
	lib/vec/vec4f.ci:58: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:59'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.references:
	lib/vec/vec4f.ci:59: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:60'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.references:
	lib/vec/vec4f.ci:75: referenced as `div`
	lib/vec/vec4f.ci:60: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:62'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.references:
	lib/vec/vec4f.ci:62: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:63'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.references:
	lib/vec/vec4f.ci:63: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:68'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.references:
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/vec4f.ci:74: referenced as `dp3`
	lib/vec/vec4f.ci:68: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:69'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.references:
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/vec4f.ci:69: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:70'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.references:
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/vec4f.ci:70: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:72'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.references:
	lib/vec/vec4f.ci:72: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:74'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.value: float32.sqrt(dp3(void(v, v)))
.references:
	lib/vec/vec4f.ci:75: referenced as `len`
	lib/vec/vec4f.ci:74: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.value: div(void(v, vec4f(len(v))))
.references:
	lib/vec/vec4f.ci:75: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:77'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.references:
	lib/vec/vec4f.ci:77: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@025758>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:3'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field .anonymous: mat4f..anonymous (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:34: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:31: referenced as `mat4f`
	lib/vec/mat4f.ci:30: referenced as `mat4f`
	lib/vec/mat4f.ci:29: referenced as `mat4f`
	lib/vec/mat4f.ci:25: referenced as `mat4f`
	lib/vec/mat4f.ci:13: referenced as `mat4f`
	lib/vec/mat4f.ci:3: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:4'
.owner: mat4f
.references:
	lib/vec/mat4f.ci:4: defined as `data`
}
mat4f..anonymous: mat4f..anonymous {
.kind: variable(val)
.base: `mat4f..anonymous`
.size: 64
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.references:
	lib/vec/mat4f.ci:59: defined as `.anonymous`
}
mat4f..anonymous.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:31: referenced as `x`
	lib/vec/mat4f.ci:30: referenced as `x`
	lib/vec/mat4f.ci:29: referenced as `x`
	lib/vec/mat4f.ci:26: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/mat4f.ci:6: defined as `x`
}
mat4f..anonymous.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:31: referenced as `y`
	lib/vec/mat4f.ci:30: referenced as `y`
	lib/vec/mat4f.ci:29: referenced as `y`
	lib/vec/mat4f.ci:26: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:7: defined as `y`
}
mat4f..anonymous.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:31: referenced as `z`
	lib/vec/mat4f.ci:30: referenced as `z`
	lib/vec/mat4f.ci:29: referenced as `z`
	lib/vec/mat4f.ci:26: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:8: defined as `z`
}
mat4f..anonymous.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:31: referenced as `w`
	lib/vec/mat4f.ci:30: referenced as `w`
	lib/vec/mat4f.ci:26: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:9: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.value: x: vec4f
.references:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f
.value: y: vec4f
.references:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f
.value: z: vec4f
.references:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.value: w: vec4f
.references:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@04b5e0>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:13'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@04b5e0> - <@04b611>)
	lib/vec/mat4f.ci:17: (49 bytes: <@04b5e0> - <@04b611>): return void(.result := {...});
	<mat4f @04b5e0>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:18: (3 bytes: <@04b5e3> - <@04b5e6>): void(.result.x.y := xy);
	<mat4f+3 @04b5e3>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:18: (3 bytes: <@04b5e6> - <@04b5e9>): void(.result.x.z := xz);
	<mat4f+6 @04b5e6>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:18: (3 bytes: <@04b5e9> - <@04b5ec>): void(.result.x.w := xw);
	<mat4f+9 @04b5e9>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:19: (3 bytes: <@04b5ec> - <@04b5ef>): void(.result.y.x := yx);
	<mat4f+12 @04b5ec>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:19: (3 bytes: <@04b5ef> - <@04b5f2>): void(.result.y.y := yy);
	<mat4f+15 @04b5ef>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:19: (3 bytes: <@04b5f2> - <@04b5f5>): void(.result.y.z := yz);
	<mat4f+18 @04b5f2>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:19: (3 bytes: <@04b5f5> - <@04b5f8>): void(.result.y.w := yw);
	<mat4f+21 @04b5f5>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:20: (3 bytes: <@04b5f8> - <@04b5fb>): void(.result.z.x := zx);
	<mat4f+24 @04b5f8>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:20: (3 bytes: <@04b5fb> - <@04b5fe>): void(.result.z.y := zy);
	<mat4f+27 @04b5fb>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:20: (3 bytes: <@04b5fe> - <@04b601>): void(.result.z.z := zz);
	<mat4f+30 @04b5fe>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:20: (3 bytes: <@04b601> - <@04b604>): void(.result.z.w := zw);
	<mat4f+33 @04b601>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:21: (3 bytes: <@04b604> - <@04b607>): void(.result.w.x := wx);
	<mat4f+36 @04b604>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:21: (3 bytes: <@04b607> - <@04b60a>): void(.result.w.y := wy);
	<mat4f+39 @04b607>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:21: (3 bytes: <@04b60a> - <@04b60d>): void(.result.w.z := wz);
	<mat4f+42 @04b60a>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:21: (3 bytes: <@04b60d> - <@04b610>): void(.result.w.w := ww);
	<mat4f+45 @04b60d>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @04b610>   : 03                         ret
.references:
	lib/vec/mat4f.ci:13: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@04b618>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:25'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@04b618> - <@04b62d>)
	lib/vec/mat4f.ci:26: (21 bytes: <@04b618> - <@04b62d>): return void(.result := {...});
	<mat4f @04b618>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @04b61a>    : 24                         load.i128
	<mat4f+3 @04b61b>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:26: (5 bytes: <@04b61d> - <@04b622>): void(.result.y := y);
	<mat4f+5 @04b61d>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @04b61f>    : 24                         load.i128
	<mat4f+8 @04b620>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:26: (5 bytes: <@04b622> - <@04b627>): void(.result.z := z);
	<mat4f+10 @04b622>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @04b624>   : 24                         load.i128
	<mat4f+13 @04b625>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:26: (5 bytes: <@04b627> - <@04b62c>): void(.result.w := w);
	<mat4f+15 @04b627>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @04b629>   : 24                         load.i128
	<mat4f+18 @04b62a>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @04b62c>   : 03                         ret
.references:
	lib/vec/mat4f.ci:25: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.references:
	lib/vec/mat4f.ci:29: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:30'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:45: referenced as `dp4`
	lib/vec/mat4f.ci:44: referenced as `dp4`
	lib/vec/mat4f.ci:43: referenced as `dp4`
	lib/vec/mat4f.ci:42: referenced as `dp4`
	lib/vec/mat4f.ci:30: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:31'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:31: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@04b630>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:33'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@04b630> - <@04b7d1>)
	lib/vec/mat4f.ci:34: (144 bytes: <@04b630> - <@04b6c0>): transposed: mat4f := {...}
	<mul @04b630>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:35: (5 bytes: <@04b634> - <@04b639>): void(transposed.x.x := rhs.x.x);
	<mul+4 @04b634>    : 10 11                      dup.x1 sp(17)
	<mul+6 @04b636>    : 22                         load.i32
	<mul+7 @04b637>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:35: (9 bytes: <@04b639> - <@04b642>): void(transposed.x.y := rhs.y.x);
	<mul+9 @04b639>    : 10 11                      dup.x1 sp(17)
	<mul+11 @04b63b>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @04b63f>   : 22                         load.i32
	<mul+16 @04b640>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:35: (9 bytes: <@04b642> - <@04b64b>): void(transposed.x.z := rhs.z.x);
	<mul+18 @04b642>   : 10 11                      dup.x1 sp(17)
	<mul+20 @04b644>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @04b648>   : 22                         load.i32
	<mul+25 @04b649>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:35: (9 bytes: <@04b64b> - <@04b654>): void(transposed.x.w := rhs.w.x);
	<mul+27 @04b64b>   : 10 11                      dup.x1 sp(17)
	<mul+29 @04b64d>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @04b651>   : 22                         load.i32
	<mul+34 @04b652>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:36: (9 bytes: <@04b654> - <@04b65d>): void(transposed.y.x := rhs.x.y);
	<mul+36 @04b654>   : 10 11                      dup.x1 sp(17)
	<mul+38 @04b656>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @04b65a>   : 22                         load.i32
	<mul+43 @04b65b>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:36: (9 bytes: <@04b65d> - <@04b666>): void(transposed.y.y := rhs.y.y);
	<mul+45 @04b65d>   : 10 11                      dup.x1 sp(17)
	<mul+47 @04b65f>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @04b663>   : 22                         load.i32
	<mul+52 @04b664>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:36: (9 bytes: <@04b666> - <@04b66f>): void(transposed.y.z := rhs.z.y);
	<mul+54 @04b666>   : 10 11                      dup.x1 sp(17)
	<mul+56 @04b668>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @04b66c>   : 22                         load.i32
	<mul+61 @04b66d>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:36: (9 bytes: <@04b66f> - <@04b678>): void(transposed.y.w := rhs.w.y);
	<mul+63 @04b66f>   : 10 11                      dup.x1 sp(17)
	<mul+65 @04b671>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @04b675>   : 22                         load.i32
	<mul+70 @04b676>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:37: (9 bytes: <@04b678> - <@04b681>): void(transposed.z.x := rhs.x.z);
	<mul+72 @04b678>   : 10 11                      dup.x1 sp(17)
	<mul+74 @04b67a>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @04b67e>   : 22                         load.i32
	<mul+79 @04b67f>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:37: (9 bytes: <@04b681> - <@04b68a>): void(transposed.z.y := rhs.y.z);
	<mul+81 @04b681>   : 10 11                      dup.x1 sp(17)
	<mul+83 @04b683>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @04b687>   : 22                         load.i32
	<mul+88 @04b688>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:37: (9 bytes: <@04b68a> - <@04b693>): void(transposed.z.z := rhs.z.z);
	<mul+90 @04b68a>   : 10 11                      dup.x1 sp(17)
	<mul+92 @04b68c>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @04b690>   : 22                         load.i32
	<mul+97 @04b691>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:37: (9 bytes: <@04b693> - <@04b69c>): void(transposed.z.w := rhs.w.z);
	<mul+99 @04b693>   : 10 11                      dup.x1 sp(17)
	<mul+101 @04b695>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @04b699>  : 22                         load.i32
	<mul+106 @04b69a>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:38: (9 bytes: <@04b69c> - <@04b6a5>): void(transposed.w.x := rhs.x.w);
	<mul+108 @04b69c>  : 10 11                      dup.x1 sp(17)
	<mul+110 @04b69e>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @04b6a2>  : 22                         load.i32
	<mul+115 @04b6a3>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:38: (9 bytes: <@04b6a5> - <@04b6ae>): void(transposed.w.y := rhs.y.w);
	<mul+117 @04b6a5>  : 10 11                      dup.x1 sp(17)
	<mul+119 @04b6a7>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @04b6ab>  : 22                         load.i32
	<mul+124 @04b6ac>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:38: (9 bytes: <@04b6ae> - <@04b6b7>): void(transposed.w.z := rhs.z.w);
	<mul+126 @04b6ae>  : 10 11                      dup.x1 sp(17)
	<mul+128 @04b6b0>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @04b6b4>  : 22                         load.i32
	<mul+133 @04b6b5>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:38: (9 bytes: <@04b6b7> - <@04b6c0>): void(transposed.w.w := rhs.w.w);
	<mul+135 @04b6b7>  : 10 11                      dup.x1 sp(17)
	<mul+137 @04b6b9>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @04b6bd>  : 22                         load.i32
	<mul+142 @04b6be>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:41: (273 bytes: <@04b6c0> - <@04b7d1>): return void(.result := {...});
	<mul+144 @04b6c0>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @04b6c4>  : 10 13                      dup.x1 sp(19)
	<mul+150 @04b6c6>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @04b6ca>  : 10 04                      dup.x1 sp(4)
	<mul+156 @04b6cc>  : 24                         load.i128
	<mul+157 @04b6cd>  : 10 09                      dup.x1 sp(9)
	<mul+159 @04b6cf>  : 24                         load.i128
	<mul+160 @04b6d0>  : 9b                         dp4.v4f
	<mul+161 @04b6d1>  : 10 05                      dup.x1 sp(5)
	<mul+163 @04b6d3>  : 24                         load.i128
	<mul+164 @04b6d4>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @04b6d6>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @04b6da>  : 24                         load.i128
	<mul+171 @04b6db>  : 9b                         dp4.v4f
	<mul+172 @04b6dc>  : 10 06                      dup.x1 sp(6)
	<mul+174 @04b6de>  : 24                         load.i128
	<mul+175 @04b6df>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @04b6e1>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @04b6e5>  : 24                         load.i128
	<mul+182 @04b6e6>  : 9b                         dp4.v4f
	<mul+183 @04b6e7>  : 10 07                      dup.x1 sp(7)
	<mul+185 @04b6e9>  : 24                         load.i128
	<mul+186 @04b6ea>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @04b6ec>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @04b6f0>  : 24                         load.i128
	<mul+193 @04b6f1>  : 9b                         dp4.v4f
	<mul+194 @04b6f2>  : 1f d0 b5 04 00             load.ref <@04b5d0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @04b6f7>  : 02                         call
	<mul+200 @04b6f8>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @04b6fc>  : 15 02                      set.x4 sp(2)
	<mul+206 @04b6fe>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:43: (68 bytes: <@04b700> - <@04b744>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @04b700>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @04b704>  : 10 13                      dup.x1 sp(19)
	<mul+214 @04b706>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @04b70a>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @04b70e>  : 10 04                      dup.x1 sp(4)
	<mul+224 @04b710>  : 24                         load.i128
	<mul+225 @04b711>  : 10 09                      dup.x1 sp(9)
	<mul+227 @04b713>  : 24                         load.i128
	<mul+228 @04b714>  : 9b                         dp4.v4f
	<mul+229 @04b715>  : 10 05                      dup.x1 sp(5)
	<mul+231 @04b717>  : 24                         load.i128
	<mul+232 @04b718>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @04b71a>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @04b71e>  : 24                         load.i128
	<mul+239 @04b71f>  : 9b                         dp4.v4f
	<mul+240 @04b720>  : 10 06                      dup.x1 sp(6)
	<mul+242 @04b722>  : 24                         load.i128
	<mul+243 @04b723>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @04b725>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @04b729>  : 24                         load.i128
	<mul+250 @04b72a>  : 9b                         dp4.v4f
	<mul+251 @04b72b>  : 10 07                      dup.x1 sp(7)
	<mul+253 @04b72d>  : 24                         load.i128
	<mul+254 @04b72e>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @04b730>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @04b734>  : 24                         load.i128
	<mul+261 @04b735>  : 9b                         dp4.v4f
	<mul+262 @04b736>  : 1f d0 b5 04 00             load.ref <@04b5d0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @04b73b>  : 02                         call
	<mul+268 @04b73c>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @04b740>  : 15 02                      set.x4 sp(2)
	<mul+274 @04b742>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:44: (68 bytes: <@04b744> - <@04b788>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @04b744>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @04b748>  : 10 13                      dup.x1 sp(19)
	<mul+282 @04b74a>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @04b74e>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @04b752>  : 10 04                      dup.x1 sp(4)
	<mul+292 @04b754>  : 24                         load.i128
	<mul+293 @04b755>  : 10 09                      dup.x1 sp(9)
	<mul+295 @04b757>  : 24                         load.i128
	<mul+296 @04b758>  : 9b                         dp4.v4f
	<mul+297 @04b759>  : 10 05                      dup.x1 sp(5)
	<mul+299 @04b75b>  : 24                         load.i128
	<mul+300 @04b75c>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @04b75e>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @04b762>  : 24                         load.i128
	<mul+307 @04b763>  : 9b                         dp4.v4f
	<mul+308 @04b764>  : 10 06                      dup.x1 sp(6)
	<mul+310 @04b766>  : 24                         load.i128
	<mul+311 @04b767>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @04b769>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @04b76d>  : 24                         load.i128
	<mul+318 @04b76e>  : 9b                         dp4.v4f
	<mul+319 @04b76f>  : 10 07                      dup.x1 sp(7)
	<mul+321 @04b771>  : 24                         load.i128
	<mul+322 @04b772>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @04b774>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @04b778>  : 24                         load.i128
	<mul+329 @04b779>  : 9b                         dp4.v4f
	<mul+330 @04b77a>  : 1f d0 b5 04 00             load.ref <@04b5d0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @04b77f>  : 02                         call
	<mul+336 @04b780>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @04b784>  : 15 02                      set.x4 sp(2)
	<mul+342 @04b786>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:45: (68 bytes: <@04b788> - <@04b7cc>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @04b788>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @04b78c>  : 10 13                      dup.x1 sp(19)
	<mul+350 @04b78e>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @04b792>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @04b796>  : 10 04                      dup.x1 sp(4)
	<mul+360 @04b798>  : 24                         load.i128
	<mul+361 @04b799>  : 10 09                      dup.x1 sp(9)
	<mul+363 @04b79b>  : 24                         load.i128
	<mul+364 @04b79c>  : 9b                         dp4.v4f
	<mul+365 @04b79d>  : 10 05                      dup.x1 sp(5)
	<mul+367 @04b79f>  : 24                         load.i128
	<mul+368 @04b7a0>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @04b7a2>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @04b7a6>  : 24                         load.i128
	<mul+375 @04b7a7>  : 9b                         dp4.v4f
	<mul+376 @04b7a8>  : 10 06                      dup.x1 sp(6)
	<mul+378 @04b7aa>  : 24                         load.i128
	<mul+379 @04b7ab>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @04b7ad>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @04b7b1>  : 24                         load.i128
	<mul+386 @04b7b2>  : 9b                         dp4.v4f
	<mul+387 @04b7b3>  : 10 07                      dup.x1 sp(7)
	<mul+389 @04b7b5>  : 24                         load.i128
	<mul+390 @04b7b6>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @04b7b8>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @04b7bc>  : 24                         load.i128
	<mul+397 @04b7bd>  : 9b                         dp4.v4f
	<mul+398 @04b7be>  : 1f d0 b5 04 00             load.ref <@04b5d0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @04b7c3>  : 02                         call
	<mul+404 @04b7c4>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @04b7c8>  : 15 02                      set.x4 sp(2)
	<mul+410 @04b7ca>  : 15 23                      set.x4 sp(35)
	<mul+412 @04b7cc>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @04b7d0>  : 03                         ret
.references:
	lib/vec/mat4f.ci:33: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.references:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.references:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.references:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.references:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.references:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.references:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.references:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.references:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.references:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.references:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.references:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.references:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.references:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.references:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.references:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.references:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.references:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.references:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.references:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.references:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.references:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.references:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.references:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.references:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.references:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.references:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.references:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.references:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.references:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.references:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.references:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.references:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.references:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.references:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.references:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.references:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.references:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.references:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02d140>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.references:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02d260>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.references:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.references:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.references:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.references:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@04b7d8>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.references:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.references:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.references:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.references:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.references:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.references:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.references:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.references:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.references:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.references:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.references:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.references:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.references:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.references:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.references:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.references:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.references:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.references:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.references:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.references:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.references:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.references:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.references:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.references:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.references:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.references:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.references:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.references:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.references:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.references:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.references:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.references:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.references:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.references:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.references:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.references:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.references:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.references:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.references:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.references:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.references:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.references:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.references:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.references:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.references:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.references:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.references:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.references:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.references:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.references:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.references:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.references:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.references:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.references:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.references:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.references:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.references:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.references:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.references:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.references:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.references:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.references:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.references:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.references:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.references:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.references:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.references:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.references:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.references:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.references:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.references:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.references:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.references:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.references:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.references:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.references:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.references:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.references:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.references:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.references:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.references:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.references:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@04b7e0>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@04b7e0> - <@04b7e1>)
	<empty @04b7e0>      : 03                         ret
.references:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@04b7e8>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@04b7e8> - <@04b7f0>)
	test/lang/function.ci:7: (8 bytes: <@04b7e8> - <@04b7f0>): return int32(.result := int32(x + y));
	<funAdd @04b7e8>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @04b7ea>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @04b7ec>    : 51                         add.i32
	<funAdd+5 @04b7ed>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @04b7ef>    : 03                         ret
.references:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.references:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.references:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.references:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.references:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.references:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@04b7f0>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@04b7f0> - <@04b7f8>)
	test/lang/function.ci:33: (8 bytes: <@04b7f0> - <@04b7f8>): return int32(.result := int32(x * y));
	<funMul @04b7f0>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @04b7f2>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @04b7f4>    : 53                         mul.i32
	<funMul+5 @04b7f5>    : 13 04                      set.x1 sp(4)
	<funMul+7 @04b7f7>    : 03                         ret
.references:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@04b7f8>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@04b7f8> - <@04b82e>)
	test/lang/function.ci:38: (16 bytes: <@04b7f8> - <@04b808>): if (bool(n <= (1)))
	<fib @04b7f8>      : 10 01                      dup.x1 sp(1)
	<fib+2 @04b7fa>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @04b7ff>    : 39                         cgt.u32
	<fib+8 @04b800>    : 05 08 00 00                jnz <fib+16 @04b808>
	test/lang/function.ci:39: (4 bytes: <@04b804> - <@04b808>): return uint32(.result := n);
	<fib+12 @04b804>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @04b807>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@04b808> - <@04b82e>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @04b808>   : 19                         load.z32
	<fib+17 @04b809>   : 10 02                      dup.x1 sp(2)
	<fib+19 @04b80b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @04b80f>   : 1f f8 b7 04 00             load.ref <@04b7f8> ;fib(n: uint32): uint32
	<fib+28 @04b814>   : 02                         call
	<fib+29 @04b815>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @04b819>   : 19                         load.z32
	<fib+34 @04b81a>   : 10 03                      dup.x1 sp(3)
	<fib+36 @04b81c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @04b820>   : 1f f8 b7 04 00             load.ref <@04b7f8> ;fib(n: uint32): uint32
	<fib+45 @04b825>   : 02                         call
	<fib+46 @04b826>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @04b82a>   : 51                         add.i32
	<fib+51 @04b82b>   : 13 03                      set.x1 sp(3)
	<fib+53 @04b82d>   : 03                         ret
.references:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.references:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.references:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.references:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.references:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.references:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.references:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.references:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.references:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.references:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.references:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.references:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.references:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.references:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.references:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.references:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.references:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.references:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.references:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.references:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@032ab8>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.references:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.references:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@032bd8>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.references:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.references:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.references:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.references:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.references:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.references:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.references:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.references:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.references:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.references:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.references:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.references:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.references:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.references:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.references:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.references:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.references:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.references:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.references:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.references:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.references:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.references:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.references:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: ' pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.references:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: ' pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.references:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.references:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.references:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.references:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.references:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.references:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.references:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.references:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.references:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.references:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.references:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.references:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.references:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.references:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.references:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.references:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.references:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.references:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.references:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.references:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.references:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.references:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.references:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.references:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.references:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.references:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.references:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.references:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.references:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.references:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.references:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@04b830>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@04b830> - <@04b831>)
	<noError @04b830>      : 03                         ret
.references:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@04b838>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@04b838> - <@04b850>)
	test/stdc/tryExec.ci:15: (4 bytes: <@04b838> - <@04b83c>): data: uint8[8192]
	<stackOverflow @04b838>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@04b83c> - <@04b84b>): stackOverflow(ptr);
	<stackOverflow+4 @04b83c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @04b840>    : 22                         load.i32
	<stackOverflow+9 @04b841>    : 1f 38 b8 04 00             load.ref <@04b838> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @04b846>   : 02                         call
	<stackOverflow+15 @04b847>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @04b84b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @04b84f>   : 03                         ret
.references:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@04b850>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@04b850> - <@04b85c>)
	test/stdc/tryExec.ci:20: (7 bytes: <@04b850> - <@04b857>): value: int32 := int32(3 / 0)
	<divisionByZero @04b850>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @04b855>    : 19                         load.z32
	<divisionByZero+6 @04b856>    : 54                         div.i32
	<divisionByZero+7 @04b857>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @04b85b>   : 03                         ret
.references:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@04b860>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@04b860> - <@04b8a4>)
	test/stdc/tryExec.ci:29: (25 bytes: <@04b860> - <@04b879>): details: NotEquals := {...}
	<abortExecution @04b860>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@04b864> - <@04b86b>): void(details.message := ("assertion failed"));
	<abortExecution+4 @04b864>    : 1f 02 c0 00 00             load.ref <@00c002> ;"assertion failed"
	<abortExecution+9 @04b869>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@04b86b> - <@04b872>): void(details.expected := 97);
	<abortExecution+11 @04b86b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @04b870>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@04b872> - <@04b879>): void(details.returned := 77);
	<abortExecution+18 @04b872>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @04b877>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@04b879> - <@04b89f>): abort(void("fatal error", details));
	<abortExecution+25 @04b879>   : 1f 40 65 03 00             load.ref <@036540> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @04b87e>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @04b883>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @04b888>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @04b88d>   : 1f 89 65 03 00             load.ref <@036589> ;"fatal error"
	<abortExecution+50 @04b892>   : 1f 20 6f 03 00             load.ref <@036f20> ;abortExecution.NotEquals
	<abortExecution+55 @04b897>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @04b89b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @04b89f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @04b8a3>   : 03                         ret
.references:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@04b8a8>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@04b8a8> - <@04b8b5>)
	test/stdc/tryExec.ci:38: (5 bytes: <@04b8a8> - <@04b8ad>): i32Ref: int32 := null
	<invalidMemoryAccess @04b8a8>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@04b8ad> - <@04b8b0>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @04b8ad>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @04b8af>    : 22                         load.i32
	<invalidMemoryAccess+8 @04b8b0>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @04b8b4>   : 03                         ret
.references:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@04b8b8>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@04b8b8> - <@04b8ba>)
	test/stdc/tryExec.ci:43: (2 bytes: <@04b8b8> - <@04b8ba>): emit(void(load.z32, ret));
	<invalidInstruction @04b8b8>      : 19                         load.z32
	<invalidInstruction+1 @04b8b9>    : 03                         ret
.references:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.references:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.references:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.references:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.references:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.references:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.references:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.references:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.references:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.references:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.references:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.references:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.references:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.references:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.references:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.references:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.references:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@04b8c0>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@04b8c0> - <@04b8c4>)
	test/lang/array.ci:103: (4 bytes: <@04b8c0> - <@04b8c4>): return uint32(.result := values.length);
	<lenSlice @04b8c0>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @04b8c3>    : 03                         ret
.references:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@04b8c8>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@04b8c8> - <@04b8d4>)
	test/lang/array.ci:104: (12 bytes: <@04b8c8> - <@04b8d4>): return int64(.result := values[idx]);
	<nthFixed @04b8c8>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @04b8ca>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @04b8cc>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @04b8d0>    : 23                         load.i64
	<nthFixed+9 @04b8d1>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @04b8d3>   : 03                         ret
.references:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@04b8d8>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@04b8d8> - <@04b8e4>)
	test/lang/array.ci:105: (12 bytes: <@04b8d8> - <@04b8e4>): return int64(.result := values[idx]);
	<nthArray @04b8d8>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @04b8da>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @04b8dc>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @04b8e0>    : 23                         load.i64
	<nthArray+9 @04b8e1>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @04b8e3>   : 03                         ret
.references:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@04b8e8>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@04b8e8> - <@04b8f4>)
	test/lang/array.ci:106: (12 bytes: <@04b8e8> - <@04b8f4>): return int64(.result := values[idx]);
	<nthSlice @04b8e8>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @04b8ea>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @04b8ec>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @04b8f0>    : 23                         load.i64
	<nthSlice+9 @04b8f1>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @04b8f3>   : 03                         ret
.references:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@039a20>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@039ab0>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@04b8f8>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@04b900>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@04b908>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@04b910>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@04b918>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@04b920>, cast: static const variable(val))
.references:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@039ab0>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.references:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.references:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@04b8f8>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@04b900>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.references:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@04b908>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@04b910>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@04b918>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.references:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@04b920>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.references:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.references:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03a470>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 39, offs: <@04b928>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@04b950>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@04b958>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@04b980>, cast: static const function)
.references:
	test/lang/method.ci:80: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:68: referenced as `RecordMethodTest`
	test/lang/method.ci:65: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:30: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:19: referenced as `RecordMethodTest`
	test/lang/method.ci:15: referenced as `RecordMethodTest`
	test/lang/method.ci:11: referenced as `RecordMethodTest`
	test/lang/method.ci:6: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@04b928>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@04b928> - <@04b94f>)
	test/lang/method.ci:7: (38 bytes: <@04b928> - <@04b94e>): trace(void("staticMethod", x));
	<staticMethod @04b928>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<staticMethod+5 @04b92d>    : 1c 07 00 00 00             load.c32 7
	<staticMethod+10 @04b932>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @04b937>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @04b93c>   : 1f d5 a3 03 00             load.ref <@03a3d5> ;"staticMethod"
	<staticMethod+25 @04b941>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<staticMethod+30 @04b946>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @04b94a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @04b94e>   : 03                         ret
.references:
	test/lang/method.ci:79: referenced as `staticMethod`
	test/lang/method.ci:65: referenced as `staticMethod`
	test/lang/method.ci:58: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@04b950>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:11'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:19: referenced as `forwardMethod`
	test/lang/method.ci:11: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:15'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.references:
	test/lang/method.ci:46: referenced as `abstractMethod`
	test/lang/method.ci:15: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:19'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:19: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: virtualMethod
.references:
	test/lang/method.ci:81: referenced as `virtualMethod`
	test/lang/method.ci:71: referenced as `virtualMethod`
	test/lang/method.ci:59: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@04b958>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@04b958> - <@04b97f>)
	test/lang/method.ci:26: (38 bytes: <@04b958> - <@04b97e>): trace(void("virtualMethod", x));
	<virtualMethod @04b958>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<virtualMethod+5 @04b95d>    : 1c 1a 00 00 00             load.c32 26
	<virtualMethod+10 @04b962>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @04b967>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @04b96c>   : 1f 13 a4 03 00             load.ref <@03a413> ;"virtualMethod"
	<virtualMethod+25 @04b971>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<virtualMethod+30 @04b976>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @04b97a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @04b97e>   : 03                         ret
.references:
	test/lang/method.ci:80: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@04b980>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:30'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@04b980> - <@04b9a7>)
	test/lang/method.ci:31: (38 bytes: <@04b980> - <@04b9a6>): trace(void("forwardMethod", x));
	<forwardMethod @04b980>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<forwardMethod+5 @04b985>    : 1c 1f 00 00 00             load.c32 31
	<forwardMethod+10 @04b98a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @04b98f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @04b994>   : 1f e7 a3 03 00             load.ref <@03a3e7> ;"forwardMethod"
	<forwardMethod+25 @04b999>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<forwardMethod+30 @04b99e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @04b9a2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @04b9a6>   : 03                         ret
.references:
	test/lang/method.ci:30: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@04b9a8>
.name: 'globalFunction'
.file: 'test/lang/method.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@04b9a8> - <@04b9cf>)
	test/lang/method.ci:41: (38 bytes: <@04b9a8> - <@04b9ce>): trace(void("globalFunction", x));
	<globalFunction @04b9a8>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<globalFunction+5 @04b9ad>    : 1c 29 00 00 00             load.c32 41
	<globalFunction+10 @04b9b2>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @04b9b7>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @04b9bc>   : 1f 21 a4 03 00             load.ref <@03a421> ;"globalFunction"
	<globalFunction+25 @04b9c1>   : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<globalFunction+30 @04b9c6>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @04b9ca>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @04b9ce>   : 03                         ret
.references:
	test/lang/method.ci:46: referenced as `globalFunction`
	test/lang/method.ci:40: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:44'
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.references:
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:80: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:76: referenced as `recordMethodTest`
	test/lang/method.ci:75: referenced as `recordMethodTest`
	test/lang/method.ci:59: referenced as `recordMethodTest`
	test/lang/method.ci:58: referenced as `recordMethodTest`
	test/lang/method.ci:44: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@04b9d0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:62'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@04b9d0> - <@04ba12>)
	test/lang/method.ci:63: (35 bytes: <@04b9d0> - <@04b9f3>): debug("extension.staticMethod");
	<staticMethod @04b9d0>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<staticMethod+5 @04b9d5>    : 1c 3f 00 00 00             load.c32 63
	<staticMethod+10 @04b9da>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @04b9df>   : 19                         load.z32
	<staticMethod+16 @04b9e0>   : 1f 41 a4 03 00             load.ref <@03a441> ;"extension.staticMethod"
	<staticMethod+21 @04b9e5>   : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<staticMethod+26 @04b9ea>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @04b9ef>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:64: (30 bytes: <@04b9f3> - <@04ba11>): if (bool((this) != null))
	<staticMethod+35 @04b9f3>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @04b9f7>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @04b9fc>   : 57                         ceq.i32
	<staticMethod+45 @04b9fd>   : 05 14 00 00                jnz <staticMethod+65 @04ba11>
	test/lang/method.ci:65: (16 bytes: <@04ba01> - <@04ba11>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @04ba01>   : 12 02                      dup.x4 sp(2)
	<staticMethod+51 @04ba03>   : 10 05                      dup.x1 sp(5)
	<staticMethod+53 @04ba05>   : 13 04                      set.x1 sp(4)
	<staticMethod+55 @04ba07>   : 1f 28 b9 04 00             load.ref <@04b928> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @04ba0c>   : 02                         call
	<staticMethod+61 @04ba0d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @04ba11>   : 03                         ret
.references:
	test/lang/method.ci:75: referenced as `staticMethod`
	test/lang/method.ci:62: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@04ba18>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:68'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@04ba18> - <@04ba57>)
	test/lang/method.ci:69: (35 bytes: <@04ba18> - <@04ba3b>): debug("extension.virtualMethod");
	<virtualMethod @04ba18>      : 1f b0 a3 03 00             load.ref <@03a3b0> ;"test/lang/method.ci"
	<virtualMethod+5 @04ba1d>    : 1c 45 00 00 00             load.c32 69
	<virtualMethod+10 @04ba22>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @04ba27>   : 19                         load.z32
	<virtualMethod+16 @04ba28>   : 1f 58 a4 03 00             load.ref <@03a458> ;"extension.virtualMethod"
	<virtualMethod+21 @04ba2d>   : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<virtualMethod+26 @04ba32>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @04ba37>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:70: (27 bytes: <@04ba3b> - <@04ba56>): if (bool((this) != null))
	<virtualMethod+35 @04ba3b>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @04ba3f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @04ba44>   : 57                         ceq.i32
	<virtualMethod+45 @04ba45>   : 05 11 00 00                jnz <virtualMethod+62 @04ba56>
	test/lang/method.ci:71: (13 bytes: <@04ba49> - <@04ba56>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @04ba49>   : 12 02                      dup.x4 sp(2)
	<virtualMethod+51 @04ba4b>   : 10 05                      dup.x1 sp(5)
	<virtualMethod+53 @04ba4d>   : 13 04                      set.x1 sp(4)
	<virtualMethod+55 @04ba4f>   : 10 08                      dup.x1 sp(8)
	<virtualMethod+57 @04ba51>   : 02                         call
	<virtualMethod+58 @04ba52>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @04ba56>   : 03                         ret
.references:
	test/lang/method.ci:76: referenced as `virtualMethod`
	test/lang/method.ci:68: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03bab8>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.references:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@03bcf8>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.references:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@03bf38>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.references:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.references:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.references:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@03c0e8>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.references:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.references:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1356>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.references:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1360>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.references:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1364>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.references:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1368>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.references:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1372>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.references:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03c550>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@03c940>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@03cd30>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@03d120>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03d510>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03d900>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.references:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.references:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1376>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.references:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.references:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.references:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.references:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.references:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.references:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.references:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.references:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.references:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.references:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.references:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.references:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.references:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.references:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.references:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.references:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.references:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.references:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.references:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.references:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.references:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.references:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.references:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.references:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.references:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.references:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.references:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.references:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.references:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.references:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1496>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.references:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1500>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.references:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.references:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.references:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.references:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.references:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.references:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.references:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.references:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.references:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.references:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.references:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.references:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.references:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.references:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.references:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.references:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.references:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.references:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.references:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.references:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.references:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1584>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.references:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1588>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.references:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.references:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.references:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.references:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.references:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.references:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.references:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.references:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.references:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.references:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.references:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.references:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.references:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.references:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.references:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.references:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.references:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.references:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.references:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.references:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.references:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1672>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.references:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1676>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.references:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.references:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.references:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.references:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.references:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.references:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.references:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.references:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.references:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.references:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.references:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.references:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.references:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.references:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.references:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.references:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.references:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.references:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.references:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.references:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.references:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1760>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.references:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1764>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.references:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.references:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.references:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.references:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.references:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.references:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.references:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.references:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.references:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.references:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.references:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.references:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.references:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.references:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.references:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.references:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.references:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.references:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.references:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.references:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.references:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1848>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.references:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1852>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.references:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.references:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.references:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.references:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.references:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.references:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.references:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.references:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.references:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.references:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.references:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.references:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.references:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.references:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.references:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.references:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.references:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.references:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.references:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.references:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.references:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1936>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.references:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1940>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.references:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.references:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.references:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.references:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.references:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.references:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.references:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.references:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.references:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.references:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.references:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.references:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.references:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.references:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.references:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.references:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.references:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.references:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.references:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.references:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.references:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2024>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.references:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2028>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.references:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.references:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.references:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.references:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2048>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.references:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2056>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.references:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.references:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.references:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.references:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.references:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.references:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.references:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.references:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.references:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.references:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.references:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.references:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.references:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.references:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.references:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.references:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2172>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.references:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2176>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.references:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.references:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.references:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.references:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2196>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.references:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2204>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.references:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.references:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.references:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.references:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.references:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.references:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.references:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.references:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.references:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.references:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.references:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.references:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.references:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.references:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.references:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.references:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2320>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.references:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2324>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.references:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.references:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.references:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.references:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.references:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.references:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.references:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.references:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.references:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.references:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.references:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.references:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.references:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.references:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.references:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2384>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.references:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2388>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.references:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.references:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.references:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.references:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2408>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.references:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2416>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.references:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.references:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.references:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.references:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.references:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.references:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.references:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.references:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.references:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.references:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2484>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.references:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2488>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.references:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.references:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.references:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.references:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2504>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.references:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2508>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.references:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.references:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.references:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2520>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.references:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2524>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.references:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2532>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.references:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2540>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.references:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.references:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.references:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.references:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.references:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.references:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.references:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.references:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.references:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_0f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathSmooth_0f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_0f`
}
testMathSmooth_0F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathSmooth_0F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_0F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:37'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:37: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:38'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:38: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.min()
.references:
	test/stdc/test.math.ci:40: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:41'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:41: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:42'
.value: Math.max()
.references:
	test/stdc/test.math.ci:42: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:43'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:43: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum()
.references:
	test/stdc/test.math.ci:45: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(1)
.references:
	test/stdc/test.math.ci:46: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:47'
.value: Math.sum(void(1, 2))
.references:
	test/stdc/test.math.ci:47: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:48'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.references:
	test/stdc/test.math.ci:48: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:50'
.value: 10
.references:
	test/stdc/test.math.ci:57: referenced as `testMathEval_x`
	test/stdc/test.math.ci:56: referenced as `testMathEval_x`
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(testMathEval_x)
.references:
	test/stdc/test.math.ci:51: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(testMathEval_x, 1.000000))
.references:
	test/stdc/test.math.ci:52: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:53: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:54: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:55: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:56'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:56: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:57'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:57: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.sin(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:59: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.cos(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:60: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.tan(float64(Math.pi / (4)))
.references:
	test/stdc/test.math.ci:61: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:62'
.value: Math.sinh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:62: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.cosh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:63: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2940>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:65'
.value: Math.asin(0.200000)
.references:
	test/stdc/test.math.ci:65: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:66'
.value: Math.acos(0.200000)
.references:
	test/stdc/test.math.ci:66: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2952>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:69'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:69: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2956>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:70'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:70: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(10.000000, 10.000000))
.references:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2972>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:73'
.value: Math.absMod(void(0.000000, 10.000000))
.references:
	test/stdc/test.math.ci:73: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2980>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.references:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2988>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(19.000000, 10.000000))
.references:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2996>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(9.000000, 10.000000))
.references:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3004>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:78'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.references:
	test/stdc/test.math.ci:78: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3012>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.references:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3020>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(18.000000, 10.000000))
.references:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3028>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(8.000000, 10.000000))
.references:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3036>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:83'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.references:
	test/stdc/test.math.ci:83: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3044>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.references:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3048>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(10.000000, 10.000000))
.references:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3052>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:87'
.value: Math.absMod(void(0.000000, 10.000000))
.references:
	test/stdc/test.math.ci:87: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3056>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.references:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3060>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(19.000000, 10.000000))
.references:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3064>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(9.000000, 10.000000))
.references:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3068>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:92'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.references:
	test/stdc/test.math.ci:92: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3072>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.references:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3076>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(18.000000, 10.000000))
.references:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3080>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(8.000000, 10.000000))
.references:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3084>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:97'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.references:
	test/stdc/test.math.ci:97: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3088>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:98'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.references:
	test/stdc/test.math.ci:98: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 10927
.offset: <@04ba57>
.name: '.main'
.print: '.main'
.field typename: typename (size: 144, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000a8>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000140>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001d8>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000270>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000308>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003a0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000438>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@0004d0>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@000568>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000600>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000698>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000730>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@0007c8>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@000860>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@0008f8>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000990>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000a30>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000f88>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@001020>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005768>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006778>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@006fe8>, cast: static const inline)
.field System: typename (size: 0, offs: <@007bc0>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00ecd0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@04a6b8>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@00fa10>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@017f40>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@04af08>, cast: static const function)
.field Complex: function (size: 7, offs: <@04af10>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@04af18>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@04af98>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@04afb8>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@04b020>, cast: static const function)
.field indexOf: function (size: 50, offs: <@04b048>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@04b080>, cast: static const function)
.field startsWith: function (size: 73, offs: <@04b0b8>, cast: static const function)
.field endsWith: function (size: 126, offs: <@04b108>, cast: static const function)
.field compare: function (size: 63, offs: <@04b188>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@04b210>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@04b238>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@01fff0>, cast: static const typename(val))
.field append: function (size: 84, offs: <@04b248>, cast: static const function)
.field append: function (size: 657, offs: <@04b2b0>, cast: static const function)
.field append: function (size: 23, offs: <@04b548>, cast: static const function)
.field append: function (size: 49, offs: <@04b560>, cast: static const function)
.field append: function (size: 25, offs: <@04b5a8>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@021f00>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@04b5c8>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@0227a8>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@04b5d0>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@025758>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@04b5e0>, cast: static const function)
.field mat4f: function (size: 21, offs: <@04b618>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@04b630>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@02d140>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@02d260>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@04b7d8>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@04b7e0>, cast: static const function)
.field funAdd: function (size: 8, offs: <@04b7e8>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@04b7f0>, cast: static const function)
.field fib: function (size: 54, offs: <@04b7f8>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@032ab8>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@032bd8>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@04b830>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@04b838>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@04b850>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@04b860>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@04b8a8>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@04b8b8>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@04b8c0>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@04b8c8>, cast: static const function)
.field nthArray: function (size: 12, offs: <@04b8d8>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@04b8e8>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@039a20>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03a470>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@04b9a8>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field staticMethod: function (size: 66, offs: <@04b9d0>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@04ba18>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@03bab8>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@03bcf8>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@03bf38>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@03c0e8>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1356>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1360>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1364>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1368>, cast: variable(val))
.field blue: color (size: 4, offs: <+1372>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@03c550>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@03c940>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@03cd30>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@03d120>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@03d510>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@03d900>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1376>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1496>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1500>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1584>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1588>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1672>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1676>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1760>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1764>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1848>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1852>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1936>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1940>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2024>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2028>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2048>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2056>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2172>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2176>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2196>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2204>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2320>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2324>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2384>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2388>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2408>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2416>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2484>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2488>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2504>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2508>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2520>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2524>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2532>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2540>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathSmooth_0f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathSmooth_0F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2940>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2952>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2956>, cast: variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <+2972>, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <+2980>, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <+2988>, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <+2996>, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <+3004>, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <+3012>, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <+3020>, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <+3028>, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <+3036>, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <+3044>, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <+3048>, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <+3052>, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <+3056>, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <+3060>, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <+3064>, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <+3068>, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <+3072>, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <+3076>, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <+3080>, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <+3084>, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <+3088>, cast: variable(f32))
.field .main: function (size: 10927, offs: <@04ba57>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static const sign(x: float32): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const sign(x: float64): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static deg2rad(x: float64): float64 := float64(float64(float64(x * pi) / (180)));
			static rad2deg(x: float64): float64 := float64(float64(float64(x * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				x: float64;
				y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				.anonymous: .anonymous;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				data: float32[16];
				.anonymous: .anonymous;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_0f: float64 := Math.smooth(0.000000);
		testMathSmooth_0F: float64 := Math.smooth(0.000000);
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (10927 bytes: <@04ba57> - <@04e506>)
	lib/std/string.ci:130: (14 bytes: <@04ba57> - <@04ba65>): static const whiteSpace: char[] := " \t\n\r"
	<.main @04ba57>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @04ba5c>    : 1f 03 ce 01 00             load.ref <@01ce03> ;" \t\n\r"
	<.main+10 @04ba61>   : 2d a0 b2 04                store.m64 <@04b2a0> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes: <@04ba65> - <@04ba73>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @04ba65>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @04ba6a>   : 1f 14 ce 01 00             load.ref <@01ce14> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @04ba6f>   : 2d a8 b2 04                store.m64 <@04b2a8> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes: <@04ba73> - <@04ba8d>): static const format: FormatFlags := {...}
	<.main+28 @04ba73>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @04ba78>   : 2e 98 b5 04                store.m32 <@04b598> ;append.format
	:: (7 bytes: <@04ba7c> - <@04ba83>): void(format.padChr := (0))
	<.main+37 @04ba7c>   : 19                         load.z32
	<.main+38 @04ba7d>   : 1f 9c b5 04 00             load.ref <@04b59c> ;append.format+4
	<.main+43 @04ba82>   : 25                         store.i8
	:: (5 bytes: <@04ba83> - <@04ba88>): void(format.padLen := 0)
	<.main+44 @04ba83>   : 19                         load.z32
	<.main+45 @04ba84>   : 2e a0 b5 04                store.m32 <@04b5a0> ;append.format+8
	:: (5 bytes: <@04ba88> - <@04ba8d>): void(format.precision := 0)
	<.main+49 @04ba88>   : 19                         load.z32
	<.main+50 @04ba89>   : 2e a4 b5 04                store.m32 <@04b5a4> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@04ba8d> - <@04ba9a>): static value: int64 := 42
	<.main+54 @04ba8d>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @04ba96>   : 2d d8 b7 04                store.m64 <@04b7d8> ;value
	test/lang/member.ci:35: (5 bytes: <@04ba9a> - <@04ba9f>): static global: int32
	<.main+67 @04ba9a>   : 19                         load.z32
	<.main+68 @04ba9b>   : 2e f8 b8 04                store.m32 <@04b8f8> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@04ba9f> - <@04baa8>): static globalInit: int32 := 1
	<.main+72 @04ba9f>   : 1c 01 00 00 00             load.c32 1
	<.main+77 @04baa4>   : 2e 00 b9 04                store.m32 <@04b900> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@04baa8> - <@04bab1>): static const globalConstant: int32 := 2
	<.main+81 @04baa8>   : 1c 02 00 00 00             load.c32 2
	<.main+86 @04baad>   : 2e 08 b9 04                store.m32 <@04b908> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@04bab1> - <@04bac3>): static globalRecInit: Inner := {...}
	<.main+90 @04bab1>   : 1c 04 00 00 00             load.c32 4
	<.main+95 @04bab6>   : 2e 18 b9 04                store.m32 <@04b918> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@04baba> - <@04bac3>): void(globalRecInit.constant := 5);
	<.main+99 @04baba>   : 1c 05 00 00 00             load.c32 5
	<.main+104 @04babf>  : 2e 1c b9 04                store.m32 <@04b91c> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@04bac3> - <@04bad5>): static const globalConstantRec: Inner := {...}
	<.main+108 @04bac3>  : 1c 06 00 00 00             load.c32 6
	<.main+113 @04bac8>  : 2e 20 b9 04                store.m32 <@04b920> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@04bacc> - <@04bad5>): void(globalConstantRec.constant := 7);
	<.main+117 @04bacc>  : 1c 07 00 00 00             load.c32 7
	<.main+122 @04bad1>  : 2e 24 b9 04                store.m32 <@04b924> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:11: (9 bytes: <@04bad5> - <@04bade>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+126 @04bad5>  : 1f 80 b9 04 00             load.ref <@04b980> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+131 @04bada>  : 2e 50 b9 04                store.m32 <@04b950> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/emit.ci:3: (1 byte: <@04bade> - <@04badf>): emitldz32: int32 := emit(load.z32)
	<.main+135 @04bade>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@04badf> - <@04bae0>): emitldz64: int64 := emit(load.z64)
	<.main+136 @04badf>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@04bae0> - <@04bae5>): emitA: int32 := 42
	<.main+137 @04bae0>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@04bae5> - <@04baea>): emitB: int32 := 96
	<.main+142 @04bae5>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@04baea> - <@04baef>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @04baea>  : 10 01                      dup.x1 sp(1)
	<.main+149 @04baec>  : 10 01                      dup.x1 sp(1)
	<.main+151 @04baee>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@04baef> - <@04bafa>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @04baef>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @04baf4>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @04baf9>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@04bafa> - <@04baff>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @04bafa>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@04baff> - <@04bb05>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @04baff>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @04bb04>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@04bb05> - <@04bb0f>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @04bb05>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @04bb0e>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@04bb0f> - <@04bb18>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @04bb0f>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@04bb18> - <@04bb22>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @04bb18>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @04bb1d>  : 1f 44 78 02 00             load.ref <@027844> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@04bb22> - <@04bb27>): i3: int32 := 3
	<.main+203 @04bb22>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@04bb27> - <@04bb2c>): i6: int32 := 6
	<.main+208 @04bb27>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@04bb2c> - <@04bb31>): i2: int32 := 2
	<.main+213 @04bb2c>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@04bb31> - <@04bb36>): i8: int32 := 8
	<.main+218 @04bb31>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@04bb36> - <@04bb37>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @04bb36>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@04bb37> - <@04bb38>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @04bb37>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@04bb38> - <@04bb39>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @04bb38>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@04bb39> - <@04bb3e>): lastVal: int32 := last(void(3, 6))
	<.main+226 @04bb39>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@04bb3e> - <@04bb40>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @04bb3e>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@04bb40> - <@04bb4a>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @04bb40>  : 10 07                      dup.x1 sp(7)
	<.main+235 @04bb42>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @04bb46>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@04bb4a> - <@04bb53>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @04bb4a>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @04bb4f>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@04bb53> - <@04bb58>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @04bb53>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @04bb55>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @04bb57>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@04bb58> - <@04bb69>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @04bb58>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @04bb5a>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @04bb5e>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @04bb60>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @04bb64>  : 51                         add.i32
	<.main+270 @04bb65>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@04bb69> - <@04bb81>): any2Val: int32 := any(void(3, 6))
	<.main+274 @04bb69>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @04bb6e>  : 10 00                      dup.x1 sp(0)
	<.main+281 @04bb70>  : 06 0a 00 00                jz <.main+291 @04bb7a>
	<.main+285 @04bb74>  : 10 00                      dup.x1 sp(0)
	<.main+287 @04bb76>  : 04 09 00 00                jmp <.main+296 @04bb7f>
	<.main+291 @04bb7a>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @04bb7f>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@04bb81> - <@04bb93>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @04bb81>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @04bb83>  : 10 00                      dup.x1 sp(0)
	<.main+302 @04bb85>  : 06 0a 00 00                jz <.main+312 @04bb8f>
	<.main+306 @04bb89>  : 10 00                      dup.x1 sp(0)
	<.main+308 @04bb8b>  : 04 06 00 00                jmp <.main+314 @04bb91>
	<.main+312 @04bb8f>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @04bb91>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@04bb93> - <@04bbb1>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @04bb93>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @04bb95>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @04bb99>  : 10 00                      dup.x1 sp(0)
	<.main+324 @04bb9b>  : 06 0a 00 00                jz <.main+334 @04bba5>
	<.main+328 @04bb9f>  : 10 00                      dup.x1 sp(0)
	<.main+330 @04bba1>  : 04 0a 00 00                jmp <.main+340 @04bbab>
	<.main+334 @04bba5>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @04bba7>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @04bbab>  : 13 01                      set.x1 sp(1)
	<.main+342 @04bbad>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@04bbb1> - <@04bbd2>): min2Val: int32 := min(void(3, 6))
	<.main+346 @04bbb1>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @04bbb6>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @04bbbb>  : 10 01                      dup.x1 sp(1)
	<.main+358 @04bbbd>  : 10 01                      dup.x1 sp(1)
	<.main+360 @04bbbf>  : 58                         clt.i32
	<.main+361 @04bbc0>  : 06 0a 00 00                jz <.main+371 @04bbca>
	<.main+365 @04bbc4>  : 10 01                      dup.x1 sp(1)
	<.main+367 @04bbc6>  : 04 06 00 00                jmp <.main+373 @04bbcc>
	<.main+371 @04bbca>  : 10 00                      dup.x1 sp(0)
	<.main+373 @04bbcc>  : 13 02                      set.x1 sp(2)
	<.main+375 @04bbce>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@04bbd2> - <@04bbed>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @04bbd2>  : 10 10                      dup.x1 sp(16)
	<.main+381 @04bbd4>  : 10 10                      dup.x1 sp(16)
	<.main+383 @04bbd6>  : 10 01                      dup.x1 sp(1)
	<.main+385 @04bbd8>  : 10 01                      dup.x1 sp(1)
	<.main+387 @04bbda>  : 58                         clt.i32
	<.main+388 @04bbdb>  : 06 0a 00 00                jz <.main+398 @04bbe5>
	<.main+392 @04bbdf>  : 10 01                      dup.x1 sp(1)
	<.main+394 @04bbe1>  : 04 06 00 00                jmp <.main+400 @04bbe7>
	<.main+398 @04bbe5>  : 10 00                      dup.x1 sp(0)
	<.main+400 @04bbe7>  : 13 02                      set.x1 sp(2)
	<.main+402 @04bbe9>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@04bbed> - <@04bc14>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @04bbed>  : 10 11                      dup.x1 sp(17)
	<.main+408 @04bbef>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @04bbf3>  : 10 11                      dup.x1 sp(17)
	<.main+414 @04bbf5>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @04bbf9>  : 10 01                      dup.x1 sp(1)
	<.main+420 @04bbfb>  : 10 01                      dup.x1 sp(1)
	<.main+422 @04bbfd>  : 58                         clt.i32
	<.main+423 @04bbfe>  : 06 0a 00 00                jz <.main+433 @04bc08>
	<.main+427 @04bc02>  : 10 01                      dup.x1 sp(1)
	<.main+429 @04bc04>  : 04 06 00 00                jmp <.main+435 @04bc0a>
	<.main+433 @04bc08>  : 10 00                      dup.x1 sp(0)
	<.main+435 @04bc0a>  : 13 02                      set.x1 sp(2)
	<.main+437 @04bc0c>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @04bc10>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@04bc14> - <@04bc35>): max2Val: int32 := max(void(3, 6))
	<.main+445 @04bc14>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @04bc19>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @04bc1e>  : 10 01                      dup.x1 sp(1)
	<.main+457 @04bc20>  : 10 01                      dup.x1 sp(1)
	<.main+459 @04bc22>  : 59                         cgt.i32
	<.main+460 @04bc23>  : 06 0a 00 00                jz <.main+470 @04bc2d>
	<.main+464 @04bc27>  : 10 01                      dup.x1 sp(1)
	<.main+466 @04bc29>  : 04 06 00 00                jmp <.main+472 @04bc2f>
	<.main+470 @04bc2d>  : 10 00                      dup.x1 sp(0)
	<.main+472 @04bc2f>  : 13 02                      set.x1 sp(2)
	<.main+474 @04bc31>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@04bc35> - <@04bc50>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @04bc35>  : 10 13                      dup.x1 sp(19)
	<.main+480 @04bc37>  : 10 13                      dup.x1 sp(19)
	<.main+482 @04bc39>  : 10 01                      dup.x1 sp(1)
	<.main+484 @04bc3b>  : 10 01                      dup.x1 sp(1)
	<.main+486 @04bc3d>  : 59                         cgt.i32
	<.main+487 @04bc3e>  : 06 0a 00 00                jz <.main+497 @04bc48>
	<.main+491 @04bc42>  : 10 01                      dup.x1 sp(1)
	<.main+493 @04bc44>  : 04 06 00 00                jmp <.main+499 @04bc4a>
	<.main+497 @04bc48>  : 10 00                      dup.x1 sp(0)
	<.main+499 @04bc4a>  : 13 02                      set.x1 sp(2)
	<.main+501 @04bc4c>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@04bc50> - <@04bc77>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @04bc50>  : 10 14                      dup.x1 sp(20)
	<.main+507 @04bc52>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @04bc56>  : 10 14                      dup.x1 sp(20)
	<.main+513 @04bc58>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @04bc5c>  : 10 01                      dup.x1 sp(1)
	<.main+519 @04bc5e>  : 10 01                      dup.x1 sp(1)
	<.main+521 @04bc60>  : 59                         cgt.i32
	<.main+522 @04bc61>  : 06 0a 00 00                jz <.main+532 @04bc6b>
	<.main+526 @04bc65>  : 10 01                      dup.x1 sp(1)
	<.main+528 @04bc67>  : 04 06 00 00                jmp <.main+534 @04bc6d>
	<.main+532 @04bc6b>  : 10 00                      dup.x1 sp(0)
	<.main+534 @04bc6d>  : 13 02                      set.x1 sp(2)
	<.main+536 @04bc6f>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @04bc73>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@04bc77> - <@04bc8c>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @04bc77>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @04bc7c>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @04bc81>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @04bc86>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @04bc8a>  : 51                         add.i32
	<.main+564 @04bc8b>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@04bc8c> - <@04bc9d>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @04bc8c>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @04bc91>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @04bc95>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @04bc99>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@04bc9d> - <@04bca8>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @04bc9d>  : 10 17                      dup.x1 sp(23)
	<.main+584 @04bc9f>  : 10 17                      dup.x1 sp(23)
	<.main+586 @04bca1>  : 10 17                      dup.x1 sp(23)
	<.main+588 @04bca3>  : 10 17                      dup.x1 sp(23)
	<.main+590 @04bca5>  : 51                         add.i32
	<.main+591 @04bca6>  : 51                         add.i32
	<.main+592 @04bca7>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@04bca8> - <@04bcb3>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @04bca8>  : 10 18                      dup.x1 sp(24)
	<.main+595 @04bcaa>  : 10 18                      dup.x1 sp(24)
	<.main+597 @04bcac>  : 51                         add.i32
	<.main+598 @04bcad>  : 10 17                      dup.x1 sp(23)
	<.main+600 @04bcaf>  : 51                         add.i32
	<.main+601 @04bcb0>  : 10 16                      dup.x1 sp(22)
	<.main+603 @04bcb2>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@04bcb3> - <@04bcd2>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @04bcb3>  : 10 19                      dup.x1 sp(25)
	<.main+606 @04bcb5>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @04bcb9>  : 10 19                      dup.x1 sp(25)
	<.main+612 @04bcbb>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @04bcbf>  : 10 19                      dup.x1 sp(25)
	<.main+618 @04bcc1>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @04bcc5>  : 10 19                      dup.x1 sp(25)
	<.main+624 @04bcc7>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @04bccb>  : 51                         add.i32
	<.main+629 @04bccc>  : 51                         add.i32
	<.main+630 @04bccd>  : 51                         add.i32
	<.main+631 @04bcce>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@04bcd2> - <@04bcf1>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @04bcd2>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @04bcd4>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @04bcd8>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @04bcda>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @04bcde>  : 51                         add.i32
	<.main+648 @04bcdf>  : 10 19                      dup.x1 sp(25)
	<.main+650 @04bce1>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @04bce5>  : 51                         add.i32
	<.main+655 @04bce6>  : 10 18                      dup.x1 sp(24)
	<.main+657 @04bce8>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @04bcec>  : 51                         add.i32
	<.main+662 @04bced>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@04bcf1> - <@04bd2f>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @04bcf1>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @04bcf6>  : 10 00                      dup.x1 sp(0)
	<.main+673 @04bcf8>  : 06 0a 00 00                jz <.main+683 @04bd02>
	<.main+677 @04bcfc>  : 10 00                      dup.x1 sp(0)
	<.main+679 @04bcfe>  : 04 2f 00 00                jmp <.main+726 @04bd2d>
	<.main+683 @04bd02>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @04bd07>  : 10 00                      dup.x1 sp(0)
	<.main+690 @04bd09>  : 06 0a 00 00                jz <.main+700 @04bd13>
	<.main+694 @04bd0d>  : 10 00                      dup.x1 sp(0)
	<.main+696 @04bd0f>  : 04 1c 00 00                jmp <.main+724 @04bd2b>
	<.main+700 @04bd13>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @04bd18>  : 10 00                      dup.x1 sp(0)
	<.main+707 @04bd1a>  : 06 0a 00 00                jz <.main+717 @04bd24>
	<.main+711 @04bd1e>  : 10 00                      dup.x1 sp(0)
	<.main+713 @04bd20>  : 04 09 00 00                jmp <.main+722 @04bd29>
	<.main+717 @04bd24>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @04bd29>  : 13 01                      set.x1 sp(1)
	<.main+724 @04bd2b>  : 13 01                      set.x1 sp(1)
	<.main+726 @04bd2d>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@04bd2f> - <@04bd6d>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @04bd2f>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @04bd34>  : 10 00                      dup.x1 sp(0)
	<.main+735 @04bd36>  : 06 0a 00 00                jz <.main+745 @04bd40>
	<.main+739 @04bd3a>  : 10 00                      dup.x1 sp(0)
	<.main+741 @04bd3c>  : 04 09 00 00                jmp <.main+750 @04bd45>
	<.main+745 @04bd40>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @04bd45>  : 13 01                      set.x1 sp(1)
	<.main+752 @04bd47>  : 10 00                      dup.x1 sp(0)
	<.main+754 @04bd49>  : 06 0a 00 00                jz <.main+764 @04bd53>
	<.main+758 @04bd4d>  : 10 00                      dup.x1 sp(0)
	<.main+760 @04bd4f>  : 04 09 00 00                jmp <.main+769 @04bd58>
	<.main+764 @04bd53>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @04bd58>  : 13 01                      set.x1 sp(1)
	<.main+771 @04bd5a>  : 10 00                      dup.x1 sp(0)
	<.main+773 @04bd5c>  : 06 0a 00 00                jz <.main+783 @04bd66>
	<.main+777 @04bd60>  : 10 00                      dup.x1 sp(0)
	<.main+779 @04bd62>  : 04 09 00 00                jmp <.main+788 @04bd6b>
	<.main+783 @04bd66>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @04bd6b>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@04bd6d> - <@04bd9f>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @04bd6d>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @04bd6f>  : 10 00                      dup.x1 sp(0)
	<.main+794 @04bd71>  : 06 0a 00 00                jz <.main+804 @04bd7b>
	<.main+798 @04bd75>  : 10 00                      dup.x1 sp(0)
	<.main+800 @04bd77>  : 04 26 00 00                jmp <.main+838 @04bd9d>
	<.main+804 @04bd7b>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @04bd7d>  : 10 00                      dup.x1 sp(0)
	<.main+808 @04bd7f>  : 06 0a 00 00                jz <.main+818 @04bd89>
	<.main+812 @04bd83>  : 10 00                      dup.x1 sp(0)
	<.main+814 @04bd85>  : 04 16 00 00                jmp <.main+836 @04bd9b>
	<.main+818 @04bd89>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @04bd8b>  : 10 00                      dup.x1 sp(0)
	<.main+822 @04bd8d>  : 06 0a 00 00                jz <.main+832 @04bd97>
	<.main+826 @04bd91>  : 10 00                      dup.x1 sp(0)
	<.main+828 @04bd93>  : 04 06 00 00                jmp <.main+834 @04bd99>
	<.main+832 @04bd97>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @04bd99>  : 13 01                      set.x1 sp(1)
	<.main+836 @04bd9b>  : 13 01                      set.x1 sp(1)
	<.main+838 @04bd9d>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@04bd9f> - <@04bdd1>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @04bd9f>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @04bda1>  : 10 00                      dup.x1 sp(0)
	<.main+844 @04bda3>  : 06 0a 00 00                jz <.main+854 @04bdad>
	<.main+848 @04bda7>  : 10 00                      dup.x1 sp(0)
	<.main+850 @04bda9>  : 04 06 00 00                jmp <.main+856 @04bdaf>
	<.main+854 @04bdad>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @04bdaf>  : 13 01                      set.x1 sp(1)
	<.main+858 @04bdb1>  : 10 00                      dup.x1 sp(0)
	<.main+860 @04bdb3>  : 06 0a 00 00                jz <.main+870 @04bdbd>
	<.main+864 @04bdb7>  : 10 00                      dup.x1 sp(0)
	<.main+866 @04bdb9>  : 04 06 00 00                jmp <.main+872 @04bdbf>
	<.main+870 @04bdbd>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @04bdbf>  : 13 01                      set.x1 sp(1)
	<.main+874 @04bdc1>  : 10 00                      dup.x1 sp(0)
	<.main+876 @04bdc3>  : 06 0a 00 00                jz <.main+886 @04bdcd>
	<.main+880 @04bdc7>  : 10 00                      dup.x1 sp(0)
	<.main+882 @04bdc9>  : 04 06 00 00                jmp <.main+888 @04bdcf>
	<.main+886 @04bdcd>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @04bdcf>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@04bdd1> - <@04be17>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @04bdd1>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @04bdd3>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @04bdd7>  : 10 00                      dup.x1 sp(0)
	<.main+898 @04bdd9>  : 06 0a 00 00                jz <.main+908 @04bde3>
	<.main+902 @04bddd>  : 10 00                      dup.x1 sp(0)
	<.main+904 @04bddf>  : 04 32 00 00                jmp <.main+954 @04be11>
	<.main+908 @04bde3>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @04bde5>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @04bde9>  : 10 00                      dup.x1 sp(0)
	<.main+916 @04bdeb>  : 06 0a 00 00                jz <.main+926 @04bdf5>
	<.main+920 @04bdef>  : 10 00                      dup.x1 sp(0)
	<.main+922 @04bdf1>  : 04 1e 00 00                jmp <.main+952 @04be0f>
	<.main+926 @04bdf5>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @04bdf7>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @04bdfb>  : 10 00                      dup.x1 sp(0)
	<.main+934 @04bdfd>  : 06 0a 00 00                jz <.main+944 @04be07>
	<.main+938 @04be01>  : 10 00                      dup.x1 sp(0)
	<.main+940 @04be03>  : 04 0a 00 00                jmp <.main+950 @04be0d>
	<.main+944 @04be07>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @04be09>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @04be0d>  : 13 01                      set.x1 sp(1)
	<.main+952 @04be0f>  : 13 01                      set.x1 sp(1)
	<.main+954 @04be11>  : 13 01                      set.x1 sp(1)
	<.main+956 @04be13>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@04be17> - <@04be5d>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @04be17>  : 10 20                      dup.x1 sp(32)
	<.main+962 @04be19>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @04be1d>  : 10 00                      dup.x1 sp(0)
	<.main+968 @04be1f>  : 06 0a 00 00                jz <.main+978 @04be29>
	<.main+972 @04be23>  : 10 00                      dup.x1 sp(0)
	<.main+974 @04be25>  : 04 0a 00 00                jmp <.main+984 @04be2f>
	<.main+978 @04be29>  : 10 20                      dup.x1 sp(32)
	<.main+980 @04be2b>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @04be2f>  : 13 01                      set.x1 sp(1)
	<.main+986 @04be31>  : 10 00                      dup.x1 sp(0)
	<.main+988 @04be33>  : 06 0a 00 00                jz <.main+998 @04be3d>
	<.main+992 @04be37>  : 10 00                      dup.x1 sp(0)
	<.main+994 @04be39>  : 04 0a 00 00                jmp <.main+1004 @04be43>
	<.main+998 @04be3d>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @04be3f> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @04be43> : 13 01                      set.x1 sp(1)
	<.main+1006 @04be45> : 10 00                      dup.x1 sp(0)
	<.main+1008 @04be47> : 06 0a 00 00                jz <.main+1018 @04be51>
	<.main+1012 @04be4b> : 10 00                      dup.x1 sp(0)
	<.main+1014 @04be4d> : 04 0a 00 00                jmp <.main+1024 @04be57>
	<.main+1018 @04be51> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @04be53> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @04be57> : 13 01                      set.x1 sp(1)
	<.main+1026 @04be59> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@04be5d> - <@04beb6>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @04be5d> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @04be62> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @04be67> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @04be6c> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @04be71> : 10 01                      dup.x1 sp(1)
	<.main+1052 @04be73> : 10 01                      dup.x1 sp(1)
	<.main+1054 @04be75> : 58                         clt.i32
	<.main+1055 @04be76> : 06 0a 00 00                jz <.main+1065 @04be80>
	<.main+1059 @04be7a> : 10 01                      dup.x1 sp(1)
	<.main+1061 @04be7c> : 04 06 00 00                jmp <.main+1067 @04be82>
	<.main+1065 @04be80> : 10 00                      dup.x1 sp(0)
	<.main+1067 @04be82> : 13 02                      set.x1 sp(2)
	<.main+1069 @04be84> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @04be88> : 10 01                      dup.x1 sp(1)
	<.main+1075 @04be8a> : 10 01                      dup.x1 sp(1)
	<.main+1077 @04be8c> : 58                         clt.i32
	<.main+1078 @04be8d> : 06 0a 00 00                jz <.main+1088 @04be97>
	<.main+1082 @04be91> : 10 01                      dup.x1 sp(1)
	<.main+1084 @04be93> : 04 06 00 00                jmp <.main+1090 @04be99>
	<.main+1088 @04be97> : 10 00                      dup.x1 sp(0)
	<.main+1090 @04be99> : 13 02                      set.x1 sp(2)
	<.main+1092 @04be9b> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @04be9f> : 10 01                      dup.x1 sp(1)
	<.main+1098 @04bea1> : 10 01                      dup.x1 sp(1)
	<.main+1100 @04bea3> : 58                         clt.i32
	<.main+1101 @04bea4> : 06 0a 00 00                jz <.main+1111 @04beae>
	<.main+1105 @04bea8> : 10 01                      dup.x1 sp(1)
	<.main+1107 @04beaa> : 04 06 00 00                jmp <.main+1113 @04beb0>
	<.main+1111 @04beae> : 10 00                      dup.x1 sp(0)
	<.main+1113 @04beb0> : 13 02                      set.x1 sp(2)
	<.main+1115 @04beb2> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@04beb6> - <@04bf0f>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @04beb6> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @04bebb> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @04bec0> : 10 01                      dup.x1 sp(1)
	<.main+1131 @04bec2> : 10 01                      dup.x1 sp(1)
	<.main+1133 @04bec4> : 58                         clt.i32
	<.main+1134 @04bec5> : 06 0a 00 00                jz <.main+1144 @04becf>
	<.main+1138 @04bec9> : 10 01                      dup.x1 sp(1)
	<.main+1140 @04becb> : 04 06 00 00                jmp <.main+1146 @04bed1>
	<.main+1144 @04becf> : 10 00                      dup.x1 sp(0)
	<.main+1146 @04bed1> : 13 02                      set.x1 sp(2)
	<.main+1148 @04bed3> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @04bed7> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @04bedc> : 10 01                      dup.x1 sp(1)
	<.main+1159 @04bede> : 10 01                      dup.x1 sp(1)
	<.main+1161 @04bee0> : 58                         clt.i32
	<.main+1162 @04bee1> : 06 0a 00 00                jz <.main+1172 @04beeb>
	<.main+1166 @04bee5> : 10 01                      dup.x1 sp(1)
	<.main+1168 @04bee7> : 04 06 00 00                jmp <.main+1174 @04beed>
	<.main+1172 @04beeb> : 10 00                      dup.x1 sp(0)
	<.main+1174 @04beed> : 13 02                      set.x1 sp(2)
	<.main+1176 @04beef> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @04bef3> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @04bef8> : 10 01                      dup.x1 sp(1)
	<.main+1187 @04befa> : 10 01                      dup.x1 sp(1)
	<.main+1189 @04befc> : 58                         clt.i32
	<.main+1190 @04befd> : 06 0a 00 00                jz <.main+1200 @04bf07>
	<.main+1194 @04bf01> : 10 01                      dup.x1 sp(1)
	<.main+1196 @04bf03> : 04 06 00 00                jmp <.main+1202 @04bf09>
	<.main+1200 @04bf07> : 10 00                      dup.x1 sp(0)
	<.main+1202 @04bf09> : 13 02                      set.x1 sp(2)
	<.main+1204 @04bf0b> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@04bf0f> - <@04bf5c>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @04bf0f> : 10 23                      dup.x1 sp(35)
	<.main+1210 @04bf11> : 10 23                      dup.x1 sp(35)
	<.main+1212 @04bf13> : 10 23                      dup.x1 sp(35)
	<.main+1214 @04bf15> : 10 23                      dup.x1 sp(35)
	<.main+1216 @04bf17> : 10 01                      dup.x1 sp(1)
	<.main+1218 @04bf19> : 10 01                      dup.x1 sp(1)
	<.main+1220 @04bf1b> : 58                         clt.i32
	<.main+1221 @04bf1c> : 06 0a 00 00                jz <.main+1231 @04bf26>
	<.main+1225 @04bf20> : 10 01                      dup.x1 sp(1)
	<.main+1227 @04bf22> : 04 06 00 00                jmp <.main+1233 @04bf28>
	<.main+1231 @04bf26> : 10 00                      dup.x1 sp(0)
	<.main+1233 @04bf28> : 13 02                      set.x1 sp(2)
	<.main+1235 @04bf2a> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @04bf2e> : 10 01                      dup.x1 sp(1)
	<.main+1241 @04bf30> : 10 01                      dup.x1 sp(1)
	<.main+1243 @04bf32> : 58                         clt.i32
	<.main+1244 @04bf33> : 06 0a 00 00                jz <.main+1254 @04bf3d>
	<.main+1248 @04bf37> : 10 01                      dup.x1 sp(1)
	<.main+1250 @04bf39> : 04 06 00 00                jmp <.main+1256 @04bf3f>
	<.main+1254 @04bf3d> : 10 00                      dup.x1 sp(0)
	<.main+1256 @04bf3f> : 13 02                      set.x1 sp(2)
	<.main+1258 @04bf41> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @04bf45> : 10 01                      dup.x1 sp(1)
	<.main+1264 @04bf47> : 10 01                      dup.x1 sp(1)
	<.main+1266 @04bf49> : 58                         clt.i32
	<.main+1267 @04bf4a> : 06 0a 00 00                jz <.main+1277 @04bf54>
	<.main+1271 @04bf4e> : 10 01                      dup.x1 sp(1)
	<.main+1273 @04bf50> : 04 06 00 00                jmp <.main+1279 @04bf56>
	<.main+1277 @04bf54> : 10 00                      dup.x1 sp(0)
	<.main+1279 @04bf56> : 13 02                      set.x1 sp(2)
	<.main+1281 @04bf58> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@04bf5c> - <@04bfa9>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @04bf5c> : 10 24                      dup.x1 sp(36)
	<.main+1287 @04bf5e> : 10 24                      dup.x1 sp(36)
	<.main+1289 @04bf60> : 10 01                      dup.x1 sp(1)
	<.main+1291 @04bf62> : 10 01                      dup.x1 sp(1)
	<.main+1293 @04bf64> : 58                         clt.i32
	<.main+1294 @04bf65> : 06 0a 00 00                jz <.main+1304 @04bf6f>
	<.main+1298 @04bf69> : 10 01                      dup.x1 sp(1)
	<.main+1300 @04bf6b> : 04 06 00 00                jmp <.main+1306 @04bf71>
	<.main+1304 @04bf6f> : 10 00                      dup.x1 sp(0)
	<.main+1306 @04bf71> : 13 02                      set.x1 sp(2)
	<.main+1308 @04bf73> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @04bf77> : 10 23                      dup.x1 sp(35)
	<.main+1314 @04bf79> : 10 01                      dup.x1 sp(1)
	<.main+1316 @04bf7b> : 10 01                      dup.x1 sp(1)
	<.main+1318 @04bf7d> : 58                         clt.i32
	<.main+1319 @04bf7e> : 06 0a 00 00                jz <.main+1329 @04bf88>
	<.main+1323 @04bf82> : 10 01                      dup.x1 sp(1)
	<.main+1325 @04bf84> : 04 06 00 00                jmp <.main+1331 @04bf8a>
	<.main+1329 @04bf88> : 10 00                      dup.x1 sp(0)
	<.main+1331 @04bf8a> : 13 02                      set.x1 sp(2)
	<.main+1333 @04bf8c> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @04bf90> : 10 22                      dup.x1 sp(34)
	<.main+1339 @04bf92> : 10 01                      dup.x1 sp(1)
	<.main+1341 @04bf94> : 10 01                      dup.x1 sp(1)
	<.main+1343 @04bf96> : 58                         clt.i32
	<.main+1344 @04bf97> : 06 0a 00 00                jz <.main+1354 @04bfa1>
	<.main+1348 @04bf9b> : 10 01                      dup.x1 sp(1)
	<.main+1350 @04bf9d> : 04 06 00 00                jmp <.main+1356 @04bfa3>
	<.main+1354 @04bfa1> : 10 00                      dup.x1 sp(0)
	<.main+1356 @04bfa3> : 13 02                      set.x1 sp(2)
	<.main+1358 @04bfa5> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@04bfa9> - <@04c00a>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @04bfa9> : 10 25                      dup.x1 sp(37)
	<.main+1364 @04bfab> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @04bfaf> : 10 25                      dup.x1 sp(37)
	<.main+1370 @04bfb1> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @04bfb5> : 10 25                      dup.x1 sp(37)
	<.main+1376 @04bfb7> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @04bfbb> : 10 25                      dup.x1 sp(37)
	<.main+1382 @04bfbd> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @04bfc1> : 10 01                      dup.x1 sp(1)
	<.main+1388 @04bfc3> : 10 01                      dup.x1 sp(1)
	<.main+1390 @04bfc5> : 58                         clt.i32
	<.main+1391 @04bfc6> : 06 0a 00 00                jz <.main+1401 @04bfd0>
	<.main+1395 @04bfca> : 10 01                      dup.x1 sp(1)
	<.main+1397 @04bfcc> : 04 06 00 00                jmp <.main+1403 @04bfd2>
	<.main+1401 @04bfd0> : 10 00                      dup.x1 sp(0)
	<.main+1403 @04bfd2> : 13 02                      set.x1 sp(2)
	<.main+1405 @04bfd4> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @04bfd8> : 10 01                      dup.x1 sp(1)
	<.main+1411 @04bfda> : 10 01                      dup.x1 sp(1)
	<.main+1413 @04bfdc> : 58                         clt.i32
	<.main+1414 @04bfdd> : 06 0a 00 00                jz <.main+1424 @04bfe7>
	<.main+1418 @04bfe1> : 10 01                      dup.x1 sp(1)
	<.main+1420 @04bfe3> : 04 06 00 00                jmp <.main+1426 @04bfe9>
	<.main+1424 @04bfe7> : 10 00                      dup.x1 sp(0)
	<.main+1426 @04bfe9> : 13 02                      set.x1 sp(2)
	<.main+1428 @04bfeb> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @04bfef> : 10 01                      dup.x1 sp(1)
	<.main+1434 @04bff1> : 10 01                      dup.x1 sp(1)
	<.main+1436 @04bff3> : 58                         clt.i32
	<.main+1437 @04bff4> : 06 0a 00 00                jz <.main+1447 @04bffe>
	<.main+1441 @04bff8> : 10 01                      dup.x1 sp(1)
	<.main+1443 @04bffa> : 04 06 00 00                jmp <.main+1449 @04c000>
	<.main+1447 @04bffe> : 10 00                      dup.x1 sp(0)
	<.main+1449 @04c000> : 13 02                      set.x1 sp(2)
	<.main+1451 @04c002> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @04c006> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@04c00a> - <@04c06b>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @04c00a> : 10 26                      dup.x1 sp(38)
	<.main+1461 @04c00c> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @04c010> : 10 26                      dup.x1 sp(38)
	<.main+1467 @04c012> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @04c016> : 10 01                      dup.x1 sp(1)
	<.main+1473 @04c018> : 10 01                      dup.x1 sp(1)
	<.main+1475 @04c01a> : 58                         clt.i32
	<.main+1476 @04c01b> : 06 0a 00 00                jz <.main+1486 @04c025>
	<.main+1480 @04c01f> : 10 01                      dup.x1 sp(1)
	<.main+1482 @04c021> : 04 06 00 00                jmp <.main+1488 @04c027>
	<.main+1486 @04c025> : 10 00                      dup.x1 sp(0)
	<.main+1488 @04c027> : 13 02                      set.x1 sp(2)
	<.main+1490 @04c029> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @04c02d> : 10 25                      dup.x1 sp(37)
	<.main+1496 @04c02f> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @04c033> : 10 01                      dup.x1 sp(1)
	<.main+1502 @04c035> : 10 01                      dup.x1 sp(1)
	<.main+1504 @04c037> : 58                         clt.i32
	<.main+1505 @04c038> : 06 0a 00 00                jz <.main+1515 @04c042>
	<.main+1509 @04c03c> : 10 01                      dup.x1 sp(1)
	<.main+1511 @04c03e> : 04 06 00 00                jmp <.main+1517 @04c044>
	<.main+1515 @04c042> : 10 00                      dup.x1 sp(0)
	<.main+1517 @04c044> : 13 02                      set.x1 sp(2)
	<.main+1519 @04c046> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @04c04a> : 10 24                      dup.x1 sp(36)
	<.main+1525 @04c04c> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @04c050> : 10 01                      dup.x1 sp(1)
	<.main+1531 @04c052> : 10 01                      dup.x1 sp(1)
	<.main+1533 @04c054> : 58                         clt.i32
	<.main+1534 @04c055> : 06 0a 00 00                jz <.main+1544 @04c05f>
	<.main+1538 @04c059> : 10 01                      dup.x1 sp(1)
	<.main+1540 @04c05b> : 04 06 00 00                jmp <.main+1546 @04c061>
	<.main+1544 @04c05f> : 10 00                      dup.x1 sp(0)
	<.main+1546 @04c061> : 13 02                      set.x1 sp(2)
	<.main+1548 @04c063> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @04c067> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@04c06b> - <@04c0c4>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @04c06b> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @04c070> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @04c075> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @04c07a> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @04c07f> : 10 01                      dup.x1 sp(1)
	<.main+1578 @04c081> : 10 01                      dup.x1 sp(1)
	<.main+1580 @04c083> : 59                         cgt.i32
	<.main+1581 @04c084> : 06 0a 00 00                jz <.main+1591 @04c08e>
	<.main+1585 @04c088> : 10 01                      dup.x1 sp(1)
	<.main+1587 @04c08a> : 04 06 00 00                jmp <.main+1593 @04c090>
	<.main+1591 @04c08e> : 10 00                      dup.x1 sp(0)
	<.main+1593 @04c090> : 13 02                      set.x1 sp(2)
	<.main+1595 @04c092> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @04c096> : 10 01                      dup.x1 sp(1)
	<.main+1601 @04c098> : 10 01                      dup.x1 sp(1)
	<.main+1603 @04c09a> : 59                         cgt.i32
	<.main+1604 @04c09b> : 06 0a 00 00                jz <.main+1614 @04c0a5>
	<.main+1608 @04c09f> : 10 01                      dup.x1 sp(1)
	<.main+1610 @04c0a1> : 04 06 00 00                jmp <.main+1616 @04c0a7>
	<.main+1614 @04c0a5> : 10 00                      dup.x1 sp(0)
	<.main+1616 @04c0a7> : 13 02                      set.x1 sp(2)
	<.main+1618 @04c0a9> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @04c0ad> : 10 01                      dup.x1 sp(1)
	<.main+1624 @04c0af> : 10 01                      dup.x1 sp(1)
	<.main+1626 @04c0b1> : 59                         cgt.i32
	<.main+1627 @04c0b2> : 06 0a 00 00                jz <.main+1637 @04c0bc>
	<.main+1631 @04c0b6> : 10 01                      dup.x1 sp(1)
	<.main+1633 @04c0b8> : 04 06 00 00                jmp <.main+1639 @04c0be>
	<.main+1637 @04c0bc> : 10 00                      dup.x1 sp(0)
	<.main+1639 @04c0be> : 13 02                      set.x1 sp(2)
	<.main+1641 @04c0c0> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@04c0c4> - <@04c11d>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @04c0c4> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @04c0c9> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @04c0ce> : 10 01                      dup.x1 sp(1)
	<.main+1657 @04c0d0> : 10 01                      dup.x1 sp(1)
	<.main+1659 @04c0d2> : 59                         cgt.i32
	<.main+1660 @04c0d3> : 06 0a 00 00                jz <.main+1670 @04c0dd>
	<.main+1664 @04c0d7> : 10 01                      dup.x1 sp(1)
	<.main+1666 @04c0d9> : 04 06 00 00                jmp <.main+1672 @04c0df>
	<.main+1670 @04c0dd> : 10 00                      dup.x1 sp(0)
	<.main+1672 @04c0df> : 13 02                      set.x1 sp(2)
	<.main+1674 @04c0e1> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @04c0e5> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @04c0ea> : 10 01                      dup.x1 sp(1)
	<.main+1685 @04c0ec> : 10 01                      dup.x1 sp(1)
	<.main+1687 @04c0ee> : 59                         cgt.i32
	<.main+1688 @04c0ef> : 06 0a 00 00                jz <.main+1698 @04c0f9>
	<.main+1692 @04c0f3> : 10 01                      dup.x1 sp(1)
	<.main+1694 @04c0f5> : 04 06 00 00                jmp <.main+1700 @04c0fb>
	<.main+1698 @04c0f9> : 10 00                      dup.x1 sp(0)
	<.main+1700 @04c0fb> : 13 02                      set.x1 sp(2)
	<.main+1702 @04c0fd> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @04c101> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @04c106> : 10 01                      dup.x1 sp(1)
	<.main+1713 @04c108> : 10 01                      dup.x1 sp(1)
	<.main+1715 @04c10a> : 59                         cgt.i32
	<.main+1716 @04c10b> : 06 0a 00 00                jz <.main+1726 @04c115>
	<.main+1720 @04c10f> : 10 01                      dup.x1 sp(1)
	<.main+1722 @04c111> : 04 06 00 00                jmp <.main+1728 @04c117>
	<.main+1726 @04c115> : 10 00                      dup.x1 sp(0)
	<.main+1728 @04c117> : 13 02                      set.x1 sp(2)
	<.main+1730 @04c119> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@04c11d> - <@04c16a>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @04c11d> : 10 29                      dup.x1 sp(41)
	<.main+1736 @04c11f> : 10 29                      dup.x1 sp(41)
	<.main+1738 @04c121> : 10 29                      dup.x1 sp(41)
	<.main+1740 @04c123> : 10 29                      dup.x1 sp(41)
	<.main+1742 @04c125> : 10 01                      dup.x1 sp(1)
	<.main+1744 @04c127> : 10 01                      dup.x1 sp(1)
	<.main+1746 @04c129> : 59                         cgt.i32
	<.main+1747 @04c12a> : 06 0a 00 00                jz <.main+1757 @04c134>
	<.main+1751 @04c12e> : 10 01                      dup.x1 sp(1)
	<.main+1753 @04c130> : 04 06 00 00                jmp <.main+1759 @04c136>
	<.main+1757 @04c134> : 10 00                      dup.x1 sp(0)
	<.main+1759 @04c136> : 13 02                      set.x1 sp(2)
	<.main+1761 @04c138> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @04c13c> : 10 01                      dup.x1 sp(1)
	<.main+1767 @04c13e> : 10 01                      dup.x1 sp(1)
	<.main+1769 @04c140> : 59                         cgt.i32
	<.main+1770 @04c141> : 06 0a 00 00                jz <.main+1780 @04c14b>
	<.main+1774 @04c145> : 10 01                      dup.x1 sp(1)
	<.main+1776 @04c147> : 04 06 00 00                jmp <.main+1782 @04c14d>
	<.main+1780 @04c14b> : 10 00                      dup.x1 sp(0)
	<.main+1782 @04c14d> : 13 02                      set.x1 sp(2)
	<.main+1784 @04c14f> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @04c153> : 10 01                      dup.x1 sp(1)
	<.main+1790 @04c155> : 10 01                      dup.x1 sp(1)
	<.main+1792 @04c157> : 59                         cgt.i32
	<.main+1793 @04c158> : 06 0a 00 00                jz <.main+1803 @04c162>
	<.main+1797 @04c15c> : 10 01                      dup.x1 sp(1)
	<.main+1799 @04c15e> : 04 06 00 00                jmp <.main+1805 @04c164>
	<.main+1803 @04c162> : 10 00                      dup.x1 sp(0)
	<.main+1805 @04c164> : 13 02                      set.x1 sp(2)
	<.main+1807 @04c166> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@04c16a> - <@04c1b7>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @04c16a> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @04c16c> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @04c16e> : 10 01                      dup.x1 sp(1)
	<.main+1817 @04c170> : 10 01                      dup.x1 sp(1)
	<.main+1819 @04c172> : 59                         cgt.i32
	<.main+1820 @04c173> : 06 0a 00 00                jz <.main+1830 @04c17d>
	<.main+1824 @04c177> : 10 01                      dup.x1 sp(1)
	<.main+1826 @04c179> : 04 06 00 00                jmp <.main+1832 @04c17f>
	<.main+1830 @04c17d> : 10 00                      dup.x1 sp(0)
	<.main+1832 @04c17f> : 13 02                      set.x1 sp(2)
	<.main+1834 @04c181> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @04c185> : 10 29                      dup.x1 sp(41)
	<.main+1840 @04c187> : 10 01                      dup.x1 sp(1)
	<.main+1842 @04c189> : 10 01                      dup.x1 sp(1)
	<.main+1844 @04c18b> : 59                         cgt.i32
	<.main+1845 @04c18c> : 06 0a 00 00                jz <.main+1855 @04c196>
	<.main+1849 @04c190> : 10 01                      dup.x1 sp(1)
	<.main+1851 @04c192> : 04 06 00 00                jmp <.main+1857 @04c198>
	<.main+1855 @04c196> : 10 00                      dup.x1 sp(0)
	<.main+1857 @04c198> : 13 02                      set.x1 sp(2)
	<.main+1859 @04c19a> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @04c19e> : 10 28                      dup.x1 sp(40)
	<.main+1865 @04c1a0> : 10 01                      dup.x1 sp(1)
	<.main+1867 @04c1a2> : 10 01                      dup.x1 sp(1)
	<.main+1869 @04c1a4> : 59                         cgt.i32
	<.main+1870 @04c1a5> : 06 0a 00 00                jz <.main+1880 @04c1af>
	<.main+1874 @04c1a9> : 10 01                      dup.x1 sp(1)
	<.main+1876 @04c1ab> : 04 06 00 00                jmp <.main+1882 @04c1b1>
	<.main+1880 @04c1af> : 10 00                      dup.x1 sp(0)
	<.main+1882 @04c1b1> : 13 02                      set.x1 sp(2)
	<.main+1884 @04c1b3> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@04c1b7> - <@04c218>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @04c1b7> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @04c1b9> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @04c1bd> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @04c1bf> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @04c1c3> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @04c1c5> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @04c1c9> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @04c1cb> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @04c1cf> : 10 01                      dup.x1 sp(1)
	<.main+1914 @04c1d1> : 10 01                      dup.x1 sp(1)
	<.main+1916 @04c1d3> : 59                         cgt.i32
	<.main+1917 @04c1d4> : 06 0a 00 00                jz <.main+1927 @04c1de>
	<.main+1921 @04c1d8> : 10 01                      dup.x1 sp(1)
	<.main+1923 @04c1da> : 04 06 00 00                jmp <.main+1929 @04c1e0>
	<.main+1927 @04c1de> : 10 00                      dup.x1 sp(0)
	<.main+1929 @04c1e0> : 13 02                      set.x1 sp(2)
	<.main+1931 @04c1e2> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @04c1e6> : 10 01                      dup.x1 sp(1)
	<.main+1937 @04c1e8> : 10 01                      dup.x1 sp(1)
	<.main+1939 @04c1ea> : 59                         cgt.i32
	<.main+1940 @04c1eb> : 06 0a 00 00                jz <.main+1950 @04c1f5>
	<.main+1944 @04c1ef> : 10 01                      dup.x1 sp(1)
	<.main+1946 @04c1f1> : 04 06 00 00                jmp <.main+1952 @04c1f7>
	<.main+1950 @04c1f5> : 10 00                      dup.x1 sp(0)
	<.main+1952 @04c1f7> : 13 02                      set.x1 sp(2)
	<.main+1954 @04c1f9> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @04c1fd> : 10 01                      dup.x1 sp(1)
	<.main+1960 @04c1ff> : 10 01                      dup.x1 sp(1)
	<.main+1962 @04c201> : 59                         cgt.i32
	<.main+1963 @04c202> : 06 0a 00 00                jz <.main+1973 @04c20c>
	<.main+1967 @04c206> : 10 01                      dup.x1 sp(1)
	<.main+1969 @04c208> : 04 06 00 00                jmp <.main+1975 @04c20e>
	<.main+1973 @04c20c> : 10 00                      dup.x1 sp(0)
	<.main+1975 @04c20e> : 13 02                      set.x1 sp(2)
	<.main+1977 @04c210> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @04c214> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@04c218> - <@04c279>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @04c218> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @04c21a> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @04c21e> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @04c220> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @04c224> : 10 01                      dup.x1 sp(1)
	<.main+1999 @04c226> : 10 01                      dup.x1 sp(1)
	<.main+2001 @04c228> : 59                         cgt.i32
	<.main+2002 @04c229> : 06 0a 00 00                jz <.main+2012 @04c233>
	<.main+2006 @04c22d> : 10 01                      dup.x1 sp(1)
	<.main+2008 @04c22f> : 04 06 00 00                jmp <.main+2014 @04c235>
	<.main+2012 @04c233> : 10 00                      dup.x1 sp(0)
	<.main+2014 @04c235> : 13 02                      set.x1 sp(2)
	<.main+2016 @04c237> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @04c23b> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @04c23d> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @04c241> : 10 01                      dup.x1 sp(1)
	<.main+2028 @04c243> : 10 01                      dup.x1 sp(1)
	<.main+2030 @04c245> : 59                         cgt.i32
	<.main+2031 @04c246> : 06 0a 00 00                jz <.main+2041 @04c250>
	<.main+2035 @04c24a> : 10 01                      dup.x1 sp(1)
	<.main+2037 @04c24c> : 04 06 00 00                jmp <.main+2043 @04c252>
	<.main+2041 @04c250> : 10 00                      dup.x1 sp(0)
	<.main+2043 @04c252> : 13 02                      set.x1 sp(2)
	<.main+2045 @04c254> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @04c258> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @04c25a> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @04c25e> : 10 01                      dup.x1 sp(1)
	<.main+2057 @04c260> : 10 01                      dup.x1 sp(1)
	<.main+2059 @04c262> : 59                         cgt.i32
	<.main+2060 @04c263> : 06 0a 00 00                jz <.main+2070 @04c26d>
	<.main+2064 @04c267> : 10 01                      dup.x1 sp(1)
	<.main+2066 @04c269> : 04 06 00 00                jmp <.main+2072 @04c26f>
	<.main+2070 @04c26d> : 10 00                      dup.x1 sp(0)
	<.main+2072 @04c26f> : 13 02                      set.x1 sp(2)
	<.main+2074 @04c271> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @04c275> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@04c279> - <@04c27e>): overload1: float32 := overload
	<.main+2082 @04c279> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@04c27e> - <@04c283>): overload2: float32 := overload()
	<.main+2087 @04c27e> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@04c283> - <@04c288>): overload3: float32 := overload(0)
	<.main+2092 @04c283> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@04c288> - <@04c28d>): overload4: float32 := overload(0.000000)
	<.main+2097 @04c288> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@04c28d> - <@04c292>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @04c28d> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@04c292> - <@04c29b>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @04c292> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@04c29b> - <@04c2b1>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @04c29b> : 11 00                      dup.x2 sp(0)
	<.main+2118 @04c29d> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @04c2a6> : 83                         mul.f64
	<.main+2128 @04c2a7> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @04c2b0> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@04c2b1> - <@04c2b6>): valueRef: int64 := value
	<.main+2138 @04c2b1> : 1f d8 b7 04 00             load.ref <@04b7d8> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@04c2b6> - <@04c2bb>): valuePtr: pointer := value
	<.main+2143 @04c2b6> : 1f d8 b7 04 00             load.ref <@04b7d8> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@04c2bb> - <@04c2c5>): valueVar: variant := value
	<.main+2148 @04c2bb> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+2153 @04c2c0> : 1f d8 b7 04 00             load.ref <@04b7d8> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@04c2c5> - <@04c2c8>): fromRef: int64 := valueRef
	<.main+2158 @04c2c5> : 10 03                      dup.x1 sp(3)
	<.main+2160 @04c2c7> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@04c2c8> - <@04c2ca>): fromPtr: int64 := valuePtr
	<.main+2161 @04c2c8> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@04c2ca> - <@04c2cc>): fromVar: int64 := valueVar
	<.main+2163 @04c2ca> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@04c2cc> - <@04c2d1>): nullRef: int64 := null
	<.main+2165 @04c2cc> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@04c2d1> - <@04c2d6>): nullPtr: pointer := null
	<.main+2170 @04c2d1> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@04c2d6> - <@04c2e0>): nullVar: variant := null
	<.main+2175 @04c2d6> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+2180 @04c2db> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@04c2e0> - <@04c2e5>): nullTyp: typename := null
	<.main+2185 @04c2e0> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@04c2e5> - <@04c2ea>): nullFun: function := null
	<.main+2190 @04c2e5> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@04c2ea> - <@04c2ef>): nullObj: object := null
	<.main+2195 @04c2ea> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@04c2ef> - <@04c2f4>): typePtr: pointer := int64
	<.main+2200 @04c2ef> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@04c2f4> - <@04c2fe>): typeVar: variant := int64
	<.main+2205 @04c2f4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @04c2f9> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@04c2fe> - <@04c303>): typeTyp: typename := int64
	<.main+2215 @04c2fe> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@04c303> - <@04c307>): local: int64 := value
	<.main+2220 @04c303> : 2b d8 b7 04                load.m64 <@04b7d8> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@04c307> - <@04c309>): copyVal: int64 := local
	<.main+2224 @04c307> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@04c309> - <@04c30b>): copyRef: int64 := valueRef
	<.main+2226 @04c309> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@04c30b> - <@04c30d>): copyPtr: pointer := valuePtr
	<.main+2228 @04c30b> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@04c30d> - <@04c30f>): copyVar: variant := valueVar
	<.main+2230 @04c30d> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@04c30f> - <@04c311>): copyTyp: typename := typeTyp
	<.main+2232 @04c30f> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@04c311> - <@04c316>): ptrVoid: pointer := void
	<.main+2234 @04c311> : 1f a8 00 00 00             load.ref <@0000a8> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@04c316> - <@04c31b>): ptrBool: pointer := bool
	<.main+2239 @04c316> : 1f 40 01 00 00             load.ref <@000140> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@04c31b> - <@04c320>): ptrChar: pointer := char
	<.main+2244 @04c31b> : 1f d8 01 00 00             load.ref <@0001d8> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@04c320> - <@04c325>): ptrInt8: pointer := int8
	<.main+2249 @04c320> : 1f 70 02 00 00             load.ref <@000270> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@04c325> - <@04c32a>): ptrInt16: pointer := int16
	<.main+2254 @04c325> : 1f 08 03 00 00             load.ref <@000308> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@04c32a> - <@04c32f>): ptrInt32: pointer := int32
	<.main+2259 @04c32a> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@04c32f> - <@04c334>): ptrInt64: pointer := int64
	<.main+2264 @04c32f> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@04c334> - <@04c339>): ptrUint8: pointer := uint8
	<.main+2269 @04c334> : 1f d0 04 00 00             load.ref <@0004d0> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@04c339> - <@04c33e>): ptrUint16: pointer := uint16
	<.main+2274 @04c339> : 1f 68 05 00 00             load.ref <@000568> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@04c33e> - <@04c343>): ptrUint32: pointer := uint32
	<.main+2279 @04c33e> : 1f 00 06 00 00             load.ref <@000600> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@04c343> - <@04c348>): ptrUint64: pointer := uint64
	<.main+2284 @04c343> : 1f 98 06 00 00             load.ref <@000698> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@04c348> - <@04c34d>): ptrFloat32: pointer := float32
	<.main+2289 @04c348> : 1f 30 07 00 00             load.ref <@000730> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@04c34d> - <@04c352>): ptrFloat64: pointer := float64
	<.main+2294 @04c34d> : 1f c8 07 00 00             load.ref <@0007c8> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@04c352> - <@04c357>): ptrTypename: pointer := typename
	<.main+2299 @04c352> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@04c357> - <@04c35c>): ptrFunction: pointer := function
	<.main+2304 @04c357> : 1f 90 09 00 00             load.ref <@000990> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@04c35c> - <@04c361>): ptrPointer: pointer := pointer
	<.main+2309 @04c35c> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@04c361> - <@04c366>): ptrVariant: pointer := variant
	<.main+2314 @04c361> : 1f f8 08 00 00             load.ref <@0008f8> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@04c366> - <@04c36b>): ptrObject: pointer := object
	<.main+2319 @04c366> : 1f 30 0a 00 00             load.ref <@000a30> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@04c36b> - <@04c375>): varVoid: variant := void
	<.main+2324 @04c36b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @04c370> : 1f a8 00 00 00             load.ref <@0000a8> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@04c375> - <@04c37f>): varBool: variant := bool
	<.main+2334 @04c375> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @04c37a> : 1f 40 01 00 00             load.ref <@000140> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@04c37f> - <@04c389>): varChar: variant := char
	<.main+2344 @04c37f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @04c384> : 1f d8 01 00 00             load.ref <@0001d8> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@04c389> - <@04c393>): varInt8: variant := int8
	<.main+2354 @04c389> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @04c38e> : 1f 70 02 00 00             load.ref <@000270> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@04c393> - <@04c39d>): varInt16: variant := int16
	<.main+2364 @04c393> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @04c398> : 1f 08 03 00 00             load.ref <@000308> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@04c39d> - <@04c3a7>): varInt32: variant := int32
	<.main+2374 @04c39d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @04c3a2> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@04c3a7> - <@04c3b1>): varInt64: variant := int64
	<.main+2384 @04c3a7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @04c3ac> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@04c3b1> - <@04c3bb>): varUint8: variant := uint8
	<.main+2394 @04c3b1> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @04c3b6> : 1f d0 04 00 00             load.ref <@0004d0> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@04c3bb> - <@04c3c5>): varUint16: variant := uint16
	<.main+2404 @04c3bb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @04c3c0> : 1f 68 05 00 00             load.ref <@000568> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@04c3c5> - <@04c3cf>): varUint32: variant := uint32
	<.main+2414 @04c3c5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @04c3ca> : 1f 00 06 00 00             load.ref <@000600> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@04c3cf> - <@04c3d9>): varUint64: variant := uint64
	<.main+2424 @04c3cf> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @04c3d4> : 1f 98 06 00 00             load.ref <@000698> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@04c3d9> - <@04c3e3>): varFloat32: variant := float32
	<.main+2434 @04c3d9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @04c3de> : 1f 30 07 00 00             load.ref <@000730> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@04c3e3> - <@04c3ed>): varFloat64: variant := float64
	<.main+2444 @04c3e3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @04c3e8> : 1f c8 07 00 00             load.ref <@0007c8> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@04c3ed> - <@04c3f7>): varTypename: variant := typename
	<.main+2454 @04c3ed> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @04c3f2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@04c3f7> - <@04c401>): varFunction: variant := function
	<.main+2464 @04c3f7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @04c3fc> : 1f 90 09 00 00             load.ref <@000990> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@04c401> - <@04c40b>): varPointer: variant := pointer
	<.main+2474 @04c401> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @04c406> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@04c40b> - <@04c415>): varVariant: variant := variant
	<.main+2484 @04c40b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @04c410> : 1f f8 08 00 00             load.ref <@0008f8> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@04c415> - <@04c41f>): varObject: variant := object
	<.main+2494 @04c415> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @04c41a> : 1f 30 0a 00 00             load.ref <@000a30> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@04c41f> - <@04c424>): typVoid: typename := void
	<.main+2504 @04c41f> : 1f a8 00 00 00             load.ref <@0000a8> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@04c424> - <@04c429>): typBool: typename := bool
	<.main+2509 @04c424> : 1f 40 01 00 00             load.ref <@000140> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@04c429> - <@04c42e>): typChar: typename := char
	<.main+2514 @04c429> : 1f d8 01 00 00             load.ref <@0001d8> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@04c42e> - <@04c433>): typInt8: typename := int8
	<.main+2519 @04c42e> : 1f 70 02 00 00             load.ref <@000270> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@04c433> - <@04c438>): typInt16: typename := int16
	<.main+2524 @04c433> : 1f 08 03 00 00             load.ref <@000308> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@04c438> - <@04c43d>): typInt32: typename := int32
	<.main+2529 @04c438> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@04c43d> - <@04c442>): typInt64: typename := int64
	<.main+2534 @04c43d> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@04c442> - <@04c447>): typUint8: typename := uint8
	<.main+2539 @04c442> : 1f d0 04 00 00             load.ref <@0004d0> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@04c447> - <@04c44c>): typUint16: typename := uint16
	<.main+2544 @04c447> : 1f 68 05 00 00             load.ref <@000568> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@04c44c> - <@04c451>): typUint32: typename := uint32
	<.main+2549 @04c44c> : 1f 00 06 00 00             load.ref <@000600> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@04c451> - <@04c456>): typUint64: typename := uint64
	<.main+2554 @04c451> : 1f 98 06 00 00             load.ref <@000698> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@04c456> - <@04c45b>): typFloat32: typename := float32
	<.main+2559 @04c456> : 1f 30 07 00 00             load.ref <@000730> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@04c45b> - <@04c460>): typFloat64: typename := float64
	<.main+2564 @04c45b> : 1f c8 07 00 00             load.ref <@0007c8> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@04c460> - <@04c465>): typTypename: typename := typename
	<.main+2569 @04c460> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@04c465> - <@04c46a>): typFunction: typename := function
	<.main+2574 @04c465> : 1f 90 09 00 00             load.ref <@000990> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@04c46a> - <@04c46f>): typPointer: typename := pointer
	<.main+2579 @04c46a> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@04c46f> - <@04c474>): typVariant: typename := variant
	<.main+2584 @04c46f> : 1f f8 08 00 00             load.ref <@0008f8> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@04c474> - <@04c479>): typObject: typename := object
	<.main+2589 @04c474> : 1f 30 0a 00 00             load.ref <@000a30> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@04c479> - <@04c47e>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @04c479> : 1f d8 b7 04 00             load.ref <@04b7d8> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@04c47e> - <@04c488>): valueOfVar: variant := variant(value)
	<.main+2599 @04c47e> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+2604 @04c483> : 1f d8 b7 04 00             load.ref <@04b7d8> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@04c488> - <@04c48d>): valueOfTyp: typename := typename(value)
	<.main+2609 @04c488> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@04c48d> - <@04c492>): typeOfValue: typename := typename(value)
	<.main+2614 @04c48d> : 1f 38 04 00 00             load.ref <@000438> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@04c492> - <@04c499>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @04c492> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+2624 @04c497> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@04c499> - <@04c49b>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @04c499> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@04c49b> - <@04c4b0>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @04c49b> : 19                         load.z32
	<.main+2629 @04c49c> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @04c4a1> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @04c4a6> : 1f e8 b7 04 00             load.ref <@04b7e8> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @04c4ab> : 02                         call
	<.main+2645 @04c4ac> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@04c4b0> - <@04c4b5>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @04c4b0> : 1f e8 b7 04 00             load.ref <@04b7e8> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@04c4b5> - <@04c4c7>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @04c4b5> : 19                         load.z32
	<.main+2655 @04c4b6> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @04c4bb> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @04c4c0> : 10 03                      dup.x1 sp(3)
	<.main+2667 @04c4c2> : 02                         call
	<.main+2668 @04c4c3> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@04c4c7> - <@04c4cc>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @04c4c7> : 1f f0 b7 04 00             load.ref <@04b7f0> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@04c4cc> - <@04c4de>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @04c4cc> : 19                         load.z32
	<.main+2678 @04c4cd> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @04c4d2> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @04c4d7> : 10 03                      dup.x1 sp(3)
	<.main+2690 @04c4d9> : 02                         call
	<.main+2691 @04c4da> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@04c4de> - <@04c4e0>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @04c4de> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@04c4e0> - <@04c4f2>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @04c4e0> : 19                         load.z32
	<.main+2698 @04c4e1> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @04c4e6> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @04c4eb> : 10 03                      dup.x1 sp(3)
	<.main+2710 @04c4ed> : 02                         call
	<.main+2711 @04c4ee> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@04c4f2> - <@04c502>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @04c4f2> : 19                         load.z32
	<.main+2716 @04c4f3> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @04c4f8> : 1f f8 b7 04 00             load.ref <@04b7f8> ;fib(n: uint32): uint32
	<.main+2726 @04c4fd> : 02                         call
	<.main+2727 @04c4fe> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@04c502> - <@04c506>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @04c502> : 2a c0 00 00                load.m32 <@0000c0>
	test/lang/reflect.ci:4: (4 bytes: <@04c506> - <@04c50a>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @04c506> : 2a 58 01 00                load.m32 <@000158>
	test/lang/reflect.ci:5: (4 bytes: <@04c50a> - <@04c50e>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @04c50a> : 2a f0 01 00                load.m32 <@0001f0>
	test/lang/reflect.ci:6: (4 bytes: <@04c50e> - <@04c512>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @04c50e> : 2a 88 02 00                load.m32 <@000288>
	test/lang/reflect.ci:7: (4 bytes: <@04c512> - <@04c516>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @04c512> : 2a 20 03 00                load.m32 <@000320>
	test/lang/reflect.ci:8: (4 bytes: <@04c516> - <@04c51a>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @04c516> : 2a b8 03 00                load.m32 <@0003b8>
	test/lang/reflect.ci:9: (4 bytes: <@04c51a> - <@04c51e>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @04c51a> : 2a 50 04 00                load.m32 <@000450>
	test/lang/reflect.ci:10: (4 bytes: <@04c51e> - <@04c522>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @04c51e> : 2a e8 04 00                load.m32 <@0004e8>
	test/lang/reflect.ci:11: (4 bytes: <@04c522> - <@04c526>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @04c522> : 2a 80 05 00                load.m32 <@000580>
	test/lang/reflect.ci:12: (4 bytes: <@04c526> - <@04c52a>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @04c526> : 2a 18 06 00                load.m32 <@000618>
	test/lang/reflect.ci:13: (4 bytes: <@04c52a> - <@04c52e>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @04c52a> : 2a b0 06 00                load.m32 <@0006b0>
	test/lang/reflect.ci:14: (4 bytes: <@04c52e> - <@04c532>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @04c52e> : 2a 48 07 00                load.m32 <@000748>
	test/lang/reflect.ci:15: (4 bytes: <@04c532> - <@04c536>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @04c532> : 2a e0 07 00                load.m32 <@0007e0>
	test/lang/reflect.ci:16: (4 bytes: <@04c536> - <@04c53a>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @04c536> : 2a 78 08 00                load.m32 <@000878>
	test/lang/reflect.ci:17: (4 bytes: <@04c53a> - <@04c53e>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @04c53a> : 2a 10 09 00                load.m32 <@000910>
	test/lang/reflect.ci:18: (4 bytes: <@04c53e> - <@04c542>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @04c53e> : 2a 20 00 00                load.m32 <@000020> ;typename+24
	test/lang/reflect.ci:19: (4 bytes: <@04c542> - <@04c546>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @04c542> : 2a a8 09 00                load.m32 <@0009a8>
	test/lang/reflect.ci:20: (4 bytes: <@04c546> - <@04c54a>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @04c546> : 2a 48 0a 00                load.m32 <@000a48>
	test/lang/reflect.ci:30: (5 bytes: <@04c54a> - <@04c54f>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @04c54a> : 1f d8 2b 03 00             load.ref <@032bd8> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@04c54f> - <@04c555>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @04c54f> : 10 00                      dup.x1 sp(0)
	<.main+2810 @04c551> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@04c555> - <@04c55c>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @04c555> : 10 01                      dup.x1 sp(1)
	<.main+2816 @04c557> : 0c 20 00 00                inc.i32(+32)
	<.main+2820 @04c55b> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@04c55c> - <@04c563>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @04c55c> : 10 02                      dup.x1 sp(2)
	<.main+2823 @04c55e> : 0c 18 00 00                inc.i32(+24)
	<.main+2827 @04c562> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@04c563> - <@04c569>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @04c563> : 10 03                      dup.x1 sp(3)
	<.main+2830 @04c565> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@04c569> - <@04c56f>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @04c569> : 10 04                      dup.x1 sp(4)
	<.main+2836 @04c56b> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@04c56f> - <@04c575>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @04c56f> : 10 05                      dup.x1 sp(5)
	<.main+2842 @04c571> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@04c575> - <@04c57b>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @04c575> : 10 00                      dup.x1 sp(0)
	<.main+2848 @04c577> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@04c57b> - <@04c582>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @04c57b> : 10 01                      dup.x1 sp(1)
	<.main+2854 @04c57d> : 0c 20 00 00                inc.i32(+32)
	<.main+2858 @04c581> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@04c582> - <@04c589>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @04c582> : 10 02                      dup.x1 sp(2)
	<.main+2861 @04c584> : 0c 18 00 00                inc.i32(+24)
	<.main+2865 @04c588> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@04c589> - <@04c58f>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @04c589> : 10 03                      dup.x1 sp(3)
	<.main+2868 @04c58b> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@04c58f> - <@04c595>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @04c58f> : 10 04                      dup.x1 sp(4)
	<.main+2874 @04c591> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@04c595> - <@04c59b>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @04c595> : 10 05                      dup.x1 sp(5)
	<.main+2880 @04c597> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@04c59b> - <@04c5a2>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @04c59b> : 10 00                      dup.x1 sp(0)
	<.main+2886 @04c59d> : 0c 20 00 00                inc.i32(+32)
	<.main+2890 @04c5a1> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@04c5a2> - <@04c5a9>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @04c5a2> : 10 01                      dup.x1 sp(1)
	<.main+2893 @04c5a4> : 0c 18 00 00                inc.i32(+24)
	<.main+2897 @04c5a8> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@04c5a9> - <@04c5af>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @04c5a9> : 10 02                      dup.x1 sp(2)
	<.main+2900 @04c5ab> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@04c5af> - <@04c5b6>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @04c5af> : 10 00                      dup.x1 sp(0)
	<.main+2906 @04c5b1> : 0c 20 00 00                inc.i32(+32)
	<.main+2910 @04c5b5> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@04c5b6> - <@04c5bd>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @04c5b6> : 10 01                      dup.x1 sp(1)
	<.main+2913 @04c5b8> : 0c 18 00 00                inc.i32(+24)
	<.main+2917 @04c5bc> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@04c5bd> - <@04c5c6>): pi64: float64 := 3.141593
	<.main+2918 @04c5bd> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@04c5c6> - <@04c5cf>): e64: float64 := 2.718282
	<.main+2927 @04c5c6> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@04c5cf> - <@04c5d2>): pi32: float32 := pi64
	<.main+2936 @04c5cf> : 11 02                      dup.x2 sp(2)
	<.main+2938 @04c5d1> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@04c5d2> - <@04c5d5>): e32: float32 := e64
	<.main+2939 @04c5d2> : 11 01                      dup.x2 sp(1)
	<.main+2941 @04c5d4> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@04c5d5> - <@04c5dc>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @04c5d5> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @04c5da> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@04c5dc> - <@04c5e3>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @04c5dc> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @04c5e1> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@04c5e3> - <@04c5ea>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @04c5e3> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @04c5e8> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@04c5ea> - <@04c606>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @04c5ea> : 10 02                      dup.x1 sp(2)
	<.main+2965 @04c5ec> : 3f 48                      b32.shl 0x008
	<.main+2967 @04c5ee> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @04c5f3> : 31                         and.b32
	<.main+2973 @04c5f4> : 10 02                      dup.x1 sp(2)
	<.main+2975 @04c5f6> : 3f 43                      b32.shl 0x003
	<.main+2977 @04c5f8> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @04c5fd> : 31                         and.b32
	<.main+2983 @04c5fe> : 32                         or.b32
	<.main+2984 @04c5ff> : 10 01                      dup.x1 sp(1)
	<.main+2986 @04c601> : 3f c3                      b32.sar 0x003
	<.main+2988 @04c603> : 3f 05                      b32.and 0x01f
	<.main+2990 @04c605> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@04c606> - <@04c620>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @04c606> : 10 03                      dup.x1 sp(3)
	<.main+2993 @04c608> : 3f 50                      b32.shl 0x010
	<.main+2995 @04c60a> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @04c60f> : 31                         and.b32
	<.main+3001 @04c610> : 10 03                      dup.x1 sp(3)
	<.main+3003 @04c612> : 3f 48                      b32.shl 0x008
	<.main+3005 @04c614> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @04c619> : 31                         and.b32
	<.main+3011 @04c61a> : 32                         or.b32
	<.main+3012 @04c61b> : 10 02                      dup.x1 sp(2)
	<.main+3014 @04c61d> : 3f 08                      b32.and 0x0ff
	<.main+3016 @04c61f> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@04c620> - <@04c630>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @04c620> : 10 01                      dup.x1 sp(1)
	<.main+3019 @04c622> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @04c627> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @04c62c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@04c630> - <@04c640>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @04c630> : 10 02                      dup.x1 sp(2)
	<.main+3035 @04c632> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @04c637> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @04c63c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@04c640> - <@04c64c>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @04c640> : 10 03                      dup.x1 sp(3)
	<.main+3051 @04c642> : 19                         load.z32
	<.main+3052 @04c643> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @04c648> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@04c64c> - <@04c65c>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @04c64c> : 10 04                      dup.x1 sp(4)
	<.main+3063 @04c64e> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @04c653> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @04c658> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@04c65c> - <@04c66c>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @04c65c> : 10 05                      dup.x1 sp(5)
	<.main+3079 @04c65e> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @04c663> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @04c668> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@04c66c> - <@04c678>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @04c66c> : 10 06                      dup.x1 sp(6)
	<.main+3095 @04c66e> : 19                         load.z32
	<.main+3096 @04c66f> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @04c674> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@04c678> - <@04c688>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @04c678> : 10 06                      dup.x1 sp(6)
	<.main+3107 @04c67a> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @04c67f> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @04c684> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@04c688> - <@04c698>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @04c688> : 10 07                      dup.x1 sp(7)
	<.main+3123 @04c68a> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @04c68f> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @04c694> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@04c698> - <@04c6a4>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @04c698> : 10 08                      dup.x1 sp(8)
	<.main+3139 @04c69a> : 19                         load.z32
	<.main+3140 @04c69b> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @04c6a0> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@04c6a4> - <@04c6b4>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @04c6a4> : 10 09                      dup.x1 sp(9)
	<.main+3151 @04c6a6> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @04c6ab> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @04c6b0> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@04c6b4> - <@04c6c4>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @04c6b4> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @04c6b6> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @04c6bb> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @04c6c0> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@04c6c4> - <@04c6d0>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @04c6c4> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @04c6c6> : 19                         load.z32
	<.main+3184 @04c6c7> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @04c6cc> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@04c6d0> - <@04c6e0>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @04c6d0> : 11 15                      dup.x2 sp(21)
	<.main+3195 @04c6d2> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @04c6db> : 84                         div.f64
	<.main+3205 @04c6dc> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@04c6e0> - <@04c6f0>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @04c6e0> : 11 17                      dup.x2 sp(23)
	<.main+3211 @04c6e2> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @04c6eb> : 84                         div.f64
	<.main+3221 @04c6ec> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@04c6f0> - <@04c700>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @04c6f0> : 11 19                      dup.x2 sp(25)
	<.main+3227 @04c6f2> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @04c6fb> : 84                         div.f64
	<.main+3237 @04c6fc> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@04c700> - <@04c70c>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @04c700> : 11 19                      dup.x2 sp(25)
	<.main+3243 @04c702> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @04c704> : 83                         mul.f64
	<.main+3246 @04c705> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @04c707> : 83                         mul.f64
	<.main+3249 @04c708> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@04c70c> - <@04c719>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @04c70c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @04c715> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@04c719> - <@04c72b>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @04c719> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @04c71b> : 11 21                      dup.x2 sp(33)
	<.main+3270 @04c71d> : 83                         mul.f64
	<.main+3271 @04c71e> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @04c727> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@04c72b> - <@04c734>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @04c72b> : 11 21                      dup.x2 sp(33)
	<.main+3286 @04c72d> : 11 23                      dup.x2 sp(35)
	<.main+3288 @04c72f> : 83                         mul.f64
	<.main+3289 @04c730> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@04c734> - <@04c743>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @04c734> : 11 23                      dup.x2 sp(35)
	<.main+3295 @04c736> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @04c73f> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@04c743> - <@04c74f>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @04c743> : 10 22                      dup.x1 sp(34)
	<.main+3310 @04c745> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @04c74a> : 74                         div.f32
	<.main+3316 @04c74b> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@04c74f> - <@04c75b>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @04c74f> : 10 23                      dup.x1 sp(35)
	<.main+3322 @04c751> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @04c756> : 74                         div.f32
	<.main+3328 @04c757> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@04c75b> - <@04c767>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @04c75b> : 10 24                      dup.x1 sp(36)
	<.main+3334 @04c75d> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @04c762> : 74                         div.f32
	<.main+3340 @04c763> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@04c767> - <@04c773>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @04c767> : 10 24                      dup.x1 sp(36)
	<.main+3346 @04c769> : 10 25                      dup.x1 sp(37)
	<.main+3348 @04c76b> : 73                         mul.f32
	<.main+3349 @04c76c> : 10 25                      dup.x1 sp(37)
	<.main+3351 @04c76e> : 73                         mul.f32
	<.main+3352 @04c76f> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@04c773> - <@04c77c>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @04c773> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @04c778> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@04c77c> - <@04c78a>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @04c77c> : 10 27                      dup.x1 sp(39)
	<.main+3367 @04c77e> : 10 28                      dup.x1 sp(40)
	<.main+3369 @04c780> : 73                         mul.f32
	<.main+3370 @04c781> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @04c786> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@04c78a> - <@04c793>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @04c78a> : 10 28                      dup.x1 sp(40)
	<.main+3381 @04c78c> : 10 29                      dup.x1 sp(41)
	<.main+3383 @04c78e> : 73                         mul.f32
	<.main+3384 @04c78f> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@04c793> - <@04c79e>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @04c793> : 10 29                      dup.x1 sp(41)
	<.main+3390 @04c795> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @04c79a> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@04c79e> - <@04c7a4>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @04c79e> : 10 25                      dup.x1 sp(37)
	<.main+3401 @04c7a0> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@04c7a4> - <@04c7aa>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @04c7a4> : 10 26                      dup.x1 sp(38)
	<.main+3407 @04c7a6> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@04c7aa> - <@04c7b0>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @04c7aa> : 10 27                      dup.x1 sp(39)
	<.main+3413 @04c7ac> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@04c7b0> - <@04c7b6>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @04c7b0> : 10 28                      dup.x1 sp(40)
	<.main+3419 @04c7b2> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@04c7b6> - <@04c7bc>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @04c7b6> : 10 29                      dup.x1 sp(41)
	<.main+3425 @04c7b8> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@04c7bc> - <@04c7c2>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @04c7bc> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @04c7be> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@04c7c2> - <@04c7ce>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @04c7c2> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @04c7c4> : 19                         load.z32
	<.main+3438 @04c7c5> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @04c7ca> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@04c7ce> - <@04c7da>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @04c7ce> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @04c7d0> : 19                         load.z32
	<.main+3450 @04c7d1> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @04c7d6> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@04c7da> - <@04c7e8>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @04c7da> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @04c7dc> : 5c                         i32.2i64
	<.main+3462 @04c7dd> : 19                         load.z32
	<.main+3463 @04c7de> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @04c7e3> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @04c7e7> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@04c7e8> - <@04c7f6>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @04c7e8> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @04c7ea> : 5c                         i32.2i64
	<.main+3476 @04c7eb> : 19                         load.z32
	<.main+3477 @04c7ec> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @04c7f1> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @04c7f5> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@04c7f6> - <@04c804>): p1: pointer := malloc(1024)
	<.main+3487 @04c7f6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @04c7fb> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @04c800> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@04c804> - <@04c812>): p2: pointer := malloc(80)
	<.main+3501 @04c804> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @04c809> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @04c80e> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@04c812> - <@04c820>): p3: pointer := malloc(160)
	<.main+3515 @04c812> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @04c817> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @04c81c> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@04c820> - <@04c82e>): p4: pointer := malloc(820)
	<.main+3529 @04c820> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @04c825> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @04c82a> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@04c82e> - <@04c83e>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @04c82e> : 10 03                      dup.x1 sp(3)
	<.main+3545 @04c830> : 19                         load.z32
	<.main+3546 @04c831> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @04c836> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @04c83a> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@04c83e> - <@04c84f>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @04c83e> : 10 03                      dup.x1 sp(3)
	<.main+3561 @04c840> : 10 02                      dup.x1 sp(2)
	<.main+3563 @04c842> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @04c847> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @04c84b> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@04c84f> - <@04c85a>): free(p1);
	<.main+3576 @04c84f> : 10 03                      dup.x1 sp(3)
	<.main+3578 @04c851> : 19                         load.z32
	<.main+3579 @04c852> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @04c856> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@04c85a> - <@04c865>): free(p2);
	<.main+3587 @04c85a> : 10 02                      dup.x1 sp(2)
	<.main+3589 @04c85c> : 19                         load.z32
	<.main+3590 @04c85d> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @04c861> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@04c865> - <@04c870>): free(p3);
	<.main+3598 @04c865> : 10 01                      dup.x1 sp(1)
	<.main+3600 @04c867> : 19                         load.z32
	<.main+3601 @04c868> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @04c86c> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@04c870> - <@04c87b>): free(p4);
	<.main+3609 @04c870> : 10 00                      dup.x1 sp(0)
	<.main+3611 @04c872> : 19                         load.z32
	<.main+3612 @04c873> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @04c877> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@04c87b> - <@04c884>): val1: int64 := 42
	<.main+3620 @04c87b> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@04c884> - <@04c88d>): val2: int64 := 96
	<.main+3629 @04c884> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@04c88d> - <@04c8af>): debug(void("val1", val1));
	<.main+3638 @04c88d> : 1f 08 5c 03 00             load.ref <@035c08> ;"test/stdc/memory.ci"
	<.main+3643 @04c892> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @04c897> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @04c89c> : 19                         load.z32
	<.main+3654 @04c89d> : 1f 30 5c 03 00             load.ref <@035c30> ;"val1"
	<.main+3659 @04c8a2> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+3664 @04c8a7> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @04c8ab> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@04c8af> - <@04c8d1>): debug(void("val2", val2));
	<.main+3672 @04c8af> : 1f 08 5c 03 00             load.ref <@035c08> ;"test/stdc/memory.ci"
	<.main+3677 @04c8b4> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @04c8b9> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @04c8be> : 19                         load.z32
	<.main+3688 @04c8bf> : 1f 35 5c 03 00             load.ref <@035c35> ;"val2"
	<.main+3693 @04c8c4> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+3698 @04c8c9> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @04c8cd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@04c8d1> - <@04c8e5>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @04c8d1> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @04c8d5> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @04c8d9> : 2a 50 04 00                load.m32 <@000450>
	<.main+3718 @04c8dd> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @04c8e1> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@04c8e5> - <@04c8f6>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @04c8e5> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @04c8e9> : 19                         load.z32
	<.main+3731 @04c8ea> : 2a 50 04 00                load.m32 <@000450>
	<.main+3735 @04c8ee> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @04c8f2> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@04c8f6> - <@04c918>): debug(void("val1", val1));
	<.main+3743 @04c8f6> : 1f 08 5c 03 00             load.ref <@035c08> ;"test/stdc/memory.ci"
	<.main+3748 @04c8fb> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @04c900> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @04c905> : 19                         load.z32
	<.main+3759 @04c906> : 1f 30 5c 03 00             load.ref <@035c30> ;"val1"
	<.main+3764 @04c90b> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+3769 @04c910> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @04c914> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@04c918> - <@04c93a>): debug(void("val2", val2));
	<.main+3777 @04c918> : 1f 08 5c 03 00             load.ref <@035c08> ;"test/stdc/memory.ci"
	<.main+3782 @04c91d> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @04c922> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @04c927> : 19                         load.z32
	<.main+3793 @04c928> : 1f 35 5c 03 00             load.ref <@035c35> ;"val2"
	<.main+3798 @04c92d> : 1f 38 04 00 00             load.ref <@000438> ;int64
	<.main+3803 @04c932> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @04c936> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@04c93a> - <@04c948>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @04c93a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @04c93f> : 1f 30 b8 04 00             load.ref <@04b830> ;noError(ptr: pointer): void
	<.main+3821 @04c944> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@04c948> - <@04c956>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @04c948> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @04c94d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @04c952> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@04c956> - <@04c964>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @04c956> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @04c95b> : 1f 38 b8 04 00             load.ref <@04b838> ;stackOverflow(ptr: pointer): void
	<.main+3849 @04c960> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@04c964> - <@04c972>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @04c964> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @04c969> : 1f 50 b8 04 00             load.ref <@04b850> ;divisionByZero(args: pointer): void
	<.main+3863 @04c96e> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@04c972> - <@04c980>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @04c972> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @04c977> : 1f b8 b8 04 00             load.ref <@04b8b8> ;invalidInstruction(args: pointer): void
	<.main+3877 @04c97c> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@04c980> - <@04c98e>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @04c980> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @04c985> : 1f a8 b8 04 00             load.ref <@04b8a8> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @04c98a> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@04c98e> - <@04c99c>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @04c98e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @04c993> : 1f 60 b8 04 00             load.ref <@04b860> ;abortExecution(args: pointer): void
	<.main+3905 @04c998> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@04c99c> - <@04c9a0>): arrFixedNoInit: int64[7]
	<.main+3909 @04c99c> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@04c9a0> - <@04c9a4>): arrArrayNoInit: int64[*]
	<.main+3913 @04c9a0> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@04c9a4> - <@04c9a8>): arrSliceNoInit: int64[]
	<.main+3917 @04c9a4> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@04c9a8> - <@04c9d5>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @04c9a8> : 19                         load.z32
	<.main+3922 @04c9a9> : 04 1c 00 00                jmp <.main+3950 @04c9c5>
	test/lang/array.ci:55: (20 bytes: <@04c9ad> - <@04c9c1>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @04c9ad> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @04c9b2> : 10 01                      dup.x1 sp(1)
	<.main+3933 @04c9b4> : 51                         add.i32
	<.main+3934 @04c9b5> : 5c                         i32.2i64
	<.main+3935 @04c9b6> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @04c9ba> : 10 03                      dup.x1 sp(3)
	<.main+3941 @04c9bc> : 0d 08 00 00                mad.u32 8
	<.main+3945 @04c9c0> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@04c9c1> - <@04c9c5>): int32(i := int32(i + 1))
	<.main+3946 @04c9c1> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@04c9c5> - <@04c9d1>): bool(i < arrFixedNoInit.length)
	<.main+3950 @04c9c5> : 10 00                      dup.x1 sp(0)
	<.main+3952 @04c9c7> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @04c9cc> : 58                         clt.i32
	<.main+3958 @04c9cd> : 05 e0 ff ff                jnz <.main+3926 @04c9ad>
	<.main+3962 @04c9d1> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@04c9d5> - <@04c9da>): arrArrayInitNull: int64[*] := null
	<.main+3966 @04c9d5> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@04c9da> - <@04c9e0>): arrSliceInitNull: int64[] := null
	<.main+3971 @04c9da> : 19                         load.z32
	<.main+3972 @04c9db> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@04c9e0> - <@04c9e4>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @04c9e0> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@04c9e4> - <@04c9ed>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @04c9e4> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @04c9e9> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@04c9ed> - <@04c9ef>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @04c9ed> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@04c9ef> - <@04c9f1>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @04c9ef> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@04c9f1> - <@04c9f3>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @04c9f1> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@04c9f3> - <@04c9f7>): strFixed: char[7]
	<.main+3996 @04c9f3> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@04c9f7> - <@04ca0d>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @04c9f7> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @04c9fb> : 1f 44 78 02 00             load.ref <@027844> ;"string"
	<.main+4009 @04ca00> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @04ca05> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @04ca09> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@04ca0d> - <@04ca2f>): debug(void("string as variant", strFixed));
	<.main+4022 @04ca0d> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4027 @04ca12> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @04ca17> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @04ca1c> : 19                         load.z32
	<.main+4038 @04ca1d> : 1f b3 7b 03 00             load.ref <@037bb3> ;"string as variant"
	<.main+4043 @04ca22> : 1f 08 89 03 00             load.ref <@038908>
	<.main+4048 @04ca27> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @04ca2b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@04ca2f> - <@04ca51>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @04ca2f> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4061 @04ca34> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @04ca39> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @04ca3e> : 19                         load.z32
	<.main+4072 @04ca3f> : 1f c5 7b 03 00             load.ref <@037bc5> ;"string to variant"
	<.main+4077 @04ca44> : 1f 08 89 03 00             load.ref <@038908>
	<.main+4082 @04ca49> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @04ca4d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@04ca51> - <@04ca56>): strArray: char[*] := "string"
	<.main+4090 @04ca51> : 1f 44 78 02 00             load.ref <@027844> ;"string"
	test/lang/array.ci:87: (32 bytes: <@04ca56> - <@04ca76>): debug(void("string as variant", strArray));
	<.main+4095 @04ca56> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4100 @04ca5b> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @04ca60> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @04ca65> : 19                         load.z32
	<.main+4111 @04ca66> : 1f b3 7b 03 00             load.ref <@037bb3> ;"string as variant"
	<.main+4116 @04ca6b> : 1f b8 8a 03 00             load.ref <@038ab8>
	<.main+4121 @04ca70> : 10 06                      dup.x1 sp(6)
	<.main+4123 @04ca72> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@04ca76> - <@04ca96>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @04ca76> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4132 @04ca7b> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @04ca80> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @04ca85> : 19                         load.z32
	<.main+4143 @04ca86> : 1f c5 7b 03 00             load.ref <@037bc5> ;"string to variant"
	<.main+4148 @04ca8b> : 1f b8 8a 03 00             load.ref <@038ab8>
	<.main+4153 @04ca90> : 10 06                      dup.x1 sp(6)
	<.main+4155 @04ca92> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@04ca96> - <@04caa0>): strSlice: char[] := "string"
	<.main+4159 @04ca96> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @04ca9b> : 1f 44 78 02 00             load.ref <@027844> ;"string"
	test/lang/array.ci:91: (32 bytes: <@04caa0> - <@04cac0>): debug(void("string as variant", strSlice));
	<.main+4169 @04caa0> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4174 @04caa5> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @04caaa> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @04caaf> : 19                         load.z32
	<.main+4185 @04cab0> : 1f b3 7b 03 00             load.ref <@037bb3> ;"string as variant"
	<.main+4190 @04cab5> : 1f d8 8b 03 00             load.ref <@038bd8>
	<.main+4195 @04caba> : 10 06                      dup.x1 sp(6)
	<.main+4197 @04cabc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@04cac0> - <@04cae0>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @04cac0> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4206 @04cac5> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @04caca> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @04cacf> : 19                         load.z32
	<.main+4217 @04cad0> : 1f c5 7b 03 00             load.ref <@037bc5> ;"string to variant"
	<.main+4222 @04cad5> : 1f d8 8b 03 00             load.ref <@038bd8>
	<.main+4227 @04cada> : 10 06                      dup.x1 sp(6)
	<.main+4229 @04cadc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@04cae0> - <@04cb13>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @04cae0> : 10 10                      dup.x1 sp(16)
	<.main+4235 @04cae2> : 19                         load.z32
	<.main+4236 @04cae3> : 38                         clt.u32
	<.main+4237 @04cae4> : 05 08 00 00                jnz <.main+4245 @04caec>
	<.main+4241 @04cae8> : 04 2b 00 00                jmp <.main+4284 @04cb13>
	<.main+4245 @04caec> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4250 @04caf1> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @04caf6> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @04cafb> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @04cb00> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4270 @04cb05> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4275 @04cb0a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @04cb0f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@04cb13> - <@04cb46>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @04cb13> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @04cb15> : 19                         load.z32
	<.main+4287 @04cb16> : 57                         ceq.i32
	<.main+4288 @04cb17> : 06 08 00 00                jz <.main+4296 @04cb1f>
	<.main+4292 @04cb1b> : 04 2b 00 00                jmp <.main+4335 @04cb46>
	<.main+4296 @04cb1f> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4301 @04cb24> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @04cb29> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @04cb2e> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @04cb33> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4321 @04cb38> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4326 @04cb3d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @04cb42> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@04cb46> - <@04cb81>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @04cb46> : 11 12                      dup.x2 sp(18)
	<.main+4337 @04cb48> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @04cb51> : 67                         ceq.i64
	<.main+4347 @04cb52> : 06 08 00 00                jz <.main+4355 @04cb5a>
	<.main+4351 @04cb56> : 04 2b 00 00                jmp <.main+4394 @04cb81>
	<.main+4355 @04cb5a> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4360 @04cb5f> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @04cb64> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @04cb69> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @04cb6e> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4380 @04cb73> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4385 @04cb78> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @04cb7d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@04cb81> - <@04cb9a>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @04cb81> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @04cb86> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @04cb8b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @04cb90> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @04cb95> : 02                         call
	<.main+4415 @04cb96> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@04cb9a> - <@04cbb0>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @04cb9a> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @04cb9f> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @04cba1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @04cba6> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @04cbab> : 02                         call
	<.main+4437 @04cbac> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@04cbb0> - <@04cbc6>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @04cbb0> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @04cbb5> : 10 08                      dup.x1 sp(8)
	<.main+4448 @04cbb7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @04cbbc> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @04cbc1> : 02                         call
	<.main+4459 @04cbc2> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@04cbc6> - <@04cbe6>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @04cbc6> : 19                         load.z32
	<.main+4464 @04cbc7> : 1a                         load.z64
	<.main+4465 @04cbc8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @04cbcd> : 1f c0 b8 04 00             load.ref <@04b8c0> ;lenSlice(values: int64[]): int32
	<.main+4475 @04cbd2> : 02                         call
	<.main+4476 @04cbd3> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @04cbd7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @04cbdc> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @04cbe1> : 02                         call
	<.main+4491 @04cbe2> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@04cbe6> - <@04cc03>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @04cbe6> : 19                         load.z32
	<.main+4496 @04cbe7> : 19                         load.z32
	<.main+4497 @04cbe8> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @04cbea> : 1f c0 b8 04 00             load.ref <@04b8c0> ;lenSlice(values: int64[]): int32
	<.main+4504 @04cbef> : 02                         call
	<.main+4505 @04cbf0> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @04cbf4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @04cbf9> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @04cbfe> : 02                         call
	<.main+4520 @04cbff> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@04cc03> - <@04cc2b>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @04cc03> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @04cc08> : 19                         load.z32
	<.main+4530 @04cc09> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @04cc0e> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @04cc12> : 1f c0 b8 04 00             load.ref <@04b8c0> ;lenSlice(values: int64[]): int32
	<.main+4544 @04cc17> : 02                         call
	<.main+4545 @04cc18> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @04cc1c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @04cc21> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @04cc26> : 02                         call
	<.main+4560 @04cc27> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@04cc2b> - <@04cc4c>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @04cc2b> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @04cc30> : 19                         load.z32
	<.main+4570 @04cc31> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @04cc33> : 1f c0 b8 04 00             load.ref <@04b8c0> ;lenSlice(values: int64[]): int32
	<.main+4577 @04cc38> : 02                         call
	<.main+4578 @04cc39> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @04cc3d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @04cc42> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @04cc47> : 02                         call
	<.main+4593 @04cc48> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@04cc4c> - <@04cc6d>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @04cc4c> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @04cc51> : 19                         load.z32
	<.main+4603 @04cc52> : 11 08                      dup.x2 sp(8)
	<.main+4605 @04cc54> : 1f c0 b8 04 00             load.ref <@04b8c0> ;lenSlice(values: int64[]): int32
	<.main+4610 @04cc59> : 02                         call
	<.main+4611 @04cc5a> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @04cc5e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @04cc63> : 1f b8 a6 04 00             load.ref <@04a6b8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @04cc68> : 02                         call
	<.main+4626 @04cc69> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@04cc6d> - <@04cf94>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @04cc6d> : 19                         load.z32
	<.main+4631 @04cc6e> : 04 16 03 00                jmp <.main+5421 @04cf84>
	test/lang/array.ci:119: (9 bytes: <@04cc72> - <@04cc7b>): expected: int64 := int32(42 + i)
	<.main+4635 @04cc72> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @04cc77> : 10 01                      dup.x1 sp(1)
	<.main+4642 @04cc79> : 51                         add.i32
	<.main+4643 @04cc7a> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@04cc7b> - <@04ccb8>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @04cc7b> : 11 00                      dup.x2 sp(0)
	<.main+4646 @04cc7d> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @04cc81> : 10 05                      dup.x1 sp(5)
	<.main+4652 @04cc83> : 0d 08 00 00                mad.u32 8
	<.main+4656 @04cc87> : 23                         load.i64
	<.main+4657 @04cc88> : 67                         ceq.i64
	<.main+4658 @04cc89> : 06 08 00 00                jz <.main+4666 @04cc91>
	<.main+4662 @04cc8d> : 04 2b 00 00                jmp <.main+4705 @04ccb8>
	<.main+4666 @04cc91> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4671 @04cc96> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @04cc9b> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @04cca0> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @04cca5> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4691 @04ccaa> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4696 @04ccaf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @04ccb4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@04ccb8> - <@04ccf3>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @04ccb8> : 11 00                      dup.x2 sp(0)
	<.main+4707 @04ccba> : 10 10                      dup.x1 sp(16)
	<.main+4709 @04ccbc> : 10 05                      dup.x1 sp(5)
	<.main+4711 @04ccbe> : 0d 08 00 00                mad.u32 8
	<.main+4715 @04ccc2> : 23                         load.i64
	<.main+4716 @04ccc3> : 67                         ceq.i64
	<.main+4717 @04ccc4> : 06 08 00 00                jz <.main+4725 @04cccc>
	<.main+4721 @04ccc8> : 04 2b 00 00                jmp <.main+4764 @04ccf3>
	<.main+4725 @04cccc> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4730 @04ccd1> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @04ccd6> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @04ccdb> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @04cce0> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4750 @04cce5> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4755 @04ccea> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @04ccef> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@04ccf3> - <@04cd2e>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @04ccf3> : 11 00                      dup.x2 sp(0)
	<.main+4766 @04ccf5> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @04ccf7> : 10 05                      dup.x1 sp(5)
	<.main+4770 @04ccf9> : 0d 08 00 00                mad.u32 8
	<.main+4774 @04ccfd> : 23                         load.i64
	<.main+4775 @04ccfe> : 67                         ceq.i64
	<.main+4776 @04ccff> : 06 08 00 00                jz <.main+4784 @04cd07>
	<.main+4780 @04cd03> : 04 2b 00 00                jmp <.main+4823 @04cd2e>
	<.main+4784 @04cd07> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4789 @04cd0c> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @04cd11> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @04cd16> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @04cd1b> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4809 @04cd20> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4814 @04cd25> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @04cd2a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@04cd2e> - <@04cd71>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @04cd2e> : 11 00                      dup.x2 sp(0)
	<.main+4825 @04cd30> : 1a                         load.z64
	<.main+4826 @04cd31> : 10 06                      dup.x1 sp(6)
	<.main+4828 @04cd33> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @04cd37> : 1f c8 b8 04 00             load.ref <@04b8c8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @04cd3c> : 02                         call
	<.main+4838 @04cd3d> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @04cd41> : 67                         ceq.i64
	<.main+4843 @04cd42> : 06 08 00 00                jz <.main+4851 @04cd4a>
	<.main+4847 @04cd46> : 04 2b 00 00                jmp <.main+4890 @04cd71>
	<.main+4851 @04cd4a> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4856 @04cd4f> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @04cd54> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @04cd59> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @04cd5e> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4876 @04cd63> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4881 @04cd68> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @04cd6d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@04cd71> - <@04cdb2>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @04cd71> : 11 00                      dup.x2 sp(0)
	<.main+4892 @04cd73> : 1a                         load.z64
	<.main+4893 @04cd74> : 10 06                      dup.x1 sp(6)
	<.main+4895 @04cd76> : 10 13                      dup.x1 sp(19)
	<.main+4897 @04cd78> : 1f c8 b8 04 00             load.ref <@04b8c8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @04cd7d> : 02                         call
	<.main+4903 @04cd7e> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @04cd82> : 67                         ceq.i64
	<.main+4908 @04cd83> : 06 08 00 00                jz <.main+4916 @04cd8b>
	<.main+4912 @04cd87> : 04 2b 00 00                jmp <.main+4955 @04cdb2>
	<.main+4916 @04cd8b> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4921 @04cd90> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @04cd95> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @04cd9a> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @04cd9f> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+4941 @04cda4> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+4946 @04cda9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @04cdae> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@04cdb2> - <@04cdf3>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @04cdb2> : 11 00                      dup.x2 sp(0)
	<.main+4957 @04cdb4> : 1a                         load.z64
	<.main+4958 @04cdb5> : 10 06                      dup.x1 sp(6)
	<.main+4960 @04cdb7> : 10 11                      dup.x1 sp(17)
	<.main+4962 @04cdb9> : 1f c8 b8 04 00             load.ref <@04b8c8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @04cdbe> : 02                         call
	<.main+4968 @04cdbf> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @04cdc3> : 67                         ceq.i64
	<.main+4973 @04cdc4> : 06 08 00 00                jz <.main+4981 @04cdcc>
	<.main+4977 @04cdc8> : 04 2b 00 00                jmp <.main+5020 @04cdf3>
	<.main+4981 @04cdcc> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+4986 @04cdd1> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @04cdd6> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @04cddb> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @04cde0> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5006 @04cde5> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5011 @04cdea> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @04cdef> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@04cdf3> - <@04ce36>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @04cdf3> : 11 00                      dup.x2 sp(0)
	<.main+5022 @04cdf5> : 1a                         load.z64
	<.main+5023 @04cdf6> : 10 06                      dup.x1 sp(6)
	<.main+5025 @04cdf8> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @04cdfc> : 1f d8 b8 04 00             load.ref <@04b8d8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @04ce01> : 02                         call
	<.main+5035 @04ce02> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @04ce06> : 67                         ceq.i64
	<.main+5040 @04ce07> : 06 08 00 00                jz <.main+5048 @04ce0f>
	<.main+5044 @04ce0b> : 04 2b 00 00                jmp <.main+5087 @04ce36>
	<.main+5048 @04ce0f> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5053 @04ce14> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @04ce19> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @04ce1e> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @04ce23> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5073 @04ce28> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5078 @04ce2d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @04ce32> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@04ce36> - <@04ce77>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @04ce36> : 11 00                      dup.x2 sp(0)
	<.main+5089 @04ce38> : 1a                         load.z64
	<.main+5090 @04ce39> : 10 06                      dup.x1 sp(6)
	<.main+5092 @04ce3b> : 10 13                      dup.x1 sp(19)
	<.main+5094 @04ce3d> : 1f d8 b8 04 00             load.ref <@04b8d8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @04ce42> : 02                         call
	<.main+5100 @04ce43> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @04ce47> : 67                         ceq.i64
	<.main+5105 @04ce48> : 06 08 00 00                jz <.main+5113 @04ce50>
	<.main+5109 @04ce4c> : 04 2b 00 00                jmp <.main+5152 @04ce77>
	<.main+5113 @04ce50> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5118 @04ce55> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @04ce5a> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @04ce5f> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @04ce64> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5138 @04ce69> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5143 @04ce6e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @04ce73> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@04ce77> - <@04ceb8>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @04ce77> : 11 00                      dup.x2 sp(0)
	<.main+5154 @04ce79> : 1a                         load.z64
	<.main+5155 @04ce7a> : 10 06                      dup.x1 sp(6)
	<.main+5157 @04ce7c> : 10 11                      dup.x1 sp(17)
	<.main+5159 @04ce7e> : 1f d8 b8 04 00             load.ref <@04b8d8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @04ce83> : 02                         call
	<.main+5165 @04ce84> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @04ce88> : 67                         ceq.i64
	<.main+5170 @04ce89> : 06 08 00 00                jz <.main+5178 @04ce91>
	<.main+5174 @04ce8d> : 04 2b 00 00                jmp <.main+5217 @04ceb8>
	<.main+5178 @04ce91> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5183 @04ce96> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @04ce9b> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @04cea0> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @04cea5> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5203 @04ceaa> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5208 @04ceaf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @04ceb4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@04ceb8> - <@04cf00>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @04ceb8> : 11 00                      dup.x2 sp(0)
	<.main+5219 @04ceba> : 1a                         load.z64
	<.main+5220 @04cebb> : 10 06                      dup.x1 sp(6)
	<.main+5222 @04cebd> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @04cec2> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @04cec6> : 1f e8 b8 04 00             load.ref <@04b8e8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @04cecb> : 02                         call
	<.main+5237 @04cecc> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @04ced0> : 67                         ceq.i64
	<.main+5242 @04ced1> : 06 08 00 00                jz <.main+5250 @04ced9>
	<.main+5246 @04ced5> : 04 2b 00 00                jmp <.main+5289 @04cf00>
	<.main+5250 @04ced9> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5255 @04cede> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @04cee3> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @04cee8> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @04ceed> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5275 @04cef2> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5280 @04cef7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @04cefc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@04cf00> - <@04cf41>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @04cf00> : 11 00                      dup.x2 sp(0)
	<.main+5291 @04cf02> : 1a                         load.z64
	<.main+5292 @04cf03> : 10 06                      dup.x1 sp(6)
	<.main+5294 @04cf05> : 11 11                      dup.x2 sp(17)
	<.main+5296 @04cf07> : 1f e8 b8 04 00             load.ref <@04b8e8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @04cf0c> : 02                         call
	<.main+5302 @04cf0d> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @04cf11> : 67                         ceq.i64
	<.main+5307 @04cf12> : 06 08 00 00                jz <.main+5315 @04cf1a>
	<.main+5311 @04cf16> : 04 2b 00 00                jmp <.main+5354 @04cf41>
	<.main+5315 @04cf1a> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5320 @04cf1f> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @04cf24> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @04cf29> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @04cf2e> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5340 @04cf33> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5345 @04cf38> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @04cf3d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@04cf41> - <@04cf7c>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @04cf41> : 11 00                      dup.x2 sp(0)
	<.main+5356 @04cf43> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @04cf45> : 10 05                      dup.x1 sp(5)
	<.main+5360 @04cf47> : 0d 08 00 00                mad.u32 8
	<.main+5364 @04cf4b> : 23                         load.i64
	<.main+5365 @04cf4c> : 67                         ceq.i64
	<.main+5366 @04cf4d> : 06 08 00 00                jz <.main+5374 @04cf55>
	<.main+5370 @04cf51> : 04 2b 00 00                jmp <.main+5413 @04cf7c>
	<.main+5374 @04cf55> : 1f f0 7a 03 00             load.ref <@037af0> ;"test/lang/array.ci"
	<.main+5379 @04cf5a> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @04cf5f> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @04cf64> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @04cf69> : 1f ba bf 00 00             load.ref <@00bfba> ;"assertion failed!"
	<.main+5399 @04cf6e> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+5404 @04cf73> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @04cf78> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @04cf7c> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@04cf80> - <@04cf84>): int32(i := int32(i + 1))
	<.main+5417 @04cf80> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@04cf84> - <@04cf90>): bool(i < arrFixedNoInit.length)
	<.main+5421 @04cf84> : 10 00                      dup.x1 sp(0)
	<.main+5423 @04cf86> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @04cf8b> : 58                         clt.i32
	<.main+5429 @04cf8c> : 05 e6 fc ff                jnz <.main+4635 @04cc72>
	<.main+5433 @04cf90> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@04cf94> - <@04cfd0>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @04cf94> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@04cf98> - <@04cf9f>): void(recordMemberTest.member := 10);
	<.main+5441 @04cf98> : 1c 0a 00 00 00             load.c32 10
	<.main+5446 @04cf9d> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@04cf9f> - <@04cfa6>): void(recordMemberTest.constant := 11);
	<.main+5448 @04cf9f> : 1c 0b 00 00 00             load.c32 11
	<.main+5453 @04cfa4> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@04cfa6> - <@04cfad>): void(recordMemberTest.memberInit := 12);
	<.main+5455 @04cfa6> : 1c 0c 00 00 00             load.c32 12
	<.main+5460 @04cfab> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@04cfad> - <@04cfb4>): void(recordMemberTest.constantInit := 13);
	<.main+5462 @04cfad> : 1c 0d 00 00 00             load.c32 13
	<.main+5467 @04cfb2> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@04cfb4> - <@04cfbb>): void(recordMemberTest.memberRec.member := 14);
	<.main+5469 @04cfb4> : 1c 0e 00 00 00             load.c32 14
	<.main+5474 @04cfb9> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@04cfbb> - <@04cfc2>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5476 @04cfbb> : 1c 0f 00 00 00             load.c32 15
	<.main+5481 @04cfc0> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@04cfc2> - <@04cfc9>): void(recordMemberTest.constantRec.member := 16);
	<.main+5483 @04cfc2> : 1c 10 00 00 00             load.c32 16
	<.main+5488 @04cfc7> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@04cfc9> - <@04cfd0>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5490 @04cfc9> : 1c 11 00 00 00             load.c32 17
	<.main+5495 @04cfce> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:44: (24 bytes: <@04cfd0> - <@04cfe8>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @04cfd0> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:46: (7 bytes: <@04cfd4> - <@04cfdb>): void(recordMethodTest.abstractMethod := globalFunction);
	<.main+5501 @04cfd4> : 1f a8 b9 04 00             load.ref <@04b9a8> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5506 @04cfd9> : 13 01                      set.x1 sp(1)
	:: (6 bytes: <@04cfdb> - <@04cfe1>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5508 @04cfdb> : 2a 50 b9 04                load.m32 <@04b950> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5512 @04cfdf> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@04cfe1> - <@04cfe8>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5514 @04cfe1> : 1f 58 b9 04 00             load.ref <@04b958> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5519 @04cfe6> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:58: (19 bytes: <@04cfe8> - <@04cffb>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+5521 @04cfe8> : 12 00                      dup.x4 sp(0)
	<.main+5523 @04cfea> : 1c 01 00 00 00             load.c32 1
	<.main+5528 @04cfef> : 13 04                      set.x1 sp(4)
	<.main+5530 @04cff1> : 1f 28 b9 04 00             load.ref <@04b928> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5535 @04cff6> : 02                         call
	<.main+5536 @04cff7> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:59: (16 bytes: <@04cffb> - <@04d00b>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+5540 @04cffb> : 12 00                      dup.x4 sp(0)
	<.main+5542 @04cffd> : 1c 01 00 00 00             load.c32 1
	<.main+5547 @04d002> : 13 04                      set.x1 sp(4)
	<.main+5549 @04d004> : 10 06                      dup.x1 sp(6)
	<.main+5551 @04d006> : 02                         call
	<.main+5552 @04d007> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:75: (17 bytes: <@04d00b> - <@04d01c>): staticMethod(void(recordMethodTest, 2));
	<.main+5556 @04d00b> : 12 00                      dup.x4 sp(0)
	<.main+5558 @04d00d> : 1c 02 00 00 00             load.c32 2
	<.main+5563 @04d012> : 1f d0 b9 04 00             load.ref <@04b9d0> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5568 @04d017> : 02                         call
	<.main+5569 @04d018> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:76: (17 bytes: <@04d01c> - <@04d02d>): virtualMethod(void(recordMethodTest, 2));
	<.main+5573 @04d01c> : 12 00                      dup.x4 sp(0)
	<.main+5575 @04d01e> : 1c 02 00 00 00             load.c32 2
	<.main+5580 @04d023> : 1f 18 ba 04 00             load.ref <@04ba18> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5585 @04d028> : 02                         call
	<.main+5586 @04d029> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:79: (19 bytes: <@04d02d> - <@04d040>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+5590 @04d02d> : 12 00                      dup.x4 sp(0)
	<.main+5592 @04d02f> : 1c 03 00 00 00             load.c32 3
	<.main+5597 @04d034> : 13 04                      set.x1 sp(4)
	<.main+5599 @04d036> : 1f 28 b9 04 00             load.ref <@04b928> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5604 @04d03b> : 02                         call
	<.main+5605 @04d03c> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:80: (19 bytes: <@04d040> - <@04d053>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5609 @04d040> : 12 00                      dup.x4 sp(0)
	<.main+5611 @04d042> : 1c 03 00 00 00             load.c32 3
	<.main+5616 @04d047> : 13 04                      set.x1 sp(4)
	<.main+5618 @04d049> : 1f 58 b9 04 00             load.ref <@04b958> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5623 @04d04e> : 02                         call
	<.main+5624 @04d04f> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:81: (16 bytes: <@04d053> - <@04d063>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5628 @04d053> : 12 00                      dup.x4 sp(0)
	<.main+5630 @04d055> : 1c 03 00 00 00             load.c32 3
	<.main+5635 @04d05a> : 13 04                      set.x1 sp(4)
	<.main+5637 @04d05c> : 10 06                      dup.x1 sp(6)
	<.main+5639 @04d05e> : 02                         call
	<.main+5640 @04d05f> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@04d063> - <@04d079>): black: rgbU8 := {...}
	<.main+5644 @04d063> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@04d067> - <@04d06d>): void(black.r := (0));
	<.main+5648 @04d067> : 19                         load.z32
	<.main+5649 @04d068> : 0a 06 00 00                load.sp(+6)
	<.main+5653 @04d06c> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@04d06d> - <@04d073>): void(black.g := (0));
	<.main+5654 @04d06d> : 19                         load.z32
	<.main+5655 @04d06e> : 0a 05 00 00                load.sp(+5)
	<.main+5659 @04d072> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@04d073> - <@04d079>): void(black.b := (0));
	<.main+5660 @04d073> : 19                         load.z32
	<.main+5661 @04d074> : 0a 04 00 00                load.sp(+4)
	<.main+5665 @04d078> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@04d079> - <@04d093>): green: rgbU8 := {...}
	<.main+5666 @04d079> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@04d07d> - <@04d083>): void(green.r := (0));
	<.main+5670 @04d07d> : 19                         load.z32
	<.main+5671 @04d07e> : 0a 06 00 00                load.sp(+6)
	<.main+5675 @04d082> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@04d083> - <@04d08d>): void(green.g := (255));
	<.main+5676 @04d083> : 1c ff 00 00 00             load.c32 255
	<.main+5681 @04d088> : 0a 05 00 00                load.sp(+5)
	<.main+5685 @04d08c> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@04d08d> - <@04d093>): void(green.b := (0));
	<.main+5686 @04d08d> : 19                         load.z32
	<.main+5687 @04d08e> : 0a 04 00 00                load.sp(+4)
	<.main+5691 @04d092> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@04d093> - <@04d0b5>): white: rgbU8 := {...}
	<.main+5692 @04d093> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@04d097> - <@04d0a1>): void(white.r := (255));
	<.main+5696 @04d097> : 1c ff 00 00 00             load.c32 255
	<.main+5701 @04d09c> : 0a 06 00 00                load.sp(+6)
	<.main+5705 @04d0a0> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@04d0a1> - <@04d0ab>): void(white.g := (255));
	<.main+5706 @04d0a1> : 1c ff 00 00 00             load.c32 255
	<.main+5711 @04d0a6> : 0a 05 00 00                load.sp(+5)
	<.main+5715 @04d0aa> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@04d0ab> - <@04d0b5>): void(white.b := (255));
	<.main+5716 @04d0ab> : 1c ff 00 00 00             load.c32 255
	<.main+5721 @04d0b0> : 0a 04 00 00                load.sp(+4)
	<.main+5725 @04d0b4> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@04d0b5> - <@04d0c0>): cyan: color := {...}
	<.main+5726 @04d0b5> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@04d0b9> - <@04d0c0>): void(cyan.col := (65535));
	<.main+5730 @04d0b9> : 1c ff ff 00 00             load.c32 65535
	<.main+5735 @04d0be> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@04d0c0> - <@04d0da>): blue: color := {...}
	<.main+5737 @04d0c0> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@04d0c4> - <@04d0ca>): void(blue.rgb.r := (0));
	<.main+5741 @04d0c4> : 19                         load.z32
	<.main+5742 @04d0c5> : 0a 06 00 00                load.sp(+6)
	<.main+5746 @04d0c9> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@04d0ca> - <@04d0d0>): void(blue.rgb.g := (0));
	<.main+5747 @04d0ca> : 19                         load.z32
	<.main+5748 @04d0cb> : 0a 05 00 00                load.sp(+5)
	<.main+5752 @04d0cf> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@04d0d0> - <@04d0da>): void(blue.rgb.b := (255));
	<.main+5753 @04d0d0> : 1c ff 00 00 00             load.c32 255
	<.main+5758 @04d0d5> : 0a 04 00 00                load.sp(+4)
	<.main+5762 @04d0d9> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@04d0da> - <@04d0df>): shift: int32 := 2
	<.main+5763 @04d0da> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@04d0df> - <@04d0e4>): boolA: bool := true
	<.main+5768 @04d0df> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@04d0e4> - <@04d0e9>): boolB: bool := bool(!false)
	<.main+5773 @04d0e4> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@04d0e9> - <@04d0f4>): boolAnd: bool := bool(boolA & boolB)
	<.main+5778 @04d0e9> : 0a 04 00 00                load.sp(+4)
	<.main+5782 @04d0ed> : 20                         load.i8
	<.main+5783 @04d0ee> : 0a 04 00 00                load.sp(+4)
	<.main+5787 @04d0f2> : 20                         load.i8
	<.main+5788 @04d0f3> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@04d0f4> - <@04d0ff>): boolIor: bool := bool(boolA | boolB)
	<.main+5789 @04d0f4> : 0a 08 00 00                load.sp(+8)
	<.main+5793 @04d0f8> : 20                         load.i8
	<.main+5794 @04d0f9> : 0a 08 00 00                load.sp(+8)
	<.main+5798 @04d0fd> : 20                         load.i8
	<.main+5799 @04d0fe> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@04d0ff> - <@04d10a>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5800 @04d0ff> : 0a 0c 00 00                load.sp(+12)
	<.main+5804 @04d103> : 20                         load.i8
	<.main+5805 @04d104> : 0a 0c 00 00                load.sp(+12)
	<.main+5809 @04d108> : 20                         load.i8
	<.main+5810 @04d109> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@04d10a> - <@04d110>): boolNot: bool := bool(!boolB)
	<.main+5811 @04d10a> : 0a 0c 00 00                load.sp(+12)
	<.main+5815 @04d10e> : 20                         load.i8
	<.main+5816 @04d10f> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@04d110> - <@04d11b>): boolCeq: bool := bool(boolA == boolB)
	<.main+5817 @04d110> : 0a 14 00 00                load.sp(+20)
	<.main+5821 @04d114> : 20                         load.i8
	<.main+5822 @04d115> : 0a 14 00 00                load.sp(+20)
	<.main+5826 @04d119> : 20                         load.i8
	<.main+5827 @04d11a> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@04d11b> - <@04d127>): boolCne: bool := bool(boolA != boolB)
	<.main+5828 @04d11b> : 0a 18 00 00                load.sp(+24)
	<.main+5832 @04d11f> : 20                         load.i8
	<.main+5833 @04d120> : 0a 18 00 00                load.sp(+24)
	<.main+5837 @04d124> : 20                         load.i8
	<.main+5838 @04d125> : 57                         ceq.i32
	<.main+5839 @04d126> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@04d127> - <@04d132>): boolClt: bool := bool(boolA < boolB)
	<.main+5840 @04d127> : 0a 1c 00 00                load.sp(+28)
	<.main+5844 @04d12b> : 20                         load.i8
	<.main+5845 @04d12c> : 0a 1c 00 00                load.sp(+28)
	<.main+5849 @04d130> : 20                         load.i8
	<.main+5850 @04d131> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@04d132> - <@04d13e>): boolCle: bool := bool(boolA <= boolB)
	<.main+5851 @04d132> : 0a 20 00 00                load.sp(+32)
	<.main+5855 @04d136> : 20                         load.i8
	<.main+5856 @04d137> : 0a 20 00 00                load.sp(+32)
	<.main+5860 @04d13b> : 20                         load.i8
	<.main+5861 @04d13c> : 59                         cgt.i32
	<.main+5862 @04d13d> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@04d13e> - <@04d149>): boolCgt: bool := bool(boolA > boolB)
	<.main+5863 @04d13e> : 0a 24 00 00                load.sp(+36)
	<.main+5867 @04d142> : 20                         load.i8
	<.main+5868 @04d143> : 0a 24 00 00                load.sp(+36)
	<.main+5872 @04d147> : 20                         load.i8
	<.main+5873 @04d148> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@04d149> - <@04d155>): boolCge: bool := bool(boolA >= boolB)
	<.main+5874 @04d149> : 0a 28 00 00                load.sp(+40)
	<.main+5878 @04d14d> : 20                         load.i8
	<.main+5879 @04d14e> : 0a 28 00 00                load.sp(+40)
	<.main+5883 @04d152> : 20                         load.i8
	<.main+5884 @04d153> : 58                         clt.i32
	<.main+5885 @04d154> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@04d155> - <@04d15a>): chrA: char := 'a'
	<.main+5886 @04d155> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@04d15a> - <@04d15f>): chrB: char := 'b'
	<.main+5891 @04d15a> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@04d15f> - <@04d164>): chrPls: char := char(+chrB)
	<.main+5896 @04d15f> : 0a 00 00 00                load.sp(+0)
	<.main+5900 @04d163> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@04d164> - <@04d16a>): chrNeg: char := char(-chrB)
	<.main+5901 @04d164> : 0a 04 00 00                load.sp(+4)
	<.main+5905 @04d168> : 20                         load.i8
	<.main+5906 @04d169> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@04d16a> - <@04d170>): chrCmt: char := char(~chrB)
	<.main+5907 @04d16a> : 0a 08 00 00                load.sp(+8)
	<.main+5911 @04d16e> : 20                         load.i8
	<.main+5912 @04d16f> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@04d170> - <@04d17b>): chrAdd: char := char(chrA + chrB)
	<.main+5913 @04d170> : 0a 10 00 00                load.sp(+16)
	<.main+5917 @04d174> : 20                         load.i8
	<.main+5918 @04d175> : 0a 10 00 00                load.sp(+16)
	<.main+5922 @04d179> : 20                         load.i8
	<.main+5923 @04d17a> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@04d17b> - <@04d186>): chrSub: char := char(chrA - chrB)
	<.main+5924 @04d17b> : 0a 14 00 00                load.sp(+20)
	<.main+5928 @04d17f> : 20                         load.i8
	<.main+5929 @04d180> : 0a 14 00 00                load.sp(+20)
	<.main+5933 @04d184> : 20                         load.i8
	<.main+5934 @04d185> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@04d186> - <@04d191>): chrMul: char := char(chrA * chrB)
	<.main+5935 @04d186> : 0a 18 00 00                load.sp(+24)
	<.main+5939 @04d18a> : 20                         load.i8
	<.main+5940 @04d18b> : 0a 18 00 00                load.sp(+24)
	<.main+5944 @04d18f> : 20                         load.i8
	<.main+5945 @04d190> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@04d191> - <@04d19c>): chrDiv: char := char(chrA / chrB)
	<.main+5946 @04d191> : 0a 1c 00 00                load.sp(+28)
	<.main+5950 @04d195> : 20                         load.i8
	<.main+5951 @04d196> : 0a 1c 00 00                load.sp(+28)
	<.main+5955 @04d19a> : 20                         load.i8
	<.main+5956 @04d19b> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@04d19c> - <@04d1a7>): chrMod: char := char(chrA % chrB)
	<.main+5957 @04d19c> : 0a 20 00 00                load.sp(+32)
	<.main+5961 @04d1a0> : 20                         load.i8
	<.main+5962 @04d1a1> : 0a 20 00 00                load.sp(+32)
	<.main+5966 @04d1a5> : 20                         load.i8
	<.main+5967 @04d1a6> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@04d1a7> - <@04d1b2>): chrAnd: char := char(chrA & chrB)
	<.main+5968 @04d1a7> : 0a 24 00 00                load.sp(+36)
	<.main+5972 @04d1ab> : 20                         load.i8
	<.main+5973 @04d1ac> : 0a 24 00 00                load.sp(+36)
	<.main+5977 @04d1b0> : 20                         load.i8
	<.main+5978 @04d1b1> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@04d1b2> - <@04d1bd>): chrIor: char := char(chrA | chrB)
	<.main+5979 @04d1b2> : 0a 28 00 00                load.sp(+40)
	<.main+5983 @04d1b6> : 20                         load.i8
	<.main+5984 @04d1b7> : 0a 28 00 00                load.sp(+40)
	<.main+5988 @04d1bb> : 20                         load.i8
	<.main+5989 @04d1bc> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@04d1bd> - <@04d1c8>): chrXor: char := char(chrA ^ chrB)
	<.main+5990 @04d1bd> : 0a 2c 00 00                load.sp(+44)
	<.main+5994 @04d1c1> : 20                         load.i8
	<.main+5995 @04d1c2> : 0a 2c 00 00                load.sp(+44)
	<.main+5999 @04d1c6> : 20                         load.i8
	<.main+6000 @04d1c7> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@04d1c8> - <@04d1d0>): chrShl: char := int32((chrA) << shift)
	<.main+6001 @04d1c8> : 0a 30 00 00                load.sp(+48)
	<.main+6005 @04d1cc> : 20                         load.i8
	<.main+6006 @04d1cd> : 10 1a                      dup.x1 sp(26)
	<.main+6008 @04d1cf> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@04d1d0> - <@04d1d8>): chrShr: char := int32((chrA) >> shift)
	<.main+6009 @04d1d0> : 0a 34 00 00                load.sp(+52)
	<.main+6013 @04d1d4> : 20                         load.i8
	<.main+6014 @04d1d5> : 10 1b                      dup.x1 sp(27)
	<.main+6016 @04d1d7> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@04d1d8> - <@04d1df>): chrNot: bool := bool(!(chrB))
	<.main+6017 @04d1d8> : 0a 34 00 00                load.sp(+52)
	<.main+6021 @04d1dc> : 20                         load.i8
	<.main+6022 @04d1dd> : 5a                         i32.2bool
	<.main+6023 @04d1de> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@04d1df> - <@04d1ea>): chrCeq: bool := bool(chrA == chrB)
	<.main+6024 @04d1df> : 0a 3c 00 00                load.sp(+60)
	<.main+6028 @04d1e3> : 20                         load.i8
	<.main+6029 @04d1e4> : 0a 3c 00 00                load.sp(+60)
	<.main+6033 @04d1e8> : 20                         load.i8
	<.main+6034 @04d1e9> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@04d1ea> - <@04d1f6>): chrCne: bool := bool(chrA != chrB)
	<.main+6035 @04d1ea> : 0a 40 00 00                load.sp(+64)
	<.main+6039 @04d1ee> : 20                         load.i8
	<.main+6040 @04d1ef> : 0a 40 00 00                load.sp(+64)
	<.main+6044 @04d1f3> : 20                         load.i8
	<.main+6045 @04d1f4> : 57                         ceq.i32
	<.main+6046 @04d1f5> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@04d1f6> - <@04d201>): chrClt: bool := bool(chrA < chrB)
	<.main+6047 @04d1f6> : 0a 44 00 00                load.sp(+68)
	<.main+6051 @04d1fa> : 20                         load.i8
	<.main+6052 @04d1fb> : 0a 44 00 00                load.sp(+68)
	<.main+6056 @04d1ff> : 20                         load.i8
	<.main+6057 @04d200> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@04d201> - <@04d20d>): chrCle: bool := bool(chrA <= chrB)
	<.main+6058 @04d201> : 0a 48 00 00                load.sp(+72)
	<.main+6062 @04d205> : 20                         load.i8
	<.main+6063 @04d206> : 0a 48 00 00                load.sp(+72)
	<.main+6067 @04d20a> : 20                         load.i8
	<.main+6068 @04d20b> : 59                         cgt.i32
	<.main+6069 @04d20c> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@04d20d> - <@04d218>): chrCgt: bool := bool(chrA > chrB)
	<.main+6070 @04d20d> : 0a 4c 00 00                load.sp(+76)
	<.main+6074 @04d211> : 20                         load.i8
	<.main+6075 @04d212> : 0a 4c 00 00                load.sp(+76)
	<.main+6079 @04d216> : 20                         load.i8
	<.main+6080 @04d217> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@04d218> - <@04d224>): chrCge: bool := bool(chrA >= chrB)
	<.main+6081 @04d218> : 0a 50 00 00                load.sp(+80)
	<.main+6085 @04d21c> : 20                         load.i8
	<.main+6086 @04d21d> : 0a 50 00 00                load.sp(+80)
	<.main+6090 @04d221> : 20                         load.i8
	<.main+6091 @04d222> : 58                         clt.i32
	<.main+6092 @04d223> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@04d224> - <@04d229>): i8A: int8 := a
	<.main+6093 @04d224> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@04d229> - <@04d22e>): i8B: int8 := b
	<.main+6098 @04d229> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@04d22e> - <@04d233>): i8Pls: int8 := int8(+i8B)
	<.main+6103 @04d22e> : 0a 00 00 00                load.sp(+0)
	<.main+6107 @04d232> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@04d233> - <@04d239>): i8Neg: int8 := int8(-i8B)
	<.main+6108 @04d233> : 0a 04 00 00                load.sp(+4)
	<.main+6112 @04d237> : 20                         load.i8
	<.main+6113 @04d238> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@04d239> - <@04d23f>): i8Cmt: int8 := int8(~i8B)
	<.main+6114 @04d239> : 0a 08 00 00                load.sp(+8)
	<.main+6118 @04d23d> : 20                         load.i8
	<.main+6119 @04d23e> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@04d23f> - <@04d24a>): i8Add: int8 := int8(i8A + i8B)
	<.main+6120 @04d23f> : 0a 10 00 00                load.sp(+16)
	<.main+6124 @04d243> : 20                         load.i8
	<.main+6125 @04d244> : 0a 10 00 00                load.sp(+16)
	<.main+6129 @04d248> : 20                         load.i8
	<.main+6130 @04d249> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@04d24a> - <@04d255>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6131 @04d24a> : 0a 14 00 00                load.sp(+20)
	<.main+6135 @04d24e> : 20                         load.i8
	<.main+6136 @04d24f> : 0a 14 00 00                load.sp(+20)
	<.main+6140 @04d253> : 20                         load.i8
	<.main+6141 @04d254> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@04d255> - <@04d260>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6142 @04d255> : 0a 18 00 00                load.sp(+24)
	<.main+6146 @04d259> : 20                         load.i8
	<.main+6147 @04d25a> : 0a 18 00 00                load.sp(+24)
	<.main+6151 @04d25e> : 20                         load.i8
	<.main+6152 @04d25f> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@04d260> - <@04d26b>): i8Div: int8 := int8(i8A / i8B)
	<.main+6153 @04d260> : 0a 1c 00 00                load.sp(+28)
	<.main+6157 @04d264> : 20                         load.i8
	<.main+6158 @04d265> : 0a 1c 00 00                load.sp(+28)
	<.main+6162 @04d269> : 20                         load.i8
	<.main+6163 @04d26a> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@04d26b> - <@04d276>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6164 @04d26b> : 0a 20 00 00                load.sp(+32)
	<.main+6168 @04d26f> : 20                         load.i8
	<.main+6169 @04d270> : 0a 20 00 00                load.sp(+32)
	<.main+6173 @04d274> : 20                         load.i8
	<.main+6174 @04d275> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@04d276> - <@04d281>): i8And: int8 := int8(i8A & i8B)
	<.main+6175 @04d276> : 0a 24 00 00                load.sp(+36)
	<.main+6179 @04d27a> : 20                         load.i8
	<.main+6180 @04d27b> : 0a 24 00 00                load.sp(+36)
	<.main+6184 @04d27f> : 20                         load.i8
	<.main+6185 @04d280> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@04d281> - <@04d28c>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6186 @04d281> : 0a 28 00 00                load.sp(+40)
	<.main+6190 @04d285> : 20                         load.i8
	<.main+6191 @04d286> : 0a 28 00 00                load.sp(+40)
	<.main+6195 @04d28a> : 20                         load.i8
	<.main+6196 @04d28b> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@04d28c> - <@04d297>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6197 @04d28c> : 0a 2c 00 00                load.sp(+44)
	<.main+6201 @04d290> : 20                         load.i8
	<.main+6202 @04d291> : 0a 2c 00 00                load.sp(+44)
	<.main+6206 @04d295> : 20                         load.i8
	<.main+6207 @04d296> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@04d297> - <@04d29f>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6208 @04d297> : 0a 30 00 00                load.sp(+48)
	<.main+6212 @04d29b> : 20                         load.i8
	<.main+6213 @04d29c> : 10 30                      dup.x1 sp(48)
	<.main+6215 @04d29e> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@04d29f> - <@04d2a7>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6216 @04d29f> : 0a 34 00 00                load.sp(+52)
	<.main+6220 @04d2a3> : 20                         load.i8
	<.main+6221 @04d2a4> : 10 31                      dup.x1 sp(49)
	<.main+6223 @04d2a6> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@04d2a7> - <@04d2ae>): i8Not: bool := bool(!(i8B))
	<.main+6224 @04d2a7> : 0a 34 00 00                load.sp(+52)
	<.main+6228 @04d2ab> : 20                         load.i8
	<.main+6229 @04d2ac> : 5a                         i32.2bool
	<.main+6230 @04d2ad> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@04d2ae> - <@04d2b9>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6231 @04d2ae> : 0a 3c 00 00                load.sp(+60)
	<.main+6235 @04d2b2> : 20                         load.i8
	<.main+6236 @04d2b3> : 0a 3c 00 00                load.sp(+60)
	<.main+6240 @04d2b7> : 20                         load.i8
	<.main+6241 @04d2b8> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@04d2b9> - <@04d2c5>): i8Cne: bool := bool(i8A != i8B)
	<.main+6242 @04d2b9> : 0a 40 00 00                load.sp(+64)
	<.main+6246 @04d2bd> : 20                         load.i8
	<.main+6247 @04d2be> : 0a 40 00 00                load.sp(+64)
	<.main+6251 @04d2c2> : 20                         load.i8
	<.main+6252 @04d2c3> : 57                         ceq.i32
	<.main+6253 @04d2c4> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@04d2c5> - <@04d2d0>): i8Clt: bool := bool(i8A < i8B)
	<.main+6254 @04d2c5> : 0a 44 00 00                load.sp(+68)
	<.main+6258 @04d2c9> : 20                         load.i8
	<.main+6259 @04d2ca> : 0a 44 00 00                load.sp(+68)
	<.main+6263 @04d2ce> : 20                         load.i8
	<.main+6264 @04d2cf> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@04d2d0> - <@04d2dc>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6265 @04d2d0> : 0a 48 00 00                load.sp(+72)
	<.main+6269 @04d2d4> : 20                         load.i8
	<.main+6270 @04d2d5> : 0a 48 00 00                load.sp(+72)
	<.main+6274 @04d2d9> : 20                         load.i8
	<.main+6275 @04d2da> : 59                         cgt.i32
	<.main+6276 @04d2db> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@04d2dc> - <@04d2e7>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6277 @04d2dc> : 0a 4c 00 00                load.sp(+76)
	<.main+6281 @04d2e0> : 20                         load.i8
	<.main+6282 @04d2e1> : 0a 4c 00 00                load.sp(+76)
	<.main+6286 @04d2e5> : 20                         load.i8
	<.main+6287 @04d2e6> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@04d2e7> - <@04d2f3>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6288 @04d2e7> : 0a 50 00 00                load.sp(+80)
	<.main+6292 @04d2eb> : 20                         load.i8
	<.main+6293 @04d2ec> : 0a 50 00 00                load.sp(+80)
	<.main+6297 @04d2f0> : 20                         load.i8
	<.main+6298 @04d2f1> : 58                         clt.i32
	<.main+6299 @04d2f2> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@04d2f3> - <@04d2f8>): u8A: uint8 := a
	<.main+6300 @04d2f3> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@04d2f8> - <@04d2fd>): u8B: uint8 := b
	<.main+6305 @04d2f8> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@04d2fd> - <@04d302>): u8Pls: uint8 := uint8(+u8B)
	<.main+6310 @04d2fd> : 0a 00 00 00                load.sp(+0)
	<.main+6314 @04d301> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@04d302> - <@04d308>): u8Neg: uint8 := uint8(-u8B)
	<.main+6315 @04d302> : 0a 04 00 00                load.sp(+4)
	<.main+6319 @04d306> : 20                         load.i8
	<.main+6320 @04d307> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@04d308> - <@04d30e>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6321 @04d308> : 0a 08 00 00                load.sp(+8)
	<.main+6325 @04d30c> : 20                         load.i8
	<.main+6326 @04d30d> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@04d30e> - <@04d319>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6327 @04d30e> : 0a 10 00 00                load.sp(+16)
	<.main+6331 @04d312> : 20                         load.i8
	<.main+6332 @04d313> : 0a 10 00 00                load.sp(+16)
	<.main+6336 @04d317> : 20                         load.i8
	<.main+6337 @04d318> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@04d319> - <@04d324>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6338 @04d319> : 0a 14 00 00                load.sp(+20)
	<.main+6342 @04d31d> : 20                         load.i8
	<.main+6343 @04d31e> : 0a 14 00 00                load.sp(+20)
	<.main+6347 @04d322> : 20                         load.i8
	<.main+6348 @04d323> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@04d324> - <@04d32f>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6349 @04d324> : 0a 18 00 00                load.sp(+24)
	<.main+6353 @04d328> : 20                         load.i8
	<.main+6354 @04d329> : 0a 18 00 00                load.sp(+24)
	<.main+6358 @04d32d> : 20                         load.i8
	<.main+6359 @04d32e> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@04d32f> - <@04d33a>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6360 @04d32f> : 0a 1c 00 00                load.sp(+28)
	<.main+6364 @04d333> : 20                         load.i8
	<.main+6365 @04d334> : 0a 1c 00 00                load.sp(+28)
	<.main+6369 @04d338> : 20                         load.i8
	<.main+6370 @04d339> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@04d33a> - <@04d345>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6371 @04d33a> : 0a 20 00 00                load.sp(+32)
	<.main+6375 @04d33e> : 20                         load.i8
	<.main+6376 @04d33f> : 0a 20 00 00                load.sp(+32)
	<.main+6380 @04d343> : 20                         load.i8
	<.main+6381 @04d344> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@04d345> - <@04d350>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6382 @04d345> : 0a 24 00 00                load.sp(+36)
	<.main+6386 @04d349> : 20                         load.i8
	<.main+6387 @04d34a> : 0a 24 00 00                load.sp(+36)
	<.main+6391 @04d34e> : 20                         load.i8
	<.main+6392 @04d34f> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@04d350> - <@04d35b>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6393 @04d350> : 0a 28 00 00                load.sp(+40)
	<.main+6397 @04d354> : 20                         load.i8
	<.main+6398 @04d355> : 0a 28 00 00                load.sp(+40)
	<.main+6402 @04d359> : 20                         load.i8
	<.main+6403 @04d35a> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@04d35b> - <@04d366>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6404 @04d35b> : 0a 2c 00 00                load.sp(+44)
	<.main+6408 @04d35f> : 20                         load.i8
	<.main+6409 @04d360> : 0a 2c 00 00                load.sp(+44)
	<.main+6413 @04d364> : 20                         load.i8
	<.main+6414 @04d365> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@04d366> - <@04d36e>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6415 @04d366> : 0a 30 00 00                load.sp(+48)
	<.main+6419 @04d36a> : 20                         load.i8
	<.main+6420 @04d36b> : 10 46                      dup.x1 sp(70)
	<.main+6422 @04d36d> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@04d36e> - <@04d376>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6423 @04d36e> : 0a 34 00 00                load.sp(+52)
	<.main+6427 @04d372> : 20                         load.i8
	<.main+6428 @04d373> : 10 47                      dup.x1 sp(71)
	<.main+6430 @04d375> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@04d376> - <@04d37d>): u8Not: bool := bool(!(u8B))
	<.main+6431 @04d376> : 0a 34 00 00                load.sp(+52)
	<.main+6435 @04d37a> : 20                         load.i8
	<.main+6436 @04d37b> : 5a                         i32.2bool
	<.main+6437 @04d37c> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@04d37d> - <@04d388>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6438 @04d37d> : 0a 3c 00 00                load.sp(+60)
	<.main+6442 @04d381> : 20                         load.i8
	<.main+6443 @04d382> : 0a 3c 00 00                load.sp(+60)
	<.main+6447 @04d386> : 20                         load.i8
	<.main+6448 @04d387> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@04d388> - <@04d394>): u8Cne: bool := bool(u8A != u8B)
	<.main+6449 @04d388> : 0a 40 00 00                load.sp(+64)
	<.main+6453 @04d38c> : 20                         load.i8
	<.main+6454 @04d38d> : 0a 40 00 00                load.sp(+64)
	<.main+6458 @04d391> : 20                         load.i8
	<.main+6459 @04d392> : 57                         ceq.i32
	<.main+6460 @04d393> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@04d394> - <@04d39f>): u8Clt: bool := bool(u8A < u8B)
	<.main+6461 @04d394> : 0a 44 00 00                load.sp(+68)
	<.main+6465 @04d398> : 20                         load.i8
	<.main+6466 @04d399> : 0a 44 00 00                load.sp(+68)
	<.main+6470 @04d39d> : 20                         load.i8
	<.main+6471 @04d39e> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@04d39f> - <@04d3ab>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6472 @04d39f> : 0a 48 00 00                load.sp(+72)
	<.main+6476 @04d3a3> : 20                         load.i8
	<.main+6477 @04d3a4> : 0a 48 00 00                load.sp(+72)
	<.main+6481 @04d3a8> : 20                         load.i8
	<.main+6482 @04d3a9> : 39                         cgt.u32
	<.main+6483 @04d3aa> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@04d3ab> - <@04d3b6>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6484 @04d3ab> : 0a 4c 00 00                load.sp(+76)
	<.main+6488 @04d3af> : 20                         load.i8
	<.main+6489 @04d3b0> : 0a 4c 00 00                load.sp(+76)
	<.main+6493 @04d3b4> : 20                         load.i8
	<.main+6494 @04d3b5> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@04d3b6> - <@04d3c2>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6495 @04d3b6> : 0a 50 00 00                load.sp(+80)
	<.main+6499 @04d3ba> : 20                         load.i8
	<.main+6500 @04d3bb> : 0a 50 00 00                load.sp(+80)
	<.main+6504 @04d3bf> : 20                         load.i8
	<.main+6505 @04d3c0> : 38                         clt.u32
	<.main+6506 @04d3c1> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@04d3c2> - <@04d3c7>): i16A: int16 := a
	<.main+6507 @04d3c2> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@04d3c7> - <@04d3cc>): i16B: int16 := b
	<.main+6512 @04d3c7> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@04d3cc> - <@04d3d1>): i16Pls: int16 := int16(+i16B)
	<.main+6517 @04d3cc> : 0a 00 00 00                load.sp(+0)
	<.main+6521 @04d3d0> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@04d3d1> - <@04d3d7>): i16Neg: int16 := int16(-i16B)
	<.main+6522 @04d3d1> : 0a 04 00 00                load.sp(+4)
	<.main+6526 @04d3d5> : 21                         load.i16
	<.main+6527 @04d3d6> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@04d3d7> - <@04d3dd>): i16Cmt: int16 := int16(~i16B)
	<.main+6528 @04d3d7> : 0a 08 00 00                load.sp(+8)
	<.main+6532 @04d3db> : 21                         load.i16
	<.main+6533 @04d3dc> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@04d3dd> - <@04d3e8>): i16Add: int16 := int16(i16A + i16B)
	<.main+6534 @04d3dd> : 0a 10 00 00                load.sp(+16)
	<.main+6538 @04d3e1> : 21                         load.i16
	<.main+6539 @04d3e2> : 0a 10 00 00                load.sp(+16)
	<.main+6543 @04d3e6> : 21                         load.i16
	<.main+6544 @04d3e7> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@04d3e8> - <@04d3f3>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6545 @04d3e8> : 0a 14 00 00                load.sp(+20)
	<.main+6549 @04d3ec> : 21                         load.i16
	<.main+6550 @04d3ed> : 0a 14 00 00                load.sp(+20)
	<.main+6554 @04d3f1> : 21                         load.i16
	<.main+6555 @04d3f2> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@04d3f3> - <@04d3fe>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6556 @04d3f3> : 0a 18 00 00                load.sp(+24)
	<.main+6560 @04d3f7> : 21                         load.i16
	<.main+6561 @04d3f8> : 0a 18 00 00                load.sp(+24)
	<.main+6565 @04d3fc> : 21                         load.i16
	<.main+6566 @04d3fd> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@04d3fe> - <@04d409>): i16Div: int16 := int16(i16A / i16B)
	<.main+6567 @04d3fe> : 0a 1c 00 00                load.sp(+28)
	<.main+6571 @04d402> : 21                         load.i16
	<.main+6572 @04d403> : 0a 1c 00 00                load.sp(+28)
	<.main+6576 @04d407> : 21                         load.i16
	<.main+6577 @04d408> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@04d409> - <@04d414>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6578 @04d409> : 0a 20 00 00                load.sp(+32)
	<.main+6582 @04d40d> : 21                         load.i16
	<.main+6583 @04d40e> : 0a 20 00 00                load.sp(+32)
	<.main+6587 @04d412> : 21                         load.i16
	<.main+6588 @04d413> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@04d414> - <@04d41f>): i16And: int16 := int16(i16A & i16B)
	<.main+6589 @04d414> : 0a 24 00 00                load.sp(+36)
	<.main+6593 @04d418> : 21                         load.i16
	<.main+6594 @04d419> : 0a 24 00 00                load.sp(+36)
	<.main+6598 @04d41d> : 21                         load.i16
	<.main+6599 @04d41e> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@04d41f> - <@04d42a>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6600 @04d41f> : 0a 28 00 00                load.sp(+40)
	<.main+6604 @04d423> : 21                         load.i16
	<.main+6605 @04d424> : 0a 28 00 00                load.sp(+40)
	<.main+6609 @04d428> : 21                         load.i16
	<.main+6610 @04d429> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@04d42a> - <@04d435>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6611 @04d42a> : 0a 2c 00 00                load.sp(+44)
	<.main+6615 @04d42e> : 21                         load.i16
	<.main+6616 @04d42f> : 0a 2c 00 00                load.sp(+44)
	<.main+6620 @04d433> : 21                         load.i16
	<.main+6621 @04d434> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@04d435> - <@04d43d>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6622 @04d435> : 0a 30 00 00                load.sp(+48)
	<.main+6626 @04d439> : 21                         load.i16
	<.main+6627 @04d43a> : 10 5c                      dup.x1 sp(92)
	<.main+6629 @04d43c> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@04d43d> - <@04d445>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6630 @04d43d> : 0a 34 00 00                load.sp(+52)
	<.main+6634 @04d441> : 21                         load.i16
	<.main+6635 @04d442> : 10 5d                      dup.x1 sp(93)
	<.main+6637 @04d444> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@04d445> - <@04d44c>): i16Not: bool := bool(!(i16B))
	<.main+6638 @04d445> : 0a 34 00 00                load.sp(+52)
	<.main+6642 @04d449> : 21                         load.i16
	<.main+6643 @04d44a> : 5a                         i32.2bool
	<.main+6644 @04d44b> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@04d44c> - <@04d457>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6645 @04d44c> : 0a 3c 00 00                load.sp(+60)
	<.main+6649 @04d450> : 21                         load.i16
	<.main+6650 @04d451> : 0a 3c 00 00                load.sp(+60)
	<.main+6654 @04d455> : 21                         load.i16
	<.main+6655 @04d456> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@04d457> - <@04d463>): i16Cne: bool := bool(i16A != i16B)
	<.main+6656 @04d457> : 0a 40 00 00                load.sp(+64)
	<.main+6660 @04d45b> : 21                         load.i16
	<.main+6661 @04d45c> : 0a 40 00 00                load.sp(+64)
	<.main+6665 @04d460> : 21                         load.i16
	<.main+6666 @04d461> : 57                         ceq.i32
	<.main+6667 @04d462> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@04d463> - <@04d46e>): i16Clt: bool := bool(i16A < i16B)
	<.main+6668 @04d463> : 0a 44 00 00                load.sp(+68)
	<.main+6672 @04d467> : 21                         load.i16
	<.main+6673 @04d468> : 0a 44 00 00                load.sp(+68)
	<.main+6677 @04d46c> : 21                         load.i16
	<.main+6678 @04d46d> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@04d46e> - <@04d47a>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6679 @04d46e> : 0a 48 00 00                load.sp(+72)
	<.main+6683 @04d472> : 21                         load.i16
	<.main+6684 @04d473> : 0a 48 00 00                load.sp(+72)
	<.main+6688 @04d477> : 21                         load.i16
	<.main+6689 @04d478> : 59                         cgt.i32
	<.main+6690 @04d479> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@04d47a> - <@04d485>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6691 @04d47a> : 0a 4c 00 00                load.sp(+76)
	<.main+6695 @04d47e> : 21                         load.i16
	<.main+6696 @04d47f> : 0a 4c 00 00                load.sp(+76)
	<.main+6700 @04d483> : 21                         load.i16
	<.main+6701 @04d484> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@04d485> - <@04d491>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6702 @04d485> : 0a 50 00 00                load.sp(+80)
	<.main+6706 @04d489> : 21                         load.i16
	<.main+6707 @04d48a> : 0a 50 00 00                load.sp(+80)
	<.main+6711 @04d48e> : 21                         load.i16
	<.main+6712 @04d48f> : 58                         clt.i32
	<.main+6713 @04d490> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@04d491> - <@04d496>): u16A: uint16 := a
	<.main+6714 @04d491> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@04d496> - <@04d49b>): u16B: uint16 := b
	<.main+6719 @04d496> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@04d49b> - <@04d4a0>): u16Pls: uint16 := uint16(+u16B)
	<.main+6724 @04d49b> : 0a 00 00 00                load.sp(+0)
	<.main+6728 @04d49f> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@04d4a0> - <@04d4a6>): u16Neg: uint16 := uint16(-u16B)
	<.main+6729 @04d4a0> : 0a 04 00 00                load.sp(+4)
	<.main+6733 @04d4a4> : 21                         load.i16
	<.main+6734 @04d4a5> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@04d4a6> - <@04d4ac>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6735 @04d4a6> : 0a 08 00 00                load.sp(+8)
	<.main+6739 @04d4aa> : 21                         load.i16
	<.main+6740 @04d4ab> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@04d4ac> - <@04d4b7>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6741 @04d4ac> : 0a 10 00 00                load.sp(+16)
	<.main+6745 @04d4b0> : 21                         load.i16
	<.main+6746 @04d4b1> : 0a 10 00 00                load.sp(+16)
	<.main+6750 @04d4b5> : 21                         load.i16
	<.main+6751 @04d4b6> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@04d4b7> - <@04d4c2>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6752 @04d4b7> : 0a 14 00 00                load.sp(+20)
	<.main+6756 @04d4bb> : 21                         load.i16
	<.main+6757 @04d4bc> : 0a 14 00 00                load.sp(+20)
	<.main+6761 @04d4c0> : 21                         load.i16
	<.main+6762 @04d4c1> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@04d4c2> - <@04d4cd>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6763 @04d4c2> : 0a 18 00 00                load.sp(+24)
	<.main+6767 @04d4c6> : 21                         load.i16
	<.main+6768 @04d4c7> : 0a 18 00 00                load.sp(+24)
	<.main+6772 @04d4cb> : 21                         load.i16
	<.main+6773 @04d4cc> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@04d4cd> - <@04d4d8>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6774 @04d4cd> : 0a 1c 00 00                load.sp(+28)
	<.main+6778 @04d4d1> : 21                         load.i16
	<.main+6779 @04d4d2> : 0a 1c 00 00                load.sp(+28)
	<.main+6783 @04d4d6> : 21                         load.i16
	<.main+6784 @04d4d7> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@04d4d8> - <@04d4e3>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6785 @04d4d8> : 0a 20 00 00                load.sp(+32)
	<.main+6789 @04d4dc> : 21                         load.i16
	<.main+6790 @04d4dd> : 0a 20 00 00                load.sp(+32)
	<.main+6794 @04d4e1> : 21                         load.i16
	<.main+6795 @04d4e2> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@04d4e3> - <@04d4ee>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6796 @04d4e3> : 0a 24 00 00                load.sp(+36)
	<.main+6800 @04d4e7> : 21                         load.i16
	<.main+6801 @04d4e8> : 0a 24 00 00                load.sp(+36)
	<.main+6805 @04d4ec> : 21                         load.i16
	<.main+6806 @04d4ed> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@04d4ee> - <@04d4f9>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6807 @04d4ee> : 0a 28 00 00                load.sp(+40)
	<.main+6811 @04d4f2> : 21                         load.i16
	<.main+6812 @04d4f3> : 0a 28 00 00                load.sp(+40)
	<.main+6816 @04d4f7> : 21                         load.i16
	<.main+6817 @04d4f8> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@04d4f9> - <@04d504>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6818 @04d4f9> : 0a 2c 00 00                load.sp(+44)
	<.main+6822 @04d4fd> : 21                         load.i16
	<.main+6823 @04d4fe> : 0a 2c 00 00                load.sp(+44)
	<.main+6827 @04d502> : 21                         load.i16
	<.main+6828 @04d503> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@04d504> - <@04d50c>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6829 @04d504> : 0a 30 00 00                load.sp(+48)
	<.main+6833 @04d508> : 21                         load.i16
	<.main+6834 @04d509> : 10 72                      dup.x1 sp(114)
	<.main+6836 @04d50b> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@04d50c> - <@04d514>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6837 @04d50c> : 0a 34 00 00                load.sp(+52)
	<.main+6841 @04d510> : 21                         load.i16
	<.main+6842 @04d511> : 10 73                      dup.x1 sp(115)
	<.main+6844 @04d513> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@04d514> - <@04d51b>): u16Not: bool := bool(!(u16B))
	<.main+6845 @04d514> : 0a 34 00 00                load.sp(+52)
	<.main+6849 @04d518> : 21                         load.i16
	<.main+6850 @04d519> : 5a                         i32.2bool
	<.main+6851 @04d51a> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@04d51b> - <@04d526>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6852 @04d51b> : 0a 3c 00 00                load.sp(+60)
	<.main+6856 @04d51f> : 21                         load.i16
	<.main+6857 @04d520> : 0a 3c 00 00                load.sp(+60)
	<.main+6861 @04d524> : 21                         load.i16
	<.main+6862 @04d525> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@04d526> - <@04d532>): u16Cne: bool := bool(u16A != u16B)
	<.main+6863 @04d526> : 0a 40 00 00                load.sp(+64)
	<.main+6867 @04d52a> : 21                         load.i16
	<.main+6868 @04d52b> : 0a 40 00 00                load.sp(+64)
	<.main+6872 @04d52f> : 21                         load.i16
	<.main+6873 @04d530> : 57                         ceq.i32
	<.main+6874 @04d531> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@04d532> - <@04d53d>): u16Clt: bool := bool(u16A < u16B)
	<.main+6875 @04d532> : 0a 44 00 00                load.sp(+68)
	<.main+6879 @04d536> : 21                         load.i16
	<.main+6880 @04d537> : 0a 44 00 00                load.sp(+68)
	<.main+6884 @04d53b> : 21                         load.i16
	<.main+6885 @04d53c> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@04d53d> - <@04d549>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6886 @04d53d> : 0a 48 00 00                load.sp(+72)
	<.main+6890 @04d541> : 21                         load.i16
	<.main+6891 @04d542> : 0a 48 00 00                load.sp(+72)
	<.main+6895 @04d546> : 21                         load.i16
	<.main+6896 @04d547> : 39                         cgt.u32
	<.main+6897 @04d548> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@04d549> - <@04d554>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6898 @04d549> : 0a 4c 00 00                load.sp(+76)
	<.main+6902 @04d54d> : 21                         load.i16
	<.main+6903 @04d54e> : 0a 4c 00 00                load.sp(+76)
	<.main+6907 @04d552> : 21                         load.i16
	<.main+6908 @04d553> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@04d554> - <@04d560>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6909 @04d554> : 0a 50 00 00                load.sp(+80)
	<.main+6913 @04d558> : 21                         load.i16
	<.main+6914 @04d559> : 0a 50 00 00                load.sp(+80)
	<.main+6918 @04d55d> : 21                         load.i16
	<.main+6919 @04d55e> : 38                         clt.u32
	<.main+6920 @04d55f> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@04d560> - <@04d565>): i32A: int32 := a
	<.main+6921 @04d560> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@04d565> - <@04d56a>): i32B: int32 := b
	<.main+6926 @04d565> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@04d56a> - <@04d56c>): i32Pls: int32 := int32(+i32B)
	<.main+6931 @04d56a> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@04d56c> - <@04d56f>): i32Neg: int32 := int32(-i32B)
	<.main+6933 @04d56c> : 10 01                      dup.x1 sp(1)
	<.main+6935 @04d56e> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@04d56f> - <@04d572>): i32Cmt: int32 := int32(~i32B)
	<.main+6936 @04d56f> : 10 02                      dup.x1 sp(2)
	<.main+6938 @04d571> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@04d572> - <@04d577>): i32Add: int32 := int32(i32A + i32B)
	<.main+6939 @04d572> : 10 04                      dup.x1 sp(4)
	<.main+6941 @04d574> : 10 04                      dup.x1 sp(4)
	<.main+6943 @04d576> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@04d577> - <@04d57c>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6944 @04d577> : 10 05                      dup.x1 sp(5)
	<.main+6946 @04d579> : 10 05                      dup.x1 sp(5)
	<.main+6948 @04d57b> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@04d57c> - <@04d581>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6949 @04d57c> : 10 06                      dup.x1 sp(6)
	<.main+6951 @04d57e> : 10 06                      dup.x1 sp(6)
	<.main+6953 @04d580> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@04d581> - <@04d586>): i32Div: int32 := int32(i32A / i32B)
	<.main+6954 @04d581> : 10 07                      dup.x1 sp(7)
	<.main+6956 @04d583> : 10 07                      dup.x1 sp(7)
	<.main+6958 @04d585> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@04d586> - <@04d58b>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6959 @04d586> : 10 08                      dup.x1 sp(8)
	<.main+6961 @04d588> : 10 08                      dup.x1 sp(8)
	<.main+6963 @04d58a> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@04d58b> - <@04d590>): i32And: int32 := int32(i32A & i32B)
	<.main+6964 @04d58b> : 10 09                      dup.x1 sp(9)
	<.main+6966 @04d58d> : 10 09                      dup.x1 sp(9)
	<.main+6968 @04d58f> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@04d590> - <@04d595>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6969 @04d590> : 10 0a                      dup.x1 sp(10)
	<.main+6971 @04d592> : 10 0a                      dup.x1 sp(10)
	<.main+6973 @04d594> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@04d595> - <@04d59a>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6974 @04d595> : 10 0b                      dup.x1 sp(11)
	<.main+6976 @04d597> : 10 0b                      dup.x1 sp(11)
	<.main+6978 @04d599> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@04d59a> - <@04d59f>): i32Shl: int32 := int32(i32A << shift)
	<.main+6979 @04d59a> : 10 0c                      dup.x1 sp(12)
	<.main+6981 @04d59c> : 10 88                      dup.x1 sp(136)
	<.main+6983 @04d59e> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@04d59f> - <@04d5a4>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6984 @04d59f> : 10 0d                      dup.x1 sp(13)
	<.main+6986 @04d5a1> : 10 89                      dup.x1 sp(137)
	<.main+6988 @04d5a3> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@04d5a4> - <@04d5a8>): i32Not: bool := bool(!(i32B))
	<.main+6989 @04d5a4> : 10 0d                      dup.x1 sp(13)
	<.main+6991 @04d5a6> : 5a                         i32.2bool
	<.main+6992 @04d5a7> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@04d5a8> - <@04d5ad>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6993 @04d5a8> : 10 0f                      dup.x1 sp(15)
	<.main+6995 @04d5aa> : 10 0f                      dup.x1 sp(15)
	<.main+6997 @04d5ac> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@04d5ad> - <@04d5b3>): i32Cne: bool := bool(i32A != i32B)
	<.main+6998 @04d5ad> : 10 10                      dup.x1 sp(16)
	<.main+7000 @04d5af> : 10 10                      dup.x1 sp(16)
	<.main+7002 @04d5b1> : 57                         ceq.i32
	<.main+7003 @04d5b2> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@04d5b3> - <@04d5b8>): i32Clt: bool := bool(i32A < i32B)
	<.main+7004 @04d5b3> : 10 11                      dup.x1 sp(17)
	<.main+7006 @04d5b5> : 10 11                      dup.x1 sp(17)
	<.main+7008 @04d5b7> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@04d5b8> - <@04d5be>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7009 @04d5b8> : 10 12                      dup.x1 sp(18)
	<.main+7011 @04d5ba> : 10 12                      dup.x1 sp(18)
	<.main+7013 @04d5bc> : 59                         cgt.i32
	<.main+7014 @04d5bd> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@04d5be> - <@04d5c3>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7015 @04d5be> : 10 13                      dup.x1 sp(19)
	<.main+7017 @04d5c0> : 10 13                      dup.x1 sp(19)
	<.main+7019 @04d5c2> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@04d5c3> - <@04d5c9>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7020 @04d5c3> : 10 14                      dup.x1 sp(20)
	<.main+7022 @04d5c5> : 10 14                      dup.x1 sp(20)
	<.main+7024 @04d5c7> : 58                         clt.i32
	<.main+7025 @04d5c8> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@04d5c9> - <@04d5ce>): u32A: uint32 := a
	<.main+7026 @04d5c9> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@04d5ce> - <@04d5d3>): u32B: uint32 := b
	<.main+7031 @04d5ce> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@04d5d3> - <@04d5d5>): u32Pls: uint32 := uint32(+u32B)
	<.main+7036 @04d5d3> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@04d5d5> - <@04d5d8>): u32Neg: uint32 := uint32(-u32B)
	<.main+7038 @04d5d5> : 10 01                      dup.x1 sp(1)
	<.main+7040 @04d5d7> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@04d5d8> - <@04d5db>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7041 @04d5d8> : 10 02                      dup.x1 sp(2)
	<.main+7043 @04d5da> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@04d5db> - <@04d5e0>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7044 @04d5db> : 10 04                      dup.x1 sp(4)
	<.main+7046 @04d5dd> : 10 04                      dup.x1 sp(4)
	<.main+7048 @04d5df> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@04d5e0> - <@04d5e5>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7049 @04d5e0> : 10 05                      dup.x1 sp(5)
	<.main+7051 @04d5e2> : 10 05                      dup.x1 sp(5)
	<.main+7053 @04d5e4> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@04d5e5> - <@04d5ea>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7054 @04d5e5> : 10 06                      dup.x1 sp(6)
	<.main+7056 @04d5e7> : 10 06                      dup.x1 sp(6)
	<.main+7058 @04d5e9> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@04d5ea> - <@04d5ef>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7059 @04d5ea> : 10 07                      dup.x1 sp(7)
	<.main+7061 @04d5ec> : 10 07                      dup.x1 sp(7)
	<.main+7063 @04d5ee> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@04d5ef> - <@04d5f4>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7064 @04d5ef> : 10 08                      dup.x1 sp(8)
	<.main+7066 @04d5f1> : 10 08                      dup.x1 sp(8)
	<.main+7068 @04d5f3> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@04d5f4> - <@04d5f9>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7069 @04d5f4> : 10 09                      dup.x1 sp(9)
	<.main+7071 @04d5f6> : 10 09                      dup.x1 sp(9)
	<.main+7073 @04d5f8> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@04d5f9> - <@04d5fe>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7074 @04d5f9> : 10 0a                      dup.x1 sp(10)
	<.main+7076 @04d5fb> : 10 0a                      dup.x1 sp(10)
	<.main+7078 @04d5fd> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@04d5fe> - <@04d603>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7079 @04d5fe> : 10 0b                      dup.x1 sp(11)
	<.main+7081 @04d600> : 10 0b                      dup.x1 sp(11)
	<.main+7083 @04d602> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@04d603> - <@04d608>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7084 @04d603> : 10 0c                      dup.x1 sp(12)
	<.main+7086 @04d605> : 10 9e                      dup.x1 sp(158)
	<.main+7088 @04d607> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@04d608> - <@04d60d>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7089 @04d608> : 10 0d                      dup.x1 sp(13)
	<.main+7091 @04d60a> : 10 9f                      dup.x1 sp(159)
	<.main+7093 @04d60c> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@04d60d> - <@04d611>): u32Not: bool := bool(!(u32B))
	<.main+7094 @04d60d> : 10 0d                      dup.x1 sp(13)
	<.main+7096 @04d60f> : 5a                         i32.2bool
	<.main+7097 @04d610> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@04d611> - <@04d616>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7098 @04d611> : 10 0f                      dup.x1 sp(15)
	<.main+7100 @04d613> : 10 0f                      dup.x1 sp(15)
	<.main+7102 @04d615> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@04d616> - <@04d61c>): u32Cne: bool := bool(u32A != u32B)
	<.main+7103 @04d616> : 10 10                      dup.x1 sp(16)
	<.main+7105 @04d618> : 10 10                      dup.x1 sp(16)
	<.main+7107 @04d61a> : 57                         ceq.i32
	<.main+7108 @04d61b> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@04d61c> - <@04d621>): u32Clt: bool := bool(u32A < u32B)
	<.main+7109 @04d61c> : 10 11                      dup.x1 sp(17)
	<.main+7111 @04d61e> : 10 11                      dup.x1 sp(17)
	<.main+7113 @04d620> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@04d621> - <@04d627>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7114 @04d621> : 10 12                      dup.x1 sp(18)
	<.main+7116 @04d623> : 10 12                      dup.x1 sp(18)
	<.main+7118 @04d625> : 39                         cgt.u32
	<.main+7119 @04d626> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@04d627> - <@04d62c>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7120 @04d627> : 10 13                      dup.x1 sp(19)
	<.main+7122 @04d629> : 10 13                      dup.x1 sp(19)
	<.main+7124 @04d62b> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@04d62c> - <@04d632>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7125 @04d62c> : 10 14                      dup.x1 sp(20)
	<.main+7127 @04d62e> : 10 14                      dup.x1 sp(20)
	<.main+7129 @04d630> : 38                         clt.u32
	<.main+7130 @04d631> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@04d632> - <@04d63b>): i64A: int64 := a
	<.main+7131 @04d632> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@04d63b> - <@04d644>): i64B: int64 := b
	<.main+7140 @04d63b> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@04d644> - <@04d646>): i64Pls: int64 := int64(+i64B)
	<.main+7149 @04d644> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@04d646> - <@04d649>): i64Neg: int64 := int64(-i64B)
	<.main+7151 @04d646> : 11 02                      dup.x2 sp(2)
	<.main+7153 @04d648> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@04d649> - <@04d64c>): i64Cmt: int64 := int64(~i64B)
	<.main+7154 @04d649> : 11 04                      dup.x2 sp(4)
	<.main+7156 @04d64b> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@04d64c> - <@04d651>): i64Add: int64 := int64(i64A + i64B)
	<.main+7157 @04d64c> : 11 08                      dup.x2 sp(8)
	<.main+7159 @04d64e> : 11 08                      dup.x2 sp(8)
	<.main+7161 @04d650> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@04d651> - <@04d656>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7162 @04d651> : 11 0a                      dup.x2 sp(10)
	<.main+7164 @04d653> : 11 0a                      dup.x2 sp(10)
	<.main+7166 @04d655> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@04d656> - <@04d65b>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7167 @04d656> : 11 0c                      dup.x2 sp(12)
	<.main+7169 @04d658> : 11 0c                      dup.x2 sp(12)
	<.main+7171 @04d65a> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@04d65b> - <@04d660>): i64Div: int64 := int64(i64A / i64B)
	<.main+7172 @04d65b> : 11 0e                      dup.x2 sp(14)
	<.main+7174 @04d65d> : 11 0e                      dup.x2 sp(14)
	<.main+7176 @04d65f> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@04d660> - <@04d665>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7177 @04d660> : 11 10                      dup.x2 sp(16)
	<.main+7179 @04d662> : 11 10                      dup.x2 sp(16)
	<.main+7181 @04d664> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@04d665> - <@04d66a>): i64And: int64 := int64(i64A & i64B)
	<.main+7182 @04d665> : 11 12                      dup.x2 sp(18)
	<.main+7184 @04d667> : 11 12                      dup.x2 sp(18)
	<.main+7186 @04d669> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@04d66a> - <@04d66f>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7187 @04d66a> : 11 14                      dup.x2 sp(20)
	<.main+7189 @04d66c> : 11 14                      dup.x2 sp(20)
	<.main+7191 @04d66e> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@04d66f> - <@04d674>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7192 @04d66f> : 11 16                      dup.x2 sp(22)
	<.main+7194 @04d671> : 11 16                      dup.x2 sp(22)
	<.main+7196 @04d673> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@04d674> - <@04d679>): i64Shl: int64 := int64(i64A << shift)
	<.main+7197 @04d674> : 11 18                      dup.x2 sp(24)
	<.main+7199 @04d676> : 10 c2                      dup.x1 sp(194)
	<.main+7201 @04d678> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@04d679> - <@04d67e>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7202 @04d679> : 11 1a                      dup.x2 sp(26)
	<.main+7204 @04d67b> : 10 c4                      dup.x1 sp(196)
	<.main+7206 @04d67d> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@04d67e> - <@04d682>): i64Not: bool := bool(!(i64B))
	<.main+7207 @04d67e> : 11 1a                      dup.x2 sp(26)
	<.main+7209 @04d680> : 6c                         i64.2bool
	<.main+7210 @04d681> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@04d682> - <@04d687>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7211 @04d682> : 11 1d                      dup.x2 sp(29)
	<.main+7213 @04d684> : 11 1d                      dup.x2 sp(29)
	<.main+7215 @04d686> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@04d687> - <@04d68d>): i64Cne: bool := bool(i64A != i64B)
	<.main+7216 @04d687> : 11 1e                      dup.x2 sp(30)
	<.main+7218 @04d689> : 11 1e                      dup.x2 sp(30)
	<.main+7220 @04d68b> : 67                         ceq.i64
	<.main+7221 @04d68c> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@04d68d> - <@04d692>): i64Clt: bool := bool(i64A < i64B)
	<.main+7222 @04d68d> : 11 1f                      dup.x2 sp(31)
	<.main+7224 @04d68f> : 11 1f                      dup.x2 sp(31)
	<.main+7226 @04d691> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@04d692> - <@04d698>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7227 @04d692> : 11 20                      dup.x2 sp(32)
	<.main+7229 @04d694> : 11 20                      dup.x2 sp(32)
	<.main+7231 @04d696> : 69                         cgt.i64
	<.main+7232 @04d697> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@04d698> - <@04d69d>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7233 @04d698> : 11 21                      dup.x2 sp(33)
	<.main+7235 @04d69a> : 11 21                      dup.x2 sp(33)
	<.main+7237 @04d69c> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@04d69d> - <@04d6a3>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7238 @04d69d> : 11 22                      dup.x2 sp(34)
	<.main+7240 @04d69f> : 11 22                      dup.x2 sp(34)
	<.main+7242 @04d6a1> : 68                         clt.i64
	<.main+7243 @04d6a2> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@04d6a3> - <@04d6ac>): u64A: uint64 := a
	<.main+7244 @04d6a3> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@04d6ac> - <@04d6b5>): u64B: uint64 := b
	<.main+7253 @04d6ac> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@04d6b5> - <@04d6b7>): u64Pls: uint64 := uint64(+u64B)
	<.main+7262 @04d6b5> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@04d6b7> - <@04d6ba>): u64Neg: uint64 := uint64(-u64B)
	<.main+7264 @04d6b7> : 11 02                      dup.x2 sp(2)
	<.main+7266 @04d6b9> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@04d6ba> - <@04d6bd>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7267 @04d6ba> : 11 04                      dup.x2 sp(4)
	<.main+7269 @04d6bc> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@04d6bd> - <@04d6c2>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7270 @04d6bd> : 11 08                      dup.x2 sp(8)
	<.main+7272 @04d6bf> : 11 08                      dup.x2 sp(8)
	<.main+7274 @04d6c1> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@04d6c2> - <@04d6c7>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7275 @04d6c2> : 11 0a                      dup.x2 sp(10)
	<.main+7277 @04d6c4> : 11 0a                      dup.x2 sp(10)
	<.main+7279 @04d6c6> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@04d6c7> - <@04d6cc>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7280 @04d6c7> : 11 0c                      dup.x2 sp(12)
	<.main+7282 @04d6c9> : 11 0c                      dup.x2 sp(12)
	<.main+7284 @04d6cb> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@04d6cc> - <@04d6d1>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7285 @04d6cc> : 11 0e                      dup.x2 sp(14)
	<.main+7287 @04d6ce> : 11 0e                      dup.x2 sp(14)
	<.main+7289 @04d6d0> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@04d6d1> - <@04d6d6>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7290 @04d6d1> : 11 10                      dup.x2 sp(16)
	<.main+7292 @04d6d3> : 11 10                      dup.x2 sp(16)
	<.main+7294 @04d6d5> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@04d6d6> - <@04d6db>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7295 @04d6d6> : 11 12                      dup.x2 sp(18)
	<.main+7297 @04d6d8> : 11 12                      dup.x2 sp(18)
	<.main+7299 @04d6da> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@04d6db> - <@04d6e0>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7300 @04d6db> : 11 14                      dup.x2 sp(20)
	<.main+7302 @04d6dd> : 11 14                      dup.x2 sp(20)
	<.main+7304 @04d6df> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@04d6e0> - <@04d6e5>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7305 @04d6e0> : 11 16                      dup.x2 sp(22)
	<.main+7307 @04d6e2> : 11 16                      dup.x2 sp(22)
	<.main+7309 @04d6e4> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@04d6e5> - <@04d6ea>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7310 @04d6e5> : 11 18                      dup.x2 sp(24)
	<.main+7312 @04d6e7> : 10 e7                      dup.x1 sp(231)
	<.main+7314 @04d6e9> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@04d6ea> - <@04d6ef>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7315 @04d6ea> : 11 1a                      dup.x2 sp(26)
	<.main+7317 @04d6ec> : 10 e9                      dup.x1 sp(233)
	<.main+7319 @04d6ee> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@04d6ef> - <@04d6f3>): u64Not: bool := bool(!(u64B))
	<.main+7320 @04d6ef> : 11 1a                      dup.x2 sp(26)
	<.main+7322 @04d6f1> : 6c                         i64.2bool
	<.main+7323 @04d6f2> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@04d6f3> - <@04d6f8>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7324 @04d6f3> : 11 1d                      dup.x2 sp(29)
	<.main+7326 @04d6f5> : 11 1d                      dup.x2 sp(29)
	<.main+7328 @04d6f7> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@04d6f8> - <@04d6fe>): u64Cne: bool := bool(u64A != u64B)
	<.main+7329 @04d6f8> : 11 1e                      dup.x2 sp(30)
	<.main+7331 @04d6fa> : 11 1e                      dup.x2 sp(30)
	<.main+7333 @04d6fc> : 67                         ceq.i64
	<.main+7334 @04d6fd> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@04d6fe> - <@04d703>): u64Clt: bool := bool(u64A < u64B)
	<.main+7335 @04d6fe> : 11 1f                      dup.x2 sp(31)
	<.main+7337 @04d700> : 11 1f                      dup.x2 sp(31)
	<.main+7339 @04d702> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@04d703> - <@04d709>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7340 @04d703> : 11 20                      dup.x2 sp(32)
	<.main+7342 @04d705> : 11 20                      dup.x2 sp(32)
	<.main+7344 @04d707> : 49                         cgt.u64
	<.main+7345 @04d708> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@04d709> - <@04d70e>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7346 @04d709> : 11 21                      dup.x2 sp(33)
	<.main+7348 @04d70b> : 11 21                      dup.x2 sp(33)
	<.main+7350 @04d70d> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@04d70e> - <@04d714>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7351 @04d70e> : 11 22                      dup.x2 sp(34)
	<.main+7353 @04d710> : 11 22                      dup.x2 sp(34)
	<.main+7355 @04d712> : 48                         clt.u64
	<.main+7356 @04d713> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@04d714> - <@04d719>): f32A: float32 := a
	<.main+7357 @04d714> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@04d719> - <@04d71e>): f32B: float32 := b
	<.main+7362 @04d719> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@04d71e> - <@04d720>): f32Pls: float32 := float32(+f32B)
	<.main+7367 @04d71e> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@04d720> - <@04d723>): f32Neg: float32 := float32(-f32B)
	<.main+7369 @04d720> : 10 01                      dup.x1 sp(1)
	<.main+7371 @04d722> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@04d723> - <@04d728>): f32Add: float32 := float32(f32A + f32B)
	<.main+7372 @04d723> : 10 03                      dup.x1 sp(3)
	<.main+7374 @04d725> : 10 03                      dup.x1 sp(3)
	<.main+7376 @04d727> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@04d728> - <@04d72d>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7377 @04d728> : 10 04                      dup.x1 sp(4)
	<.main+7379 @04d72a> : 10 04                      dup.x1 sp(4)
	<.main+7381 @04d72c> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@04d72d> - <@04d732>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7382 @04d72d> : 10 05                      dup.x1 sp(5)
	<.main+7384 @04d72f> : 10 05                      dup.x1 sp(5)
	<.main+7386 @04d731> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@04d732> - <@04d737>): f32Div: float32 := float32(f32A / f32B)
	<.main+7387 @04d732> : 10 06                      dup.x1 sp(6)
	<.main+7389 @04d734> : 10 06                      dup.x1 sp(6)
	<.main+7391 @04d736> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@04d737> - <@04d73c>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7392 @04d737> : 10 07                      dup.x1 sp(7)
	<.main+7394 @04d739> : 10 07                      dup.x1 sp(7)
	<.main+7396 @04d73b> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@04d73c> - <@04d740>): f32Not: bool := bool(!(f32B))
	<.main+7397 @04d73c> : 10 07                      dup.x1 sp(7)
	<.main+7399 @04d73e> : 7b                         f32.2bool
	<.main+7400 @04d73f> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@04d740> - <@04d745>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7401 @04d740> : 10 09                      dup.x1 sp(9)
	<.main+7403 @04d742> : 10 09                      dup.x1 sp(9)
	<.main+7405 @04d744> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@04d745> - <@04d74b>): f32Cne: bool := bool(f32A != f32B)
	<.main+7406 @04d745> : 10 0a                      dup.x1 sp(10)
	<.main+7408 @04d747> : 10 0a                      dup.x1 sp(10)
	<.main+7410 @04d749> : 77                         ceq.f32
	<.main+7411 @04d74a> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@04d74b> - <@04d750>): f32Clt: bool := bool(f32A < f32B)
	<.main+7412 @04d74b> : 10 0b                      dup.x1 sp(11)
	<.main+7414 @04d74d> : 10 0b                      dup.x1 sp(11)
	<.main+7416 @04d74f> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@04d750> - <@04d756>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7417 @04d750> : 10 0c                      dup.x1 sp(12)
	<.main+7419 @04d752> : 10 0c                      dup.x1 sp(12)
	<.main+7421 @04d754> : 79                         cgt.f32
	<.main+7422 @04d755> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@04d756> - <@04d75b>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7423 @04d756> : 10 0d                      dup.x1 sp(13)
	<.main+7425 @04d758> : 10 0d                      dup.x1 sp(13)
	<.main+7427 @04d75a> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@04d75b> - <@04d761>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7428 @04d75b> : 10 0e                      dup.x1 sp(14)
	<.main+7430 @04d75d> : 10 0e                      dup.x1 sp(14)
	<.main+7432 @04d75f> : 78                         clt.f32
	<.main+7433 @04d760> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@04d761> - <@04d76a>): f64A: float64 := a
	<.main+7434 @04d761> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@04d76a> - <@04d773>): f64B: float64 := b
	<.main+7443 @04d76a> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@04d773> - <@04d775>): f64Pls: float64 := float64(+f64B)
	<.main+7452 @04d773> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@04d775> - <@04d778>): f64Neg: float64 := float64(-f64B)
	<.main+7454 @04d775> : 11 02                      dup.x2 sp(2)
	<.main+7456 @04d777> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@04d778> - <@04d77d>): f64Add: float64 := float64(f64A + f64B)
	<.main+7457 @04d778> : 11 06                      dup.x2 sp(6)
	<.main+7459 @04d77a> : 11 06                      dup.x2 sp(6)
	<.main+7461 @04d77c> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@04d77d> - <@04d782>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7462 @04d77d> : 11 08                      dup.x2 sp(8)
	<.main+7464 @04d77f> : 11 08                      dup.x2 sp(8)
	<.main+7466 @04d781> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@04d782> - <@04d787>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7467 @04d782> : 11 0a                      dup.x2 sp(10)
	<.main+7469 @04d784> : 11 0a                      dup.x2 sp(10)
	<.main+7471 @04d786> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@04d787> - <@04d78c>): f64Div: float64 := float64(f64A / f64B)
	<.main+7472 @04d787> : 11 0c                      dup.x2 sp(12)
	<.main+7474 @04d789> : 11 0c                      dup.x2 sp(12)
	<.main+7476 @04d78b> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@04d78c> - <@04d791>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7477 @04d78c> : 11 0e                      dup.x2 sp(14)
	<.main+7479 @04d78e> : 11 0e                      dup.x2 sp(14)
	<.main+7481 @04d790> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@04d791> - <@04d795>): f64Not: bool := bool(!(f64B))
	<.main+7482 @04d791> : 11 0e                      dup.x2 sp(14)
	<.main+7484 @04d793> : 8d                         f64.2bool
	<.main+7485 @04d794> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@04d795> - <@04d79a>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7486 @04d795> : 11 11                      dup.x2 sp(17)
	<.main+7488 @04d797> : 11 11                      dup.x2 sp(17)
	<.main+7490 @04d799> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@04d79a> - <@04d7a0>): f64Cne: bool := bool(f64A != f64B)
	<.main+7491 @04d79a> : 11 12                      dup.x2 sp(18)
	<.main+7493 @04d79c> : 11 12                      dup.x2 sp(18)
	<.main+7495 @04d79e> : 87                         ceq.f64
	<.main+7496 @04d79f> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@04d7a0> - <@04d7a5>): f64Clt: bool := bool(f64A < f64B)
	<.main+7497 @04d7a0> : 11 13                      dup.x2 sp(19)
	<.main+7499 @04d7a2> : 11 13                      dup.x2 sp(19)
	<.main+7501 @04d7a4> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@04d7a5> - <@04d7ab>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7502 @04d7a5> : 11 14                      dup.x2 sp(20)
	<.main+7504 @04d7a7> : 11 14                      dup.x2 sp(20)
	<.main+7506 @04d7a9> : 89                         cgt.f64
	<.main+7507 @04d7aa> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@04d7ab> - <@04d7b0>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7508 @04d7ab> : 11 15                      dup.x2 sp(21)
	<.main+7510 @04d7ad> : 11 15                      dup.x2 sp(21)
	<.main+7512 @04d7af> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@04d7b0> - <@04d7b6>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7513 @04d7b0> : 11 16                      dup.x2 sp(22)
	<.main+7515 @04d7b2> : 11 16                      dup.x2 sp(22)
	<.main+7517 @04d7b4> : 88                         clt.f64
	<.main+7518 @04d7b5> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@04d7b6> - <@04d7bb>): ptrA: pointer := null
	<.main+7519 @04d7b6> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@04d7bb> - <@04d7bf>): ptrB: pointer := pointer(shift)
	<.main+7524 @04d7bb> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@04d7bf> - <@04d7c4>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7528 @04d7bf> : 10 01                      dup.x1 sp(1)
	<.main+7530 @04d7c1> : 10 01                      dup.x1 sp(1)
	<.main+7532 @04d7c3> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@04d7c4> - <@04d7ca>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7533 @04d7c4> : 10 02                      dup.x1 sp(2)
	<.main+7535 @04d7c6> : 10 02                      dup.x1 sp(2)
	<.main+7537 @04d7c8> : 57                         ceq.i32
	<.main+7538 @04d7c9> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@04d7ca> - <@04d7f1>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7539 @04d7ca> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7544 @04d7cf> : 1c 04 00 00 00             load.c32 4
	<.main+7549 @04d7d4> : 1c 0e 00 00 00             load.c32 14
	<.main+7554 @04d7d9> : 1c 01 00 00 00             load.c32 1
	<.main+7559 @04d7de> : 1f a1 6f 04 00             load.ref <@046fa1> ;"0 == 0"
	<.main+7564 @04d7e3> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+7569 @04d7e8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7574 @04d7ed> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@04d7f1> - <@04d818>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7578 @04d7f1> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7583 @04d7f6> : 1c 0c 00 00 00             load.c32 12
	<.main+7588 @04d7fb> : 1c 0e 00 00 00             load.c32 14
	<.main+7593 @04d800> : 1c 03 00 00 00             load.c32 3
	<.main+7598 @04d805> : 1f a1 6f 04 00             load.ref <@046fa1> ;"0 == 0"
	<.main+7603 @04d80a> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+7608 @04d80f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7613 @04d814> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@04d818> - <@04d83f>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7617 @04d818> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7622 @04d81d> : 1c 16 00 00 00             load.c32 22
	<.main+7627 @04d822> : 1c 0e 00 00 00             load.c32 14
	<.main+7632 @04d827> : 1c 06 00 00 00             load.c32 6
	<.main+7637 @04d82c> : 1f a1 6f 04 00             load.ref <@046fa1> ;"0 == 0"
	<.main+7642 @04d831> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+7647 @04d836> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7652 @04d83b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@04d83f> - <@04d840>): t: int32 := 0
	<.main+7656 @04d83f> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@04d840> - <@04d86e>): if (bool(t == 0))
	<.main+7657 @04d840> : 10 00                      dup.x1 sp(0)
	<.main+7659 @04d842> : 19                         load.z32
	<.main+7660 @04d843> : 57                         ceq.i32
	<.main+7661 @04d844> : 06 2a 00 00                jz <.main+7703 @04d86e>
	test/lang/statementIf.ci:29: (38 bytes: <@04d848> - <@04d86e>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7665 @04d848> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7670 @04d84d> : 1c 1d 00 00 00             load.c32 29
	<.main+7675 @04d852> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @04d857> : 1c 07 00 00 00             load.c32 7
	<.main+7685 @04d85c> : 1f af 6f 04 00             load.ref <@046faf> ;"t == 0"
	<.main+7690 @04d861> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7695 @04d866> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @04d86a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@04d86e> - <@04d89c>): if (bool(t != 0))
	<.main+7703 @04d86e> : 10 00                      dup.x1 sp(0)
	<.main+7705 @04d870> : 19                         load.z32
	<.main+7706 @04d871> : 57                         ceq.i32
	<.main+7707 @04d872> : 05 2a 00 00                jnz <.main+7749 @04d89c>
	test/lang/statementIf.ci:33: (38 bytes: <@04d876> - <@04d89c>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7711 @04d876> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7716 @04d87b> : 1c 21 00 00 00             load.c32 33
	<.main+7721 @04d880> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @04d885> : 1c 08 00 00 00             load.c32 8
	<.main+7731 @04d88a> : 1f b6 6f 04 00             load.ref <@046fb6> ;"t != 0"
	<.main+7736 @04d88f> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7741 @04d894> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @04d898> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@04d89c> - <@04d8f4>): if (bool(t == 0))
	<.main+7749 @04d89c> : 10 00                      dup.x1 sp(0)
	<.main+7751 @04d89e> : 19                         load.z32
	<.main+7752 @04d89f> : 57                         ceq.i32
	<.main+7753 @04d8a0> : 06 2e 00 00                jz <.main+7799 @04d8ce>
	test/lang/statementIf.ci:37: (38 bytes: <@04d8a4> - <@04d8ca>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7757 @04d8a4> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7762 @04d8a9> : 1c 25 00 00 00             load.c32 37
	<.main+7767 @04d8ae> : 1c 0e 00 00 00             load.c32 14
	<.main+7772 @04d8b3> : 1c 09 00 00 00             load.c32 9
	<.main+7777 @04d8b8> : 1f af 6f 04 00             load.ref <@046faf> ;"t == 0"
	<.main+7782 @04d8bd> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7787 @04d8c2> : 0a 18 00 00                load.sp(+24)
	<.main+7791 @04d8c6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7795 @04d8ca> : 04 2a 00 00                jmp <.main+7837 @04d8f4>
	test/lang/statementIf.ci:40: (38 bytes: <@04d8ce> - <@04d8f4>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7799 @04d8ce> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7804 @04d8d3> : 1c 28 00 00 00             load.c32 40
	<.main+7809 @04d8d8> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @04d8dd> : 1c 0a 00 00 00             load.c32 10
	<.main+7819 @04d8e2> : 1f b6 6f 04 00             load.ref <@046fb6> ;"t != 0"
	<.main+7824 @04d8e7> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7829 @04d8ec> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @04d8f0> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@04d8f4> - <@04d94c>): if (bool(t != 0))
	<.main+7837 @04d8f4> : 10 00                      dup.x1 sp(0)
	<.main+7839 @04d8f6> : 19                         load.z32
	<.main+7840 @04d8f7> : 57                         ceq.i32
	<.main+7841 @04d8f8> : 05 2e 00 00                jnz <.main+7887 @04d926>
	test/lang/statementIf.ci:44: (38 bytes: <@04d8fc> - <@04d922>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7845 @04d8fc> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7850 @04d901> : 1c 2c 00 00 00             load.c32 44
	<.main+7855 @04d906> : 1c 0e 00 00 00             load.c32 14
	<.main+7860 @04d90b> : 1c 0b 00 00 00             load.c32 11
	<.main+7865 @04d910> : 1f b6 6f 04 00             load.ref <@046fb6> ;"t != 0"
	<.main+7870 @04d915> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7875 @04d91a> : 0a 18 00 00                load.sp(+24)
	<.main+7879 @04d91e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7883 @04d922> : 04 2a 00 00                jmp <.main+7925 @04d94c>
	test/lang/statementIf.ci:47: (38 bytes: <@04d926> - <@04d94c>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7887 @04d926> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7892 @04d92b> : 1c 2f 00 00 00             load.c32 47
	<.main+7897 @04d930> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @04d935> : 1c 0c 00 00 00             load.c32 12
	<.main+7907 @04d93a> : 1f af 6f 04 00             load.ref <@046faf> ;"t == 0"
	<.main+7912 @04d93f> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7917 @04d944> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @04d948> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@04d94c> - <@04dab2>): if (bool(t == 0))
	<.main+7925 @04d94c> : 10 00                      dup.x1 sp(0)
	<.main+7927 @04d94e> : 19                         load.z32
	<.main+7928 @04d94f> : 57                         ceq.i32
	<.main+7929 @04d950> : 06 2e 00 00                jz <.main+7975 @04d97e>
	test/lang/statementIf.ci:51: (38 bytes: <@04d954> - <@04d97a>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7933 @04d954> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7938 @04d959> : 1c 33 00 00 00             load.c32 51
	<.main+7943 @04d95e> : 1c 0e 00 00 00             load.c32 14
	<.main+7948 @04d963> : 1c 09 00 00 00             load.c32 9
	<.main+7953 @04d968> : 1f af 6f 04 00             load.ref <@046faf> ;"t == 0"
	<.main+7958 @04d96d> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+7963 @04d972> : 0a 18 00 00                load.sp(+24)
	<.main+7967 @04d976> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7971 @04d97a> : 04 38 01 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:53: (308 bytes: <@04d97e> - <@04dab2>): if (bool(t == 1))
	<.main+7975 @04d97e> : 10 00                      dup.x1 sp(0)
	<.main+7977 @04d980> : 1c 01 00 00 00             load.c32 1
	<.main+7982 @04d985> : 57                         ceq.i32
	<.main+7983 @04d986> : 06 2e 00 00                jz <.main+8029 @04d9b4>
	test/lang/statementIf.ci:54: (38 bytes: <@04d98a> - <@04d9b0>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7987 @04d98a> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+7992 @04d98f> : 1c 36 00 00 00             load.c32 54
	<.main+7997 @04d994> : 1c 0e 00 00 00             load.c32 14
	<.main+8002 @04d999> : 1c 0a 00 00 00             load.c32 10
	<.main+8007 @04d99e> : 1f bd 6f 04 00             load.ref <@046fbd> ;"t == 1"
	<.main+8012 @04d9a3> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8017 @04d9a8> : 0a 18 00 00                load.sp(+24)
	<.main+8021 @04d9ac> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8025 @04d9b0> : 04 02 01 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:56: (254 bytes: <@04d9b4> - <@04dab2>): if (bool(t == 2))
	<.main+8029 @04d9b4> : 10 00                      dup.x1 sp(0)
	<.main+8031 @04d9b6> : 1c 02 00 00 00             load.c32 2
	<.main+8036 @04d9bb> : 57                         ceq.i32
	<.main+8037 @04d9bc> : 06 2e 00 00                jz <.main+8083 @04d9ea>
	test/lang/statementIf.ci:57: (38 bytes: <@04d9c0> - <@04d9e6>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8041 @04d9c0> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+8046 @04d9c5> : 1c 39 00 00 00             load.c32 57
	<.main+8051 @04d9ca> : 1c 0e 00 00 00             load.c32 14
	<.main+8056 @04d9cf> : 1c 0a 00 00 00             load.c32 10
	<.main+8061 @04d9d4> : 1f c4 6f 04 00             load.ref <@046fc4> ;"t == 2"
	<.main+8066 @04d9d9> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8071 @04d9de> : 0a 18 00 00                load.sp(+24)
	<.main+8075 @04d9e2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8079 @04d9e6> : 04 cc 00 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:59: (200 bytes: <@04d9ea> - <@04dab2>): if (bool(t == 3))
	<.main+8083 @04d9ea> : 10 00                      dup.x1 sp(0)
	<.main+8085 @04d9ec> : 1c 03 00 00 00             load.c32 3
	<.main+8090 @04d9f1> : 57                         ceq.i32
	<.main+8091 @04d9f2> : 06 2e 00 00                jz <.main+8137 @04da20>
	test/lang/statementIf.ci:60: (38 bytes: <@04d9f6> - <@04da1c>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8095 @04d9f6> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+8100 @04d9fb> : 1c 3c 00 00 00             load.c32 60
	<.main+8105 @04da00> : 1c 0e 00 00 00             load.c32 14
	<.main+8110 @04da05> : 1c 0a 00 00 00             load.c32 10
	<.main+8115 @04da0a> : 1f cb 6f 04 00             load.ref <@046fcb> ;"t == 3"
	<.main+8120 @04da0f> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8125 @04da14> : 0a 18 00 00                load.sp(+24)
	<.main+8129 @04da18> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8133 @04da1c> : 04 96 00 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:62: (146 bytes: <@04da20> - <@04dab2>): if (bool(t == 4))
	<.main+8137 @04da20> : 10 00                      dup.x1 sp(0)
	<.main+8139 @04da22> : 1c 04 00 00 00             load.c32 4
	<.main+8144 @04da27> : 57                         ceq.i32
	<.main+8145 @04da28> : 06 2e 00 00                jz <.main+8191 @04da56>
	test/lang/statementIf.ci:63: (38 bytes: <@04da2c> - <@04da52>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8149 @04da2c> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+8154 @04da31> : 1c 3f 00 00 00             load.c32 63
	<.main+8159 @04da36> : 1c 0e 00 00 00             load.c32 14
	<.main+8164 @04da3b> : 1c 0a 00 00 00             load.c32 10
	<.main+8169 @04da40> : 1f d2 6f 04 00             load.ref <@046fd2> ;"t == 4"
	<.main+8174 @04da45> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8179 @04da4a> : 0a 18 00 00                load.sp(+24)
	<.main+8183 @04da4e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8187 @04da52> : 04 60 00 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:65: (92 bytes: <@04da56> - <@04dab2>): if (bool(t == 5))
	<.main+8191 @04da56> : 10 00                      dup.x1 sp(0)
	<.main+8193 @04da58> : 1c 05 00 00 00             load.c32 5
	<.main+8198 @04da5d> : 57                         ceq.i32
	<.main+8199 @04da5e> : 06 2e 00 00                jz <.main+8245 @04da8c>
	test/lang/statementIf.ci:66: (38 bytes: <@04da62> - <@04da88>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8203 @04da62> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+8208 @04da67> : 1c 42 00 00 00             load.c32 66
	<.main+8213 @04da6c> : 1c 0e 00 00 00             load.c32 14
	<.main+8218 @04da71> : 1c 0a 00 00 00             load.c32 10
	<.main+8223 @04da76> : 1f d9 6f 04 00             load.ref <@046fd9> ;"t == 5"
	<.main+8228 @04da7b> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8233 @04da80> : 0a 18 00 00                load.sp(+24)
	<.main+8237 @04da84> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8241 @04da88> : 04 2a 00 00                jmp <.main+8283 @04dab2>
	test/lang/statementIf.ci:69: (38 bytes: <@04da8c> - <@04dab2>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8245 @04da8c> : 1f 88 6f 04 00             load.ref <@046f88> ;"test/lang/statementIf.ci"
	<.main+8250 @04da91> : 1c 45 00 00 00             load.c32 69
	<.main+8255 @04da96> : 1c 0e 00 00 00             load.c32 14
	<.main+8260 @04da9b> : 1c 0a 00 00 00             load.c32 10
	<.main+8265 @04daa0> : 1f e0 6f 04 00             load.ref <@046fe0> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8270 @04daa5> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8275 @04daaa> : 0a 18 00 00                load.sp(+24)
	<.main+8279 @04daae> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@04dab2> - <@04dae1>): for ( ; ; )
	<.main+8283 @04dab2> : 04 2b 00 00                jmp <.main+8326 @04dadd>
	test/lang/statementFor.ci:4: (35 bytes: <@04dab6> - <@04dad9>): debug("for ( ; ; )");
	<.main+8287 @04dab6> : 1f c0 70 04 00             load.ref <@0470c0> ;"test/lang/statementFor.ci"
	<.main+8292 @04dabb> : 1c 04 00 00 00             load.c32 4
	<.main+8297 @04dac0> : 1c 0e 00 00 00             load.c32 14
	<.main+8302 @04dac5> : 19                         load.z32
	<.main+8303 @04dac6> : 1f da 70 04 00             load.ref <@0470da> ;"for ( ; ; )"
	<.main+8308 @04dacb> : 1f 60 08 00 00             load.ref <@000860> ;pointer
	<.main+8313 @04dad0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8318 @04dad5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@04dad9> - <@04dadd>): break;
	<.main+8322 @04dad9> : 04 08 00 00                jmp <.main+8330 @04dae1>
	:: (4 bytes: <@04dadd> - <@04dae1>)
	<.main+8326 @04dadd> : 04 d9 ff ff                jmp <.main+8287 @04dab6>
	test/lang/statementFor.ci:8: (59 bytes: <@04dae1> - <@04db1c>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8330 @04dae1> : 19                         load.z32
	<.main+8331 @04dae2> : 04 2a 00 00                jmp <.main+8373 @04db0c>
	test/lang/statementFor.ci:9: (34 bytes: <@04dae6> - <@04db08>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8335 @04dae6> : 1f c0 70 04 00             load.ref <@0470c0> ;"test/lang/statementFor.ci"
	<.main+8340 @04daeb> : 1c 09 00 00 00             load.c32 9
	<.main+8345 @04daf0> : 1c 0e 00 00 00             load.c32 14
	<.main+8350 @04daf5> : 19                         load.z32
	<.main+8351 @04daf6> : 1f e6 70 04 00             load.ref <@0470e6> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8356 @04dafb> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8361 @04db00> : 0a 18 00 00                load.sp(+24)
	<.main+8365 @04db04> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@04db08> - <@04db0c>): int32(i := int32(i + 1))
	<.main+8369 @04db08> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@04db0c> - <@04db18>): bool(i < 2)
	<.main+8373 @04db0c> : 10 00                      dup.x1 sp(0)
	<.main+8375 @04db0e> : 1c 02 00 00 00             load.c32 2
	<.main+8380 @04db13> : 58                         clt.i32
	<.main+8381 @04db14> : 05 d2 ff ff                jnz <.main+8335 @04dae6>
	<.main+8385 @04db18> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@04db1c> - <@04db1d>): forIdx: int32
	<.main+8389 @04db1c> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@04db1d> - <@04db56>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8390 @04db1d> : 19                         load.z32
	<.main+8391 @04db1e> : 13 01                      set.x1 sp(1)
	<.main+8393 @04db20> : 04 2a 00 00                jmp <.main+8435 @04db4a>
	test/lang/statementFor.ci:14: (34 bytes: <@04db24> - <@04db46>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8397 @04db24> : 1f c0 70 04 00             load.ref <@0470c0> ;"test/lang/statementFor.ci"
	<.main+8402 @04db29> : 1c 0e 00 00 00             load.c32 14
	<.main+8407 @04db2e> : 1c 0e 00 00 00             load.c32 14
	<.main+8412 @04db33> : 19                         load.z32
	<.main+8413 @04db34> : 1f 0c 71 04 00             load.ref <@04710c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8418 @04db39> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8423 @04db3e> : 0a 18 00 00                load.sp(+24)
	<.main+8427 @04db42> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@04db46> - <@04db4a>): int32(forIdx := int32(forIdx + 1))
	<.main+8431 @04db46> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@04db4a> - <@04db56>): bool(forIdx < 2)
	<.main+8435 @04db4a> : 10 00                      dup.x1 sp(0)
	<.main+8437 @04db4c> : 1c 02 00 00 00             load.c32 2
	<.main+8442 @04db51> : 58                         clt.i32
	<.main+8443 @04db52> : 05 d2 ff ff                jnz <.main+8397 @04db24>
	test/lang/statementFor.ci:17: (75 bytes: <@04db56> - <@04dba1>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8447 @04db56> : 19                         load.z32
	<.main+8448 @04db57> : 04 3a 00 00                jmp <.main+8506 @04db91>
	test/lang/statementFor.ci:18: (16 bytes: <@04db5b> - <@04db6b>): if (bool(i < 2))
	<.main+8452 @04db5b> : 10 00                      dup.x1 sp(0)
	<.main+8454 @04db5d> : 1c 02 00 00 00             load.c32 2
	<.main+8459 @04db62> : 58                         clt.i32
	<.main+8460 @04db63> : 06 08 00 00                jz <.main+8468 @04db6b>
	test/lang/statementFor.ci:19: (4 bytes: <@04db67> - <@04db6b>): continue;
	<.main+8464 @04db67> : 04 26 00 00                jmp <.main+8502 @04db8d>
	test/lang/statementFor.ci:21: (34 bytes: <@04db6b> - <@04db8d>): debug(void("for with continue", i));
	<.main+8468 @04db6b> : 1f c0 70 04 00             load.ref <@0470c0> ;"test/lang/statementFor.ci"
	<.main+8473 @04db70> : 1c 15 00 00 00             load.c32 21
	<.main+8478 @04db75> : 1c 0e 00 00 00             load.c32 14
	<.main+8483 @04db7a> : 19                         load.z32
	<.main+8484 @04db7b> : 1f 36 71 04 00             load.ref <@047136> ;"for with continue"
	<.main+8489 @04db80> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8494 @04db85> : 0a 18 00 00                load.sp(+24)
	<.main+8498 @04db89> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@04db8d> - <@04db91>): int32(i := int32(i + 1))
	<.main+8502 @04db8d> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@04db91> - <@04db9d>): bool(i < 7)
	<.main+8506 @04db91> : 10 00                      dup.x1 sp(0)
	<.main+8508 @04db93> : 1c 07 00 00 00             load.c32 7
	<.main+8513 @04db98> : 58                         clt.i32
	<.main+8514 @04db99> : 05 c2 ff ff                jnz <.main+8452 @04db5b>
	<.main+8518 @04db9d> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@04dba1> - <@04dbec>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8522 @04dba1> : 19                         load.z32
	<.main+8523 @04dba2> : 04 3a 00 00                jmp <.main+8581 @04dbdc>
	test/lang/statementFor.ci:25: (16 bytes: <@04dba6> - <@04dbb6>): if (bool(i > 2))
	<.main+8527 @04dba6> : 10 00                      dup.x1 sp(0)
	<.main+8529 @04dba8> : 1c 02 00 00 00             load.c32 2
	<.main+8534 @04dbad> : 59                         cgt.i32
	<.main+8535 @04dbae> : 06 08 00 00                jz <.main+8543 @04dbb6>
	test/lang/statementFor.ci:26: (4 bytes: <@04dbb2> - <@04dbb6>): break;
	<.main+8539 @04dbb2> : 04 36 00 00                jmp <.main+8593 @04dbe8>
	test/lang/statementFor.ci:28: (34 bytes: <@04dbb6> - <@04dbd8>): debug(void("for with break", i));
	<.main+8543 @04dbb6> : 1f c0 70 04 00             load.ref <@0470c0> ;"test/lang/statementFor.ci"
	<.main+8548 @04dbbb> : 1c 1c 00 00 00             load.c32 28
	<.main+8553 @04dbc0> : 1c 0e 00 00 00             load.c32 14
	<.main+8558 @04dbc5> : 19                         load.z32
	<.main+8559 @04dbc6> : 1f 48 71 04 00             load.ref <@047148> ;"for with break"
	<.main+8564 @04dbcb> : 1f a0 03 00 00             load.ref <@0003a0> ;int32
	<.main+8569 @04dbd0> : 0a 18 00 00                load.sp(+24)
	<.main+8573 @04dbd4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@04dbd8> - <@04dbdc>): int32(i := int32(i + 1))
	<.main+8577 @04dbd8> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@04dbdc> - <@04dbe8>): bool(i < 7)
	<.main+8581 @04dbdc> : 10 00                      dup.x1 sp(0)
	<.main+8583 @04dbde> : 1c 07 00 00 00             load.c32 7
	<.main+8588 @04dbe3> : 58                         clt.i32
	<.main+8589 @04dbe4> : 05 c2 ff ff                jnz <.main+8527 @04dba6>
	<.main+8593 @04dbe8> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@04dbec> - <@04dc00>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8597 @04dbec> : 1a                         load.z64
	<.main+8598 @04dbed> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8607 @04dbf6> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8612 @04dbfb> : 02                         call
	<.main+8613 @04dbfc> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@04dc00> - <@04dc14>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8617 @04dc00> : 1a                         load.z64
	<.main+8618 @04dc01> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8627 @04dc0a> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8632 @04dc0f> : 02                         call
	<.main+8633 @04dc10> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@04dc14> - <@04dc28>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8637 @04dc14> : 1a                         load.z64
	<.main+8638 @04dc15> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8647 @04dc1e> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8652 @04dc23> : 02                         call
	<.main+8653 @04dc24> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@04dc28> - <@04dc3c>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8657 @04dc28> : 1a                         load.z64
	<.main+8658 @04dc29> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8667 @04dc32> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8672 @04dc37> : 02                         call
	<.main+8673 @04dc38> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@04dc3c> - <@04dc50>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8677 @04dc3c> : 1a                         load.z64
	<.main+8678 @04dc3d> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8687 @04dc46> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8692 @04dc4b> : 02                         call
	<.main+8693 @04dc4c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@04dc50> - <@04dc64>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8697 @04dc50> : 1a                         load.z64
	<.main+8698 @04dc51> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8707 @04dc5a> : 1f 70 a7 04 00             load.ref <@04a770> ;Math.floor(x: float64): float64
	<.main+8712 @04dc5f> : 02                         call
	<.main+8713 @04dc60> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (21 bytes: <@04dc64> - <@04dc79>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8717 @04dc64> : 19                         load.z32
	<.main+8718 @04dc65> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8727 @04dc6e> : 1f b0 a7 04 00             load.ref <@04a7b0> ;Math.sign(x: float64): int32
	<.main+8732 @04dc73> : 02                         call
	<.main+8733 @04dc74> : 09 f8 ff ff                inc.sp(-8)
	<.main+8737 @04dc78> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (13 bytes: <@04dc79> - <@04dc86>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8738 @04dc79> : 19                         load.z32
	<.main+8739 @04dc7a> : 1a                         load.z64
	<.main+8740 @04dc7b> : 1f b0 a7 04 00             load.ref <@04a7b0> ;Math.sign(x: float64): int32
	<.main+8745 @04dc80> : 02                         call
	<.main+8746 @04dc81> : 09 f8 ff ff                inc.sp(-8)
	<.main+8750 @04dc85> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (21 bytes: <@04dc86> - <@04dc9b>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8751 @04dc86> : 19                         load.z32
	<.main+8752 @04dc87> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8761 @04dc90> : 1f b0 a7 04 00             load.ref <@04a7b0> ;Math.sign(x: float64): int32
	<.main+8766 @04dc95> : 02                         call
	<.main+8767 @04dc96> : 09 f8 ff ff                inc.sp(-8)
	<.main+8771 @04dc9a> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@04dc9b> - <@04dcac>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8772 @04dc9b> : 19                         load.z32
	<.main+8773 @04dc9c> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8778 @04dca1> : 1f 88 a7 04 00             load.ref <@04a788> ;Math.sign(x: float32): int32
	<.main+8783 @04dca6> : 02                         call
	<.main+8784 @04dca7> : 09 fc ff ff                inc.sp(-4)
	<.main+8788 @04dcab> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@04dcac> - <@04dcb9>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8789 @04dcac> : 19                         load.z32
	<.main+8790 @04dcad> : 19                         load.z32
	<.main+8791 @04dcae> : 1f 88 a7 04 00             load.ref <@04a788> ;Math.sign(x: float32): int32
	<.main+8796 @04dcb3> : 02                         call
	<.main+8797 @04dcb4> : 09 fc ff ff                inc.sp(-4)
	<.main+8801 @04dcb8> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@04dcb9> - <@04dcca>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8802 @04dcb9> : 19                         load.z32
	<.main+8803 @04dcba> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8808 @04dcbf> : 1f 88 a7 04 00             load.ref <@04a788> ;Math.sign(x: float32): int32
	<.main+8813 @04dcc4> : 02                         call
	<.main+8814 @04dcc5> : 09 fc ff ff                inc.sp(-4)
	<.main+8818 @04dcc9> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@04dcca> - <@04dcde>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8819 @04dcca> : 1a                         load.z64
	<.main+8820 @04dccb> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8829 @04dcd4> : 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<.main+8834 @04dcd9> : 02                         call
	<.main+8835 @04dcda> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@04dcde> - <@04dce9>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8839 @04dcde> : 1b                         load.z128
	<.main+8840 @04dcdf> : 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<.main+8845 @04dce4> : 02                         call
	<.main+8846 @04dce5> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@04dce9> - <@04dcfd>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8850 @04dce9> : 1a                         load.z64
	<.main+8851 @04dcea> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8860 @04dcf3> : 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<.main+8865 @04dcf8> : 02                         call
	<.main+8866 @04dcf9> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@04dcfd> - <@04dd0e>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8870 @04dcfd> : 19                         load.z32
	<.main+8871 @04dcfe> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8876 @04dd03> : 1f d8 a7 04 00             load.ref <@04a7d8> ;Math.abs(x: float32): float32
	<.main+8881 @04dd08> : 02                         call
	<.main+8882 @04dd09> : 09 fc ff ff                inc.sp(-4)
	<.main+8886 @04dd0d> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@04dd0e> - <@04dd1b>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8887 @04dd0e> : 19                         load.z32
	<.main+8888 @04dd0f> : 19                         load.z32
	<.main+8889 @04dd10> : 1f d8 a7 04 00             load.ref <@04a7d8> ;Math.abs(x: float32): float32
	<.main+8894 @04dd15> : 02                         call
	<.main+8895 @04dd16> : 09 fc ff ff                inc.sp(-4)
	<.main+8899 @04dd1a> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@04dd1b> - <@04dd2c>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8900 @04dd1b> : 19                         load.z32
	<.main+8901 @04dd1c> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8906 @04dd21> : 1f d8 a7 04 00             load.ref <@04a7d8> ;Math.abs(x: float32): float32
	<.main+8911 @04dd26> : 02                         call
	<.main+8912 @04dd27> : 09 fc ff ff                inc.sp(-4)
	<.main+8916 @04dd2b> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@04dd2c> - <@04dd42>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8917 @04dd2c> : 19                         load.z32
	<.main+8918 @04dd2d> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8923 @04dd32> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8928 @04dd37> : 1f 48 a8 04 00             load.ref <@04a848> ;Math.min(a: float32, b: float32): float32
	<.main+8933 @04dd3c> : 02                         call
	<.main+8934 @04dd3d> : 09 f8 ff ff                inc.sp(-8)
	<.main+8938 @04dd41> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@04dd42> - <@04dd58>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8939 @04dd42> : 19                         load.z32
	<.main+8940 @04dd43> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8945 @04dd48> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8950 @04dd4d> : 1f 78 a8 04 00             load.ref <@04a878> ;Math.max(a: float32, b: float32): float32
	<.main+8955 @04dd52> : 02                         call
	<.main+8956 @04dd53> : 09 f8 ff ff                inc.sp(-8)
	<.main+8960 @04dd57> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@04dd58> - <@04dd75>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8961 @04dd58> : 1a                         load.z64
	<.main+8962 @04dd59> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8971 @04dd62> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8980 @04dd6b> : 1f 60 a8 04 00             load.ref <@04a860> ;Math.min(a: float64, b: float64): float64
	<.main+8985 @04dd70> : 02                         call
	<.main+8986 @04dd71> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@04dd75> - <@04dd92>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8990 @04dd75> : 1a                         load.z64
	<.main+8991 @04dd76> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9000 @04dd7f> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9009 @04dd88> : 1f 90 a8 04 00             load.ref <@04a890> ;Math.max(a: float64, b: float64): float64
	<.main+9014 @04dd8d> : 02                         call
	<.main+9015 @04dd8e> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@04dd92> - <@04dda9>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9019 @04dd92> : 19                         load.z32
	<.main+9020 @04dd93> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9025 @04dd98> : 19                         load.z32
	<.main+9026 @04dd99> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9031 @04dd9e> : 1f a8 a8 04 00             load.ref <@04a8a8> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9036 @04dda3> : 02                         call
	<.main+9037 @04dda4> : 09 f4 ff ff                inc.sp(-12)
	<.main+9041 @04dda8> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@04dda9> - <@04ddc7>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9042 @04dda9> : 1a                         load.z64
	<.main+9043 @04ddaa> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9052 @04ddb3> : 1a                         load.z64
	<.main+9053 @04ddb4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9062 @04ddbd> : 1f c8 a8 04 00             load.ref <@04a8c8> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9067 @04ddc2> : 02                         call
	<.main+9068 @04ddc3> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@04ddc7> - <@04dddc>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9072 @04ddc7> : 19                         load.z32
	<.main+9073 @04ddc8> : 10 00                      dup.x1 sp(0)
	<.main+9075 @04ddca> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9080 @04ddcf> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9085 @04ddd4> : 10 03                      dup.x1 sp(3)
	<.main+9087 @04ddd6> : 72                         sub.f32
	<.main+9088 @04ddd7> : 73                         mul.f32
	<.main+9089 @04ddd8> : 71                         add.f32
	<.main+9090 @04ddd9> : 13 01                      set.x1 sp(1)
	<.main+9092 @04dddb> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@04dddc> - <@04ddf8>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9093 @04dddc> : 1a                         load.z64
	<.main+9094 @04dddd> : 11 00                      dup.x2 sp(0)
	<.main+9096 @04dddf> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9105 @04dde8> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9114 @04ddf1> : 11 06                      dup.x2 sp(6)
	<.main+9116 @04ddf3> : 82                         sub.f64
	<.main+9117 @04ddf4> : 83                         mul.f64
	<.main+9118 @04ddf5> : 81                         add.f64
	<.main+9119 @04ddf6> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (24 bytes: <@04ddf8> - <@04de10>): testMathSmooth_0f: float64 := Math.smooth(0.000000)
	<.main+9121 @04ddf8> : 19                         load.z32
	<.main+9122 @04ddf9> : 10 00                      dup.x1 sp(0)
	<.main+9124 @04ddfb> : 10 01                      dup.x1 sp(1)
	<.main+9126 @04ddfd> : 73                         mul.f32
	<.main+9127 @04ddfe> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9132 @04de03> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9137 @04de08> : 10 03                      dup.x1 sp(3)
	<.main+9139 @04de0a> : 73                         mul.f32
	<.main+9140 @04de0b> : 72                         sub.f32
	<.main+9141 @04de0c> : 73                         mul.f32
	<.main+9142 @04de0d> : 13 01                      set.x1 sp(1)
	<.main+9144 @04de0f> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (31 bytes: <@04de10> - <@04de2f>): testMathSmooth_0F: float64 := Math.smooth(0.000000)
	<.main+9145 @04de10> : 1a                         load.z64
	<.main+9146 @04de11> : 11 00                      dup.x2 sp(0)
	<.main+9148 @04de13> : 11 02                      dup.x2 sp(2)
	<.main+9150 @04de15> : 83                         mul.f64
	<.main+9151 @04de16> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9160 @04de1f> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9169 @04de28> : 11 06                      dup.x2 sp(6)
	<.main+9171 @04de2a> : 83                         mul.f64
	<.main+9172 @04de2b> : 82                         sub.f64
	<.main+9173 @04de2c> : 83                         mul.f64
	<.main+9174 @04de2d> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:37: (60 bytes: <@04de2f> - <@04de6b>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9176 @04de2f> : 19                         load.z32
	<.main+9177 @04de30> : 19                         load.z32
	<.main+9178 @04de31> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9183 @04de36> : 10 02                      dup.x1 sp(2)
	<.main+9185 @04de38> : 72                         sub.f32
	<.main+9186 @04de39> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9191 @04de3e> : 10 03                      dup.x1 sp(3)
	<.main+9193 @04de40> : 72                         sub.f32
	<.main+9194 @04de41> : 74                         div.f32
	<.main+9195 @04de42> : 19                         load.z32
	<.main+9196 @04de43> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9201 @04de48> : 1f a8 a8 04 00             load.ref <@04a8a8> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9206 @04de4d> : 02                         call
	<.main+9207 @04de4e> : 09 f4 ff ff                inc.sp(-12)
	<.main+9211 @04de52> : 10 00                      dup.x1 sp(0)
	<.main+9213 @04de54> : 10 01                      dup.x1 sp(1)
	<.main+9215 @04de56> : 73                         mul.f32
	<.main+9216 @04de57> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9221 @04de5c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9226 @04de61> : 10 03                      dup.x1 sp(3)
	<.main+9228 @04de63> : 73                         mul.f32
	<.main+9229 @04de64> : 72                         sub.f32
	<.main+9230 @04de65> : 73                         mul.f32
	<.main+9231 @04de66> : 13 01                      set.x1 sp(1)
	<.main+9233 @04de68> : 13 01                      set.x1 sp(1)
	<.main+9235 @04de6a> : 7d                         f32.2f64
	test/stdc/test.math.ci:38: (78 bytes: <@04de6b> - <@04deb9>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9236 @04de6b> : 1b                         load.z128
	<.main+9237 @04de6c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9246 @04de75> : 11 04                      dup.x2 sp(4)
	<.main+9248 @04de77> : 82                         sub.f64
	<.main+9249 @04de78> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9258 @04de81> : 11 06                      dup.x2 sp(6)
	<.main+9260 @04de83> : 82                         sub.f64
	<.main+9261 @04de84> : 84                         div.f64
	<.main+9262 @04de85> : 1a                         load.z64
	<.main+9263 @04de86> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9272 @04de8f> : 1f c8 a8 04 00             load.ref <@04a8c8> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9277 @04de94> : 02                         call
	<.main+9278 @04de95> : 09 e8 ff ff                inc.sp(-24)
	<.main+9282 @04de99> : 11 00                      dup.x2 sp(0)
	<.main+9284 @04de9b> : 11 02                      dup.x2 sp(2)
	<.main+9286 @04de9d> : 83                         mul.f64
	<.main+9287 @04de9e> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9296 @04dea7> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9305 @04deb0> : 11 06                      dup.x2 sp(6)
	<.main+9307 @04deb2> : 83                         mul.f64
	<.main+9308 @04deb3> : 82                         sub.f64
	<.main+9309 @04deb4> : 83                         mul.f64
	<.main+9310 @04deb5> : 14 02                      set.x2 sp(2)
	<.main+9312 @04deb7> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:40: (21 bytes: <@04deb9> - <@04dece>): testMathMin_nan: float64 := Math.min()
	<.main+9314 @04deb9> : 19                         load.z32
	<.main+9315 @04deba> : 0a 04 00 00                load.sp(+4)
	<.main+9319 @04debe> : 1a                         load.z64
	<.main+9320 @04debf> : 11 02                      dup.x2 sp(2)
	<.main+9322 @04dec1> : 1f e8 a8 04 00             load.ref <@04a8e8> ;Math.min(data: float64[]): float64
	<.main+9327 @04dec6> : 02                         call
	<.main+9328 @04dec7> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9331 @04deca> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@04dece> - <@04df38>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9335 @04dece> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9344 @04ded7> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9353 @04dee0> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9362 @04dee9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9371 @04def2> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9380 @04defb> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9389 @04df04> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9398 @04df0d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9407 @04df16> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9416 @04df1f> : 1c 09 00 00 00             load.c32 9
	<.main+9421 @04df24> : 0a 04 00 00                load.sp(+4)
	<.main+9425 @04df28> : 1a                         load.z64
	<.main+9426 @04df29> : 11 02                      dup.x2 sp(2)
	<.main+9428 @04df2b> : 1f e8 a8 04 00             load.ref <@04a8e8> ;Math.min(data: float64[]): float64
	<.main+9433 @04df30> : 02                         call
	<.main+9434 @04df31> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9437 @04df34> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:42: (21 bytes: <@04df38> - <@04df4d>): testMathMax_nan: float64 := Math.max()
	<.main+9441 @04df38> : 19                         load.z32
	<.main+9442 @04df39> : 0a 04 00 00                load.sp(+4)
	<.main+9446 @04df3d> : 1a                         load.z64
	<.main+9447 @04df3e> : 11 02                      dup.x2 sp(2)
	<.main+9449 @04df40> : 1f 30 a9 04 00             load.ref <@04a930> ;Math.max(data: float64[]): float64
	<.main+9454 @04df45> : 02                         call
	<.main+9455 @04df46> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9458 @04df49> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:43: (106 bytes: <@04df4d> - <@04dfb7>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9462 @04df4d> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9471 @04df56> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9480 @04df5f> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9489 @04df68> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9498 @04df71> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9507 @04df7a> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9516 @04df83> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9525 @04df8c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9534 @04df95> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9543 @04df9e> : 1c 09 00 00 00             load.c32 9
	<.main+9548 @04dfa3> : 0a 04 00 00                load.sp(+4)
	<.main+9552 @04dfa7> : 1a                         load.z64
	<.main+9553 @04dfa8> : 11 02                      dup.x2 sp(2)
	<.main+9555 @04dfaa> : 1f 30 a9 04 00             load.ref <@04a930> ;Math.max(data: float64[]): float64
	<.main+9560 @04dfaf> : 02                         call
	<.main+9561 @04dfb0> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9564 @04dfb3> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:45: (21 bytes: <@04dfb7> - <@04dfcc>): testMathSum_0: float64 := Math.sum()
	<.main+9568 @04dfb7> : 19                         load.z32
	<.main+9569 @04dfb8> : 0a 04 00 00                load.sp(+4)
	<.main+9573 @04dfbc> : 1a                         load.z64
	<.main+9574 @04dfbd> : 11 02                      dup.x2 sp(2)
	<.main+9576 @04dfbf> : 1f 78 a9 04 00             load.ref <@04a978> ;Math.sum(data: float64[]): float64
	<.main+9581 @04dfc4> : 02                         call
	<.main+9582 @04dfc5> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9585 @04dfc8> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:46: (34 bytes: <@04dfcc> - <@04dfee>): testMathSum_1: float64 := Math.sum(1)
	<.main+9589 @04dfcc> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9598 @04dfd5> : 1c 01 00 00 00             load.c32 1
	<.main+9603 @04dfda> : 0a 04 00 00                load.sp(+4)
	<.main+9607 @04dfde> : 1a                         load.z64
	<.main+9608 @04dfdf> : 11 02                      dup.x2 sp(2)
	<.main+9610 @04dfe1> : 1f 78 a9 04 00             load.ref <@04a978> ;Math.sum(data: float64[]): float64
	<.main+9615 @04dfe6> : 02                         call
	<.main+9616 @04dfe7> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9619 @04dfea> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:47: (43 bytes: <@04dfee> - <@04e019>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9623 @04dfee> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9632 @04dff7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9641 @04e000> : 1c 02 00 00 00             load.c32 2
	<.main+9646 @04e005> : 0a 04 00 00                load.sp(+4)
	<.main+9650 @04e009> : 1a                         load.z64
	<.main+9651 @04e00a> : 11 02                      dup.x2 sp(2)
	<.main+9653 @04e00c> : 1f 78 a9 04 00             load.ref <@04a978> ;Math.sum(data: float64[]): float64
	<.main+9658 @04e011> : 02                         call
	<.main+9659 @04e012> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9662 @04e015> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:48: (115 bytes: <@04e019> - <@04e08c>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9666 @04e019> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9675 @04e022> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9684 @04e02b> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9693 @04e034> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9702 @04e03d> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9711 @04e046> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9720 @04e04f> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9729 @04e058> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9738 @04e061> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9747 @04e06a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9756 @04e073> : 1c 0a 00 00 00             load.c32 10
	<.main+9761 @04e078> : 0a 04 00 00                load.sp(+4)
	<.main+9765 @04e07c> : 1a                         load.z64
	<.main+9766 @04e07d> : 11 02                      dup.x2 sp(2)
	<.main+9768 @04e07f> : 1f 78 a9 04 00             load.ref <@04a978> ;Math.sum(data: float64[]): float64
	<.main+9773 @04e084> : 02                         call
	<.main+9774 @04e085> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9777 @04e088> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:50: (9 bytes: <@04e08c> - <@04e095>): testMathEval_x: float64 := 10
	<.main+9781 @04e08c> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:51: (23 bytes: <@04e095> - <@04e0ac>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9790 @04e095> : 19                         load.z32
	<.main+9791 @04e096> : 0a 04 00 00                load.sp(+4)
	<.main+9795 @04e09a> : 1a                         load.z64
	<.main+9796 @04e09b> : 11 04                      dup.x2 sp(4)
	<.main+9798 @04e09d> : 11 04                      dup.x2 sp(4)
	<.main+9800 @04e09f> : 1f a0 a9 04 00             load.ref <@04a9a0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9805 @04e0a4> : 02                         call
	<.main+9806 @04e0a5> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9809 @04e0a8> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:52: (9 bytes: <@04e0ac> - <@04e0b5>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9813 @04e0ac> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:53: (22 bytes: <@04e0b5> - <@04e0cb>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9822 @04e0b5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9831 @04e0be> : 11 06                      dup.x2 sp(6)
	<.main+9833 @04e0c0> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9842 @04e0c9> : 83                         mul.f64
	<.main+9843 @04e0ca> : 81                         add.f64
	test/stdc/test.math.ci:54: (39 bytes: <@04e0cb> - <@04e0f2>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9844 @04e0cb> : 11 06                      dup.x2 sp(6)
	<.main+9846 @04e0cd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9855 @04e0d6> : 11 02                      dup.x2 sp(2)
	<.main+9857 @04e0d8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9866 @04e0e1> : 11 06                      dup.x2 sp(6)
	<.main+9868 @04e0e3> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9877 @04e0ec> : 83                         mul.f64
	<.main+9878 @04e0ed> : 81                         add.f64
	<.main+9879 @04e0ee> : 83                         mul.f64
	<.main+9880 @04e0ef> : 81                         add.f64
	<.main+9881 @04e0f0> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:55: (56 bytes: <@04e0f2> - <@04e12a>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9883 @04e0f2> : 11 08                      dup.x2 sp(8)
	<.main+9885 @04e0f4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9894 @04e0fd> : 11 02                      dup.x2 sp(2)
	<.main+9896 @04e0ff> : 11 04                      dup.x2 sp(4)
	<.main+9898 @04e101> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9907 @04e10a> : 11 02                      dup.x2 sp(2)
	<.main+9909 @04e10c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9918 @04e115> : 11 06                      dup.x2 sp(6)
	<.main+9920 @04e117> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9929 @04e120> : 83                         mul.f64
	<.main+9930 @04e121> : 81                         add.f64
	<.main+9931 @04e122> : 83                         mul.f64
	<.main+9932 @04e123> : 81                         add.f64
	<.main+9933 @04e124> : 14 02                      set.x2 sp(2)
	<.main+9935 @04e126> : 83                         mul.f64
	<.main+9936 @04e127> : 81                         add.f64
	<.main+9937 @04e128> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:56: (72 bytes: <@04e12a> - <@04e172>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9939 @04e12a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9948 @04e133> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9957 @04e13c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9966 @04e145> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9975 @04e14e> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9984 @04e157> : 1c 05 00 00 00             load.c32 5
	<.main+9989 @04e15c> : 0a 04 00 00                load.sp(+4)
	<.main+9993 @04e160> : 1a                         load.z64
	<.main+9994 @04e161> : 11 18                      dup.x2 sp(24)
	<.main+9996 @04e163> : 11 04                      dup.x2 sp(4)
	<.main+9998 @04e165> : 1f a0 a9 04 00             load.ref <@04a9a0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10003 @04e16a>: 02                         call
	<.main+10004 @04e16b>: 17 10 04                   mov.x2 sp(16, 4)
	<.main+10007 @04e16e>: 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:57: (81 bytes: <@04e172> - <@04e1c3>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10011 @04e172>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10020 @04e17b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10029 @04e184>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10038 @04e18d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10047 @04e196>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10056 @04e19f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10065 @04e1a8>: 1c 06 00 00 00             load.c32 6
	<.main+10070 @04e1ad>: 0a 04 00 00                load.sp(+4)
	<.main+10074 @04e1b1>: 1a                         load.z64
	<.main+10075 @04e1b2>: 11 1c                      dup.x2 sp(28)
	<.main+10077 @04e1b4>: 11 04                      dup.x2 sp(4)
	<.main+10079 @04e1b6>: 1f a0 a9 04 00             load.ref <@04a9a0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10084 @04e1bb>: 02                         call
	<.main+10085 @04e1bc>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10088 @04e1bf>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:59: (31 bytes: <@04e1c3> - <@04e1e2>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10092 @04e1c3>: 1a                         load.z64
	<.main+10093 @04e1c4>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10102 @04e1cd>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10111 @04e1d6>: 84                         div.f64
	<.main+10112 @04e1d7>: 19                         load.z32
	<.main+10113 @04e1d8>: 1f 50 aa 04 00             load.ref <@04aa50> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10118 @04e1dd>: 02                         call
	<.main+10119 @04e1de>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:60: (45 bytes: <@04e1e2> - <@04e20f>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10123 @04e1e2>: 1b                         load.z128
	<.main+10124 @04e1e3>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10133 @04e1ec>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10142 @04e1f5>: 84                         div.f64
	<.main+10143 @04e1f6>: 1f f0 a7 04 00             load.ref <@04a7f0> ;Math.abs(x: float64): float64
	<.main+10148 @04e1fb>: 02                         call
	<.main+10149 @04e1fc>: 09 f8 ff ff                inc.sp(-8)
	<.main+10153 @04e200>: 1c 01 00 00 00             load.c32 1
	<.main+10158 @04e205>: 1f 50 aa 04 00             load.ref <@04aa50> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10163 @04e20a>: 02                         call
	<.main+10164 @04e20b>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:61: (30 bytes: <@04e20f> - <@04e22d>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10168 @04e20f>: 1a                         load.z64
	<.main+10169 @04e210>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10178 @04e219>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10187 @04e222>: 84                         div.f64
	<.main+10188 @04e223>: 1f a0 ab 04 00             load.ref <@04aba0> ;Math.tan(arg: float64): float64
	<.main+10193 @04e228>: 02                         call
	<.main+10194 @04e229>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:62: (30 bytes: <@04e22d> - <@04e24b>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10198 @04e22d>: 1a                         load.z64
	<.main+10199 @04e22e>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10208 @04e237>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10217 @04e240>: 84                         div.f64
	<.main+10218 @04e241>: 1f 18 ad 04 00             load.ref <@04ad18> ;Math.sinh(x: float64): float64
	<.main+10223 @04e246>: 02                         call
	<.main+10224 @04e247>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (30 bytes: <@04e24b> - <@04e269>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10228 @04e24b>: 1a                         load.z64
	<.main+10229 @04e24c>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10238 @04e255>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10247 @04e25e>: 84                         div.f64
	<.main+10248 @04e25f>: 1f 10 ae 04 00             load.ref <@04ae10> ;Math.cosh(x: float64): float64
	<.main+10253 @04e264>: 02                         call
	<.main+10254 @04e265>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:65: (20 bytes: <@04e269> - <@04e27d>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10258 @04e269>: 1a                         load.z64
	<.main+10259 @04e26a>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10268 @04e273>: 1f 60 ae 04 00             load.ref <@04ae60> ;Math.asin(x: float64): float64
	<.main+10273 @04e278>: 02                         call
	<.main+10274 @04e279>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:66: (40 bytes: <@04e27d> - <@04e2a5>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10278 @04e27d>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10287 @04e286>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10296 @04e28f>: 84                         div.f64
	<.main+10297 @04e290>: 1a                         load.z64
	<.main+10298 @04e291>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10307 @04e29a>: 1f 60 ae 04 00             load.ref <@04ae60> ;Math.asin(x: float64): float64
	<.main+10312 @04e29f>: 02                         call
	<.main+10313 @04e2a0>: 09 f8 ff ff                inc.sp(-8)
	<.main+10317 @04e2a4>: 82                         sub.f64
	test/stdc/test.math.ci:69: (28 bytes: <@04e2a5> - <@04e2c1>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10318 @04e2a5>: 19                         load.z32
	<.main+10319 @04e2a6>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10324 @04e2ab>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10329 @04e2b0>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10334 @04e2b5>: 1f d0 a9 04 00             load.ref <@04a9d0> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10339 @04e2ba>: 02                         call
	<.main+10340 @04e2bb>: 09 f4 ff ff                inc.sp(-12)
	<.main+10344 @04e2bf>: 19                         load.z32
	<.main+10345 @04e2c0>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (40 bytes: <@04e2c1> - <@04e2e9>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10346 @04e2c1>: 19                         load.z32
	<.main+10347 @04e2c2>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10356 @04e2cb>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10365 @04e2d4>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10374 @04e2dd>: 1f 10 aa 04 00             load.ref <@04aa10> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10379 @04e2e2>: 02                         call
	<.main+10380 @04e2e3>: 09 e8 ff ff                inc.sp(-24)
	<.main+10384 @04e2e7>: 19                         load.z32
	<.main+10385 @04e2e8>: 57                         ceq.i32
	test/stdc/test.math.ci:72: (29 bytes: <@04e2e9> - <@04e306>): testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10386 @04e2e9>: 1a                         load.z64
	<.main+10387 @04e2ea>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10396 @04e2f3>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10405 @04e2fc>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10410 @04e301>: 02                         call
	<.main+10411 @04e302>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:73: (20 bytes: <@04e306> - <@04e31a>): testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+10415 @04e306>: 1b                         load.z128
	<.main+10416 @04e307>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10425 @04e310>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10430 @04e315>: 02                         call
	<.main+10431 @04e316>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:74: (29 bytes: <@04e31a> - <@04e337>): testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+10435 @04e31a>: 1a                         load.z64
	<.main+10436 @04e31b>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+10445 @04e324>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10454 @04e32d>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10459 @04e332>: 02                         call
	<.main+10460 @04e333>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:76: (29 bytes: <@04e337> - <@04e354>): testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+10464 @04e337>: 1a                         load.z64
	<.main+10465 @04e338>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+10474 @04e341>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10483 @04e34a>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10488 @04e34f>: 02                         call
	<.main+10489 @04e350>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:77: (29 bytes: <@04e354> - <@04e371>): testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+10493 @04e354>: 1a                         load.z64
	<.main+10494 @04e355>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10503 @04e35e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10512 @04e367>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10517 @04e36c>: 02                         call
	<.main+10518 @04e36d>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:78: (29 bytes: <@04e371> - <@04e38e>): testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+10522 @04e371>: 1a                         load.z64
	<.main+10523 @04e372>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+10532 @04e37b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10541 @04e384>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10546 @04e389>: 02                         call
	<.main+10547 @04e38a>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:79: (29 bytes: <@04e38e> - <@04e3ab>): testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+10551 @04e38e>: 1a                         load.z64
	<.main+10552 @04e38f>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+10561 @04e398>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10570 @04e3a1>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10575 @04e3a6>: 02                         call
	<.main+10576 @04e3a7>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:81: (29 bytes: <@04e3ab> - <@04e3c8>): testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+10580 @04e3ab>: 1a                         load.z64
	<.main+10581 @04e3ac>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+10590 @04e3b5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10599 @04e3be>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10604 @04e3c3>: 02                         call
	<.main+10605 @04e3c4>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:82: (29 bytes: <@04e3c8> - <@04e3e5>): testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+10609 @04e3c8>: 1a                         load.z64
	<.main+10610 @04e3c9>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10619 @04e3d2>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10628 @04e3db>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10633 @04e3e0>: 02                         call
	<.main+10634 @04e3e1>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:83: (29 bytes: <@04e3e5> - <@04e402>): testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+10638 @04e3e5>: 1a                         load.z64
	<.main+10639 @04e3e6>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+10648 @04e3ef>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10657 @04e3f8>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10662 @04e3fd>: 02                         call
	<.main+10663 @04e3fe>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:84: (29 bytes: <@04e402> - <@04e41f>): testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+10667 @04e402>: 1a                         load.z64
	<.main+10668 @04e403>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+10677 @04e40c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10686 @04e415>: 1f 28 a8 04 00             load.ref <@04a828> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10691 @04e41a>: 02                         call
	<.main+10692 @04e41b>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:86: (21 bytes: <@04e41f> - <@04e434>): testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+10696 @04e41f>: 19                         load.z32
	<.main+10697 @04e420>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10702 @04e425>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10707 @04e42a>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10712 @04e42f>: 02                         call
	<.main+10713 @04e430>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:87: (17 bytes: <@04e434> - <@04e445>): testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+10717 @04e434>: 19                         load.z32
	<.main+10718 @04e435>: 19                         load.z32
	<.main+10719 @04e436>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10724 @04e43b>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10729 @04e440>: 02                         call
	<.main+10730 @04e441>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:88: (21 bytes: <@04e445> - <@04e45a>): testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+10734 @04e445>: 19                         load.z32
	<.main+10735 @04e446>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+10740 @04e44b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10745 @04e450>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10750 @04e455>: 02                         call
	<.main+10751 @04e456>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:90: (21 bytes: <@04e45a> - <@04e46f>): testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+10755 @04e45a>: 19                         load.z32
	<.main+10756 @04e45b>: 7f 00 00 98 41             load.f32 19.000000
	<.main+10761 @04e460>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10766 @04e465>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10771 @04e46a>: 02                         call
	<.main+10772 @04e46b>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:91: (21 bytes: <@04e46f> - <@04e484>): testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+10776 @04e46f>: 19                         load.z32
	<.main+10777 @04e470>: 7f 00 00 10 41             load.f32 9.000000
	<.main+10782 @04e475>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10787 @04e47a>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10792 @04e47f>: 02                         call
	<.main+10793 @04e480>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:92: (21 bytes: <@04e484> - <@04e499>): testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+10797 @04e484>: 19                         load.z32
	<.main+10798 @04e485>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+10803 @04e48a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10808 @04e48f>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10813 @04e494>: 02                         call
	<.main+10814 @04e495>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:93: (21 bytes: <@04e499> - <@04e4ae>): testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+10818 @04e499>: 19                         load.z32
	<.main+10819 @04e49a>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+10824 @04e49f>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10829 @04e4a4>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10834 @04e4a9>: 02                         call
	<.main+10835 @04e4aa>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:95: (21 bytes: <@04e4ae> - <@04e4c3>): testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+10839 @04e4ae>: 19                         load.z32
	<.main+10840 @04e4af>: 7f 00 00 90 41             load.f32 18.000000
	<.main+10845 @04e4b4>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10850 @04e4b9>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10855 @04e4be>: 02                         call
	<.main+10856 @04e4bf>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:96: (21 bytes: <@04e4c3> - <@04e4d8>): testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+10860 @04e4c3>: 19                         load.z32
	<.main+10861 @04e4c4>: 7f 00 00 00 41             load.f32 8.000000
	<.main+10866 @04e4c9>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10871 @04e4ce>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10876 @04e4d3>: 02                         call
	<.main+10877 @04e4d4>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:97: (21 bytes: <@04e4d8> - <@04e4ed>): testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+10881 @04e4d8>: 19                         load.z32
	<.main+10882 @04e4d9>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+10887 @04e4de>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10892 @04e4e3>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10897 @04e4e8>: 02                         call
	<.main+10898 @04e4e9>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:98: (21 bytes: <@04e4ed> - <@04e502>): testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+10902 @04e4ed>: 19                         load.z32
	<.main+10903 @04e4ee>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+10908 @04e4f3>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10913 @04e4f8>: 1f 08 a8 04 00             load.ref <@04a808> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10918 @04e4fd>: 02                         call
	<.main+10919 @04e4fe>: 09 f8 ff ff                inc.sp(-8)
	<.main+10923 @04e502>: 01 00 00 00                nfc(0) ;halt(): void
.references:
}

---------- Execute: byte-code
[ 222.81] > .main
[ 223.21]  > funAdd(x: int32, y: int32): int32
[ 223.22]  < return
[ 223.24]  > funAdd(x: int32, y: int32): int32
[ 223.25]  < return
[ 223.26]  > funMul(x: int32, y: int32): int32
[ 223.26]  < return
[ 223.28]  > funMul(x: int32, y: int32): int32
[ 223.29]  < return
[ 223.30]  > fib(n: uint32): uint32
[ 223.31]   > fib(n: uint32): uint32
[ 223.32]    > fib(n: uint32): uint32
[ 223.33]     > fib(n: uint32): uint32
[ 223.34]      > fib(n: uint32): uint32
[ 223.35]       > fib(n: uint32): uint32
[ 223.36]        > fib(n: uint32): uint32
[ 223.37]         > fib(n: uint32): uint32
[ 223.38]          > fib(n: uint32): uint32
[ 223.39]           > fib(n: uint32): uint32
[ 223.40]            > fib(n: uint32): uint32
[ 223.41]             > fib(n: uint32): uint32
[ 223.42]              > fib(n: uint32): uint32
[ 223.43]              < return
[ 223.44]              > fib(n: uint32): uint32
[ 223.44]              < return
[ 223.45]             < return
[ 223.46]             > fib(n: uint32): uint32
[ 223.47]             < return
[ 223.48]            < return
[ 223.48]            > fib(n: uint32): uint32
[ 223.49]             > fib(n: uint32): uint32
[ 223.50]             < return
[ 223.51]             > fib(n: uint32): uint32
[ 223.52]             < return
[ 223.53]            < return
[ 223.53]           < return
[ 223.54]           > fib(n: uint32): uint32
[ 223.55]            > fib(n: uint32): uint32
[ 223.56]             > fib(n: uint32): uint32
[ 223.57]             < return
[ 223.58]             > fib(n: uint32): uint32
[ 223.59]             < return
[ 223.59]            < return
[ 223.60]            > fib(n: uint32): uint32
[ 223.61]            < return
[ 223.62]           < return
[ 223.62]          < return
[ 223.63]          > fib(n: uint32): uint32
[ 223.64]           > fib(n: uint32): uint32
[ 223.65]            > fib(n: uint32): uint32
[ 223.66]             > fib(n: uint32): uint32
[ 223.67]             < return
[ 223.68]             > fib(n: uint32): uint32
[ 223.69]             < return
[ 223.70]            < return
[ 223.70]            > fib(n: uint32): uint32
[ 223.71]            < return
[ 223.72]           < return
[ 223.73]           > fib(n: uint32): uint32
[ 223.74]            > fib(n: uint32): uint32
[ 223.75]            < return
[ 223.76]            > fib(n: uint32): uint32
[ 223.77]            < return
[ 223.77]           < return
[ 223.78]          < return
[ 223.79]         < return
[ 223.79]         > fib(n: uint32): uint32
[ 223.81]          > fib(n: uint32): uint32
[ 223.81]           > fib(n: uint32): uint32
[ 223.82]            > fib(n: uint32): uint32
[ 223.84]             > fib(n: uint32): uint32
[ 223.84]             < return
[ 223.85]             > fib(n: uint32): uint32
[ 223.86]             < return
[ 223.87]            < return
[ 223.88]            > fib(n: uint32): uint32
[ 223.88]            < return
[ 223.89]           < return
[ 223.90]           > fib(n: uint32): uint32
[ 223.91]            > fib(n: uint32): uint32
[ 223.92]            < return
[ 223.93]            > fib(n: uint32): uint32
[ 223.94]            < return
[ 223.94]           < return
[ 223.95]          < return
[ 223.96]          > fib(n: uint32): uint32
[ 223.97]           > fib(n: uint32): uint32
[ 223.98]            > fib(n: uint32): uint32
[ 223.99]            < return
[ 223.99]            > fib(n: uint32): uint32
[ 224.00]            < return
[ 224.01]           < return
[ 224.02]           > fib(n: uint32): uint32
[ 224.03]           < return
[ 224.03]          < return
[ 224.04]         < return
[ 224.05]        < return
[ 224.06]        > fib(n: uint32): uint32
[ 224.06]         > fib(n: uint32): uint32
[ 224.08]          > fib(n: uint32): uint32
[ 224.09]           > fib(n: uint32): uint32
[ 224.10]            > fib(n: uint32): uint32
[ 224.11]             > fib(n: uint32): uint32
[ 224.12]             < return
[ 224.12]             > fib(n: uint32): uint32
[ 224.13]             < return
[ 224.14]            < return
[ 224.15]            > fib(n: uint32): uint32
[ 224.16]            < return
[ 224.16]           < return
[ 224.17]           > fib(n: uint32): uint32
[ 224.18]            > fib(n: uint32): uint32
[ 224.19]            < return
[ 224.20]            > fib(n: uint32): uint32
[ 224.21]            < return
[ 224.21]           < return
[ 224.22]          < return
[ 224.23]          > fib(n: uint32): uint32
[ 224.24]           > fib(n: uint32): uint32
[ 224.25]            > fib(n: uint32): uint32
[ 224.26]            < return
[ 224.26]            > fib(n: uint32): uint32
[ 224.27]            < return
[ 224.29]           < return
[ 224.30]           > fib(n: uint32): uint32
[ 224.31]           < return
[ 224.31]          < return
[ 224.32]         < return
[ 224.33]         > fib(n: uint32): uint32
[ 224.34]          > fib(n: uint32): uint32
[ 224.35]           > fib(n: uint32): uint32
[ 224.36]            > fib(n: uint32): uint32
[ 224.37]            < return
[ 224.38]            > fib(n: uint32): uint32
[ 224.39]            < return
[ 224.39]           < return
[ 224.40]           > fib(n: uint32): uint32
[ 224.41]           < return
[ 224.42]          < return
[ 224.42]          > fib(n: uint32): uint32
[ 224.43]           > fib(n: uint32): uint32
[ 224.44]           < return
[ 224.45]           > fib(n: uint32): uint32
[ 224.46]           < return
[ 224.47]          < return
[ 224.47]         < return
[ 224.48]        < return
[ 224.49]       < return
[ 224.50]       > fib(n: uint32): uint32
[ 224.51]        > fib(n: uint32): uint32
[ 224.52]         > fib(n: uint32): uint32
[ 224.53]          > fib(n: uint32): uint32
[ 224.54]           > fib(n: uint32): uint32
[ 224.55]            > fib(n: uint32): uint32
[ 224.56]             > fib(n: uint32): uint32
[ 224.56]             < return
[ 224.57]             > fib(n: uint32): uint32
[ 224.58]             < return
[ 224.59]            < return
[ 224.60]            > fib(n: uint32): uint32
[ 224.61]            < return
[ 224.61]           < return
[ 224.62]           > fib(n: uint32): uint32
[ 224.63]            > fib(n: uint32): uint32
[ 224.64]            < return
[ 224.65]            > fib(n: uint32): uint32
[ 224.66]            < return
[ 224.66]           < return
[ 224.67]          < return
[ 224.68]          > fib(n: uint32): uint32
[ 224.69]           > fib(n: uint32): uint32
[ 224.70]            > fib(n: uint32): uint32
[ 224.71]            < return
[ 224.72]            > fib(n: uint32): uint32
[ 224.73]            < return
[ 224.74]           < return
[ 224.74]           > fib(n: uint32): uint32
[ 224.75]           < return
[ 224.76]          < return
[ 224.77]         < return
[ 224.77]         > fib(n: uint32): uint32
[ 224.78]          > fib(n: uint32): uint32
[ 224.79]           > fib(n: uint32): uint32
[ 224.80]            > fib(n: uint32): uint32
[ 224.81]            < return
[ 224.82]            > fib(n: uint32): uint32
[ 224.83]            < return
[ 224.84]           < return
[ 224.84]           > fib(n: uint32): uint32
[ 224.85]           < return
[ 224.86]          < return
[ 224.87]          > fib(n: uint32): uint32
[ 224.88]           > fib(n: uint32): uint32
[ 224.89]           < return
[ 224.90]           > fib(n: uint32): uint32
[ 224.90]           < return
[ 224.91]          < return
[ 224.92]         < return
[ 224.93]        < return
[ 224.93]        > fib(n: uint32): uint32
[ 224.94]         > fib(n: uint32): uint32
[ 224.95]          > fib(n: uint32): uint32
[ 224.96]           > fib(n: uint32): uint32
[ 224.97]            > fib(n: uint32): uint32
[ 224.98]            < return
[ 224.99]            > fib(n: uint32): uint32
[ 225.00]            < return
[ 225.01]           < return
[ 225.01]           > fib(n: uint32): uint32
[ 225.02]           < return
[ 225.03]          < return
[ 225.04]          > fib(n: uint32): uint32
[ 225.05]           > fib(n: uint32): uint32
[ 225.06]           < return
[ 225.06]           > fib(n: uint32): uint32
[ 225.07]           < return
[ 225.08]          < return
[ 225.09]         < return
[ 225.09]         > fib(n: uint32): uint32
[ 225.10]          > fib(n: uint32): uint32
[ 225.12]           > fib(n: uint32): uint32
[ 225.12]           < return
[ 225.13]           > fib(n: uint32): uint32
[ 225.14]           < return
[ 225.15]          < return
[ 225.16]          > fib(n: uint32): uint32
[ 225.16]          < return
[ 225.17]         < return
[ 225.18]        < return
[ 225.19]       < return
[ 225.19]      < return
[ 225.20]      > fib(n: uint32): uint32
[ 225.21]       > fib(n: uint32): uint32
[ 225.22]        > fib(n: uint32): uint32
[ 225.23]         > fib(n: uint32): uint32
[ 225.24]          > fib(n: uint32): uint32
[ 225.25]           > fib(n: uint32): uint32
[ 225.26]            > fib(n: uint32): uint32
[ 225.27]             > fib(n: uint32): uint32
[ 225.28]             < return
[ 225.29]             > fib(n: uint32): uint32
[ 225.30]             < return
[ 225.30]            < return
[ 225.31]            > fib(n: uint32): uint32
[ 225.32]            < return
[ 225.33]           < return
[ 225.34]           > fib(n: uint32): uint32
[ 225.34]            > fib(n: uint32): uint32
[ 225.35]            < return
[ 225.36]            > fib(n: uint32): uint32
[ 225.37]            < return
[ 225.38]           < return
[ 225.39]          < return
[ 225.39]          > fib(n: uint32): uint32
[ 225.40]           > fib(n: uint32): uint32
[ 225.41]            > fib(n: uint32): uint32
[ 225.42]            < return
[ 225.43]            > fib(n: uint32): uint32
[ 225.44]            < return
[ 225.45]           < return
[ 225.45]           > fib(n: uint32): uint32
[ 225.46]           < return
[ 225.47]          < return
[ 225.48]         < return
[ 225.48]         > fib(n: uint32): uint32
[ 225.50]          > fib(n: uint32): uint32
[ 225.50]           > fib(n: uint32): uint32
[ 225.51]            > fib(n: uint32): uint32
[ 225.52]            < return
[ 225.53]            > fib(n: uint32): uint32
[ 225.54]            < return
[ 225.55]           < return
[ 225.56]           > fib(n: uint32): uint32
[ 225.56]           < return
[ 225.57]          < return
[ 225.58]          > fib(n: uint32): uint32
[ 225.59]           > fib(n: uint32): uint32
[ 225.60]           < return
[ 225.60]           > fib(n: uint32): uint32
[ 225.61]           < return
[ 225.62]          < return
[ 225.63]         < return
[ 225.64]        < return
[ 225.65]        > fib(n: uint32): uint32
[ 225.66]         > fib(n: uint32): uint32
[ 225.66]          > fib(n: uint32): uint32
[ 225.68]           > fib(n: uint32): uint32
[ 225.69]            > fib(n: uint32): uint32
[ 225.69]            < return
[ 225.70]            > fib(n: uint32): uint32
[ 225.71]            < return
[ 225.72]           < return
[ 225.73]           > fib(n: uint32): uint32
[ 225.74]           < return
[ 225.74]          < return
[ 225.75]          > fib(n: uint32): uint32
[ 225.76]           > fib(n: uint32): uint32
[ 225.77]           < return
[ 225.78]           > fib(n: uint32): uint32
[ 225.79]           < return
[ 225.79]          < return
[ 225.80]         < return
[ 225.81]         > fib(n: uint32): uint32
[ 225.82]          > fib(n: uint32): uint32
[ 225.83]           > fib(n: uint32): uint32
[ 225.84]           < return
[ 225.84]           > fib(n: uint32): uint32
[ 225.85]           < return
[ 225.86]          < return
[ 225.87]          > fib(n: uint32): uint32
[ 225.88]          < return
[ 225.88]         < return
[ 225.89]        < return
[ 225.90]       < return
[ 225.91]       > fib(n: uint32): uint32
[ 225.92]        > fib(n: uint32): uint32
[ 225.93]         > fib(n: uint32): uint32
[ 225.94]          > fib(n: uint32): uint32
[ 225.95]           > fib(n: uint32): uint32
[ 225.96]            > fib(n: uint32): uint32
[ 225.97]            < return
[ 225.97]            > fib(n: uint32): uint32
[ 225.98]            < return
[ 225.99]           < return
[ 226.00]           > fib(n: uint32): uint32
[ 226.01]           < return
[ 226.01]          < return
[ 226.02]          > fib(n: uint32): uint32
[ 226.03]           > fib(n: uint32): uint32
[ 226.04]           < return
[ 226.05]           > fib(n: uint32): uint32
[ 226.06]           < return
[ 226.07]          < return
[ 226.07]         < return
[ 226.08]         > fib(n: uint32): uint32
[ 226.09]          > fib(n: uint32): uint32
[ 226.10]           > fib(n: uint32): uint32
[ 226.11]           < return
[ 226.12]           > fib(n: uint32): uint32
[ 226.13]           < return
[ 226.13]          < return
[ 226.14]          > fib(n: uint32): uint32
[ 226.15]          < return
[ 226.16]         < return
[ 226.16]        < return
[ 226.17]        > fib(n: uint32): uint32
[ 226.18]         > fib(n: uint32): uint32
[ 226.19]          > fib(n: uint32): uint32
[ 226.20]           > fib(n: uint32): uint32
[ 226.21]           < return
[ 226.22]           > fib(n: uint32): uint32
[ 226.23]           < return
[ 226.24]          < return
[ 226.24]          > fib(n: uint32): uint32
[ 226.25]          < return
[ 226.26]         < return
[ 226.27]         > fib(n: uint32): uint32
[ 226.28]          > fib(n: uint32): uint32
[ 226.28]          < return
[ 226.29]          > fib(n: uint32): uint32
[ 226.30]          < return
[ 226.31]         < return
[ 226.32]        < return
[ 226.32]       < return
[ 226.33]      < return
[ 226.34]     < return
[ 226.34]     > fib(n: uint32): uint32
[ 226.35]      > fib(n: uint32): uint32
[ 226.36]       > fib(n: uint32): uint32
[ 226.37]        > fib(n: uint32): uint32
[ 226.38]         > fib(n: uint32): uint32
[ 226.39]          > fib(n: uint32): uint32
[ 226.40]           > fib(n: uint32): uint32
[ 226.41]            > fib(n: uint32): uint32
[ 226.43]             > fib(n: uint32): uint32
[ 226.43]             < return
[ 226.44]             > fib(n: uint32): uint32
[ 226.45]             < return
[ 226.46]            < return
[ 226.47]            > fib(n: uint32): uint32
[ 226.47]            < return
[ 226.48]           < return
[ 226.49]           > fib(n: uint32): uint32
[ 226.50]            > fib(n: uint32): uint32
[ 226.51]            < return
[ 226.51]            > fib(n: uint32): uint32
[ 226.52]            < return
[ 226.53]           < return
[ 226.54]          < return
[ 226.55]          > fib(n: uint32): uint32
[ 226.56]           > fib(n: uint32): uint32
[ 226.57]            > fib(n: uint32): uint32
[ 226.57]            < return
[ 226.58]            > fib(n: uint32): uint32
[ 226.59]            < return
[ 226.60]           < return
[ 226.61]           > fib(n: uint32): uint32
[ 226.62]           < return
[ 226.63]          < return
[ 226.63]         < return
[ 226.64]         > fib(n: uint32): uint32
[ 226.65]          > fib(n: uint32): uint32
[ 226.66]           > fib(n: uint32): uint32
[ 226.67]            > fib(n: uint32): uint32
[ 226.68]            < return
[ 226.69]            > fib(n: uint32): uint32
[ 226.70]            < return
[ 226.70]           < return
[ 226.71]           > fib(n: uint32): uint32
[ 226.72]           < return
[ 226.73]          < return
[ 226.74]          > fib(n: uint32): uint32
[ 226.75]           > fib(n: uint32): uint32
[ 226.75]           < return
[ 226.76]           > fib(n: uint32): uint32
[ 226.77]           < return
[ 226.78]          < return
[ 226.78]         < return
[ 226.79]        < return
[ 226.80]        > fib(n: uint32): uint32
[ 226.81]         > fib(n: uint32): uint32
[ 226.82]          > fib(n: uint32): uint32
[ 226.83]           > fib(n: uint32): uint32
[ 226.84]            > fib(n: uint32): uint32
[ 226.85]            < return
[ 226.86]            > fib(n: uint32): uint32
[ 226.87]            < return
[ 226.87]           < return
[ 226.88]           > fib(n: uint32): uint32
[ 226.89]           < return
[ 226.90]          < return
[ 226.90]          > fib(n: uint32): uint32
[ 226.91]           > fib(n: uint32): uint32
[ 226.92]           < return
[ 226.93]           > fib(n: uint32): uint32
[ 226.94]           < return
[ 226.95]          < return
[ 226.95]         < return
[ 226.96]         > fib(n: uint32): uint32
[ 226.97]          > fib(n: uint32): uint32
[ 226.98]           > fib(n: uint32): uint32
[ 226.99]           < return
[ 227.00]           > fib(n: uint32): uint32
[ 227.01]           < return
[ 227.01]          < return
[ 227.02]          > fib(n: uint32): uint32
[ 227.03]          < return
[ 227.04]         < return
[ 227.04]        < return
[ 227.05]       < return
[ 227.06]       > fib(n: uint32): uint32
[ 227.07]        > fib(n: uint32): uint32
[ 227.08]         > fib(n: uint32): uint32
[ 227.09]          > fib(n: uint32): uint32
[ 227.10]           > fib(n: uint32): uint32
[ 227.11]            > fib(n: uint32): uint32
[ 227.12]            < return
[ 227.13]            > fib(n: uint32): uint32
[ 227.14]            < return
[ 227.14]           < return
[ 227.15]           > fib(n: uint32): uint32
[ 227.16]           < return
[ 227.17]          < return
[ 227.18]          > fib(n: uint32): uint32
[ 227.19]           > fib(n: uint32): uint32
[ 227.19]           < return
[ 227.20]           > fib(n: uint32): uint32
[ 227.21]           < return
[ 227.22]          < return
[ 227.22]         < return
[ 227.23]         > fib(n: uint32): uint32
[ 227.24]          > fib(n: uint32): uint32
[ 227.26]           > fib(n: uint32): uint32
[ 227.26]           < return
[ 227.27]           > fib(n: uint32): uint32
[ 227.28]           < return
[ 227.29]          < return
[ 227.30]          > fib(n: uint32): uint32
[ 227.31]          < return
[ 227.31]         < return
[ 227.32]        < return
[ 227.33]        > fib(n: uint32): uint32
[ 227.34]         > fib(n: uint32): uint32
[ 227.35]          > fib(n: uint32): uint32
[ 227.36]           > fib(n: uint32): uint32
[ 227.37]           < return
[ 227.37]           > fib(n: uint32): uint32
[ 227.38]           < return
[ 227.39]          < return
[ 227.40]          > fib(n: uint32): uint32
[ 227.41]          < return
[ 227.41]         < return
[ 227.42]         > fib(n: uint32): uint32
[ 227.43]          > fib(n: uint32): uint32
[ 227.44]          < return
[ 227.45]          > fib(n: uint32): uint32
[ 227.46]          < return
[ 227.47]         < return
[ 227.47]        < return
[ 227.48]       < return
[ 227.49]      < return
[ 227.49]      > fib(n: uint32): uint32
[ 227.50]       > fib(n: uint32): uint32
[ 227.51]        > fib(n: uint32): uint32
[ 227.52]         > fib(n: uint32): uint32
[ 227.53]          > fib(n: uint32): uint32
[ 227.54]           > fib(n: uint32): uint32
[ 227.55]            > fib(n: uint32): uint32
[ 227.56]            < return
[ 227.57]            > fib(n: uint32): uint32
[ 227.58]            < return
[ 227.59]           < return
[ 227.60]           > fib(n: uint32): uint32
[ 227.61]           < return
[ 227.61]          < return
[ 227.62]          > fib(n: uint32): uint32
[ 227.63]           > fib(n: uint32): uint32
[ 227.64]           < return
[ 227.65]           > fib(n: uint32): uint32
[ 227.66]           < return
[ 227.66]          < return
[ 227.67]         < return
[ 227.68]         > fib(n: uint32): uint32
[ 227.69]          > fib(n: uint32): uint32
[ 227.70]           > fib(n: uint32): uint32
[ 227.71]           < return
[ 227.72]           > fib(n: uint32): uint32
[ 227.72]           < return
[ 227.73]          < return
[ 227.74]          > fib(n: uint32): uint32
[ 227.75]          < return
[ 227.75]         < return
[ 227.76]        < return
[ 227.77]        > fib(n: uint32): uint32
[ 227.78]         > fib(n: uint32): uint32
[ 227.79]          > fib(n: uint32): uint32
[ 227.80]           > fib(n: uint32): uint32
[ 227.81]           < return
[ 227.82]           > fib(n: uint32): uint32
[ 227.82]           < return
[ 227.83]          < return
[ 227.84]          > fib(n: uint32): uint32
[ 227.85]          < return
[ 227.86]         < return
[ 227.86]         > fib(n: uint32): uint32
[ 227.87]          > fib(n: uint32): uint32
[ 227.88]          < return
[ 227.89]          > fib(n: uint32): uint32
[ 227.90]          < return
[ 227.91]         < return
[ 227.91]        < return
[ 227.92]       < return
[ 227.93]       > fib(n: uint32): uint32
[ 227.94]        > fib(n: uint32): uint32
[ 227.95]         > fib(n: uint32): uint32
[ 227.96]          > fib(n: uint32): uint32
[ 227.97]           > fib(n: uint32): uint32
[ 227.98]           < return
[ 227.99]           > fib(n: uint32): uint32
[ 227.99]           < return
[ 228.00]          < return
[ 228.01]          > fib(n: uint32): uint32
[ 228.02]          < return
[ 228.03]         < return
[ 228.03]         > fib(n: uint32): uint32
[ 228.04]          > fib(n: uint32): uint32
[ 228.05]          < return
[ 228.06]          > fib(n: uint32): uint32
[ 228.07]          < return
[ 228.08]         < return
[ 228.08]        < return
[ 228.09]        > fib(n: uint32): uint32
[ 228.10]         > fib(n: uint32): uint32
[ 228.11]          > fib(n: uint32): uint32
[ 228.12]          < return
[ 228.13]          > fib(n: uint32): uint32
[ 228.14]          < return
[ 228.14]         < return
[ 228.15]         > fib(n: uint32): uint32
[ 228.16]         < return
[ 228.17]        < return
[ 228.17]       < return
[ 228.18]      < return
[ 228.19]     < return
[ 228.19]    < return
[ 228.20]    > fib(n: uint32): uint32
[ 228.21]     > fib(n: uint32): uint32
[ 228.22]      > fib(n: uint32): uint32
[ 228.23]       > fib(n: uint32): uint32
[ 228.24]        > fib(n: uint32): uint32
[ 228.25]         > fib(n: uint32): uint32
[ 228.26]          > fib(n: uint32): uint32
[ 228.27]           > fib(n: uint32): uint32
[ 228.29]            > fib(n: uint32): uint32
[ 228.30]             > fib(n: uint32): uint32
[ 228.31]             < return
[ 228.31]             > fib(n: uint32): uint32
[ 228.32]             < return
[ 228.33]            < return
[ 228.34]            > fib(n: uint32): uint32
[ 228.35]            < return
[ 228.35]           < return
[ 228.36]           > fib(n: uint32): uint32
[ 228.37]            > fib(n: uint32): uint32
[ 228.38]            < return
[ 228.39]            > fib(n: uint32): uint32
[ 228.40]            < return
[ 228.41]           < return
[ 228.41]          < return
[ 228.43]          > fib(n: uint32): uint32
[ 228.44]           > fib(n: uint32): uint32
[ 228.45]            > fib(n: uint32): uint32
[ 228.46]            < return
[ 228.46]            > fib(n: uint32): uint32
[ 228.47]            < return
[ 228.48]           < return
[ 228.49]           > fib(n: uint32): uint32
[ 228.50]           < return
[ 228.50]          < return
[ 228.51]         < return
[ 228.52]         > fib(n: uint32): uint32
[ 228.53]          > fib(n: uint32): uint32
[ 228.54]           > fib(n: uint32): uint32
[ 228.55]            > fib(n: uint32): uint32
[ 228.56]            < return
[ 228.57]            > fib(n: uint32): uint32
[ 228.58]            < return
[ 228.59]           < return
[ 228.59]           > fib(n: uint32): uint32
[ 228.60]           < return
[ 228.61]          < return
[ 228.62]          > fib(n: uint32): uint32
[ 228.63]           > fib(n: uint32): uint32
[ 228.63]           < return
[ 228.64]           > fib(n: uint32): uint32
[ 228.65]           < return
[ 228.66]          < return
[ 228.67]         < return
[ 228.67]        < return
[ 228.68]        > fib(n: uint32): uint32
[ 228.69]         > fib(n: uint32): uint32
[ 228.70]          > fib(n: uint32): uint32
[ 228.71]           > fib(n: uint32): uint32
[ 228.72]            > fib(n: uint32): uint32
[ 228.73]            < return
[ 228.74]            > fib(n: uint32): uint32
[ 228.75]            < return
[ 228.75]           < return
[ 228.76]           > fib(n: uint32): uint32
[ 228.77]           < return
[ 228.78]          < return
[ 228.79]          > fib(n: uint32): uint32
[ 228.80]           > fib(n: uint32): uint32
[ 228.81]           < return
[ 228.81]           > fib(n: uint32): uint32
[ 228.82]           < return
[ 228.83]          < return
[ 228.84]         < return
[ 228.84]         > fib(n: uint32): uint32
[ 228.85]          > fib(n: uint32): uint32
[ 228.86]           > fib(n: uint32): uint32
[ 228.87]           < return
[ 228.88]           > fib(n: uint32): uint32
[ 228.89]           < return
[ 228.90]          < return
[ 228.90]          > fib(n: uint32): uint32
[ 228.91]          < return
[ 228.92]         < return
[ 228.93]        < return
[ 228.93]       < return
[ 228.94]       > fib(n: uint32): uint32
[ 228.95]        > fib(n: uint32): uint32
[ 228.96]         > fib(n: uint32): uint32
[ 228.97]          > fib(n: uint32): uint32
[ 228.98]           > fib(n: uint32): uint32
[ 228.99]            > fib(n: uint32): uint32
[ 229.00]            < return
[ 229.01]            > fib(n: uint32): uint32
[ 229.02]            < return
[ 229.03]           < return
[ 229.04]           > fib(n: uint32): uint32
[ 229.04]           < return
[ 229.05]          < return
[ 229.06]          > fib(n: uint32): uint32
[ 229.07]           > fib(n: uint32): uint32
[ 229.08]           < return
[ 229.09]           > fib(n: uint32): uint32
[ 229.09]           < return
[ 229.10]          < return
[ 229.11]         < return
[ 229.12]         > fib(n: uint32): uint32
[ 229.13]          > fib(n: uint32): uint32
[ 229.14]           > fib(n: uint32): uint32
[ 229.15]           < return
[ 229.15]           > fib(n: uint32): uint32
[ 229.16]           < return
[ 229.17]          < return
[ 229.18]          > fib(n: uint32): uint32
[ 229.19]          < return
[ 229.19]         < return
[ 229.20]        < return
[ 229.21]        > fib(n: uint32): uint32
[ 229.22]         > fib(n: uint32): uint32
[ 229.23]          > fib(n: uint32): uint32
[ 229.24]           > fib(n: uint32): uint32
[ 229.25]           < return
[ 229.25]           > fib(n: uint32): uint32
[ 229.26]           < return
[ 229.27]          < return
[ 229.28]          > fib(n: uint32): uint32
[ 229.29]          < return
[ 229.29]         < return
[ 229.30]         > fib(n: uint32): uint32
[ 229.31]          > fib(n: uint32): uint32
[ 229.32]          < return
[ 229.33]          > fib(n: uint32): uint32
[ 229.34]          < return
[ 229.34]         < return
[ 229.35]        < return
[ 229.36]       < return
[ 229.37]      < return
[ 229.37]      > fib(n: uint32): uint32
[ 229.38]       > fib(n: uint32): uint32
[ 229.39]        > fib(n: uint32): uint32
[ 229.40]         > fib(n: uint32): uint32
[ 229.41]          > fib(n: uint32): uint32
[ 229.42]           > fib(n: uint32): uint32
[ 229.43]            > fib(n: uint32): uint32
[ 229.44]            < return
[ 229.45]            > fib(n: uint32): uint32
[ 229.46]            < return
[ 229.47]           < return
[ 229.47]           > fib(n: uint32): uint32
[ 229.48]           < return
[ 229.49]          < return
[ 229.50]          > fib(n: uint32): uint32
[ 229.51]           > fib(n: uint32): uint32
[ 229.52]           < return
[ 229.53]           > fib(n: uint32): uint32
[ 229.54]           < return
[ 229.54]          < return
[ 229.55]         < return
[ 229.56]         > fib(n: uint32): uint32
[ 229.57]          > fib(n: uint32): uint32
[ 229.58]           > fib(n: uint32): uint32
[ 229.59]           < return
[ 229.59]           > fib(n: uint32): uint32
[ 229.60]           < return
[ 229.61]          < return
[ 229.62]          > fib(n: uint32): uint32
[ 229.63]          < return
[ 229.63]         < return
[ 229.64]        < return
[ 229.65]        > fib(n: uint32): uint32
[ 229.66]         > fib(n: uint32): uint32
[ 229.67]          > fib(n: uint32): uint32
[ 229.68]           > fib(n: uint32): uint32
[ 229.69]           < return
[ 229.70]           > fib(n: uint32): uint32
[ 229.71]           < return
[ 229.71]          < return
[ 229.72]          > fib(n: uint32): uint32
[ 229.73]          < return
[ 229.74]         < return
[ 229.74]         > fib(n: uint32): uint32
[ 229.75]          > fib(n: uint32): uint32
[ 229.76]          < return
[ 229.77]          > fib(n: uint32): uint32
[ 229.78]          < return
[ 229.79]         < return
[ 229.79]        < return
[ 229.80]       < return
[ 229.81]       > fib(n: uint32): uint32
[ 229.82]        > fib(n: uint32): uint32
[ 229.83]         > fib(n: uint32): uint32
[ 229.84]          > fib(n: uint32): uint32
[ 229.85]           > fib(n: uint32): uint32
[ 229.86]           < return
[ 229.87]           > fib(n: uint32): uint32
[ 229.88]           < return
[ 229.88]          < return
[ 229.89]          > fib(n: uint32): uint32
[ 229.90]          < return
[ 229.91]         < return
[ 229.91]         > fib(n: uint32): uint32
[ 229.92]          > fib(n: uint32): uint32
[ 229.93]          < return
[ 229.94]          > fib(n: uint32): uint32
[ 229.95]          < return
[ 229.96]         < return
[ 229.96]        < return
[ 229.97]        > fib(n: uint32): uint32
[ 229.98]         > fib(n: uint32): uint32
[ 229.99]          > fib(n: uint32): uint32
[ 230.00]          < return
[ 230.01]          > fib(n: uint32): uint32
[ 230.02]          < return
[ 230.03]         < return
[ 230.03]         > fib(n: uint32): uint32
[ 230.04]         < return
[ 230.05]        < return
[ 230.06]       < return
[ 230.06]      < return
[ 230.07]     < return
[ 230.08]     > fib(n: uint32): uint32
[ 230.09]      > fib(n: uint32): uint32
[ 230.10]       > fib(n: uint32): uint32
[ 230.11]        > fib(n: uint32): uint32
[ 230.12]         > fib(n: uint32): uint32
[ 230.13]          > fib(n: uint32): uint32
[ 230.14]           > fib(n: uint32): uint32
[ 230.15]            > fib(n: uint32): uint32
[ 230.16]            < return
[ 230.17]            > fib(n: uint32): uint32
[ 230.18]            < return
[ 230.18]           < return
[ 230.19]           > fib(n: uint32): uint32
[ 230.20]           < return
[ 230.21]          < return
[ 230.21]          > fib(n: uint32): uint32
[ 230.22]           > fib(n: uint32): uint32
[ 230.23]           < return
[ 230.24]           > fib(n: uint32): uint32
[ 230.25]           < return
[ 230.26]          < return
[ 230.26]         < return
[ 230.27]         > fib(n: uint32): uint32
[ 230.28]          > fib(n: uint32): uint32
[ 230.29]           > fib(n: uint32): uint32
[ 230.30]           < return
[ 230.31]           > fib(n: uint32): uint32
[ 230.32]           < return
[ 230.32]          < return
[ 230.33]          > fib(n: uint32): uint32
[ 230.34]          < return
[ 230.35]         < return
[ 230.35]        < return
[ 230.36]        > fib(n: uint32): uint32
[ 230.37]         > fib(n: uint32): uint32
[ 230.38]          > fib(n: uint32): uint32
[ 230.39]           > fib(n: uint32): uint32
[ 230.40]           < return
[ 230.41]           > fib(n: uint32): uint32
[ 230.42]           < return
[ 230.43]          < return
[ 230.43]          > fib(n: uint32): uint32
[ 230.44]          < return
[ 230.45]         < return
[ 230.46]         > fib(n: uint32): uint32
[ 230.47]          > fib(n: uint32): uint32
[ 230.48]          < return
[ 230.49]          > fib(n: uint32): uint32
[ 230.50]          < return
[ 230.50]         < return
[ 230.51]        < return
[ 230.52]       < return
[ 230.52]       > fib(n: uint32): uint32
[ 230.53]        > fib(n: uint32): uint32
[ 230.54]         > fib(n: uint32): uint32
[ 230.55]          > fib(n: uint32): uint32
[ 230.56]           > fib(n: uint32): uint32
[ 230.57]           < return
[ 230.58]           > fib(n: uint32): uint32
[ 230.59]           < return
[ 230.60]          < return
[ 230.60]          > fib(n: uint32): uint32
[ 230.61]          < return
[ 230.62]         < return
[ 230.63]         > fib(n: uint32): uint32
[ 230.64]          > fib(n: uint32): uint32
[ 230.65]          < return
[ 230.65]          > fib(n: uint32): uint32
[ 230.66]          < return
[ 230.67]         < return
[ 230.68]        < return
[ 230.69]        > fib(n: uint32): uint32
[ 230.69]         > fib(n: uint32): uint32
[ 230.71]          > fib(n: uint32): uint32
[ 230.71]          < return
[ 230.72]          > fib(n: uint32): uint32
[ 230.73]          < return
[ 230.74]         < return
[ 230.75]         > fib(n: uint32): uint32
[ 230.75]         < return
[ 230.76]        < return
[ 230.77]       < return
[ 230.78]      < return
[ 230.78]      > fib(n: uint32): uint32
[ 230.79]       > fib(n: uint32): uint32
[ 230.80]        > fib(n: uint32): uint32
[ 230.81]         > fib(n: uint32): uint32
[ 230.82]          > fib(n: uint32): uint32
[ 230.83]           > fib(n: uint32): uint32
[ 230.84]           < return
[ 230.85]           > fib(n: uint32): uint32
[ 230.86]           < return
[ 230.87]          < return
[ 230.87]          > fib(n: uint32): uint32
[ 230.88]          < return
[ 230.89]         < return
[ 230.90]         > fib(n: uint32): uint32
[ 230.91]          > fib(n: uint32): uint32
[ 230.91]          < return
[ 230.92]          > fib(n: uint32): uint32
[ 230.93]          < return
[ 230.94]         < return
[ 230.95]        < return
[ 230.95]        > fib(n: uint32): uint32
[ 230.96]         > fib(n: uint32): uint32
[ 230.97]          > fib(n: uint32): uint32
[ 230.98]          < return
[ 230.99]          > fib(n: uint32): uint32
[ 231.00]          < return
[ 231.01]         < return
[ 231.01]         > fib(n: uint32): uint32
[ 231.02]         < return
[ 231.03]        < return
[ 231.04]       < return
[ 231.04]       > fib(n: uint32): uint32
[ 231.05]        > fib(n: uint32): uint32
[ 231.06]         > fib(n: uint32): uint32
[ 231.07]          > fib(n: uint32): uint32
[ 231.08]          < return
[ 231.09]          > fib(n: uint32): uint32
[ 231.10]          < return
[ 231.11]         < return
[ 231.11]         > fib(n: uint32): uint32
[ 231.12]         < return
[ 231.13]        < return
[ 231.14]        > fib(n: uint32): uint32
[ 231.15]         > fib(n: uint32): uint32
[ 231.16]         < return
[ 231.16]         > fib(n: uint32): uint32
[ 231.17]         < return
[ 231.18]        < return
[ 231.19]       < return
[ 231.20]      < return
[ 231.20]     < return
[ 231.21]    < return
[ 231.22]   < return
[ 231.22]   > fib(n: uint32): uint32
[ 231.24]    > fib(n: uint32): uint32
[ 231.25]     > fib(n: uint32): uint32
[ 231.25]      > fib(n: uint32): uint32
[ 231.26]       > fib(n: uint32): uint32
[ 231.28]        > fib(n: uint32): uint32
[ 231.28]         > fib(n: uint32): uint32
[ 231.29]          > fib(n: uint32): uint32
[ 231.31]           > fib(n: uint32): uint32
[ 231.31]            > fib(n: uint32): uint32
[ 231.32]             > fib(n: uint32): uint32
[ 231.33]             < return
[ 231.34]             > fib(n: uint32): uint32
[ 231.35]             < return
[ 231.36]            < return
[ 231.37]            > fib(n: uint32): uint32
[ 231.37]            < return
[ 231.38]           < return
[ 231.39]           > fib(n: uint32): uint32
[ 231.40]            > fib(n: uint32): uint32
[ 231.41]            < return
[ 231.41]            > fib(n: uint32): uint32
[ 231.43]            < return
[ 231.43]           < return
[ 231.44]          < return
[ 231.45]          > fib(n: uint32): uint32
[ 231.46]           > fib(n: uint32): uint32
[ 231.47]            > fib(n: uint32): uint32
[ 231.48]            < return
[ 231.49]            > fib(n: uint32): uint32
[ 231.50]            < return
[ 231.50]           < return
[ 231.51]           > fib(n: uint32): uint32
[ 231.52]           < return
[ 231.53]          < return
[ 231.53]         < return
[ 231.54]         > fib(n: uint32): uint32
[ 231.55]          > fib(n: uint32): uint32
[ 231.56]           > fib(n: uint32): uint32
[ 231.57]            > fib(n: uint32): uint32
[ 231.58]            < return
[ 231.59]            > fib(n: uint32): uint32
[ 231.60]            < return
[ 231.60]           < return
[ 231.61]           > fib(n: uint32): uint32
[ 231.62]           < return
[ 231.63]          < return
[ 231.63]          > fib(n: uint32): uint32
[ 231.65]           > fib(n: uint32): uint32
[ 231.65]           < return
[ 231.66]           > fib(n: uint32): uint32
[ 231.67]           < return
[ 231.68]          < return
[ 231.69]         < return
[ 231.69]        < return
[ 231.70]        > fib(n: uint32): uint32
[ 231.71]         > fib(n: uint32): uint32
[ 231.72]          > fib(n: uint32): uint32
[ 231.73]           > fib(n: uint32): uint32
[ 231.74]            > fib(n: uint32): uint32
[ 231.75]            < return
[ 231.76]            > fib(n: uint32): uint32
[ 231.76]            < return
[ 231.77]           < return
[ 231.78]           > fib(n: uint32): uint32
[ 231.79]           < return
[ 231.80]          < return
[ 231.80]          > fib(n: uint32): uint32
[ 231.81]           > fib(n: uint32): uint32
[ 231.82]           < return
[ 231.83]           > fib(n: uint32): uint32
[ 231.84]           < return
[ 231.85]          < return
[ 231.85]         < return
[ 231.86]         > fib(n: uint32): uint32
[ 231.87]          > fib(n: uint32): uint32
[ 231.88]           > fib(n: uint32): uint32
[ 231.89]           < return
[ 231.90]           > fib(n: uint32): uint32
[ 231.91]           < return
[ 231.91]          < return
[ 231.92]          > fib(n: uint32): uint32
[ 231.93]          < return
[ 231.94]         < return
[ 231.94]        < return
[ 231.95]       < return
[ 231.96]       > fib(n: uint32): uint32
[ 231.97]        > fib(n: uint32): uint32
[ 231.98]         > fib(n: uint32): uint32
[ 231.99]          > fib(n: uint32): uint32
[ 232.00]           > fib(n: uint32): uint32
[ 232.01]            > fib(n: uint32): uint32
[ 232.02]            < return
[ 232.03]            > fib(n: uint32): uint32
[ 232.04]            < return
[ 232.04]           < return
[ 232.05]           > fib(n: uint32): uint32
[ 232.06]           < return
[ 232.07]          < return
[ 232.08]          > fib(n: uint32): uint32
[ 232.09]           > fib(n: uint32): uint32
[ 232.09]           < return
[ 232.10]           > fib(n: uint32): uint32
[ 232.11]           < return
[ 232.12]          < return
[ 232.13]         < return
[ 232.13]         > fib(n: uint32): uint32
[ 232.14]          > fib(n: uint32): uint32
[ 232.15]           > fib(n: uint32): uint32
[ 232.16]           < return
[ 232.17]           > fib(n: uint32): uint32
[ 232.18]           < return
[ 232.19]          < return
[ 232.19]          > fib(n: uint32): uint32
[ 232.20]          < return
[ 232.21]         < return
[ 232.22]        < return
[ 232.22]        > fib(n: uint32): uint32
[ 232.24]         > fib(n: uint32): uint32
[ 232.25]          > fib(n: uint32): uint32
[ 232.25]           > fib(n: uint32): uint32
[ 232.26]           < return
[ 232.27]           > fib(n: uint32): uint32
[ 232.29]           < return
[ 232.30]          < return
[ 232.30]          > fib(n: uint32): uint32
[ 232.31]          < return
[ 232.32]         < return
[ 232.33]         > fib(n: uint32): uint32
[ 232.34]          > fib(n: uint32): uint32
[ 232.35]          < return
[ 232.35]          > fib(n: uint32): uint32
[ 232.36]          < return
[ 232.37]         < return
[ 232.38]        < return
[ 232.38]       < return
[ 232.39]      < return
[ 232.40]      > fib(n: uint32): uint32
[ 232.41]       > fib(n: uint32): uint32
[ 232.42]        > fib(n: uint32): uint32
[ 232.43]         > fib(n: uint32): uint32
[ 232.44]          > fib(n: uint32): uint32
[ 232.45]           > fib(n: uint32): uint32
[ 232.46]            > fib(n: uint32): uint32
[ 232.47]            < return
[ 232.48]            > fib(n: uint32): uint32
[ 232.49]            < return
[ 232.50]           < return
[ 232.50]           > fib(n: uint32): uint32
[ 232.51]           < return
[ 232.52]          < return
[ 232.53]          > fib(n: uint32): uint32
[ 232.54]           > fib(n: uint32): uint32
[ 232.55]           < return
[ 232.56]           > fib(n: uint32): uint32
[ 232.56]           < return
[ 232.57]          < return
[ 232.58]         < return
[ 232.59]         > fib(n: uint32): uint32
[ 232.60]          > fib(n: uint32): uint32
[ 232.61]           > fib(n: uint32): uint32
[ 232.62]           < return
[ 232.62]           > fib(n: uint32): uint32
[ 232.63]           < return
[ 232.64]          < return
[ 232.65]          > fib(n: uint32): uint32
[ 232.66]          < return
[ 232.66]         < return
[ 232.67]        < return
[ 232.68]        > fib(n: uint32): uint32
[ 232.69]         > fib(n: uint32): uint32
[ 232.70]          > fib(n: uint32): uint32
[ 232.71]           > fib(n: uint32): uint32
[ 232.72]           < return
[ 232.72]           > fib(n: uint32): uint32
[ 232.73]           < return
[ 232.74]          < return
[ 232.75]          > fib(n: uint32): uint32
[ 232.76]          < return
[ 232.76]         < return
[ 232.77]         > fib(n: uint32): uint32
[ 232.78]          > fib(n: uint32): uint32
[ 232.79]          < return
[ 232.80]          > fib(n: uint32): uint32
[ 232.81]          < return
[ 232.81]         < return
[ 232.82]        < return
[ 232.83]       < return
[ 232.84]       > fib(n: uint32): uint32
[ 232.84]        > fib(n: uint32): uint32
[ 232.85]         > fib(n: uint32): uint32
[ 232.87]          > fib(n: uint32): uint32
[ 232.88]           > fib(n: uint32): uint32
[ 232.88]           < return
[ 232.89]           > fib(n: uint32): uint32
[ 232.90]           < return
[ 232.91]          < return
[ 232.92]          > fib(n: uint32): uint32
[ 232.93]          < return
[ 232.93]         < return
[ 232.94]         > fib(n: uint32): uint32
[ 232.95]          > fib(n: uint32): uint32
[ 232.96]          < return
[ 232.97]          > fib(n: uint32): uint32
[ 232.98]          < return
[ 232.98]         < return
[ 232.99]        < return
[ 233.00]        > fib(n: uint32): uint32
[ 233.01]         > fib(n: uint32): uint32
[ 233.02]          > fib(n: uint32): uint32
[ 233.03]          < return
[ 233.03]          > fib(n: uint32): uint32
[ 233.04]          < return
[ 233.05]         < return
[ 233.06]         > fib(n: uint32): uint32
[ 233.07]         < return
[ 233.07]        < return
[ 233.08]       < return
[ 233.09]      < return
[ 233.09]     < return
[ 233.10]     > fib(n: uint32): uint32
[ 233.11]      > fib(n: uint32): uint32
[ 233.12]       > fib(n: uint32): uint32
[ 233.13]        > fib(n: uint32): uint32
[ 233.14]         > fib(n: uint32): uint32
[ 233.15]          > fib(n: uint32): uint32
[ 233.16]           > fib(n: uint32): uint32
[ 233.17]            > fib(n: uint32): uint32
[ 233.18]            < return
[ 233.19]            > fib(n: uint32): uint32
[ 233.20]            < return
[ 233.21]           < return
[ 233.21]           > fib(n: uint32): uint32
[ 233.22]           < return
[ 233.23]          < return
[ 233.24]          > fib(n: uint32): uint32
[ 233.25]           > fib(n: uint32): uint32
[ 233.26]           < return
[ 233.26]           > fib(n: uint32): uint32
[ 233.27]           < return
[ 233.28]          < return
[ 233.29]         < return
[ 233.30]         > fib(n: uint32): uint32
[ 233.31]          > fib(n: uint32): uint32
[ 233.32]           > fib(n: uint32): uint32
[ 233.32]           < return
[ 233.33]           > fib(n: uint32): uint32
[ 233.34]           < return
[ 233.35]          < return
[ 233.36]          > fib(n: uint32): uint32
[ 233.37]          < return
[ 233.37]         < return
[ 233.38]        < return
[ 233.39]        > fib(n: uint32): uint32
[ 233.40]         > fib(n: uint32): uint32
[ 233.41]          > fib(n: uint32): uint32
[ 233.42]           > fib(n: uint32): uint32
[ 233.43]           < return
[ 233.44]           > fib(n: uint32): uint32
[ 233.45]           < return
[ 233.45]          < return
[ 233.46]          > fib(n: uint32): uint32
[ 233.47]          < return
[ 233.48]         < return
[ 233.48]         > fib(n: uint32): uint32
[ 233.50]          > fib(n: uint32): uint32
[ 233.50]          < return
[ 233.51]          > fib(n: uint32): uint32
[ 233.52]          < return
[ 233.53]         < return
[ 233.53]        < return
[ 233.54]       < return
[ 233.55]       > fib(n: uint32): uint32
[ 233.56]        > fib(n: uint32): uint32
[ 233.57]         > fib(n: uint32): uint32
[ 233.58]          > fib(n: uint32): uint32
[ 233.59]           > fib(n: uint32): uint32
[ 233.60]           < return
[ 233.61]           > fib(n: uint32): uint32
[ 233.62]           < return
[ 233.62]          < return
[ 233.63]          > fib(n: uint32): uint32
[ 233.64]          < return
[ 233.65]         < return
[ 233.65]         > fib(n: uint32): uint32
[ 233.66]          > fib(n: uint32): uint32
[ 233.67]          < return
[ 233.68]          > fib(n: uint32): uint32
[ 233.69]          < return
[ 233.70]         < return
[ 233.70]        < return
[ 233.71]        > fib(n: uint32): uint32
[ 233.72]         > fib(n: uint32): uint32
[ 233.73]          > fib(n: uint32): uint32
[ 233.74]          < return
[ 233.75]          > fib(n: uint32): uint32
[ 233.76]          < return
[ 233.76]         < return
[ 233.77]         > fib(n: uint32): uint32
[ 233.78]         < return
[ 233.79]        < return
[ 233.79]       < return
[ 233.80]      < return
[ 233.81]      > fib(n: uint32): uint32
[ 233.82]       > fib(n: uint32): uint32
[ 233.83]        > fib(n: uint32): uint32
[ 233.84]         > fib(n: uint32): uint32
[ 233.85]          > fib(n: uint32): uint32
[ 233.86]           > fib(n: uint32): uint32
[ 233.87]           < return
[ 233.88]           > fib(n: uint32): uint32
[ 233.88]           < return
[ 233.89]          < return
[ 233.90]          > fib(n: uint32): uint32
[ 233.91]          < return
[ 233.92]         < return
[ 233.93]         > fib(n: uint32): uint32
[ 233.94]          > fib(n: uint32): uint32
[ 233.95]          < return
[ 233.95]          > fib(n: uint32): uint32
[ 233.96]          < return
[ 233.97]         < return
[ 233.98]        < return
[ 233.99]        > fib(n: uint32): uint32
[ 234.00]         > fib(n: uint32): uint32
[ 234.00]          > fib(n: uint32): uint32
[ 234.01]          < return
[ 234.02]          > fib(n: uint32): uint32
[ 234.03]          < return
[ 234.04]         < return
[ 234.05]         > fib(n: uint32): uint32
[ 234.06]         < return
[ 234.06]        < return
[ 234.07]       < return
[ 234.08]       > fib(n: uint32): uint32
[ 234.09]        > fib(n: uint32): uint32
[ 234.10]         > fib(n: uint32): uint32
[ 234.11]          > fib(n: uint32): uint32
[ 234.12]          < return
[ 234.12]          > fib(n: uint32): uint32
[ 234.13]          < return
[ 234.14]         < return
[ 234.15]         > fib(n: uint32): uint32
[ 234.16]         < return
[ 234.16]        < return
[ 234.17]        > fib(n: uint32): uint32
[ 234.18]         > fib(n: uint32): uint32
[ 234.19]         < return
[ 234.20]         > fib(n: uint32): uint32
[ 234.21]         < return
[ 234.22]        < return
[ 234.22]       < return
[ 234.23]      < return
[ 234.24]     < return
[ 234.24]    < return
[ 234.25]    > fib(n: uint32): uint32
[ 234.26]     > fib(n: uint32): uint32
[ 234.27]      > fib(n: uint32): uint32
[ 234.28]       > fib(n: uint32): uint32
[ 234.29]        > fib(n: uint32): uint32
[ 234.30]         > fib(n: uint32): uint32
[ 234.31]          > fib(n: uint32): uint32
[ 234.32]           > fib(n: uint32): uint32
[ 234.33]            > fib(n: uint32): uint32
[ 234.34]            < return
[ 234.35]            > fib(n: uint32): uint32
[ 234.36]            < return
[ 234.36]           < return
[ 234.37]           > fib(n: uint32): uint32
[ 234.38]           < return
[ 234.39]          < return
[ 234.40]          > fib(n: uint32): uint32
[ 234.41]           > fib(n: uint32): uint32
[ 234.42]           < return
[ 234.42]           > fib(n: uint32): uint32
[ 234.43]           < return
[ 234.44]          < return
[ 234.45]         < return
[ 234.45]         > fib(n: uint32): uint32
[ 234.46]          > fib(n: uint32): uint32
[ 234.47]           > fib(n: uint32): uint32
[ 234.48]           < return
[ 234.49]           > fib(n: uint32): uint32
[ 234.50]           < return
[ 234.51]          < return
[ 234.51]          > fib(n: uint32): uint32
[ 234.53]          < return
[ 234.53]         < return
[ 234.54]        < return
[ 234.55]        > fib(n: uint32): uint32
[ 234.56]         > fib(n: uint32): uint32
[ 234.57]          > fib(n: uint32): uint32
[ 234.58]           > fib(n: uint32): uint32
[ 234.59]           < return
[ 234.59]           > fib(n: uint32): uint32
[ 234.60]           < return
[ 234.61]          < return
[ 234.62]          > fib(n: uint32): uint32
[ 234.63]          < return
[ 234.63]         < return
[ 234.64]         > fib(n: uint32): uint32
[ 234.65]          > fib(n: uint32): uint32
[ 234.66]          < return
[ 234.67]          > fib(n: uint32): uint32
[ 234.68]          < return
[ 234.68]         < return
[ 234.69]        < return
[ 234.70]       < return
[ 234.71]       > fib(n: uint32): uint32
[ 234.72]        > fib(n: uint32): uint32
[ 234.72]         > fib(n: uint32): uint32
[ 234.74]          > fib(n: uint32): uint32
[ 234.75]           > fib(n: uint32): uint32
[ 234.75]           < return
[ 234.76]           > fib(n: uint32): uint32
[ 234.77]           < return
[ 234.78]          < return
[ 234.79]          > fib(n: uint32): uint32
[ 234.79]          < return
[ 234.80]         < return
[ 234.81]         > fib(n: uint32): uint32
[ 234.82]          > fib(n: uint32): uint32
[ 234.83]          < return
[ 234.84]          > fib(n: uint32): uint32
[ 234.85]          < return
[ 234.85]         < return
[ 234.86]        < return
[ 234.87]        > fib(n: uint32): uint32
[ 234.88]         > fib(n: uint32): uint32
[ 234.89]          > fib(n: uint32): uint32
[ 234.90]          < return
[ 234.90]          > fib(n: uint32): uint32
[ 234.91]          < return
[ 234.92]         < return
[ 234.93]         > fib(n: uint32): uint32
[ 234.94]         < return
[ 234.94]        < return
[ 234.95]       < return
[ 234.96]      < return
[ 234.97]      > fib(n: uint32): uint32
[ 234.97]       > fib(n: uint32): uint32
[ 234.99]        > fib(n: uint32): uint32
[ 235.00]         > fib(n: uint32): uint32
[ 235.00]          > fib(n: uint32): uint32
[ 235.01]           > fib(n: uint32): uint32
[ 235.02]           < return
[ 235.03]           > fib(n: uint32): uint32
[ 235.04]           < return
[ 235.05]          < return
[ 235.06]          > fib(n: uint32): uint32
[ 235.06]          < return
[ 235.07]         < return
[ 235.08]         > fib(n: uint32): uint32
[ 235.09]          > fib(n: uint32): uint32
[ 235.10]          < return
[ 235.10]          > fib(n: uint32): uint32
[ 235.11]          < return
[ 235.12]         < return
[ 235.13]        < return
[ 235.14]        > fib(n: uint32): uint32
[ 235.15]         > fib(n: uint32): uint32
[ 235.16]          > fib(n: uint32): uint32
[ 235.16]          < return
[ 235.17]          > fib(n: uint32): uint32
[ 235.18]          < return
[ 235.19]         < return
[ 235.20]         > fib(n: uint32): uint32
[ 235.21]         < return
[ 235.21]        < return
[ 235.22]       < return
[ 235.23]       > fib(n: uint32): uint32
[ 235.24]        > fib(n: uint32): uint32
[ 235.25]         > fib(n: uint32): uint32
[ 235.26]          > fib(n: uint32): uint32
[ 235.27]          < return
[ 235.27]          > fib(n: uint32): uint32
[ 235.28]          < return
[ 235.29]         < return
[ 235.30]         > fib(n: uint32): uint32
[ 235.31]         < return
[ 235.31]        < return
[ 235.32]        > fib(n: uint32): uint32
[ 235.33]         > fib(n: uint32): uint32
[ 235.34]         < return
[ 235.35]         > fib(n: uint32): uint32
[ 235.36]         < return
[ 235.37]        < return
[ 235.37]       < return
[ 235.38]      < return
[ 235.39]     < return
[ 235.40]     > fib(n: uint32): uint32
[ 235.41]      > fib(n: uint32): uint32
[ 235.41]       > fib(n: uint32): uint32
[ 235.43]        > fib(n: uint32): uint32
[ 235.44]         > fib(n: uint32): uint32
[ 235.45]          > fib(n: uint32): uint32
[ 235.46]           > fib(n: uint32): uint32
[ 235.47]           < return
[ 235.47]           > fib(n: uint32): uint32
[ 235.48]           < return
[ 235.49]          < return
[ 235.50]          > fib(n: uint32): uint32
[ 235.50]          < return
[ 235.51]         < return
[ 235.52]         > fib(n: uint32): uint32
[ 235.53]          > fib(n: uint32): uint32
[ 235.54]          < return
[ 235.55]          > fib(n: uint32): uint32
[ 235.56]          < return
[ 235.56]         < return
[ 235.57]        < return
[ 235.58]        > fib(n: uint32): uint32
[ 235.59]         > fib(n: uint32): uint32
[ 235.60]          > fib(n: uint32): uint32
[ 235.61]          < return
[ 235.61]          > fib(n: uint32): uint32
[ 235.62]          < return
[ 235.63]         < return
[ 235.64]         > fib(n: uint32): uint32
[ 235.65]         < return
[ 235.65]        < return
[ 235.66]       < return
[ 235.67]       > fib(n: uint32): uint32
[ 235.68]        > fib(n: uint32): uint32
[ 235.69]         > fib(n: uint32): uint32
[ 235.70]          > fib(n: uint32): uint32
[ 235.71]          < return
[ 235.72]          > fib(n: uint32): uint32
[ 235.72]          < return
[ 235.73]         < return
[ 235.74]         > fib(n: uint32): uint32
[ 235.75]         < return
[ 235.75]        < return
[ 235.76]        > fib(n: uint32): uint32
[ 235.77]         > fib(n: uint32): uint32
[ 235.78]         < return
[ 235.79]         > fib(n: uint32): uint32
[ 235.80]         < return
[ 235.81]        < return
[ 235.81]       < return
[ 235.82]      < return
[ 235.83]      > fib(n: uint32): uint32
[ 235.84]       > fib(n: uint32): uint32
[ 235.85]        > fib(n: uint32): uint32
[ 235.86]         > fib(n: uint32): uint32
[ 235.87]          > fib(n: uint32): uint32
[ 235.88]          < return
[ 235.88]          > fib(n: uint32): uint32
[ 235.89]          < return
[ 235.90]         < return
[ 235.91]         > fib(n: uint32): uint32
[ 235.92]         < return
[ 235.92]        < return
[ 235.93]        > fib(n: uint32): uint32
[ 235.94]         > fib(n: uint32): uint32
[ 235.95]         < return
[ 235.96]         > fib(n: uint32): uint32
[ 235.97]         < return
[ 235.97]        < return
[ 235.98]       < return
[ 235.99]       > fib(n: uint32): uint32
[ 236.00]        > fib(n: uint32): uint32
[ 236.01]         > fib(n: uint32): uint32
[ 236.02]         < return
[ 236.03]         > fib(n: uint32): uint32
[ 236.04]         < return
[ 236.04]        < return
[ 236.05]        > fib(n: uint32): uint32
[ 236.06]        < return
[ 236.07]       < return
[ 236.07]      < return
[ 236.08]     < return
[ 236.09]    < return
[ 236.09]   < return
[ 236.10]  < return
[ 236.13]  > typename.name(type: typename): .cstr
[ 236.15]  < return
[ 236.16]  > typename.file(type: typename): .cstr
[ 236.17]  < return
[ 236.18]  > typename.line(type: typename): int32
[ 236.19]  < return
[ 236.19]  > typename.base(type: typename): typename
[ 236.20]  < return
[ 236.21]  > typename.name(type: typename): .cstr
[ 236.22]  < return
[ 236.23]  > typename.file(type: typename): .cstr
[ 236.24]  < return
[ 236.25]  > typename.line(type: typename): int32
[ 236.26]  < return
[ 236.27]  > typename.base(type: typename): typename
[ 236.28]  < return
[ 236.30]  > typename.base(type: typename): typename
[ 236.31]  < return
[ 236.35]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.36]  < return
[ 236.37]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.38]  < return
[ 236.38]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.39]  < return
[ 236.40]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.41]  < return
[ 236.42]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.43]  < return
[ 236.44]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.45]  < return
[ 236.46]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.47]  < return
[ 236.48]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.49]  < return
[ 236.50]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.50]  < return
[ 236.51]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.52]  < return
[ 236.53]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.54]  < return
[ 236.55]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.56]  < return
[ 236.57]  > float64.sin(x: float64): float64
[ 236.59]  < return
[ 236.60]  > float64.cos(x: float64): float64
[ 236.61]  < return
[ 236.62]  > float64.tan(x: float64): float64
[ 236.63]  < return
[ 236.64]  > float64.log(x: float64): float64
[ 236.66]  < return
[ 236.66]  > float64.exp(x: float64): float64
[ 236.67]  < return
[ 236.68]  > float64.pow(x: float64, y: float64): float64
[ 236.69]  < return
[ 236.70]  > float64.sqrt(x: float64): float64
[ 236.71]  < return
[ 236.72]  > float64.atan2(x: float64, y: float64): float64
[ 236.73]  < return
[ 236.74]  > float32.sin(x: float32): float32
[ 236.75]  < return
[ 236.76]  > float32.cos(x: float32): float32
[ 236.77]  < return
[ 236.78]  > float32.tan(x: float32): float32
[ 236.79]  < return
[ 236.80]  > float32.log(x: float32): float32
[ 236.81]  < return
[ 236.81]  > float32.exp(x: float32): float32
[ 236.82]  < return
[ 236.83]  > float32.pow(x: float32, y: float32): float32
[ 236.84]  < return
[ 236.85]  > float32.sqrt(x: float32): float32
[ 236.86]  < return
[ 236.87]  > float32.atan2(x: float32, y: float32): float32
[ 236.88]  < return
[ 236.89]  > uint32.pop(value: int32): int32
[ 236.90]  < return
[ 236.90]  > uint32.swap(value: int32): int32
[ 236.91]  < return
[ 236.92]  > uint32.bsr(value: int32): int32
[ 236.93]  < return
[ 236.94]  > uint32.bsf(value: int32): int32
[ 236.95]  < return
[ 236.95]  > uint32.hib(value: int32): int32
[ 236.96]  < return
[ 236.97]  > uint32.lob(value: int32): int32
[ 236.98]  < return
[ 236.99]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 237.00]  < return
[ 237.01]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 237.01]  < return
[ 237.03]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 237.03]  < return
[ 237.04]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 237.05]  < return
[ 237.06]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.07]  < return
[ 237.08]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.09]  < return
[ 237.10]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.11]  < return
[ 237.12]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.13]  < return
[ 237.13]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 237.15]  < return
[ 237.16]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 237.16]  < return
[ 237.17]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.18]  < return
[ 237.19]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.20]  < return
[ 237.21]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.22]  < return
[ 237.23]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 237.24]  < return
[ 237.25]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 237.27]  < return
[ 237.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 237.31]  < return
[ 237.31]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 237.32]  < return
[ 237.34]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 237.34]  < return
[ 237.36]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 237.38]  < return
[ 237.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 237.42]  < return
[ 237.43]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 237.43]   > noError(ptr: pointer): void
[ 237.44]   < return
[ 237.45]   > halt(): void
[ 237.46]   < return
[ 237.47]  < return
[ 237.47]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 237.49]  < return
[ 237.50]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 237.50]   > stackOverflow(ptr: pointer): void
[ 237.51]    > stackOverflow(ptr: pointer): void
[ 237.52]     > stackOverflow(ptr: pointer): void
[ 237.53]      > stackOverflow(ptr: pointer): void
[ 237.54]       > stackOverflow(ptr: pointer): void
[ 237.55]        > stackOverflow(ptr: pointer): void
[ 237.56]         > stackOverflow(ptr: pointer): void
[ 237.57]          > stackOverflow(ptr: pointer): void
[ 237.58]           > stackOverflow(ptr: pointer): void
[ 237.59]            > stackOverflow(ptr: pointer): void
[ 237.60]             > stackOverflow(ptr: pointer): void
[ 237.61]              > stackOverflow(ptr: pointer): void
[ 237.62]               > stackOverflow(ptr: pointer): void
[ 237.62]                > stackOverflow(ptr: pointer): void
[ 237.63]                 > stackOverflow(ptr: pointer): void
[ 237.64]                  > stackOverflow(ptr: pointer): void
[ 237.65]                   > stackOverflow(ptr: pointer): void
[ 237.66]                    > stackOverflow(ptr: pointer): void
[ 237.67]                     > stackOverflow(ptr: pointer): void
[ 237.68]                      > stackOverflow(ptr: pointer): void
[ 237.69]                       > stackOverflow(ptr: pointer): void
[ 237.70]                        > stackOverflow(ptr: pointer): void
[ 237.71]                         > stackOverflow(ptr: pointer): void
[ 237.72]                          > stackOverflow(ptr: pointer): void
[ 237.72]                           > stackOverflow(ptr: pointer): void
[ 237.73]                            > stackOverflow(ptr: pointer): void
[ 237.74]                             > stackOverflow(ptr: pointer): void
[ 237.75]                              > stackOverflow(ptr: pointer): void
[ 237.76]                               > stackOverflow(ptr: pointer): void
[ 237.77]                                > stackOverflow(ptr: pointer): void
[ 237.78]                                 > stackOverflow(ptr: pointer): void
[ 237.79]                                  > stackOverflow(ptr: pointer): void
[ 237.80]                                   > stackOverflow(ptr: pointer): void
[ 237.81]                                    > stackOverflow(ptr: pointer): void
[ 237.81]                                     > stackOverflow(ptr: pointer): void
[ 237.82]                                      > stackOverflow(ptr: pointer): void
[ 237.83]                                       > stackOverflow(ptr: pointer): void
[ 237.84]                                        > stackOverflow(ptr: pointer): void
[ 237.85]                                         > stackOverflow(ptr: pointer): void
[ 237.86]                                          > stackOverflow(ptr: pointer): void
[ 237.87]                                           > stackOverflow(ptr: pointer): void
[ 237.88]                                            > stackOverflow(ptr: pointer): void
[ 237.89]                                             > stackOverflow(ptr: pointer): void
[ 237.90]                                              > stackOverflow(ptr: pointer): void
[ 237.91]                                               > stackOverflow(ptr: pointer): void
[ 237.91]                                                > stackOverflow(ptr: pointer): void
[ 237.92]                                                 > stackOverflow(ptr: pointer): void
[ 237.93]                                                  > stackOverflow(ptr: pointer): void
[ 237.94]                                                   > stackOverflow(ptr: pointer): void
[ 237.96]                                                    > stackOverflow(ptr: pointer): void
[ 237.96]                                                     > stackOverflow(ptr: pointer): void
[ 237.97]                                                      > stackOverflow(ptr: pointer): void
[ 237.98]                                                       > stackOverflow(ptr: pointer): void
[ 237.99]                                                        > stackOverflow(ptr: pointer): void
[ 238.00]                                                         > stackOverflow(ptr: pointer): void
[ 238.01]                                                          > stackOverflow(ptr: pointer): void
[ 238.02]                                                           > stackOverflow(ptr: pointer): void
[ 238.03]                                                            > stackOverflow(ptr: pointer): void
[ 238.04]                                                             > stackOverflow(ptr: pointer): void
[ 238.05]                                                              > stackOverflow(ptr: pointer): void
[ 238.06]                                                               > stackOverflow(ptr: pointer): void
[ 238.07]                                                                > stackOverflow(ptr: pointer): void
[ 238.07]                                                                 > stackOverflow(ptr: pointer): void
[ 238.08]                                                                  > stackOverflow(ptr: pointer): void
[ 238.09]                                                                  < return
[ 238.10]                                                                 < return
[ 238.11]                                                                < return
[ 238.11]                                                               < return
[ 238.12]                                                              < return
[ 238.13]                                                             < return
[ 238.13]                                                            < return
[ 238.14]                                                           < return
[ 238.15]                                                          < return
[ 238.15]                                                         < return
[ 238.16]                                                        < return
[ 238.17]                                                       < return
[ 238.18]                                                      < return
[ 238.18]                                                     < return
[ 238.19]                                                    < return
[ 238.19]                                                   < return
[ 238.20]                                                  < return
[ 238.21]                                                 < return
[ 238.22]                                                < return
[ 238.22]                                               < return
[ 238.23]                                              < return
[ 238.24]                                             < return
[ 238.24]                                            < return
[ 238.25]                                           < return
[ 238.26]                                          < return
[ 238.26]                                         < return
[ 238.27]                                        < return
[ 238.28]                                       < return
[ 238.28]                                      < return
[ 238.29]                                     < return
[ 238.30]                                    < return
[ 238.30]                                   < return
[ 238.31]                                  < return
[ 238.32]                                 < return
[ 238.32]                                < return
[ 238.33]                               < return
[ 238.34]                              < return
[ 238.34]                             < return
[ 238.35]                            < return
[ 238.36]                           < return
[ 238.37]                          < return
[ 238.37]                         < return
[ 238.38]                        < return
[ 238.39]                       < return
[ 238.40]                      < return
[ 238.40]                     < return
[ 238.41]                    < return
[ 238.41]                   < return
[ 238.42]                  < return
[ 238.43]                 < return
[ 238.44]                < return
[ 238.44]               < return
[ 238.45]              < return
[ 238.46]             < return
[ 238.46]            < return
[ 238.47]           < return
[ 238.48]          < return
[ 238.48]         < return
[ 238.49]        < return
[ 238.50]       < return
[ 238.50]      < return
[ 238.51]     < return
[ 238.52]    < return
[ 238.52]   < return
[ 238.53]  < return
[ 238.54]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.55]   > divisionByZero(args: pointer): void
[ 238.56]   < return
[ 238.56]  < return
[ 238.57]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.58]   > invalidInstruction(args: pointer): void
[ 238.59]   < return
[ 238.60]  < return
[ 238.60]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.61]   > invalidMemoryAccess(args: pointer): void
[ 238.62]   < return
[ 238.63]  < return
[ 238.64]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.65]   > abortExecution(args: pointer): void
[ 238.66]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 238.75]    < return
[ 238.75]   < return
[ 238.76]  < return
[ 238.87]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 238.88]  < return
[ 238.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 238.96]  < return
[ 238.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 239.03]  < return
[ 239.04]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 239.07]  < return
[ 239.08]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 239.11]  < return
[ 239.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 239.14]  < return
[ 239.16]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 239.18]  < return
[ 239.21]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.22]  < return
[ 239.23]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.23]  < return
[ 239.25]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.25]  < return
[ 239.26]  > lenSlice(values: int64[]): int32
[ 239.28]  < return
[ 239.28]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.29]  < return
[ 239.30]  > lenSlice(values: int64[]): int32
[ 239.31]  < return
[ 239.32]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.33]  < return
[ 239.34]  > lenSlice(values: int64[]): int32
[ 239.35]  < return
[ 239.36]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.37]  < return
[ 239.38]  > lenSlice(values: int64[]): int32
[ 239.39]  < return
[ 239.40]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.41]  < return
[ 239.42]  > lenSlice(values: int64[]): int32
[ 239.43]  < return
[ 239.44]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 239.45]  < return
[ 239.49]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.50]  < return
[ 239.51]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.53]  < return
[ 239.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.55]  < return
[ 239.56]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.58]  < return
[ 239.59]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.60]  < return
[ 239.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.63]  < return
[ 239.64]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.65]  < return
[ 239.67]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.68]  < return
[ 239.72]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.74]  < return
[ 239.75]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.76]  < return
[ 239.78]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.79]  < return
[ 239.80]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.81]  < return
[ 239.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.84]  < return
[ 239.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.86]  < return
[ 239.88]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.89]  < return
[ 239.90]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.91]  < return
[ 239.96]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.97]  < return
[ 239.99]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.00]  < return
[ 240.01]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.02]  < return
[ 240.04]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.05]  < return
[ 240.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.07]  < return
[ 240.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.10]  < return
[ 240.11]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.12]  < return
[ 240.14]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.15]  < return
[ 240.19]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.21]  < return
[ 240.22]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.23]  < return
[ 240.25]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.26]  < return
[ 240.27]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.29]  < return
[ 240.31]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.32]  < return
[ 240.33]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.34]  < return
[ 240.36]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.37]  < return
[ 240.38]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.39]  < return
[ 240.44]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.45]  < return
[ 240.47]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.48]  < return
[ 240.49]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.50]  < return
[ 240.52]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.53]  < return
[ 240.54]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.55]  < return
[ 240.57]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.58]  < return
[ 240.59]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.60]  < return
[ 240.62]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.63]  < return
[ 240.68]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.69]  < return
[ 240.70]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.71]  < return
[ 240.73]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.74]  < return
[ 240.75]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.76]  < return
[ 240.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.79]  < return
[ 240.80]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.81]  < return
[ 240.83]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.84]  < return
[ 240.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.87]  < return
[ 240.91]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.93]  < return
[ 240.94]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.95]  < return
[ 240.97]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.98]  < return
[ 240.99]  > nthArray(idx: int32, values: int64[*]): int64
[ 241.00]  < return
[ 241.01]  > nthArray(idx: int32, values: int64[*]): int64
[ 241.03]  < return
[ 241.04]  > nthArray(idx: int32, values: int64[*]): int64
[ 241.05]  < return
[ 241.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 241.08]  < return
[ 241.09]  > nthSlice(idx: int32, values: int64[]): int64
[ 241.10]  < return
[ 241.15]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 241.16]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(1)
	test/lang/method.ci:58: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 241.24]   < return
[ 241.25]  < return
[ 241.26]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.27]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(1)
	test/lang/method.ci:59: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 241.34]   < return
[ 241.35]  < return
[ 241.36]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 241.37]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:63: debug: extension.staticMethod
[ 241.38]   < return
[ 241.39]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 241.40]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(2)
	test/lang/method.ci:65: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:75: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 241.52]    < return
[ 241.53]   < return
[ 241.54]  < return
[ 241.55]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.56]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:69: debug: extension.virtualMethod
[ 241.57]   < return
[ 241.58]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.59]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(2)
	test/lang/method.ci:71: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:76: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 241.71]    < return
[ 241.72]   < return
[ 241.72]  < return
[ 241.74]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 241.75]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(3)
	test/lang/method.ci:79: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 241.82]   < return
[ 241.83]  < return
[ 241.84]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.85]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:80: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 241.92]   < return
[ 241.93]  < return
[ 241.94]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.95]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:81: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 242.02]   < return
[ 242.03]  < return
[ 242.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 243.01]  < return
[ 243.03]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 243.05]  < return
[ 243.06]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 243.09]  < return
[ 243.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 243.13]  < return
[ 243.16]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 243.18]  < return
[ 243.20]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 243.23]  < return
[ 243.25]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 243.27]  < return
[ 243.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 243.31]  < return
[ 243.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 243.35]  < return
[ 243.38]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 243.40]  < return
[ 243.43]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 243.45]  < return
[ 243.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 243.49]  < return
[ 243.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 243.57]  < return
[ 243.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 243.62]  < return
[ 243.64]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 243.67]  < return
[ 243.69]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 243.71]  < return
[ 243.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 243.76]  < return
[ 243.80]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 243.82]  < return
[ 243.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 243.86]  < return
[ 243.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 243.91]  < return
[ 243.94]  > Math.floor(x: float64): float64
[ 243.94]   > Math.modf(x: float64, intPart: float64): float64
[ 243.95]   < return
[ 243.96]  < return
[ 243.97]  > Math.floor(x: float64): float64
[ 243.98]   > Math.modf(x: float64, intPart: float64): float64
[ 243.99]   < return
[ 243.99]  < return
[ 244.01]  > Math.floor(x: float64): float64
[ 244.01]   > Math.modf(x: float64, intPart: float64): float64
[ 244.02]   < return
[ 244.03]  < return
[ 244.04]  > Math.floor(x: float64): float64
[ 244.05]   > Math.modf(x: float64, intPart: float64): float64
[ 244.05]    > Math.modf(x: float64, intPart: float64): float64
[ 244.06]    < return
[ 244.07]   < return
[ 244.07]  < return
[ 244.09]  > Math.floor(x: float64): float64
[ 244.09]   > Math.modf(x: float64, intPart: float64): float64
[ 244.10]    > Math.modf(x: float64, intPart: float64): float64
[ 244.11]    < return
[ 244.12]   < return
[ 244.12]  < return
[ 244.13]  > Math.floor(x: float64): float64
[ 244.14]   > Math.modf(x: float64, intPart: float64): float64
[ 244.15]    > Math.modf(x: float64, intPart: float64): float64
[ 244.16]    < return
[ 244.16]   < return
[ 244.17]  < return
[ 244.18]  > Math.sign(x: float64): int32
[ 244.19]  < return
[ 244.21]  > Math.sign(x: float64): int32
[ 244.21]  < return
[ 244.23]  > Math.sign(x: float64): int32
[ 244.23]  < return
[ 244.25]  > Math.sign(x: float32): int32
[ 244.26]  < return
[ 244.27]  > Math.sign(x: float32): int32
[ 244.28]  < return
[ 244.30]  > Math.sign(x: float32): int32
[ 244.30]  < return
[ 244.32]  > Math.abs(x: float64): float64
[ 244.33]  < return
[ 244.34]  > Math.abs(x: float64): float64
[ 244.36]  < return
[ 244.38]  > Math.abs(x: float64): float64
[ 244.39]  < return
[ 244.41]  > Math.abs(x: float32): float32
[ 244.42]  < return
[ 244.44]  > Math.abs(x: float32): float32
[ 244.45]  < return
[ 244.47]  > Math.abs(x: float32): float32
[ 244.49]  < return
[ 244.51]  > Math.min(a: float32, b: float32): float32
[ 244.52]  < return
[ 244.54]  > Math.max(a: float32, b: float32): float32
[ 244.56]  < return
[ 244.58]  > Math.min(a: float64, b: float64): float64
[ 244.59]  < return
[ 244.62]  > Math.max(a: float64, b: float64): float64
[ 244.63]  < return
[ 244.65]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 244.66]  < return
[ 244.69]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 244.70]  < return
[ 244.77]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 244.78]  < return
[ 244.81]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 244.82]  < return
[ 244.84]  > Math.min(data: float64[]): float64
[ 244.85]  < return
[ 244.88]  > Math.min(data: float64[]): float64
[ 244.92]  < return
[ 244.93]  > Math.max(data: float64[]): float64
[ 244.94]  < return
[ 244.97]  > Math.max(data: float64[]): float64
[ 245.00]  < return
[ 245.02]  > Math.sum(data: float64[]): float64
[ 245.03]  < return
[ 245.05]  > Math.sum(data: float64[]): float64
[ 245.06]  < return
[ 245.08]  > Math.sum(data: float64[]): float64
[ 245.10]  < return
[ 245.13]  > Math.sum(data: float64[]): float64
[ 245.17]  < return
[ 245.19]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.20]  < return
[ 245.26]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.29]  < return
[ 245.31]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.34]  < return
[ 245.36]  > Math.sinCos(arg: float64, quad: int32): float64
[ 245.39]  < return
[ 245.40]  > Math.abs(x: float64): float64
[ 245.41]  < return
[ 245.42]  > Math.sinCos(arg: float64, quad: int32): float64
[ 245.44]  < return
[ 245.46]  > Math.tan(arg: float64): float64
[ 245.47]   > Math.modf(x: float64, intPart: float64): float64
[ 245.48]   < return
[ 245.50]  < return
[ 245.52]  > Math.sinh(x: float64): float64
[ 245.53]   > float64.exp(x: float64): float64
[ 245.54]   < return
[ 245.54]   > float64.exp(x: float64): float64
[ 245.55]   < return
[ 245.56]  < return
[ 245.57]  > Math.cosh(x: float64): float64
[ 245.58]   > float64.exp(x: float64): float64
[ 245.59]   < return
[ 245.60]   > float64.exp(x: float64): float64
[ 245.60]   < return
[ 245.61]  < return
[ 245.62]  > Math.asin(x: float64): float64
[ 245.64]   > float64.sqrt(x: float64): float64
[ 245.64]   < return
[ 245.65]   > float64.atan2(x: float64, y: float64): float64
[ 245.66]   < return
[ 245.67]  < return
[ 245.68]  > Math.asin(x: float64): float64
[ 245.69]   > float64.sqrt(x: float64): float64
[ 245.70]   < return
[ 245.71]   > float64.atan2(x: float64, y: float64): float64
[ 245.72]   < return
[ 245.72]  < return
[ 245.74]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 245.75]  < return
[ 245.77]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 245.78]  < return
[ 245.79]  > Math.absMod(val: float64, mod: float64): float64
[ 245.80]  < return
[ 245.81]  > Math.absMod(val: float64, mod: float64): float64
[ 245.82]  < return
[ 245.84]  > Math.absMod(val: float64, mod: float64): float64
[ 245.84]  < return
[ 245.86]  > Math.absMod(val: float64, mod: float64): float64
[ 245.87]  < return
[ 245.88]  > Math.absMod(val: float64, mod: float64): float64
[ 245.89]  < return
[ 245.90]  > Math.absMod(val: float64, mod: float64): float64
[ 245.91]  < return
[ 245.92]  > Math.absMod(val: float64, mod: float64): float64
[ 245.93]  < return
[ 245.94]  > Math.absMod(val: float64, mod: float64): float64
[ 245.95]  < return
[ 245.97]  > Math.absMod(val: float64, mod: float64): float64
[ 245.97]  < return
[ 245.99]  > Math.absMod(val: float64, mod: float64): float64
[ 246.00]  < return
[ 246.01]  > Math.absMod(val: float64, mod: float64): float64
[ 246.02]  < return
[ 246.03]  > Math.absMod(val: float32, mod: float32): float32
[ 246.04]  < return
[ 246.05]  > Math.absMod(val: float32, mod: float32): float32
[ 246.06]  < return
[ 246.07]  > Math.absMod(val: float32, mod: float32): float32
[ 246.08]  < return
[ 246.10]  > Math.absMod(val: float32, mod: float32): float32
[ 246.10]  < return
[ 246.12]  > Math.absMod(val: float32, mod: float32): float32
[ 246.13]  < return
[ 246.14]  > Math.absMod(val: float32, mod: float32): float32
[ 246.15]  < return
[ 246.16]  > Math.absMod(val: float32, mod: float32): float32
[ 246.17]  < return
[ 246.19]  > Math.absMod(val: float32, mod: float32): float32
[ 246.19]  < return
[ 246.21]  > Math.absMod(val: float32, mod: float32): float32
[ 246.22]  < return
[ 246.23]  > Math.absMod(val: float32, mod: float32): float32
[ 246.24]  < return
[ 246.25]  > Math.absMod(val: float32, mod: float32): float32
[ 246.26]  < return
[ 246.27]  > halt(): void
[ 246.28]  < return
[ 246.28] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:39: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:46: Math.floor: function(<Math.floor>)
lib/std/math.ci:58: Math.sign: function(<Math.sign>)
lib/std/math.ci:67: Math.sign: function(<Math.sign>)
lib/std/math.ci:83: Math.abs: function(<Math.abs>)
lib/std/math.ci:89: Math.abs: function(<Math.abs>)
lib/std/math.ci:95: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:114: Math.min: function(<Math.min>)
lib/std/math.ci:120: Math.min: function(<Math.min>)
lib/std/math.ci:132: Math.max: function(<Math.max>)
lib/std/math.ci:138: Math.max: function(<Math.max>)
lib/std/math.ci:150: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:185: Math.min: function(<Math.min>)
lib/std/math.ci:197: Math.max: function(<Math.max>)
lib/std/math.ci:210: Math.sum: function(<Math.sum>)
lib/std/math.ci:228: Math.eval: function(<Math.eval>)
lib/std/math.ci:236: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:249: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:263: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:320: Math.tan: function(<Math.tan>)
lib/std/math.ci:377: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:416: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:432: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
lib/vec/vec2d.ci:3: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:8: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:3: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:21: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:3: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:13: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:25: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:33: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(144)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(207832)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(207544)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2608)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(144)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:11: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:25: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:30: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:40: globalFunction: function(<globalFunction>)
test/lang/method.ci:44: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:62: staticMethod: function(<staticMethod>)
test/lang/method.ci:68: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_0f: float64(0.000000)
test/stdc/test.math.ci:36: testMathSmooth_0F: float64(0.000000)
test/stdc/test.math.ci:37: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:38: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:40: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:42: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:43: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:45: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:46: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:47: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:48: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:50: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:51: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:52: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:53: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:54: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:55: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:56: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:57: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:59: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:61: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:62: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:63: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:65: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:66: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:69: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:70: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:73: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:78: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:83: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:87: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:92: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:97: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:98: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 320774(313.3 Kb)
memory[heap] @04e506; size: 1251832(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 304824(297.7 Kb)
memory[code] @000000; size: 15604(15.2 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @04e518; size: 1251792(1.2 Mb)

---------- Profile functions: 81/115, coverage: 70.43%
::[.005768, .005768): exec(2), time(0.014 ms): halt(): void
::[.005a88, .005a88): exec(3), time(0.030 ms): typename.base(type: typename): typename
::[.005c70, .005c70): exec(2), time(0.018 ms): typename.file(type: typename): .cstr
::[.005e58, .005e58): exec(2), time(0.017 ms): typename.line(type: typename): int32
::[.006040, .006040): exec(2), time(0.019 ms): typename.name(type: typename): .cstr
::[.006778, .006778): exec(40), time(1.430 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.006fe8, .006fe8): exec(7), time(1.277 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007268, .007268): exec(8), time(0.067 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007578, .007578): exec(2), time(0.018 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007888, .007888): exec(2), time(0.017 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.007b90, .007b90): exec(1), time(0.009 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.007e18, .007e18): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.008008, .008008): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008160, .008160): exec(0), time(0.000 ms): System.rand(): int32
::[.0082b8, .0082b8): exec(0), time(0.000 ms): System.time(): int32
::[.008410, .008410): exec(0), time(0.000 ms): System.clock(): int32
::[.008568, .008568): exec(0), time(0.000 ms): System.millis(): int64
::[.008750, .008750): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.008a60, .008a60): exec(7), time(0.057 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.008d68, .008d68): exec(7), time(0.058 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.008f50, .008f50): exec(1), time(0.009 ms): uint32.pop(value: int32): int32
::[.009138, .009138): exec(1), time(0.008 ms): uint32.swap(value: int32): int32
::[.009320, .009320): exec(1), time(0.008 ms): uint32.bsr(value: int32): int32
::[.009508, .009508): exec(1), time(0.008 ms): uint32.bsf(value: int32): int32
::[.0096f0, .0096f0): exec(1), time(0.008 ms): uint32.hib(value: int32): int32
::[.0098d8, .0098d8): exec(1), time(0.007 ms): uint32.lob(value: int32): int32
::[.009bd8, .009bd8): exec(1), time(0.009 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.009ed8, .009ed8): exec(1), time(0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00a0c0, .00a0c0): exec(1), time(0.010 ms): float32.sin(x: float32): float32
::[.00a2a8, .00a2a8): exec(1), time(0.009 ms): float32.cos(x: float32): float32
::[.00a490, .00a490): exec(1), time(0.008 ms): float32.tan(x: float32): float32
::[.00a678, .00a678): exec(1), time(0.008 ms): float32.log(x: float32): float32
::[.00a860, .00a860): exec(1), time(0.008 ms): float32.exp(x: float32): float32
::[.00aad8, .00aad8): exec(1), time(0.008 ms): float32.pow(x: float32, y: float32): float32
::[.00acc0, .00acc0): exec(1), time(0.007 ms): float32.sqrt(x: float32): float32
::[.00af38, .00af38): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00b118, .00b118): exec(1), time(0.022 ms): float64.sin(x: float64): float64
::[.00b2f8, .00b2f8): exec(1), time(0.013 ms): float64.cos(x: float64): float64
::[.00b4d8, .00b4d8): exec(1), time(0.009 ms): float64.tan(x: float64): float64
::[.00b6b8, .00b6b8): exec(1), time(0.013 ms): float64.log(x: float64): float64
::[.00b898, .00b898): exec(5), time(0.037 ms): float64.exp(x: float64): float64
::[.00bb08, .00bb08): exec(1), time(0.008 ms): float64.pow(x: float64, y: float64): float64
::[.00bce8, .00bce8): exec(3), time(0.022 ms): float64.sqrt(x: float64): float64
::[.00bf58, .00bf58): exec(3), time(0.026 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:39:[.04a6b8, .04a716): exec(8), time(0.073 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.04a718, .04a76e): exec(10), time(0.102 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:46:[.04a770, .04a788): exec(6), time(0.179-0.093 ms): Math.floor(x: float64): float64
lib/std/math.ci:58:[.04a788, .04a7ac): exec(3), time(0.029 ms): Math.sign(x: float32): int32
lib/std/math.ci:67:[.04a7b0, .04a7d4): exec(3), time(0.027 ms): Math.sign(x: float64): int32
lib/std/math.ci:83:[.04a7d8, .04a7ea): exec(3), time(0.043 ms): Math.abs(x: float32): float32
lib/std/math.ci:89:[.04a7f0, .04a802): exec(4), time(0.047 ms): Math.abs(x: float64): float64
lib/std/math.ci:95:[.04a808, .04a823): exec(11), time(0.098 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.04a828, .04a843): exec(11), time(0.098 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:114:[.04a848, .04a859): exec(1), time(0.014 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:120:[.04a860, .04a871): exec(1), time(0.015 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:132:[.04a878, .04a889): exec(1), time(0.014 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:138:[.04a890, .04a8a1): exec(1), time(0.015 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:150:[.04a8a8, .04a8c6): exec(2), time(0.026 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:159:[.04a8c8, .04a8e6): exec(2), time(0.021 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:185:[.04a8e8, .04a930): exec(2), time(0.048 ms): Math.min(data: float64[]): float64
lib/std/math.ci:197:[.04a930, .04a978): exec(2), time(0.047 ms): Math.max(data: float64[]): float64
lib/std/math.ci:210:[.04a978, .04a9a0): exec(4), time(0.093 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:228:[.04a9a0, .04a9cf): exec(3), time(0.073 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:236:[.04a9d0, .04aa09): exec(1), time(0.011 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:249:[.04aa10, .04aa49): exec(1), time(0.011 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:263:[.04aa50, .04ab9f): exec(2), time(0.052 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:320:[.04aba0, .04ad13): exec(1), time(0.044-0.009 ms): Math.tan(arg: float64): float64
lib/std/math.ci:377:[.04ad18, .04ae09): exec(1), time(0.043-0.015 ms): Math.sinh(x: float64): float64
lib/std/math.ci:416:[.04ae10, .04ae5b): exec(1), time(0.037-0.014 ms): Math.cosh(x: float64): float64
lib/std/math.ci:432:[.04ae60, .04af06): exec(2), time(0.087-0.029 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:20:[.04af08, .04af0f): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:25:[.04af10, .04af17): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:66:[.04af18, .04af93): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:93:[.04af98, .04afb7): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:107:[.04afb8, .04b01c): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:3:[.04b020, .04b046): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:14:[.04b048, .04b07a): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:24:[.04b080, .04b0b2): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:35:[.04b0b8, .04b101): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:44:[.04b108, .04b186): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:58:[.04b188, .04b1c7): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:71:[.04b1c8, .04b20f): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:70:[.04b210, .04b234): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:84:[.04b238, .04b246): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:113:[.04b248, .04b29c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:129:[.04b2b0, .04b541): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:192:[.04b548, .04b55f): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:196:[.04b560, .04b591): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:205:[.04b5a8, .04b5c1): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:8:[.04b5c8, .04b5cf): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:21:[.04b5d0, .04b5dd): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:13:[.04b5e0, .04b611): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:25:[.04b618, .04b62d): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:33:[.04b630, .04b7d1): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:3:[.04b7e0, .04b7e1): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:6:[.04b7e8, .04b7f0): exec(2), time(0.020 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.04b7f0, .04b7f8): exec(2), time(0.019 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.04b7f8, .04b82e): exec(753), time(12.805 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.04b830, .04b831): exec(1), time(0.010 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.04b838, .04b850): exec(64-64), time(1.019 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.04b850, .04b85c): exec(1-1), time(0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.04b860, .04b8a4): exec(1-1), time(0.105-0.084 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.04b8a8, .04b8b5): exec(1-1), time(0.011 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.04b8b8, .04b8ba): exec(1-1), time(0.009 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.04b8c0, .04b8c4): exec(5), time(0.050 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.04b8c8, .04b8d4): exec(21), time(0.233 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.04b8d8, .04b8e4): exec(21), time(0.239 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.04b8e8, .04b8f4): exec(14), time(0.158 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.04b928, .04b94f): exec(3), time(0.317-0.262 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:25:[.04b958, .04b97f): exec(4), time(0.401-0.327 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:30:[.04b980, .04b9a7): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.04b9a8, .04b9cf): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:62:[.04b9d0, .04ba12): exec(1), time(0.178-0.148 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:68:[.04ba18, .04ba57): exec(1), time(0.177-0.148 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.04ba57, .04e506): exec(1), time(23.472-18.130 ms): .main

---------- Profile statements: 898/1148, coverage: 78.22%
lib/stdlib.ci:41:[.04a6c1, .04a6c2) exec(8), time(0.043-0.043 ms): <assertEq+9>
lib/stdlib.ci:40:[.04a6b8, .04a6c2) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:44:[.04a6c6, .04a6d1) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:45:[.04a6d1, .04a6dc) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:46:[.04a6dc, .04a6df) exec(0), time(0.000 ms): <assertEq+36>
::[.04a6df, .04a6eb) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:43:[.04a6c2, .04a6eb) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:48:[.04a6eb, .04a711) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.04a730, .04a741) exec(3), time(0.041-0.041 ms): <modf+24>
lib/std/math.ci:26:[.04a741, .04a748) exec(3), time(0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.04a748, .04a74b) exec(3), time(0.015-0.015 ms): <modf+48>
lib/std/math.ci:24:[.04a728, .04a74f) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.04a74f, .04a753) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.04a753, .04a757) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.04a718, .04a757) exec(10-3), time(0.002-0.002 ms): <modf+0>
lib/std/math.ci:32:[.04a757, .04a763) exec(7), time(0.002-0.002 ms): <modf+63>
lib/std/math.ci:33:[.04a763, .04a76b) exec(7), time(0.004-0.004 ms): <modf+75>
lib/std/math.ci:34:[.04a76b, .04a76e) exec(7), time(0.039-0.039 ms): <modf+83>
lib/std/math.ci:47:[.04a770, .04a771) exec(6), time(0.002-0.002 ms): <floor+0>
lib/std/math.ci:48:[.04a771, .04a785) exec(6), time(0.127-0.127 ms): <floor+1>
lib/std/math.ci:49:[.04a785, .04a788) exec(6), time(0.031-0.031 ms): <floor+21>
lib/std/math.ci:60:[.04a790, .04a794) exec(1), time(0.011-0.011 ms): <sign+8>
lib/std/math.ci:59:[.04a788, .04a794) exec(3-1), time(0.001-0.001 ms): <sign+0>
lib/std/math.ci:63:[.04a79c, .04a7a4) exec(1), time(0.006-0.006 ms): <sign+20>
lib/std/math.ci:62:[.04a794, .04a7a4) exec(2-1), time(0.000 ms): <sign+12>
lib/std/math.ci:65:[.04a7a4, .04a7ac) exec(1), time(0.005-0.005 ms): <sign+28>
lib/std/math.ci:69:[.04a7b8, .04a7bc) exec(1), time(0.006-0.006 ms): <sign+8>
lib/std/math.ci:68:[.04a7b0, .04a7bc) exec(3-1), time(0.002-0.002 ms): <sign+0>
lib/std/math.ci:72:[.04a7c4, .04a7cc) exec(1), time(0.005-0.005 ms): <sign+20>
lib/std/math.ci:71:[.04a7bc, .04a7cc) exec(2-1), time(0.001-0.001 ms): <sign+12>
lib/std/math.ci:74:[.04a7cc, .04a7d4) exec(1), time(0.006-0.006 ms): <sign+28>
lib/std/math.ci:85:[.04a7e0, .04a7e6) exec(1), time(0.009-0.009 ms): <abs+8>
lib/std/math.ci:84:[.04a7d8, .04a7e6) exec(3-1), time(0.001-0.001 ms): <abs+0>
lib/std/math.ci:87:[.04a7e6, .04a7ea) exec(2), time(0.016-0.016 ms): <abs+14>
lib/std/math.ci:91:[.04a7f8, .04a7fe) exec(1), time(0.008-0.008 ms): <abs+8>
lib/std/math.ci:90:[.04a7f0, .04a7fe) exec(4-1), time(0.003-0.003 ms): <abs+0>
lib/std/math.ci:93:[.04a7fe, .04a802) exec(3), time(0.019-0.019 ms): <abs+14>
lib/std/math.ci:97:[.04a817, .04a81f) exec(4), time(0.024-0.024 ms): <absMod+15>
lib/std/math.ci:96:[.04a808, .04a81f) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:99:[.04a81f, .04a823) exec(7), time(0.038-0.038 ms): <absMod+23>
lib/std/math.ci:103:[.04a837, .04a83f) exec(4), time(0.023-0.023 ms): <absMod+15>
lib/std/math.ci:102:[.04a828, .04a83f) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:105:[.04a83f, .04a843) exec(7), time(0.039-0.039 ms): <absMod+23>
lib/std/math.ci:116:[.04a851, .04a855) exec(1), time(0.007-0.007 ms): <min+9>
lib/std/math.ci:115:[.04a848, .04a855) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:118:[.04a855, .04a859) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:122:[.04a869, .04a86d) exec(1), time(0.008-0.008 ms): <min+9>
lib/std/math.ci:121:[.04a860, .04a86d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:124:[.04a86d, .04a871) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:134:[.04a881, .04a885) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:133:[.04a878, .04a885) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:136:[.04a885, .04a889) exec(1), time(0.008-0.008 ms): <max+13>
lib/std/math.ci:140:[.04a899, .04a89d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:139:[.04a890, .04a89d) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:142:[.04a89d, .04a8a1) exec(1), time(0.008-0.008 ms): <max+13>
lib/std/math.ci:152:[.04a8b1, .04a8b5) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:151:[.04a8a8, .04a8b5) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:155:[.04a8be, .04a8c2) exec(1), time(0.008-0.008 ms): <clamp+22>
lib/std/math.ci:154:[.04a8b5, .04a8c2) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:157:[.04a8c2, .04a8c6) exec(1), time(0.005-0.005 ms): <clamp+26>
lib/std/math.ci:161:[.04a8d1, .04a8d5) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.04a8c8, .04a8d5) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.04a8de, .04a8e2) exec(1), time(0.005-0.005 ms): <clamp+22>
lib/std/math.ci:163:[.04a8d5, .04a8e2) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.04a8e2, .04a8e6) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:187:[.04a8f0, .04a8f5) exec(1), time(0.005-0.005 ms): <min+8>
lib/std/math.ci:186:[.04a8e8, .04a8f5) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:189:[.04a8f5, .04a8f8) exec(1), time(0.001-0.001 ms): <min+13>
lib/std/math.ci:192:[.04a911, .04a91c) exec(2), time(0.001-0.001 ms): <min+41>
lib/std/math.ci:191:[.04a901, .04a91c) exec(8-2), time(0.004-0.004 ms): <min+25>
lib/std/math.ci:190:[.04a91c, .04a920) exec(8), time(0.002-0.002 ms): <min+52>
lib/std/math.ci:190:[.04a920, .04a929) exec(9), time(0.006-0.006 ms): <min+56>
lib/std/math.ci:190:[.04a8f8, .04a92d) exec(1), time(0.001-0.001 ms): <min+16>
lib/std/math.ci:195:[.04a92d, .04a930) exec(1), time(0.006-0.006 ms): <min+69>
lib/std/math.ci:199:[.04a938, .04a93d) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:198:[.04a930, .04a93d) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:201:[.04a93d, .04a940) exec(1), time(0.001-0.001 ms): <max+13>
lib/std/math.ci:204:[.04a959, .04a964) exec(2), time(0.002-0.002 ms): <max+41>
lib/std/math.ci:203:[.04a949, .04a964) exec(8-2), time(0.003-0.003 ms): <max+25>
lib/std/math.ci:202:[.04a964, .04a968) exec(8), time(0.003-0.003 ms): <max+52>
lib/std/math.ci:202:[.04a968, .04a971) exec(9), time(0.003-0.003 ms): <max+56>
lib/std/math.ci:202:[.04a940, .04a975) exec(1), time(0.001-0.001 ms): <max+16>
lib/std/math.ci:207:[.04a975, .04a978) exec(1), time(0.006-0.006 ms): <max+69>
lib/std/math.ci:211:[.04a978, .04a979) exec(4), time(0.003-0.003 ms): <sum+0>
lib/std/math.ci:213:[.04a97e, .04a98c) exec(13), time(0.013-0.013 ms): <sum+6>
lib/std/math.ci:212:[.04a98c, .04a990) exec(13), time(0.003-0.003 ms): <sum+20>
lib/std/math.ci:212:[.04a990, .04a999) exec(17), time(0.014-0.014 ms): <sum+24>
lib/std/math.ci:212:[.04a979, .04a99d) exec(4), time(0.004-0.004 ms): <sum+1>
lib/std/math.ci:215:[.04a99d, .04a9a0) exec(4), time(0.022-0.022 ms): <sum+37>
lib/std/math.ci:229:[.04a9a0, .04a9a1) exec(3), time(0.002-0.002 ms): <eval+0>
lib/std/math.ci:231:[.04a9ab, .04a9bc) exec(11), time(0.011-0.011 ms): <eval+11>
lib/std/math.ci:230:[.04a9bc, .04a9c0) exec(11), time(0.003-0.003 ms): <eval+28>
lib/std/math.ci:230:[.04a9c0, .04a9c8) exec(14), time(0.008-0.008 ms): <eval+32>
lib/std/math.ci:230:[.04a9a1, .04a9cc) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:233:[.04a9cc, .04a9cf) exec(3), time(0.017-0.017 ms): <eval+44>
lib/std/math.ci:239:[.04a9e5, .04a9ed) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:238:[.04a9d9, .04a9ed) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:244:[.04a9fd, .04aa05) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:243:[.04a9f1, .04aa05) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:237:[.04a9d0, .04aa05) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:247:[.04aa05, .04aa09) exec(1), time(0.005-0.005 ms): <cmp+53>
lib/std/math.ci:252:[.04aa25, .04aa2d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:251:[.04aa19, .04aa2d) exec(1), time(0.000 ms): <cmp+9>
lib/std/math.ci:257:[.04aa3d, .04aa45) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:256:[.04aa31, .04aa45) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:250:[.04aa10, .04aa45) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:260:[.04aa45, .04aa49) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:277:[.04aa50, .04aa52) exec(2), time(0.000 ms): <sinCos+0>
lib/std/math.ci:279:[.04aa5a, .04aa5b) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:280:[.04aa5b, .04aa63) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:278:[.04aa52, .04aa63) exec(2), time(0.000 ms): <sinCos+2>
lib/std/math.ci:283:[.04aa63, .04aa64) exec(2), time(0.000 ms): <sinCos+19>
lib/std/math.ci:284:[.04aa64, .04aa7c) exec(2), time(0.000 ms): <sinCos+20>
lib/std/math.ci:286:[.04aa8c, .04aa8d) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:287:[.04aa8d, .04aa9f) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:288:[.04aa9f, .04aaa3) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:290:[.04aaa3, .04aaa4) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:291:[.04aaa4, .04aac2) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:292:[.04aac2, .04aad4) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:295:[.04aadc, .04aadf) exec(2), time(0.000 ms): <sinCos+140>
lib/std/math.ci:296:[.04aadf, .04aae7) exec(2), time(0.000 ms): <sinCos+143>
lib/std/math.ci:297:[.04aae7, .04aaee) exec(2), time(0.000 ms): <sinCos+151>
lib/std/math.ci:298:[.04aaee, .04aaf4) exec(2), time(0.000 ms): <sinCos+158>
lib/std/math.ci:285:[.04aa7c, .04aaf8) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:301:[.04ab00, .04ab0e) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:300:[.04aaf8, .04ab0e) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:304:[.04ab1a, .04ab1b) exec(1), time(0.000 ms): <sinCos+202>
lib/std/math.ci:303:[.04ab0e, .04ab1b) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:307:[.04ab1b, .04ab20) exec(2), time(0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:308:[.04ab20, .04ab60) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:309:[.04ab60, .04ab93) exec(2), time(0.003-0.003 ms): <sinCos+272>
lib/std/math.ci:310:[.04ab93, .04ab9f) exec(2), time(0.012-0.012 ms): <sinCos+323>
lib/std/math.ci:333:[.04aba0, .04aba1) exec(1), time(0.000 ms): <tan+0>
lib/std/math.ci:334:[.04aba1, .04aba2) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:337:[.04abaa, .04abaf) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:338:[.04abaf, .04abb9) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:336:[.04aba2, .04abb9) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:340:[.04abb9, .04abd1) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:342:[.04abd1, .04abd2) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:343:[.04abd2, .04abe2) exec(1), time(0.016-0.016 ms): <tan+50>
lib/std/math.ci:344:[.04abe2, .04abeb) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:348:[.04abff, .04ac0d) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:349:[.04ac0d, .04ac17) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:352:[.04ac27, .04ac32) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:353:[.04ac32, .04ac3c) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:356:[.04ac4c, .04ac5a) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:357:[.04ac5a, .04ac65) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:355:[.04ac40, .04ac65) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:351:[.04ac1b, .04ac65) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:347:[.04abf3, .04ac65) exec(1), time(0.001-0.001 ms): <tan+83>
lib/std/math.ci:346:[.04abeb, .04ac65) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:360:[.04ac65, .04ac6a) exec(1), time(0.000 ms): <tan+197>
lib/std/math.ci:361:[.04ac6a, .04acaa) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:362:[.04acaa, .04acd1) exec(1), time(0.002-0.002 ms): <tan+266>
lib/std/math.ci:366:[.04ace2, .04aceb) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:365:[.04acda, .04aceb) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:368:[.04aceb, .04acf9) exec(1), time(0.001-0.001 ms): <tan+331>
lib/std/math.ci:364:[.04acd1, .04acf9) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:371:[.04ad02, .04ad0c) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:370:[.04acf9, .04ad0c) exec(1), time(0.001-0.001 ms): <tan+345>
lib/std/math.ci:373:[.04ad0c, .04ad13) exec(1), time(0.006-0.006 ms): <tan+364>
lib/std/math.ci:389:[.04ad18, .04ad19) exec(1), time(0.001-0.001 ms): <sinh+0>
lib/std/math.ci:391:[.04ad21, .04ad26) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:392:[.04ad26, .04ad30) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:390:[.04ad19, .04ad30) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:396:[.04ad40, .04ad57) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:395:[.04ad30, .04ad57) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:399:[.04ad57, .04ad58) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:401:[.04ad68, .04ad82) exec(1), time(0.028-0.028 ms): <sinh+80>
lib/std/math.ci:404:[.04ad86, .04ad8b) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:405:[.04ad8b, .04adc0) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:406:[.04adc0, .04adeb) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:400:[.04ad58, .04adef) exec(1), time(0.029-0.029 ms): <sinh+64>
lib/std/math.ci:410:[.04adf8, .04ae02) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:409:[.04adef, .04ae02) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:412:[.04ae02, .04ae09) exec(1), time(0.006-0.006 ms): <sinh+234>
lib/std/math.ci:418:[.04ae18, .04ae1d) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:417:[.04ae10, .04ae1d) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:421:[.04ae2d, .04ae40) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:420:[.04ae1d, .04ae40) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:423:[.04ae40, .04ae5b) exec(1), time(0.032-0.032 ms): <cosh+48>
lib/std/math.ci:435:[.04ae68, .04ae6c) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:433:[.04ae60, .04ae6c) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:438:[.04ae6c, .04ae6d) exec(2), time(0.000 ms): <asin+12>
lib/std/math.ci:440:[.04ae75, .04ae7f) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:441:[.04ae7f, .04ae84) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:439:[.04ae6d, .04ae84) exec(2), time(0.000 ms): <asin+13>
lib/std/math.ci:446:[.04ae94, .04ae9d) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:444:[.04ae84, .04ae9d) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:449:[.04ae9d, .04aeb0) exec(2), time(0.028-0.028 ms): <asin+61>
lib/std/math.ci:451:[.04aec0, .04aede) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:454:[.04aee2, .04aeec) exec(2), time(0.028-0.028 ms): <asin+130>
lib/std/math.ci:450:[.04aeb0, .04aeec) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:458:[.04aef5, .04aeff) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:457:[.04aeec, .04aeff) exec(2), time(0.002-0.002 ms): <asin+140>
lib/std/math.ci:460:[.04aeff, .04af06) exec(2), time(0.012-0.012 ms): <asin+159>
::[.04af0b, .04af0e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:21:[.04af08, .04af0f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:28:[.04af13, .04af16) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:26:[.04af10, .04af17) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:71:[.04af37, .04af3c) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:72:[.04af3c, .04af44) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:75:[.04af51, .04af5e) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:73:[.04af44, .04af63) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:70:[.04af18, .04af67) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:78:[.04af67, .04af6c) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:79:[.04af6c, .04af74) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:82:[.04af81, .04af8e) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:80:[.04af74, .04af93) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:94:[.04af98, .04afa3) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:97:[.04afaa, .04afb2) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:95:[.04afa3, .04afb7) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:108:[.04afb8, .04afcf) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:109:[.04afcf, .04afdf) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:110:[.04afdf, .04afee) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:111:[.04afee, .04b001) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:114:[.04b00c, .04b017) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:112:[.04b001, .04b01c) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:5:[.04b02c, .04b030) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:4:[.04b020, .04b030) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:7:[.04b030, .04b031) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:8:[.04b035, .04b039) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:8:[.04b039, .04b043) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:8:[.04b031, .04b043) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:10:[.04b043, .04b046) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:17:[.04b05d, .04b060) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:16:[.04b04d, .04b060) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:15:[.04b060, .04b064) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:15:[.04b064, .04b06e) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:15:[.04b048, .04b072) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:20:[.04b072, .04b07a) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:25:[.04b080, .04b085) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:28:[.04b09a, .04b09d) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:27:[.04b08a, .04b09d) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:26:[.04b09d, .04b0a1) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:26:[.04b0a1, .04b0ab) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:26:[.04b085, .04b0af) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:31:[.04b0af, .04b0b2) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:38:[.04b0d7, .04b0e2) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:37:[.04b0bd, .04b0e2) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:36:[.04b0e2, .04b0e6) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:36:[.04b0e6, .04b0f2) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:36:[.04b0b8, .04b0f6) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:41:[.04b0f6, .04b101) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:45:[.04b108, .04b115) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:46:[.04b115, .04b122) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:48:[.04b12b, .04b136) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:47:[.04b122, .04b136) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:52:[.04b15b, .04b166) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:51:[.04b13b, .04b166) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:50:[.04b166, .04b16a) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:50:[.04b16a, .04b173) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:50:[.04b136, .04b177) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:55:[.04b177, .04b186) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:59:[.04b188, .04b189) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:61:[.04b18e, .04b1a4) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:63:[.04b1b0, .04b1b4) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:62:[.04b1a4, .04b1b4) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:60:[.04b1b4, .04b1b8) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:60:[.04b1b8, .04b1c0) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:60:[.04b189, .04b1c4) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:66:[.04b1c4, .04b1c7) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:73:[.04b1d7, .04b1e2) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:72:[.04b1c8, .04b1e2) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:76:[.04b1f1, .04b1fc) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:75:[.04b1e2, .04b1fc) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:78:[.04b1fc, .04b20f) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:81:[.04b210, .04b234) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:85:[.04b238, .04b246) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:116:[.04b256, .04b25a) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:115:[.04b24d, .04b25a) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:118:[.04b25a, .04b266) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:119:[.04b266, .04b26e) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:114:[.04b26e, .04b272) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:114:[.04b272, .04b27c) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:114:[.04b248, .04b280) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:123:[.04b289, .04b291) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:122:[.04b280, .04b291) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:125:[.04b291, .04b298) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:126:[.04b298, .04b29c) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:133:[.04b2b0, .04b2b1) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:134:[.04b2b1, .04b2b5) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:136:[.04b2b5, .04b2b8) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:137:[.04b2b8, .04b2ee) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:138:[.04b2ee, .04b323) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:142:[.04b327, .04b342) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:141:[.04b342, .04b349) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:141:[.04b349, .04b351) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:141:[.04b323, .04b351) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:145:[.04b359, .04b36e) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:144:[.04b351, .04b36e) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:148:[.04b36e, .04b378) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:150:[.04b378, .04b37f) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:152:[.04b38a, .04b394) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:151:[.04b37f, .04b394) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:157:[.04b39f, .04b3a7) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:161:[.04b3c5, .04b3f9) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:162:[.04b3f9, .04b404) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:163:[.04b404, .04b40c) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:160:[.04b40c, .04b414) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:160:[.04b414, .04b41c) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:160:[.04b3c1, .04b41c) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:158:[.04b3a7, .04b41c) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:166:[.04b41c, .04b450) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:167:[.04b450, .04b45b) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:168:[.04b45b, .04b463) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:156:[.04b394, .04b463) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:173:[.04b467, .04b49b) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:174:[.04b49b, .04b4a6) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:175:[.04b4a6, .04b4ae) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:172:[.04b4ae, .04b4b6) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:172:[.04b4b6, .04b4be) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:172:[.04b463, .04b4be) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:180:[.04b4c3, .04b4f7) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:181:[.04b4f7, .04b508) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:182:[.04b508, .04b510) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:179:[.04b510, .04b514) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:179:[.04b514, .04b51d) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:179:[.04b4be, .04b521) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:186:[.04b52a, .04b532) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:185:[.04b521, .04b532) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:188:[.04b532, .04b539) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:189:[.04b539, .04b541) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:193:[.04b548, .04b55f) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:197:[.04b560, .04b561) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:199:[.04b569, .04b570) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:200:[.04b570, .04b575) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:198:[.04b561, .04b575) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:202:[.04b575, .04b591) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:207:[.04b5a8, .04b5c1) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:11:[.04b5cb, .04b5ce) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:9:[.04b5c8, .04b5cf) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:22:[.04b5d3, .04b5d6) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:22:[.04b5d6, .04b5d9) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:22:[.04b5d9, .04b5dc) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:22:[.04b5d0, .04b5dd) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:18:[.04b5e3, .04b5e6) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:18:[.04b5e6, .04b5e9) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:18:[.04b5e9, .04b5ec) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:19:[.04b5ec, .04b5ef) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:19:[.04b5ef, .04b5f2) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:19:[.04b5f2, .04b5f5) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:19:[.04b5f5, .04b5f8) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:20:[.04b5f8, .04b5fb) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:20:[.04b5fb, .04b5fe) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:20:[.04b5fe, .04b601) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:20:[.04b601, .04b604) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:21:[.04b604, .04b607) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:21:[.04b607, .04b60a) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:21:[.04b60a, .04b60d) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:21:[.04b60d, .04b610) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:17:[.04b5e0, .04b611) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:26:[.04b61d, .04b622) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:26:[.04b622, .04b627) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:26:[.04b627, .04b62c) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:26:[.04b618, .04b62d) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:35:[.04b634, .04b639) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:35:[.04b639, .04b642) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:35:[.04b642, .04b64b) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:35:[.04b64b, .04b654) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:36:[.04b654, .04b65d) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:36:[.04b65d, .04b666) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:36:[.04b666, .04b66f) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:36:[.04b66f, .04b678) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:37:[.04b678, .04b681) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:37:[.04b681, .04b68a) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:37:[.04b68a, .04b693) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:37:[.04b693, .04b69c) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:38:[.04b69c, .04b6a5) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:38:[.04b6a5, .04b6ae) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:38:[.04b6ae, .04b6b7) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:38:[.04b6b7, .04b6c0) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:34:[.04b630, .04b6c0) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:43:[.04b700, .04b744) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:44:[.04b744, .04b788) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:45:[.04b788, .04b7cc) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:41:[.04b6c0, .04b7d1) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:7:[.04b7e8, .04b7f0) exec(2), time(0.015-0.015 ms): <funAdd+0>
test/lang/function.ci:33:[.04b7f0, .04b7f8) exec(2), time(0.014-0.014 ms): <funMul+0>
test/lang/function.ci:39:[.04b804, .04b808) exec(377), time(2.404-2.404 ms): <fib+12>
test/lang/function.ci:38:[.04b7f8, .04b808) exec(753-377), time(0.412-0.412 ms): <fib+0>
test/lang/function.ci:41:[.04b808, .04b82e) exec(376-375), time(12.802-12.802 ms): <fib+16>
test/stdc/tryExec.ci:15:[.04b838, .04b83c) exec(64-1), time(0.030-0.030 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.04b83c, .04b84b) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.04b850, .04b857) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.04b864, .04b86b) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.04b86b, .04b872) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.04b872, .04b879) exec(1), time(0.000 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.04b860, .04b879) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.04b879, .04b89f) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.04b8a8, .04b8ad) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.04b8ad, .04b8b0) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.04b8b8, .04b8ba) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.04b8c0, .04b8c4) exec(5), time(0.033-0.033 ms): <lenSlice+0>
test/lang/array.ci:104:[.04b8c8, .04b8d4) exec(21), time(0.155-0.155 ms): <nthFixed+0>
test/lang/array.ci:105:[.04b8d8, .04b8e4) exec(21), time(0.157-0.157 ms): <nthArray+0>
test/lang/array.ci:106:[.04b8e8, .04b8f4) exec(14), time(0.104-0.104 ms): <nthSlice+0>
test/lang/method.ci:7:[.04b928, .04b94e) exec(3), time(0.286-0.286 ms): <staticMethod+0>
test/lang/method.ci:26:[.04b958, .04b97e) exec(4), time(0.361-0.361 ms): <virtualMethod+0>
test/lang/method.ci:31:[.04b980, .04b9a6) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.04b9a8, .04b9ce) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:63:[.04b9d0, .04b9f3) exec(1), time(0.022-0.022 ms): <staticMethod+0>
test/lang/method.ci:65:[.04ba01, .04ba11) exec(1), time(0.142-0.142 ms): <staticMethod+49>
test/lang/method.ci:64:[.04b9f3, .04ba11) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:69:[.04ba18, .04ba3b) exec(1), time(0.023-0.023 ms): <virtualMethod+0>
test/lang/method.ci:71:[.04ba49, .04ba56) exec(1), time(0.143-0.143 ms): <virtualMethod+49>
test/lang/method.ci:70:[.04ba3b, .04ba56) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:130:[.04ba57, .04ba65) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:131:[.04ba65, .04ba73) exec(1), time(0.000 ms): <.main+14>
::[.04ba7c, .04ba83) exec(1), time(0.002-0.002 ms): <.main+37>
::[.04ba83, .04ba88) exec(1), time(0.001-0.001 ms): <.main+44>
::[.04ba88, .04ba8d) exec(1), time(0.000 ms): <.main+49>
lib/std/string.ci:206:[.04ba73, .04ba8d) exec(1-1), time(0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.04ba8d, .04ba9a) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.04ba9a, .04ba9f) exec(1), time(0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.04ba9f, .04baa8) exec(1), time(0.000 ms): <.main+72>
test/lang/member.ci:41:[.04baa8, .04bab1) exec(1), time(0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.04baba, .04bac3) exec(1), time(0.001-0.001 ms): <.main+99>
test/lang/member.ci:47:[.04bab1, .04bac3) exec(1-1), time(0.000 ms): <.main+90>
test/lang/member.ci:50:[.04bacc, .04bad5) exec(1), time(0.000 ms): <.main+117>
test/lang/member.ci:50:[.04bac3, .04bad5) exec(1-1), time(0.000 ms): <.main+108>
test/lang/method.ci:11:[.04bad5, .04bade) exec(1), time(0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.04bade, .04badf) exec(1), time(0.001-0.001 ms): <.main+135>
test/lang/emit.ci:4:[.04badf, .04bae0) exec(1), time(0.001-0.001 ms): <.main+136>
test/lang/emit.ci:6:[.04bae0, .04bae5) exec(1), time(0.000 ms): <.main+137>
test/lang/emit.ci:7:[.04bae5, .04baea) exec(1), time(0.000 ms): <.main+142>
test/lang/emit.ci:9:[.04baea, .04baef) exec(1), time(0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.04baef, .04bafa) exec(1), time(0.001-0.001 ms): <.main+152>
test/lang/emit.ci:17:[.04bafa, .04baff) exec(1), time(0.001-0.001 ms): <.main+163>
test/lang/emit.ci:18:[.04baff, .04bb05) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.04bb05, .04bb0f) exec(1), time(0.001-0.001 ms): <.main+174>
test/lang/emit.ci:20:[.04bb0f, .04bb18) exec(1), time(0.001-0.001 ms): <.main+184>
test/lang/emit.ci:23:[.04bb18, .04bb22) exec(1), time(0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.04bb22, .04bb27) exec(1), time(0.000 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.04bb27, .04bb2c) exec(1), time(0.000 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.04bb2c, .04bb31) exec(1), time(0.000 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.04bb31, .04bb36) exec(1), time(0.000 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.04bb36, .04bb37) exec(1), time(0.000 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.04bb37, .04bb38) exec(1), time(0.000 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.04bb38, .04bb39) exec(1), time(0.000 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.04bb39, .04bb3e) exec(1), time(0.001-0.001 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.04bb3e, .04bb40) exec(1), time(0.001-0.001 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.04bb40, .04bb4a) exec(1), time(0.001-0.001 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.04bb4a, .04bb53) exec(1), time(0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.04bb53, .04bb58) exec(1), time(0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.04bb58, .04bb69) exec(1), time(0.002-0.002 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.04bb69, .04bb81) exec(1), time(0.002-0.002 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.04bb81, .04bb93) exec(1), time(0.002-0.002 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.04bb93, .04bbb1) exec(1), time(0.002-0.002 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.04bbb1, .04bbd2) exec(1), time(0.003-0.003 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.04bbd2, .04bbed) exec(1), time(0.003-0.003 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.04bbed, .04bc14) exec(1), time(0.004-0.004 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.04bc14, .04bc35) exec(1), time(0.003-0.003 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.04bc35, .04bc50) exec(1), time(0.003-0.003 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.04bc50, .04bc77) exec(1), time(0.004-0.004 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.04bc77, .04bc8c) exec(1), time(0.002-0.002 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.04bc8c, .04bc9d) exec(1), time(0.001-0.001 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.04bc9d, .04bca8) exec(1), time(0.002-0.002 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.04bca8, .04bcb3) exec(1), time(0.002-0.002 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.04bcb3, .04bcd2) exec(1), time(0.004-0.004 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.04bcd2, .04bcf1) exec(1), time(0.004-0.004 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.04bcf1, .04bd2f) exec(1), time(0.002-0.002 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.04bd2f, .04bd6d) exec(1), time(0.005-0.005 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.04bd6d, .04bd9f) exec(1), time(0.002-0.002 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.04bd9f, .04bdd1) exec(1), time(0.005-0.005 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.04bdd1, .04be17) exec(1), time(0.003-0.003 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.04be17, .04be5d) exec(1), time(0.006-0.006 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.04be5d, .04beb6) exec(1), time(0.009-0.009 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.04beb6, .04bf0f) exec(1), time(0.009-0.009 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.04bf0f, .04bf5c) exec(1), time(0.009-0.009 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.04bf5c, .04bfa9) exec(1), time(0.010-0.010 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.04bfa9, .04c00a) exec(1), time(0.011-0.011 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.04c00a, .04c06b) exec(1), time(0.011-0.011 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.04c06b, .04c0c4) exec(1), time(0.009-0.009 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.04c0c4, .04c11d) exec(1), time(0.010-0.010 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.04c11d, .04c16a) exec(1), time(0.009-0.009 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.04c16a, .04c1b7) exec(1), time(0.010-0.010 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.04c1b7, .04c218) exec(1), time(0.011-0.011 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.04c218, .04c279) exec(1), time(0.012-0.012 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.04c279, .04c27e) exec(1), time(0.000 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.04c27e, .04c283) exec(1), time(0.000 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.04c283, .04c288) exec(1), time(0.000 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.04c288, .04c28d) exec(1), time(0.001-0.001 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.04c28d, .04c292) exec(1), time(0.001-0.001 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.04c292, .04c29b) exec(1), time(0.000 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.04c29b, .04c2b1) exec(1), time(0.002-0.002 ms): <.main+2116>
test/lang/initByRef.ci:8:[.04c2b1, .04c2b6) exec(1), time(0.000 ms): <.main+2138>
test/lang/initByRef.ci:9:[.04c2b6, .04c2bb) exec(1), time(0.000 ms): <.main+2143>
test/lang/initByRef.ci:10:[.04c2bb, .04c2c5) exec(1), time(0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.04c2c5, .04c2c8) exec(1), time(0.001-0.001 ms): <.main+2158>
test/lang/initByRef.ci:13:[.04c2c8, .04c2ca) exec(1), time(0.001-0.001 ms): <.main+2161>
test/lang/initByRef.ci:14:[.04c2ca, .04c2cc) exec(1), time(0.000 ms): <.main+2163>
test/lang/initByRef.ci:16:[.04c2cc, .04c2d1) exec(1), time(0.000 ms): <.main+2165>
test/lang/initByRef.ci:17:[.04c2d1, .04c2d6) exec(1), time(0.000 ms): <.main+2170>
test/lang/initByRef.ci:18:[.04c2d6, .04c2e0) exec(1), time(0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.04c2e0, .04c2e5) exec(1), time(0.000 ms): <.main+2185>
test/lang/initByRef.ci:20:[.04c2e5, .04c2ea) exec(1), time(0.000 ms): <.main+2190>
test/lang/initByRef.ci:21:[.04c2ea, .04c2ef) exec(1), time(0.001-0.001 ms): <.main+2195>
test/lang/initByRef.ci:23:[.04c2ef, .04c2f4) exec(1), time(0.001-0.001 ms): <.main+2200>
test/lang/initByRef.ci:24:[.04c2f4, .04c2fe) exec(1), time(0.000 ms): <.main+2205>
test/lang/initByRef.ci:25:[.04c2fe, .04c303) exec(1), time(0.001-0.001 ms): <.main+2215>
test/lang/initByRef.ci:27:[.04c303, .04c307) exec(1), time(0.001-0.001 ms): <.main+2220>
test/lang/initByRef.ci:28:[.04c307, .04c309) exec(1), time(0.000 ms): <.main+2224>
test/lang/initByRef.ci:29:[.04c309, .04c30b) exec(1), time(0.000 ms): <.main+2226>
test/lang/initByRef.ci:30:[.04c30b, .04c30d) exec(1), time(0.000 ms): <.main+2228>
test/lang/initByRef.ci:31:[.04c30d, .04c30f) exec(1), time(0.001-0.001 ms): <.main+2230>
test/lang/initByRef.ci:32:[.04c30f, .04c311) exec(1), time(0.000 ms): <.main+2232>
test/lang/initByRef.ci:35:[.04c311, .04c316) exec(1), time(0.000 ms): <.main+2234>
test/lang/initByRef.ci:36:[.04c316, .04c31b) exec(1), time(0.000 ms): <.main+2239>
test/lang/initByRef.ci:37:[.04c31b, .04c320) exec(1), time(0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.04c320, .04c325) exec(1), time(0.001-0.001 ms): <.main+2249>
test/lang/initByRef.ci:39:[.04c325, .04c32a) exec(1), time(0.000 ms): <.main+2254>
test/lang/initByRef.ci:40:[.04c32a, .04c32f) exec(1), time(0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.04c32f, .04c334) exec(1), time(0.000 ms): <.main+2264>
test/lang/initByRef.ci:42:[.04c334, .04c339) exec(1), time(0.000 ms): <.main+2269>
test/lang/initByRef.ci:43:[.04c339, .04c33e) exec(1), time(0.001-0.001 ms): <.main+2274>
test/lang/initByRef.ci:44:[.04c33e, .04c343) exec(1), time(0.000 ms): <.main+2279>
test/lang/initByRef.ci:45:[.04c343, .04c348) exec(1), time(0.000 ms): <.main+2284>
test/lang/initByRef.ci:46:[.04c348, .04c34d) exec(1), time(0.000 ms): <.main+2289>
test/lang/initByRef.ci:47:[.04c34d, .04c352) exec(1), time(0.000 ms): <.main+2294>
test/lang/initByRef.ci:48:[.04c352, .04c357) exec(1), time(0.001-0.001 ms): <.main+2299>
test/lang/initByRef.ci:49:[.04c357, .04c35c) exec(1), time(0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.04c35c, .04c361) exec(1), time(0.000 ms): <.main+2309>
test/lang/initByRef.ci:51:[.04c361, .04c366) exec(1), time(0.000 ms): <.main+2314>
test/lang/initByRef.ci:52:[.04c366, .04c36b) exec(1), time(0.001-0.001 ms): <.main+2319>
test/lang/initByRef.ci:55:[.04c36b, .04c375) exec(1), time(0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.04c375, .04c37f) exec(1), time(0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.04c37f, .04c389) exec(1), time(0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.04c389, .04c393) exec(1), time(0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.04c393, .04c39d) exec(1), time(0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.04c39d, .04c3a7) exec(1), time(0.001-0.001 ms): <.main+2374>
test/lang/initByRef.ci:61:[.04c3a7, .04c3b1) exec(1), time(0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.04c3b1, .04c3bb) exec(1), time(0.000 ms): <.main+2394>
test/lang/initByRef.ci:63:[.04c3bb, .04c3c5) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/initByRef.ci:64:[.04c3c5, .04c3cf) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.04c3cf, .04c3d9) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.04c3d9, .04c3e3) exec(1), time(0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.04c3e3, .04c3ed) exec(1), time(0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.04c3ed, .04c3f7) exec(1), time(0.001-0.001 ms): <.main+2454>
test/lang/initByRef.ci:69:[.04c3f7, .04c401) exec(1), time(0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.04c401, .04c40b) exec(1), time(0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.04c40b, .04c415) exec(1), time(0.001-0.001 ms): <.main+2484>
test/lang/initByRef.ci:72:[.04c415, .04c41f) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.04c41f, .04c424) exec(1), time(0.000 ms): <.main+2504>
test/lang/initByRef.ci:76:[.04c424, .04c429) exec(1), time(0.000 ms): <.main+2509>
test/lang/initByRef.ci:77:[.04c429, .04c42e) exec(1), time(0.001-0.001 ms): <.main+2514>
test/lang/initByRef.ci:78:[.04c42e, .04c433) exec(1), time(0.000 ms): <.main+2519>
test/lang/initByRef.ci:79:[.04c433, .04c438) exec(1), time(0.000 ms): <.main+2524>
test/lang/initByRef.ci:80:[.04c438, .04c43d) exec(1), time(0.001-0.001 ms): <.main+2529>
test/lang/initByRef.ci:81:[.04c43d, .04c442) exec(1), time(0.001-0.001 ms): <.main+2534>
test/lang/initByRef.ci:82:[.04c442, .04c447) exec(1), time(0.000 ms): <.main+2539>
test/lang/initByRef.ci:83:[.04c447, .04c44c) exec(1), time(0.000 ms): <.main+2544>
test/lang/initByRef.ci:84:[.04c44c, .04c451) exec(1), time(0.000 ms): <.main+2549>
test/lang/initByRef.ci:85:[.04c451, .04c456) exec(1), time(0.001-0.001 ms): <.main+2554>
test/lang/initByRef.ci:86:[.04c456, .04c45b) exec(1), time(0.001-0.001 ms): <.main+2559>
test/lang/initByRef.ci:87:[.04c45b, .04c460) exec(1), time(0.000 ms): <.main+2564>
test/lang/initByRef.ci:88:[.04c460, .04c465) exec(1), time(0.000 ms): <.main+2569>
test/lang/initByRef.ci:89:[.04c465, .04c46a) exec(1), time(0.001-0.001 ms): <.main+2574>
test/lang/initByRef.ci:90:[.04c46a, .04c46f) exec(1), time(0.001-0.001 ms): <.main+2579>
test/lang/initByRef.ci:91:[.04c46f, .04c474) exec(1), time(0.000 ms): <.main+2584>
test/lang/initByRef.ci:92:[.04c474, .04c479) exec(1), time(0.000 ms): <.main+2589>
test/lang/initByRef.ci:95:[.04c479, .04c47e) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:96:[.04c47e, .04c488) exec(1), time(0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.04c488, .04c48d) exec(1), time(0.001-0.001 ms): <.main+2609>
test/lang/initByRef.ci:99:[.04c48d, .04c492) exec(1), time(0.001-0.001 ms): <.main+2614>
test/lang/initByRef.ci:105:[.04c492, .04c499) exec(1), time(0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.04c499, .04c49b) exec(1), time(0.000 ms): <.main+2626>
test/lang/function.ci:11:[.04c49b, .04c4b0) exec(1), time(0.020-0.020 ms): <.main+2628>
test/lang/function.ci:14:[.04c4b0, .04c4b5) exec(1), time(0.000 ms): <.main+2649>
test/lang/function.ci:17:[.04c4b5, .04c4c7) exec(1), time(0.019-0.019 ms): <.main+2654>
test/lang/function.ci:20:[.04c4c7, .04c4cc) exec(1), time(0.000 ms): <.main+2672>
test/lang/function.ci:23:[.04c4cc, .04c4de) exec(1), time(0.018-0.018 ms): <.main+2677>
test/lang/function.ci:26:[.04c4de, .04c4e0) exec(1), time(0.001-0.001 ms): <.main+2695>
test/lang/function.ci:29:[.04c4e0, .04c4f2) exec(1), time(0.018-0.018 ms): <.main+2697>
test/lang/function.ci:45:[.04c4f2, .04c502) exec(1), time(12.814-12.814 ms): <.main+2715>
test/lang/reflect.ci:3:[.04c502, .04c506) exec(1), time(0.001-0.001 ms): <.main+2731>
test/lang/reflect.ci:4:[.04c506, .04c50a) exec(1), time(0.000 ms): <.main+2735>
test/lang/reflect.ci:5:[.04c50a, .04c50e) exec(1), time(0.000 ms): <.main+2739>
test/lang/reflect.ci:6:[.04c50e, .04c512) exec(1), time(0.001-0.001 ms): <.main+2743>
test/lang/reflect.ci:7:[.04c512, .04c516) exec(1), time(0.001-0.001 ms): <.main+2747>
test/lang/reflect.ci:8:[.04c516, .04c51a) exec(1), time(0.000 ms): <.main+2751>
test/lang/reflect.ci:9:[.04c51a, .04c51e) exec(1), time(0.000 ms): <.main+2755>
test/lang/reflect.ci:10:[.04c51e, .04c522) exec(1), time(0.001-0.001 ms): <.main+2759>
test/lang/reflect.ci:11:[.04c522, .04c526) exec(1), time(0.001-0.001 ms): <.main+2763>
test/lang/reflect.ci:12:[.04c526, .04c52a) exec(1), time(0.000 ms): <.main+2767>
test/lang/reflect.ci:13:[.04c52a, .04c52e) exec(1), time(0.000 ms): <.main+2771>
test/lang/reflect.ci:14:[.04c52e, .04c532) exec(1), time(0.001-0.001 ms): <.main+2775>
test/lang/reflect.ci:15:[.04c532, .04c536) exec(1), time(0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:16:[.04c536, .04c53a) exec(1), time(0.000 ms): <.main+2783>
test/lang/reflect.ci:17:[.04c53a, .04c53e) exec(1), time(0.000 ms): <.main+2787>
test/lang/reflect.ci:18:[.04c53e, .04c542) exec(1), time(0.001-0.001 ms): <.main+2791>
test/lang/reflect.ci:19:[.04c542, .04c546) exec(1), time(0.000 ms): <.main+2795>
test/lang/reflect.ci:20:[.04c546, .04c54a) exec(1), time(0.000 ms): <.main+2799>
test/lang/reflect.ci:30:[.04c54a, .04c54f) exec(1), time(0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:31:[.04c54f, .04c555) exec(1), time(0.018-0.018 ms): <.main+2808>
test/lang/reflect.ci:32:[.04c555, .04c55c) exec(1), time(0.001-0.001 ms): <.main+2814>
test/lang/reflect.ci:33:[.04c55c, .04c563) exec(1), time(0.002-0.002 ms): <.main+2821>
test/lang/reflect.ci:34:[.04c563, .04c569) exec(1), time(0.016-0.016 ms): <.main+2828>
test/lang/reflect.ci:35:[.04c569, .04c56f) exec(1), time(0.016-0.016 ms): <.main+2834>
test/lang/reflect.ci:37:[.04c56f, .04c575) exec(1), time(0.017-0.017 ms): <.main+2840>
test/lang/reflect.ci:38:[.04c575, .04c57b) exec(1), time(0.016-0.016 ms): <.main+2846>
test/lang/reflect.ci:39:[.04c57b, .04c582) exec(1), time(0.002-0.002 ms): <.main+2852>
test/lang/reflect.ci:40:[.04c582, .04c589) exec(1), time(0.001-0.001 ms): <.main+2859>
test/lang/reflect.ci:41:[.04c589, .04c58f) exec(1), time(0.016-0.016 ms): <.main+2866>
test/lang/reflect.ci:42:[.04c58f, .04c595) exec(1), time(0.016-0.016 ms): <.main+2872>
test/lang/reflect.ci:44:[.04c595, .04c59b) exec(1), time(0.021-0.021 ms): <.main+2878>
test/lang/reflect.ci:45:[.04c59b, .04c5a2) exec(1), time(0.001-0.001 ms): <.main+2884>
test/lang/reflect.ci:46:[.04c5a2, .04c5a9) exec(1), time(0.002-0.002 ms): <.main+2891>
test/lang/reflect.ci:48:[.04c5a9, .04c5af) exec(1), time(0.016-0.016 ms): <.main+2898>
test/lang/reflect.ci:49:[.04c5af, .04c5b6) exec(1), time(0.001-0.001 ms): <.main+2904>
test/lang/reflect.ci:50:[.04c5b6, .04c5bd) exec(1), time(0.002-0.002 ms): <.main+2911>
test/stdc/number.ci:3:[.04c5bd, .04c5c6) exec(1), time(0.000 ms): <.main+2918>
test/stdc/number.ci:4:[.04c5c6, .04c5cf) exec(1), time(0.000 ms): <.main+2927>
test/stdc/number.ci:6:[.04c5cf, .04c5d2) exec(1), time(0.001-0.001 ms): <.main+2936>
test/stdc/number.ci:7:[.04c5d2, .04c5d5) exec(1), time(0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.04c5d5, .04c5dc) exec(1), time(0.001-0.001 ms): <.main+2942>
test/stdc/number.ci:15:[.04c5dc, .04c5e3) exec(1), time(0.001-0.001 ms): <.main+2949>
test/stdc/number.ci:16:[.04c5e3, .04c5ea) exec(1), time(0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.04c5ea, .04c606) exec(1), time(0.008-0.008 ms): <.main+2963>
test/stdc/number.ci:19:[.04c606, .04c620) exec(1), time(0.007-0.007 ms): <.main+2991>
test/stdc/number.ci:21:[.04c620, .04c630) exec(1), time(0.017-0.017 ms): <.main+3017>
test/stdc/number.ci:22:[.04c630, .04c640) exec(1), time(0.016-0.016 ms): <.main+3033>
test/stdc/number.ci:23:[.04c640, .04c64c) exec(1), time(0.016-0.016 ms): <.main+3049>
test/stdc/number.ci:25:[.04c64c, .04c65c) exec(1), time(0.017-0.017 ms): <.main+3061>
test/stdc/number.ci:26:[.04c65c, .04c66c) exec(1), time(0.020-0.020 ms): <.main+3077>
test/stdc/number.ci:27:[.04c66c, .04c678) exec(1), time(0.017-0.017 ms): <.main+3093>
test/stdc/number.ci:29:[.04c678, .04c688) exec(1), time(0.016-0.016 ms): <.main+3105>
test/stdc/number.ci:30:[.04c688, .04c698) exec(1), time(0.017-0.017 ms): <.main+3121>
test/stdc/number.ci:31:[.04c698, .04c6a4) exec(1), time(0.017-0.017 ms): <.main+3137>
test/stdc/number.ci:33:[.04c6a4, .04c6b4) exec(1), time(0.016-0.016 ms): <.main+3149>
test/stdc/number.ci:34:[.04c6b4, .04c6c4) exec(1), time(0.017-0.017 ms): <.main+3165>
test/stdc/number.ci:35:[.04c6c4, .04c6d0) exec(1), time(0.017-0.017 ms): <.main+3181>
test/stdc/number.ci:37:[.04c6d0, .04c6e0) exec(1), time(0.031-0.031 ms): <.main+3193>
test/stdc/number.ci:38:[.04c6e0, .04c6f0) exec(1), time(0.022-0.022 ms): <.main+3209>
test/stdc/number.ci:39:[.04c6f0, .04c700) exec(1), time(0.017-0.017 ms): <.main+3225>
test/stdc/number.ci:40:[.04c700, .04c70c) exec(1), time(0.022-0.022 ms): <.main+3241>
test/stdc/number.ci:41:[.04c70c, .04c719) exec(1), time(0.015-0.015 ms): <.main+3253>
test/stdc/number.ci:42:[.04c719, .04c72b) exec(1), time(0.018-0.018 ms): <.main+3266>
test/stdc/number.ci:43:[.04c72b, .04c734) exec(1), time(0.016-0.016 ms): <.main+3284>
test/stdc/number.ci:44:[.04c734, .04c743) exec(1), time(0.019-0.019 ms): <.main+3293>
test/stdc/number.ci:46:[.04c743, .04c74f) exec(1), time(0.020-0.020 ms): <.main+3308>
test/stdc/number.ci:47:[.04c74f, .04c75b) exec(1), time(0.017-0.017 ms): <.main+3320>
test/stdc/number.ci:48:[.04c75b, .04c767) exec(1), time(0.017-0.017 ms): <.main+3332>
test/stdc/number.ci:49:[.04c767, .04c773) exec(1), time(0.018-0.018 ms): <.main+3344>
test/stdc/number.ci:50:[.04c773, .04c77c) exec(1), time(0.015-0.015 ms): <.main+3356>
test/stdc/number.ci:51:[.04c77c, .04c78a) exec(1), time(0.017-0.017 ms): <.main+3365>
test/stdc/number.ci:52:[.04c78a, .04c793) exec(1), time(0.017-0.017 ms): <.main+3379>
test/stdc/number.ci:53:[.04c793, .04c79e) exec(1), time(0.019-0.019 ms): <.main+3388>
test/stdc/number.ci:55:[.04c79e, .04c7a4) exec(1), time(0.016-0.016 ms): <.main+3399>
test/stdc/number.ci:56:[.04c7a4, .04c7aa) exec(1), time(0.015-0.015 ms): <.main+3405>
test/stdc/number.ci:57:[.04c7aa, .04c7b0) exec(1), time(0.015-0.015 ms): <.main+3411>
test/stdc/number.ci:58:[.04c7b0, .04c7b6) exec(1), time(0.016-0.016 ms): <.main+3417>
test/stdc/number.ci:59:[.04c7b6, .04c7bc) exec(1), time(0.015-0.015 ms): <.main+3423>
test/stdc/number.ci:60:[.04c7bc, .04c7c2) exec(1), time(0.016-0.016 ms): <.main+3429>
test/stdc/number.ci:62:[.04c7c2, .04c7ce) exec(1), time(0.017-0.017 ms): <.main+3435>
test/stdc/number.ci:63:[.04c7ce, .04c7da) exec(1), time(0.017-0.017 ms): <.main+3447>
test/stdc/number.ci:65:[.04c7da, .04c7e8) exec(1), time(0.019-0.019 ms): <.main+3459>
test/stdc/number.ci:66:[.04c7e8, .04c7f6) exec(1), time(0.018-0.018 ms): <.main+3473>
test/stdc/memory.ci:7:[.04c7f6, .04c804) exec(1), time(0.017-0.017 ms): <.main+3487>
test/stdc/memory.ci:8:[.04c804, .04c812) exec(1), time(0.017-0.017 ms): <.main+3501>
test/stdc/memory.ci:9:[.04c812, .04c820) exec(1), time(0.016-0.016 ms): <.main+3515>
test/stdc/memory.ci:10:[.04c820, .04c82e) exec(1), time(0.017-0.017 ms): <.main+3529>
test/stdc/memory.ci:13:[.04c82e, .04c83e) exec(1), time(0.018-0.018 ms): <.main+3543>
test/stdc/memory.ci:14:[.04c83e, .04c84f) exec(1), time(0.018-0.018 ms): <.main+3559>
test/stdc/memory.ci:17:[.04c84f, .04c85a) exec(1), time(0.017-0.017 ms): <.main+3576>
test/stdc/memory.ci:18:[.04c85a, .04c865) exec(1), time(0.017-0.017 ms): <.main+3587>
test/stdc/memory.ci:19:[.04c865, .04c870) exec(1), time(0.017-0.017 ms): <.main+3598>
test/stdc/memory.ci:20:[.04c870, .04c87b) exec(1), time(0.017-0.017 ms): <.main+3609>
test/stdc/memory.ci:23:[.04c87b, .04c884) exec(1), time(0.001-0.001 ms): <.main+3620>
test/stdc/memory.ci:24:[.04c884, .04c88d) exec(1), time(0.000 ms): <.main+3629>
test/stdc/memory.ci:26:[.04c88d, .04c8af) exec(1), time(0.033-0.033 ms): <.main+3638>
test/stdc/memory.ci:27:[.04c8af, .04c8d1) exec(1), time(0.031-0.031 ms): <.main+3672>
test/stdc/memory.ci:29:[.04c8d1, .04c8e5) exec(1), time(0.019-0.019 ms): <.main+3706>
test/stdc/memory.ci:30:[.04c8e5, .04c8f6) exec(1), time(0.018-0.018 ms): <.main+3726>
test/stdc/memory.ci:32:[.04c8f6, .04c918) exec(1), time(0.037-0.037 ms): <.main+3743>
test/stdc/memory.ci:33:[.04c918, .04c93a) exec(1), time(0.030-0.030 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.04c93a, .04c948) exec(1), time(0.049-0.049 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.04c948, .04c956) exec(1), time(0.019-0.019 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.04c956, .04c964) exec(1), time(1.041-1.041 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.04c964, .04c972) exec(1), time(0.032-0.032 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.04c972, .04c980) exec(1), time(0.032-0.032 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.04c980, .04c98e) exec(1), time(0.033-0.033 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.04c98e, .04c99c) exec(1), time(0.129-0.129 ms): <.main+3895>
test/lang/array.ci:49:[.04c99c, .04c9a0) exec(1), time(0.000 ms): <.main+3909>
test/lang/array.ci:50:[.04c9a0, .04c9a4) exec(1), time(0.000 ms): <.main+3913>
test/lang/array.ci:51:[.04c9a4, .04c9a8) exec(1), time(0.001-0.001 ms): <.main+3917>
test/lang/array.ci:55:[.04c9ad, .04c9c1) exec(7), time(0.035-0.035 ms): <.main+3926>
test/lang/array.ci:54:[.04c9c1, .04c9c5) exec(7), time(0.002-0.002 ms): <.main+3946>
test/lang/array.ci:54:[.04c9c5, .04c9d1) exec(8), time(0.019-0.019 ms): <.main+3950>
test/lang/array.ci:54:[.04c9a8, .04c9d5) exec(1), time(0.003-0.003 ms): <.main+3921>
test/lang/array.ci:59:[.04c9d5, .04c9da) exec(1), time(0.000 ms): <.main+3966>
test/lang/array.ci:60:[.04c9da, .04c9e0) exec(1), time(0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.04c9e0, .04c9e4) exec(1), time(0.001-0.001 ms): <.main+3977>
test/lang/array.ci:64:[.04c9e4, .04c9ed) exec(1), time(0.001-0.001 ms): <.main+3981>
test/lang/array.ci:67:[.04c9ed, .04c9ef) exec(1), time(0.000 ms): <.main+3990>
test/lang/array.ci:68:[.04c9ef, .04c9f1) exec(1), time(0.001-0.001 ms): <.main+3992>
test/lang/array.ci:71:[.04c9f1, .04c9f3) exec(1), time(0.000 ms): <.main+3994>
test/lang/array.ci:81:[.04c9f3, .04c9f7) exec(1), time(0.000 ms): <.main+3996>
test/lang/array.ci:82:[.04c9f7, .04ca0d) exec(1), time(0.020-0.020 ms): <.main+4000>
test/lang/array.ci:83:[.04ca0d, .04ca2f) exec(1), time(0.076-0.076 ms): <.main+4022>
test/lang/array.ci:84:[.04ca2f, .04ca51) exec(1), time(0.074-0.074 ms): <.main+4056>
test/lang/array.ci:86:[.04ca51, .04ca56) exec(1), time(0.001-0.001 ms): <.main+4090>
test/lang/array.ci:87:[.04ca56, .04ca76) exec(1), time(0.036-0.036 ms): <.main+4095>
test/lang/array.ci:88:[.04ca76, .04ca96) exec(1), time(0.035-0.035 ms): <.main+4127>
test/lang/array.ci:90:[.04ca96, .04caa0) exec(1), time(0.001-0.001 ms): <.main+4159>
test/lang/array.ci:91:[.04caa0, .04cac0) exec(1), time(0.034-0.034 ms): <.main+4169>
test/lang/array.ci:92:[.04cac0, .04cae0) exec(1), time(0.037-0.037 ms): <.main+4201>
test/lang/array.ci:98:[.04cae0, .04cb13) exec(1), time(0.003-0.003 ms): <.main+4233>
test/lang/array.ci:99:[.04cb13, .04cb46) exec(1), time(0.003-0.003 ms): <.main+4284>
test/lang/array.ci:101:[.04cb46, .04cb81) exec(1), time(0.003-0.003 ms): <.main+4335>
test/lang/array.ci:108:[.04cb81, .04cb9a) exec(1), time(0.019-0.019 ms): <.main+4394>
test/lang/array.ci:109:[.04cb9a, .04cbb0) exec(1), time(0.019-0.019 ms): <.main+4419>
test/lang/array.ci:110:[.04cbb0, .04cbc6) exec(1), time(0.018-0.018 ms): <.main+4441>
test/lang/array.ci:112:[.04cbc6, .04cbe6) exec(1), time(0.038-0.038 ms): <.main+4463>
test/lang/array.ci:113:[.04cbe6, .04cc03) exec(1), time(0.037-0.037 ms): <.main+4495>
test/lang/array.ci:114:[.04cc03, .04cc2b) exec(1), time(0.040-0.040 ms): <.main+4524>
test/lang/array.ci:115:[.04cc2b, .04cc4c) exec(1), time(0.038-0.038 ms): <.main+4564>
test/lang/array.ci:116:[.04cc4c, .04cc6d) exec(1), time(0.037-0.037 ms): <.main+4597>
test/lang/array.ci:119:[.04cc72, .04cc7b) exec(7), time(0.019-0.019 ms): <.main+4635>
test/lang/array.ci:120:[.04cc7b, .04ccb8) exec(7), time(0.036-0.036 ms): <.main+4644>
test/lang/array.ci:121:[.04ccb8, .04ccf3) exec(7), time(0.035-0.035 ms): <.main+4705>
test/lang/array.ci:122:[.04ccf3, .04cd2e) exec(7), time(0.035-0.035 ms): <.main+4764>
test/lang/array.ci:124:[.04cd2e, .04cd71) exec(7), time(0.168-0.168 ms): <.main+4823>
test/lang/array.ci:125:[.04cd71, .04cdb2) exec(7), time(0.167-0.167 ms): <.main+4890>
test/lang/array.ci:126:[.04cdb2, .04cdf3) exec(7), time(0.168-0.168 ms): <.main+4955>
test/lang/array.ci:128:[.04cdf3, .04ce36) exec(7), time(0.180-0.180 ms): <.main+5020>
test/lang/array.ci:129:[.04ce36, .04ce77) exec(7), time(0.168-0.168 ms): <.main+5087>
test/lang/array.ci:130:[.04ce77, .04ceb8) exec(7), time(0.168-0.168 ms): <.main+5152>
test/lang/array.ci:132:[.04ceb8, .04cf00) exec(7), time(0.172-0.172 ms): <.main+5217>
test/lang/array.ci:134:[.04cf00, .04cf41) exec(7), time(0.173-0.173 ms): <.main+5289>
test/lang/array.ci:136:[.04cf41, .04cf7c) exec(7), time(0.035-0.035 ms): <.main+5354>
test/lang/array.ci:118:[.04cf80, .04cf84) exec(7), time(0.004-0.004 ms): <.main+5417>
test/lang/array.ci:118:[.04cf84, .04cf90) exec(8), time(0.019-0.019 ms): <.main+5421>
test/lang/array.ci:118:[.04cc6d, .04cf94) exec(1), time(0.004-0.004 ms): <.main+4630>
test/lang/member.ci:54:[.04cf98, .04cf9f) exec(1), time(0.001-0.001 ms): <.main+5441>
test/lang/member.ci:55:[.04cf9f, .04cfa6) exec(1), time(0.001-0.001 ms): <.main+5448>
test/lang/member.ci:56:[.04cfa6, .04cfad) exec(1), time(0.001-0.001 ms): <.main+5455>
test/lang/member.ci:57:[.04cfad, .04cfb4) exec(1), time(0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.04cfb4, .04cfbb) exec(1), time(0.001-0.001 ms): <.main+5469>
test/lang/member.ci:61:[.04cfbb, .04cfc2) exec(1), time(0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.04cfc2, .04cfc9) exec(1), time(0.001-0.001 ms): <.main+5483>
test/lang/member.ci:66:[.04cfc9, .04cfd0) exec(1), time(0.001-0.001 ms): <.main+5490>
test/lang/member.ci:53:[.04cf94, .04cfd0) exec(1-1), time(0.000 ms): <.main+5437>
test/lang/method.ci:46:[.04cfd4, .04cfdb) exec(1), time(0.001-0.001 ms): <.main+5501>
::[.04cfdb, .04cfe1) exec(1), time(0.002-0.002 ms): <.main+5508>
::[.04cfe1, .04cfe8) exec(1), time(0.001-0.001 ms): <.main+5514>
test/lang/method.ci:44:[.04cfd0, .04cfe8) exec(1-1), time(0.000 ms): <.main+5497>
test/lang/method.ci:58:[.04cfe8, .04cffb) exec(1), time(0.102-0.102 ms): <.main+5521>
test/lang/method.ci:59:[.04cffb, .04d00b) exec(1), time(0.100-0.100 ms): <.main+5540>
test/lang/method.ci:75:[.04d00b, .04d01c) exec(1), time(0.187-0.187 ms): <.main+5556>
test/lang/method.ci:76:[.04d01c, .04d02d) exec(1), time(0.188-0.188 ms): <.main+5573>
test/lang/method.ci:79:[.04d02d, .04d040) exec(1), time(0.103-0.103 ms): <.main+5590>
test/lang/method.ci:80:[.04d040, .04d053) exec(1), time(0.100-0.100 ms): <.main+5609>
test/lang/method.ci:81:[.04d053, .04d063) exec(1), time(0.099-0.099 ms): <.main+5628>
test/lang/recUnion.ci:26:[.04d067, .04d06d) exec(1), time(0.002-0.002 ms): <.main+5648>
test/lang/recUnion.ci:26:[.04d06d, .04d073) exec(1), time(0.002-0.002 ms): <.main+5654>
test/lang/recUnion.ci:26:[.04d073, .04d079) exec(1), time(0.002-0.002 ms): <.main+5660>
test/lang/recUnion.ci:26:[.04d063, .04d079) exec(1-1), time(0.000 ms): <.main+5644>
test/lang/recUnion.ci:27:[.04d07d, .04d083) exec(1), time(0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:27:[.04d083, .04d08d) exec(1), time(0.002-0.002 ms): <.main+5676>
test/lang/recUnion.ci:27:[.04d08d, .04d093) exec(1), time(0.002-0.002 ms): <.main+5686>
test/lang/recUnion.ci:27:[.04d079, .04d093) exec(1-1), time(0.000 ms): <.main+5666>
test/lang/recUnion.ci:28:[.04d097, .04d0a1) exec(1), time(0.002-0.002 ms): <.main+5696>
test/lang/recUnion.ci:28:[.04d0a1, .04d0ab) exec(1), time(0.002-0.002 ms): <.main+5706>
test/lang/recUnion.ci:28:[.04d0ab, .04d0b5) exec(1), time(0.002-0.002 ms): <.main+5716>
test/lang/recUnion.ci:28:[.04d093, .04d0b5) exec(1-1), time(0.000 ms): <.main+5692>
test/lang/recUnion.ci:30:[.04d0b9, .04d0c0) exec(1), time(0.001-0.001 ms): <.main+5730>
test/lang/recUnion.ci:30:[.04d0b5, .04d0c0) exec(1-1), time(0.000 ms): <.main+5726>
test/lang/recUnion.ci:31:[.04d0c4, .04d0ca) exec(1), time(0.002-0.002 ms): <.main+5741>
test/lang/recUnion.ci:31:[.04d0ca, .04d0d0) exec(1), time(0.002-0.002 ms): <.main+5747>
test/lang/recUnion.ci:31:[.04d0d0, .04d0da) exec(1), time(0.002-0.002 ms): <.main+5753>
test/lang/recUnion.ci:31:[.04d0c0, .04d0da) exec(1-1), time(0.000 ms): <.main+5737>
test/lang/useOperator.ci:5:[.04d0da, .04d0df) exec(1), time(0.000 ms): <.main+5763>
test/lang/useOperator.ci:7:[.04d0df, .04d0e4) exec(1), time(0.000 ms): <.main+5768>
test/lang/useOperator.ci:8:[.04d0e4, .04d0e9) exec(1), time(0.000 ms): <.main+5773>
test/lang/useOperator.ci:17:[.04d0e9, .04d0f4) exec(1), time(0.004-0.004 ms): <.main+5778>
test/lang/useOperator.ci:18:[.04d0f4, .04d0ff) exec(1), time(0.003-0.003 ms): <.main+5789>
test/lang/useOperator.ci:19:[.04d0ff, .04d10a) exec(1), time(0.003-0.003 ms): <.main+5800>
test/lang/useOperator.ci:22:[.04d10a, .04d110) exec(1), time(0.002-0.002 ms): <.main+5811>
test/lang/useOperator.ci:23:[.04d110, .04d11b) exec(1), time(0.003-0.003 ms): <.main+5817>
test/lang/useOperator.ci:24:[.04d11b, .04d127) exec(1), time(0.004-0.004 ms): <.main+5828>
test/lang/useOperator.ci:25:[.04d127, .04d132) exec(1), time(0.003-0.003 ms): <.main+5840>
test/lang/useOperator.ci:26:[.04d132, .04d13e) exec(1), time(0.004-0.004 ms): <.main+5851>
test/lang/useOperator.ci:27:[.04d13e, .04d149) exec(1), time(0.004-0.004 ms): <.main+5863>
test/lang/useOperator.ci:28:[.04d149, .04d155) exec(1), time(0.004-0.004 ms): <.main+5874>
test/lang/useOperator.ci:30:[.04d155, .04d15a) exec(1), time(0.000 ms): <.main+5886>
test/lang/useOperator.ci:31:[.04d15a, .04d15f) exec(1), time(0.000 ms): <.main+5891>
test/lang/useOperator.ci:32:[.04d15f, .04d164) exec(1), time(0.001-0.001 ms): <.main+5896>
test/lang/useOperator.ci:33:[.04d164, .04d16a) exec(1), time(0.002-0.002 ms): <.main+5901>
test/lang/useOperator.ci:34:[.04d16a, .04d170) exec(1), time(0.002-0.002 ms): <.main+5907>
test/lang/useOperator.ci:35:[.04d170, .04d17b) exec(1), time(0.004-0.004 ms): <.main+5913>
test/lang/useOperator.ci:36:[.04d17b, .04d186) exec(1), time(0.003-0.003 ms): <.main+5924>
test/lang/useOperator.ci:37:[.04d186, .04d191) exec(1), time(0.004-0.004 ms): <.main+5935>
test/lang/useOperator.ci:38:[.04d191, .04d19c) exec(1), time(0.003-0.003 ms): <.main+5946>
test/lang/useOperator.ci:39:[.04d19c, .04d1a7) exec(1), time(0.004-0.004 ms): <.main+5957>
test/lang/useOperator.ci:40:[.04d1a7, .04d1b2) exec(1), time(0.003-0.003 ms): <.main+5968>
test/lang/useOperator.ci:41:[.04d1b2, .04d1bd) exec(1), time(0.004-0.004 ms): <.main+5979>
test/lang/useOperator.ci:42:[.04d1bd, .04d1c8) exec(1), time(0.003-0.003 ms): <.main+5990>
test/lang/useOperator.ci:43:[.04d1c8, .04d1d0) exec(1), time(0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:44:[.04d1d0, .04d1d8) exec(1), time(0.003-0.003 ms): <.main+6009>
test/lang/useOperator.ci:45:[.04d1d8, .04d1df) exec(1), time(0.002-0.002 ms): <.main+6017>
test/lang/useOperator.ci:46:[.04d1df, .04d1ea) exec(1), time(0.003-0.003 ms): <.main+6024>
test/lang/useOperator.ci:47:[.04d1ea, .04d1f6) exec(1), time(0.004-0.004 ms): <.main+6035>
test/lang/useOperator.ci:48:[.04d1f6, .04d201) exec(1), time(0.004-0.004 ms): <.main+6047>
test/lang/useOperator.ci:49:[.04d201, .04d20d) exec(1), time(0.004-0.004 ms): <.main+6058>
test/lang/useOperator.ci:50:[.04d20d, .04d218) exec(1), time(0.004-0.004 ms): <.main+6070>
test/lang/useOperator.ci:51:[.04d218, .04d224) exec(1), time(0.004-0.004 ms): <.main+6081>
test/lang/useOperator.ci:53:[.04d224, .04d229) exec(1), time(0.001-0.001 ms): <.main+6093>
test/lang/useOperator.ci:54:[.04d229, .04d22e) exec(1), time(0.000 ms): <.main+6098>
test/lang/useOperator.ci:55:[.04d22e, .04d233) exec(1), time(0.001-0.001 ms): <.main+6103>
test/lang/useOperator.ci:56:[.04d233, .04d239) exec(1), time(0.002-0.002 ms): <.main+6108>
test/lang/useOperator.ci:57:[.04d239, .04d23f) exec(1), time(0.002-0.002 ms): <.main+6114>
test/lang/useOperator.ci:58:[.04d23f, .04d24a) exec(1), time(0.003-0.003 ms): <.main+6120>
test/lang/useOperator.ci:59:[.04d24a, .04d255) exec(1), time(0.004-0.004 ms): <.main+6131>
test/lang/useOperator.ci:60:[.04d255, .04d260) exec(1), time(0.003-0.003 ms): <.main+6142>
test/lang/useOperator.ci:61:[.04d260, .04d26b) exec(1), time(0.004-0.004 ms): <.main+6153>
test/lang/useOperator.ci:62:[.04d26b, .04d276) exec(1), time(0.004-0.004 ms): <.main+6164>
test/lang/useOperator.ci:63:[.04d276, .04d281) exec(1), time(0.003-0.003 ms): <.main+6175>
test/lang/useOperator.ci:64:[.04d281, .04d28c) exec(1), time(0.004-0.004 ms): <.main+6186>
test/lang/useOperator.ci:65:[.04d28c, .04d297) exec(1), time(0.003-0.003 ms): <.main+6197>
test/lang/useOperator.ci:66:[.04d297, .04d29f) exec(1), time(0.002-0.002 ms): <.main+6208>
test/lang/useOperator.ci:67:[.04d29f, .04d2a7) exec(1), time(0.003-0.003 ms): <.main+6216>
test/lang/useOperator.ci:68:[.04d2a7, .04d2ae) exec(1), time(0.003-0.003 ms): <.main+6224>
test/lang/useOperator.ci:69:[.04d2ae, .04d2b9) exec(1), time(0.004-0.004 ms): <.main+6231>
test/lang/useOperator.ci:70:[.04d2b9, .04d2c5) exec(1), time(0.004-0.004 ms): <.main+6242>
test/lang/useOperator.ci:71:[.04d2c5, .04d2d0) exec(1), time(0.004-0.004 ms): <.main+6254>
test/lang/useOperator.ci:72:[.04d2d0, .04d2dc) exec(1), time(0.004-0.004 ms): <.main+6265>
test/lang/useOperator.ci:73:[.04d2dc, .04d2e7) exec(1), time(0.003-0.003 ms): <.main+6277>
test/lang/useOperator.ci:74:[.04d2e7, .04d2f3) exec(1), time(0.005-0.005 ms): <.main+6288>
test/lang/useOperator.ci:76:[.04d2f3, .04d2f8) exec(1), time(0.000 ms): <.main+6300>
test/lang/useOperator.ci:77:[.04d2f8, .04d2fd) exec(1), time(0.001-0.001 ms): <.main+6305>
test/lang/useOperator.ci:78:[.04d2fd, .04d302) exec(1), time(0.001-0.001 ms): <.main+6310>
test/lang/useOperator.ci:79:[.04d302, .04d308) exec(1), time(0.002-0.002 ms): <.main+6315>
test/lang/useOperator.ci:80:[.04d308, .04d30e) exec(1), time(0.002-0.002 ms): <.main+6321>
test/lang/useOperator.ci:81:[.04d30e, .04d319) exec(1), time(0.004-0.004 ms): <.main+6327>
test/lang/useOperator.ci:82:[.04d319, .04d324) exec(1), time(0.003-0.003 ms): <.main+6338>
test/lang/useOperator.ci:83:[.04d324, .04d32f) exec(1), time(0.003-0.003 ms): <.main+6349>
test/lang/useOperator.ci:84:[.04d32f, .04d33a) exec(1), time(0.004-0.004 ms): <.main+6360>
test/lang/useOperator.ci:85:[.04d33a, .04d345) exec(1), time(0.004-0.004 ms): <.main+6371>
test/lang/useOperator.ci:86:[.04d345, .04d350) exec(1), time(0.003-0.003 ms): <.main+6382>
test/lang/useOperator.ci:87:[.04d350, .04d35b) exec(1), time(0.004-0.004 ms): <.main+6393>
test/lang/useOperator.ci:88:[.04d35b, .04d366) exec(1), time(0.004-0.004 ms): <.main+6404>
test/lang/useOperator.ci:89:[.04d366, .04d36e) exec(1), time(0.002-0.002 ms): <.main+6415>
test/lang/useOperator.ci:90:[.04d36e, .04d376) exec(1), time(0.002-0.002 ms): <.main+6423>
test/lang/useOperator.ci:91:[.04d376, .04d37d) exec(1), time(0.002-0.002 ms): <.main+6431>
test/lang/useOperator.ci:92:[.04d37d, .04d388) exec(1), time(0.004-0.004 ms): <.main+6438>
test/lang/useOperator.ci:93:[.04d388, .04d394) exec(1), time(0.005-0.005 ms): <.main+6449>
test/lang/useOperator.ci:94:[.04d394, .04d39f) exec(1), time(0.003-0.003 ms): <.main+6461>
test/lang/useOperator.ci:95:[.04d39f, .04d3ab) exec(1), time(0.005-0.005 ms): <.main+6472>
test/lang/useOperator.ci:96:[.04d3ab, .04d3b6) exec(1), time(0.004-0.004 ms): <.main+6484>
test/lang/useOperator.ci:97:[.04d3b6, .04d3c2) exec(1), time(0.004-0.004 ms): <.main+6495>
test/lang/useOperator.ci:99:[.04d3c2, .04d3c7) exec(1), time(0.001-0.001 ms): <.main+6507>
test/lang/useOperator.ci:100:[.04d3c7, .04d3cc) exec(1), time(0.000 ms): <.main+6512>
test/lang/useOperator.ci:101:[.04d3cc, .04d3d1) exec(1), time(0.002-0.002 ms): <.main+6517>
test/lang/useOperator.ci:102:[.04d3d1, .04d3d7) exec(1), time(0.002-0.002 ms): <.main+6522>
test/lang/useOperator.ci:103:[.04d3d7, .04d3dd) exec(1), time(0.002-0.002 ms): <.main+6528>
test/lang/useOperator.ci:104:[.04d3dd, .04d3e8) exec(1), time(0.003-0.003 ms): <.main+6534>
test/lang/useOperator.ci:105:[.04d3e8, .04d3f3) exec(1), time(0.003-0.003 ms): <.main+6545>
test/lang/useOperator.ci:106:[.04d3f3, .04d3fe) exec(1), time(0.004-0.004 ms): <.main+6556>
test/lang/useOperator.ci:107:[.04d3fe, .04d409) exec(1), time(0.004-0.004 ms): <.main+6567>
test/lang/useOperator.ci:108:[.04d409, .04d414) exec(1), time(0.003-0.003 ms): <.main+6578>
test/lang/useOperator.ci:109:[.04d414, .04d41f) exec(1), time(0.004-0.004 ms): <.main+6589>
test/lang/useOperator.ci:110:[.04d41f, .04d42a) exec(1), time(0.004-0.004 ms): <.main+6600>
test/lang/useOperator.ci:111:[.04d42a, .04d435) exec(1), time(0.003-0.003 ms): <.main+6611>
test/lang/useOperator.ci:112:[.04d435, .04d43d) exec(1), time(0.002-0.002 ms): <.main+6622>
test/lang/useOperator.ci:113:[.04d43d, .04d445) exec(1), time(0.003-0.003 ms): <.main+6630>
test/lang/useOperator.ci:114:[.04d445, .04d44c) exec(1), time(0.003-0.003 ms): <.main+6638>
test/lang/useOperator.ci:115:[.04d44c, .04d457) exec(1), time(0.004-0.004 ms): <.main+6645>
test/lang/useOperator.ci:116:[.04d457, .04d463) exec(1), time(0.005-0.005 ms): <.main+6656>
test/lang/useOperator.ci:117:[.04d463, .04d46e) exec(1), time(0.004-0.004 ms): <.main+6668>
test/lang/useOperator.ci:118:[.04d46e, .04d47a) exec(1), time(0.004-0.004 ms): <.main+6679>
test/lang/useOperator.ci:119:[.04d47a, .04d485) exec(1), time(0.004-0.004 ms): <.main+6691>
test/lang/useOperator.ci:120:[.04d485, .04d491) exec(1), time(0.005-0.005 ms): <.main+6702>
test/lang/useOperator.ci:122:[.04d491, .04d496) exec(1), time(0.000 ms): <.main+6714>
test/lang/useOperator.ci:123:[.04d496, .04d49b) exec(1), time(0.001-0.001 ms): <.main+6719>
test/lang/useOperator.ci:124:[.04d49b, .04d4a0) exec(1), time(0.001-0.001 ms): <.main+6724>
test/lang/useOperator.ci:125:[.04d4a0, .04d4a6) exec(1), time(0.002-0.002 ms): <.main+6729>
test/lang/useOperator.ci:126:[.04d4a6, .04d4ac) exec(1), time(0.002-0.002 ms): <.main+6735>
test/lang/useOperator.ci:127:[.04d4ac, .04d4b7) exec(1), time(0.003-0.003 ms): <.main+6741>
test/lang/useOperator.ci:128:[.04d4b7, .04d4c2) exec(1), time(0.003-0.003 ms): <.main+6752>
test/lang/useOperator.ci:129:[.04d4c2, .04d4cd) exec(1), time(0.004-0.004 ms): <.main+6763>
test/lang/useOperator.ci:130:[.04d4cd, .04d4d8) exec(1), time(0.004-0.004 ms): <.main+6774>
test/lang/useOperator.ci:131:[.04d4d8, .04d4e3) exec(1), time(0.004-0.004 ms): <.main+6785>
test/lang/useOperator.ci:132:[.04d4e3, .04d4ee) exec(1), time(0.004-0.004 ms): <.main+6796>
test/lang/useOperator.ci:133:[.04d4ee, .04d4f9) exec(1), time(0.003-0.003 ms): <.main+6807>
test/lang/useOperator.ci:134:[.04d4f9, .04d504) exec(1), time(0.004-0.004 ms): <.main+6818>
test/lang/useOperator.ci:135:[.04d504, .04d50c) exec(1), time(0.003-0.003 ms): <.main+6829>
test/lang/useOperator.ci:136:[.04d50c, .04d514) exec(1), time(0.003-0.003 ms): <.main+6837>
test/lang/useOperator.ci:137:[.04d514, .04d51b) exec(1), time(0.003-0.003 ms): <.main+6845>
test/lang/useOperator.ci:138:[.04d51b, .04d526) exec(1), time(0.003-0.003 ms): <.main+6852>
test/lang/useOperator.ci:139:[.04d526, .04d532) exec(1), time(0.005-0.005 ms): <.main+6863>
test/lang/useOperator.ci:140:[.04d532, .04d53d) exec(1), time(0.004-0.004 ms): <.main+6875>
test/lang/useOperator.ci:141:[.04d53d, .04d549) exec(1), time(0.005-0.005 ms): <.main+6886>
test/lang/useOperator.ci:142:[.04d549, .04d554) exec(1), time(0.004-0.004 ms): <.main+6898>
test/lang/useOperator.ci:143:[.04d554, .04d560) exec(1), time(0.004-0.004 ms): <.main+6909>
test/lang/useOperator.ci:145:[.04d560, .04d565) exec(1), time(0.001-0.001 ms): <.main+6921>
test/lang/useOperator.ci:146:[.04d565, .04d56a) exec(1), time(0.000 ms): <.main+6926>
test/lang/useOperator.ci:147:[.04d56a, .04d56c) exec(1), time(0.001-0.001 ms): <.main+6931>
test/lang/useOperator.ci:148:[.04d56c, .04d56f) exec(1), time(0.001-0.001 ms): <.main+6933>
test/lang/useOperator.ci:149:[.04d56f, .04d572) exec(1), time(0.002-0.002 ms): <.main+6936>
test/lang/useOperator.ci:150:[.04d572, .04d577) exec(1), time(0.002-0.002 ms): <.main+6939>
test/lang/useOperator.ci:151:[.04d577, .04d57c) exec(1), time(0.002-0.002 ms): <.main+6944>
test/lang/useOperator.ci:152:[.04d57c, .04d581) exec(1), time(0.002-0.002 ms): <.main+6949>
test/lang/useOperator.ci:153:[.04d581, .04d586) exec(1), time(0.002-0.002 ms): <.main+6954>
test/lang/useOperator.ci:154:[.04d586, .04d58b) exec(1), time(0.002-0.002 ms): <.main+6959>
test/lang/useOperator.ci:155:[.04d58b, .04d590) exec(1), time(0.002-0.002 ms): <.main+6964>
test/lang/useOperator.ci:156:[.04d590, .04d595) exec(1), time(0.002-0.002 ms): <.main+6969>
test/lang/useOperator.ci:157:[.04d595, .04d59a) exec(1), time(0.002-0.002 ms): <.main+6974>
test/lang/useOperator.ci:158:[.04d59a, .04d59f) exec(1), time(0.002-0.002 ms): <.main+6979>
test/lang/useOperator.ci:159:[.04d59f, .04d5a4) exec(1), time(0.002-0.002 ms): <.main+6984>
test/lang/useOperator.ci:160:[.04d5a4, .04d5a8) exec(1), time(0.002-0.002 ms): <.main+6989>
test/lang/useOperator.ci:161:[.04d5a8, .04d5ad) exec(1), time(0.002-0.002 ms): <.main+6993>
test/lang/useOperator.ci:162:[.04d5ad, .04d5b3) exec(1), time(0.003-0.003 ms): <.main+6998>
test/lang/useOperator.ci:163:[.04d5b3, .04d5b8) exec(1), time(0.002-0.002 ms): <.main+7004>
test/lang/useOperator.ci:164:[.04d5b8, .04d5be) exec(1), time(0.003-0.003 ms): <.main+7009>
test/lang/useOperator.ci:165:[.04d5be, .04d5c3) exec(1), time(0.002-0.002 ms): <.main+7015>
test/lang/useOperator.ci:166:[.04d5c3, .04d5c9) exec(1), time(0.003-0.003 ms): <.main+7020>
test/lang/useOperator.ci:168:[.04d5c9, .04d5ce) exec(1), time(0.001-0.001 ms): <.main+7026>
test/lang/useOperator.ci:169:[.04d5ce, .04d5d3) exec(1), time(0.000 ms): <.main+7031>
test/lang/useOperator.ci:170:[.04d5d3, .04d5d5) exec(1), time(0.001-0.001 ms): <.main+7036>
test/lang/useOperator.ci:171:[.04d5d5, .04d5d8) exec(1), time(0.001-0.001 ms): <.main+7038>
test/lang/useOperator.ci:172:[.04d5d8, .04d5db) exec(1), time(0.002-0.002 ms): <.main+7041>
test/lang/useOperator.ci:173:[.04d5db, .04d5e0) exec(1), time(0.002-0.002 ms): <.main+7044>
test/lang/useOperator.ci:174:[.04d5e0, .04d5e5) exec(1), time(0.002-0.002 ms): <.main+7049>
test/lang/useOperator.ci:175:[.04d5e5, .04d5ea) exec(1), time(0.002-0.002 ms): <.main+7054>
test/lang/useOperator.ci:176:[.04d5ea, .04d5ef) exec(1), time(0.002-0.002 ms): <.main+7059>
test/lang/useOperator.ci:177:[.04d5ef, .04d5f4) exec(1), time(0.002-0.002 ms): <.main+7064>
test/lang/useOperator.ci:178:[.04d5f4, .04d5f9) exec(1), time(0.002-0.002 ms): <.main+7069>
test/lang/useOperator.ci:179:[.04d5f9, .04d5fe) exec(1), time(0.002-0.002 ms): <.main+7074>
test/lang/useOperator.ci:180:[.04d5fe, .04d603) exec(1), time(0.002-0.002 ms): <.main+7079>
test/lang/useOperator.ci:181:[.04d603, .04d608) exec(1), time(0.002-0.002 ms): <.main+7084>
test/lang/useOperator.ci:182:[.04d608, .04d60d) exec(1), time(0.002-0.002 ms): <.main+7089>
test/lang/useOperator.ci:183:[.04d60d, .04d611) exec(1), time(0.002-0.002 ms): <.main+7094>
test/lang/useOperator.ci:184:[.04d611, .04d616) exec(1), time(0.002-0.002 ms): <.main+7098>
test/lang/useOperator.ci:185:[.04d616, .04d61c) exec(1), time(0.003-0.003 ms): <.main+7103>
test/lang/useOperator.ci:186:[.04d61c, .04d621) exec(1), time(0.002-0.002 ms): <.main+7109>
test/lang/useOperator.ci:187:[.04d621, .04d627) exec(1), time(0.003-0.003 ms): <.main+7114>
test/lang/useOperator.ci:188:[.04d627, .04d62c) exec(1), time(0.002-0.002 ms): <.main+7120>
test/lang/useOperator.ci:189:[.04d62c, .04d632) exec(1), time(0.003-0.003 ms): <.main+7125>
test/lang/useOperator.ci:191:[.04d632, .04d63b) exec(1), time(0.000 ms): <.main+7131>
test/lang/useOperator.ci:192:[.04d63b, .04d644) exec(1), time(0.000 ms): <.main+7140>
test/lang/useOperator.ci:193:[.04d644, .04d646) exec(1), time(0.001-0.001 ms): <.main+7149>
test/lang/useOperator.ci:194:[.04d646, .04d649) exec(1), time(0.001-0.001 ms): <.main+7151>
test/lang/useOperator.ci:195:[.04d649, .04d64c) exec(1), time(0.002-0.002 ms): <.main+7154>
test/lang/useOperator.ci:196:[.04d64c, .04d651) exec(1), time(0.002-0.002 ms): <.main+7157>
test/lang/useOperator.ci:197:[.04d651, .04d656) exec(1), time(0.002-0.002 ms): <.main+7162>
test/lang/useOperator.ci:198:[.04d656, .04d65b) exec(1), time(0.002-0.002 ms): <.main+7167>
test/lang/useOperator.ci:199:[.04d65b, .04d660) exec(1), time(0.002-0.002 ms): <.main+7172>
test/lang/useOperator.ci:200:[.04d660, .04d665) exec(1), time(0.002-0.002 ms): <.main+7177>
test/lang/useOperator.ci:201:[.04d665, .04d66a) exec(1), time(0.002-0.002 ms): <.main+7182>
test/lang/useOperator.ci:202:[.04d66a, .04d66f) exec(1), time(0.003-0.003 ms): <.main+7187>
test/lang/useOperator.ci:203:[.04d66f, .04d674) exec(1), time(0.002-0.002 ms): <.main+7192>
test/lang/useOperator.ci:204:[.04d674, .04d679) exec(1), time(0.002-0.002 ms): <.main+7197>
test/lang/useOperator.ci:205:[.04d679, .04d67e) exec(1), time(0.002-0.002 ms): <.main+7202>
test/lang/useOperator.ci:206:[.04d67e, .04d682) exec(1), time(0.002-0.002 ms): <.main+7207>
test/lang/useOperator.ci:207:[.04d682, .04d687) exec(1), time(0.002-0.002 ms): <.main+7211>
test/lang/useOperator.ci:208:[.04d687, .04d68d) exec(1), time(0.003-0.003 ms): <.main+7216>
test/lang/useOperator.ci:209:[.04d68d, .04d692) exec(1), time(0.003-0.003 ms): <.main+7222>
test/lang/useOperator.ci:210:[.04d692, .04d698) exec(1), time(0.003-0.003 ms): <.main+7227>
test/lang/useOperator.ci:211:[.04d698, .04d69d) exec(1), time(0.003-0.003 ms): <.main+7233>
test/lang/useOperator.ci:212:[.04d69d, .04d6a3) exec(1), time(0.003-0.003 ms): <.main+7238>
test/lang/useOperator.ci:214:[.04d6a3, .04d6ac) exec(1), time(0.000 ms): <.main+7244>
test/lang/useOperator.ci:215:[.04d6ac, .04d6b5) exec(1), time(0.000 ms): <.main+7253>
test/lang/useOperator.ci:216:[.04d6b5, .04d6b7) exec(1), time(0.001-0.001 ms): <.main+7262>
test/lang/useOperator.ci:217:[.04d6b7, .04d6ba) exec(1), time(0.001-0.001 ms): <.main+7264>
test/lang/useOperator.ci:218:[.04d6ba, .04d6bd) exec(1), time(0.002-0.002 ms): <.main+7267>
test/lang/useOperator.ci:219:[.04d6bd, .04d6c2) exec(1), time(0.002-0.002 ms): <.main+7270>
test/lang/useOperator.ci:220:[.04d6c2, .04d6c7) exec(1), time(0.002-0.002 ms): <.main+7275>
test/lang/useOperator.ci:221:[.04d6c7, .04d6cc) exec(1), time(0.002-0.002 ms): <.main+7280>
test/lang/useOperator.ci:222:[.04d6cc, .04d6d1) exec(1), time(0.002-0.002 ms): <.main+7285>
test/lang/useOperator.ci:223:[.04d6d1, .04d6d6) exec(1), time(0.002-0.002 ms): <.main+7290>
test/lang/useOperator.ci:224:[.04d6d6, .04d6db) exec(1), time(0.002-0.002 ms): <.main+7295>
test/lang/useOperator.ci:225:[.04d6db, .04d6e0) exec(1), time(0.002-0.002 ms): <.main+7300>
test/lang/useOperator.ci:226:[.04d6e0, .04d6e5) exec(1), time(0.002-0.002 ms): <.main+7305>
test/lang/useOperator.ci:227:[.04d6e5, .04d6ea) exec(1), time(0.003-0.003 ms): <.main+7310>
test/lang/useOperator.ci:228:[.04d6ea, .04d6ef) exec(1), time(0.002-0.002 ms): <.main+7315>
test/lang/useOperator.ci:229:[.04d6ef, .04d6f3) exec(1), time(0.003-0.003 ms): <.main+7320>
test/lang/useOperator.ci:230:[.04d6f3, .04d6f8) exec(1), time(0.002-0.002 ms): <.main+7324>
test/lang/useOperator.ci:231:[.04d6f8, .04d6fe) exec(1), time(0.004-0.004 ms): <.main+7329>
test/lang/useOperator.ci:232:[.04d6fe, .04d703) exec(1), time(0.002-0.002 ms): <.main+7335>
test/lang/useOperator.ci:233:[.04d703, .04d709) exec(1), time(0.003-0.003 ms): <.main+7340>
test/lang/useOperator.ci:234:[.04d709, .04d70e) exec(1), time(0.002-0.002 ms): <.main+7346>
test/lang/useOperator.ci:235:[.04d70e, .04d714) exec(1), time(0.003-0.003 ms): <.main+7351>
test/lang/useOperator.ci:237:[.04d714, .04d719) exec(1), time(0.000 ms): <.main+7357>
test/lang/useOperator.ci:238:[.04d719, .04d71e) exec(1), time(0.001-0.001 ms): <.main+7362>
test/lang/useOperator.ci:239:[.04d71e, .04d720) exec(1), time(0.000 ms): <.main+7367>
test/lang/useOperator.ci:240:[.04d720, .04d723) exec(1), time(0.001-0.001 ms): <.main+7369>
test/lang/useOperator.ci:242:[.04d723, .04d728) exec(1), time(0.003-0.003 ms): <.main+7372>
test/lang/useOperator.ci:243:[.04d728, .04d72d) exec(1), time(0.002-0.002 ms): <.main+7377>
test/lang/useOperator.ci:244:[.04d72d, .04d732) exec(1), time(0.003-0.003 ms): <.main+7382>
test/lang/useOperator.ci:245:[.04d732, .04d737) exec(1), time(0.002-0.002 ms): <.main+7387>
test/lang/useOperator.ci:246:[.04d737, .04d73c) exec(1), time(0.003-0.003 ms): <.main+7392>
test/lang/useOperator.ci:252:[.04d73c, .04d740) exec(1), time(0.002-0.002 ms): <.main+7397>
test/lang/useOperator.ci:253:[.04d740, .04d745) exec(1), time(0.002-0.002 ms): <.main+7401>
test/lang/useOperator.ci:254:[.04d745, .04d74b) exec(1), time(0.003-0.003 ms): <.main+7406>
test/lang/useOperator.ci:255:[.04d74b, .04d750) exec(1), time(0.002-0.002 ms): <.main+7412>
test/lang/useOperator.ci:256:[.04d750, .04d756) exec(1), time(0.003-0.003 ms): <.main+7417>
test/lang/useOperator.ci:257:[.04d756, .04d75b) exec(1), time(0.003-0.003 ms): <.main+7423>
test/lang/useOperator.ci:258:[.04d75b, .04d761) exec(1), time(0.003-0.003 ms): <.main+7428>
test/lang/useOperator.ci:260:[.04d761, .04d76a) exec(1), time(0.001-0.001 ms): <.main+7434>
test/lang/useOperator.ci:261:[.04d76a, .04d773) exec(1), time(0.000 ms): <.main+7443>
test/lang/useOperator.ci:262:[.04d773, .04d775) exec(1), time(0.000 ms): <.main+7452>
test/lang/useOperator.ci:263:[.04d775, .04d778) exec(1), time(0.002-0.002 ms): <.main+7454>
test/lang/useOperator.ci:265:[.04d778, .04d77d) exec(1), time(0.002-0.002 ms): <.main+7457>
test/lang/useOperator.ci:266:[.04d77d, .04d782) exec(1), time(0.002-0.002 ms): <.main+7462>
test/lang/useOperator.ci:267:[.04d782, .04d787) exec(1), time(0.002-0.002 ms): <.main+7467>
test/lang/useOperator.ci:268:[.04d787, .04d78c) exec(1), time(0.002-0.002 ms): <.main+7472>
test/lang/useOperator.ci:269:[.04d78c, .04d791) exec(1), time(0.003-0.003 ms): <.main+7477>
test/lang/useOperator.ci:275:[.04d791, .04d795) exec(1), time(0.003-0.003 ms): <.main+7482>
test/lang/useOperator.ci:276:[.04d795, .04d79a) exec(1), time(0.002-0.002 ms): <.main+7486>
test/lang/useOperator.ci:277:[.04d79a, .04d7a0) exec(1), time(0.003-0.003 ms): <.main+7491>
test/lang/useOperator.ci:278:[.04d7a0, .04d7a5) exec(1), time(0.002-0.002 ms): <.main+7497>
test/lang/useOperator.ci:279:[.04d7a5, .04d7ab) exec(1), time(0.003-0.003 ms): <.main+7502>
test/lang/useOperator.ci:280:[.04d7ab, .04d7b0) exec(1), time(0.003-0.003 ms): <.main+7508>
test/lang/useOperator.ci:281:[.04d7b0, .04d7b6) exec(1), time(0.003-0.003 ms): <.main+7513>
test/lang/useOperator.ci:283:[.04d7b6, .04d7bb) exec(1), time(0.001-0.001 ms): <.main+7519>
test/lang/useOperator.ci:284:[.04d7bb, .04d7bf) exec(1), time(0.001-0.001 ms): <.main+7524>
test/lang/useOperator.ci:299:[.04d7bf, .04d7c4) exec(1), time(0.002-0.002 ms): <.main+7528>
test/lang/useOperator.ci:300:[.04d7c4, .04d7ca) exec(1), time(0.003-0.003 ms): <.main+7533>
test/lang/statementIf.ci:4:[.04d7ca, .04d7f1) exec(1), time(0.034-0.034 ms): <.main+7539>
test/lang/statementIf.ci:12:[.04d7f1, .04d818) exec(1), time(0.034-0.034 ms): <.main+7578>
test/lang/statementIf.ci:22:[.04d818, .04d83f) exec(1), time(0.034-0.034 ms): <.main+7617>
test/lang/statementIf.ci:26:[.04d83f, .04d840) exec(1), time(0.001-0.001 ms): <.main+7656>
test/lang/statementIf.ci:29:[.04d848, .04d86e) exec(1), time(0.039-0.039 ms): <.main+7665>
test/lang/statementIf.ci:28:[.04d840, .04d86e) exec(1-1), time(0.000 ms): <.main+7657>
test/lang/statementIf.ci:33:[.04d876, .04d89c) exec(0), time(0.000 ms): <.main+7711>
test/lang/statementIf.ci:32:[.04d86e, .04d89c) exec(1), time(0.003-0.003 ms): <.main+7703>
test/lang/statementIf.ci:37:[.04d8a4, .04d8ca) exec(1), time(0.039-0.039 ms): <.main+7757>
test/lang/statementIf.ci:40:[.04d8ce, .04d8f4) exec(0), time(0.000 ms): <.main+7799>
test/lang/statementIf.ci:36:[.04d89c, .04d8f4) exec(1), time(0.041-0.041 ms): <.main+7749>
test/lang/statementIf.ci:44:[.04d8fc, .04d922) exec(0), time(0.000 ms): <.main+7845>
test/lang/statementIf.ci:47:[.04d926, .04d94c) exec(1), time(0.038-0.038 ms): <.main+7887>
test/lang/statementIf.ci:43:[.04d8f4, .04d94c) exec(1-1), time(0.000 ms): <.main+7837>
test/lang/statementIf.ci:51:[.04d954, .04d97a) exec(1), time(0.038-0.038 ms): <.main+7933>
test/lang/statementIf.ci:54:[.04d98a, .04d9b0) exec(0), time(0.000 ms): <.main+7987>
test/lang/statementIf.ci:57:[.04d9c0, .04d9e6) exec(0), time(0.000 ms): <.main+8041>
test/lang/statementIf.ci:60:[.04d9f6, .04da1c) exec(0), time(0.000 ms): <.main+8095>
test/lang/statementIf.ci:63:[.04da2c, .04da52) exec(0), time(0.000 ms): <.main+8149>
test/lang/statementIf.ci:66:[.04da62, .04da88) exec(0), time(0.000 ms): <.main+8203>
test/lang/statementIf.ci:69:[.04da8c, .04dab2) exec(0), time(0.000 ms): <.main+8245>
test/lang/statementIf.ci:65:[.04da56, .04dab2) exec(0), time(0.000 ms): <.main+8191>
test/lang/statementIf.ci:62:[.04da20, .04dab2) exec(0), time(0.000 ms): <.main+8137>
test/lang/statementIf.ci:59:[.04d9ea, .04dab2) exec(0), time(0.000 ms): <.main+8083>
test/lang/statementIf.ci:56:[.04d9b4, .04dab2) exec(0), time(0.000 ms): <.main+8029>
test/lang/statementIf.ci:53:[.04d97e, .04dab2) exec(0), time(0.000 ms): <.main+7975>
test/lang/statementIf.ci:50:[.04d94c, .04dab2) exec(1), time(0.040-0.040 ms): <.main+7925>
test/lang/statementFor.ci:4:[.04dab6, .04dad9) exec(1), time(0.029-0.029 ms): <.main+8287>
test/lang/statementFor.ci:5:[.04dad9, .04dadd) exec(1), time(0.001-0.001 ms): <.main+8322>
::[.04dadd, .04dae1) exec(1), time(0.000 ms): <.main+8326>
test/lang/statementFor.ci:3:[.04dab2, .04dae1) exec(1-1), time(0.000 ms): <.main+8283>
test/lang/statementFor.ci:9:[.04dae6, .04db08) exec(2), time(0.069-0.069 ms): <.main+8335>
test/lang/statementFor.ci:8:[.04db08, .04db0c) exec(2), time(0.001-0.001 ms): <.main+8369>
test/lang/statementFor.ci:8:[.04db0c, .04db18) exec(3), time(0.009-0.009 ms): <.main+8373>
test/lang/statementFor.ci:8:[.04dae1, .04db1c) exec(1), time(0.005-0.005 ms): <.main+8330>
test/lang/statementFor.ci:12:[.04db1c, .04db1d) exec(1), time(0.000 ms): <.main+8389>
test/lang/statementFor.ci:14:[.04db24, .04db46) exec(2), time(0.068-0.068 ms): <.main+8397>
test/lang/statementFor.ci:13:[.04db46, .04db4a) exec(2), time(0.001-0.001 ms): <.main+8431>
test/lang/statementFor.ci:13:[.04db4a, .04db56) exec(3), time(0.010-0.010 ms): <.main+8435>
test/lang/statementFor.ci:13:[.04db1d, .04db56) exec(1-1), time(0.000 ms): <.main+8390>
test/lang/statementFor.ci:19:[.04db67, .04db6b) exec(2), time(0.000 ms): <.main+8464>
test/lang/statementFor.ci:18:[.04db5b, .04db6b) exec(7-2), time(0.016-0.016 ms): <.main+8452>
test/lang/statementFor.ci:21:[.04db6b, .04db8d) exec(5), time(0.173-0.173 ms): <.main+8468>
test/lang/statementFor.ci:17:[.04db8d, .04db91) exec(7), time(0.004-0.004 ms): <.main+8502>
test/lang/statementFor.ci:17:[.04db91, .04db9d) exec(8), time(0.028-0.028 ms): <.main+8506>
test/lang/statementFor.ci:17:[.04db56, .04dba1) exec(1), time(0.005-0.005 ms): <.main+8447>
test/lang/statementFor.ci:26:[.04dbb2, .04dbb6) exec(1), time(0.000 ms): <.main+8539>
test/lang/statementFor.ci:25:[.04dba6, .04dbb6) exec(4-1), time(0.009-0.009 ms): <.main+8527>
test/lang/statementFor.ci:28:[.04dbb6, .04dbd8) exec(3), time(0.102-0.102 ms): <.main+8543>
test/lang/statementFor.ci:24:[.04dbd8, .04dbdc) exec(3), time(0.001-0.001 ms): <.main+8577>
test/lang/statementFor.ci:24:[.04dbdc, .04dbe8) exec(4), time(0.012-0.012 ms): <.main+8581>
test/lang/statementFor.ci:24:[.04dba1, .04dbec) exec(1), time(0.002-0.002 ms): <.main+8522>
test/stdc/test.math.ci:3:[.04dbec, .04dc00) exec(1), time(0.034-0.034 ms): <.main+8597>
test/stdc/test.math.ci:4:[.04dc00, .04dc14) exec(1), time(0.033-0.033 ms): <.main+8617>
test/stdc/test.math.ci:5:[.04dc14, .04dc28) exec(1), time(0.032-0.032 ms): <.main+8637>
test/stdc/test.math.ci:6:[.04dc28, .04dc3c) exec(1), time(0.046-0.046 ms): <.main+8657>
test/stdc/test.math.ci:7:[.04dc3c, .04dc50) exec(1), time(0.046-0.046 ms): <.main+8677>
test/stdc/test.math.ci:8:[.04dc50, .04dc64) exec(1), time(0.046-0.046 ms): <.main+8697>
test/stdc/test.math.ci:10:[.04dc64, .04dc79) exec(1), time(0.021-0.021 ms): <.main+8717>
test/stdc/test.math.ci:11:[.04dc79, .04dc86) exec(1), time(0.020-0.020 ms): <.main+8738>
test/stdc/test.math.ci:12:[.04dc86, .04dc9b) exec(1), time(0.020-0.020 ms): <.main+8751>
test/stdc/test.math.ci:13:[.04dc9b, .04dcac) exec(1), time(0.020-0.020 ms): <.main+8772>
test/stdc/test.math.ci:14:[.04dcac, .04dcb9) exec(1), time(0.026-0.026 ms): <.main+8789>
test/stdc/test.math.ci:15:[.04dcb9, .04dcca) exec(1), time(0.021-0.021 ms): <.main+8802>
test/stdc/test.math.ci:17:[.04dcca, .04dcde) exec(1), time(0.019-0.019 ms): <.main+8819>
test/stdc/test.math.ci:18:[.04dcde, .04dce9) exec(1), time(0.032-0.032 ms): <.main+8839>
test/stdc/test.math.ci:19:[.04dce9, .04dcfd) exec(1), time(0.028-0.028 ms): <.main+8850>
test/stdc/test.math.ci:20:[.04dcfd, .04dd0e) exec(1), time(0.030-0.030 ms): <.main+8870>
test/stdc/test.math.ci:21:[.04dd0e, .04dd1b) exec(1), time(0.034-0.034 ms): <.main+8887>
test/stdc/test.math.ci:22:[.04dd1b, .04dd2c) exec(1), time(0.033-0.033 ms): <.main+8900>
test/stdc/test.math.ci:24:[.04dd2c, .04dd42) exec(1), time(0.032-0.032 ms): <.main+8917>
test/stdc/test.math.ci:25:[.04dd42, .04dd58) exec(1), time(0.033-0.033 ms): <.main+8939>
test/stdc/test.math.ci:26:[.04dd58, .04dd75) exec(1), time(0.033-0.033 ms): <.main+8961>
test/stdc/test.math.ci:27:[.04dd75, .04dd92) exec(1), time(0.031-0.031 ms): <.main+8990>
test/stdc/test.math.ci:29:[.04dd92, .04dda9) exec(1), time(0.038-0.038 ms): <.main+9019>
test/stdc/test.math.ci:30:[.04dda9, .04ddc7) exec(1), time(0.026-0.026 ms): <.main+9042>
test/stdc/test.math.ci:32:[.04ddc7, .04dddc) exec(1), time(0.009-0.009 ms): <.main+9072>
test/stdc/test.math.ci:33:[.04dddc, .04ddf8) exec(1), time(0.009-0.009 ms): <.main+9093>
test/stdc/test.math.ci:35:[.04ddf8, .04de10) exec(1), time(0.012-0.012 ms): <.main+9121>
test/stdc/test.math.ci:36:[.04de10, .04de2f) exec(1), time(0.011-0.011 ms): <.main+9145>
test/stdc/test.math.ci:37:[.04de2f, .04de6b) exec(1), time(0.042-0.042 ms): <.main+9176>
test/stdc/test.math.ci:38:[.04de6b, .04deb9) exec(1), time(0.040-0.040 ms): <.main+9236>
test/stdc/test.math.ci:40:[.04deb9, .04dece) exec(1), time(0.024-0.024 ms): <.main+9314>
test/stdc/test.math.ci:41:[.04dece, .04df38) exec(1), time(0.060-0.060 ms): <.main+9335>
test/stdc/test.math.ci:42:[.04df38, .04df4d) exec(1), time(0.024-0.024 ms): <.main+9441>
test/stdc/test.math.ci:43:[.04df4d, .04dfb7) exec(1), time(0.060-0.060 ms): <.main+9462>
test/stdc/test.math.ci:45:[.04dfb7, .04dfcc) exec(1), time(0.026-0.026 ms): <.main+9568>
test/stdc/test.math.ci:46:[.04dfcc, .04dfee) exec(1), time(0.030-0.030 ms): <.main+9589>
test/stdc/test.math.ci:47:[.04dfee, .04e019) exec(1), time(0.041-0.041 ms): <.main+9623>
test/stdc/test.math.ci:48:[.04e019, .04e08c) exec(1), time(0.066-0.066 ms): <.main+9666>
test/stdc/test.math.ci:50:[.04e08c, .04e095) exec(1), time(0.000 ms): <.main+9781>
test/stdc/test.math.ci:51:[.04e095, .04e0ac) exec(1), time(0.028-0.028 ms): <.main+9790>
test/stdc/test.math.ci:52:[.04e0ac, .04e0b5) exec(1), time(0.001-0.001 ms): <.main+9813>
test/stdc/test.math.ci:53:[.04e0b5, .04e0cb) exec(1), time(0.005-0.005 ms): <.main+9822>
test/stdc/test.math.ci:54:[.04e0cb, .04e0f2) exec(1), time(0.011-0.011 ms): <.main+9844>
test/stdc/test.math.ci:55:[.04e0f2, .04e12a) exec(1), time(0.017-0.017 ms): <.main+9883>
test/stdc/test.math.ci:56:[.04e12a, .04e172) exec(1), time(0.048-0.048 ms): <.main+9939>
test/stdc/test.math.ci:57:[.04e172, .04e1c3) exec(1), time(0.052-0.052 ms): <.main+10011>
test/stdc/test.math.ci:59:[.04e1c3, .04e1e2) exec(1), time(0.040-0.040 ms): <.main+10092>
test/stdc/test.math.ci:60:[.04e1e2, .04e20f) exec(1), time(0.057-0.057 ms): <.main+10123>
test/stdc/test.math.ci:61:[.04e20f, .04e22d) exec(1), time(0.056-0.056 ms): <.main+10168>
test/stdc/test.math.ci:62:[.04e22d, .04e24b) exec(1), time(0.056-0.056 ms): <.main+10198>
test/stdc/test.math.ci:63:[.04e24b, .04e269) exec(1), time(0.049-0.049 ms): <.main+10228>
test/stdc/test.math.ci:65:[.04e269, .04e27d) exec(1), time(0.055-0.055 ms): <.main+10258>
test/stdc/test.math.ci:66:[.04e27d, .04e2a5) exec(1), time(0.058-0.058 ms): <.main+10278>
test/stdc/test.math.ci:69:[.04e2a5, .04e2c1) exec(1), time(0.025-0.025 ms): <.main+10318>
test/stdc/test.math.ci:70:[.04e2c1, .04e2e9) exec(1), time(0.025-0.025 ms): <.main+10346>
test/stdc/test.math.ci:72:[.04e2e9, .04e306) exec(1), time(0.021-0.021 ms): <.main+10386>
test/stdc/test.math.ci:73:[.04e306, .04e31a) exec(1), time(0.020-0.020 ms): <.main+10415>
test/stdc/test.math.ci:74:[.04e31a, .04e337) exec(1), time(0.020-0.020 ms): <.main+10435>
test/stdc/test.math.ci:76:[.04e337, .04e354) exec(1), time(0.020-0.020 ms): <.main+10464>
test/stdc/test.math.ci:77:[.04e354, .04e371) exec(1), time(0.020-0.020 ms): <.main+10493>
test/stdc/test.math.ci:78:[.04e371, .04e38e) exec(1), time(0.019-0.019 ms): <.main+10522>
test/stdc/test.math.ci:79:[.04e38e, .04e3ab) exec(1), time(0.020-0.020 ms): <.main+10551>
test/stdc/test.math.ci:81:[.04e3ab, .04e3c8) exec(1), time(0.020-0.020 ms): <.main+10580>
test/stdc/test.math.ci:82:[.04e3c8, .04e3e5) exec(1), time(0.020-0.020 ms): <.main+10609>
test/stdc/test.math.ci:83:[.04e3e5, .04e402) exec(1), time(0.020-0.020 ms): <.main+10638>
test/stdc/test.math.ci:84:[.04e402, .04e41f) exec(1), time(0.020-0.020 ms): <.main+10667>
test/stdc/test.math.ci:86:[.04e41f, .04e434) exec(1), time(0.021-0.021 ms): <.main+10696>
test/stdc/test.math.ci:87:[.04e434, .04e445) exec(1), time(0.021-0.021 ms): <.main+10717>
test/stdc/test.math.ci:88:[.04e445, .04e45a) exec(1), time(0.020-0.020 ms): <.main+10734>
test/stdc/test.math.ci:90:[.04e45a, .04e46f) exec(1), time(0.020-0.020 ms): <.main+10755>
test/stdc/test.math.ci:91:[.04e46f, .04e484) exec(1), time(0.020-0.020 ms): <.main+10776>
test/stdc/test.math.ci:92:[.04e484, .04e499) exec(1), time(0.020-0.020 ms): <.main+10797>
test/stdc/test.math.ci:93:[.04e499, .04e4ae) exec(1), time(0.021-0.021 ms): <.main+10818>
test/stdc/test.math.ci:95:[.04e4ae, .04e4c3) exec(1), time(0.021-0.021 ms): <.main+10839>
test/stdc/test.math.ci:96:[.04e4c3, .04e4d8) exec(1), time(0.020-0.020 ms): <.main+10860>
test/stdc/test.math.ci:97:[.04e4d8, .04e4ed) exec(1), time(0.021-0.021 ms): <.main+10881>
test/stdc/test.math.ci:98:[.04e4ed, .04e502) exec(1), time(0.021-0.021 ms): <.main+10902>

---------- Exitcode: 0, time: 23.480 ms
