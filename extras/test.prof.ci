
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:59: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:80: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:81: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:82: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:79: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:67: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:94: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:95: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:97: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:98: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:99: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:78: warn: comment does not belong to a declaration
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@005f68>, cast: static const inline)
.field file: function (size: 0, offs: <@006168>, cast: static const inline)
.field line: function (size: 0, offs: <@006368>, cast: static const inline)
.field name: function (size: 0, offs: <@006568>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:92: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:92: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005f68>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006168>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006368>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006568>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:75: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:56: referenced as `bool`
	lib/stdlib.ci:54: referenced as `bool`
	lib/stdlib.ci:52: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:75: referenced as `char`
	lib/stdlib.ci:70: referenced as `char`
	lib/stdlib.ci:54: referenced as `char`
	lib/stdlib.ci:52: referenced as `char`
	lib/stdlib.ci:47: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:42: referenced as `char`
	lib/stdlib.ci:40: referenced as `char`
	lib/stdlib.ci:37: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:32: referenced as `char`
	lib/stdlib.ci:30: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:25: referenced as `char`
	lib/stdlib.ci:22: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:92: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0091a8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0094d8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0096d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0098d8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ad8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009cd8>, cast: static const inline)
.field hib: function (size: 0, offs: <@009ed8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a0d8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091a8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0094d8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098d8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ad8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009cd8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ed8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0d8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a400>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a728>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a400>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a728>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00a928>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ab28>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ad28>, cast: static const inline)
.field log: function (size: 0, offs: <@00af28>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b128>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b3c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b5c0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b858>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a928>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab28>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad28>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af28>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b128>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b3c0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5c0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b858>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00ba50>, cast: static const inline)
.field cos: function (size: 0, offs: <@00bc48>, cast: static const inline)
.field tan: function (size: 0, offs: <@00be40>, cast: static const inline)
.field log: function (size: 0, offs: <@00c038>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c230>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c4c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c6b8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c948>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba50>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc48>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be40>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c038>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c230>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c4c0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6b8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c948>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007880>, cast: static const inline)
.field fill: function (size: 0, offs: <@007bb8>, cast: static const inline)
.field copy: function (size: 0, offs: <@007ef0>, cast: static const inline)
.field move: function (size: 0, offs: <@008220>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007880>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bb8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007ef0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008220>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:67: referenced as `variant`
	lib/stdlib.ci:64: referenced as `variant`
	lib/stdlib.ci:61: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:45: referenced as `variant`
	lib/stdlib.ci:40: referenced as `variant`
	lib/stdlib.ci:35: referenced as `variant`
	lib/stdlib.ci:30: referenced as `variant`
	lib/stdlib.ci:25: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:15: referenced as `variant`
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:87: referenced as `null`
	lib/stdlib.ci:70: referenced as `null`
	lib/stdlib.ci:67: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:47: referenced as `null`
	lib/stdlib.ci:42: referenced as `null`
	lib/stdlib.ci:37: referenced as `null`
	lib/stdlib.ci:32: referenced as `null`
	lib/stdlib.ci:27: referenced as `null`
	lib/stdlib.ci:22: referenced as `null`
	lib/stdlib.ci:17: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.usages:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.usages:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@001058>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@0010f8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0014b8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001558>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0017d8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001d78>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@0022f0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0024c0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002690>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002860>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002a30>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002d30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@003180>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@0035b0>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0039e0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f40>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044a0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0048d0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004d00>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005130>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005560>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005730>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0014b8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001558>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0017d8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001d78>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022f0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0024c0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002690>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002860>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a30>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002d30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003180>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0035b0>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0039e0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f40>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044a0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048d0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004d00>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005130>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005560>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005730>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005c20>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d00>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(5)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:84: referenced as `abort`
	lib/stdlib.ci:49: referenced as `abort`
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:42: referenced as `error`
	lib/stdlib.ci:40: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:37: referenced as `warn`
	lib/stdlib.ci:35: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:32: referenced as `info`
	lib/stdlib.ci:30: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:27: referenced as `debug`
	lib/stdlib.ci:25: referenced as `debug`
	lib/stdlib.ci:22: referenced as `debug`
	lib/stdlib.ci:20: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:17: referenced as `verbose`
	lib/stdlib.ci:15: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:37: referenced as `noTrace`
	lib/stdlib.ci:35: referenced as `noTrace`
	lib/stdlib.ci:32: referenced as `noTrace`
	lib/stdlib.ci:30: referenced as `noTrace`
	lib/stdlib.ci:22: referenced as `noTrace`
	lib/stdlib.ci:20: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:84: referenced as `defTrace`
	lib/stdlib.ci:49: referenced as `defTrace`
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:45: referenced as `defTrace`
	lib/stdlib.ci:42: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:27: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0075e0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008250>
.name: 'System'
.field exit: function (size: 0, offs: <@0084c8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0086d0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008838>, cast: static const inline)
.field time: function (size: 0, offs: <@0089a0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008b08>, cast: static const inline)
.field millis: function (size: 0, offs: <@008c70>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008e70>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084c8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008838>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b08>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c70>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e70>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.usages:
	internal usages: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:15: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:17: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:20: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:22'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/stdlib.ci:22: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/stdlib.ci:25: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:27: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:30'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:30: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:32'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:32: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:35'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:35: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:37: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:40: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:42: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:52: referenced as `abort`
	lib/stdlib.ci:45: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:56: referenced as `abort`
	lib/stdlib.ci:54: referenced as `abort`
	lib/stdlib.ci:47: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:49: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:52'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:52: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:54'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:54: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:56'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:56: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00fbe0>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:59'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:79: referenced as `NotEquals`
	lib/stdlib.ci:59: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:80: referenced as `expected`
	lib/stdlib.ci:61: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:64'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:81: referenced as `returned`
	lib/stdlib.ci:64: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:67'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:67: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:70'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:82: referenced as `message`
	lib/stdlib.ci:70: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@050210>
.name: 'assertEq'
.file: 'lib/stdlib.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@050210> - <@05026e>)
	lib/stdlib.ci:76: (10 bytes: <@050210> - <@05021a>): if (bool(returned == expected))
	<assertEq @050210>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @050212>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @050214>    : 57                         ceq.i32
	<assertEq+5 @050215>    : 06 05 00 00                jz <assertEq+10 @05021a>
	lib/stdlib.ci:77: (1 byte: <@050219> - <@05021a>): return;
	<assertEq+9 @050219>    : 03                         ret
	lib/stdlib.ci:79: (41 bytes: <@05021a> - <@050243>): details: NotEquals := {...}
	<assertEq+10 @05021a>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:80: (11 bytes: <@05021e> - <@050229>): void(details.expected := (expected));
	<assertEq+14 @05021e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @050223>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @050227>   : 14 02                      set.x64 sp(2)
	lib/stdlib.ci:81: (11 bytes: <@050229> - <@050234>): void(details.returned := (returned));
	<assertEq+25 @050229>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @05022e>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @050232>   : 14 04                      set.x64 sp(4)
	lib/stdlib.ci:82: (3 bytes: <@050234> - <@050237>): void(details.message := (message));
	<assertEq+36 @050234>   : 16 06 09                   mov.x32 sp(6, 9)
	:: (12 bytes: <@050237> - <@050243>): void(details.argument := (null))
	<assertEq+39 @050237>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @05023c>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @050241>   : 14 06                      set.x64 sp(6)
	lib/stdlib.ci:84: (38 bytes: <@050243> - <@050269>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @050243>   : 1f 78 c9 00 00             load.ref <@00c978> ;"lib/stdlib.ci"
	<assertEq+56 @050248>   : 1c 54 00 00 00             load.c32 84
	<assertEq+61 @05024d>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @050252>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @050257>   : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<assertEq+76 @05025c>   : 1f e0 fb 00 00             load.ref <@00fbe0> ;NotEquals
	<assertEq+81 @050261>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @050265>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @050269>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @05026d>   : 03                         ret
.usages:
	lib/stdlib.ci:87: referenced as `assertEq`
	lib/stdlib.ci:75: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/stdlib.ci:87'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:87: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:92'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:92: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@010e58>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@050270>, cast: static const function)
.field floor: function (size: 24, offs: <@0502c8>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@0502e0>, cast: static const function)
.field abs: function (size: 18, offs: <@0502f8>, cast: static const function)
.field absMod: function (size: 27, offs: <@050310>, cast: static const function)
.field absMod: function (size: 27, offs: <@050330>, cast: static const function)
.field min: function (size: 17, offs: <@050350>, cast: static const function)
.field min: function (size: 17, offs: <@050368>, cast: static const function)
.field max: function (size: 17, offs: <@050380>, cast: static const function)
.field max: function (size: 17, offs: <@050398>, cast: static const function)
.field clamp: function (size: 30, offs: <@0503b0>, cast: static const function)
.field clamp: function (size: 30, offs: <@0503d0>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@0503f0>, cast: static const function)
.field max: function (size: 72, offs: <@050438>, cast: static const function)
.field sum: function (size: 40, offs: <@050480>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@0504a8>, cast: static const function)
.field cmp: function (size: 57, offs: <@0504d8>, cast: static const function)
.field cmp: function (size: 57, offs: <@050518>, cast: static const function)
.field sinCos: function (size: 335, offs: <@050558>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@0506a8>, cast: static const function)
.field sinh: function (size: 241, offs: <@050820>, cast: static const function)
.field cosh: function (size: 75, offs: <@050918>, cast: static const function)
.field asin: function (size: 166, offs: <@050968>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: float64(1.000000 / ln2)
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: float64(1.000000 / ln10)
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: float64((0) / 0.000000)
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: float64((1) / 0.000000)
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@050270>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@050270> - <@0502c6>)
	lib/std/math.ci:23: (63 bytes: <@050270> - <@0502af>): if (bool(x < (1)))
	<modf @050270>      : 11 02                      dup.x64 sp(2)
	<modf+2 @050272>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @05027b>   : 88                         clt.f64
	<modf+12 @05027c>   : 06 33 00 00                jz <modf+63 @0502af>
	lib/std/math.ci:24: (39 bytes: <@050280> - <@0502a7>): if (bool(x < (0)))
	<modf+16 @050280>   : 11 02                      dup.x64 sp(2)
	<modf+18 @050282>   : 1a                         load.z64
	<modf+19 @050283>   : 88                         clt.f64
	<modf+20 @050284>   : 06 23 00 00                jz <modf+55 @0502a7>
	lib/std/math.ci:25: (17 bytes: <@050288> - <@050299>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @050288>   : 1a                         load.z64
	<modf+25 @050289>   : 11 04                      dup.x64 sp(4)
	<modf+27 @05028b>   : 80                         neg.f64
	<modf+28 @05028c>   : 10 05                      dup.x32 sp(5)
	<modf+30 @05028e>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @050293>   : 02                         call
	<modf+36 @050294>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @050298>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@050299> - <@0502a0>): float64(intPart := float64(-intPart));
	<modf+41 @050299>   : 10 03                      dup.x32 sp(3)
	<modf+43 @05029b>   : 23                         load.i64
	<modf+44 @05029c>   : 80                         neg.f64
	<modf+45 @05029d>   : 10 05                      dup.x32 sp(5)
	<modf+47 @05029f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0502a0> - <@0502a3>): return float64(.result := result);
	<modf+48 @0502a0>   : 14 06                      set.x64 sp(6)
	<modf+50 @0502a2>   : 03                         ret
	<modf+51 @0502a3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0502a7> - <@0502ab>): float64(intPart := (0));
	<modf+55 @0502a7>   : 1a                         load.z64
	<modf+56 @0502a8>   : 10 03                      dup.x32 sp(3)
	<modf+58 @0502aa>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0502ab> - <@0502af>): return float64(.result := x);
	<modf+59 @0502ab>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @0502ae>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0502af> - <@0502bb>): result: float64 := float64(x % (1))
	<modf+63 @0502af>   : 11 02                      dup.x64 sp(2)
	<modf+65 @0502b1>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @0502ba>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@0502bb> - <@0502c3>): float64(intPart := float64(x - result));
	<modf+75 @0502bb>   : 11 04                      dup.x64 sp(4)
	<modf+77 @0502bd>   : 11 02                      dup.x64 sp(2)
	<modf+79 @0502bf>   : 82                         sub.f64
	<modf+80 @0502c0>   : 10 05                      dup.x32 sp(5)
	<modf+82 @0502c2>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@0502c3> - <@0502c6>): return float64(.result := result);
	<modf+83 @0502c3>   : 14 06                      set.x64 sp(6)
	<modf+85 @0502c5>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@0502c8>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@0502c8> - <@0502e0>)
	lib/std/math.ci:48: (1 byte: <@0502c8> - <@0502c9>): result: float64
	<floor @0502c8>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@0502c9> - <@0502dd>): modf(void(x, result));
	<floor+1 @0502c9>    : 11 05                      dup.x64 sp(5)
	<floor+3 @0502cb>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @0502cf>    : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @0502d4>   : 02                         call
	<floor+13 @0502d5>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @0502d9>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@0502dd> - <@0502e0>): return float64(.result := result);
	<floor+21 @0502dd>   : 14 05                      set.x64 sp(5)
	<floor+23 @0502df>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0502e0>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@0502e0> - <@0502f2>)
	lib/std/math.ci:78: (14 bytes: <@0502e0> - <@0502ee>): if (bool(x < (0)))
	<abs @0502e0>      : 10 01                      dup.x32 sp(1)
	<abs+2 @0502e2>    : 19                         load.z32
	<abs+3 @0502e3>    : 78                         clt.f32
	<abs+4 @0502e4>    : 06 0a 00 00                jz <abs+14 @0502ee>
	lib/std/math.ci:79: (6 bytes: <@0502e8> - <@0502ee>): return float32(.result := float32(-x));
	<abs+8 @0502e8>    : 10 01                      dup.x32 sp(1)
	<abs+10 @0502ea>   : 70                         neg.f32
	<abs+11 @0502eb>   : 13 03                      set.x32 sp(3)
	<abs+13 @0502ed>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@0502ee> - <@0502f2>): return float32(.result := x);
	<abs+14 @0502ee>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @0502f1>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0502f8>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@0502f8> - <@05030a>)
	lib/std/math.ci:86: (14 bytes: <@0502f8> - <@050306>): if (bool(x < (0)))
	<abs @0502f8>      : 11 01                      dup.x64 sp(1)
	<abs+2 @0502fa>    : 1a                         load.z64
	<abs+3 @0502fb>    : 88                         clt.f64
	<abs+4 @0502fc>    : 06 0a 00 00                jz <abs+14 @050306>
	lib/std/math.ci:87: (6 bytes: <@050300> - <@050306>): return float64(.result := float64(-x));
	<abs+8 @050300>    : 11 01                      dup.x64 sp(1)
	<abs+10 @050302>   : 80                         neg.f64
	<abs+11 @050303>   : 14 05                      set.x64 sp(5)
	<abs+13 @050305>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@050306> - <@05030a>): return float64(.result := x);
	<abs+14 @050306>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @050309>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050310>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@050310> - <@05032b>)
	lib/std/math.ci:94: (23 bytes: <@050310> - <@050327>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @050310>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @050312>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @050314>    : 75                         mod.f32
	<absMod+5 @050315>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @050317>    : 13 04                      set.x32 sp(4)
	<absMod+9 @050319>    : 19                         load.z32
	<absMod+10 @05031a>   : 78                         clt.f32
	<absMod+11 @05031b>   : 06 0c 00 00                jz <absMod+23 @050327>
	lib/std/math.ci:95: (8 bytes: <@05031f> - <@050327>): return float32(.result := float32(val + mod));
	<absMod+15 @05031f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @050321>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @050323>   : 71                         add.f32
	<absMod+20 @050324>   : 13 04                      set.x32 sp(4)
	<absMod+22 @050326>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@050327> - <@05032b>): return float32(.result := val);
	<absMod+23 @050327>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @05032a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050330>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@050330> - <@05034b>)
	lib/std/math.ci:102: (23 bytes: <@050330> - <@050347>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @050330>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @050332>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @050334>    : 85                         mod.f64
	<absMod+5 @050335>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @050337>    : 14 07                      set.x64 sp(7)
	<absMod+9 @050339>    : 1a                         load.z64
	<absMod+10 @05033a>   : 88                         clt.f64
	<absMod+11 @05033b>   : 06 0c 00 00                jz <absMod+23 @050347>
	lib/std/math.ci:103: (8 bytes: <@05033f> - <@050347>): return float64(.result := float64(val + mod));
	<absMod+15 @05033f>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @050341>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @050343>   : 81                         add.f64
	<absMod+20 @050344>   : 14 07                      set.x64 sp(7)
	<absMod+22 @050346>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@050347> - <@05034b>): return float64(.result := val);
	<absMod+23 @050347>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @05034a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050350>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@050350> - <@050361>)
	lib/std/math.ci:116: (13 bytes: <@050350> - <@05035d>): if (bool(a < b))
	<min @050350>      : 10 02                      dup.x32 sp(2)
	<min+2 @050352>    : 10 02                      dup.x32 sp(2)
	<min+4 @050354>    : 78                         clt.f32
	<min+5 @050355>    : 06 08 00 00                jz <min+13 @05035d>
	lib/std/math.ci:117: (4 bytes: <@050359> - <@05035d>): return float32(.result := a);
	<min+9 @050359>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @05035c>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@05035d> - <@050361>): return float32(.result := b);
	<min+13 @05035d>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @050360>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050368>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@050368> - <@050379>)
	lib/std/math.ci:124: (13 bytes: <@050368> - <@050375>): if (bool(a < b))
	<min @050368>      : 11 03                      dup.x64 sp(3)
	<min+2 @05036a>    : 11 03                      dup.x64 sp(3)
	<min+4 @05036c>    : 88                         clt.f64
	<min+5 @05036d>    : 06 08 00 00                jz <min+13 @050375>
	lib/std/math.ci:125: (4 bytes: <@050371> - <@050375>): return float64(.result := a);
	<min+9 @050371>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @050374>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@050375> - <@050379>): return float64(.result := b);
	<min+13 @050375>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @050378>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050380>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@050380> - <@050391>)
	lib/std/math.ci:138: (13 bytes: <@050380> - <@05038d>): if (bool(a > b))
	<max @050380>      : 10 02                      dup.x32 sp(2)
	<max+2 @050382>    : 10 02                      dup.x32 sp(2)
	<max+4 @050384>    : 79                         cgt.f32
	<max+5 @050385>    : 06 08 00 00                jz <max+13 @05038d>
	lib/std/math.ci:139: (4 bytes: <@050389> - <@05038d>): return float32(.result := a);
	<max+9 @050389>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @05038c>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@05038d> - <@050391>): return float32(.result := b);
	<max+13 @05038d>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @050390>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050398>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@050398> - <@0503a9>)
	lib/std/math.ci:146: (13 bytes: <@050398> - <@0503a5>): if (bool(a > b))
	<max @050398>      : 11 03                      dup.x64 sp(3)
	<max+2 @05039a>    : 11 03                      dup.x64 sp(3)
	<max+4 @05039c>    : 89                         cgt.f64
	<max+5 @05039d>    : 06 08 00 00                jz <max+13 @0503a5>
	lib/std/math.ci:147: (4 bytes: <@0503a1> - <@0503a5>): return float64(.result := a);
	<max+9 @0503a1>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @0503a4>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@0503a5> - <@0503a9>): return float64(.result := b);
	<max+13 @0503a5>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @0503a8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0503b0>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@0503b0> - <@0503ce>)
	lib/std/math.ci:160: (13 bytes: <@0503b0> - <@0503bd>): if (bool(t < a))
	<clamp @0503b0>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @0503b2>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @0503b4>    : 78                         clt.f32
	<clamp+5 @0503b5>    : 06 08 00 00                jz <clamp+13 @0503bd>
	lib/std/math.ci:161: (4 bytes: <@0503b9> - <@0503bd>): return float32(.result := a);
	<clamp+9 @0503b9>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @0503bc>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@0503bd> - <@0503ca>): if (bool(t > b))
	<clamp+13 @0503bd>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @0503bf>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @0503c1>   : 79                         cgt.f32
	<clamp+18 @0503c2>   : 06 08 00 00                jz <clamp+26 @0503ca>
	lib/std/math.ci:164: (4 bytes: <@0503c6> - <@0503ca>): return float32(.result := b);
	<clamp+22 @0503c6>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @0503c9>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@0503ca> - <@0503ce>): return float32(.result := t);
	<clamp+26 @0503ca>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @0503cd>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0503d0>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@0503d0> - <@0503ee>)
	lib/std/math.ci:171: (13 bytes: <@0503d0> - <@0503dd>): if (bool(t < a))
	<clamp @0503d0>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @0503d2>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @0503d4>    : 88                         clt.f64
	<clamp+5 @0503d5>    : 06 08 00 00                jz <clamp+13 @0503dd>
	lib/std/math.ci:172: (4 bytes: <@0503d9> - <@0503dd>): return float64(.result := a);
	<clamp+9 @0503d9>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @0503dc>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@0503dd> - <@0503ea>): if (bool(t > b))
	<clamp+13 @0503dd>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @0503df>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @0503e1>   : 89                         cgt.f64
	<clamp+18 @0503e2>   : 06 08 00 00                jz <clamp+26 @0503ea>
	lib/std/math.ci:175: (4 bytes: <@0503e6> - <@0503ea>): return float64(.result := b);
	<clamp+22 @0503e6>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @0503e9>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@0503ea> - <@0503ee>): return float64(.result := t);
	<clamp+26 @0503ea>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @0503ed>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@0503f0>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@0503f0> - <@050438>)
	lib/std/math.ci:202: (13 bytes: <@0503f0> - <@0503fd>): if (bool(data.length == (0)))
	<min @0503f0>      : 10 02                      dup.x32 sp(2)
	<min+2 @0503f2>    : 19                         load.z32
	<min+3 @0503f3>    : 57                         ceq.i32
	<min+4 @0503f4>    : 06 09 00 00                jz <min+13 @0503fd>
	lib/std/math.ci:203: (5 bytes: <@0503f8> - <@0503fd>): return float64(.result := nan);
	<min+8 @0503f8>    : 1b                         load.z128
	<min+9 @0503f9>    : 84                         div.f64
	<min+10 @0503fa>   : 14 05                      set.x64 sp(5)
	<min+12 @0503fc>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@0503fd> - <@050400>): result: float64 := data[0]
	<min+13 @0503fd>   : 10 01                      dup.x32 sp(1)
	<min+15 @0503ff>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@050400> - <@050435>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @050400>   : 1c 01 00 00 00             load.c32 1
	<min+21 @050405>   : 04 23 00 00                jmp <min+56 @050428>
	lib/std/math.ci:207: (27 bytes: <@050409> - <@050424>): if (bool(result > data[i]))
	<min+25 @050409>   : 11 01                      dup.x64 sp(1)
	<min+27 @05040b>   : 10 06                      dup.x32 sp(6)
	<min+29 @05040d>   : 10 03                      dup.x32 sp(3)
	<min+31 @05040f>   : 0d 08 00 00                mad.u32 8
	<min+35 @050413>   : 23                         load.i64
	<min+36 @050414>   : 89                         cgt.f64
	<min+37 @050415>   : 06 0f 00 00                jz <min+52 @050424>
	lib/std/math.ci:208: (11 bytes: <@050419> - <@050424>): float64(result := data[i]);
	<min+41 @050419>   : 10 04                      dup.x32 sp(4)
	<min+43 @05041b>   : 10 01                      dup.x32 sp(1)
	<min+45 @05041d>   : 0d 08 00 00                mad.u32 8
	<min+49 @050421>   : 23                         load.i64
	<min+50 @050422>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@050424> - <@050428>): int32(i := int32(i + 1))
	<min+52 @050424>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@050428> - <@050431>): bool(i < (data.length))
	<min+56 @050428>   : 10 00                      dup.x32 sp(0)
	<min+58 @05042a>   : 10 06                      dup.x32 sp(6)
	<min+60 @05042c>   : 58                         clt.i32
	<min+61 @05042d>   : 05 dc ff ff                jnz <min+25 @050409>
	<min+65 @050431>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@050435> - <@050438>): return float64(.result := result);
	<min+69 @050435>   : 14 05                      set.x64 sp(5)
	<min+71 @050437>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@050438>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@050438> - <@050480>)
	lib/std/math.ci:216: (13 bytes: <@050438> - <@050445>): if (bool(data.length == (0)))
	<max @050438>      : 10 02                      dup.x32 sp(2)
	<max+2 @05043a>    : 19                         load.z32
	<max+3 @05043b>    : 57                         ceq.i32
	<max+4 @05043c>    : 06 09 00 00                jz <max+13 @050445>
	lib/std/math.ci:217: (5 bytes: <@050440> - <@050445>): return float64(.result := nan);
	<max+8 @050440>    : 1b                         load.z128
	<max+9 @050441>    : 84                         div.f64
	<max+10 @050442>   : 14 05                      set.x64 sp(5)
	<max+12 @050444>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@050445> - <@050448>): result: float64 := data[0]
	<max+13 @050445>   : 10 01                      dup.x32 sp(1)
	<max+15 @050447>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@050448> - <@05047d>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @050448>   : 1c 01 00 00 00             load.c32 1
	<max+21 @05044d>   : 04 23 00 00                jmp <max+56 @050470>
	lib/std/math.ci:221: (27 bytes: <@050451> - <@05046c>): if (bool(result < data[i]))
	<max+25 @050451>   : 11 01                      dup.x64 sp(1)
	<max+27 @050453>   : 10 06                      dup.x32 sp(6)
	<max+29 @050455>   : 10 03                      dup.x32 sp(3)
	<max+31 @050457>   : 0d 08 00 00                mad.u32 8
	<max+35 @05045b>   : 23                         load.i64
	<max+36 @05045c>   : 88                         clt.f64
	<max+37 @05045d>   : 06 0f 00 00                jz <max+52 @05046c>
	lib/std/math.ci:222: (11 bytes: <@050461> - <@05046c>): float64(result := data[i]);
	<max+41 @050461>   : 10 04                      dup.x32 sp(4)
	<max+43 @050463>   : 10 01                      dup.x32 sp(1)
	<max+45 @050465>   : 0d 08 00 00                mad.u32 8
	<max+49 @050469>   : 23                         load.i64
	<max+50 @05046a>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@05046c> - <@050470>): int32(i := int32(i + 1))
	<max+52 @05046c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@050470> - <@050479>): bool(i < (data.length))
	<max+56 @050470>   : 10 00                      dup.x32 sp(0)
	<max+58 @050472>   : 10 06                      dup.x32 sp(6)
	<max+60 @050474>   : 58                         clt.i32
	<max+61 @050475>   : 05 dc ff ff                jnz <max+25 @050451>
	<max+65 @050479>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@05047d> - <@050480>): return float64(.result := result);
	<max+69 @05047d>   : 14 05                      set.x64 sp(5)
	<max+71 @05047f>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@050480>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@050480> - <@0504a8>)
	lib/std/math.ci:230: (1 byte: <@050480> - <@050481>): result: float64 := 0
	<sum @050480>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@050481> - <@0504a5>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @050481>    : 6a                         i64.2i32
	<sum+2 @050482>    : 04 16 00 00                jmp <sum+24 @050498>
	lib/std/math.ci:232: (14 bytes: <@050486> - <@050494>): float64(result := float64(result + data[i]));
	<sum+6 @050486>    : 11 01                      dup.x64 sp(1)
	<sum+8 @050488>    : 10 06                      dup.x32 sp(6)
	<sum+10 @05048a>   : 10 03                      dup.x32 sp(3)
	<sum+12 @05048c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @050490>   : 23                         load.i64
	<sum+17 @050491>   : 81                         add.f64
	<sum+18 @050492>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@050494> - <@050498>): int32(i := int32(i + 1))
	<sum+20 @050494>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@050498> - <@0504a1>): bool(i < (data.length))
	<sum+24 @050498>   : 10 00                      dup.x32 sp(0)
	<sum+26 @05049a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @05049c>   : 58                         clt.i32
	<sum+29 @05049d>   : 05 e9 ff ff                jnz <sum+6 @050486>
	<sum+33 @0504a1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@0504a5> - <@0504a8>): return float64(.result := result);
	<sum+37 @0504a5>   : 14 05                      set.x64 sp(5)
	<sum+39 @0504a7>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@0504a8>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@0504a8> - <@0504d7>)
	lib/std/math.ci:257: (1 byte: <@0504a8> - <@0504a9>): result: float64 := 0
	<eval @0504a8>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@0504a9> - <@0504d4>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @0504a9>    : 10 04                      dup.x32 sp(4)
	<eval+3 @0504ab>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @0504af>    : 04 19 00 00                jmp <eval+32 @0504c8>
	lib/std/math.ci:259: (17 bytes: <@0504b3> - <@0504c4>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @0504b3>   : 11 01                      dup.x64 sp(1)
	<eval+13 @0504b5>   : 11 08                      dup.x64 sp(8)
	<eval+15 @0504b7>   : 83                         mul.f64
	<eval+16 @0504b8>   : 10 06                      dup.x32 sp(6)
	<eval+18 @0504ba>   : 10 03                      dup.x32 sp(3)
	<eval+20 @0504bc>   : 0d 08 00 00                mad.u32 8
	<eval+24 @0504c0>   : 23                         load.i64
	<eval+25 @0504c1>   : 81                         add.f64
	<eval+26 @0504c2>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:258: (4 bytes: <@0504c4> - <@0504c8>): int32(i := int32(i - 1))
	<eval+28 @0504c4>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@0504c8> - <@0504d0>): bool(i >= 0)
	<eval+32 @0504c8>   : 10 00                      dup.x32 sp(0)
	<eval+34 @0504ca>   : 19                         load.z32
	<eval+35 @0504cb>   : 58                         clt.i32
	<eval+36 @0504cc>   : 06 e7 ff ff                jz <eval+11 @0504b3>
	<eval+40 @0504d0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@0504d4> - <@0504d7>): return float64(.result := result);
	<eval+44 @0504d4>   : 14 07                      set.x64 sp(7)
	<eval+46 @0504d6>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@0504d8>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@0504d8> - <@050511>)
	lib/std/math.ci:266: (53 bytes: <@0504d8> - <@05050d>): if (bool(a < b))
	<cmp @0504d8>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @0504da>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @0504dc>    : 78                         clt.f32
	<cmp+5 @0504dd>    : 06 1c 00 00                jz <cmp+33 @0504f9>
	lib/std/math.ci:267: (20 bytes: <@0504e1> - <@0504f5>): if (bool(eps < (float32(b - a))))
	<cmp+9 @0504e1>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @0504e3>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @0504e5>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @0504e7>   : 72                         sub.f32
	<cmp+16 @0504e8>   : 78                         clt.f32
	<cmp+17 @0504e9>   : 06 0c 00 00                jz <cmp+29 @0504f5>
	lib/std/math.ci:268: (8 bytes: <@0504ed> - <@0504f5>): return int32(.result := int32(-1));
	<cmp+21 @0504ed>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0504f2>   : 13 05                      set.x32 sp(5)
	<cmp+28 @0504f4>   : 03                         ret
	<cmp+29 @0504f5>   : 04 18 00 00                jmp <cmp+53 @05050d>
	lib/std/math.ci:272: (20 bytes: <@0504f9> - <@05050d>): if (bool(eps < (float32(a - b))))
	<cmp+33 @0504f9>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @0504fb>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @0504fd>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @0504ff>   : 72                         sub.f32
	<cmp+40 @050500>   : 78                         clt.f32
	<cmp+41 @050501>   : 06 0c 00 00                jz <cmp+53 @05050d>
	lib/std/math.ci:273: (8 bytes: <@050505> - <@05050d>): return int32(.result := int32(+1));
	<cmp+45 @050505>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05050a>   : 13 05                      set.x32 sp(5)
	<cmp+52 @05050c>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@05050d> - <@050511>): return int32(.result := 0);
	<cmp+53 @05050d>   : 19                         load.z32
	<cmp+54 @05050e>   : 13 05                      set.x32 sp(5)
	<cmp+56 @050510>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@050518>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@050518> - <@050551>)
	lib/std/math.ci:281: (53 bytes: <@050518> - <@05054d>): if (bool(a < b))
	<cmp @050518>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @05051a>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @05051c>    : 88                         clt.f64
	<cmp+5 @05051d>    : 06 1c 00 00                jz <cmp+33 @050539>
	lib/std/math.ci:282: (20 bytes: <@050521> - <@050535>): if (bool(eps < (float64(b - a))))
	<cmp+9 @050521>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @050523>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @050525>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @050527>   : 82                         sub.f64
	<cmp+16 @050528>   : 88                         clt.f64
	<cmp+17 @050529>   : 06 0c 00 00                jz <cmp+29 @050535>
	lib/std/math.ci:283: (8 bytes: <@05052d> - <@050535>): return int32(.result := int32(-1));
	<cmp+21 @05052d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @050532>   : 13 08                      set.x32 sp(8)
	<cmp+28 @050534>   : 03                         ret
	<cmp+29 @050535>   : 04 18 00 00                jmp <cmp+53 @05054d>
	lib/std/math.ci:287: (20 bytes: <@050539> - <@05054d>): if (bool(eps < (float64(a - b))))
	<cmp+33 @050539>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @05053b>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @05053d>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @05053f>   : 82                         sub.f64
	<cmp+40 @050540>   : 88                         clt.f64
	<cmp+41 @050541>   : 06 0c 00 00                jz <cmp+53 @05054d>
	lib/std/math.ci:288: (8 bytes: <@050545> - <@05054d>): return int32(.result := int32(+1));
	<cmp+45 @050545>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05054a>   : 13 08                      set.x32 sp(8)
	<cmp+52 @05054c>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@05054d> - <@050551>): return int32(.result := 0);
	<cmp+53 @05054d>   : 19                         load.z32
	<cmp+54 @05054e>   : 13 08                      set.x32 sp(8)
	<cmp+56 @050550>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@050558>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@050558> - <@0506a7>)
	lib/std/math.ci:309: (2 bytes: <@050558> - <@05055a>): x: float64 := arg
	<sinCos @050558>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:310: (17 bytes: <@05055a> - <@05056b>): if (bool(x < (0)))
	<sinCos+2 @05055a>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @05055c>    : 1a                         load.z64
	<sinCos+5 @05055d>    : 88                         clt.f64
	<sinCos+6 @05055e>    : 06 0d 00 00                jz <sinCos+19 @05056b>
	lib/std/math.ci:311: (1 byte: <@050562> - <@050563>): float64(x := float64(-x));
	<sinCos+10 @050562>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@050563> - <@05056b>): int32(quad := int32(quad + 2));
	<sinCos+11 @050563>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @050565>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @050569>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:315: (1 byte: <@05056b> - <@05056c>): y: float64
	<sinCos+19 @05056b>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@05056c> - <@050584>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @05056c>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @05056e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @050577>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @050580>   : 84                         div.f64
	<sinCos+41 @050581>   : 83                         mul.f64
	<sinCos+42 @050582>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:317: (124 bytes: <@050584> - <@050600>): if (bool(x > (32764)))
	<sinCos+44 @050584>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @050586>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05058f>   : 89                         cgt.f64
	<sinCos+56 @050590>   : 06 54 00 00                jz <sinCos+140 @0505e4>
	lib/std/math.ci:318: (1 byte: <@050594> - <@050595>): e: float64
	<sinCos+60 @050594>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@050595> - <@0505a7>): float64(y := modf(void(x, e)));
	<sinCos+61 @050595>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @050597>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05059b>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @0505a0>   : 02                         call
	<sinCos+73 @0505a1>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @0505a5>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:320: (4 bytes: <@0505a7> - <@0505ab>): float64(e := float64(e + (quad)));
	<sinCos+79 @0505a7>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @0505a9>   : 5d                         i32.2f64
	<sinCos+82 @0505aa>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@0505ab> - <@0505ac>): f: float64
	<sinCos+83 @0505ab>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@0505ac> - <@0505ca>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @0505ac>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @0505b5>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @0505b7>   : 83                         mul.f64
	<sinCos+96 @0505b8>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @0505bc>  : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @0505c1>  : 02                         call
	<sinCos+106 @0505c2>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @0505c6>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@0505ca> - <@0505dc>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @0505ca>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @0505cc>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @0505d5>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @0505d7>  : 83                         mul.f64
	<sinCos+128 @0505d8>  : 82                         sub.f64
	<sinCos+129 @0505d9>  : 8a                         f64.2i32
	<sinCos+130 @0505da>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @0505dc>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @0505e0>  : 04 20 00 00                jmp <sinCos+168 @050600>
	lib/std/math.ci:327: (3 bytes: <@0505e4> - <@0505e7>): k: int32 := x
	<sinCos+140 @0505e4>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @0505e6>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@0505e7> - <@0505ef>): float64(y := float64(x - (k)));
	<sinCos+143 @0505e7>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @0505e9>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @0505eb>  : 5d                         i32.2f64
	<sinCos+148 @0505ec>  : 82                         sub.f64
	<sinCos+149 @0505ed>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:329: (7 bytes: <@0505ef> - <@0505f6>): int32(quad := int32(quad + k));
	<sinCos+151 @0505ef>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @0505f1>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @0505f3>  : 51                         add.i32
	<sinCos+156 @0505f4>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:330: (6 bytes: <@0505f6> - <@0505fc>): int32(quad := int32(quad & 3));
	<sinCos+158 @0505f6>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @0505f8>  : 3f 02                      b32.and 0x003
	<sinCos+162 @0505fa>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @0505fc>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@050600> - <@050616>): if (int32(quad & 1))
	<sinCos+168 @050600>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @050602>  : 3f 01                      b32.and 0x001
	<sinCos+172 @050604>  : 06 12 00 00                jz <sinCos+190 @050616>
	lib/std/math.ci:333: (14 bytes: <@050608> - <@050616>): float64(y := float64((1) - y));
	<sinCos+176 @050608>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @050611>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @050613>  : 82                         sub.f64
	<sinCos+188 @050614>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:335: (13 bytes: <@050616> - <@050623>): if (bool(quad > 1))
	<sinCos+190 @050616>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @050618>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05061d>  : 59                         cgt.i32
	<sinCos+198 @05061e>  : 06 05 00 00                jz <sinCos+203 @050623>
	lib/std/math.ci:336: (1 byte: <@050622> - <@050623>): float64(y := float64(-y));
	<sinCos+202 @050622>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@050623> - <@050628>): ysq: float64 := float64(y * y)
	<sinCos+203 @050623>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @050625>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @050627>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@050628> - <@050668>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @050628>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @050631>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @050633>  : 83                         mul.f64
	<sinCos+220 @050634>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05063d>  : 81                         add.f64
	<sinCos+230 @05063e>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @050640>  : 83                         mul.f64
	<sinCos+233 @050641>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05064a>  : 81                         add.f64
	<sinCos+243 @05064b>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @05064d>  : 83                         mul.f64
	<sinCos+246 @05064e>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @050657>  : 81                         add.f64
	<sinCos+256 @050658>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @05065a>  : 83                         mul.f64
	<sinCos+259 @05065b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @050664>  : 81                         add.f64
	<sinCos+269 @050665>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @050667>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@050668> - <@05069b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @050668>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @05066a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @050673>  : 81                         add.f64
	<sinCos+284 @050674>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @050676>  : 83                         mul.f64
	<sinCos+287 @050677>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @050680>  : 81                         add.f64
	<sinCos+297 @050681>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @050683>  : 83                         mul.f64
	<sinCos+300 @050684>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05068d>  : 81                         add.f64
	<sinCos+310 @05068e>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @050690>  : 83                         mul.f64
	<sinCos+313 @050691>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05069a>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@05069b> - <@0506a7>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @05069b>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @05069d>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @05069f>  : 84                         div.f64
	<sinCos+328 @0506a0>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @0506a2>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @0506a6>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@0506a8>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@0506a8> - <@05081b>)
	lib/std/math.ci:365: (1 byte: <@0506a8> - <@0506a9>): complement: bool := false
	<tan @0506a8>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@0506a9> - <@0506aa>): negate: bool := false
	<tan+1 @0506a9>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@0506aa> - <@0506c1>): if (bool(arg < (0)))
	<tan+2 @0506aa>    : 11 03                      dup.x64 sp(3)
	<tan+4 @0506ac>    : 1a                         load.z64
	<tan+5 @0506ad>    : 88                         clt.f64
	<tan+6 @0506ae>    : 06 13 00 00                jz <tan+25 @0506c1>
	lib/std/math.ci:369: (5 bytes: <@0506b2> - <@0506b7>): float64(arg := float64(-arg));
	<tan+10 @0506b2>   : 11 03                      dup.x64 sp(3)
	<tan+12 @0506b4>   : 80                         neg.f64
	<tan+13 @0506b5>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:370: (10 bytes: <@0506b7> - <@0506c1>): bool(negate := true);
	<tan+15 @0506b7>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @0506bc>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @0506c0>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@0506c1> - <@0506d9>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @0506c1>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @0506ca>   : 11 05                      dup.x64 sp(5)
	<tan+36 @0506cc>   : 83                         mul.f64
	<tan+37 @0506cd>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @0506d6>   : 84                         div.f64
	<tan+47 @0506d7>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:374: (1 byte: <@0506d9> - <@0506da>): e: float64
	<tan+49 @0506d9>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@0506da> - <@0506ea>): x: float64 := modf(void(arg, e))
	<tan+50 @0506da>   : 11 07                      dup.x64 sp(7)
	<tan+52 @0506dc>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @0506e0>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @0506e5>   : 02                         call
	<tan+62 @0506e6>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@0506ea> - <@0506f3>): i: int32 := int32(int32(e) % 4)
	<tan+66 @0506ea>   : 11 02                      dup.x64 sp(2)
	<tan+68 @0506ec>   : 8a                         f64.2i32
	<tan+69 @0506ed>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @0506f2>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@0506f3> - <@05076d>): if (bool(i == 0))
	<tan+75 @0506f3>   : 10 00                      dup.x32 sp(0)
	<tan+77 @0506f5>   : 19                         load.z32
	<tan+78 @0506f6>   : 57                         ceq.i32
	<tan+79 @0506f7>   : 05 76 00 00                jnz <tan+197 @05076d>
	lib/std/math.ci:379: (114 bytes: <@0506fb> - <@05076d>): if (bool(i == 1))
	<tan+83 @0506fb>   : 10 00                      dup.x32 sp(0)
	<tan+85 @0506fd>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @050702>   : 57                         ceq.i32
	<tan+91 @050703>   : 06 20 00 00                jz <tan+123 @050723>
	lib/std/math.ci:380: (14 bytes: <@050707> - <@050715>): float64(x := float64((1) - x));
	<tan+95 @050707>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @050710>  : 11 03                      dup.x64 sp(3)
	<tan+106 @050712>  : 82                         sub.f64
	<tan+107 @050713>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:381: (10 bytes: <@050715> - <@05071f>): bool(complement := true);
	<tan+109 @050715>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05071a>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05071e>  : 25                         store.i8
	<tan+119 @05071f>  : 04 4e 00 00                jmp <tan+197 @05076d>
	lib/std/math.ci:383: (74 bytes: <@050723> - <@05076d>): if (bool(i == 2))
	<tan+123 @050723>  : 10 00                      dup.x32 sp(0)
	<tan+125 @050725>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05072a>  : 57                         ceq.i32
	<tan+131 @05072b>  : 06 1d 00 00                jz <tan+160 @050748>
	lib/std/math.ci:384: (11 bytes: <@05072f> - <@05073a>): bool(negate := bool(!negate));
	<tan+135 @05072f>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @050733>  : 20                         load.i8
	<tan+140 @050734>  : 0b                         not.b32
	<tan+141 @050735>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @050739>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@05073a> - <@050744>): bool(complement := true);
	<tan+146 @05073a>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05073f>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @050743>  : 25                         store.i8
	<tan+156 @050744>  : 04 29 00 00                jmp <tan+197 @05076d>
	lib/std/math.ci:387: (37 bytes: <@050748> - <@05076d>): if (bool(i == 3))
	<tan+160 @050748>  : 10 00                      dup.x32 sp(0)
	<tan+162 @05074a>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05074f>  : 57                         ceq.i32
	<tan+168 @050750>  : 06 1d 00 00                jz <tan+197 @05076d>
	lib/std/math.ci:388: (14 bytes: <@050754> - <@050762>): float64(x := float64((1) - x));
	<tan+172 @050754>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05075d>  : 11 03                      dup.x64 sp(3)
	<tan+183 @05075f>  : 82                         sub.f64
	<tan+184 @050760>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:389: (11 bytes: <@050762> - <@05076d>): bool(negate := bool(!negate));
	<tan+186 @050762>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @050766>  : 20                         load.i8
	<tan+191 @050767>  : 0b                         not.b32
	<tan+192 @050768>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05076c>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@05076d> - <@050772>): xsq: float64 := float64(x * x)
	<tan+197 @05076d>  : 11 01                      dup.x64 sp(1)
	<tan+199 @05076f>  : 11 03                      dup.x64 sp(3)
	<tan+201 @050771>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@050772> - <@0507b2>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @050772>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05077b>  : 11 02                      dup.x64 sp(2)
	<tan+213 @05077d>  : 83                         mul.f64
	<tan+214 @05077e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @050787>  : 81                         add.f64
	<tan+224 @050788>  : 11 02                      dup.x64 sp(2)
	<tan+226 @05078a>  : 83                         mul.f64
	<tan+227 @05078b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @050794>  : 81                         add.f64
	<tan+237 @050795>  : 11 02                      dup.x64 sp(2)
	<tan+239 @050797>  : 83                         mul.f64
	<tan+240 @050798>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @0507a1>  : 81                         add.f64
	<tan+250 @0507a2>  : 11 02                      dup.x64 sp(2)
	<tan+252 @0507a4>  : 83                         mul.f64
	<tan+253 @0507a5>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @0507ae>  : 81                         add.f64
	<tan+263 @0507af>  : 11 05                      dup.x64 sp(5)
	<tan+265 @0507b1>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@0507b2> - <@0507d9>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @0507b2>  : 11 02                      dup.x64 sp(2)
	<tan+268 @0507b4>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @0507bd>  : 81                         add.f64
	<tan+278 @0507be>  : 11 04                      dup.x64 sp(4)
	<tan+280 @0507c0>  : 83                         mul.f64
	<tan+281 @0507c1>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @0507ca>  : 81                         add.f64
	<tan+291 @0507cb>  : 11 04                      dup.x64 sp(4)
	<tan+293 @0507cd>  : 83                         mul.f64
	<tan+294 @0507ce>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @0507d7>  : 81                         add.f64
	<tan+304 @0507d8>  : 84                         div.f64
	lib/std/math.ci:396: (40 bytes: <@0507d9> - <@050801>): if (complement)
	<tan+305 @0507d9>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @0507dd>  : 20                         load.i8
	<tan+310 @0507de>  : 06 23 00 00                jz <tan+345 @050801>
	lib/std/math.ci:397: (17 bytes: <@0507e2> - <@0507f3>): if (bool(result == (0)))
	<tan+314 @0507e2>  : 11 00                      dup.x64 sp(0)
	<tan+316 @0507e4>  : 1a                         load.z64
	<tan+317 @0507e5>  : 87                         ceq.f64
	<tan+318 @0507e6>  : 06 0d 00 00                jz <tan+331 @0507f3>
	lib/std/math.ci:398: (9 bytes: <@0507ea> - <@0507f3>): return float64(.result := nan);
	<tan+322 @0507ea>  : 1b                         load.z128
	<tan+323 @0507eb>  : 84                         div.f64
	<tan+324 @0507ec>  : 14 10                      set.x64 sp(16)
	<tan+326 @0507ee>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @0507f2>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@0507f3> - <@050801>): float64(result := float64((1) / result));
	<tan+331 @0507f3>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @0507fc>  : 11 02                      dup.x64 sp(2)
	<tan+342 @0507fe>  : 84                         div.f64
	<tan+343 @0507ff>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:402: (19 bytes: <@050801> - <@050814>): if (negate)
	<tan+345 @050801>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @050805>  : 20                         load.i8
	<tan+350 @050806>  : 06 0e 00 00                jz <tan+364 @050814>
	lib/std/math.ci:403: (10 bytes: <@05080a> - <@050814>): return float64(.result := float64(-result));
	<tan+354 @05080a>  : 11 00                      dup.x64 sp(0)
	<tan+356 @05080c>  : 80                         neg.f64
	<tan+357 @05080d>  : 14 10                      set.x64 sp(16)
	<tan+359 @05080f>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @050813>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@050814> - <@05081b>): return float64(.result := result);
	<tan+364 @050814>  : 14 0e                      set.x64 sp(14)
	<tan+366 @050816>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @05081a>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@050820>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@050820> - <@050911>)
	lib/std/math.ci:421: (1 byte: <@050820> - <@050821>): negate: bool := false
	<sinh @050820>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@050821> - <@050838>): if (bool(x < (0)))
	<sinh+1 @050821>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @050823>    : 1a                         load.z64
	<sinh+4 @050824>    : 88                         clt.f64
	<sinh+5 @050825>    : 06 13 00 00                jz <sinh+24 @050838>
	lib/std/math.ci:423: (5 bytes: <@050829> - <@05082e>): float64(x := float64(-x));
	<sinh+9 @050829>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @05082b>   : 80                         neg.f64
	<sinh+12 @05082c>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:424: (10 bytes: <@05082e> - <@050838>): bool(negate := true);
	<sinh+14 @05082e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @050833>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @050837>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@050838> - <@05085f>): if (bool(x > (21)))
	<sinh+24 @050838>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @05083a>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @050843>   : 89                         cgt.f64
	<sinh+36 @050844>   : 06 1b 00 00                jz <sinh+63 @05085f>
	lib/std/math.ci:428: (23 bytes: <@050848> - <@05085f>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @050848>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @05084a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @05084e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @050857>   : 84                         div.f64
	<sinh+56 @050858>   : 14 06                      set.x64 sp(6)
	<sinh+58 @05085a>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @05085e>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@05085f> - <@050860>): result: float64
	<sinh+63 @05085f>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@050860> - <@0508f7>): if (bool(x > 0.500000))
	<sinh+64 @050860>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @050862>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @05086b>   : 89                         cgt.f64
	<sinh+76 @05086c>   : 06 22 00 00                jz <sinh+110 @05088e>
	lib/std/math.ci:433: (26 bytes: <@050870> - <@05088a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @050870>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @050872>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @050876>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @050878>   : 80                         neg.f64
	<sinh+89 @050879>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @05087d>   : 82                         sub.f64
	<sinh+94 @05087e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @050887>  : 84                         div.f64
	<sinh+104 @050888>  : 14 02                      set.x64 sp(2)
	<sinh+106 @05088a>  : 04 6d 00 00                jmp <sinh+215 @0508f7>
	lib/std/math.ci:436: (5 bytes: <@05088e> - <@050893>): sq: float64 := float64(x * x)
	<sinh+110 @05088e>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @050890>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @050892>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@050893> - <@0508c8>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @050893>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05089c>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @05089e>  : 83                         mul.f64
	<sinh+127 @05089f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @0508a8>  : 81                         add.f64
	<sinh+137 @0508a9>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @0508ab>  : 83                         mul.f64
	<sinh+140 @0508ac>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @0508b5>  : 81                         add.f64
	<sinh+150 @0508b6>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @0508b8>  : 83                         mul.f64
	<sinh+153 @0508b9>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @0508c2>  : 81                         add.f64
	<sinh+163 @0508c3>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @0508c5>  : 83                         mul.f64
	<sinh+166 @0508c6>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:438: (43 bytes: <@0508c8> - <@0508f3>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @0508c8>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @0508ca>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @0508cc>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @0508d5>  : 81                         add.f64
	<sinh+182 @0508d6>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @0508d8>  : 83                         mul.f64
	<sinh+185 @0508d9>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @0508e2>  : 81                         add.f64
	<sinh+195 @0508e3>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @0508e5>  : 83                         mul.f64
	<sinh+198 @0508e6>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @0508ef>  : 81                         add.f64
	<sinh+208 @0508f0>  : 84                         div.f64
	<sinh+209 @0508f1>  : 14 04                      set.x64 sp(4)
	<sinh+211 @0508f3>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@0508f7> - <@05090a>): if (negate)
	<sinh+215 @0508f7>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @0508fb>  : 20                         load.i8
	<sinh+220 @0508fc>  : 06 0e 00 00                jz <sinh+234 @05090a>
	lib/std/math.ci:442: (10 bytes: <@050900> - <@05090a>): return float64(.result := float64(-result));
	<sinh+224 @050900>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @050902>  : 80                         neg.f64
	<sinh+227 @050903>  : 14 08                      set.x64 sp(8)
	<sinh+229 @050905>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @050909>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@05090a> - <@050911>): return float64(.result := result);
	<sinh+234 @05090a>  : 14 06                      set.x64 sp(6)
	<sinh+236 @05090c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @050910>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@050918>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@050918> - <@050963>)
	lib/std/math.ci:449: (13 bytes: <@050918> - <@050925>): if (bool(x < (0)))
	<cosh @050918>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @05091a>    : 1a                         load.z64
	<cosh+3 @05091b>    : 88                         clt.f64
	<cosh+4 @05091c>    : 06 09 00 00                jz <cosh+13 @050925>
	lib/std/math.ci:450: (5 bytes: <@050920> - <@050925>): float64(x := float64(-x));
	<cosh+8 @050920>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @050922>   : 80                         neg.f64
	<cosh+11 @050923>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:452: (35 bytes: <@050925> - <@050948>): if (bool(x > (21)))
	<cosh+13 @050925>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @050927>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @050930>   : 89                         cgt.f64
	<cosh+25 @050931>   : 06 17 00 00                jz <cosh+48 @050948>
	lib/std/math.ci:453: (19 bytes: <@050935> - <@050948>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @050935>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @050937>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @05093b>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @050944>   : 84                         div.f64
	<cosh+45 @050945>   : 14 05                      set.x64 sp(5)
	<cosh+47 @050947>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@050948> - <@050963>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @050948>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @05094a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @05094e>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @050950>   : 80                         neg.f64
	<cosh+57 @050951>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @050955>   : 81                         add.f64
	<cosh+62 @050956>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @05095f>   : 84                         div.f64
	<cosh+72 @050960>   : 14 05                      set.x64 sp(5)
	<cosh+74 @050962>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@050968>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@050968> - <@050a0e>)
	lib/std/math.ci:464: (12 bytes: <@050968> - <@050974>): if (bool(x == (0)))
	<asin @050968>      : 11 01                      dup.x64 sp(1)
	<asin+2 @05096a>    : 1a                         load.z64
	<asin+3 @05096b>    : 87                         ceq.f64
	<asin+4 @05096c>    : 06 08 00 00                jz <asin+12 @050974>
	lib/std/math.ci:466: (4 bytes: <@050970> - <@050974>): return float64(.result := x);
	<asin+8 @050970>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @050973>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@050974> - <@050975>): negate: bool := false
	<asin+12 @050974>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@050975> - <@05098c>): if (bool(x < (0)))
	<asin+13 @050975>   : 11 02                      dup.x64 sp(2)
	<asin+15 @050977>   : 1a                         load.z64
	<asin+16 @050978>   : 88                         clt.f64
	<asin+17 @050979>   : 06 13 00 00                jz <asin+36 @05098c>
	lib/std/math.ci:471: (10 bytes: <@05097d> - <@050987>): bool(negate := true);
	<asin+21 @05097d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @050982>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @050986>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@050987> - <@05098c>): float64(x := float64(-x));
	<asin+31 @050987>   : 11 02                      dup.x64 sp(2)
	<asin+33 @050989>   : 80                         neg.f64
	<asin+34 @05098a>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:475: (25 bytes: <@05098c> - <@0509a5>): if (bool(x > (1)))
	<asin+36 @05098c>   : 11 02                      dup.x64 sp(2)
	<asin+38 @05098e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @050997>   : 89                         cgt.f64
	<asin+48 @050998>   : 06 0d 00 00                jz <asin+61 @0509a5>
	lib/std/math.ci:477: (9 bytes: <@05099c> - <@0509a5>): return float64(.result := nan);
	<asin+52 @05099c>   : 1b                         load.z128
	<asin+53 @05099d>   : 84                         div.f64
	<asin+54 @05099e>   : 14 06                      set.x64 sp(6)
	<asin+56 @0509a0>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @0509a4>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@0509a5> - <@0509b8>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @0509a5>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @0509ae>   : 11 04                      dup.x64 sp(4)
	<asin+72 @0509b0>   : 11 06                      dup.x64 sp(6)
	<asin+74 @0509b2>   : 83                         mul.f64
	<asin+75 @0509b3>   : 82                         sub.f64
	<asin+76 @0509b4>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@0509b8> - <@0509f4>): if (bool(x > 0.700000))
	<asin+80 @0509b8>   : 11 04                      dup.x64 sp(4)
	<asin+82 @0509ba>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @0509c3>   : 89                         cgt.f64
	<asin+92 @0509c4>   : 06 26 00 00                jz <asin+130 @0509ea>
	lib/std/math.ci:482: (30 bytes: <@0509c8> - <@0509e6>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @0509c8>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @0509d1>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @0509da>  : 84                         div.f64
	<asin+115 @0509db>  : 11 02                      dup.x64 sp(2)
	<asin+117 @0509dd>  : 11 08                      dup.x64 sp(8)
	<asin+119 @0509df>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @0509e3>  : 82                         sub.f64
	<asin+124 @0509e4>  : 14 02                      set.x64 sp(2)
	<asin+126 @0509e6>  : 04 0e 00 00                jmp <asin+140 @0509f4>
	lib/std/math.ci:485: (10 bytes: <@0509ea> - <@0509f4>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @0509ea>  : 11 04                      dup.x64 sp(4)
	<asin+132 @0509ec>  : 11 02                      dup.x64 sp(2)
	<asin+134 @0509ee>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @0509f2>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:488: (19 bytes: <@0509f4> - <@050a07>): if (negate)
	<asin+140 @0509f4>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @0509f8>  : 20                         load.i8
	<asin+145 @0509f9>  : 06 0e 00 00                jz <asin+159 @050a07>
	lib/std/math.ci:489: (10 bytes: <@0509fd> - <@050a07>): return float64(.result := float64(-result));
	<asin+149 @0509fd>  : 11 00                      dup.x64 sp(0)
	<asin+151 @0509ff>  : 80                         neg.f64
	<asin+152 @050a00>  : 14 08                      set.x64 sp(8)
	<asin+154 @050a02>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @050a06>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@050a07> - <@050a0e>): return float64(.result := result);
	<asin+159 @050a07>  : 14 06                      set.x64 sp(6)
	<asin+161 @050a09>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @050a0d>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@019b78>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050a10>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@050a10> - <@050a17>)
	lib/std/math.Complex.ci:25: (7 bytes: <@050a10> - <@050a17>): return void(.result := {...});
	<Complex @050a10>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@050a13> - <@050a16>): void(.result.im := (0))
	<Complex+3 @050a13>    : 1a                         load.z64
	<Complex+4 @050a14>    : 14 07                      set.x64 sp(7)
	<Complex+6 @050a16>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050a18>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@050a18> - <@050a1f>)
	lib/std/math.Complex.ci:32: (7 bytes: <@050a18> - <@050a1f>): return void(.result := {...});
	<Complex @050a18>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@050a1b> - <@050a1e>): void(.result.im := im);
	<Complex+3 @050a1b>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @050a1e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@050a20>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@050a20> - <@050a9b>)
	lib/std/math.Complex.ci:87: (79 bytes: <@050a20> - <@050a6f>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @050a20>      : 1a                         load.z64
	<div+1 @050a21>    : 11 03                      dup.x64 sp(3)
	<div+3 @050a23>    : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<div+8 @050a28>    : 02                         call
	<div+9 @050a29>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @050a2d>   : 1a                         load.z64
	<div+14 @050a2e>   : 11 07                      dup.x64 sp(7)
	<div+16 @050a30>   : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<div+21 @050a35>   : 02                         call
	<div+22 @050a36>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @050a3a>   : 88                         clt.f64
	<div+27 @050a3b>   : 05 34 00 00                jnz <div+79 @050a6f>
	lib/std/math.Complex.ci:88: (5 bytes: <@050a3f> - <@050a44>): r: float64 := float64(b.im / b.re)
	<div+31 @050a3f>   : 11 03                      dup.x64 sp(3)
	<div+33 @050a41>   : 11 03                      dup.x64 sp(3)
	<div+35 @050a43>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@050a44> - <@050a4c>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @050a44>   : 11 03                      dup.x64 sp(3)
	<div+38 @050a46>   : 11 02                      dup.x64 sp(2)
	<div+40 @050a48>   : 11 09                      dup.x64 sp(9)
	<div+42 @050a4a>   : 83                         mul.f64
	<div+43 @050a4b>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@050a4c> - <@050a6b>): return void(.result := {...});
	<div+44 @050a4c>   : 11 09                      dup.x64 sp(9)
	<div+46 @050a4e>   : 11 04                      dup.x64 sp(4)
	<div+48 @050a50>   : 11 0f                      dup.x64 sp(15)
	<div+50 @050a52>   : 83                         mul.f64
	<div+51 @050a53>   : 81                         add.f64
	<div+52 @050a54>   : 11 02                      dup.x64 sp(2)
	<div+54 @050a56>   : 84                         div.f64
	<div+55 @050a57>   : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@050a59> - <@050a66>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @050a59>   : 11 0b                      dup.x64 sp(11)
	<div+59 @050a5b>   : 11 04                      dup.x64 sp(4)
	<div+61 @050a5d>   : 11 0d                      dup.x64 sp(13)
	<div+63 @050a5f>   : 83                         mul.f64
	<div+64 @050a60>   : 82                         sub.f64
	<div+65 @050a61>   : 11 02                      dup.x64 sp(2)
	<div+67 @050a63>   : 84                         div.f64
	<div+68 @050a64>   : 14 11                      set.x64 sp(17)
	<div+70 @050a66>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @050a6a>   : 03                         ret
	<div+75 @050a6b>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@050a6f> - <@050a74>): r: float64 := float64(b.re / b.im)
	<div+79 @050a6f>   : 11 01                      dup.x64 sp(1)
	<div+81 @050a71>   : 11 05                      dup.x64 sp(5)
	<div+83 @050a73>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@050a74> - <@050a7c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @050a74>   : 11 05                      dup.x64 sp(5)
	<div+86 @050a76>   : 11 02                      dup.x64 sp(2)
	<div+88 @050a78>   : 11 07                      dup.x64 sp(7)
	<div+90 @050a7a>   : 83                         mul.f64
	<div+91 @050a7b>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@050a7c> - <@050a9b>): return void(.result := {...});
	<div+92 @050a7c>   : 11 09                      dup.x64 sp(9)
	<div+94 @050a7e>   : 11 04                      dup.x64 sp(4)
	<div+96 @050a80>   : 83                         mul.f64
	<div+97 @050a81>   : 11 0d                      dup.x64 sp(13)
	<div+99 @050a83>   : 81                         add.f64
	<div+100 @050a84>  : 11 02                      dup.x64 sp(2)
	<div+102 @050a86>  : 84                         div.f64
	<div+103 @050a87>  : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@050a89> - <@050a96>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @050a89>  : 11 0b                      dup.x64 sp(11)
	<div+107 @050a8b>  : 11 04                      dup.x64 sp(4)
	<div+109 @050a8d>  : 83                         mul.f64
	<div+110 @050a8e>  : 11 0b                      dup.x64 sp(11)
	<div+112 @050a90>  : 82                         sub.f64
	<div+113 @050a91>  : 11 02                      dup.x64 sp(2)
	<div+115 @050a93>  : 84                         div.f64
	<div+116 @050a94>  : 14 11                      set.x64 sp(17)
	<div+118 @050a96>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @050a9a>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@050aa0>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@050aa0> - <@050abf>)
	lib/std/math.Complex.ci:115: (11 bytes: <@050aa0> - <@050aab>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @050aa0>      : 11 01                      dup.x64 sp(1)
	<inv+2 @050aa2>    : 11 03                      dup.x64 sp(3)
	<inv+4 @050aa4>    : 83                         mul.f64
	<inv+5 @050aa5>    : 11 05                      dup.x64 sp(5)
	<inv+7 @050aa7>    : 11 07                      dup.x64 sp(7)
	<inv+9 @050aa9>    : 83                         mul.f64
	<inv+10 @050aaa>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@050aab> - <@050abf>): return void(.result := {...});
	<inv+11 @050aab>   : 11 03                      dup.x64 sp(3)
	<inv+13 @050aad>   : 11 02                      dup.x64 sp(2)
	<inv+15 @050aaf>   : 84                         div.f64
	<inv+16 @050ab0>   : 14 09                      set.x64 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@050ab2> - <@050aba>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @050ab2>   : 11 05                      dup.x64 sp(5)
	<inv+20 @050ab4>   : 80                         neg.f64
	<inv+21 @050ab5>   : 11 02                      dup.x64 sp(2)
	<inv+23 @050ab7>   : 84                         div.f64
	<inv+24 @050ab8>   : 14 0b                      set.x64 sp(11)
	<inv+26 @050aba>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @050abe>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@050ac0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@050ac0> - <@050b24>)
	lib/std/math.Complex.ci:133: (23 bytes: <@050ac0> - <@050ad7>): r: float64 := abs(a)
	<pow @050ac0>      : 12 05                      dup.x128 sp(5)
	<pow+2 @050ac2>    : 11 00                      dup.x64 sp(0)
	<pow+4 @050ac4>    : 11 02                      dup.x64 sp(2)
	<pow+6 @050ac6>    : 83                         mul.f64
	<pow+7 @050ac7>    : 11 04                      dup.x64 sp(4)
	<pow+9 @050ac9>    : 11 06                      dup.x64 sp(6)
	<pow+11 @050acb>   : 83                         mul.f64
	<pow+12 @050acc>   : 81                         add.f64
	<pow+13 @050acd>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @050ad1>   : 14 04                      set.x64 sp(4)
	<pow+19 @050ad3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@050ad7> - <@050ae7>): t: float64 := arg(a)
	<pow+23 @050ad7>   : 12 07                      dup.x128 sp(7)
	<pow+25 @050ad9>   : 11 00                      dup.x64 sp(0)
	<pow+27 @050adb>   : 11 04                      dup.x64 sp(4)
	<pow+29 @050add>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @050ae1>   : 14 04                      set.x64 sp(4)
	<pow+35 @050ae3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@050ae7> - <@050af6>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @050ae7>   : 11 05                      dup.x64 sp(5)
	<pow+41 @050ae9>   : 11 02                      dup.x64 sp(2)
	<pow+43 @050aeb>   : 83                         mul.f64
	<pow+44 @050aec>   : 11 09                      dup.x64 sp(9)
	<pow+46 @050aee>   : 11 06                      dup.x64 sp(6)
	<pow+48 @050af0>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @050af4>   : 83                         mul.f64
	<pow+53 @050af5>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@050af6> - <@050b09>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @050af6>   : 11 04                      dup.x64 sp(4)
	<pow+56 @050af8>   : 11 09                      dup.x64 sp(9)
	<pow+58 @050afa>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @050afe>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @050b00>   : 80                         neg.f64
	<pow+65 @050b01>   : 11 06                      dup.x64 sp(6)
	<pow+67 @050b03>   : 83                         mul.f64
	<pow+68 @050b04>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @050b08>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@050b09> - <@050b24>): return void(.result := {...});
	<pow+73 @050b09>   : 11 00                      dup.x64 sp(0)
	<pow+75 @050b0b>   : 11 04                      dup.x64 sp(4)
	<pow+77 @050b0d>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @050b11>   : 83                         mul.f64
	<pow+82 @050b12>   : 14 13                      set.x64 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@050b14> - <@050b1f>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @050b14>   : 11 00                      dup.x64 sp(0)
	<pow+86 @050b16>   : 11 04                      dup.x64 sp(4)
	<pow+88 @050b18>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @050b1c>   : 83                         mul.f64
	<pow+93 @050b1d>   : 14 15                      set.x64 sp(21)
	<pow+95 @050b1f>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @050b23>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@050b28>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@050b28> - <@050b4e>)
	lib/std/string.ci:5: (16 bytes: <@050b28> - <@050b38>): if (bool((str) == null))
	<length @050b28>      : 10 01                      dup.x32 sp(1)
	<length+2 @050b2a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @050b2f>    : 57                         ceq.i32
	<length+8 @050b30>    : 06 08 00 00                jz <length+16 @050b38>
	lib/std/string.ci:6: (4 bytes: <@050b34> - <@050b38>): return int32(.result := 0);
	<length+12 @050b34>   : 19                         load.z32
	<length+13 @050b35>   : 13 03                      set.x32 sp(3)
	<length+15 @050b37>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@050b38> - <@050b39>): result: int32 := 0
	<length+16 @050b38>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@050b39> - <@050b4b>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @050b39>   : 04 08 00 00                jmp <length+25 @050b41>
	lib/std/string.ci:9: (4 bytes: <@050b3d> - <@050b41>): int32(result := int32(result + 1))
	<length+21 @050b3d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@050b41> - <@050b4b>): str[result]
	<length+25 @050b41>   : 10 02                      dup.x32 sp(2)
	<length+27 @050b43>   : 10 01                      dup.x32 sp(1)
	<length+29 @050b45>   : 51                         add.i32
	<length+30 @050b46>   : 20                         load.i8
	<length+31 @050b47>   : 05 f6 ff ff                jnz <length+21 @050b3d>
	lib/std/string.ci:11: (3 bytes: <@050b4b> - <@050b4e>): return int32(.result := result);
	<length+35 @050b4b>   : 13 03                      set.x32 sp(3)
	<length+37 @050b4d>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050b50>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@050b50> - <@050b82>)
	lib/std/string.ci:16: (42 bytes: <@050b50> - <@050b7a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @050b50>      : 19                         load.z32
	<indexOf+1 @050b51>    : 04 1b 00 00                jmp <indexOf+28 @050b6c>
	lib/std/string.ci:17: (19 bytes: <@050b55> - <@050b68>): if (bool(str[i] == chr))
	<indexOf+5 @050b55>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @050b57>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @050b59>    : 51                         add.i32
	<indexOf+10 @050b5a>   : 20                         load.i8
	<indexOf+11 @050b5b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @050b5f>   : 20                         load.i8
	<indexOf+16 @050b60>   : 57                         ceq.i32
	<indexOf+17 @050b61>   : 06 07 00 00                jz <indexOf+24 @050b68>
	lib/std/string.ci:18: (3 bytes: <@050b65> - <@050b68>): return int32(.result := i);
	<indexOf+21 @050b65>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @050b67>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@050b68> - <@050b6c>): int32(i := int32(i + 1))
	<indexOf+24 @050b68>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@050b6c> - <@050b76>): str[i]
	<indexOf+28 @050b6c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @050b6e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @050b70>   : 51                         add.i32
	<indexOf+33 @050b71>   : 20                         load.i8
	<indexOf+34 @050b72>   : 05 e3 ff ff                jnz <indexOf+5 @050b55>
	<indexOf+38 @050b76>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@050b7a> - <@050b82>): return int32(.result := int32(-1));
	<indexOf+42 @050b7a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @050b7f>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @050b81>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050b88>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@050b88> - <@050bba>)
	lib/std/string.ci:26: (5 bytes: <@050b88> - <@050b8d>): result: int32 := int32(-1)
	<lastIndexOf @050b88>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@050b8d> - <@050bb7>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @050b8d>    : 19                         load.z32
	<lastIndexOf+6 @050b8e>    : 04 1b 00 00                jmp <lastIndexOf+33 @050ba9>
	lib/std/string.ci:28: (19 bytes: <@050b92> - <@050ba5>): if (bool(str[i] == chr))
	<lastIndexOf+10 @050b92>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @050b94>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @050b96>   : 51                         add.i32
	<lastIndexOf+15 @050b97>   : 20                         load.i8
	<lastIndexOf+16 @050b98>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @050b9c>   : 20                         load.i8
	<lastIndexOf+21 @050b9d>   : 57                         ceq.i32
	<lastIndexOf+22 @050b9e>   : 06 07 00 00                jz <lastIndexOf+29 @050ba5>
	lib/std/string.ci:29: (3 bytes: <@050ba2> - <@050ba5>): int32(result := i);
	<lastIndexOf+26 @050ba2>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@050ba5> - <@050ba9>): int32(i := int32(i + 1))
	<lastIndexOf+29 @050ba5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@050ba9> - <@050bb3>): str[i]
	<lastIndexOf+33 @050ba9>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @050bab>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @050bad>   : 51                         add.i32
	<lastIndexOf+38 @050bae>   : 20                         load.i8
	<lastIndexOf+39 @050baf>   : 05 e3 ff ff                jnz <lastIndexOf+10 @050b92>
	<lastIndexOf+43 @050bb3>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@050bb7> - <@050bba>): return int32(.result := result);
	<lastIndexOf+47 @050bb7>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @050bb9>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@050bc0>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@050bc0> - <@050c09>)
	lib/std/string.ci:37: (62 bytes: <@050bc0> - <@050bfe>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @050bc0>      : 19                         load.z32
	<startsWith+1 @050bc1>    : 04 2d 00 00                jmp <startsWith+46 @050bee>
	lib/std/string.ci:38: (37 bytes: <@050bc5> - <@050bea>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @050bc5>    : 19                         load.z32
	<startsWith+6 @050bc6>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @050bc8>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @050bca>   : 51                         add.i32
	<startsWith+11 @050bcb>   : 20                         load.i8
	<startsWith+12 @050bcc>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @050bce>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @050bd0>   : 51                         add.i32
	<startsWith+17 @050bd1>   : 20                         load.i8
	<startsWith+18 @050bd2>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @050bd4>   : 02                         call
	<startsWith+21 @050bd5>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @050bd9>   : 19                         load.z32
	<startsWith+26 @050bda>   : 57                         ceq.i32
	<startsWith+27 @050bdb>   : 05 0f 00 00                jnz <startsWith+42 @050bea>
	lib/std/string.ci:39: (11 bytes: <@050bdf> - <@050bea>): return bool(.result := false);
	<startsWith+31 @050bdf>   : 19                         load.z32
	<startsWith+32 @050be0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @050be4>   : 25                         store.i8
	<startsWith+37 @050be5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @050be9>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@050bea> - <@050bee>): int32(i := int32(i + 1))
	<startsWith+42 @050bea>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@050bee> - <@050bfa>): bool((with[i]) != 0)
	<startsWith+46 @050bee>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @050bf0>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @050bf2>   : 51                         add.i32
	<startsWith+51 @050bf3>   : 20                         load.i8
	<startsWith+52 @050bf4>   : 19                         load.z32
	<startsWith+53 @050bf5>   : 57                         ceq.i32
	<startsWith+54 @050bf6>   : 06 cf ff ff                jz <startsWith+5 @050bc5>
	<startsWith+58 @050bfa>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@050bfe> - <@050c09>): return bool(.result := true);
	<startsWith+62 @050bfe>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @050c03>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @050c07>   : 25                         store.i8
	<startsWith+72 @050c08>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@050c10>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@050c10> - <@050c8e>)
	lib/std/string.ci:47: (13 bytes: <@050c10> - <@050c1d>): withLen: int32 := length(with)
	<endsWith @050c10>      : 19                         load.z32
	<endsWith+1 @050c11>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @050c13>    : 1f 28 0b 05 00             load.ref <@050b28> ;length(str: char[*]): int32
	<endsWith+8 @050c18>    : 02                         call
	<endsWith+9 @050c19>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@050c1d> - <@050c2a>): strLen: int32 := length(str)
	<endsWith+13 @050c1d>   : 19                         load.z32
	<endsWith+14 @050c1e>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @050c20>   : 1f 28 0b 05 00             load.ref <@050b28> ;length(str: char[*]): int32
	<endsWith+21 @050c25>   : 02                         call
	<endsWith+22 @050c26>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@050c2a> - <@050c3e>): if (bool(strLen < withLen))
	<endsWith+26 @050c2a>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @050c2c>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @050c2e>   : 58                         clt.i32
	<endsWith+31 @050c2f>   : 06 0f 00 00                jz <endsWith+46 @050c3e>
	lib/std/string.ci:50: (11 bytes: <@050c33> - <@050c3e>): return bool(.result := false);
	<endsWith+35 @050c33>   : 19                         load.z32
	<endsWith+36 @050c34>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @050c38>   : 25                         store.i8
	<endsWith+41 @050c39>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @050c3d>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@050c3e> - <@050c7f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @050c3e>   : 19                         load.z32
	<endsWith+47 @050c3f>   : 04 33 00 00                jmp <endsWith+98 @050c72>
	lib/std/string.ci:53: (43 bytes: <@050c43> - <@050c6e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @050c43>   : 19                         load.z32
	<endsWith+52 @050c44>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @050c46>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @050c48>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @050c4a>   : 52                         sub.i32
	<endsWith+59 @050c4b>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @050c4d>   : 51                         add.i32
	<endsWith+62 @050c4e>   : 51                         add.i32
	<endsWith+63 @050c4f>   : 20                         load.i8
	<endsWith+64 @050c50>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @050c52>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @050c54>   : 51                         add.i32
	<endsWith+69 @050c55>   : 20                         load.i8
	<endsWith+70 @050c56>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @050c58>   : 02                         call
	<endsWith+73 @050c59>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @050c5d>   : 19                         load.z32
	<endsWith+78 @050c5e>   : 57                         ceq.i32
	<endsWith+79 @050c5f>   : 05 0f 00 00                jnz <endsWith+94 @050c6e>
	lib/std/string.ci:54: (11 bytes: <@050c63> - <@050c6e>): return bool(.result := false);
	<endsWith+83 @050c63>   : 19                         load.z32
	<endsWith+84 @050c64>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @050c68>   : 25                         store.i8
	<endsWith+89 @050c69>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @050c6d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@050c6e> - <@050c72>): int32(i := int32(i + 1))
	<endsWith+94 @050c6e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@050c72> - <@050c7b>): bool(i < withLen)
	<endsWith+98 @050c72>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @050c74>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @050c76>  : 58                         clt.i32
	<endsWith+103 @050c77>  : 05 cc ff ff                jnz <endsWith+51 @050c43>
	<endsWith+107 @050c7b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@050c7f> - <@050c8e>): return bool(.result := true);
	<endsWith+111 @050c7f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @050c84>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @050c88>  : 25                         store.i8
	<endsWith+121 @050c89>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @050c8d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@050c90>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@050c90> - <@050ccf>)
	lib/std/string.ci:62: (1 byte: <@050c90> - <@050c91>): result: int32 := 0
	<compare @050c90>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@050c91> - <@050ccc>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @050c91>    : 19                         load.z32
	<compare+2 @050c92>    : 04 2e 00 00                jmp <compare+48 @050cc0>
	lib/std/string.ci:64: (22 bytes: <@050c96> - <@050cac>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @050c96>    : 19                         load.z32
	<compare+7 @050c97>    : 10 06                      dup.x32 sp(6)
	<compare+9 @050c99>    : 10 02                      dup.x32 sp(2)
	<compare+11 @050c9b>   : 51                         add.i32
	<compare+12 @050c9c>   : 20                         load.i8
	<compare+13 @050c9d>   : 10 06                      dup.x32 sp(6)
	<compare+15 @050c9f>   : 10 03                      dup.x32 sp(3)
	<compare+17 @050ca1>   : 51                         add.i32
	<compare+18 @050ca2>   : 20                         load.i8
	<compare+19 @050ca3>   : 10 06                      dup.x32 sp(6)
	<compare+21 @050ca5>   : 02                         call
	<compare+22 @050ca6>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @050caa>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@050cac> - <@050cbc>): if (bool((str[i]) == 0))
	<compare+28 @050cac>   : 10 05                      dup.x32 sp(5)
	<compare+30 @050cae>   : 10 01                      dup.x32 sp(1)
	<compare+32 @050cb0>   : 51                         add.i32
	<compare+33 @050cb1>   : 20                         load.i8
	<compare+34 @050cb2>   : 19                         load.z32
	<compare+35 @050cb3>   : 57                         ceq.i32
	<compare+36 @050cb4>   : 06 08 00 00                jz <compare+44 @050cbc>
	lib/std/string.ci:66: (4 bytes: <@050cb8> - <@050cbc>): break;
	<compare+40 @050cb8>   : 04 10 00 00                jmp <compare+56 @050cc8>
	lib/std/string.ci:63: (4 bytes: <@050cbc> - <@050cc0>): int32(i := int32(i + 1))
	<compare+44 @050cbc>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@050cc0> - <@050cc8>): bool(result == 0)
	<compare+48 @050cc0>   : 10 01                      dup.x32 sp(1)
	<compare+50 @050cc2>   : 19                         load.z32
	<compare+51 @050cc3>   : 57                         ceq.i32
	<compare+52 @050cc4>   : 05 d2 ff ff                jnz <compare+6 @050c96>
	<compare+56 @050cc8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@050ccc> - <@050ccf>): return int32(.result := result);
	<compare+60 @050ccc>   : 13 05                      set.x32 sp(5)
	<compare+62 @050cce>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@050d18>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@050d18> - <@050d3c>)
	lib/std/string.ci:84: (36 bytes: <@050d18> - <@050d3c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @050d18>      : 19                         load.z32
	<ignCaseCmp+1 @050d19>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @050d1d>    : 20                         load.i8
	<ignCaseCmp+6 @050d1e>    : 1f d0 0c 05 00             load.ref <@050cd0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @050d23>   : 02                         call
	<ignCaseCmp+12 @050d24>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @050d28>   : 19                         load.z32
	<ignCaseCmp+17 @050d29>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @050d2d>   : 20                         load.i8
	<ignCaseCmp+22 @050d2e>   : 1f d0 0c 05 00             load.ref <@050cd0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @050d33>   : 02                         call
	<ignCaseCmp+28 @050d34>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @050d38>   : 52                         sub.i32
	<ignCaseCmp+33 @050d39>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @050d3b>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@050d40>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@050d40> - <@050d4e>)
	lib/std/string.ci:89: (14 bytes: <@050d40> - <@050d4e>): return char(.result := char(chr - with));
	<caseCmp @050d40>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @050d44>    : 20                         load.i8
	<caseCmp+5 @050d45>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @050d49>    : 20                         load.i8
	<caseCmp+10 @050d4a>   : 52                         sub.i32
	<caseCmp+11 @050d4b>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @050d4d>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0225a0>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@050d50>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@050d50> - <@050da4>)
	lib/std/string.ci:127: (56 bytes: <@050d50> - <@050d88>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @050d50>      : 19                         load.z32
	<append+1 @050d51>    : 04 29 00 00                jmp <append+42 @050d7a>
	lib/std/string.ci:128: (13 bytes: <@050d55> - <@050d62>): if (bool(pos >= (output.length)))
	<append+5 @050d55>    : 10 03                      dup.x32 sp(3)
	<append+7 @050d57>    : 10 06                      dup.x32 sp(6)
	<append+9 @050d59>    : 58                         clt.i32
	<append+10 @050d5a>   : 05 08 00 00                jnz <append+18 @050d62>
	lib/std/string.ci:129: (4 bytes: <@050d5e> - <@050d62>): break;
	<append+14 @050d5e>   : 04 26 00 00                jmp <append+52 @050d84>
	lib/std/string.ci:131: (12 bytes: <@050d62> - <@050d6e>): char(output[pos] := value[i]);
	<append+18 @050d62>   : 10 02                      dup.x32 sp(2)
	<append+20 @050d64>   : 10 01                      dup.x32 sp(1)
	<append+22 @050d66>   : 51                         add.i32
	<append+23 @050d67>   : 20                         load.i8
	<append+24 @050d68>   : 10 05                      dup.x32 sp(5)
	<append+26 @050d6a>   : 10 05                      dup.x32 sp(5)
	<append+28 @050d6c>   : 51                         add.i32
	<append+29 @050d6d>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@050d6e> - <@050d76>): int32(pos := int32(pos + 1));
	<append+30 @050d6e>   : 10 03                      dup.x32 sp(3)
	<append+32 @050d70>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @050d74>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:127: (4 bytes: <@050d76> - <@050d7a>): int32(i := int32(i + 1))
	<append+38 @050d76>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@050d7a> - <@050d84>): value[i]
	<append+42 @050d7a>   : 10 02                      dup.x32 sp(2)
	<append+44 @050d7c>   : 10 01                      dup.x32 sp(1)
	<append+46 @050d7e>   : 51                         add.i32
	<append+47 @050d7f>   : 20                         load.i8
	<append+48 @050d80>   : 05 d5 ff ff                jnz <append+5 @050d55>
	<append+52 @050d84>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@050d88> - <@050d99>): if (bool(pos >= (output.length)))
	<append+56 @050d88>   : 10 02                      dup.x32 sp(2)
	<append+58 @050d8a>   : 10 05                      dup.x32 sp(5)
	<append+60 @050d8c>   : 58                         clt.i32
	<append+61 @050d8d>   : 05 0c 00 00                jnz <append+73 @050d99>
	lib/std/string.ci:136: (8 bytes: <@050d91> - <@050d99>): int32(pos := (uint32(output.length - (1))));
	<append+65 @050d91>   : 10 04                      dup.x32 sp(4)
	<append+67 @050d93>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @050d97>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:138: (7 bytes: <@050d99> - <@050da0>): char(output[pos] := (0));
	<append+73 @050d99>   : 19                         load.z32
	<append+74 @050d9a>   : 10 04                      dup.x32 sp(4)
	<append+76 @050d9c>   : 10 04                      dup.x32 sp(4)
	<append+78 @050d9e>   : 51                         add.i32
	<append+79 @050d9f>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@050da0> - <@050da4>): return int32(.result := pos);
	<append+80 @050da0>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @050da3>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@050db8>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@050db8> - <@051049>)
	lib/std/string.ci:147: (1 byte: <@050db8> - <@050db9>): len: int32 := 0
	<append @050db8>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@050db9> - <@050dbd>): digits: char[80]
	<append+1 @050db9>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@050dbd> - <@050dc0>): radix: int32 := format.radix
	<append+5 @050dbd>    : 10 16                      dup.x32 sp(22)
	<append+7 @050dbf>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@050dc0> - <@050df6>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @050dc0>    : 10 00                      dup.x32 sp(0)
	<append+10 @050dc2>   : 1c 01 00 00 00             load.c32 1
	<append+15 @050dc7>   : 59                         cgt.i32
	<append+16 @050dc8>   : 06 08 00 00                jz <append+24 @050dd0>
	<append+20 @050dcc>   : 04 2a 00 00                jmp <append+62 @050df6>
	<append+24 @050dd0>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+29 @050dd5>   : 1c 97 00 00 00             load.c32 151
	<append+34 @050dda>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @050ddf>   : 1c 80 00 00 00             load.c32 128
	<append+44 @050de4>   : 1f fa f0 01 00             load.ref <@01f0fa> ;"radix is too small"
	<append+49 @050de9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @050dee>   : 0a 18 00 00                load.sp(+24)
	<append+58 @050df2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@050df6> - <@050e2b>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @050df6>   : 10 00                      dup.x32 sp(0)
	<append+64 @050df8>   : 2a b4 0d 05                load.m32 <@050db4> ;append.radixDigits+4
	<append+68 @050dfc>   : 58                         clt.i32
	<append+69 @050dfd>   : 06 08 00 00                jz <append+77 @050e05>
	<append+73 @050e01>   : 04 2a 00 00                jmp <append+115 @050e2b>
	<append+77 @050e05>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+82 @050e0a>   : 1c 98 00 00 00             load.c32 152
	<append+87 @050e0f>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @050e14>   : 1c 80 00 00 00             load.c32 128
	<append+97 @050e19>   : 1f 0d f1 01 00             load.ref <@01f10d> ;"radix is too big"
	<append+102 @050e1e>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @050e23>  : 0a 18 00 00                load.sp(+24)
	<append+111 @050e27>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@050e2b> - <@050e59>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @050e2b>  : 04 26 00 00                jmp <append+153 @050e51>
	lib/std/string.ci:156: (27 bytes: <@050e2f> - <@050e4a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @050e2f>  : 2a b0 0d 05                load.m32 <@050db0> ;append.radixDigits
	<append+123 @050e33>  : 10 19                      dup.x32 sp(25)
	<append+125 @050e35>  : 10 02                      dup.x32 sp(2)
	<append+127 @050e37>  : 35                         mod.u32
	<append+128 @050e38>  : 51                         add.i32
	<append+129 @050e39>  : 20                         load.i8
	<append+130 @050e3a>  : 0a 08 00 00                load.sp(+8)
	<append+134 @050e3e>  : 10 17                      dup.x32 sp(23)
	<append+136 @050e40>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @050e44>  : 10 00                      dup.x32 sp(0)
	<append+142 @050e46>  : 13 19                      set.x32 sp(25)
	<append+144 @050e48>  : 51                         add.i32
	<append+145 @050e49>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@050e4a> - <@050e51>): uint32(value := uint32(value / (radix)))
	<append+146 @050e4a>  : 10 18                      dup.x32 sp(24)
	<append+148 @050e4c>  : 10 01                      dup.x32 sp(1)
	<append+150 @050e4e>  : 34                         div.u32
	<append+151 @050e4f>  : 13 19                      set.x32 sp(25)
	lib/std/string.ci:155: (8 bytes: <@050e51> - <@050e59>): bool(value > (0))
	<append+153 @050e51>  : 10 18                      dup.x32 sp(24)
	<append+155 @050e53>  : 19                         load.z32
	<append+156 @050e54>  : 39                         cgt.u32
	<append+157 @050e55>  : 05 da ff ff                jnz <append+119 @050e2f>
	lib/std/string.ci:158: (29 bytes: <@050e59> - <@050e76>): if (bool(len == 0))
	<append+161 @050e59>  : 10 15                      dup.x32 sp(21)
	<append+163 @050e5b>  : 19                         load.z32
	<append+164 @050e5c>  : 57                         ceq.i32
	<append+165 @050e5d>  : 06 19 00 00                jz <append+190 @050e76>
	lib/std/string.ci:159: (21 bytes: <@050e61> - <@050e76>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @050e61>  : 1c 30 00 00 00             load.c32 48
	<append+174 @050e66>  : 0a 08 00 00                load.sp(+8)
	<append+178 @050e6a>  : 10 17                      dup.x32 sp(23)
	<append+180 @050e6c>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @050e70>  : 10 00                      dup.x32 sp(0)
	<append+186 @050e72>  : 13 19                      set.x32 sp(25)
	<append+188 @050e74>  : 51                         add.i32
	<append+189 @050e75>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@050e76> - <@050e80>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @050e76>  : 10 17                      dup.x32 sp(23)
	<append+192 @050e78>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @050e7c>  : 22                         load.i32
	<append+197 @050e7d>  : 10 16                      dup.x32 sp(22)
	<append+199 @050e7f>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@050e80> - <@050e87>): padChr: char := format.padChr
	<append+200 @050e80>  : 10 18                      dup.x32 sp(24)
	<append+202 @050e82>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @050e86>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@050e87> - <@050e9c>): if (bool(padChr == ''))
	<append+207 @050e87>  : 0a 00 00 00                load.sp(+0)
	<append+211 @050e8b>  : 20                         load.i8
	<append+212 @050e8c>  : 19                         load.z32
	<append+213 @050e8d>  : 57                         ceq.i32
	<append+214 @050e8e>  : 06 0e 00 00                jz <append+228 @050e9c>
	lib/std/string.ci:166: (10 bytes: <@050e92> - <@050e9c>): char(padChr := ' ');
	<append+218 @050e92>  : 1c 20 00 00 00             load.c32 32
	<append+223 @050e97>  : 0a 04 00 00                load.sp(+4)
	<append+227 @050e9b>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@050e9c> - <@050f6b>): if (bool((sign) != 0))
	<append+228 @050e9c>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @050ea0>  : 20                         load.i8
	<append+233 @050ea1>  : 19                         load.z32
	<append+234 @050ea2>  : 57                         ceq.i32
	<append+235 @050ea3>  : 05 c8 00 00                jnz <append+435 @050f6b>
	lib/std/string.ci:171: (8 bytes: <@050ea7> - <@050eaf>): int32(maxLen := int32(maxLen - 1));
	<append+239 @050ea7>  : 10 01                      dup.x32 sp(1)
	<append+241 @050ea9>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @050ead>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:172: (117 bytes: <@050eaf> - <@050f24>): if (contains(void(whiteSpace, padChr)))
	<append+247 @050eaf>  : 19                         load.z32
	<append+248 @050eb0>  : 2a a8 0d 05                load.m32 <@050da8> ;append.whiteSpace
	<append+252 @050eb4>  : 0a 08 00 00                load.sp(+8)
	<append+256 @050eb8>  : 20                         load.i8
	<append+257 @050eb9>  : 1f 50 0b 05 00             load.ref <@050b50> ;indexOf(str: char[*], chr: char): int32
	<append+262 @050ebe>  : 02                         call
	<append+263 @050ebf>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @050ec3>  : 19                         load.z32
	<append+268 @050ec4>  : 58                         clt.i32
	<append+269 @050ec5>  : 05 5f 00 00                jnz <append+364 @050f24>
	lib/std/string.ci:174: (91 bytes: <@050ec9> - <@050f24>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @050ec9>  : 04 53 00 00                jmp <append+356 @050f1c>
	lib/std/string.ci:175: (52 bytes: <@050ecd> - <@050f01>): assert(bool(pos < (output.length)));
	<append+277 @050ecd>  : 10 1c                      dup.x32 sp(28)
	<append+279 @050ecf>  : 10 1f                      dup.x32 sp(31)
	<append+281 @050ed1>  : 58                         clt.i32
	<append+282 @050ed2>  : 06 08 00 00                jz <append+290 @050eda>
	<append+286 @050ed6>  : 04 2b 00 00                jmp <append+329 @050f01>
	<append+290 @050eda>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+295 @050edf>  : 1c af 00 00 00             load.c32 175
	<append+300 @050ee4>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @050ee9>  : 1c 80 00 00 00             load.c32 128
	<append+310 @050eee>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+315 @050ef3>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @050ef8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @050efd>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@050f01> - <@050f0c>): char(output[pos] := padChr);
	<append+329 @050f01>  : 0a 00 00 00                load.sp(+0)
	<append+333 @050f05>  : 20                         load.i8
	<append+334 @050f06>  : 10 1e                      dup.x32 sp(30)
	<append+336 @050f08>  : 10 1e                      dup.x32 sp(30)
	<append+338 @050f0a>  : 51                         add.i32
	<append+339 @050f0b>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@050f0c> - <@050f14>): int32(pos := int32(pos + 1));
	<append+340 @050f0c>  : 10 1c                      dup.x32 sp(28)
	<append+342 @050f0e>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @050f12>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:174: (8 bytes: <@050f14> - <@050f1c>): int32(maxLen := int32(maxLen - 1))
	<append+348 @050f14>  : 10 01                      dup.x32 sp(1)
	<append+350 @050f16>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @050f1a>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:174: (8 bytes: <@050f1c> - <@050f24>): bool(maxLen > 0)
	<append+356 @050f1c>  : 10 01                      dup.x32 sp(1)
	<append+358 @050f1e>  : 19                         load.z32
	<append+359 @050f1f>  : 59                         cgt.i32
	<append+360 @050f20>  : 05 ad ff ff                jnz <append+277 @050ecd>
	lib/std/string.ci:180: (52 bytes: <@050f24> - <@050f58>): assert(bool(pos < (output.length)));
	<append+364 @050f24>  : 10 1c                      dup.x32 sp(28)
	<append+366 @050f26>  : 10 1f                      dup.x32 sp(31)
	<append+368 @050f28>  : 58                         clt.i32
	<append+369 @050f29>  : 06 08 00 00                jz <append+377 @050f31>
	<append+373 @050f2d>  : 04 2b 00 00                jmp <append+416 @050f58>
	<append+377 @050f31>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+382 @050f36>  : 1c b4 00 00 00             load.c32 180
	<append+387 @050f3b>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @050f40>  : 1c 80 00 00 00             load.c32 128
	<append+397 @050f45>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+402 @050f4a>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @050f4f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @050f54>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@050f58> - <@050f63>): char(output[pos] := sign);
	<append+416 @050f58>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @050f5c>  : 20                         load.i8
	<append+421 @050f5d>  : 10 1e                      dup.x32 sp(30)
	<append+423 @050f5f>  : 10 1e                      dup.x32 sp(30)
	<append+425 @050f61>  : 51                         add.i32
	<append+426 @050f62>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@050f63> - <@050f6b>): int32(pos := int32(pos + 1));
	<append+427 @050f63>  : 10 1c                      dup.x32 sp(28)
	<append+429 @050f65>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @050f69>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (91 bytes: <@050f6b> - <@050fc6>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @050f6b>  : 04 53 00 00                jmp <append+518 @050fbe>
	lib/std/string.ci:187: (52 bytes: <@050f6f> - <@050fa3>): assert(bool(pos < (output.length)));
	<append+439 @050f6f>  : 10 1c                      dup.x32 sp(28)
	<append+441 @050f71>  : 10 1f                      dup.x32 sp(31)
	<append+443 @050f73>  : 58                         clt.i32
	<append+444 @050f74>  : 06 08 00 00                jz <append+452 @050f7c>
	<append+448 @050f78>  : 04 2b 00 00                jmp <append+491 @050fa3>
	<append+452 @050f7c>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+457 @050f81>  : 1c bb 00 00 00             load.c32 187
	<append+462 @050f86>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @050f8b>  : 1c 80 00 00 00             load.c32 128
	<append+472 @050f90>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+477 @050f95>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @050f9a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @050f9f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@050fa3> - <@050fae>): char(output[pos] := padChr);
	<append+491 @050fa3>  : 0a 00 00 00                load.sp(+0)
	<append+495 @050fa7>  : 20                         load.i8
	<append+496 @050fa8>  : 10 1e                      dup.x32 sp(30)
	<append+498 @050faa>  : 10 1e                      dup.x32 sp(30)
	<append+500 @050fac>  : 51                         add.i32
	<append+501 @050fad>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@050fae> - <@050fb6>): int32(pos := int32(pos + 1));
	<append+502 @050fae>  : 10 1c                      dup.x32 sp(28)
	<append+504 @050fb0>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @050fb4>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (8 bytes: <@050fb6> - <@050fbe>): int32(maxLen := int32(maxLen - 1))
	<append+510 @050fb6>  : 10 01                      dup.x32 sp(1)
	<append+512 @050fb8>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @050fbc>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:186: (8 bytes: <@050fbe> - <@050fc6>): bool(maxLen > 0)
	<append+518 @050fbe>  : 10 01                      dup.x32 sp(1)
	<append+520 @050fc0>  : 19                         load.z32
	<append+521 @050fc1>  : 59                         cgt.i32
	<append+522 @050fc2>  : 05 ad ff ff                jnz <append+439 @050f6f>
	lib/std/string.ci:193: (99 bytes: <@050fc6> - <@051029>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @050fc6>  : 19                         load.z32
	<append+527 @050fc7>  : 04 55 00 00                jmp <append+612 @05101c>
	lib/std/string.ci:194: (52 bytes: <@050fcb> - <@050fff>): assert(bool(i < (output.length)));
	<append+531 @050fcb>  : 10 00                      dup.x32 sp(0)
	<append+533 @050fcd>  : 10 20                      dup.x32 sp(32)
	<append+535 @050fcf>  : 58                         clt.i32
	<append+536 @050fd0>  : 06 08 00 00                jz <append+544 @050fd8>
	<append+540 @050fd4>  : 04 2b 00 00                jmp <append+583 @050fff>
	<append+544 @050fd8>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+549 @050fdd>  : 1c c2 00 00 00             load.c32 194
	<append+554 @050fe2>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @050fe7>  : 1c 80 00 00 00             load.c32 128
	<append+564 @050fec>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+569 @050ff1>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @050ff6>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @050ffb>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@050fff> - <@051010>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @050fff>  : 0a 10 00 00                load.sp(+16)
	<append+587 @051003>  : 10 19                      dup.x32 sp(25)
	<append+589 @051005>  : 10 02                      dup.x32 sp(2)
	<append+591 @051007>  : 52                         sub.i32
	<append+592 @051008>  : 51                         add.i32
	<append+593 @051009>  : 20                         load.i8
	<append+594 @05100a>  : 10 1f                      dup.x32 sp(31)
	<append+596 @05100c>  : 10 1f                      dup.x32 sp(31)
	<append+598 @05100e>  : 51                         add.i32
	<append+599 @05100f>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@051010> - <@051018>): int32(pos := int32(pos + 1));
	<append+600 @051010>  : 10 1d                      dup.x32 sp(29)
	<append+602 @051012>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @051016>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:193: (4 bytes: <@051018> - <@05101c>): int32(i := int32(i + 1))
	<append+608 @051018>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@05101c> - <@051025>): bool(i < len)
	<append+612 @05101c>  : 10 00                      dup.x32 sp(0)
	<append+614 @05101e>  : 10 19                      dup.x32 sp(25)
	<append+616 @051020>  : 58                         clt.i32
	<append+617 @051021>  : 05 aa ff ff                jnz <append+531 @050fcb>
	<append+621 @051025>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@051029> - <@05103a>): if (bool(pos >= (output.length)))
	<append+625 @051029>  : 10 1c                      dup.x32 sp(28)
	<append+627 @05102b>  : 10 1f                      dup.x32 sp(31)
	<append+629 @05102d>  : 58                         clt.i32
	<append+630 @05102e>  : 05 0c 00 00                jnz <append+642 @05103a>
	lib/std/string.ci:200: (8 bytes: <@051032> - <@05103a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @051032>  : 10 1e                      dup.x32 sp(30)
	<append+636 @051034>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @051038>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:202: (7 bytes: <@05103a> - <@051041>): char(output[pos] := (0));
	<append+642 @05103a>  : 19                         load.z32
	<append+643 @05103b>  : 10 1e                      dup.x32 sp(30)
	<append+645 @05103d>  : 10 1e                      dup.x32 sp(30)
	<append+647 @05103f>  : 51                         add.i32
	<append+648 @051040>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@051041> - <@051049>): return int32(.result := pos);
	<append+649 @051041>  : 16 1f 1c                   mov.x32 sp(31, 28)
	<append+652 @051044>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @051048>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@051050>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@051050> - <@051067>)
	lib/std/string.ci:208: (23 bytes: <@051050> - <@051067>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @051050>      : 19                         load.z32
	<append+1 @051051>    : 11 05                      dup.x64 sp(5)
	<append+3 @051053>    : 10 06                      dup.x32 sp(6)
	<append+5 @051055>    : 19                         load.z32
	<append+6 @051056>    : 10 07                      dup.x32 sp(7)
	<append+8 @051058>    : 10 07                      dup.x32 sp(7)
	<append+10 @05105a>   : 1f b8 0d 05 00             load.ref <@050db8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @05105f>   : 02                         call
	<append+16 @051060>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @051064>   : 13 07                      set.x32 sp(7)
	<append+22 @051066>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@051068>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@051068> - <@051099>)
	lib/std/string.ci:213: (1 byte: <@051068> - <@051069>): sign: int32 := 0
	<append @051068>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@051069> - <@05107d>): if (bool(value < 0))
	<append+1 @051069>    : 10 03                      dup.x32 sp(3)
	<append+3 @05106b>    : 19                         load.z32
	<append+4 @05106c>    : 58                         clt.i32
	<append+5 @05106d>    : 06 10 00 00                jz <append+21 @05107d>
	lib/std/string.ci:215: (7 bytes: <@051071> - <@051078>): int32(sign := ('-'));
	<append+9 @051071>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @051076>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:216: (5 bytes: <@051078> - <@05107d>): int32(value := int32(-value));
	<append+16 @051078>   : 10 03                      dup.x32 sp(3)
	<append+18 @05107a>   : 50                         neg.i32
	<append+19 @05107b>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:218: (28 bytes: <@05107d> - <@051099>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @05107d>   : 19                         load.z32
	<append+22 @05107e>   : 11 06                      dup.x64 sp(6)
	<append+24 @051080>   : 10 07                      dup.x32 sp(7)
	<append+26 @051082>   : 10 04                      dup.x32 sp(4)
	<append+28 @051084>   : 10 08                      dup.x32 sp(8)
	<append+30 @051086>   : 10 08                      dup.x32 sp(8)
	<append+32 @051088>   : 1f b8 0d 05 00             load.ref <@050db8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @05108d>   : 02                         call
	<append+38 @05108e>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @051092>   : 13 08                      set.x32 sp(8)
	<append+44 @051094>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @051098>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@0510b0>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@0510b0> - <@0510c9>)
	lib/std/string.ci:224: (25 bytes: <@0510b0> - <@0510c9>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @0510b0>      : 19                         load.z32
	<append+1 @0510b1>    : 11 04                      dup.x64 sp(4)
	<append+3 @0510b3>    : 10 05                      dup.x32 sp(5)
	<append+5 @0510b5>    : 10 05                      dup.x32 sp(5)
	<append+7 @0510b7>    : 1f a0 10 05 00             load.ref <@0510a0> ;append.format
	<append+12 @0510bc>   : 1f 50 10 05 00             load.ref <@051050> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @0510c1>   : 02                         call
	<append+18 @0510c2>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @0510c6>   : 13 06                      set.x32 sp(6)
	<append+24 @0510c8>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024730>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0510d0>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@0510d0> - <@0510d7>)
	lib/vec/vec2d.ci:17: (7 bytes: <@0510d0> - <@0510d7>): return void(.result := {...});
	<vec2d @0510d0>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@0510d3> - <@0510d6>): void(.result.y := y);
	<vec2d+3 @0510d3>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @0510d6>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0256e8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0510d8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@0510d8> - <@0510e5>)
	lib/vec/vec4f.ci:29: (13 bytes: <@0510d8> - <@0510e5>): return void(.result := {...});
	<vec4f @0510d8>      : 16 05 04                   mov.x32 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510db> - <@0510de>): void(.result.y := y);
	<vec4f+3 @0510db>    : 16 06 03                   mov.x32 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510de> - <@0510e1>): void(.result.z := z);
	<vec4f+6 @0510de>    : 16 07 02                   mov.x32 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510e1> - <@0510e4>): void(.result.w := w);
	<vec4f+9 @0510e1>    : 16 08 01                   mov.x32 sp(8, 1)
	<vec4f+12 @0510e4>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with given x, y, z components, and w with 0'
.value: vec4f(void(void(void(x, y), z), 0.000000))
.usages:
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(len(v))))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@028ac8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0510e8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@0510e8> - <@051119>)
	lib/vec/mat4f.ci:31: (49 bytes: <@0510e8> - <@051119>): return void(.result := {...});
	<mat4f @0510e8>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510eb> - <@0510ee>): void(.result.x.y := xy);
	<mat4f+3 @0510eb>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510ee> - <@0510f1>): void(.result.x.z := xz);
	<mat4f+6 @0510ee>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510f1> - <@0510f4>): void(.result.x.w := xw);
	<mat4f+9 @0510f1>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510f4> - <@0510f7>): void(.result.y.x := yx);
	<mat4f+12 @0510f4>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510f7> - <@0510fa>): void(.result.y.y := yy);
	<mat4f+15 @0510f7>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510fa> - <@0510fd>): void(.result.y.z := yz);
	<mat4f+18 @0510fa>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510fd> - <@051100>): void(.result.y.w := yw);
	<mat4f+21 @0510fd>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes: <@051100> - <@051103>): void(.result.z.x := zx);
	<mat4f+24 @051100>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes: <@051103> - <@051106>): void(.result.z.y := zy);
	<mat4f+27 @051103>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes: <@051106> - <@051109>): void(.result.z.z := zz);
	<mat4f+30 @051106>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes: <@051109> - <@05110c>): void(.result.z.w := zw);
	<mat4f+33 @051109>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes: <@05110c> - <@05110f>): void(.result.w.x := wx);
	<mat4f+36 @05110c>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes: <@05110f> - <@051112>): void(.result.w.y := wy);
	<mat4f+39 @05110f>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes: <@051112> - <@051115>): void(.result.w.z := wz);
	<mat4f+42 @051112>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes: <@051115> - <@051118>): void(.result.w.w := ww);
	<mat4f+45 @051115>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @051118>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@051120>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@051120> - <@051135>)
	lib/vec/mat4f.ci:41: (21 bytes: <@051120> - <@051135>): return void(.result := {...});
	<mat4f @051120>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @051122>    : 24                         load.i128
	<mat4f+3 @051123>    : 15 09                      set.x128 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes: <@051125> - <@05112a>): void(.result.y := y);
	<mat4f+5 @051125>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @051127>    : 24                         load.i128
	<mat4f+8 @051128>    : 15 0d                      set.x128 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes: <@05112a> - <@05112f>): void(.result.z := z);
	<mat4f+10 @05112a>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @05112c>   : 24                         load.i128
	<mat4f+13 @05112d>   : 15 11                      set.x128 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes: <@05112f> - <@051134>): void(.result.w := w);
	<mat4f+15 @05112f>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @051131>   : 24                         load.i128
	<mat4f+18 @051132>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @051134>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@051138>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@051138> - <@0512d9>)
	lib/vec/mat4f.ci:53: (144 bytes: <@051138> - <@0511c8>): transposed: mat4f := {...}
	<mul @051138>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes: <@05113c> - <@051141>): void(transposed.x.x := rhs.x.x);
	<mul+4 @05113c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @05113e>    : 22                         load.i32
	<mul+7 @05113f>    : 13 01                      set.x32 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes: <@051141> - <@05114a>): void(transposed.x.y := rhs.y.x);
	<mul+9 @051141>    : 10 11                      dup.x32 sp(17)
	<mul+11 @051143>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @051147>   : 22                         load.i32
	<mul+16 @051148>   : 13 02                      set.x32 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes: <@05114a> - <@051153>): void(transposed.x.z := rhs.z.x);
	<mul+18 @05114a>   : 10 11                      dup.x32 sp(17)
	<mul+20 @05114c>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @051150>   : 22                         load.i32
	<mul+25 @051151>   : 13 03                      set.x32 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes: <@051153> - <@05115c>): void(transposed.x.w := rhs.w.x);
	<mul+27 @051153>   : 10 11                      dup.x32 sp(17)
	<mul+29 @051155>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @051159>   : 22                         load.i32
	<mul+34 @05115a>   : 13 04                      set.x32 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes: <@05115c> - <@051165>): void(transposed.y.x := rhs.x.y);
	<mul+36 @05115c>   : 10 11                      dup.x32 sp(17)
	<mul+38 @05115e>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @051162>   : 22                         load.i32
	<mul+43 @051163>   : 13 05                      set.x32 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes: <@051165> - <@05116e>): void(transposed.y.y := rhs.y.y);
	<mul+45 @051165>   : 10 11                      dup.x32 sp(17)
	<mul+47 @051167>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @05116b>   : 22                         load.i32
	<mul+52 @05116c>   : 13 06                      set.x32 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes: <@05116e> - <@051177>): void(transposed.y.z := rhs.z.y);
	<mul+54 @05116e>   : 10 11                      dup.x32 sp(17)
	<mul+56 @051170>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @051174>   : 22                         load.i32
	<mul+61 @051175>   : 13 07                      set.x32 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes: <@051177> - <@051180>): void(transposed.y.w := rhs.w.y);
	<mul+63 @051177>   : 10 11                      dup.x32 sp(17)
	<mul+65 @051179>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @05117d>   : 22                         load.i32
	<mul+70 @05117e>   : 13 08                      set.x32 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes: <@051180> - <@051189>): void(transposed.z.x := rhs.x.z);
	<mul+72 @051180>   : 10 11                      dup.x32 sp(17)
	<mul+74 @051182>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @051186>   : 22                         load.i32
	<mul+79 @051187>   : 13 09                      set.x32 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes: <@051189> - <@051192>): void(transposed.z.y := rhs.y.z);
	<mul+81 @051189>   : 10 11                      dup.x32 sp(17)
	<mul+83 @05118b>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @05118f>   : 22                         load.i32
	<mul+88 @051190>   : 13 0a                      set.x32 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes: <@051192> - <@05119b>): void(transposed.z.z := rhs.z.z);
	<mul+90 @051192>   : 10 11                      dup.x32 sp(17)
	<mul+92 @051194>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @051198>   : 22                         load.i32
	<mul+97 @051199>   : 13 0b                      set.x32 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes: <@05119b> - <@0511a4>): void(transposed.z.w := rhs.w.z);
	<mul+99 @05119b>   : 10 11                      dup.x32 sp(17)
	<mul+101 @05119d>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @0511a1>  : 22                         load.i32
	<mul+106 @0511a2>  : 13 0c                      set.x32 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511a4> - <@0511ad>): void(transposed.w.x := rhs.x.w);
	<mul+108 @0511a4>  : 10 11                      dup.x32 sp(17)
	<mul+110 @0511a6>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @0511aa>  : 22                         load.i32
	<mul+115 @0511ab>  : 13 0d                      set.x32 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511ad> - <@0511b6>): void(transposed.w.y := rhs.y.w);
	<mul+117 @0511ad>  : 10 11                      dup.x32 sp(17)
	<mul+119 @0511af>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @0511b3>  : 22                         load.i32
	<mul+124 @0511b4>  : 13 0e                      set.x32 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511b6> - <@0511bf>): void(transposed.w.z := rhs.z.w);
	<mul+126 @0511b6>  : 10 11                      dup.x32 sp(17)
	<mul+128 @0511b8>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @0511bc>  : 22                         load.i32
	<mul+133 @0511bd>  : 13 0f                      set.x32 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511bf> - <@0511c8>): void(transposed.w.w := rhs.w.w);
	<mul+135 @0511bf>  : 10 11                      dup.x32 sp(17)
	<mul+137 @0511c1>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @0511c5>  : 22                         load.i32
	<mul+142 @0511c6>  : 13 10                      set.x32 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes: <@0511c8> - <@0512d9>): return void(.result := {...});
	<mul+144 @0511c8>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @0511cc>  : 10 13                      dup.x32 sp(19)
	<mul+150 @0511ce>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @0511d2>  : 10 04                      dup.x32 sp(4)
	<mul+156 @0511d4>  : 24                         load.i128
	<mul+157 @0511d5>  : 10 09                      dup.x32 sp(9)
	<mul+159 @0511d7>  : 24                         load.i128
	<mul+160 @0511d8>  : 9b                         dp4.v4f
	<mul+161 @0511d9>  : 10 05                      dup.x32 sp(5)
	<mul+163 @0511db>  : 24                         load.i128
	<mul+164 @0511dc>  : 10 0a                      dup.x32 sp(10)
	<mul+166 @0511de>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @0511e2>  : 24                         load.i128
	<mul+171 @0511e3>  : 9b                         dp4.v4f
	<mul+172 @0511e4>  : 10 06                      dup.x32 sp(6)
	<mul+174 @0511e6>  : 24                         load.i128
	<mul+175 @0511e7>  : 10 0b                      dup.x32 sp(11)
	<mul+177 @0511e9>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @0511ed>  : 24                         load.i128
	<mul+182 @0511ee>  : 9b                         dp4.v4f
	<mul+183 @0511ef>  : 10 07                      dup.x32 sp(7)
	<mul+185 @0511f1>  : 24                         load.i128
	<mul+186 @0511f2>  : 10 0c                      dup.x32 sp(12)
	<mul+188 @0511f4>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @0511f8>  : 24                         load.i128
	<mul+193 @0511f9>  : 9b                         dp4.v4f
	<mul+194 @0511fa>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @0511ff>  : 02                         call
	<mul+200 @051200>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @051204>  : 15 02                      set.x128 sp(2)
	<mul+206 @051206>  : 15 17                      set.x128 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes: <@051208> - <@05124c>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @051208>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @05120c>  : 10 13                      dup.x32 sp(19)
	<mul+214 @05120e>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @051212>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @051216>  : 10 04                      dup.x32 sp(4)
	<mul+224 @051218>  : 24                         load.i128
	<mul+225 @051219>  : 10 09                      dup.x32 sp(9)
	<mul+227 @05121b>  : 24                         load.i128
	<mul+228 @05121c>  : 9b                         dp4.v4f
	<mul+229 @05121d>  : 10 05                      dup.x32 sp(5)
	<mul+231 @05121f>  : 24                         load.i128
	<mul+232 @051220>  : 10 0a                      dup.x32 sp(10)
	<mul+234 @051222>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @051226>  : 24                         load.i128
	<mul+239 @051227>  : 9b                         dp4.v4f
	<mul+240 @051228>  : 10 06                      dup.x32 sp(6)
	<mul+242 @05122a>  : 24                         load.i128
	<mul+243 @05122b>  : 10 0b                      dup.x32 sp(11)
	<mul+245 @05122d>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @051231>  : 24                         load.i128
	<mul+250 @051232>  : 9b                         dp4.v4f
	<mul+251 @051233>  : 10 07                      dup.x32 sp(7)
	<mul+253 @051235>  : 24                         load.i128
	<mul+254 @051236>  : 10 0c                      dup.x32 sp(12)
	<mul+256 @051238>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @05123c>  : 24                         load.i128
	<mul+261 @05123d>  : 9b                         dp4.v4f
	<mul+262 @05123e>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @051243>  : 02                         call
	<mul+268 @051244>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @051248>  : 15 02                      set.x128 sp(2)
	<mul+274 @05124a>  : 15 1b                      set.x128 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes: <@05124c> - <@051290>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @05124c>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @051250>  : 10 13                      dup.x32 sp(19)
	<mul+282 @051252>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @051256>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @05125a>  : 10 04                      dup.x32 sp(4)
	<mul+292 @05125c>  : 24                         load.i128
	<mul+293 @05125d>  : 10 09                      dup.x32 sp(9)
	<mul+295 @05125f>  : 24                         load.i128
	<mul+296 @051260>  : 9b                         dp4.v4f
	<mul+297 @051261>  : 10 05                      dup.x32 sp(5)
	<mul+299 @051263>  : 24                         load.i128
	<mul+300 @051264>  : 10 0a                      dup.x32 sp(10)
	<mul+302 @051266>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @05126a>  : 24                         load.i128
	<mul+307 @05126b>  : 9b                         dp4.v4f
	<mul+308 @05126c>  : 10 06                      dup.x32 sp(6)
	<mul+310 @05126e>  : 24                         load.i128
	<mul+311 @05126f>  : 10 0b                      dup.x32 sp(11)
	<mul+313 @051271>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @051275>  : 24                         load.i128
	<mul+318 @051276>  : 9b                         dp4.v4f
	<mul+319 @051277>  : 10 07                      dup.x32 sp(7)
	<mul+321 @051279>  : 24                         load.i128
	<mul+322 @05127a>  : 10 0c                      dup.x32 sp(12)
	<mul+324 @05127c>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @051280>  : 24                         load.i128
	<mul+329 @051281>  : 9b                         dp4.v4f
	<mul+330 @051282>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @051287>  : 02                         call
	<mul+336 @051288>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @05128c>  : 15 02                      set.x128 sp(2)
	<mul+342 @05128e>  : 15 1f                      set.x128 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes: <@051290> - <@0512d4>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @051290>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @051294>  : 10 13                      dup.x32 sp(19)
	<mul+350 @051296>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @05129a>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @05129e>  : 10 04                      dup.x32 sp(4)
	<mul+360 @0512a0>  : 24                         load.i128
	<mul+361 @0512a1>  : 10 09                      dup.x32 sp(9)
	<mul+363 @0512a3>  : 24                         load.i128
	<mul+364 @0512a4>  : 9b                         dp4.v4f
	<mul+365 @0512a5>  : 10 05                      dup.x32 sp(5)
	<mul+367 @0512a7>  : 24                         load.i128
	<mul+368 @0512a8>  : 10 0a                      dup.x32 sp(10)
	<mul+370 @0512aa>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @0512ae>  : 24                         load.i128
	<mul+375 @0512af>  : 9b                         dp4.v4f
	<mul+376 @0512b0>  : 10 06                      dup.x32 sp(6)
	<mul+378 @0512b2>  : 24                         load.i128
	<mul+379 @0512b3>  : 10 0b                      dup.x32 sp(11)
	<mul+381 @0512b5>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @0512b9>  : 24                         load.i128
	<mul+386 @0512ba>  : 9b                         dp4.v4f
	<mul+387 @0512bb>  : 10 07                      dup.x32 sp(7)
	<mul+389 @0512bd>  : 24                         load.i128
	<mul+390 @0512be>  : 10 0c                      dup.x32 sp(12)
	<mul+392 @0512c0>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @0512c4>  : 24                         load.i128
	<mul+397 @0512c5>  : 9b                         dp4.v4f
	<mul+398 @0512c6>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @0512cb>  : 02                         call
	<mul+404 @0512cc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @0512d0>  : 15 02                      set.x128 sp(2)
	<mul+410 @0512d2>  : 15 23                      set.x128 sp(35)
	<mul+412 @0512d4>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @0512d8>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0512e0>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0512e8>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0512f0>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0512f8>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051300>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051308>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051310>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051318>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051320>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051328>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@051330>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051338>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051340>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051348>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051350>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051358>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051360>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051368>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051370>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051378>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051380>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051388>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051390>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051398>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513a0>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513a8>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513b0>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513b8>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513c0>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513c8>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513d0>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513d8>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513e0>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513e8>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513f0>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0513f8>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051400>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051408>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051410>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051418>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051420>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051428>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051430>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051438>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051440>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051448>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051450>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051458>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051460>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051468>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051470>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051478>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051480>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051488>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051490>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051498>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0514a0>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0514a8>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0514b0>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0514b8>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0514c0>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0514c8>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@030ff0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031120>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@0514d0>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@0514d8>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0514e0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0514e8>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0514f0>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0514f8>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051500>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051508>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051510>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051518>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051520>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051528>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051530>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051538>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@051540>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051548>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051550>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051558>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051560>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051568>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051570>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051578>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051580>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051588>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051590>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051598>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515a0>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515a8>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515b0>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515b8>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515c0>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515c8>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515d0>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515d8>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515e0>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515e8>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515f0>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0515f8>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051600>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051608>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051610>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051618>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051620>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051628>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051630>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051638>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051640>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051648>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051650>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051658>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051660>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051668>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051670>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051678>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051680>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051688>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051690>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051698>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0516a0>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0516a8>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516b0>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516b8>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516c0>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516c8>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516d0>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516d8>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516e0>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516e8>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516f0>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0516f8>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051700>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051708>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051710>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051718>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051720>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051728>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051730>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051738>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051740>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051748>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051750>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051758>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051760>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051768>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@051770>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@051770> - <@051771>)
	<empty @051770>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@051778>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@051778> - <@051780>)
	test/lang/function.ci:8: (8 bytes: <@051778> - <@051780>): return int32(.result := int32(x + y));
	<funAdd @051778>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @05177a>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @05177c>    : 51                         add.i32
	<funAdd+5 @05177d>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @05177f>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051780>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051788>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051790>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051798>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0517a0>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0517a8>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0517b0>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@0517b8>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@0517b8> - <@0517c0>)
	test/lang/function.ci:34: (8 bytes: <@0517b8> - <@0517c0>): return int32(.result := int32(x * y));
	<funMul @0517b8>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @0517ba>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @0517bc>    : 53                         mul.i32
	<funMul+5 @0517bd>    : 13 04                      set.x32 sp(4)
	<funMul+7 @0517bf>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@0517c0>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@0517c0> - <@0517f6>)
	test/lang/function.ci:39: (16 bytes: <@0517c0> - <@0517d0>): if (bool(n <= (1)))
	<fib @0517c0>      : 10 01                      dup.x32 sp(1)
	<fib+2 @0517c2>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @0517c7>    : 39                         cgt.u32
	<fib+8 @0517c8>    : 05 08 00 00                jnz <fib+16 @0517d0>
	test/lang/function.ci:40: (4 bytes: <@0517cc> - <@0517d0>): return uint32(.result := n);
	<fib+12 @0517cc>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @0517cf>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@0517d0> - <@0517f6>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @0517d0>   : 19                         load.z32
	<fib+17 @0517d1>   : 10 02                      dup.x32 sp(2)
	<fib+19 @0517d3>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @0517d7>   : 1f c0 17 05 00             load.ref <@0517c0> ;fib(n: uint32): uint32
	<fib+28 @0517dc>   : 02                         call
	<fib+29 @0517dd>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @0517e1>   : 19                         load.z32
	<fib+34 @0517e2>   : 10 03                      dup.x32 sp(3)
	<fib+36 @0517e4>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @0517e8>   : 1f c0 17 05 00             load.ref <@0517c0> ;fib(n: uint32): uint32
	<fib+45 @0517ed>   : 02                         call
	<fib+46 @0517ee>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @0517f2>   : 51                         add.i32
	<fib+51 @0517f3>   : 13 03                      set.x32 sp(3)
	<fib+53 @0517f5>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0517f8>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051800>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051808>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051810>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051818>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051820>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051828>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051830>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051838>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051840>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051848>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051850>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051858>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051860>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051868>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051870>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051878>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051880>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051888>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@036f88>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@0370b8>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051890>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051898>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518a0>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518a8>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0518b0>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518b8>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0518c0>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0518c8>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518d0>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518d8>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0518e0>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518e8>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0518f0>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518f8>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051900>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051908>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051910>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051918>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051920>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051928>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051930>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051938>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051940>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051948>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051950>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051958>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051960>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051968>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051970>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051978>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051980>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051988>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051990>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051998>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519a0>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519a8>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519b0>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519b8>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519c0>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519c8>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519d0>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519d8>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519e0>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519e8>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519f0>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0519f8>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051a00>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a08>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a10>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a18>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a20>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a28>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a30>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a38>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a40>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a48>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@051a50>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a58>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a60>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a68>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a70>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a78>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a80>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a88>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051a90>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051a98>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051aa0>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051aa8>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051ab0>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051ab8>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051ac0>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@051ac8>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@051ac8> - <@051ac9>)
	<noError @051ac8>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@051ad0>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@051ad0> - <@051ae8>)
	test/stdc/tryExec.ci:15: (4 bytes: <@051ad0> - <@051ad4>): data: uint8[8192]
	<stackOverflow @051ad0>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@051ad4> - <@051ae3>): stackOverflow(ptr);
	<stackOverflow+4 @051ad4>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @051ad8>    : 22                         load.i32
	<stackOverflow+9 @051ad9>    : 1f d0 1a 05 00             load.ref <@051ad0> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @051ade>   : 02                         call
	<stackOverflow+15 @051adf>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @051ae3>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @051ae7>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@051ae8>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@051ae8> - <@051af4>)
	test/stdc/tryExec.ci:20: (7 bytes: <@051ae8> - <@051aef>): value: int32 := int32(3 / 0)
	<divisionByZero @051ae8>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @051aed>    : 19                         load.z32
	<divisionByZero+6 @051aee>    : 54                         div.i32
	<divisionByZero+7 @051aef>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @051af3>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@051af8>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@051af8> - <@051b3c>)
	test/stdc/tryExec.ci:29: (25 bytes: <@051af8> - <@051b11>): details: NotEquals := {...}
	<abortExecution @051af8>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@051afc> - <@051b03>): void(details.message := ("assertion failed"));
	<abortExecution+4 @051afc>    : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<abortExecution+9 @051b01>    : 13 01                      set.x32 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@051b03> - <@051b0a>): void(details.expected := 97);
	<abortExecution+11 @051b03>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @051b08>   : 13 02                      set.x32 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@051b0a> - <@051b11>): void(details.returned := 77);
	<abortExecution+18 @051b0a>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @051b0f>   : 13 03                      set.x32 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@051b11> - <@051b37>): abort(void("fatal error", details));
	<abortExecution+25 @051b11>   : 1f 28 ad 03 00             load.ref <@03ad28> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @051b16>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @051b1b>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @051b20>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @051b25>   : 1f 71 ad 03 00             load.ref <@03ad71> ;"fatal error"
	<abortExecution+50 @051b2a>   : 1f 88 b7 03 00             load.ref <@03b788> ;abortExecution.NotEquals
	<abortExecution+55 @051b2f>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @051b33>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @051b37>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @051b3b>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@051b40>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@051b40> - <@051b4d>)
	test/stdc/tryExec.ci:38: (5 bytes: <@051b40> - <@051b45>): i32Ref: int32 := null
	<invalidMemoryAccess @051b40>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@051b45> - <@051b48>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @051b45>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @051b47>    : 22                         load.i32
	<invalidMemoryAccess+8 @051b48>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @051b4c>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@051b50>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@051b50> - <@051b52>)
	test/stdc/tryExec.ci:43: (2 bytes: <@051b50> - <@051b52>): emit(void(load.z32, ret));
	<invalidInstruction @051b50>      : 19                         load.z32
	<invalidInstruction+1 @051b51>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b58>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b60>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b68>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b70>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b78>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b80>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051b88>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@051b90>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@051bc8>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@051bd0>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@051bd8>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@051be0>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@051be8>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@051bf0>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@051bf8>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@051c00>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@051c08>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@051c10>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051c18>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@051c20>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@051c28>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@051c28> - <@051c2c>)
	test/lang/array.ci:103: (4 bytes: <@051c28> - <@051c2c>): return uint32(.result := values.length);
	<lenSlice @051c28>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @051c2b>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@051c30>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@051c30> - <@051c3c>)
	test/lang/array.ci:104: (12 bytes: <@051c30> - <@051c3c>): return int64(.result := values[idx]);
	<nthFixed @051c30>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @051c32>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @051c34>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @051c38>    : 23                         load.i64
	<nthFixed+9 @051c39>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @051c3b>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@051c40>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@051c40> - <@051c4c>)
	test/lang/array.ci:105: (12 bytes: <@051c40> - <@051c4c>): return int64(.result := values[idx]);
	<nthArray @051c40>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @051c42>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @051c44>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @051c48>    : 23                         load.i64
	<nthArray+9 @051c49>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @051c4b>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@051c50>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@051c50> - <@051c5c>)
	test/lang/array.ci:106: (12 bytes: <@051c50> - <@051c5c>): return int64(.result := values[idx]);
	<nthSlice @051c50>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @051c52>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @051c54>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @051c58>    : 23                         load.i64
	<nthSlice+9 @051c59>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @051c5b>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03e4d0>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@03e568>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@051c60>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@051c68>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@051c70>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@051c78>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@051c80>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@051c88>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03e568>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051c60>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051c68>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@051c70>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051c78>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051c80>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051c88>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@051c90>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03f3a8>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@051cb0>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@051cd8>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@051ce0>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@051d08>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051cb0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@051cb0> - <@051cd7>)
	test/lang/method.ci:11: (38 bytes: <@051cb0> - <@051cd6>): trace(void("staticMethod", x));
	<staticMethod @051cb0>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<staticMethod+5 @051cb5>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @051cba>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @051cbf>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @051cc4>   : 1f 85 ef 03 00             load.ref <@03ef85> ;"staticMethod"
	<staticMethod+25 @051cc9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @051cce>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @051cd2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @051cd6>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051cd8>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051ce0>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@051ce0> - <@051d07>)
	test/lang/method.ci:41: (38 bytes: <@051ce0> - <@051d06>): trace(void("virtualMethod", x));
	<virtualMethod @051ce0>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<virtualMethod+5 @051ce5>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @051cea>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @051cef>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @051cf4>   : 1f 76 f2 03 00             load.ref <@03f276> ;"virtualMethod"
	<virtualMethod+25 @051cf9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @051cfe>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @051d02>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @051d06>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051d08>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@051d08> - <@051d2f>)
	test/lang/method.ci:48: (38 bytes: <@051d08> - <@051d2e>): trace(void("forwardMethod", x));
	<forwardMethod @051d08>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<forwardMethod+5 @051d0d>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @051d12>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @051d17>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @051d1c>   : 1f fd ef 03 00             load.ref <@03effd> ;"forwardMethod"
	<forwardMethod+25 @051d21>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @051d26>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @051d2a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @051d2e>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051d30>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@051d30> - <@051d57>)
	test/lang/method.ci:58: (38 bytes: <@051d30> - <@051d56>): trace(void("globalFunction", x));
	<globalFunction @051d30>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<globalFunction+5 @051d35>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @051d3a>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @051d3f>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @051d44>   : 1f a9 f2 03 00             load.ref <@03f2a9> ;"globalFunction"
	<globalFunction+25 @051d49>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @051d4e>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @051d52>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @051d56>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@051d58>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@051d68>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@051d68> - <@051daa>)
	test/lang/method.ci:85: (35 bytes: <@051d68> - <@051d8b>): debug("extension.staticMethod");
	<staticMethod @051d68>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<staticMethod+5 @051d6d>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @051d72>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @051d77>   : 19                         load.z32
	<staticMethod+16 @051d78>   : 1f 77 f3 03 00             load.ref <@03f377> ;"extension.staticMethod"
	<staticMethod+21 @051d7d>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @051d82>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @051d87>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@051d8b> - <@051da9>): if (bool((this) != null))
	<staticMethod+35 @051d8b>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @051d8f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @051d94>   : 57                         ceq.i32
	<staticMethod+45 @051d95>   : 05 14 00 00                jnz <staticMethod+65 @051da9>
	test/lang/method.ci:87: (16 bytes: <@051d99> - <@051da9>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @051d99>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @051d9b>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @051d9d>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @051d9f>   : 1f b0 1c 05 00             load.ref <@051cb0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @051da4>   : 02                         call
	<staticMethod+61 @051da5>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @051da9>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@051db0>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@051db0> - <@051def>)
	test/lang/method.ci:91: (35 bytes: <@051db0> - <@051dd3>): debug("extension.virtualMethod");
	<virtualMethod @051db0>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<virtualMethod+5 @051db5>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @051dba>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @051dbf>   : 19                         load.z32
	<virtualMethod+16 @051dc0>   : 1f 8e f3 03 00             load.ref <@03f38e> ;"extension.virtualMethod"
	<virtualMethod+21 @051dc5>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @051dca>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @051dcf>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@051dd3> - <@051dee>): if (bool((this) != null))
	<virtualMethod+35 @051dd3>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @051dd7>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @051ddc>   : 57                         ceq.i32
	<virtualMethod+45 @051ddd>   : 05 11 00 00                jnz <virtualMethod+62 @051dee>
	test/lang/method.ci:93: (13 bytes: <@051de1> - <@051dee>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @051de1>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @051de3>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @051de5>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @051de7>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @051de9>   : 02                         call
	<virtualMethod+58 @051dea>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @051dee>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@040b28>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@040d88>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@040fe8>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@0411b0>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@051df0>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@051df8>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@051e00>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@051e08>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@051e10>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@041650>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@041a78>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@041ea0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@0422c8>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0426f0>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@042b18>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e18>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e20>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e28>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e30>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e38>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e40>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e48>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e50>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e58>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e60>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e68>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e70>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051e78>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051e80>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051e88>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051e90>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051e98>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ea0>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ea8>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051eb0>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051eb8>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ec0>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ec8>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ed0>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ed8>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ee0>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ee8>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@051ef0>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051ef8>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f00>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f08>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f10>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f18>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f20>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051f28>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f30>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f38>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f40>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f48>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f50>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f58>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f60>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f68>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f70>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f78>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f80>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f88>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f90>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051f98>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@051fa0>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fa8>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fb0>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fb8>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fc0>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fc8>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fd0>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@051fd8>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@051fe0>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@051fe8>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@051ff0>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@051ff8>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052000>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052008>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052010>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052018>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052020>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052028>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052030>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052038>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052040>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052048>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052050>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052058>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052060>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052068>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052070>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052078>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052080>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052088>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052090>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052098>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520a0>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520a8>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520b0>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520b8>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520c0>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520c8>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520d0>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520d8>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520e0>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520e8>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520f0>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0520f8>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052100>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052108>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052110>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052118>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052120>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052128>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052130>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052138>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052140>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052148>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052150>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052158>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052160>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052168>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052170>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052178>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052180>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052188>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052190>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052198>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0521a0>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0521a8>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0521b0>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521b8>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521c0>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521c8>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521d0>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521d8>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521e0>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0521e8>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0521f0>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0521f8>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052200>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052208>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052210>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052218>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052220>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052228>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052230>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052238>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052240>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052248>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052250>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052258>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052260>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052268>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052270>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052278>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052280>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052288>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052290>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052298>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522a0>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522a8>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522b0>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522b8>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522c0>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522c8>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522d0>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522d8>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522e0>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522e8>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522f0>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0522f8>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052300>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052308>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052310>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052318>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052320>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052328>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052330>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052338>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052340>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052348>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052350>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052358>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052360>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052368>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052370>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052378>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052380>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052388>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052390>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052398>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0523a0>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0523a8>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0523b0>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0523b8>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0523c0>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523c8>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523d0>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523d8>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523e0>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523e8>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523f0>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523f8>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052400>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052408>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052410>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052418>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052420>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052428>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052430>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052438>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052440>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052448>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052450>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052458>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052460>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052468>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052470>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052478>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052480>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052488>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052490>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052498>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0524a0>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0524a8>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524b0>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524b8>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524c0>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524c8>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524d0>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524d8>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524e0>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524e8>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0524f0>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0524f8>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052500>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052508>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052510>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052518>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052520>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052528>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052530>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052538>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052540>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052548>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052550>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052558>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052560>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052568>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052570>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052578>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052580>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052588>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052590>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052598>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525a0>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525a8>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0525b0>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0525b8>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525c0>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525c8>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0525d0>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0525d8>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0525e0>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0525e8>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0525f0>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0525f8>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052600>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052608>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052610>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052618>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052620>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052628>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052630>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052638>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052640>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052648>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052650>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052658>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052670>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052678>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052680>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052688>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052690>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052698>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526a0>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526a8>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526b0>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526b8>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526c0>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526c8>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526d0>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526d8>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526e0>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526e8>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526f0>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0526f8>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052700>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052708>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052710>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052718>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052720>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052728>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052730>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052738>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052740>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052748>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052750>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052758>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052760>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052768>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052770>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052778>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052780>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052788>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052790>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052798>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527a0>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527a8>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527b0>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527b8>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527c0>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527c8>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527d0>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0527d8>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0527e0>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0527e8>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0527f0>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0527f8>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052800>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052808>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052810>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052818>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052820>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052828>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052830>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 14636
.offset: <@052834>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@001058>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@0010f8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005c20>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006d00>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0075e0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008250>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 32, offs: <@00fbe0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@050210>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@010e58>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@019b78>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@050a10>, cast: static const function)
.field Complex: function (size: 7, offs: <@050a18>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@050a20>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@050aa0>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@050ac0>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@050b28>, cast: static const function)
.field indexOf: function (size: 50, offs: <@050b50>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@050b88>, cast: static const function)
.field startsWith: function (size: 73, offs: <@050bc0>, cast: static const function)
.field endsWith: function (size: 126, offs: <@050c10>, cast: static const function)
.field compare: function (size: 63, offs: <@050c90>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@050d18>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@050d40>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@0225a0>, cast: static const typename(val))
.field append: function (size: 84, offs: <@050d50>, cast: static const function)
.field append: function (size: 657, offs: <@050db8>, cast: static const function)
.field append: function (size: 23, offs: <@051050>, cast: static const function)
.field append: function (size: 49, offs: <@051068>, cast: static const function)
.field append: function (size: 25, offs: <@0510b0>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024730>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@0510d0>, cast: static const function)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@0256e8>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@0510d8>, cast: static const function)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field len: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@028ac8>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@0510e8>, cast: static const function)
.field mat4f: function (size: 21, offs: <@051120>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 417, offs: <@051138>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@0512e0>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@0512e8>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@0512f0>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@0512f8>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@051300>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@051308>, cast: static variable(i32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@051310>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@051318>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@051320>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@051328>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@051330>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@051338>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@051340>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@051348>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@051350>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@051358>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@051360>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@051368>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@051370>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@051378>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@051380>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@051388>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@051390>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@051398>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@0513a0>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@0513a8>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@0513b0>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@0513b8>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@0513c0>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@0513c8>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@0513d0>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@0513d8>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@0513e0>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@0513e8>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@0513f0>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@0513f8>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@051400>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@051408>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@051410>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@051418>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@051420>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@051428>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@051430>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@051438>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@051440>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@051448>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@051450>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@051458>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@051460>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@051468>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@051470>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@051478>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@051480>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@051488>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@051490>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@051498>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@0514a0>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@0514a8>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@0514b0>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@0514b8>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@0514c0>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@0514c8>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@030ff0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@031120>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@0514d0>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@0514d8>, cast: static variable(val))
.field value: int64 (size: 8, offs: <@0514e0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@0514e8>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@0514f0>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@0514f8>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@051500>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@051508>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@051510>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@051518>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@051520>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@051528>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@051530>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@051538>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@051540>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@051548>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@051550>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@051558>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@051560>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@051568>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@051570>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@051578>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@051580>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@051588>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@051590>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@051598>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@0515a0>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@0515a8>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@0515b0>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@0515b8>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@0515c0>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@0515c8>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@0515d0>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@0515d8>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@0515e0>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@0515e8>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@0515f0>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@0515f8>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@051600>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@051608>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@051610>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@051618>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@051620>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@051628>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@051630>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@051638>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@051640>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@051648>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@051650>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@051658>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@051660>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@051668>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@051670>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@051678>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@051680>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@051688>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@051690>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@051698>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@0516a0>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@0516a8>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@0516b0>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@0516b8>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@0516c0>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@0516c8>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@0516d0>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@0516d8>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@0516e0>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@0516e8>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@0516f0>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@0516f8>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@051700>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@051708>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@051710>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@051718>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@051720>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@051728>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@051730>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@051738>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@051740>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@051748>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@051750>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@051758>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@051760>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@051768>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@051770>, cast: static const function)
.field funAdd: function (size: 8, offs: <@051778>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@051780>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@051788>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@051790>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@051798>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@0517a0>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@0517a8>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@0517b0>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@0517b8>, cast: static const function)
.field fib: function (size: 54, offs: <@0517c0>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@0517f8>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@051800>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@051808>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@051810>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@051818>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@051820>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@051828>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@051830>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@051838>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@051840>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@051848>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@051850>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@051858>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@051860>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@051868>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@051870>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@051878>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@051880>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@051888>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@036f88>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@0370b8>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@051890>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@051898>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@0518a0>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@0518a8>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@0518b0>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@0518b8>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@0518c0>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@0518c8>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@0518d0>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@0518d8>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@0518e0>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@0518e8>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@0518f0>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@0518f8>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@051900>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@051908>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@051910>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@051918>, cast: static variable(i32))
.field pi64: float64 (size: 8, offs: <@051920>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@051928>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@051930>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@051938>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@051940>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@051948>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@051950>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@051958>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@051960>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@051968>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@051970>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@051978>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@051980>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@051988>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@051990>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@051998>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@0519a0>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@0519a8>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@0519b0>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@0519b8>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@0519c0>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@0519c8>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@0519d0>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@0519d8>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@0519e0>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@0519e8>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@0519f0>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@0519f8>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@051a00>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@051a08>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@051a10>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@051a18>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@051a20>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@051a28>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@051a30>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@051a38>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@051a40>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@051a48>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@051a50>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@051a58>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@051a60>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@051a68>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@051a70>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@051a78>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@051a80>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@051a88>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@051a90>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@051a98>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@051aa0>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@051aa8>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@051ab0>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@051ab8>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@051ac0>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@051ac8>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@051ad0>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@051ae8>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@051af8>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@051b40>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@051b50>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@051b58>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@051b60>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@051b68>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@051b70>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@051b78>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@051b80>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@051b88>, cast: static variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <@051b90>, cast: static variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <@051bc8>, cast: static variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <@051bd0>, cast: static variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@051bd8>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@051be0>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@051be8>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@051bf0>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@051bf8>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@051c00>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@051c08>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@051c10>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@051c18>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@051c20>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@051c28>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@051c30>, cast: static const function)
.field nthArray: function (size: 12, offs: <@051c40>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@051c50>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@03e4d0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@051c90>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03f3a8>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@051d30>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@051d58>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@051d68>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@051db0>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@040b28>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@040d88>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@040fe8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@0411b0>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@051df0>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@051df8>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@051e00>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@051e08>, cast: static variable(val))
.field blue: color (size: 4, offs: <@051e10>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@041650>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@041a78>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@041ea0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@0422c8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@0426f0>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@042b18>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@051e18>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@051e20>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@051e28>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@051e30>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@051e38>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@051e40>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@051e48>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@051e50>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@051e58>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@051e60>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@051e68>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@051e70>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@051e78>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@051e80>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@051e88>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@051e90>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@051e98>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@051ea0>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@051ea8>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@051eb0>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@051eb8>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@051ec0>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@051ec8>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@051ed0>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@051ed8>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@051ee0>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@051ee8>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@051ef0>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@051ef8>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@051f00>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@051f08>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@051f10>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@051f18>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@051f20>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@051f28>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@051f30>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@051f38>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@051f40>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@051f48>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@051f50>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@051f58>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@051f60>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@051f68>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@051f70>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@051f78>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@051f80>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@051f88>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@051f90>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@051f98>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@051fa0>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@051fa8>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@051fb0>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@051fb8>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@051fc0>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@051fc8>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@051fd0>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@051fd8>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@051fe0>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@051fe8>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@051ff0>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@051ff8>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@052000>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@052008>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@052010>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@052018>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@052020>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@052028>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@052030>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@052038>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@052040>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@052048>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@052050>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@052058>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@052060>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@052068>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@052070>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@052078>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@052080>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@052088>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@052090>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@052098>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@0520a0>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@0520a8>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@0520b0>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@0520b8>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@0520c0>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@0520c8>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@0520d0>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@0520d8>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@0520e0>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@0520e8>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@0520f0>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@0520f8>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@052100>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@052108>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@052110>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@052118>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@052120>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@052128>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@052130>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@052138>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@052140>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@052148>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@052150>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@052158>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@052160>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@052168>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@052170>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@052178>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@052180>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@052188>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@052190>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@052198>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@0521a0>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@0521a8>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@0521b0>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@0521b8>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@0521c0>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@0521c8>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@0521d0>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@0521d8>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@0521e0>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@0521e8>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@0521f0>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@0521f8>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@052200>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@052208>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@052210>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@052218>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@052220>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@052228>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@052230>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@052238>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@052240>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@052248>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@052250>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@052258>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@052260>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@052268>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@052270>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@052278>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@052280>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@052288>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@052290>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@052298>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@0522a0>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@0522a8>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@0522b0>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@0522b8>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@0522c0>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@0522c8>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@0522d0>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@0522d8>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@0522e0>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@0522e8>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@0522f0>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@0522f8>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@052300>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@052308>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@052310>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@052318>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@052320>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@052328>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@052330>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@052338>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@052340>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@052348>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@052350>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@052358>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@052360>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@052368>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@052370>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@052378>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@052380>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@052388>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@052390>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@052398>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@0523a0>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@0523a8>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@0523b0>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@0523b8>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@0523c0>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@0523c8>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@0523d0>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@0523d8>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@0523e0>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@0523e8>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@0523f0>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@0523f8>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@052400>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@052408>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@052410>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@052418>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@052420>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@052428>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@052430>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@052438>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@052440>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@052448>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@052450>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@052458>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@052460>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@052468>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@052470>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@052478>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@052480>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@052488>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@052490>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@052498>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@0524a0>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@0524a8>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@0524b0>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@0524b8>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@0524c0>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@0524c8>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@0524d0>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@0524d8>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@0524e0>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@0524e8>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@0524f0>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@0524f8>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@052500>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@052508>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@052510>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@052518>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@052520>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@052528>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@052530>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@052538>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@052540>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@052548>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@052550>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@052558>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@052560>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@052568>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@052570>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@052578>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@052580>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@052588>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@052590>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@052598>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@0525a0>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@0525a8>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@0525b0>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@0525b8>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@0525c0>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@0525c8>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@0525d0>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@0525d8>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@0525e0>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@0525e8>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@0525f0>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@0525f8>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@052600>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@052608>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@052610>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@052618>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@052620>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@052628>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@052630>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@052638>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@052640>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@052648>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@052650>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@052658>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@052660>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@052668>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@052670>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@052678>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@052680>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@052688>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@052690>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@052698>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@0526a0>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@0526a8>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@0526b0>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@0526b8>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@0526c0>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@0526c8>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@0526d0>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@0526d8>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@0526e0>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@0526e8>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@0526f0>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@0526f8>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@052700>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@052708>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@052710>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@052718>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@052720>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@052728>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@052730>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@052738>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@052740>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@052748>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@052750>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@052758>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@052760>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@052768>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@052770>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@052778>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@052780>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@052788>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@052790>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@052798>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@0527a0>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@0527a8>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@0527b0>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@0527b8>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@0527c0>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@0527c8>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@0527d0>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@0527d8>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@0527e0>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@0527e8>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@0527f0>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@0527f8>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@052800>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@052808>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@052810>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@052818>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@052820>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@052828>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@052830>, cast: static variable(f32))
.field .main: function (size: 14636, offs: <@052834>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			static verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		static add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			static min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			static max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			static len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			static normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedNoInit: int64[7];
		static arrArrayNoInit: int64[*];
		static arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedNoInit;
		static arrSliceInitFixed: int64[] := arrFixedNoInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14636 bytes: <@052834> - <@056160>)
	lib/std/string.ci:144: (14 bytes: <@052834> - <@052842>): static const whiteSpace: char[] := " \t\n\r"
	<.main @052834>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @052839>    : 1f b9 f0 01 00             load.ref <@01f0b9> ;" \t\n\r"
	<.main+10 @05283e>   : 2d a8 0d 05                store.m64 <@050da8> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@052842> - <@052850>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @052842>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @052847>   : 1f ca f0 01 00             load.ref <@01f0ca> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @05284c>   : 2d b0 0d 05                store.m64 <@050db0> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@052850> - <@05286a>): static const format: FormatFlags := {...}
	<.main+28 @052850>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @052855>   : 2e a0 10 05                store.m32 <@0510a0> ;append.format
	:: (7 bytes: <@052859> - <@052860>): void(format.padChr := (0))
	<.main+37 @052859>   : 19                         load.z32
	<.main+38 @05285a>   : 1f a4 10 05 00             load.ref <@0510a4> ;append.format+4
	<.main+43 @05285f>   : 25                         store.i8
	:: (5 bytes: <@052860> - <@052865>): void(format.padLen := 0)
	<.main+44 @052860>   : 19                         load.z32
	<.main+45 @052861>   : 2e a8 10 05                store.m32 <@0510a8> ;append.format+8
	:: (5 bytes: <@052865> - <@05286a>): void(format.precision := 0)
	<.main+49 @052865>   : 19                         load.z32
	<.main+50 @052866>   : 2e ac 10 05                store.m32 <@0510ac> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@05286a> - <@05286f>): static emitldz32: int32 := emit(load.z32)
	<.main+54 @05286a>   : 19                         load.z32
	<.main+55 @05286b>   : 2e e0 12 05                store.m32 <@0512e0> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@05286f> - <@052874>): static emitldz64: int64 := emit(load.z64)
	<.main+59 @05286f>   : 1a                         load.z64
	<.main+60 @052870>   : 2d e8 12 05                store.m64 <@0512e8> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@052874> - <@05287d>): static emitA: int32 := 42
	<.main+64 @052874>   : 1c 2a 00 00 00             load.c32 42
	<.main+69 @052879>   : 2e f0 12 05                store.m32 <@0512f0> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@05287d> - <@052886>): static emitB: int32 := 96
	<.main+73 @05287d>   : 1c 60 00 00 00             load.c32 96
	<.main+78 @052882>   : 2e f8 12 05                store.m32 <@0512f8> ;emitB
	test/lang/emit.ci:9: (13 bytes: <@052886> - <@052893>): static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+82 @052886>   : 2a f0 12 05                load.m32 <@0512f0> ;emitA
	<.main+86 @05288a>   : 2a f8 12 05                load.m32 <@0512f8> ;emitB
	<.main+90 @05288e>   : 51                         add.i32
	<.main+91 @05288f>   : 2e 00 13 05                store.m32 <@051300> ;emitAddI32
	test/lang/emit.ci:10: (15 bytes: <@052893> - <@0528a2>): static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+95 @052893>   : 1c 0a 00 00 00             load.c32 10
	<.main+100 @052898>  : 1c 05 00 00 00             load.c32 5
	<.main+105 @05289d>  : 54                         div.i32
	<.main+106 @05289e>  : 2e 08 13 05                store.m32 <@051308> ;emitDivI32
	test/lang/emit.ci:17: (9 bytes: <@0528a2> - <@0528ab>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+110 @0528a2>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+115 @0528a7>  : 2e 10 13 05                store.m32 <@051310> ;emitFloatAsInt1
	test/lang/emit.ci:18: (10 bytes: <@0528ab> - <@0528b5>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+119 @0528ab>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+124 @0528b0>  : 5b                         i32.2i64
	<.main+125 @0528b1>  : 2d 18 13 05                store.m64 <@051318> ;emitFloatAsInt2
	test/lang/emit.ci:19: (14 bytes: <@0528b5> - <@0528c3>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+129 @0528b5>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+138 @0528be>  : 6a                         i64.2i32
	<.main+139 @0528bf>  : 2e 20 13 05                store.m32 <@051320> ;emitFloatAsInt3
	test/lang/emit.ci:20: (13 bytes: <@0528c3> - <@0528d0>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+143 @0528c3>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+152 @0528cc>  : 2d 28 13 05                store.m64 <@051328> ;emitFloatAsInt4
	test/lang/emit.ci:23: (14 bytes: <@0528d0> - <@0528de>): static emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+156 @0528d0>  : 1c 03 00 00 00             load.c32 3
	<.main+161 @0528d5>  : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+166 @0528da>  : 2d 30 13 05                store.m64 <@051330> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@0528de> - <@0528e7>): static i3: int32 := 3
	<.main+170 @0528de>  : 1c 03 00 00 00             load.c32 3
	<.main+175 @0528e3>  : 2e 38 13 05                store.m32 <@051338> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@0528e7> - <@0528f0>): static i6: int32 := 6
	<.main+179 @0528e7>  : 1c 06 00 00 00             load.c32 6
	<.main+184 @0528ec>  : 2e 40 13 05                store.m32 <@051340> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@0528f0> - <@0528f9>): static i2: int32 := 2
	<.main+188 @0528f0>  : 1c 02 00 00 00             load.c32 2
	<.main+193 @0528f5>  : 2e 48 13 05                store.m32 <@051348> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@0528f9> - <@052902>): static i8: int32 := 8
	<.main+197 @0528f9>  : 1c 08 00 00 00             load.c32 8
	<.main+202 @0528fe>  : 2e 50 13 05                store.m32 <@051350> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@052902> - <@052907>): static zeroVal: int32 := zero(void(3, 6))
	<.main+206 @052902>  : 19                         load.z32
	<.main+207 @052903>  : 2e 58 13 05                store.m32 <@051358> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@052907> - <@05290c>): static zeroVar: int32 := zero(void(i3, i6))
	<.main+211 @052907>  : 19                         load.z32
	<.main+212 @052908>  : 2e 60 13 05                store.m32 <@051360> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@05290c> - <@052911>): static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+216 @05290c>  : 19                         load.z32
	<.main+217 @05290d>  : 2e 68 13 05                store.m32 <@051368> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@052911> - <@05291a>): static lastVal: int32 := last(void(3, 6))
	<.main+221 @052911>  : 1c 06 00 00 00             load.c32 6
	<.main+226 @052916>  : 2e 70 13 05                store.m32 <@051370> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@05291a> - <@052922>): static lastVar: int32 := last(void(i3, i6))
	<.main+230 @05291a>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+234 @05291e>  : 2e 78 13 05                store.m32 <@051378> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@052922> - <@052932>): static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+238 @052922>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+242 @052926>  : 0c 01 00 00                inc.i32(+1)
	<.main+246 @05292a>  : 0c ff ff ff                inc.i32(-1)
	<.main+250 @05292e>  : 2e 80 13 05                store.m32 <@051380> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@052932> - <@05293f>): static sum2Val: int32 := sum(void(3, 6))
	<.main+254 @052932>  : 1c 03 00 00 00             load.c32 3
	<.main+259 @052937>  : 0c 06 00 00                inc.i32(+6)
	<.main+263 @05293b>  : 2e 88 13 05                store.m32 <@051388> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@05293f> - <@05294c>): static sum2Var: int32 := sum(void(i3, i6))
	<.main+267 @05293f>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+271 @052943>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+275 @052947>  : 51                         add.i32
	<.main+276 @052948>  : 2e 90 13 05                store.m32 <@051390> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@05294c> - <@052965>): static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+280 @05294c>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+284 @052950>  : 0c 01 00 00                inc.i32(+1)
	<.main+288 @052954>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+292 @052958>  : 0c 01 00 00                inc.i32(+1)
	<.main+296 @05295c>  : 51                         add.i32
	<.main+297 @05295d>  : 0c fe ff ff                inc.i32(-2)
	<.main+301 @052961>  : 2e 98 13 05                store.m32 <@051398> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@052965> - <@052981>): static any2Val: int32 := any(void(3, 6))
	<.main+305 @052965>  : 1c 03 00 00 00             load.c32 3
	<.main+310 @05296a>  : 10 00                      dup.x32 sp(0)
	<.main+312 @05296c>  : 06 0a 00 00                jz <.main+322 @052976>
	<.main+316 @052970>  : 10 00                      dup.x32 sp(0)
	<.main+318 @052972>  : 04 09 00 00                jmp <.main+327 @05297b>
	<.main+322 @052976>  : 1c 06 00 00 00             load.c32 6
	<.main+327 @05297b>  : 13 01                      set.x32 sp(1)
	<.main+329 @05297d>  : 2e a0 13 05                store.m32 <@0513a0> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@052981> - <@05299b>): static any2Var: int32 := any(void(i3, i6))
	<.main+333 @052981>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+337 @052985>  : 10 00                      dup.x32 sp(0)
	<.main+339 @052987>  : 06 0a 00 00                jz <.main+349 @052991>
	<.main+343 @05298b>  : 10 00                      dup.x32 sp(0)
	<.main+345 @05298d>  : 04 08 00 00                jmp <.main+353 @052995>
	<.main+349 @052991>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+353 @052995>  : 13 01                      set.x32 sp(1)
	<.main+355 @052997>  : 2e a8 13 05                store.m32 <@0513a8> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@05299b> - <@0529c1>): static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+359 @05299b>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+363 @05299f>  : 0c 01 00 00                inc.i32(+1)
	<.main+367 @0529a3>  : 10 00                      dup.x32 sp(0)
	<.main+369 @0529a5>  : 06 0a 00 00                jz <.main+379 @0529af>
	<.main+373 @0529a9>  : 10 00                      dup.x32 sp(0)
	<.main+375 @0529ab>  : 04 0c 00 00                jmp <.main+387 @0529b7>
	<.main+379 @0529af>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+383 @0529b3>  : 0c 01 00 00                inc.i32(+1)
	<.main+387 @0529b7>  : 13 01                      set.x32 sp(1)
	<.main+389 @0529b9>  : 0c ff ff ff                inc.i32(-1)
	<.main+393 @0529bd>  : 2e b0 13 05                store.m32 <@0513b0> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@0529c1> - <@0529e6>): static min2Val: int32 := min(void(3, 6))
	<.main+397 @0529c1>  : 1c 03 00 00 00             load.c32 3
	<.main+402 @0529c6>  : 1c 06 00 00 00             load.c32 6
	<.main+407 @0529cb>  : 10 01                      dup.x32 sp(1)
	<.main+409 @0529cd>  : 10 01                      dup.x32 sp(1)
	<.main+411 @0529cf>  : 58                         clt.i32
	<.main+412 @0529d0>  : 06 0a 00 00                jz <.main+422 @0529da>
	<.main+416 @0529d4>  : 10 01                      dup.x32 sp(1)
	<.main+418 @0529d6>  : 04 06 00 00                jmp <.main+424 @0529dc>
	<.main+422 @0529da>  : 10 00                      dup.x32 sp(0)
	<.main+424 @0529dc>  : 13 02                      set.x32 sp(2)
	<.main+426 @0529de>  : 09 fc ff ff                inc.sp(-4)
	<.main+430 @0529e2>  : 2e b8 13 05                store.m32 <@0513b8> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@0529e6> - <@052a09>): static min2Var: int32 := min(void(i3, i6))
	<.main+434 @0529e6>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+438 @0529ea>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+442 @0529ee>  : 10 01                      dup.x32 sp(1)
	<.main+444 @0529f0>  : 10 01                      dup.x32 sp(1)
	<.main+446 @0529f2>  : 58                         clt.i32
	<.main+447 @0529f3>  : 06 0a 00 00                jz <.main+457 @0529fd>
	<.main+451 @0529f7>  : 10 01                      dup.x32 sp(1)
	<.main+453 @0529f9>  : 04 06 00 00                jmp <.main+459 @0529ff>
	<.main+457 @0529fd>  : 10 00                      dup.x32 sp(0)
	<.main+459 @0529ff>  : 13 02                      set.x32 sp(2)
	<.main+461 @052a01>  : 09 fc ff ff                inc.sp(-4)
	<.main+465 @052a05>  : 2e c0 13 05                store.m32 <@0513c0> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@052a09> - <@052a38>): static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+469 @052a09>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+473 @052a0d>  : 0c 01 00 00                inc.i32(+1)
	<.main+477 @052a11>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+481 @052a15>  : 0c 01 00 00                inc.i32(+1)
	<.main+485 @052a19>  : 10 01                      dup.x32 sp(1)
	<.main+487 @052a1b>  : 10 01                      dup.x32 sp(1)
	<.main+489 @052a1d>  : 58                         clt.i32
	<.main+490 @052a1e>  : 06 0a 00 00                jz <.main+500 @052a28>
	<.main+494 @052a22>  : 10 01                      dup.x32 sp(1)
	<.main+496 @052a24>  : 04 06 00 00                jmp <.main+502 @052a2a>
	<.main+500 @052a28>  : 10 00                      dup.x32 sp(0)
	<.main+502 @052a2a>  : 13 02                      set.x32 sp(2)
	<.main+504 @052a2c>  : 09 fc ff ff                inc.sp(-4)
	<.main+508 @052a30>  : 0c ff ff ff                inc.i32(-1)
	<.main+512 @052a34>  : 2e c8 13 05                store.m32 <@0513c8> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@052a38> - <@052a5d>): static max2Val: int32 := max(void(3, 6))
	<.main+516 @052a38>  : 1c 03 00 00 00             load.c32 3
	<.main+521 @052a3d>  : 1c 06 00 00 00             load.c32 6
	<.main+526 @052a42>  : 10 01                      dup.x32 sp(1)
	<.main+528 @052a44>  : 10 01                      dup.x32 sp(1)
	<.main+530 @052a46>  : 59                         cgt.i32
	<.main+531 @052a47>  : 06 0a 00 00                jz <.main+541 @052a51>
	<.main+535 @052a4b>  : 10 01                      dup.x32 sp(1)
	<.main+537 @052a4d>  : 04 06 00 00                jmp <.main+543 @052a53>
	<.main+541 @052a51>  : 10 00                      dup.x32 sp(0)
	<.main+543 @052a53>  : 13 02                      set.x32 sp(2)
	<.main+545 @052a55>  : 09 fc ff ff                inc.sp(-4)
	<.main+549 @052a59>  : 2e d0 13 05                store.m32 <@0513d0> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@052a5d> - <@052a80>): static max2Var: int32 := max(void(i3, i6))
	<.main+553 @052a5d>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+557 @052a61>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+561 @052a65>  : 10 01                      dup.x32 sp(1)
	<.main+563 @052a67>  : 10 01                      dup.x32 sp(1)
	<.main+565 @052a69>  : 59                         cgt.i32
	<.main+566 @052a6a>  : 06 0a 00 00                jz <.main+576 @052a74>
	<.main+570 @052a6e>  : 10 01                      dup.x32 sp(1)
	<.main+572 @052a70>  : 04 06 00 00                jmp <.main+578 @052a76>
	<.main+576 @052a74>  : 10 00                      dup.x32 sp(0)
	<.main+578 @052a76>  : 13 02                      set.x32 sp(2)
	<.main+580 @052a78>  : 09 fc ff ff                inc.sp(-4)
	<.main+584 @052a7c>  : 2e d8 13 05                store.m32 <@0513d8> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@052a80> - <@052aaf>): static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+588 @052a80>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+592 @052a84>  : 0c 01 00 00                inc.i32(+1)
	<.main+596 @052a88>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+600 @052a8c>  : 0c 01 00 00                inc.i32(+1)
	<.main+604 @052a90>  : 10 01                      dup.x32 sp(1)
	<.main+606 @052a92>  : 10 01                      dup.x32 sp(1)
	<.main+608 @052a94>  : 59                         cgt.i32
	<.main+609 @052a95>  : 06 0a 00 00                jz <.main+619 @052a9f>
	<.main+613 @052a99>  : 10 01                      dup.x32 sp(1)
	<.main+615 @052a9b>  : 04 06 00 00                jmp <.main+621 @052aa1>
	<.main+619 @052a9f>  : 10 00                      dup.x32 sp(0)
	<.main+621 @052aa1>  : 13 02                      set.x32 sp(2)
	<.main+623 @052aa3>  : 09 fc ff ff                inc.sp(-4)
	<.main+627 @052aa7>  : 0c ff ff ff                inc.i32(-1)
	<.main+631 @052aab>  : 2e e0 13 05                store.m32 <@0513e0> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@052aaf> - <@052ac8>): static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+635 @052aaf>  : 1c 03 00 00 00             load.c32 3
	<.main+640 @052ab4>  : 1c 06 00 00 00             load.c32 6
	<.main+645 @052ab9>  : 1c 02 00 00 00             load.c32 2
	<.main+650 @052abe>  : 0c 08 00 00                inc.i32(+8)
	<.main+654 @052ac2>  : 51                         add.i32
	<.main+655 @052ac3>  : 51                         add.i32
	<.main+656 @052ac4>  : 2e e8 13 05                store.m32 <@0513e8> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@052ac8> - <@052add>): static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+660 @052ac8>  : 1c 03 00 00 00             load.c32 3
	<.main+665 @052acd>  : 0c 06 00 00                inc.i32(+6)
	<.main+669 @052ad1>  : 0c 02 00 00                inc.i32(+2)
	<.main+673 @052ad5>  : 0c 08 00 00                inc.i32(+8)
	<.main+677 @052ad9>  : 2e f0 13 05                store.m32 <@0513f0> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@052add> - <@052af4>): static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+681 @052add>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+685 @052ae1>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+689 @052ae5>  : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+693 @052ae9>  : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+697 @052aed>  : 51                         add.i32
	<.main+698 @052aee>  : 51                         add.i32
	<.main+699 @052aef>  : 51                         add.i32
	<.main+700 @052af0>  : 2e f8 13 05                store.m32 <@0513f8> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@052af4> - <@052b0b>): static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+704 @052af4>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+708 @052af8>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+712 @052afc>  : 51                         add.i32
	<.main+713 @052afd>  : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+717 @052b01>  : 51                         add.i32
	<.main+718 @052b02>  : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+722 @052b06>  : 51                         add.i32
	<.main+723 @052b07>  : 2e 00 14 05                store.m32 <@051400> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@052b0b> - <@052b36>): static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+727 @052b0b>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+731 @052b0f>  : 0c 01 00 00                inc.i32(+1)
	<.main+735 @052b13>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+739 @052b17>  : 0c 01 00 00                inc.i32(+1)
	<.main+743 @052b1b>  : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+747 @052b1f>  : 0c 01 00 00                inc.i32(+1)
	<.main+751 @052b23>  : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+755 @052b27>  : 0c 01 00 00                inc.i32(+1)
	<.main+759 @052b2b>  : 51                         add.i32
	<.main+760 @052b2c>  : 51                         add.i32
	<.main+761 @052b2d>  : 51                         add.i32
	<.main+762 @052b2e>  : 0c fc ff ff                inc.i32(-4)
	<.main+766 @052b32>  : 2e 08 14 05                store.m32 <@051408> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@052b36> - <@052b61>): static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+770 @052b36>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+774 @052b3a>  : 0c 01 00 00                inc.i32(+1)
	<.main+778 @052b3e>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+782 @052b42>  : 0c 01 00 00                inc.i32(+1)
	<.main+786 @052b46>  : 51                         add.i32
	<.main+787 @052b47>  : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+791 @052b4b>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @052b4f>  : 51                         add.i32
	<.main+796 @052b50>  : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+800 @052b54>  : 0c 01 00 00                inc.i32(+1)
	<.main+804 @052b58>  : 51                         add.i32
	<.main+805 @052b59>  : 0c fc ff ff                inc.i32(-4)
	<.main+809 @052b5d>  : 2e 10 14 05                store.m32 <@051410> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@052b61> - <@052ba3>): static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+813 @052b61>  : 1c 03 00 00 00             load.c32 3
	<.main+818 @052b66>  : 10 00                      dup.x32 sp(0)
	<.main+820 @052b68>  : 06 0a 00 00                jz <.main+830 @052b72>
	<.main+824 @052b6c>  : 10 00                      dup.x32 sp(0)
	<.main+826 @052b6e>  : 04 2f 00 00                jmp <.main+873 @052b9d>
	<.main+830 @052b72>  : 1c 06 00 00 00             load.c32 6
	<.main+835 @052b77>  : 10 00                      dup.x32 sp(0)
	<.main+837 @052b79>  : 06 0a 00 00                jz <.main+847 @052b83>
	<.main+841 @052b7d>  : 10 00                      dup.x32 sp(0)
	<.main+843 @052b7f>  : 04 1c 00 00                jmp <.main+871 @052b9b>
	<.main+847 @052b83>  : 1c 02 00 00 00             load.c32 2
	<.main+852 @052b88>  : 10 00                      dup.x32 sp(0)
	<.main+854 @052b8a>  : 06 0a 00 00                jz <.main+864 @052b94>
	<.main+858 @052b8e>  : 10 00                      dup.x32 sp(0)
	<.main+860 @052b90>  : 04 09 00 00                jmp <.main+869 @052b99>
	<.main+864 @052b94>  : 1c 08 00 00 00             load.c32 8
	<.main+869 @052b99>  : 13 01                      set.x32 sp(1)
	<.main+871 @052b9b>  : 13 01                      set.x32 sp(1)
	<.main+873 @052b9d>  : 13 01                      set.x32 sp(1)
	<.main+875 @052b9f>  : 2e 18 14 05                store.m32 <@051418> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@052ba3> - <@052be5>): static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+879 @052ba3>  : 1c 03 00 00 00             load.c32 3
	<.main+884 @052ba8>  : 10 00                      dup.x32 sp(0)
	<.main+886 @052baa>  : 06 0a 00 00                jz <.main+896 @052bb4>
	<.main+890 @052bae>  : 10 00                      dup.x32 sp(0)
	<.main+892 @052bb0>  : 04 09 00 00                jmp <.main+901 @052bb9>
	<.main+896 @052bb4>  : 1c 06 00 00 00             load.c32 6
	<.main+901 @052bb9>  : 13 01                      set.x32 sp(1)
	<.main+903 @052bbb>  : 10 00                      dup.x32 sp(0)
	<.main+905 @052bbd>  : 06 0a 00 00                jz <.main+915 @052bc7>
	<.main+909 @052bc1>  : 10 00                      dup.x32 sp(0)
	<.main+911 @052bc3>  : 04 09 00 00                jmp <.main+920 @052bcc>
	<.main+915 @052bc7>  : 1c 02 00 00 00             load.c32 2
	<.main+920 @052bcc>  : 13 01                      set.x32 sp(1)
	<.main+922 @052bce>  : 10 00                      dup.x32 sp(0)
	<.main+924 @052bd0>  : 06 0a 00 00                jz <.main+934 @052bda>
	<.main+928 @052bd4>  : 10 00                      dup.x32 sp(0)
	<.main+930 @052bd6>  : 04 09 00 00                jmp <.main+939 @052bdf>
	<.main+934 @052bda>  : 1c 08 00 00 00             load.c32 8
	<.main+939 @052bdf>  : 13 01                      set.x32 sp(1)
	<.main+941 @052be1>  : 2e 20 14 05                store.m32 <@051420> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@052be5> - <@052c23>): static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+945 @052be5>  : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+949 @052be9>  : 10 00                      dup.x32 sp(0)
	<.main+951 @052beb>  : 06 0a 00 00                jz <.main+961 @052bf5>
	<.main+955 @052bef>  : 10 00                      dup.x32 sp(0)
	<.main+957 @052bf1>  : 04 2c 00 00                jmp <.main+1001 @052c1d>
	<.main+961 @052bf5>  : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+965 @052bf9>  : 10 00                      dup.x32 sp(0)
	<.main+967 @052bfb>  : 06 0a 00 00                jz <.main+977 @052c05>
	<.main+971 @052bff>  : 10 00                      dup.x32 sp(0)
	<.main+973 @052c01>  : 04 1a 00 00                jmp <.main+999 @052c1b>
	<.main+977 @052c05>  : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+981 @052c09>  : 10 00                      dup.x32 sp(0)
	<.main+983 @052c0b>  : 06 0a 00 00                jz <.main+993 @052c15>
	<.main+987 @052c0f>  : 10 00                      dup.x32 sp(0)
	<.main+989 @052c11>  : 04 08 00 00                jmp <.main+997 @052c19>
	<.main+993 @052c15>  : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+997 @052c19>  : 13 01                      set.x32 sp(1)
	<.main+999 @052c1b>  : 13 01                      set.x32 sp(1)
	<.main+1001 @052c1d> : 13 01                      set.x32 sp(1)
	<.main+1003 @052c1f> : 2e 28 14 05                store.m32 <@051428> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@052c23> - <@052c61>): static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+1007 @052c23> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1011 @052c27> : 10 00                      dup.x32 sp(0)
	<.main+1013 @052c29> : 06 0a 00 00                jz <.main+1023 @052c33>
	<.main+1017 @052c2d> : 10 00                      dup.x32 sp(0)
	<.main+1019 @052c2f> : 04 08 00 00                jmp <.main+1027 @052c37>
	<.main+1023 @052c33> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1027 @052c37> : 13 01                      set.x32 sp(1)
	<.main+1029 @052c39> : 10 00                      dup.x32 sp(0)
	<.main+1031 @052c3b> : 06 0a 00 00                jz <.main+1041 @052c45>
	<.main+1035 @052c3f> : 10 00                      dup.x32 sp(0)
	<.main+1037 @052c41> : 04 08 00 00                jmp <.main+1045 @052c49>
	<.main+1041 @052c45> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1045 @052c49> : 13 01                      set.x32 sp(1)
	<.main+1047 @052c4b> : 10 00                      dup.x32 sp(0)
	<.main+1049 @052c4d> : 06 0a 00 00                jz <.main+1059 @052c57>
	<.main+1053 @052c51> : 10 00                      dup.x32 sp(0)
	<.main+1055 @052c53> : 04 08 00 00                jmp <.main+1063 @052c5b>
	<.main+1059 @052c57> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1063 @052c5b> : 13 01                      set.x32 sp(1)
	<.main+1065 @052c5d> : 2e 30 14 05                store.m32 <@051430> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@052c61> - <@052cb3>): static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1069 @052c61> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1073 @052c65> : 0c 01 00 00                inc.i32(+1)
	<.main+1077 @052c69> : 10 00                      dup.x32 sp(0)
	<.main+1079 @052c6b> : 06 0a 00 00                jz <.main+1089 @052c75>
	<.main+1083 @052c6f> : 10 00                      dup.x32 sp(0)
	<.main+1085 @052c71> : 04 38 00 00                jmp <.main+1141 @052ca9>
	<.main+1089 @052c75> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1093 @052c79> : 0c 01 00 00                inc.i32(+1)
	<.main+1097 @052c7d> : 10 00                      dup.x32 sp(0)
	<.main+1099 @052c7f> : 06 0a 00 00                jz <.main+1109 @052c89>
	<.main+1103 @052c83> : 10 00                      dup.x32 sp(0)
	<.main+1105 @052c85> : 04 22 00 00                jmp <.main+1139 @052ca7>
	<.main+1109 @052c89> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1113 @052c8d> : 0c 01 00 00                inc.i32(+1)
	<.main+1117 @052c91> : 10 00                      dup.x32 sp(0)
	<.main+1119 @052c93> : 06 0a 00 00                jz <.main+1129 @052c9d>
	<.main+1123 @052c97> : 10 00                      dup.x32 sp(0)
	<.main+1125 @052c99> : 04 0c 00 00                jmp <.main+1137 @052ca5>
	<.main+1129 @052c9d> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1133 @052ca1> : 0c 01 00 00                inc.i32(+1)
	<.main+1137 @052ca5> : 13 01                      set.x32 sp(1)
	<.main+1139 @052ca7> : 13 01                      set.x32 sp(1)
	<.main+1141 @052ca9> : 13 01                      set.x32 sp(1)
	<.main+1143 @052cab> : 0c ff ff ff                inc.i32(-1)
	<.main+1147 @052caf> : 2e 38 14 05                store.m32 <@051438> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@052cb3> - <@052d05>): static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1151 @052cb3> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1155 @052cb7> : 0c 01 00 00                inc.i32(+1)
	<.main+1159 @052cbb> : 10 00                      dup.x32 sp(0)
	<.main+1161 @052cbd> : 06 0a 00 00                jz <.main+1171 @052cc7>
	<.main+1165 @052cc1> : 10 00                      dup.x32 sp(0)
	<.main+1167 @052cc3> : 04 0c 00 00                jmp <.main+1179 @052ccf>
	<.main+1171 @052cc7> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1175 @052ccb> : 0c 01 00 00                inc.i32(+1)
	<.main+1179 @052ccf> : 13 01                      set.x32 sp(1)
	<.main+1181 @052cd1> : 10 00                      dup.x32 sp(0)
	<.main+1183 @052cd3> : 06 0a 00 00                jz <.main+1193 @052cdd>
	<.main+1187 @052cd7> : 10 00                      dup.x32 sp(0)
	<.main+1189 @052cd9> : 04 0c 00 00                jmp <.main+1201 @052ce5>
	<.main+1193 @052cdd> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1197 @052ce1> : 0c 01 00 00                inc.i32(+1)
	<.main+1201 @052ce5> : 13 01                      set.x32 sp(1)
	<.main+1203 @052ce7> : 10 00                      dup.x32 sp(0)
	<.main+1205 @052ce9> : 06 0a 00 00                jz <.main+1215 @052cf3>
	<.main+1209 @052ced> : 10 00                      dup.x32 sp(0)
	<.main+1211 @052cef> : 04 0c 00 00                jmp <.main+1223 @052cfb>
	<.main+1215 @052cf3> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1219 @052cf7> : 0c 01 00 00                inc.i32(+1)
	<.main+1223 @052cfb> : 13 01                      set.x32 sp(1)
	<.main+1225 @052cfd> : 0c ff ff ff                inc.i32(-1)
	<.main+1229 @052d01> : 2e 40 14 05                store.m32 <@051440> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@052d05> - <@052d62>): static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1233 @052d05> : 1c 03 00 00 00             load.c32 3
	<.main+1238 @052d0a> : 1c 06 00 00 00             load.c32 6
	<.main+1243 @052d0f> : 1c 02 00 00 00             load.c32 2
	<.main+1248 @052d14> : 1c 08 00 00 00             load.c32 8
	<.main+1253 @052d19> : 10 01                      dup.x32 sp(1)
	<.main+1255 @052d1b> : 10 01                      dup.x32 sp(1)
	<.main+1257 @052d1d> : 58                         clt.i32
	<.main+1258 @052d1e> : 06 0a 00 00                jz <.main+1268 @052d28>
	<.main+1262 @052d22> : 10 01                      dup.x32 sp(1)
	<.main+1264 @052d24> : 04 06 00 00                jmp <.main+1270 @052d2a>
	<.main+1268 @052d28> : 10 00                      dup.x32 sp(0)
	<.main+1270 @052d2a> : 13 02                      set.x32 sp(2)
	<.main+1272 @052d2c> : 09 fc ff ff                inc.sp(-4)
	<.main+1276 @052d30> : 10 01                      dup.x32 sp(1)
	<.main+1278 @052d32> : 10 01                      dup.x32 sp(1)
	<.main+1280 @052d34> : 58                         clt.i32
	<.main+1281 @052d35> : 06 0a 00 00                jz <.main+1291 @052d3f>
	<.main+1285 @052d39> : 10 01                      dup.x32 sp(1)
	<.main+1287 @052d3b> : 04 06 00 00                jmp <.main+1293 @052d41>
	<.main+1291 @052d3f> : 10 00                      dup.x32 sp(0)
	<.main+1293 @052d41> : 13 02                      set.x32 sp(2)
	<.main+1295 @052d43> : 09 fc ff ff                inc.sp(-4)
	<.main+1299 @052d47> : 10 01                      dup.x32 sp(1)
	<.main+1301 @052d49> : 10 01                      dup.x32 sp(1)
	<.main+1303 @052d4b> : 58                         clt.i32
	<.main+1304 @052d4c> : 06 0a 00 00                jz <.main+1314 @052d56>
	<.main+1308 @052d50> : 10 01                      dup.x32 sp(1)
	<.main+1310 @052d52> : 04 06 00 00                jmp <.main+1316 @052d58>
	<.main+1314 @052d56> : 10 00                      dup.x32 sp(0)
	<.main+1316 @052d58> : 13 02                      set.x32 sp(2)
	<.main+1318 @052d5a> : 09 fc ff ff                inc.sp(-4)
	<.main+1322 @052d5e> : 2e 48 14 05                store.m32 <@051448> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@052d62> - <@052dbf>): static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1326 @052d62> : 1c 03 00 00 00             load.c32 3
	<.main+1331 @052d67> : 1c 06 00 00 00             load.c32 6
	<.main+1336 @052d6c> : 10 01                      dup.x32 sp(1)
	<.main+1338 @052d6e> : 10 01                      dup.x32 sp(1)
	<.main+1340 @052d70> : 58                         clt.i32
	<.main+1341 @052d71> : 06 0a 00 00                jz <.main+1351 @052d7b>
	<.main+1345 @052d75> : 10 01                      dup.x32 sp(1)
	<.main+1347 @052d77> : 04 06 00 00                jmp <.main+1353 @052d7d>
	<.main+1351 @052d7b> : 10 00                      dup.x32 sp(0)
	<.main+1353 @052d7d> : 13 02                      set.x32 sp(2)
	<.main+1355 @052d7f> : 09 fc ff ff                inc.sp(-4)
	<.main+1359 @052d83> : 1c 02 00 00 00             load.c32 2
	<.main+1364 @052d88> : 10 01                      dup.x32 sp(1)
	<.main+1366 @052d8a> : 10 01                      dup.x32 sp(1)
	<.main+1368 @052d8c> : 58                         clt.i32
	<.main+1369 @052d8d> : 06 0a 00 00                jz <.main+1379 @052d97>
	<.main+1373 @052d91> : 10 01                      dup.x32 sp(1)
	<.main+1375 @052d93> : 04 06 00 00                jmp <.main+1381 @052d99>
	<.main+1379 @052d97> : 10 00                      dup.x32 sp(0)
	<.main+1381 @052d99> : 13 02                      set.x32 sp(2)
	<.main+1383 @052d9b> : 09 fc ff ff                inc.sp(-4)
	<.main+1387 @052d9f> : 1c 08 00 00 00             load.c32 8
	<.main+1392 @052da4> : 10 01                      dup.x32 sp(1)
	<.main+1394 @052da6> : 10 01                      dup.x32 sp(1)
	<.main+1396 @052da8> : 58                         clt.i32
	<.main+1397 @052da9> : 06 0a 00 00                jz <.main+1407 @052db3>
	<.main+1401 @052dad> : 10 01                      dup.x32 sp(1)
	<.main+1403 @052daf> : 04 06 00 00                jmp <.main+1409 @052db5>
	<.main+1407 @052db3> : 10 00                      dup.x32 sp(0)
	<.main+1409 @052db5> : 13 02                      set.x32 sp(2)
	<.main+1411 @052db7> : 09 fc ff ff                inc.sp(-4)
	<.main+1415 @052dbb> : 2e 50 14 05                store.m32 <@051450> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@052dbf> - <@052e18>): static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1419 @052dbf> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1423 @052dc3> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1427 @052dc7> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1431 @052dcb> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1435 @052dcf> : 10 01                      dup.x32 sp(1)
	<.main+1437 @052dd1> : 10 01                      dup.x32 sp(1)
	<.main+1439 @052dd3> : 58                         clt.i32
	<.main+1440 @052dd4> : 06 0a 00 00                jz <.main+1450 @052dde>
	<.main+1444 @052dd8> : 10 01                      dup.x32 sp(1)
	<.main+1446 @052dda> : 04 06 00 00                jmp <.main+1452 @052de0>
	<.main+1450 @052dde> : 10 00                      dup.x32 sp(0)
	<.main+1452 @052de0> : 13 02                      set.x32 sp(2)
	<.main+1454 @052de2> : 09 fc ff ff                inc.sp(-4)
	<.main+1458 @052de6> : 10 01                      dup.x32 sp(1)
	<.main+1460 @052de8> : 10 01                      dup.x32 sp(1)
	<.main+1462 @052dea> : 58                         clt.i32
	<.main+1463 @052deb> : 06 0a 00 00                jz <.main+1473 @052df5>
	<.main+1467 @052def> : 10 01                      dup.x32 sp(1)
	<.main+1469 @052df1> : 04 06 00 00                jmp <.main+1475 @052df7>
	<.main+1473 @052df5> : 10 00                      dup.x32 sp(0)
	<.main+1475 @052df7> : 13 02                      set.x32 sp(2)
	<.main+1477 @052df9> : 09 fc ff ff                inc.sp(-4)
	<.main+1481 @052dfd> : 10 01                      dup.x32 sp(1)
	<.main+1483 @052dff> : 10 01                      dup.x32 sp(1)
	<.main+1485 @052e01> : 58                         clt.i32
	<.main+1486 @052e02> : 06 0a 00 00                jz <.main+1496 @052e0c>
	<.main+1490 @052e06> : 10 01                      dup.x32 sp(1)
	<.main+1492 @052e08> : 04 06 00 00                jmp <.main+1498 @052e0e>
	<.main+1496 @052e0c> : 10 00                      dup.x32 sp(0)
	<.main+1498 @052e0e> : 13 02                      set.x32 sp(2)
	<.main+1500 @052e10> : 09 fc ff ff                inc.sp(-4)
	<.main+1504 @052e14> : 2e 58 14 05                store.m32 <@051458> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@052e18> - <@052e71>): static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1508 @052e18> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1512 @052e1c> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1516 @052e20> : 10 01                      dup.x32 sp(1)
	<.main+1518 @052e22> : 10 01                      dup.x32 sp(1)
	<.main+1520 @052e24> : 58                         clt.i32
	<.main+1521 @052e25> : 06 0a 00 00                jz <.main+1531 @052e2f>
	<.main+1525 @052e29> : 10 01                      dup.x32 sp(1)
	<.main+1527 @052e2b> : 04 06 00 00                jmp <.main+1533 @052e31>
	<.main+1531 @052e2f> : 10 00                      dup.x32 sp(0)
	<.main+1533 @052e31> : 13 02                      set.x32 sp(2)
	<.main+1535 @052e33> : 09 fc ff ff                inc.sp(-4)
	<.main+1539 @052e37> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1543 @052e3b> : 10 01                      dup.x32 sp(1)
	<.main+1545 @052e3d> : 10 01                      dup.x32 sp(1)
	<.main+1547 @052e3f> : 58                         clt.i32
	<.main+1548 @052e40> : 06 0a 00 00                jz <.main+1558 @052e4a>
	<.main+1552 @052e44> : 10 01                      dup.x32 sp(1)
	<.main+1554 @052e46> : 04 06 00 00                jmp <.main+1560 @052e4c>
	<.main+1558 @052e4a> : 10 00                      dup.x32 sp(0)
	<.main+1560 @052e4c> : 13 02                      set.x32 sp(2)
	<.main+1562 @052e4e> : 09 fc ff ff                inc.sp(-4)
	<.main+1566 @052e52> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1570 @052e56> : 10 01                      dup.x32 sp(1)
	<.main+1572 @052e58> : 10 01                      dup.x32 sp(1)
	<.main+1574 @052e5a> : 58                         clt.i32
	<.main+1575 @052e5b> : 06 0a 00 00                jz <.main+1585 @052e65>
	<.main+1579 @052e5f> : 10 01                      dup.x32 sp(1)
	<.main+1581 @052e61> : 04 06 00 00                jmp <.main+1587 @052e67>
	<.main+1585 @052e65> : 10 00                      dup.x32 sp(0)
	<.main+1587 @052e67> : 13 02                      set.x32 sp(2)
	<.main+1589 @052e69> : 09 fc ff ff                inc.sp(-4)
	<.main+1593 @052e6d> : 2e 60 14 05                store.m32 <@051460> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@052e71> - <@052ede>): static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1597 @052e71> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1601 @052e75> : 0c 01 00 00                inc.i32(+1)
	<.main+1605 @052e79> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1609 @052e7d> : 0c 01 00 00                inc.i32(+1)
	<.main+1613 @052e81> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1617 @052e85> : 0c 01 00 00                inc.i32(+1)
	<.main+1621 @052e89> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1625 @052e8d> : 0c 01 00 00                inc.i32(+1)
	<.main+1629 @052e91> : 10 01                      dup.x32 sp(1)
	<.main+1631 @052e93> : 10 01                      dup.x32 sp(1)
	<.main+1633 @052e95> : 58                         clt.i32
	<.main+1634 @052e96> : 06 0a 00 00                jz <.main+1644 @052ea0>
	<.main+1638 @052e9a> : 10 01                      dup.x32 sp(1)
	<.main+1640 @052e9c> : 04 06 00 00                jmp <.main+1646 @052ea2>
	<.main+1644 @052ea0> : 10 00                      dup.x32 sp(0)
	<.main+1646 @052ea2> : 13 02                      set.x32 sp(2)
	<.main+1648 @052ea4> : 09 fc ff ff                inc.sp(-4)
	<.main+1652 @052ea8> : 10 01                      dup.x32 sp(1)
	<.main+1654 @052eaa> : 10 01                      dup.x32 sp(1)
	<.main+1656 @052eac> : 58                         clt.i32
	<.main+1657 @052ead> : 06 0a 00 00                jz <.main+1667 @052eb7>
	<.main+1661 @052eb1> : 10 01                      dup.x32 sp(1)
	<.main+1663 @052eb3> : 04 06 00 00                jmp <.main+1669 @052eb9>
	<.main+1667 @052eb7> : 10 00                      dup.x32 sp(0)
	<.main+1669 @052eb9> : 13 02                      set.x32 sp(2)
	<.main+1671 @052ebb> : 09 fc ff ff                inc.sp(-4)
	<.main+1675 @052ebf> : 10 01                      dup.x32 sp(1)
	<.main+1677 @052ec1> : 10 01                      dup.x32 sp(1)
	<.main+1679 @052ec3> : 58                         clt.i32
	<.main+1680 @052ec4> : 06 0a 00 00                jz <.main+1690 @052ece>
	<.main+1684 @052ec8> : 10 01                      dup.x32 sp(1)
	<.main+1686 @052eca> : 04 06 00 00                jmp <.main+1692 @052ed0>
	<.main+1690 @052ece> : 10 00                      dup.x32 sp(0)
	<.main+1692 @052ed0> : 13 02                      set.x32 sp(2)
	<.main+1694 @052ed2> : 09 fc ff ff                inc.sp(-4)
	<.main+1698 @052ed6> : 0c ff ff ff                inc.i32(-1)
	<.main+1702 @052eda> : 2e 68 14 05                store.m32 <@051468> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@052ede> - <@052f4b>): static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1706 @052ede> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+1710 @052ee2> : 0c 01 00 00                inc.i32(+1)
	<.main+1714 @052ee6> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+1718 @052eea> : 0c 01 00 00                inc.i32(+1)
	<.main+1722 @052eee> : 10 01                      dup.x32 sp(1)
	<.main+1724 @052ef0> : 10 01                      dup.x32 sp(1)
	<.main+1726 @052ef2> : 58                         clt.i32
	<.main+1727 @052ef3> : 06 0a 00 00                jz <.main+1737 @052efd>
	<.main+1731 @052ef7> : 10 01                      dup.x32 sp(1)
	<.main+1733 @052ef9> : 04 06 00 00                jmp <.main+1739 @052eff>
	<.main+1737 @052efd> : 10 00                      dup.x32 sp(0)
	<.main+1739 @052eff> : 13 02                      set.x32 sp(2)
	<.main+1741 @052f01> : 09 fc ff ff                inc.sp(-4)
	<.main+1745 @052f05> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+1749 @052f09> : 0c 01 00 00                inc.i32(+1)
	<.main+1753 @052f0d> : 10 01                      dup.x32 sp(1)
	<.main+1755 @052f0f> : 10 01                      dup.x32 sp(1)
	<.main+1757 @052f11> : 58                         clt.i32
	<.main+1758 @052f12> : 06 0a 00 00                jz <.main+1768 @052f1c>
	<.main+1762 @052f16> : 10 01                      dup.x32 sp(1)
	<.main+1764 @052f18> : 04 06 00 00                jmp <.main+1770 @052f1e>
	<.main+1768 @052f1c> : 10 00                      dup.x32 sp(0)
	<.main+1770 @052f1e> : 13 02                      set.x32 sp(2)
	<.main+1772 @052f20> : 09 fc ff ff                inc.sp(-4)
	<.main+1776 @052f24> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+1780 @052f28> : 0c 01 00 00                inc.i32(+1)
	<.main+1784 @052f2c> : 10 01                      dup.x32 sp(1)
	<.main+1786 @052f2e> : 10 01                      dup.x32 sp(1)
	<.main+1788 @052f30> : 58                         clt.i32
	<.main+1789 @052f31> : 06 0a 00 00                jz <.main+1799 @052f3b>
	<.main+1793 @052f35> : 10 01                      dup.x32 sp(1)
	<.main+1795 @052f37> : 04 06 00 00                jmp <.main+1801 @052f3d>
	<.main+1799 @052f3b> : 10 00                      dup.x32 sp(0)
	<.main+1801 @052f3d> : 13 02                      set.x32 sp(2)
	<.main+1803 @052f3f> : 09 fc ff ff                inc.sp(-4)
	<.main+1807 @052f43> : 0c ff ff ff                inc.i32(-1)
	<.main+1811 @052f47> : 2e 70 14 05                store.m32 <@051470> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@052f4b> - <@052fa8>): static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1815 @052f4b> : 1c 03 00 00 00             load.c32 3
	<.main+1820 @052f50> : 1c 06 00 00 00             load.c32 6
	<.main+1825 @052f55> : 1c 02 00 00 00             load.c32 2
	<.main+1830 @052f5a> : 1c 08 00 00 00             load.c32 8
	<.main+1835 @052f5f> : 10 01                      dup.x32 sp(1)
	<.main+1837 @052f61> : 10 01                      dup.x32 sp(1)
	<.main+1839 @052f63> : 59                         cgt.i32
	<.main+1840 @052f64> : 06 0a 00 00                jz <.main+1850 @052f6e>
	<.main+1844 @052f68> : 10 01                      dup.x32 sp(1)
	<.main+1846 @052f6a> : 04 06 00 00                jmp <.main+1852 @052f70>
	<.main+1850 @052f6e> : 10 00                      dup.x32 sp(0)
	<.main+1852 @052f70> : 13 02                      set.x32 sp(2)
	<.main+1854 @052f72> : 09 fc ff ff                inc.sp(-4)
	<.main+1858 @052f76> : 10 01                      dup.x32 sp(1)
	<.main+1860 @052f78> : 10 01                      dup.x32 sp(1)
	<.main+1862 @052f7a> : 59                         cgt.i32
	<.main+1863 @052f7b> : 06 0a 00 00                jz <.main+1873 @052f85>
	<.main+1867 @052f7f> : 10 01                      dup.x32 sp(1)
	<.main+1869 @052f81> : 04 06 00 00                jmp <.main+1875 @052f87>
	<.main+1873 @052f85> : 10 00                      dup.x32 sp(0)
	<.main+1875 @052f87> : 13 02                      set.x32 sp(2)
	<.main+1877 @052f89> : 09 fc ff ff                inc.sp(-4)
	<.main+1881 @052f8d> : 10 01                      dup.x32 sp(1)
	<.main+1883 @052f8f> : 10 01                      dup.x32 sp(1)
	<.main+1885 @052f91> : 59                         cgt.i32
	<.main+1886 @052f92> : 06 0a 00 00                jz <.main+1896 @052f9c>
	<.main+1890 @052f96> : 10 01                      dup.x32 sp(1)
	<.main+1892 @052f98> : 04 06 00 00                jmp <.main+1898 @052f9e>
	<.main+1896 @052f9c> : 10 00                      dup.x32 sp(0)
	<.main+1898 @052f9e> : 13 02                      set.x32 sp(2)
	<.main+1900 @052fa0> : 09 fc ff ff                inc.sp(-4)
	<.main+1904 @052fa4> : 2e 78 14 05                store.m32 <@051478> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@052fa8> - <@053005>): static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1908 @052fa8> : 1c 03 00 00 00             load.c32 3
	<.main+1913 @052fad> : 1c 06 00 00 00             load.c32 6
	<.main+1918 @052fb2> : 10 01                      dup.x32 sp(1)
	<.main+1920 @052fb4> : 10 01                      dup.x32 sp(1)
	<.main+1922 @052fb6> : 59                         cgt.i32
	<.main+1923 @052fb7> : 06 0a 00 00                jz <.main+1933 @052fc1>
	<.main+1927 @052fbb> : 10 01                      dup.x32 sp(1)
	<.main+1929 @052fbd> : 04 06 00 00                jmp <.main+1935 @052fc3>
	<.main+1933 @052fc1> : 10 00                      dup.x32 sp(0)
	<.main+1935 @052fc3> : 13 02                      set.x32 sp(2)
	<.main+1937 @052fc5> : 09 fc ff ff                inc.sp(-4)
	<.main+1941 @052fc9> : 1c 02 00 00 00             load.c32 2
	<.main+1946 @052fce> : 10 01                      dup.x32 sp(1)
	<.main+1948 @052fd0> : 10 01                      dup.x32 sp(1)
	<.main+1950 @052fd2> : 59                         cgt.i32
	<.main+1951 @052fd3> : 06 0a 00 00                jz <.main+1961 @052fdd>
	<.main+1955 @052fd7> : 10 01                      dup.x32 sp(1)
	<.main+1957 @052fd9> : 04 06 00 00                jmp <.main+1963 @052fdf>
	<.main+1961 @052fdd> : 10 00                      dup.x32 sp(0)
	<.main+1963 @052fdf> : 13 02                      set.x32 sp(2)
	<.main+1965 @052fe1> : 09 fc ff ff                inc.sp(-4)
	<.main+1969 @052fe5> : 1c 08 00 00 00             load.c32 8
	<.main+1974 @052fea> : 10 01                      dup.x32 sp(1)
	<.main+1976 @052fec> : 10 01                      dup.x32 sp(1)
	<.main+1978 @052fee> : 59                         cgt.i32
	<.main+1979 @052fef> : 06 0a 00 00                jz <.main+1989 @052ff9>
	<.main+1983 @052ff3> : 10 01                      dup.x32 sp(1)
	<.main+1985 @052ff5> : 04 06 00 00                jmp <.main+1991 @052ffb>
	<.main+1989 @052ff9> : 10 00                      dup.x32 sp(0)
	<.main+1991 @052ffb> : 13 02                      set.x32 sp(2)
	<.main+1993 @052ffd> : 09 fc ff ff                inc.sp(-4)
	<.main+1997 @053001> : 2e 80 14 05                store.m32 <@051480> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@053005> - <@05305e>): static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+2001 @053005> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+2005 @053009> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+2009 @05300d> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+2013 @053011> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+2017 @053015> : 10 01                      dup.x32 sp(1)
	<.main+2019 @053017> : 10 01                      dup.x32 sp(1)
	<.main+2021 @053019> : 59                         cgt.i32
	<.main+2022 @05301a> : 06 0a 00 00                jz <.main+2032 @053024>
	<.main+2026 @05301e> : 10 01                      dup.x32 sp(1)
	<.main+2028 @053020> : 04 06 00 00                jmp <.main+2034 @053026>
	<.main+2032 @053024> : 10 00                      dup.x32 sp(0)
	<.main+2034 @053026> : 13 02                      set.x32 sp(2)
	<.main+2036 @053028> : 09 fc ff ff                inc.sp(-4)
	<.main+2040 @05302c> : 10 01                      dup.x32 sp(1)
	<.main+2042 @05302e> : 10 01                      dup.x32 sp(1)
	<.main+2044 @053030> : 59                         cgt.i32
	<.main+2045 @053031> : 06 0a 00 00                jz <.main+2055 @05303b>
	<.main+2049 @053035> : 10 01                      dup.x32 sp(1)
	<.main+2051 @053037> : 04 06 00 00                jmp <.main+2057 @05303d>
	<.main+2055 @05303b> : 10 00                      dup.x32 sp(0)
	<.main+2057 @05303d> : 13 02                      set.x32 sp(2)
	<.main+2059 @05303f> : 09 fc ff ff                inc.sp(-4)
	<.main+2063 @053043> : 10 01                      dup.x32 sp(1)
	<.main+2065 @053045> : 10 01                      dup.x32 sp(1)
	<.main+2067 @053047> : 59                         cgt.i32
	<.main+2068 @053048> : 06 0a 00 00                jz <.main+2078 @053052>
	<.main+2072 @05304c> : 10 01                      dup.x32 sp(1)
	<.main+2074 @05304e> : 04 06 00 00                jmp <.main+2080 @053054>
	<.main+2078 @053052> : 10 00                      dup.x32 sp(0)
	<.main+2080 @053054> : 13 02                      set.x32 sp(2)
	<.main+2082 @053056> : 09 fc ff ff                inc.sp(-4)
	<.main+2086 @05305a> : 2e 88 14 05                store.m32 <@051488> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@05305e> - <@0530b7>): static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+2090 @05305e> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+2094 @053062> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+2098 @053066> : 10 01                      dup.x32 sp(1)
	<.main+2100 @053068> : 10 01                      dup.x32 sp(1)
	<.main+2102 @05306a> : 59                         cgt.i32
	<.main+2103 @05306b> : 06 0a 00 00                jz <.main+2113 @053075>
	<.main+2107 @05306f> : 10 01                      dup.x32 sp(1)
	<.main+2109 @053071> : 04 06 00 00                jmp <.main+2115 @053077>
	<.main+2113 @053075> : 10 00                      dup.x32 sp(0)
	<.main+2115 @053077> : 13 02                      set.x32 sp(2)
	<.main+2117 @053079> : 09 fc ff ff                inc.sp(-4)
	<.main+2121 @05307d> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+2125 @053081> : 10 01                      dup.x32 sp(1)
	<.main+2127 @053083> : 10 01                      dup.x32 sp(1)
	<.main+2129 @053085> : 59                         cgt.i32
	<.main+2130 @053086> : 06 0a 00 00                jz <.main+2140 @053090>
	<.main+2134 @05308a> : 10 01                      dup.x32 sp(1)
	<.main+2136 @05308c> : 04 06 00 00                jmp <.main+2142 @053092>
	<.main+2140 @053090> : 10 00                      dup.x32 sp(0)
	<.main+2142 @053092> : 13 02                      set.x32 sp(2)
	<.main+2144 @053094> : 09 fc ff ff                inc.sp(-4)
	<.main+2148 @053098> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+2152 @05309c> : 10 01                      dup.x32 sp(1)
	<.main+2154 @05309e> : 10 01                      dup.x32 sp(1)
	<.main+2156 @0530a0> : 59                         cgt.i32
	<.main+2157 @0530a1> : 06 0a 00 00                jz <.main+2167 @0530ab>
	<.main+2161 @0530a5> : 10 01                      dup.x32 sp(1)
	<.main+2163 @0530a7> : 04 06 00 00                jmp <.main+2169 @0530ad>
	<.main+2167 @0530ab> : 10 00                      dup.x32 sp(0)
	<.main+2169 @0530ad> : 13 02                      set.x32 sp(2)
	<.main+2171 @0530af> : 09 fc ff ff                inc.sp(-4)
	<.main+2175 @0530b3> : 2e 90 14 05                store.m32 <@051490> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@0530b7> - <@053124>): static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2179 @0530b7> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+2183 @0530bb> : 0c 01 00 00                inc.i32(+1)
	<.main+2187 @0530bf> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+2191 @0530c3> : 0c 01 00 00                inc.i32(+1)
	<.main+2195 @0530c7> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+2199 @0530cb> : 0c 01 00 00                inc.i32(+1)
	<.main+2203 @0530cf> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+2207 @0530d3> : 0c 01 00 00                inc.i32(+1)
	<.main+2211 @0530d7> : 10 01                      dup.x32 sp(1)
	<.main+2213 @0530d9> : 10 01                      dup.x32 sp(1)
	<.main+2215 @0530db> : 59                         cgt.i32
	<.main+2216 @0530dc> : 06 0a 00 00                jz <.main+2226 @0530e6>
	<.main+2220 @0530e0> : 10 01                      dup.x32 sp(1)
	<.main+2222 @0530e2> : 04 06 00 00                jmp <.main+2228 @0530e8>
	<.main+2226 @0530e6> : 10 00                      dup.x32 sp(0)
	<.main+2228 @0530e8> : 13 02                      set.x32 sp(2)
	<.main+2230 @0530ea> : 09 fc ff ff                inc.sp(-4)
	<.main+2234 @0530ee> : 10 01                      dup.x32 sp(1)
	<.main+2236 @0530f0> : 10 01                      dup.x32 sp(1)
	<.main+2238 @0530f2> : 59                         cgt.i32
	<.main+2239 @0530f3> : 06 0a 00 00                jz <.main+2249 @0530fd>
	<.main+2243 @0530f7> : 10 01                      dup.x32 sp(1)
	<.main+2245 @0530f9> : 04 06 00 00                jmp <.main+2251 @0530ff>
	<.main+2249 @0530fd> : 10 00                      dup.x32 sp(0)
	<.main+2251 @0530ff> : 13 02                      set.x32 sp(2)
	<.main+2253 @053101> : 09 fc ff ff                inc.sp(-4)
	<.main+2257 @053105> : 10 01                      dup.x32 sp(1)
	<.main+2259 @053107> : 10 01                      dup.x32 sp(1)
	<.main+2261 @053109> : 59                         cgt.i32
	<.main+2262 @05310a> : 06 0a 00 00                jz <.main+2272 @053114>
	<.main+2266 @05310e> : 10 01                      dup.x32 sp(1)
	<.main+2268 @053110> : 04 06 00 00                jmp <.main+2274 @053116>
	<.main+2272 @053114> : 10 00                      dup.x32 sp(0)
	<.main+2274 @053116> : 13 02                      set.x32 sp(2)
	<.main+2276 @053118> : 09 fc ff ff                inc.sp(-4)
	<.main+2280 @05311c> : 0c ff ff ff                inc.i32(-1)
	<.main+2284 @053120> : 2e 98 14 05                store.m32 <@051498> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@053124> - <@053191>): static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2288 @053124> : 2a 38 13 05                load.m32 <@051338> ;i3
	<.main+2292 @053128> : 0c 01 00 00                inc.i32(+1)
	<.main+2296 @05312c> : 2a 40 13 05                load.m32 <@051340> ;i6
	<.main+2300 @053130> : 0c 01 00 00                inc.i32(+1)
	<.main+2304 @053134> : 10 01                      dup.x32 sp(1)
	<.main+2306 @053136> : 10 01                      dup.x32 sp(1)
	<.main+2308 @053138> : 59                         cgt.i32
	<.main+2309 @053139> : 06 0a 00 00                jz <.main+2319 @053143>
	<.main+2313 @05313d> : 10 01                      dup.x32 sp(1)
	<.main+2315 @05313f> : 04 06 00 00                jmp <.main+2321 @053145>
	<.main+2319 @053143> : 10 00                      dup.x32 sp(0)
	<.main+2321 @053145> : 13 02                      set.x32 sp(2)
	<.main+2323 @053147> : 09 fc ff ff                inc.sp(-4)
	<.main+2327 @05314b> : 2a 48 13 05                load.m32 <@051348> ;i2
	<.main+2331 @05314f> : 0c 01 00 00                inc.i32(+1)
	<.main+2335 @053153> : 10 01                      dup.x32 sp(1)
	<.main+2337 @053155> : 10 01                      dup.x32 sp(1)
	<.main+2339 @053157> : 59                         cgt.i32
	<.main+2340 @053158> : 06 0a 00 00                jz <.main+2350 @053162>
	<.main+2344 @05315c> : 10 01                      dup.x32 sp(1)
	<.main+2346 @05315e> : 04 06 00 00                jmp <.main+2352 @053164>
	<.main+2350 @053162> : 10 00                      dup.x32 sp(0)
	<.main+2352 @053164> : 13 02                      set.x32 sp(2)
	<.main+2354 @053166> : 09 fc ff ff                inc.sp(-4)
	<.main+2358 @05316a> : 2a 50 13 05                load.m32 <@051350> ;i8
	<.main+2362 @05316e> : 0c 01 00 00                inc.i32(+1)
	<.main+2366 @053172> : 10 01                      dup.x32 sp(1)
	<.main+2368 @053174> : 10 01                      dup.x32 sp(1)
	<.main+2370 @053176> : 59                         cgt.i32
	<.main+2371 @053177> : 06 0a 00 00                jz <.main+2381 @053181>
	<.main+2375 @05317b> : 10 01                      dup.x32 sp(1)
	<.main+2377 @05317d> : 04 06 00 00                jmp <.main+2383 @053183>
	<.main+2381 @053181> : 10 00                      dup.x32 sp(0)
	<.main+2383 @053183> : 13 02                      set.x32 sp(2)
	<.main+2385 @053185> : 09 fc ff ff                inc.sp(-4)
	<.main+2389 @053189> : 0c ff ff ff                inc.i32(-1)
	<.main+2393 @05318d> : 2e a0 14 05                store.m32 <@0514a0> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@053191> - <@05319a>): static overload1: float32 := overload
	<.main+2397 @053191> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2402 @053196> : 2e a8 14 05                store.m32 <@0514a8> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@05319a> - <@0531a3>): static overload2: float32 := overload()
	<.main+2406 @05319a> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2411 @05319f> : 2e b0 14 05                store.m32 <@0514b0> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@0531a3> - <@0531ac>): static overload3: float32 := overload(0)
	<.main+2415 @0531a3> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2420 @0531a8> : 2e b8 14 05                store.m32 <@0514b8> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@0531ac> - <@0531b5>): static overload4: float32 := overload(0.000000)
	<.main+2424 @0531ac> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2429 @0531b1> : 2e c0 14 05                store.m32 <@0514c0> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@0531b5> - <@0531be>): static overload5: float32 := overload(void(0, 0))
	<.main+2433 @0531b5> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2438 @0531ba> : 2e c8 14 05                store.m32 <@0514c8> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@0531be> - <@0531cb>): static boilC: Celsius := Celsius(100.000000)
	<.main+2442 @0531be> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2451 @0531c7> : 2d d0 14 05                store.m64 <@0514d0> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@0531cb> - <@0531e7>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2455 @0531cb> : 2b d0 14 05                load.m64 <@0514d0> ;boilC
	<.main+2459 @0531cf> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2468 @0531d8> : 83                         mul.f64
	<.main+2469 @0531d9> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2478 @0531e2> : 81                         add.f64
	<.main+2479 @0531e3> : 2d d8 14 05                store.m64 <@0514d8> ;boilF
	test/lang/initByRef.ci:7: (13 bytes: <@0531e7> - <@0531f4>): static value: int64 := 42
	<.main+2483 @0531e7> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+2492 @0531f0> : 2d e0 14 05                store.m64 <@0514e0> ;value
	test/lang/initByRef.ci:8: (9 bytes: <@0531f4> - <@0531fd>): static valueRef: int64 := value
	<.main+2496 @0531f4> : 1f e0 14 05 00             load.ref <@0514e0> ;value
	<.main+2501 @0531f9> : 2e e8 14 05                store.m32 <@0514e8> ;valueRef
	test/lang/initByRef.ci:9: (9 bytes: <@0531fd> - <@053206>): static valuePtr: pointer := value
	<.main+2505 @0531fd> : 1f e0 14 05 00             load.ref <@0514e0> ;value
	<.main+2510 @053202> : 2e f0 14 05                store.m32 <@0514f0> ;valuePtr
	test/lang/initByRef.ci:10: (14 bytes: <@053206> - <@053214>): static valueVar: variant := value
	<.main+2514 @053206> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2519 @05320b> : 1f e0 14 05 00             load.ref <@0514e0> ;value
	<.main+2524 @053210> : 2d f8 14 05                store.m64 <@0514f8> ;valueVar
	test/lang/initByRef.ci:12: (9 bytes: <@053214> - <@05321d>): static fromRef: int64 := valueRef
	<.main+2528 @053214> : 2a e8 14 05                load.m32 <@0514e8> ;valueRef
	<.main+2532 @053218> : 23                         load.i64
	<.main+2533 @053219> : 2d 00 15 05                store.m64 <@051500> ;fromRef
	test/lang/initByRef.ci:13: (8 bytes: <@05321d> - <@053225>): static fromPtr: int64 := valuePtr
	<.main+2537 @05321d> : 2a f0 14 05                load.m32 <@0514f0> ;valuePtr
	<.main+2541 @053221> : 2e 08 15 05                store.m32 <@051508> ;fromPtr
	test/lang/initByRef.ci:14: (8 bytes: <@053225> - <@05322d>): static fromVar: int64 := valueVar
	<.main+2545 @053225> : 2a f8 14 05                load.m32 <@0514f8> ;valueVar
	<.main+2549 @053229> : 2e 10 15 05                store.m32 <@051510> ;fromVar
	test/lang/initByRef.ci:16: (9 bytes: <@05322d> - <@053236>): static nullRef: int64 := null
	<.main+2553 @05322d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2558 @053232> : 2e 18 15 05                store.m32 <@051518> ;nullRef
	test/lang/initByRef.ci:17: (9 bytes: <@053236> - <@05323f>): static nullPtr: pointer := null
	<.main+2562 @053236> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2567 @05323b> : 2e 20 15 05                store.m32 <@051520> ;nullPtr
	test/lang/initByRef.ci:18: (14 bytes: <@05323f> - <@05324d>): static nullVar: variant := null
	<.main+2571 @05323f> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2576 @053244> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2581 @053249> : 2d 28 15 05                store.m64 <@051528> ;nullVar
	test/lang/initByRef.ci:19: (9 bytes: <@05324d> - <@053256>): static nullTyp: typename := null
	<.main+2585 @05324d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2590 @053252> : 2e 30 15 05                store.m32 <@051530> ;nullTyp
	test/lang/initByRef.ci:20: (9 bytes: <@053256> - <@05325f>): static nullFun: function := null
	<.main+2594 @053256> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2599 @05325b> : 2e 38 15 05                store.m32 <@051538> ;nullFun
	test/lang/initByRef.ci:21: (9 bytes: <@05325f> - <@053268>): static nullObj: object := null
	<.main+2603 @05325f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2608 @053264> : 2e 40 15 05                store.m32 <@051540> ;nullObj
	test/lang/initByRef.ci:23: (9 bytes: <@053268> - <@053271>): static typePtr: pointer := int64
	<.main+2612 @053268> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2617 @05326d> : 2e 48 15 05                store.m32 <@051548> ;typePtr
	test/lang/initByRef.ci:24: (14 bytes: <@053271> - <@05327f>): static typeVar: variant := int64
	<.main+2621 @053271> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2626 @053276> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2631 @05327b> : 2d 50 15 05                store.m64 <@051550> ;typeVar
	test/lang/initByRef.ci:25: (9 bytes: <@05327f> - <@053288>): static typeTyp: typename := int64
	<.main+2635 @05327f> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2640 @053284> : 2e 58 15 05                store.m32 <@051558> ;typeTyp
	test/lang/initByRef.ci:27: (8 bytes: <@053288> - <@053290>): static local: int64 := value
	<.main+2644 @053288> : 2b e0 14 05                load.m64 <@0514e0> ;value
	<.main+2648 @05328c> : 2d 60 15 05                store.m64 <@051560> ;local
	test/lang/initByRef.ci:28: (8 bytes: <@053290> - <@053298>): static copyVal: int64 := local
	<.main+2652 @053290> : 2b 60 15 05                load.m64 <@051560> ;local
	<.main+2656 @053294> : 2d 68 15 05                store.m64 <@051568> ;copyVal
	test/lang/initByRef.ci:29: (8 bytes: <@053298> - <@0532a0>): static copyRef: int64 := valueRef
	<.main+2660 @053298> : 2a e8 14 05                load.m32 <@0514e8> ;valueRef
	<.main+2664 @05329c> : 2e 70 15 05                store.m32 <@051570> ;copyRef
	test/lang/initByRef.ci:30: (8 bytes: <@0532a0> - <@0532a8>): static copyPtr: pointer := valuePtr
	<.main+2668 @0532a0> : 2a f0 14 05                load.m32 <@0514f0> ;valuePtr
	<.main+2672 @0532a4> : 2e 78 15 05                store.m32 <@051578> ;copyPtr
	test/lang/initByRef.ci:31: (8 bytes: <@0532a8> - <@0532b0>): static copyVar: variant := valueVar
	<.main+2676 @0532a8> : 2b f8 14 05                load.m64 <@0514f8> ;valueVar
	<.main+2680 @0532ac> : 2d 80 15 05                store.m64 <@051580> ;copyVar
	test/lang/initByRef.ci:32: (8 bytes: <@0532b0> - <@0532b8>): static copyTyp: typename := typeTyp
	<.main+2684 @0532b0> : 2a 58 15 05                load.m32 <@051558> ;typeTyp
	<.main+2688 @0532b4> : 2e 88 15 05                store.m32 <@051588> ;copyTyp
	test/lang/initByRef.ci:35: (9 bytes: <@0532b8> - <@0532c1>): static ptrVoid: pointer := void
	<.main+2692 @0532b8> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2697 @0532bd> : 2e 90 15 05                store.m32 <@051590> ;ptrVoid
	test/lang/initByRef.ci:36: (9 bytes: <@0532c1> - <@0532ca>): static ptrBool: pointer := bool
	<.main+2701 @0532c1> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2706 @0532c6> : 2e 98 15 05                store.m32 <@051598> ;ptrBool
	test/lang/initByRef.ci:37: (9 bytes: <@0532ca> - <@0532d3>): static ptrChar: pointer := char
	<.main+2710 @0532ca> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2715 @0532cf> : 2e a0 15 05                store.m32 <@0515a0> ;ptrChar
	test/lang/initByRef.ci:38: (9 bytes: <@0532d3> - <@0532dc>): static ptrInt8: pointer := int8
	<.main+2719 @0532d3> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2724 @0532d8> : 2e a8 15 05                store.m32 <@0515a8> ;ptrInt8
	test/lang/initByRef.ci:39: (9 bytes: <@0532dc> - <@0532e5>): static ptrInt16: pointer := int16
	<.main+2728 @0532dc> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2733 @0532e1> : 2e b0 15 05                store.m32 <@0515b0> ;ptrInt16
	test/lang/initByRef.ci:40: (9 bytes: <@0532e5> - <@0532ee>): static ptrInt32: pointer := int32
	<.main+2737 @0532e5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2742 @0532ea> : 2e b8 15 05                store.m32 <@0515b8> ;ptrInt32
	test/lang/initByRef.ci:41: (9 bytes: <@0532ee> - <@0532f7>): static ptrInt64: pointer := int64
	<.main+2746 @0532ee> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2751 @0532f3> : 2e c0 15 05                store.m32 <@0515c0> ;ptrInt64
	test/lang/initByRef.ci:42: (9 bytes: <@0532f7> - <@053300>): static ptrUint8: pointer := uint8
	<.main+2755 @0532f7> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2760 @0532fc> : 2e c8 15 05                store.m32 <@0515c8> ;ptrUint8
	test/lang/initByRef.ci:43: (9 bytes: <@053300> - <@053309>): static ptrUint16: pointer := uint16
	<.main+2764 @053300> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2769 @053305> : 2e d0 15 05                store.m32 <@0515d0> ;ptrUint16
	test/lang/initByRef.ci:44: (9 bytes: <@053309> - <@053312>): static ptrUint32: pointer := uint32
	<.main+2773 @053309> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2778 @05330e> : 2e d8 15 05                store.m32 <@0515d8> ;ptrUint32
	test/lang/initByRef.ci:45: (9 bytes: <@053312> - <@05331b>): static ptrUint64: pointer := uint64
	<.main+2782 @053312> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+2787 @053317> : 2e e0 15 05                store.m32 <@0515e0> ;ptrUint64
	test/lang/initByRef.ci:46: (9 bytes: <@05331b> - <@053324>): static ptrFloat32: pointer := float32
	<.main+2791 @05331b> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+2796 @053320> : 2e e8 15 05                store.m32 <@0515e8> ;ptrFloat32
	test/lang/initByRef.ci:47: (9 bytes: <@053324> - <@05332d>): static ptrFloat64: pointer := float64
	<.main+2800 @053324> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+2805 @053329> : 2e f0 15 05                store.m32 <@0515f0> ;ptrFloat64
	test/lang/initByRef.ci:48: (9 bytes: <@05332d> - <@053336>): static ptrTypename: pointer := typename
	<.main+2809 @05332d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2814 @053332> : 2e f8 15 05                store.m32 <@0515f8> ;ptrTypename
	test/lang/initByRef.ci:49: (9 bytes: <@053336> - <@05333f>): static ptrFunction: pointer := function
	<.main+2818 @053336> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+2823 @05333b> : 2e 00 16 05                store.m32 <@051600> ;ptrFunction
	test/lang/initByRef.ci:50: (9 bytes: <@05333f> - <@053348>): static ptrPointer: pointer := pointer
	<.main+2827 @05333f> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2832 @053344> : 2e 08 16 05                store.m32 <@051608> ;ptrPointer
	test/lang/initByRef.ci:51: (9 bytes: <@053348> - <@053351>): static ptrVariant: pointer := variant
	<.main+2836 @053348> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+2841 @05334d> : 2e 10 16 05                store.m32 <@051610> ;ptrVariant
	test/lang/initByRef.ci:52: (9 bytes: <@053351> - <@05335a>): static ptrObject: pointer := object
	<.main+2845 @053351> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+2850 @053356> : 2e 18 16 05                store.m32 <@051618> ;ptrObject
	test/lang/initByRef.ci:55: (14 bytes: <@05335a> - <@053368>): static varVoid: variant := void
	<.main+2854 @05335a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2859 @05335f> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2864 @053364> : 2d 20 16 05                store.m64 <@051620> ;varVoid
	test/lang/initByRef.ci:56: (14 bytes: <@053368> - <@053376>): static varBool: variant := bool
	<.main+2868 @053368> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2873 @05336d> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2878 @053372> : 2d 28 16 05                store.m64 <@051628> ;varBool
	test/lang/initByRef.ci:57: (14 bytes: <@053376> - <@053384>): static varChar: variant := char
	<.main+2882 @053376> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2887 @05337b> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2892 @053380> : 2d 30 16 05                store.m64 <@051630> ;varChar
	test/lang/initByRef.ci:58: (14 bytes: <@053384> - <@053392>): static varInt8: variant := int8
	<.main+2896 @053384> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2901 @053389> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2906 @05338e> : 2d 38 16 05                store.m64 <@051638> ;varInt8
	test/lang/initByRef.ci:59: (14 bytes: <@053392> - <@0533a0>): static varInt16: variant := int16
	<.main+2910 @053392> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2915 @053397> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2920 @05339c> : 2d 40 16 05                store.m64 <@051640> ;varInt16
	test/lang/initByRef.ci:60: (14 bytes: <@0533a0> - <@0533ae>): static varInt32: variant := int32
	<.main+2924 @0533a0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2929 @0533a5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2934 @0533aa> : 2d 48 16 05                store.m64 <@051648> ;varInt32
	test/lang/initByRef.ci:61: (14 bytes: <@0533ae> - <@0533bc>): static varInt64: variant := int64
	<.main+2938 @0533ae> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2943 @0533b3> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2948 @0533b8> : 2d 50 16 05                store.m64 <@051650> ;varInt64
	test/lang/initByRef.ci:62: (14 bytes: <@0533bc> - <@0533ca>): static varUint8: variant := uint8
	<.main+2952 @0533bc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2957 @0533c1> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2962 @0533c6> : 2d 58 16 05                store.m64 <@051658> ;varUint8
	test/lang/initByRef.ci:63: (14 bytes: <@0533ca> - <@0533d8>): static varUint16: variant := uint16
	<.main+2966 @0533ca> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2971 @0533cf> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2976 @0533d4> : 2d 60 16 05                store.m64 <@051660> ;varUint16
	test/lang/initByRef.ci:64: (14 bytes: <@0533d8> - <@0533e6>): static varUint32: variant := uint32
	<.main+2980 @0533d8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2985 @0533dd> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2990 @0533e2> : 2d 68 16 05                store.m64 <@051668> ;varUint32
	test/lang/initByRef.ci:65: (14 bytes: <@0533e6> - <@0533f4>): static varUint64: variant := uint64
	<.main+2994 @0533e6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2999 @0533eb> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3004 @0533f0> : 2d 70 16 05                store.m64 <@051670> ;varUint64
	test/lang/initByRef.ci:66: (14 bytes: <@0533f4> - <@053402>): static varFloat32: variant := float32
	<.main+3008 @0533f4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3013 @0533f9> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3018 @0533fe> : 2d 78 16 05                store.m64 <@051678> ;varFloat32
	test/lang/initByRef.ci:67: (14 bytes: <@053402> - <@053410>): static varFloat64: variant := float64
	<.main+3022 @053402> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3027 @053407> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3032 @05340c> : 2d 80 16 05                store.m64 <@051680> ;varFloat64
	test/lang/initByRef.ci:68: (14 bytes: <@053410> - <@05341e>): static varTypename: variant := typename
	<.main+3036 @053410> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3041 @053415> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3046 @05341a> : 2d 88 16 05                store.m64 <@051688> ;varTypename
	test/lang/initByRef.ci:69: (14 bytes: <@05341e> - <@05342c>): static varFunction: variant := function
	<.main+3050 @05341e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3055 @053423> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3060 @053428> : 2d 90 16 05                store.m64 <@051690> ;varFunction
	test/lang/initByRef.ci:70: (14 bytes: <@05342c> - <@05343a>): static varPointer: variant := pointer
	<.main+3064 @05342c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3069 @053431> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3074 @053436> : 2d 98 16 05                store.m64 <@051698> ;varPointer
	test/lang/initByRef.ci:71: (14 bytes: <@05343a> - <@053448>): static varVariant: variant := variant
	<.main+3078 @05343a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3083 @05343f> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3088 @053444> : 2d a0 16 05                store.m64 <@0516a0> ;varVariant
	test/lang/initByRef.ci:72: (14 bytes: <@053448> - <@053456>): static varObject: variant := object
	<.main+3092 @053448> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3097 @05344d> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3102 @053452> : 2d a8 16 05                store.m64 <@0516a8> ;varObject
	test/lang/initByRef.ci:75: (9 bytes: <@053456> - <@05345f>): static typVoid: typename := void
	<.main+3106 @053456> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3111 @05345b> : 2e b0 16 05                store.m32 <@0516b0> ;typVoid
	test/lang/initByRef.ci:76: (9 bytes: <@05345f> - <@053468>): static typBool: typename := bool
	<.main+3115 @05345f> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3120 @053464> : 2e b8 16 05                store.m32 <@0516b8> ;typBool
	test/lang/initByRef.ci:77: (9 bytes: <@053468> - <@053471>): static typChar: typename := char
	<.main+3124 @053468> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3129 @05346d> : 2e c0 16 05                store.m32 <@0516c0> ;typChar
	test/lang/initByRef.ci:78: (9 bytes: <@053471> - <@05347a>): static typInt8: typename := int8
	<.main+3133 @053471> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3138 @053476> : 2e c8 16 05                store.m32 <@0516c8> ;typInt8
	test/lang/initByRef.ci:79: (9 bytes: <@05347a> - <@053483>): static typInt16: typename := int16
	<.main+3142 @05347a> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3147 @05347f> : 2e d0 16 05                store.m32 <@0516d0> ;typInt16
	test/lang/initByRef.ci:80: (9 bytes: <@053483> - <@05348c>): static typInt32: typename := int32
	<.main+3151 @053483> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3156 @053488> : 2e d8 16 05                store.m32 <@0516d8> ;typInt32
	test/lang/initByRef.ci:81: (9 bytes: <@05348c> - <@053495>): static typInt64: typename := int64
	<.main+3160 @05348c> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3165 @053491> : 2e e0 16 05                store.m32 <@0516e0> ;typInt64
	test/lang/initByRef.ci:82: (9 bytes: <@053495> - <@05349e>): static typUint8: typename := uint8
	<.main+3169 @053495> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3174 @05349a> : 2e e8 16 05                store.m32 <@0516e8> ;typUint8
	test/lang/initByRef.ci:83: (9 bytes: <@05349e> - <@0534a7>): static typUint16: typename := uint16
	<.main+3178 @05349e> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3183 @0534a3> : 2e f0 16 05                store.m32 <@0516f0> ;typUint16
	test/lang/initByRef.ci:84: (9 bytes: <@0534a7> - <@0534b0>): static typUint32: typename := uint32
	<.main+3187 @0534a7> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3192 @0534ac> : 2e f8 16 05                store.m32 <@0516f8> ;typUint32
	test/lang/initByRef.ci:85: (9 bytes: <@0534b0> - <@0534b9>): static typUint64: typename := uint64
	<.main+3196 @0534b0> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3201 @0534b5> : 2e 00 17 05                store.m32 <@051700> ;typUint64
	test/lang/initByRef.ci:86: (9 bytes: <@0534b9> - <@0534c2>): static typFloat32: typename := float32
	<.main+3205 @0534b9> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3210 @0534be> : 2e 08 17 05                store.m32 <@051708> ;typFloat32
	test/lang/initByRef.ci:87: (9 bytes: <@0534c2> - <@0534cb>): static typFloat64: typename := float64
	<.main+3214 @0534c2> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3219 @0534c7> : 2e 10 17 05                store.m32 <@051710> ;typFloat64
	test/lang/initByRef.ci:88: (9 bytes: <@0534cb> - <@0534d4>): static typTypename: typename := typename
	<.main+3223 @0534cb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3228 @0534d0> : 2e 18 17 05                store.m32 <@051718> ;typTypename
	test/lang/initByRef.ci:89: (9 bytes: <@0534d4> - <@0534dd>): static typFunction: typename := function
	<.main+3232 @0534d4> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3237 @0534d9> : 2e 20 17 05                store.m32 <@051720> ;typFunction
	test/lang/initByRef.ci:90: (9 bytes: <@0534dd> - <@0534e6>): static typPointer: typename := pointer
	<.main+3241 @0534dd> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3246 @0534e2> : 2e 28 17 05                store.m32 <@051728> ;typPointer
	test/lang/initByRef.ci:91: (9 bytes: <@0534e6> - <@0534ef>): static typVariant: typename := variant
	<.main+3250 @0534e6> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3255 @0534eb> : 2e 30 17 05                store.m32 <@051730> ;typVariant
	test/lang/initByRef.ci:92: (9 bytes: <@0534ef> - <@0534f8>): static typObject: typename := object
	<.main+3259 @0534ef> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3264 @0534f4> : 2e 38 17 05                store.m32 <@051738> ;typObject
	test/lang/initByRef.ci:95: (9 bytes: <@0534f8> - <@053501>): static valueOfPtr: pointer := pointer(value)
	<.main+3268 @0534f8> : 1f e0 14 05 00             load.ref <@0514e0> ;value
	<.main+3273 @0534fd> : 2e 40 17 05                store.m32 <@051740> ;valueOfPtr
	test/lang/initByRef.ci:96: (14 bytes: <@053501> - <@05350f>): static valueOfVar: variant := variant(value)
	<.main+3277 @053501> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3282 @053506> : 1f e0 14 05 00             load.ref <@0514e0> ;value
	<.main+3287 @05350b> : 2d 48 17 05                store.m64 <@051748> ;valueOfVar
	test/lang/initByRef.ci:97: (9 bytes: <@05350f> - <@053518>): static valueOfTyp: typename := typename(value)
	<.main+3291 @05350f> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3296 @053514> : 2e 50 17 05                store.m32 <@051750> ;valueOfTyp
	test/lang/initByRef.ci:99: (9 bytes: <@053518> - <@053521>): static typeOfValue: typename := typename(value)
	<.main+3300 @053518> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3305 @05351d> : 2e 58 17 05                store.m32 <@051758> ;typeOfValue
	test/lang/initByRef.ci:105: (13 bytes: <@053521> - <@05352e>): static copyPtrFloat64: variant := ptrFloat64
	<.main+3309 @053521> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3314 @053526> : 2a f0 15 05                load.m32 <@0515f0> ;ptrFloat64
	<.main+3318 @05352a> : 2d 60 17 05                store.m64 <@051760> ;copyPtrFloat64
	test/lang/initByRef.ci:108: (8 bytes: <@05352e> - <@053536>): static copyVarFloat64: pointer := varFloat64
	<.main+3322 @05352e> : 2a 80 16 05                load.m32 <@051680> ;varFloat64
	<.main+3326 @053532> : 2e 68 17 05                store.m32 <@051768> ;copyVarFloat64
	test/lang/function.ci:12: (25 bytes: <@053536> - <@05354f>): static funAddResult: int32 := funAdd(void(2, 7))
	<.main+3330 @053536> : 19                         load.z32
	<.main+3331 @053537> : 1c 02 00 00 00             load.c32 2
	<.main+3336 @05353c> : 1c 07 00 00 00             load.c32 7
	<.main+3341 @053541> : 1f 78 17 05 00             load.ref <@051778> ;funAdd(x: int32, y: int32): int32
	<.main+3346 @053546> : 02                         call
	<.main+3347 @053547> : 09 f8 ff ff                inc.sp(-8)
	<.main+3351 @05354b> : 2e 80 17 05                store.m32 <@051780> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@05354f> - <@053558>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+3355 @05354f> : 1f 78 17 05 00             load.ref <@051778> ;funAdd(x: int32, y: int32): int32
	<.main+3360 @053554> : 2e 88 17 05                store.m32 <@051788> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@053558> - <@053570>): static funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+3364 @053558> : 19                         load.z32
	<.main+3365 @053559> : 1c 02 00 00 00             load.c32 2
	<.main+3370 @05355e> : 1c 08 00 00 00             load.c32 8
	<.main+3375 @053563> : 2a 88 17 05                load.m32 <@051788> ;funAddRef(x: int32, y: int32): int32
	<.main+3379 @053567> : 02                         call
	<.main+3380 @053568> : 09 f8 ff ff                inc.sp(-8)
	<.main+3384 @05356c> : 2e 90 17 05                store.m32 <@051790> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@053570> - <@053579>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+3388 @053570> : 1f b8 17 05 00             load.ref <@0517b8> ;funMul(x: int32, y: int32): int32
	<.main+3393 @053575> : 2e 98 17 05                store.m32 <@051798> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@053579> - <@053591>): static funMulResult: int32 := funMul(void(2, 6))
	<.main+3397 @053579> : 19                         load.z32
	<.main+3398 @05357a> : 1c 02 00 00 00             load.c32 2
	<.main+3403 @05357f> : 1c 06 00 00 00             load.c32 6
	<.main+3408 @053584> : 2a 98 17 05                load.m32 <@051798> ;funMul(x: int32, y: int32): int32
	<.main+3412 @053588> : 02                         call
	<.main+3413 @053589> : 09 f8 ff ff                inc.sp(-8)
	<.main+3417 @05358d> : 2e a0 17 05                store.m32 <@0517a0> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@053591> - <@053599>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+3421 @053591> : 2a 98 17 05                load.m32 <@051798> ;funMul(x: int32, y: int32): int32
	<.main+3425 @053595> : 2e a8 17 05                store.m32 <@0517a8> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@053599> - <@0535b1>): static funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+3429 @053599> : 19                         load.z32
	<.main+3430 @05359a> : 1c 02 00 00 00             load.c32 2
	<.main+3435 @05359f> : 1c 07 00 00 00             load.c32 7
	<.main+3440 @0535a4> : 2a a8 17 05                load.m32 <@0517a8> ;funMulRef(x: int32, y: int32): int32
	<.main+3444 @0535a8> : 02                         call
	<.main+3445 @0535a9> : 09 f8 ff ff                inc.sp(-8)
	<.main+3449 @0535ad> : 2e b0 17 05                store.m32 <@0517b0> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@0535b1> - <@0535c5>): static fibonacci_13: uint32 := fib(13)
	<.main+3453 @0535b1> : 19                         load.z32
	<.main+3454 @0535b2> : 1c 0d 00 00 00             load.c32 13
	<.main+3459 @0535b7> : 1f c0 17 05 00             load.ref <@0517c0> ;fib(n: uint32): uint32
	<.main+3464 @0535bc> : 02                         call
	<.main+3465 @0535bd> : 09 fc ff ff                inc.sp(-4)
	<.main+3469 @0535c1> : 2e f8 17 05                store.m32 <@0517f8> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@0535c5> - <@0535cd>): static sizeofVoid: int32 := sizeof(void)
	<.main+3473 @0535c5> : 2a d0 00 00                load.m32 <@0000d0>
	<.main+3477 @0535c9> : 2e 00 18 05                store.m32 <@051800> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@0535cd> - <@0535d5>): static sizeofBool: int32 := sizeof(bool)
	<.main+3481 @0535cd> : 2a 70 01 00                load.m32 <@000170>
	<.main+3485 @0535d1> : 2e 08 18 05                store.m32 <@051808> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@0535d5> - <@0535dd>): static sizeofChar: int32 := sizeof(char)
	<.main+3489 @0535d5> : 2a 10 02 00                load.m32 <@000210>
	<.main+3493 @0535d9> : 2e 10 18 05                store.m32 <@051810> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@0535dd> - <@0535e5>): static sizeofInt8: int32 := sizeof(int8)
	<.main+3497 @0535dd> : 2a b0 02 00                load.m32 <@0002b0>
	<.main+3501 @0535e1> : 2e 18 18 05                store.m32 <@051818> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@0535e5> - <@0535ed>): static sizeofInt16: int32 := sizeof(int16)
	<.main+3505 @0535e5> : 2a 50 03 00                load.m32 <@000350>
	<.main+3509 @0535e9> : 2e 20 18 05                store.m32 <@051820> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@0535ed> - <@0535f5>): static sizeofInt32: int32 := sizeof(int32)
	<.main+3513 @0535ed> : 2a f0 03 00                load.m32 <@0003f0>
	<.main+3517 @0535f1> : 2e 28 18 05                store.m32 <@051828> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@0535f5> - <@0535fd>): static sizeofInt64: int32 := sizeof(int64)
	<.main+3521 @0535f5> : 2a 90 04 00                load.m32 <@000490>
	<.main+3525 @0535f9> : 2e 30 18 05                store.m32 <@051830> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@0535fd> - <@053605>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+3529 @0535fd> : 2a 30 05 00                load.m32 <@000530>
	<.main+3533 @053601> : 2e 38 18 05                store.m32 <@051838> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@053605> - <@05360d>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+3537 @053605> : 2a d0 05 00                load.m32 <@0005d0>
	<.main+3541 @053609> : 2e 40 18 05                store.m32 <@051840> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@05360d> - <@053615>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+3545 @05360d> : 2a 70 06 00                load.m32 <@000670>
	<.main+3549 @053611> : 2e 48 18 05                store.m32 <@051848> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@053615> - <@05361d>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+3553 @053615> : 2a 10 07 00                load.m32 <@000710>
	<.main+3557 @053619> : 2e 50 18 05                store.m32 <@051850> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@05361d> - <@053625>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+3561 @05361d> : 2a b0 07 00                load.m32 <@0007b0>
	<.main+3565 @053621> : 2e 58 18 05                store.m32 <@051858> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@053625> - <@05362d>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+3569 @053625> : 2a 50 08 00                load.m32 <@000850>
	<.main+3573 @053629> : 2e 60 18 05                store.m32 <@051860> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@05362d> - <@053635>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+3577 @05362d> : 2a f0 08 00                load.m32 <@0008f0>
	<.main+3581 @053631> : 2e 68 18 05                store.m32 <@051868> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@053635> - <@05363d>): static sizeofVariant: int32 := sizeof(variant)
	<.main+3585 @053635> : 2a 90 09 00                load.m32 <@000990>
	<.main+3589 @053639> : 2e 70 18 05                store.m32 <@051870> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@05363d> - <@053645>): static sizeofTypename: int32 := sizeof(typename)
	<.main+3593 @05363d> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	<.main+3597 @053641> : 2e 78 18 05                store.m32 <@051878> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@053645> - <@05364d>): static sizeofFunction: int32 := sizeof(function)
	<.main+3601 @053645> : 2a 30 0a 00                load.m32 <@000a30>
	<.main+3605 @053649> : 2e 80 18 05                store.m32 <@051880> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@05364d> - <@053655>): static sizeofObject: int32 := sizeof(object)
	<.main+3609 @05364d> : 2a d8 0a 00                load.m32 <@000ad8>
	<.main+3613 @053651> : 2e 88 18 05                store.m32 <@051888> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@053655> - <@05365e>): static typeofRecord: typename := RecordSizeofExt
	<.main+3617 @053655> : 1f b8 70 03 00             load.ref <@0370b8> ;RecordSizeofExt
	<.main+3622 @05365a> : 2e 90 18 05                store.m32 <@051890> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@05365e> - <@05366a>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+3626 @05365e> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3630 @053662> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	<.main+3634 @053666> : 2e 98 18 05                store.m32 <@051898> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@05366a> - <@053677>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+3638 @05366a> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3642 @05366e> : 0c 28 00 00                inc.i32(+40)
	<.main+3646 @053672> : 22                         load.i32
	<.main+3647 @053673> : 2e a0 18 05                store.m32 <@0518a0> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@053677> - <@053684>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+3651 @053677> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3655 @05367b> : 0c 20 00 00                inc.i32(+32)
	<.main+3659 @05367f> : 22                         load.i32
	<.main+3660 @053680> : 2e a8 18 05                store.m32 <@0518a8> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@053684> - <@053690>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+3664 @053684> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3668 @053688> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	<.main+3672 @05368c> : 2e b0 18 05                store.m32 <@0518b0> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@053690> - <@05369c>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+3676 @053690> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3680 @053694> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	<.main+3684 @053698> : 2e b8 18 05                store.m32 <@0518b8> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@05369c> - <@0536a8>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+3688 @05369c> : 2a 90 18 05                load.m32 <@051890> ;typeofRecord
	<.main+3692 @0536a0> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	<.main+3696 @0536a4> : 2e c0 18 05                store.m32 <@0518c0> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@0536a8> - <@0536b4>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+3700 @0536a8> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3704 @0536ac> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	<.main+3708 @0536b0> : 2e c8 18 05                store.m32 <@0518c8> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@0536b4> - <@0536c1>): static offsetOfBase: int32 := typeofBase.offset
	<.main+3712 @0536b4> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3716 @0536b8> : 0c 28 00 00                inc.i32(+40)
	<.main+3720 @0536bc> : 22                         load.i32
	<.main+3721 @0536bd> : 2e d0 18 05                store.m32 <@0518d0> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@0536c1> - <@0536ce>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+3725 @0536c1> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3729 @0536c5> : 0c 20 00 00                inc.i32(+32)
	<.main+3733 @0536c9> : 22                         load.i32
	<.main+3734 @0536ca> : 2e d8 18 05                store.m32 <@0518d8> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@0536ce> - <@0536da>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+3738 @0536ce> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3742 @0536d2> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	<.main+3746 @0536d6> : 2e e0 18 05                store.m32 <@0518e0> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@0536da> - <@0536e6>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+3750 @0536da> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3754 @0536de> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	<.main+3758 @0536e2> : 2e e8 18 05                store.m32 <@0518e8> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@0536e6> - <@0536f2>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+3762 @0536e6> : 2a c0 18 05                load.m32 <@0518c0> ;typeofBase
	<.main+3766 @0536ea> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	<.main+3770 @0536ee> : 2e f0 18 05                store.m32 <@0518f0> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@0536f2> - <@0536ff>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+3774 @0536f2> : 2a f0 18 05                load.m32 <@0518f0> ;typeofBase1
	<.main+3778 @0536f6> : 0c 28 00 00                inc.i32(+40)
	<.main+3782 @0536fa> : 22                         load.i32
	<.main+3783 @0536fb> : 2e f8 18 05                store.m32 <@0518f8> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@0536ff> - <@05370c>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+3787 @0536ff> : 2a f0 18 05                load.m32 <@0518f0> ;typeofBase1
	<.main+3791 @053703> : 0c 20 00 00                inc.i32(+32)
	<.main+3795 @053707> : 22                         load.i32
	<.main+3796 @053708> : 2e 00 19 05                store.m32 <@051900> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@05370c> - <@053718>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+3800 @05370c> : 2a f0 18 05                load.m32 <@0518f0> ;typeofBase1
	<.main+3804 @053710> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	<.main+3808 @053714> : 2e 08 19 05                store.m32 <@051908> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@053718> - <@053725>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+3812 @053718> : 2a 08 19 05                load.m32 <@051908> ;typeofBase2
	<.main+3816 @05371c> : 0c 28 00 00                inc.i32(+40)
	<.main+3820 @053720> : 22                         load.i32
	<.main+3821 @053721> : 2e 10 19 05                store.m32 <@051910> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@053725> - <@053732>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+3825 @053725> : 2a 08 19 05                load.m32 <@051908> ;typeofBase2
	<.main+3829 @053729> : 0c 20 00 00                inc.i32(+32)
	<.main+3833 @05372d> : 22                         load.i32
	<.main+3834 @05372e> : 2e 18 19 05                store.m32 <@051918> ;sizeOfBase2
	test/stdc/number.ci:3: (13 bytes: <@053732> - <@05373f>): static pi64: float64 := 3.141593
	<.main+3838 @053732> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+3847 @05373b> : 2d 20 19 05                store.m64 <@051920> ;pi64
	test/stdc/number.ci:4: (13 bytes: <@05373f> - <@05374c>): static e64: float64 := 2.718282
	<.main+3851 @05373f> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+3860 @053748> : 2d 28 19 05                store.m64 <@051928> ;e64
	test/stdc/number.ci:6: (9 bytes: <@05374c> - <@053755>): static pi32: float32 := pi64
	<.main+3864 @05374c> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+3868 @053750> : 8c                         f64.2f32
	<.main+3869 @053751> : 2e 30 19 05                store.m32 <@051930> ;pi32
	test/stdc/number.ci:7: (9 bytes: <@053755> - <@05375e>): static e32: float32 := e64
	<.main+3873 @053755> : 2b 28 19 05                load.m64 <@051928> ;e64
	<.main+3877 @053759> : 8c                         f64.2f32
	<.main+3878 @05375a> : 2e 38 19 05                store.m32 <@051938> ;e32
	test/stdc/number.ci:14: (11 bytes: <@05375e> - <@053769>): static r_comp: int32 := int32(14 << 3)
	<.main+3882 @05375e> : 1c 0e 00 00 00             load.c32 14
	<.main+3887 @053763> : 3f 43                      b32.shl 0x003
	<.main+3889 @053765> : 2e 40 19 05                store.m32 <@051940> ;r_comp
	test/stdc/number.ci:15: (11 bytes: <@053769> - <@053774>): static g_comp: int32 := int32(63 << 2)
	<.main+3893 @053769> : 1c 3f 00 00 00             load.c32 63
	<.main+3898 @05376e> : 3f 42                      b32.shl 0x002
	<.main+3900 @053770> : 2e 48 19 05                store.m32 <@051948> ;g_comp
	test/stdc/number.ci:16: (11 bytes: <@053774> - <@05377f>): static b_comp: int32 := int32(31 << 3)
	<.main+3904 @053774> : 1c 1f 00 00 00             load.c32 31
	<.main+3909 @053779> : 3f 43                      b32.shl 0x003
	<.main+3911 @05377b> : 2e 50 19 05                store.m32 <@051950> ;b_comp
	test/stdc/number.ci:18: (38 bytes: <@05377f> - <@0537a5>): static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+3915 @05377f> : 2a 40 19 05                load.m32 <@051940> ;r_comp
	<.main+3919 @053783> : 3f 48                      b32.shl 0x008
	<.main+3921 @053785> : 1c 00 f8 00 00             load.c32 63488
	<.main+3926 @05378a> : 31                         and.b32
	<.main+3927 @05378b> : 2a 48 19 05                load.m32 <@051948> ;g_comp
	<.main+3931 @05378f> : 3f 43                      b32.shl 0x003
	<.main+3933 @053791> : 1c e0 07 00 00             load.c32 2016
	<.main+3938 @053796> : 31                         and.b32
	<.main+3939 @053797> : 32                         or.b32
	<.main+3940 @053798> : 2a 50 19 05                load.m32 <@051950> ;b_comp
	<.main+3944 @05379c> : 3f c3                      b32.sar 0x003
	<.main+3946 @05379e> : 3f 05                      b32.and 0x01f
	<.main+3948 @0537a0> : 32                         or.b32
	<.main+3949 @0537a1> : 2e 58 19 05                store.m32 <@051958> ;r5g6b5
	test/stdc/number.ci:19: (36 bytes: <@0537a5> - <@0537c9>): static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3953 @0537a5> : 2a 40 19 05                load.m32 <@051940> ;r_comp
	<.main+3957 @0537a9> : 3f 50                      b32.shl 0x010
	<.main+3959 @0537ab> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3964 @0537b0> : 31                         and.b32
	<.main+3965 @0537b1> : 2a 48 19 05                load.m32 <@051948> ;g_comp
	<.main+3969 @0537b5> : 3f 48                      b32.shl 0x008
	<.main+3971 @0537b7> : 1c 00 ff 00 00             load.c32 65280
	<.main+3976 @0537bc> : 31                         and.b32
	<.main+3977 @0537bd> : 32                         or.b32
	<.main+3978 @0537be> : 2a 50 19 05                load.m32 <@051950> ;b_comp
	<.main+3982 @0537c2> : 3f 08                      b32.and 0x0ff
	<.main+3984 @0537c4> : 32                         or.b32
	<.main+3985 @0537c5> : 2e 60 19 05                store.m32 <@051960> ;r8g8b8
	test/stdc/number.ci:21: (22 bytes: <@0537c9> - <@0537df>): static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3989 @0537c9> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+3993 @0537cd> : 1c 0b 00 00 00             load.c32 11
	<.main+3998 @0537d2> : 1c 05 00 00 00             load.c32 5
	<.main+4003 @0537d7> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4007 @0537db> : 2e 68 19 05                store.m32 <@051968> ;zxtR5
	test/stdc/number.ci:22: (22 bytes: <@0537df> - <@0537f5>): static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+4011 @0537df> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4015 @0537e3> : 1c 05 00 00 00             load.c32 5
	<.main+4020 @0537e8> : 1c 06 00 00 00             load.c32 6
	<.main+4025 @0537ed> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4029 @0537f1> : 2e 70 19 05                store.m32 <@051970> ;zxtG6
	test/stdc/number.ci:23: (18 bytes: <@0537f5> - <@053807>): static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4033 @0537f5> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4037 @0537f9> : 19                         load.z32
	<.main+4038 @0537fa> : 1c 05 00 00 00             load.c32 5
	<.main+4043 @0537ff> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4047 @053803> : 2e 78 19 05                store.m32 <@051978> ;zxtB5
	test/stdc/number.ci:25: (22 bytes: <@053807> - <@05381d>): static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+4051 @053807> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4055 @05380b> : 1c 0b 00 00 00             load.c32 11
	<.main+4060 @053810> : 1c 05 00 00 00             load.c32 5
	<.main+4065 @053815> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4069 @053819> : 2e 80 19 05                store.m32 <@051980> ;sxtR5
	test/stdc/number.ci:26: (22 bytes: <@05381d> - <@053833>): static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+4073 @05381d> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4077 @053821> : 1c 05 00 00 00             load.c32 5
	<.main+4082 @053826> : 1c 06 00 00 00             load.c32 6
	<.main+4087 @05382b> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4091 @05382f> : 2e 88 19 05                store.m32 <@051988> ;sxtG6
	test/stdc/number.ci:27: (18 bytes: <@053833> - <@053845>): static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4095 @053833> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4099 @053837> : 19                         load.z32
	<.main+4100 @053838> : 1c 05 00 00 00             load.c32 5
	<.main+4105 @05383d> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4109 @053841> : 2e 90 19 05                store.m32 <@051990> ;sxtB5
	test/stdc/number.ci:29: (22 bytes: <@053845> - <@05385b>): static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+4113 @053845> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4117 @053849> : 1c 10 00 00 00             load.c32 16
	<.main+4122 @05384e> : 1c 08 00 00 00             load.c32 8
	<.main+4127 @053853> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4131 @053857> : 2e 98 19 05                store.m32 <@051998> ;zxtR8
	test/stdc/number.ci:30: (22 bytes: <@05385b> - <@053871>): static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+4135 @05385b> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4139 @05385f> : 1c 08 00 00 00             load.c32 8
	<.main+4144 @053864> : 1c 08 00 00 00             load.c32 8
	<.main+4149 @053869> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4153 @05386d> : 2e a0 19 05                store.m32 <@0519a0> ;zxtG8
	test/stdc/number.ci:31: (18 bytes: <@053871> - <@053883>): static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+4157 @053871> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4161 @053875> : 19                         load.z32
	<.main+4162 @053876> : 1c 08 00 00 00             load.c32 8
	<.main+4167 @05387b> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4171 @05387f> : 2e a8 19 05                store.m32 <@0519a8> ;zxtB8
	test/stdc/number.ci:33: (22 bytes: <@053883> - <@053899>): static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+4175 @053883> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4179 @053887> : 1c 10 00 00 00             load.c32 16
	<.main+4184 @05388c> : 1c 08 00 00 00             load.c32 8
	<.main+4189 @053891> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4193 @053895> : 2e b0 19 05                store.m32 <@0519b0> ;sxtR8
	test/stdc/number.ci:34: (22 bytes: <@053899> - <@0538af>): static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+4197 @053899> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4201 @05389d> : 1c 08 00 00 00             load.c32 8
	<.main+4206 @0538a2> : 1c 08 00 00 00             load.c32 8
	<.main+4211 @0538a7> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4215 @0538ab> : 2e b8 19 05                store.m32 <@0519b8> ;sxtG8
	test/stdc/number.ci:35: (18 bytes: <@0538af> - <@0538c1>): static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+4219 @0538af> : 2a 60 19 05                load.m32 <@051960> ;r8g8b8
	<.main+4223 @0538b3> : 19                         load.z32
	<.main+4224 @0538b4> : 1c 08 00 00 00             load.c32 8
	<.main+4229 @0538b9> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4233 @0538bd> : 2e c0 19 05                store.m32 <@0519c0> ;sxtB8
	test/stdc/number.ci:37: (22 bytes: <@0538c1> - <@0538d7>): static testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+4237 @0538c1> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4241 @0538c5> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4250 @0538ce> : 84                         div.f64
	<.main+4251 @0538cf> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<.main+4255 @0538d3> : 2d c8 19 05                store.m64 <@0519c8> ;testSin_f64
	test/stdc/number.ci:38: (22 bytes: <@0538d7> - <@0538ed>): static testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+4259 @0538d7> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4263 @0538db> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4272 @0538e4> : 84                         div.f64
	<.main+4273 @0538e5> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<.main+4277 @0538e9> : 2d d0 19 05                store.m64 <@0519d0> ;testCos_f64
	test/stdc/number.ci:39: (22 bytes: <@0538ed> - <@053903>): static testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+4281 @0538ed> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4285 @0538f1> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+4294 @0538fa> : 84                         div.f64
	<.main+4295 @0538fb> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	<.main+4299 @0538ff> : 2d d8 19 05                store.m64 <@0519d8> ;testTan_f64
	test/stdc/number.ci:40: (22 bytes: <@053903> - <@053919>): static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+4303 @053903> : 2b 28 19 05                load.m64 <@051928> ;e64
	<.main+4307 @053907> : 2b 28 19 05                load.m64 <@051928> ;e64
	<.main+4311 @05390b> : 83                         mul.f64
	<.main+4312 @05390c> : 2b 28 19 05                load.m64 <@051928> ;e64
	<.main+4316 @053910> : 83                         mul.f64
	<.main+4317 @053911> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<.main+4321 @053915> : 2d e0 19 05                store.m64 <@0519e0> ;testLog_f64
	test/stdc/number.ci:41: (17 bytes: <@053919> - <@05392a>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+4325 @053919> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4334 @053922> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<.main+4338 @053926> : 2d e8 19 05                store.m64 <@0519e8> ;testExp_f64
	test/stdc/number.ci:42: (26 bytes: <@05392a> - <@053944>): static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+4342 @05392a> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4346 @05392e> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4350 @053932> : 83                         mul.f64
	<.main+4351 @053933> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+4360 @05393c> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<.main+4364 @053940> : 2d f0 19 05                store.m64 <@0519f0> ;testPow_f64
	test/stdc/number.ci:43: (17 bytes: <@053944> - <@053955>): static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+4368 @053944> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4372 @053948> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4376 @05394c> : 83                         mul.f64
	<.main+4377 @05394d> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<.main+4381 @053951> : 2d f8 19 05                store.m64 <@0519f8> ;testSqrt_f64
	test/stdc/number.ci:44: (21 bytes: <@053955> - <@05396a>): static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+4385 @053955> : 2b 20 19 05                load.m64 <@051920> ;pi64
	<.main+4389 @053959> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4398 @053962> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<.main+4402 @053966> : 2d 00 1a 05                store.m64 <@051a00> ;testAtan_f64
	test/stdc/number.ci:46: (18 bytes: <@05396a> - <@05397c>): static testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+4406 @05396a> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4410 @05396e> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4415 @053973> : 74                         div.f32
	<.main+4416 @053974> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	<.main+4420 @053978> : 2e 08 1a 05                store.m32 <@051a08> ;testSin_f32
	test/stdc/number.ci:47: (18 bytes: <@05397c> - <@05398e>): static testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+4424 @05397c> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4428 @053980> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4433 @053985> : 74                         div.f32
	<.main+4434 @053986> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	<.main+4438 @05398a> : 2e 10 1a 05                store.m32 <@051a10> ;testCos_f32
	test/stdc/number.ci:48: (18 bytes: <@05398e> - <@0539a0>): static testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+4442 @05398e> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4446 @053992> : 7f 00 00 80 40             load.f32 4.000000
	<.main+4451 @053997> : 74                         div.f32
	<.main+4452 @053998> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	<.main+4456 @05399c> : 2e 18 1a 05                store.m32 <@051a18> ;testTan_f32
	test/stdc/number.ci:49: (22 bytes: <@0539a0> - <@0539b6>): static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+4460 @0539a0> : 2a 38 19 05                load.m32 <@051938> ;e32
	<.main+4464 @0539a4> : 2a 38 19 05                load.m32 <@051938> ;e32
	<.main+4468 @0539a8> : 73                         mul.f32
	<.main+4469 @0539a9> : 2a 38 19 05                load.m32 <@051938> ;e32
	<.main+4473 @0539ad> : 73                         mul.f32
	<.main+4474 @0539ae> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	<.main+4478 @0539b2> : 2e 20 1a 05                store.m32 <@051a20> ;testLog_f32
	test/stdc/number.ci:50: (13 bytes: <@0539b6> - <@0539c3>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+4482 @0539b6> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4487 @0539bb> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	<.main+4491 @0539bf> : 2e 28 1a 05                store.m32 <@051a28> ;testExp_f32
	test/stdc/number.ci:51: (22 bytes: <@0539c3> - <@0539d9>): static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+4495 @0539c3> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4499 @0539c7> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4503 @0539cb> : 73                         mul.f32
	<.main+4504 @0539cc> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+4509 @0539d1> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	<.main+4513 @0539d5> : 2e 30 1a 05                store.m32 <@051a30> ;testPow_f32
	test/stdc/number.ci:52: (17 bytes: <@0539d9> - <@0539ea>): static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+4517 @0539d9> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4521 @0539dd> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4525 @0539e1> : 73                         mul.f32
	<.main+4526 @0539e2> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	<.main+4530 @0539e6> : 2e 38 1a 05                store.m32 <@051a38> ;testSqrt_f32
	test/stdc/number.ci:53: (17 bytes: <@0539ea> - <@0539fb>): static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+4534 @0539ea> : 2a 30 19 05                load.m32 <@051930> ;pi32
	<.main+4538 @0539ee> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4543 @0539f3> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	<.main+4547 @0539f7> : 2e 40 1a 05                store.m32 <@051a40> ;testAtan_f32
	test/stdc/number.ci:55: (12 bytes: <@0539fb> - <@053a07>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+4551 @0539fb> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4555 @0539ff> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	<.main+4559 @053a03> : 2e 48 1a 05                store.m32 <@051a48> ;testPopulation_u32
	test/stdc/number.ci:56: (12 bytes: <@053a07> - <@053a13>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+4563 @053a07> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4567 @053a0b> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	<.main+4571 @053a0f> : 2e 50 1a 05                store.m32 <@051a50> ;testSwapBits_u32
	test/stdc/number.ci:57: (12 bytes: <@053a13> - <@053a1f>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+4575 @053a13> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4579 @053a17> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	<.main+4583 @053a1b> : 2e 58 1a 05                store.m32 <@051a58> ;testBitScanReverse_u32
	test/stdc/number.ci:58: (12 bytes: <@053a1f> - <@053a2b>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+4587 @053a1f> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4591 @053a23> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	<.main+4595 @053a27> : 2e 60 1a 05                store.m32 <@051a60> ;testBitScanForward_u32
	test/stdc/number.ci:59: (12 bytes: <@053a2b> - <@053a37>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+4599 @053a2b> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4603 @053a2f> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	<.main+4607 @053a33> : 2e 68 1a 05                store.m32 <@051a68> ;testHighBit_u32
	test/stdc/number.ci:60: (12 bytes: <@053a37> - <@053a43>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+4611 @053a37> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4615 @053a3b> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	<.main+4619 @053a3f> : 2e 70 1a 05                store.m32 <@051a70> ;testLowBit_u32
	test/stdc/number.ci:62: (18 bytes: <@053a43> - <@053a55>): static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4623 @053a43> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4627 @053a47> : 19                         load.z32
	<.main+4628 @053a48> : 1c 05 00 00 00             load.c32 5
	<.main+4633 @053a4d> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4637 @053a51> : 2e 78 1a 05                store.m32 <@051a78> ;testZeroExtend_u32
	test/stdc/number.ci:63: (18 bytes: <@053a55> - <@053a67>): static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4641 @053a55> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4645 @053a59> : 19                         load.z32
	<.main+4646 @053a5a> : 1c 05 00 00 00             load.c32 5
	<.main+4651 @053a5f> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4655 @053a63> : 2e 80 1a 05                store.m32 <@051a80> ;testSignExtend_u32
	test/stdc/number.ci:65: (20 bytes: <@053a67> - <@053a7b>): static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+4659 @053a67> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4663 @053a6b> : 5b                         i32.2i64
	<.main+4664 @053a6c> : 19                         load.z32
	<.main+4665 @053a6d> : 1c 05 00 00 00             load.c32 5
	<.main+4670 @053a72> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+4674 @053a76> : 6a                         i64.2i32
	<.main+4675 @053a77> : 2e 88 1a 05                store.m32 <@051a88> ;testZeroExtend_u64
	test/stdc/number.ci:66: (20 bytes: <@053a7b> - <@053a8f>): static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+4679 @053a7b> : 2a 58 19 05                load.m32 <@051958> ;r5g6b5
	<.main+4683 @053a7f> : 5b                         i32.2i64
	<.main+4684 @053a80> : 19                         load.z32
	<.main+4685 @053a81> : 1c 05 00 00 00             load.c32 5
	<.main+4690 @053a86> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+4694 @053a8a> : 6a                         i64.2i32
	<.main+4695 @053a8b> : 2e 90 1a 05                store.m32 <@051a90> ;testSignExtend_u64
	test/stdc/memory.ci:7: (18 bytes: <@053a8f> - <@053aa1>): static p1: pointer := malloc(1024)
	<.main+4699 @053a8f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4704 @053a94> : 1c 00 04 00 00             load.c32 1024
	<.main+4709 @053a99> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4713 @053a9d> : 2e 98 1a 05                store.m32 <@051a98> ;p1
	test/stdc/memory.ci:8: (18 bytes: <@053aa1> - <@053ab3>): static p2: pointer := malloc(80)
	<.main+4717 @053aa1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4722 @053aa6> : 1c 50 00 00 00             load.c32 80
	<.main+4727 @053aab> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4731 @053aaf> : 2e a0 1a 05                store.m32 <@051aa0> ;p2
	test/stdc/memory.ci:9: (18 bytes: <@053ab3> - <@053ac5>): static p3: pointer := malloc(160)
	<.main+4735 @053ab3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4740 @053ab8> : 1c a0 00 00 00             load.c32 160
	<.main+4745 @053abd> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4749 @053ac1> : 2e a8 1a 05                store.m32 <@051aa8> ;p3
	test/stdc/memory.ci:10: (18 bytes: <@053ac5> - <@053ad7>): static p4: pointer := malloc(820)
	<.main+4753 @053ac5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4758 @053aca> : 1c 34 03 00 00             load.c32 820
	<.main+4763 @053acf> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4767 @053ad3> : 2e b0 1a 05                store.m32 <@051ab0> ;p4
	test/stdc/memory.ci:23: (13 bytes: <@053ad7> - <@053ae4>): static val1: int64 := 42
	<.main+4771 @053ad7> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4780 @053ae0> : 2d b8 1a 05                store.m64 <@051ab8> ;val1
	test/stdc/memory.ci:24: (13 bytes: <@053ae4> - <@053af1>): static val2: int64 := 96
	<.main+4784 @053ae4> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+4793 @053aed> : 2d c0 1a 05                store.m64 <@051ac0> ;val2
	test/stdc/tryExec.ci:46: (18 bytes: <@053af1> - <@053b03>): static tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+4797 @053af1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4802 @053af6> : 1f c8 1a 05 00             load.ref <@051ac8> ;noError(ptr: pointer): void
	<.main+4807 @053afb> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4811 @053aff> : 2e 58 1b 05                store.m32 <@051b58> ;tryExecErr0
	test/stdc/tryExec.ci:47: (18 bytes: <@053b03> - <@053b15>): static tryExecErr1: int32 := tryExec(void(null, null))
	<.main+4815 @053b03> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4820 @053b08> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4825 @053b0d> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4829 @053b11> : 2e 60 1b 05                store.m32 <@051b60> ;tryExecErr1
	test/stdc/tryExec.ci:48: (18 bytes: <@053b15> - <@053b27>): static tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+4833 @053b15> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4838 @053b1a> : 1f d0 1a 05 00             load.ref <@051ad0> ;stackOverflow(ptr: pointer): void
	<.main+4843 @053b1f> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4847 @053b23> : 2e 68 1b 05                store.m32 <@051b68> ;tryExecErr2
	test/stdc/tryExec.ci:49: (18 bytes: <@053b27> - <@053b39>): static tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+4851 @053b27> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4856 @053b2c> : 1f e8 1a 05 00             load.ref <@051ae8> ;divisionByZero(args: pointer): void
	<.main+4861 @053b31> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4865 @053b35> : 2e 70 1b 05                store.m32 <@051b70> ;tryExecErr3
	test/stdc/tryExec.ci:50: (18 bytes: <@053b39> - <@053b4b>): static tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+4869 @053b39> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4874 @053b3e> : 1f 50 1b 05 00             load.ref <@051b50> ;invalidInstruction(args: pointer): void
	<.main+4879 @053b43> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4883 @053b47> : 2e 78 1b 05                store.m32 <@051b78> ;tryExecErr4
	test/stdc/tryExec.ci:51: (18 bytes: <@053b4b> - <@053b5d>): static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+4887 @053b4b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4892 @053b50> : 1f 40 1b 05 00             load.ref <@051b40> ;invalidMemoryAccess(args: pointer): void
	<.main+4897 @053b55> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4901 @053b59> : 2e 80 1b 05                store.m32 <@051b80> ;tryExecErr5
	test/stdc/tryExec.ci:52: (18 bytes: <@053b5d> - <@053b6f>): static tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+4905 @053b5d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4910 @053b62> : 1f f8 1a 05 00             load.ref <@051af8> ;abortExecution(args: pointer): void
	<.main+4915 @053b67> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4919 @053b6b> : 2e 88 1b 05                store.m32 <@051b88> ;tryExecErr6
	test/lang/array.ci:59: (9 bytes: <@053b6f> - <@053b78>): static arrArrayInitNull: int64[*] := null
	<.main+4923 @053b6f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4928 @053b74> : 2e d8 1b 05                store.m32 <@051bd8> ;arrArrayInitNull
	test/lang/array.ci:60: (10 bytes: <@053b78> - <@053b82>): static arrSliceInitNull: int64[] := null
	<.main+4932 @053b78> : 19                         load.z32
	<.main+4933 @053b79> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4938 @053b7e> : 2d e0 1b 05                store.m64 <@051be0> ;arrSliceInitNull
	test/lang/array.ci:63: (9 bytes: <@053b82> - <@053b8b>): static arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+4942 @053b82> : 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+4947 @053b87> : 2e e8 1b 05                store.m32 <@051be8> ;arrArrayInitFixed
	test/lang/array.ci:64: (14 bytes: <@053b8b> - <@053b99>): static arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+4951 @053b8b> : 1c 07 00 00 00             load.c32 7
	<.main+4956 @053b90> : 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+4961 @053b95> : 2d f0 1b 05                store.m64 <@051bf0> ;arrSliceInitFixed
	test/lang/array.ci:67: (8 bytes: <@053b99> - <@053ba1>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+4965 @053b99> : 2a f0 1b 05                load.m32 <@051bf0> ;arrSliceInitFixed
	<.main+4969 @053b9d> : 2e f8 1b 05                store.m32 <@051bf8> ;arrArrayInitSlice
	test/lang/array.ci:68: (8 bytes: <@053ba1> - <@053ba9>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+4973 @053ba1> : 2b f0 1b 05                load.m64 <@051bf0> ;arrSliceInitFixed
	<.main+4977 @053ba5> : 2d 00 1c 05                store.m64 <@051c00> ;arrSliceInitSlice
	test/lang/array.ci:71: (8 bytes: <@053ba9> - <@053bb1>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+4981 @053ba9> : 2a e8 1b 05                load.m32 <@051be8> ;arrArrayInitFixed
	<.main+4985 @053bad> : 2e 08 1c 05                store.m32 <@051c08> ;arrArrayInitPtr
	test/lang/array.ci:86: (9 bytes: <@053bb1> - <@053bba>): static strArray: char[*] := "string"
	<.main+4989 @053bb1> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+4994 @053bb6> : 2e 18 1c 05                store.m32 <@051c18> ;strArray
	test/lang/array.ci:90: (14 bytes: <@053bba> - <@053bc8>): static strSlice: char[] := "string"
	<.main+4998 @053bba> : 1c 06 00 00 00             load.c32 6
	<.main+5003 @053bbf> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+5008 @053bc4> : 2d 20 1c 05                store.m64 <@051c20> ;strSlice
	test/lang/member.ci:35: (5 bytes: <@053bc8> - <@053bcd>): static global: int32
	<.main+5012 @053bc8> : 19                         load.z32
	<.main+5013 @053bc9> : 2e 60 1c 05                store.m32 <@051c60> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@053bcd> - <@053bd6>): static globalInit: int32 := 1
	<.main+5017 @053bcd> : 1c 01 00 00 00             load.c32 1
	<.main+5022 @053bd2> : 2e 68 1c 05                store.m32 <@051c68> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@053bd6> - <@053bdf>): static const globalConstant: int32 := 2
	<.main+5026 @053bd6> : 1c 02 00 00 00             load.c32 2
	<.main+5031 @053bdb> : 2e 70 1c 05                store.m32 <@051c70> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@053bdf> - <@053bf1>): static globalRecInit: Inner := {...}
	<.main+5035 @053bdf> : 1c 04 00 00 00             load.c32 4
	<.main+5040 @053be4> : 2e 80 1c 05                store.m32 <@051c80> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@053be8> - <@053bf1>): void(globalRecInit.constant := 5);
	<.main+5044 @053be8> : 1c 05 00 00 00             load.c32 5
	<.main+5049 @053bed> : 2e 84 1c 05                store.m32 <@051c84> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@053bf1> - <@053c03>): static const globalConstantRec: Inner := {...}
	<.main+5053 @053bf1> : 1c 06 00 00 00             load.c32 6
	<.main+5058 @053bf6> : 2e 88 1c 05                store.m32 <@051c88> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@053bfa> - <@053c03>): void(globalConstantRec.constant := 7);
	<.main+5062 @053bfa> : 1c 07 00 00 00             load.c32 7
	<.main+5067 @053bff> : 2e 8c 1c 05                store.m32 <@051c8c> ;RecordMemberTest.globalConstantRec+4
	test/lang/member.ci:53: (72 bytes: <@053c03> - <@053c4b>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5071 @053c03> : 1c 0a 00 00 00             load.c32 10
	<.main+5076 @053c08> : 2e 90 1c 05                store.m32 <@051c90> ;recordMemberTest
	test/lang/member.ci:55: (9 bytes: <@053c0c> - <@053c15>): void(recordMemberTest.constant := 11);
	<.main+5080 @053c0c> : 1c 0b 00 00 00             load.c32 11
	<.main+5085 @053c11> : 2e 94 1c 05                store.m32 <@051c94> ;recordMemberTest+4
	test/lang/member.ci:56: (9 bytes: <@053c15> - <@053c1e>): void(recordMemberTest.memberInit := 12);
	<.main+5089 @053c15> : 1c 0c 00 00 00             load.c32 12
	<.main+5094 @053c1a> : 2e 98 1c 05                store.m32 <@051c98> ;recordMemberTest+8
	test/lang/member.ci:57: (9 bytes: <@053c1e> - <@053c27>): void(recordMemberTest.constantInit := 13);
	<.main+5098 @053c1e> : 1c 0d 00 00 00             load.c32 13
	<.main+5103 @053c23> : 2e 9c 1c 05                store.m32 <@051c9c> ;recordMemberTest+12
	test/lang/member.ci:60: (9 bytes: <@053c27> - <@053c30>): void(recordMemberTest.memberRec.member := 14);
	<.main+5107 @053c27> : 1c 0e 00 00 00             load.c32 14
	<.main+5112 @053c2c> : 2e a0 1c 05                store.m32 <@051ca0> ;recordMemberTest+16
	test/lang/member.ci:61: (9 bytes: <@053c30> - <@053c39>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5116 @053c30> : 1c 0f 00 00 00             load.c32 15
	<.main+5121 @053c35> : 2e a4 1c 05                store.m32 <@051ca4> ;recordMemberTest+20
	test/lang/member.ci:65: (9 bytes: <@053c39> - <@053c42>): void(recordMemberTest.constantRec.member := 16);
	<.main+5125 @053c39> : 1c 10 00 00 00             load.c32 16
	<.main+5130 @053c3e> : 2e a8 1c 05                store.m32 <@051ca8> ;recordMemberTest+24
	test/lang/member.ci:66: (9 bytes: <@053c42> - <@053c4b>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5134 @053c42> : 1c 11 00 00 00             load.c32 17
	<.main+5139 @053c47> : 2e ac 1c 05                store.m32 <@051cac> ;recordMemberTest+28
	test/lang/method.ci:18: (9 bytes: <@053c4b> - <@053c54>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5143 @053c4b> : 1f 08 1d 05 00             load.ref <@051d08> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5148 @053c50> : 2e d8 1c 05                store.m32 <@051cd8> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/method.ci:62: (26 bytes: <@053c54> - <@053c6e>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5152 @053c54> : 1f 30 1d 05 00             load.ref <@051d30> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5157 @053c59> : 2e 58 1d 05                store.m32 <@051d58> ;recordMethodTest
	:: (8 bytes: <@053c5d> - <@053c65>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5161 @053c5d> : 2a d8 1c 05                load.m32 <@051cd8> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5165 @053c61> : 2e 5c 1d 05                store.m32 <@051d5c> ;recordMethodTest+4
	:: (9 bytes: <@053c65> - <@053c6e>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5169 @053c65> : 1f e0 1c 05 00             load.ref <@051ce0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5174 @053c6a> : 2e 60 1d 05                store.m32 <@051d60> ;recordMethodTest+8
	test/lang/recUnion.ci:26: (21 bytes: <@053c6e> - <@053c83>): static black: rgbU8 := {...}
	<.main+5178 @053c6e> : 19                         load.z32
	<.main+5179 @053c6f> : 1f f2 1d 05 00             load.ref <@051df2> ;black+2
	<.main+5184 @053c74> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@053c75> - <@053c7c>): void(black.g := (0));
	<.main+5185 @053c75> : 19                         load.z32
	<.main+5186 @053c76> : 1f f1 1d 05 00             load.ref <@051df1> ;black+1
	<.main+5191 @053c7b> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@053c7c> - <@053c83>): void(black.b := (0));
	<.main+5192 @053c7c> : 19                         load.z32
	<.main+5193 @053c7d> : 1f f0 1d 05 00             load.ref <@051df0> ;black
	<.main+5198 @053c82> : 25                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@053c83> - <@053c9c>): static green: rgbU8 := {...}
	<.main+5199 @053c83> : 19                         load.z32
	<.main+5200 @053c84> : 1f fa 1d 05 00             load.ref <@051dfa> ;green+2
	<.main+5205 @053c89> : 25                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@053c8a> - <@053c95>): void(green.g := (255));
	<.main+5206 @053c8a> : 1c ff 00 00 00             load.c32 255
	<.main+5211 @053c8f> : 1f f9 1d 05 00             load.ref <@051df9> ;green+1
	<.main+5216 @053c94> : 25                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@053c95> - <@053c9c>): void(green.b := (0));
	<.main+5217 @053c95> : 19                         load.z32
	<.main+5218 @053c96> : 1f f8 1d 05 00             load.ref <@051df8> ;green
	<.main+5223 @053c9b> : 25                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@053c9c> - <@053cbd>): static white: rgbU8 := {...}
	<.main+5224 @053c9c> : 1c ff 00 00 00             load.c32 255
	<.main+5229 @053ca1> : 1f 02 1e 05 00             load.ref <@051e02> ;white+2
	<.main+5234 @053ca6> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@053ca7> - <@053cb2>): void(white.g := (255));
	<.main+5235 @053ca7> : 1c ff 00 00 00             load.c32 255
	<.main+5240 @053cac> : 1f 01 1e 05 00             load.ref <@051e01> ;white+1
	<.main+5245 @053cb1> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@053cb2> - <@053cbd>): void(white.b := (255));
	<.main+5246 @053cb2> : 1c ff 00 00 00             load.c32 255
	<.main+5251 @053cb7> : 1f 00 1e 05 00             load.ref <@051e00> ;white
	<.main+5256 @053cbc> : 25                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@053cbd> - <@053cc6>): static cyan: color := {...}
	<.main+5257 @053cbd> : 1c ff ff 00 00             load.c32 65535
	<.main+5262 @053cc2> : 2e 08 1e 05                store.m32 <@051e08> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@053cc6> - <@053cdf>): static blue: color := {...}
	<.main+5266 @053cc6> : 19                         load.z32
	<.main+5267 @053cc7> : 1f 12 1e 05 00             load.ref <@051e12> ;blue+2
	<.main+5272 @053ccc> : 25                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@053ccd> - <@053cd4>): void(blue.rgb.g := (0));
	<.main+5273 @053ccd> : 19                         load.z32
	<.main+5274 @053cce> : 1f 11 1e 05 00             load.ref <@051e11> ;blue+1
	<.main+5279 @053cd3> : 25                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@053cd4> - <@053cdf>): void(blue.rgb.b := (255));
	<.main+5280 @053cd4> : 1c ff 00 00 00             load.c32 255
	<.main+5285 @053cd9> : 1f 10 1e 05 00             load.ref <@051e10> ;blue
	<.main+5290 @053cde> : 25                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@053cdf> - <@053ce8>): static shift: int32 := 2
	<.main+5291 @053cdf> : 1c 02 00 00 00             load.c32 2
	<.main+5296 @053ce4> : 2e 18 1e 05                store.m32 <@051e18> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@053ce8> - <@053cf3>): static boolA: bool := true
	<.main+5300 @053ce8> : 1c 01 00 00 00             load.c32 1
	<.main+5305 @053ced> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5310 @053cf2> : 25                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@053cf3> - <@053cfe>): static boolB: bool := bool(!false)
	<.main+5311 @053cf3> : 1c 01 00 00 00             load.c32 1
	<.main+5316 @053cf8> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5321 @053cfd> : 25                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@053cfe> - <@053d11>): static boolAnd: bool := bool(boolA & boolB)
	<.main+5322 @053cfe> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5327 @053d03> : 20                         load.i8
	<.main+5328 @053d04> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5333 @053d09> : 20                         load.i8
	<.main+5334 @053d0a> : 31                         and.b32
	<.main+5335 @053d0b> : 1f 30 1e 05 00             load.ref <@051e30> ;boolAnd
	<.main+5340 @053d10> : 25                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@053d11> - <@053d24>): static boolIor: bool := bool(boolA | boolB)
	<.main+5341 @053d11> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5346 @053d16> : 20                         load.i8
	<.main+5347 @053d17> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5352 @053d1c> : 20                         load.i8
	<.main+5353 @053d1d> : 32                         or.b32
	<.main+5354 @053d1e> : 1f 38 1e 05 00             load.ref <@051e38> ;boolIor
	<.main+5359 @053d23> : 25                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@053d24> - <@053d37>): static boolXor: bool := bool(boolA ^ boolB)
	<.main+5360 @053d24> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5365 @053d29> : 20                         load.i8
	<.main+5366 @053d2a> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5371 @053d2f> : 20                         load.i8
	<.main+5372 @053d30> : 36                         xor.b32
	<.main+5373 @053d31> : 1f 40 1e 05 00             load.ref <@051e40> ;boolXor
	<.main+5378 @053d36> : 25                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@053d37> - <@053d44>): static boolNot: bool := bool(!boolB)
	<.main+5379 @053d37> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5384 @053d3c> : 20                         load.i8
	<.main+5385 @053d3d> : 0b                         not.b32
	<.main+5386 @053d3e> : 1f 48 1e 05 00             load.ref <@051e48> ;boolNot
	<.main+5391 @053d43> : 25                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@053d44> - <@053d57>): static boolCeq: bool := bool(boolA == boolB)
	<.main+5392 @053d44> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5397 @053d49> : 20                         load.i8
	<.main+5398 @053d4a> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5403 @053d4f> : 20                         load.i8
	<.main+5404 @053d50> : 57                         ceq.i32
	<.main+5405 @053d51> : 1f 50 1e 05 00             load.ref <@051e50> ;boolCeq
	<.main+5410 @053d56> : 25                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@053d57> - <@053d6b>): static boolCne: bool := bool(boolA != boolB)
	<.main+5411 @053d57> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5416 @053d5c> : 20                         load.i8
	<.main+5417 @053d5d> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5422 @053d62> : 20                         load.i8
	<.main+5423 @053d63> : 57                         ceq.i32
	<.main+5424 @053d64> : 0b                         not.b32
	<.main+5425 @053d65> : 1f 58 1e 05 00             load.ref <@051e58> ;boolCne
	<.main+5430 @053d6a> : 25                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@053d6b> - <@053d7e>): static boolClt: bool := bool(boolA < boolB)
	<.main+5431 @053d6b> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5436 @053d70> : 20                         load.i8
	<.main+5437 @053d71> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5442 @053d76> : 20                         load.i8
	<.main+5443 @053d77> : 58                         clt.i32
	<.main+5444 @053d78> : 1f 60 1e 05 00             load.ref <@051e60> ;boolClt
	<.main+5449 @053d7d> : 25                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@053d7e> - <@053d92>): static boolCle: bool := bool(boolA <= boolB)
	<.main+5450 @053d7e> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5455 @053d83> : 20                         load.i8
	<.main+5456 @053d84> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5461 @053d89> : 20                         load.i8
	<.main+5462 @053d8a> : 59                         cgt.i32
	<.main+5463 @053d8b> : 0b                         not.b32
	<.main+5464 @053d8c> : 1f 68 1e 05 00             load.ref <@051e68> ;boolCle
	<.main+5469 @053d91> : 25                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@053d92> - <@053da5>): static boolCgt: bool := bool(boolA > boolB)
	<.main+5470 @053d92> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5475 @053d97> : 20                         load.i8
	<.main+5476 @053d98> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5481 @053d9d> : 20                         load.i8
	<.main+5482 @053d9e> : 59                         cgt.i32
	<.main+5483 @053d9f> : 1f 70 1e 05 00             load.ref <@051e70> ;boolCgt
	<.main+5488 @053da4> : 25                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@053da5> - <@053db9>): static boolCge: bool := bool(boolA >= boolB)
	<.main+5489 @053da5> : 1f 20 1e 05 00             load.ref <@051e20> ;boolA
	<.main+5494 @053daa> : 20                         load.i8
	<.main+5495 @053dab> : 1f 28 1e 05 00             load.ref <@051e28> ;boolB
	<.main+5500 @053db0> : 20                         load.i8
	<.main+5501 @053db1> : 58                         clt.i32
	<.main+5502 @053db2> : 0b                         not.b32
	<.main+5503 @053db3> : 1f 78 1e 05 00             load.ref <@051e78> ;boolCge
	<.main+5508 @053db8> : 25                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@053db9> - <@053dc4>): static chrA: char := 'a'
	<.main+5509 @053db9> : 1c 61 00 00 00             load.c32 97
	<.main+5514 @053dbe> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5519 @053dc3> : 25                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@053dc4> - <@053dcf>): static chrB: char := 'b'
	<.main+5520 @053dc4> : 1c 62 00 00 00             load.c32 98
	<.main+5525 @053dc9> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5530 @053dce> : 25                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@053dcf> - <@053ddb>): static chrPls: char := char(+chrB)
	<.main+5531 @053dcf> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5536 @053dd4> : 20                         load.i8
	<.main+5537 @053dd5> : 1f 90 1e 05 00             load.ref <@051e90> ;chrPls
	<.main+5542 @053dda> : 25                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@053ddb> - <@053de8>): static chrNeg: char := char(-chrB)
	<.main+5543 @053ddb> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5548 @053de0> : 20                         load.i8
	<.main+5549 @053de1> : 50                         neg.i32
	<.main+5550 @053de2> : 1f 98 1e 05 00             load.ref <@051e98> ;chrNeg
	<.main+5555 @053de7> : 25                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@053de8> - <@053df5>): static chrCmt: char := char(~chrB)
	<.main+5556 @053de8> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5561 @053ded> : 20                         load.i8
	<.main+5562 @053dee> : 30                         cmt.b32
	<.main+5563 @053def> : 1f a0 1e 05 00             load.ref <@051ea0> ;chrCmt
	<.main+5568 @053df4> : 25                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@053df5> - <@053e08>): static chrAdd: char := char(chrA + chrB)
	<.main+5569 @053df5> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5574 @053dfa> : 20                         load.i8
	<.main+5575 @053dfb> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5580 @053e00> : 20                         load.i8
	<.main+5581 @053e01> : 51                         add.i32
	<.main+5582 @053e02> : 1f a8 1e 05 00             load.ref <@051ea8> ;chrAdd
	<.main+5587 @053e07> : 25                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@053e08> - <@053e1b>): static chrSub: char := char(chrA - chrB)
	<.main+5588 @053e08> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5593 @053e0d> : 20                         load.i8
	<.main+5594 @053e0e> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5599 @053e13> : 20                         load.i8
	<.main+5600 @053e14> : 52                         sub.i32
	<.main+5601 @053e15> : 1f b0 1e 05 00             load.ref <@051eb0> ;chrSub
	<.main+5606 @053e1a> : 25                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@053e1b> - <@053e2e>): static chrMul: char := char(chrA * chrB)
	<.main+5607 @053e1b> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5612 @053e20> : 20                         load.i8
	<.main+5613 @053e21> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5618 @053e26> : 20                         load.i8
	<.main+5619 @053e27> : 53                         mul.i32
	<.main+5620 @053e28> : 1f b8 1e 05 00             load.ref <@051eb8> ;chrMul
	<.main+5625 @053e2d> : 25                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@053e2e> - <@053e41>): static chrDiv: char := char(chrA / chrB)
	<.main+5626 @053e2e> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5631 @053e33> : 20                         load.i8
	<.main+5632 @053e34> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5637 @053e39> : 20                         load.i8
	<.main+5638 @053e3a> : 54                         div.i32
	<.main+5639 @053e3b> : 1f c0 1e 05 00             load.ref <@051ec0> ;chrDiv
	<.main+5644 @053e40> : 25                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@053e41> - <@053e54>): static chrMod: char := char(chrA % chrB)
	<.main+5645 @053e41> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5650 @053e46> : 20                         load.i8
	<.main+5651 @053e47> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5656 @053e4c> : 20                         load.i8
	<.main+5657 @053e4d> : 55                         mod.i32
	<.main+5658 @053e4e> : 1f c8 1e 05 00             load.ref <@051ec8> ;chrMod
	<.main+5663 @053e53> : 25                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@053e54> - <@053e67>): static chrAnd: char := char(chrA & chrB)
	<.main+5664 @053e54> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5669 @053e59> : 20                         load.i8
	<.main+5670 @053e5a> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5675 @053e5f> : 20                         load.i8
	<.main+5676 @053e60> : 31                         and.b32
	<.main+5677 @053e61> : 1f d0 1e 05 00             load.ref <@051ed0> ;chrAnd
	<.main+5682 @053e66> : 25                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@053e67> - <@053e7a>): static chrIor: char := char(chrA | chrB)
	<.main+5683 @053e67> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5688 @053e6c> : 20                         load.i8
	<.main+5689 @053e6d> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5694 @053e72> : 20                         load.i8
	<.main+5695 @053e73> : 32                         or.b32
	<.main+5696 @053e74> : 1f d8 1e 05 00             load.ref <@051ed8> ;chrIor
	<.main+5701 @053e79> : 25                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@053e7a> - <@053e8d>): static chrXor: char := char(chrA ^ chrB)
	<.main+5702 @053e7a> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5707 @053e7f> : 20                         load.i8
	<.main+5708 @053e80> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5713 @053e85> : 20                         load.i8
	<.main+5714 @053e86> : 36                         xor.b32
	<.main+5715 @053e87> : 1f e0 1e 05 00             load.ref <@051ee0> ;chrXor
	<.main+5720 @053e8c> : 25                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@053e8d> - <@053e9e>): static chrShl: char := int32((chrA) << shift)
	<.main+5721 @053e8d> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5726 @053e92> : 20                         load.i8
	<.main+5727 @053e93> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+5731 @053e97> : 3a                         shl.b32
	<.main+5732 @053e98> : 1f e8 1e 05 00             load.ref <@051ee8> ;chrShl
	<.main+5737 @053e9d> : 25                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@053e9e> - <@053eaf>): static chrShr: char := int32((chrA) >> shift)
	<.main+5738 @053e9e> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5743 @053ea3> : 20                         load.i8
	<.main+5744 @053ea4> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+5748 @053ea8> : 3c                         sar.b32
	<.main+5749 @053ea9> : 1f f0 1e 05 00             load.ref <@051ef0> ;chrShr
	<.main+5754 @053eae> : 25                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@053eaf> - <@053ebd>): static chrNot: bool := bool(!(chrB))
	<.main+5755 @053eaf> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5760 @053eb4> : 20                         load.i8
	<.main+5761 @053eb5> : 5a                         i32.2bool
	<.main+5762 @053eb6> : 0b                         not.b32
	<.main+5763 @053eb7> : 1f f8 1e 05 00             load.ref <@051ef8> ;chrNot
	<.main+5768 @053ebc> : 25                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@053ebd> - <@053ed0>): static chrCeq: bool := bool(chrA == chrB)
	<.main+5769 @053ebd> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5774 @053ec2> : 20                         load.i8
	<.main+5775 @053ec3> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5780 @053ec8> : 20                         load.i8
	<.main+5781 @053ec9> : 57                         ceq.i32
	<.main+5782 @053eca> : 1f 00 1f 05 00             load.ref <@051f00> ;chrCeq
	<.main+5787 @053ecf> : 25                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@053ed0> - <@053ee4>): static chrCne: bool := bool(chrA != chrB)
	<.main+5788 @053ed0> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5793 @053ed5> : 20                         load.i8
	<.main+5794 @053ed6> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5799 @053edb> : 20                         load.i8
	<.main+5800 @053edc> : 57                         ceq.i32
	<.main+5801 @053edd> : 0b                         not.b32
	<.main+5802 @053ede> : 1f 08 1f 05 00             load.ref <@051f08> ;chrCne
	<.main+5807 @053ee3> : 25                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@053ee4> - <@053ef7>): static chrClt: bool := bool(chrA < chrB)
	<.main+5808 @053ee4> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5813 @053ee9> : 20                         load.i8
	<.main+5814 @053eea> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5819 @053eef> : 20                         load.i8
	<.main+5820 @053ef0> : 58                         clt.i32
	<.main+5821 @053ef1> : 1f 10 1f 05 00             load.ref <@051f10> ;chrClt
	<.main+5826 @053ef6> : 25                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@053ef7> - <@053f0b>): static chrCle: bool := bool(chrA <= chrB)
	<.main+5827 @053ef7> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5832 @053efc> : 20                         load.i8
	<.main+5833 @053efd> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5838 @053f02> : 20                         load.i8
	<.main+5839 @053f03> : 59                         cgt.i32
	<.main+5840 @053f04> : 0b                         not.b32
	<.main+5841 @053f05> : 1f 18 1f 05 00             load.ref <@051f18> ;chrCle
	<.main+5846 @053f0a> : 25                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@053f0b> - <@053f1e>): static chrCgt: bool := bool(chrA > chrB)
	<.main+5847 @053f0b> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5852 @053f10> : 20                         load.i8
	<.main+5853 @053f11> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5858 @053f16> : 20                         load.i8
	<.main+5859 @053f17> : 59                         cgt.i32
	<.main+5860 @053f18> : 1f 20 1f 05 00             load.ref <@051f20> ;chrCgt
	<.main+5865 @053f1d> : 25                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@053f1e> - <@053f32>): static chrCge: bool := bool(chrA >= chrB)
	<.main+5866 @053f1e> : 1f 80 1e 05 00             load.ref <@051e80> ;chrA
	<.main+5871 @053f23> : 20                         load.i8
	<.main+5872 @053f24> : 1f 88 1e 05 00             load.ref <@051e88> ;chrB
	<.main+5877 @053f29> : 20                         load.i8
	<.main+5878 @053f2a> : 58                         clt.i32
	<.main+5879 @053f2b> : 0b                         not.b32
	<.main+5880 @053f2c> : 1f 28 1f 05 00             load.ref <@051f28> ;chrCge
	<.main+5885 @053f31> : 25                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@053f32> - <@053f3d>): static i8A: int8 := a
	<.main+5886 @053f32> : 1c 60 00 00 00             load.c32 96
	<.main+5891 @053f37> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+5896 @053f3c> : 25                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@053f3d> - <@053f48>): static i8B: int8 := b
	<.main+5897 @053f3d> : 1c 2a 00 00 00             load.c32 42
	<.main+5902 @053f42> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5907 @053f47> : 25                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@053f48> - <@053f54>): static i8Pls: int8 := int8(+i8B)
	<.main+5908 @053f48> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5913 @053f4d> : 20                         load.i8
	<.main+5914 @053f4e> : 1f 40 1f 05 00             load.ref <@051f40> ;i8Pls
	<.main+5919 @053f53> : 25                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@053f54> - <@053f61>): static i8Neg: int8 := int8(-i8B)
	<.main+5920 @053f54> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5925 @053f59> : 20                         load.i8
	<.main+5926 @053f5a> : 50                         neg.i32
	<.main+5927 @053f5b> : 1f 48 1f 05 00             load.ref <@051f48> ;i8Neg
	<.main+5932 @053f60> : 25                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@053f61> - <@053f6e>): static i8Cmt: int8 := int8(~i8B)
	<.main+5933 @053f61> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5938 @053f66> : 20                         load.i8
	<.main+5939 @053f67> : 30                         cmt.b32
	<.main+5940 @053f68> : 1f 50 1f 05 00             load.ref <@051f50> ;i8Cmt
	<.main+5945 @053f6d> : 25                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@053f6e> - <@053f81>): static i8Add: int8 := int8(i8A + i8B)
	<.main+5946 @053f6e> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+5951 @053f73> : 20                         load.i8
	<.main+5952 @053f74> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5957 @053f79> : 20                         load.i8
	<.main+5958 @053f7a> : 51                         add.i32
	<.main+5959 @053f7b> : 1f 58 1f 05 00             load.ref <@051f58> ;i8Add
	<.main+5964 @053f80> : 25                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@053f81> - <@053f94>): static i8Sub: int8 := int8(i8A - i8B)
	<.main+5965 @053f81> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+5970 @053f86> : 20                         load.i8
	<.main+5971 @053f87> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5976 @053f8c> : 20                         load.i8
	<.main+5977 @053f8d> : 52                         sub.i32
	<.main+5978 @053f8e> : 1f 60 1f 05 00             load.ref <@051f60> ;i8Sub
	<.main+5983 @053f93> : 25                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@053f94> - <@053fa7>): static i8Mul: int8 := int8(i8A * i8B)
	<.main+5984 @053f94> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+5989 @053f99> : 20                         load.i8
	<.main+5990 @053f9a> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+5995 @053f9f> : 20                         load.i8
	<.main+5996 @053fa0> : 53                         mul.i32
	<.main+5997 @053fa1> : 1f 68 1f 05 00             load.ref <@051f68> ;i8Mul
	<.main+6002 @053fa6> : 25                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@053fa7> - <@053fba>): static i8Div: int8 := int8(i8A / i8B)
	<.main+6003 @053fa7> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6008 @053fac> : 20                         load.i8
	<.main+6009 @053fad> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6014 @053fb2> : 20                         load.i8
	<.main+6015 @053fb3> : 54                         div.i32
	<.main+6016 @053fb4> : 1f 70 1f 05 00             load.ref <@051f70> ;i8Div
	<.main+6021 @053fb9> : 25                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@053fba> - <@053fcd>): static i8Mod: int8 := int8(i8A % i8B)
	<.main+6022 @053fba> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6027 @053fbf> : 20                         load.i8
	<.main+6028 @053fc0> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6033 @053fc5> : 20                         load.i8
	<.main+6034 @053fc6> : 55                         mod.i32
	<.main+6035 @053fc7> : 1f 78 1f 05 00             load.ref <@051f78> ;i8Mod
	<.main+6040 @053fcc> : 25                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@053fcd> - <@053fe0>): static i8And: int8 := int8(i8A & i8B)
	<.main+6041 @053fcd> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6046 @053fd2> : 20                         load.i8
	<.main+6047 @053fd3> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6052 @053fd8> : 20                         load.i8
	<.main+6053 @053fd9> : 31                         and.b32
	<.main+6054 @053fda> : 1f 80 1f 05 00             load.ref <@051f80> ;i8And
	<.main+6059 @053fdf> : 25                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@053fe0> - <@053ff3>): static i8Ior: int8 := int8(i8A | i8B)
	<.main+6060 @053fe0> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6065 @053fe5> : 20                         load.i8
	<.main+6066 @053fe6> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6071 @053feb> : 20                         load.i8
	<.main+6072 @053fec> : 32                         or.b32
	<.main+6073 @053fed> : 1f 88 1f 05 00             load.ref <@051f88> ;i8Ior
	<.main+6078 @053ff2> : 25                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@053ff3> - <@054006>): static i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6079 @053ff3> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6084 @053ff8> : 20                         load.i8
	<.main+6085 @053ff9> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6090 @053ffe> : 20                         load.i8
	<.main+6091 @053fff> : 36                         xor.b32
	<.main+6092 @054000> : 1f 90 1f 05 00             load.ref <@051f90> ;i8Xor
	<.main+6097 @054005> : 25                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@054006> - <@054017>): static i8Shl: int8 := int32((i8A) << shift)
	<.main+6098 @054006> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6103 @05400b> : 20                         load.i8
	<.main+6104 @05400c> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6108 @054010> : 3a                         shl.b32
	<.main+6109 @054011> : 1f 98 1f 05 00             load.ref <@051f98> ;i8Shl
	<.main+6114 @054016> : 25                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@054017> - <@054028>): static i8Shr: int8 := int32((i8A) >> shift)
	<.main+6115 @054017> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6120 @05401c> : 20                         load.i8
	<.main+6121 @05401d> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6125 @054021> : 3c                         sar.b32
	<.main+6126 @054022> : 1f a0 1f 05 00             load.ref <@051fa0> ;i8Shr
	<.main+6131 @054027> : 25                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@054028> - <@054036>): static i8Not: bool := bool(!(i8B))
	<.main+6132 @054028> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6137 @05402d> : 20                         load.i8
	<.main+6138 @05402e> : 5a                         i32.2bool
	<.main+6139 @05402f> : 0b                         not.b32
	<.main+6140 @054030> : 1f a8 1f 05 00             load.ref <@051fa8> ;i8Not
	<.main+6145 @054035> : 25                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@054036> - <@054049>): static i8Ceq: bool := bool(i8A == i8B)
	<.main+6146 @054036> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6151 @05403b> : 20                         load.i8
	<.main+6152 @05403c> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6157 @054041> : 20                         load.i8
	<.main+6158 @054042> : 57                         ceq.i32
	<.main+6159 @054043> : 1f b0 1f 05 00             load.ref <@051fb0> ;i8Ceq
	<.main+6164 @054048> : 25                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@054049> - <@05405d>): static i8Cne: bool := bool(i8A != i8B)
	<.main+6165 @054049> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6170 @05404e> : 20                         load.i8
	<.main+6171 @05404f> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6176 @054054> : 20                         load.i8
	<.main+6177 @054055> : 57                         ceq.i32
	<.main+6178 @054056> : 0b                         not.b32
	<.main+6179 @054057> : 1f b8 1f 05 00             load.ref <@051fb8> ;i8Cne
	<.main+6184 @05405c> : 25                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@05405d> - <@054070>): static i8Clt: bool := bool(i8A < i8B)
	<.main+6185 @05405d> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6190 @054062> : 20                         load.i8
	<.main+6191 @054063> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6196 @054068> : 20                         load.i8
	<.main+6197 @054069> : 58                         clt.i32
	<.main+6198 @05406a> : 1f c0 1f 05 00             load.ref <@051fc0> ;i8Clt
	<.main+6203 @05406f> : 25                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@054070> - <@054084>): static i8Cle: bool := bool(i8A <= i8B)
	<.main+6204 @054070> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6209 @054075> : 20                         load.i8
	<.main+6210 @054076> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6215 @05407b> : 20                         load.i8
	<.main+6216 @05407c> : 59                         cgt.i32
	<.main+6217 @05407d> : 0b                         not.b32
	<.main+6218 @05407e> : 1f c8 1f 05 00             load.ref <@051fc8> ;i8Cle
	<.main+6223 @054083> : 25                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@054084> - <@054097>): static i8Cgt: bool := bool(i8A > i8B)
	<.main+6224 @054084> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6229 @054089> : 20                         load.i8
	<.main+6230 @05408a> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6235 @05408f> : 20                         load.i8
	<.main+6236 @054090> : 59                         cgt.i32
	<.main+6237 @054091> : 1f d0 1f 05 00             load.ref <@051fd0> ;i8Cgt
	<.main+6242 @054096> : 25                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@054097> - <@0540ab>): static i8Cge: bool := bool(i8A >= i8B)
	<.main+6243 @054097> : 1f 30 1f 05 00             load.ref <@051f30> ;i8A
	<.main+6248 @05409c> : 20                         load.i8
	<.main+6249 @05409d> : 1f 38 1f 05 00             load.ref <@051f38> ;i8B
	<.main+6254 @0540a2> : 20                         load.i8
	<.main+6255 @0540a3> : 58                         clt.i32
	<.main+6256 @0540a4> : 0b                         not.b32
	<.main+6257 @0540a5> : 1f d8 1f 05 00             load.ref <@051fd8> ;i8Cge
	<.main+6262 @0540aa> : 25                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@0540ab> - <@0540b6>): static u8A: uint8 := a
	<.main+6263 @0540ab> : 1c 60 00 00 00             load.c32 96
	<.main+6268 @0540b0> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6273 @0540b5> : 25                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@0540b6> - <@0540c1>): static u8B: uint8 := b
	<.main+6274 @0540b6> : 1c 2a 00 00 00             load.c32 42
	<.main+6279 @0540bb> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6284 @0540c0> : 25                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@0540c1> - <@0540cd>): static u8Pls: uint8 := uint8(+u8B)
	<.main+6285 @0540c1> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6290 @0540c6> : 20                         load.i8
	<.main+6291 @0540c7> : 1f f0 1f 05 00             load.ref <@051ff0> ;u8Pls
	<.main+6296 @0540cc> : 25                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@0540cd> - <@0540da>): static u8Neg: uint8 := uint8(-u8B)
	<.main+6297 @0540cd> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6302 @0540d2> : 20                         load.i8
	<.main+6303 @0540d3> : 50                         neg.i32
	<.main+6304 @0540d4> : 1f f8 1f 05 00             load.ref <@051ff8> ;u8Neg
	<.main+6309 @0540d9> : 25                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@0540da> - <@0540e7>): static u8Cmt: uint8 := uint8(~u8B)
	<.main+6310 @0540da> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6315 @0540df> : 20                         load.i8
	<.main+6316 @0540e0> : 30                         cmt.b32
	<.main+6317 @0540e1> : 1f 00 20 05 00             load.ref <@052000> ;u8Cmt
	<.main+6322 @0540e6> : 25                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@0540e7> - <@0540fa>): static u8Add: uint8 := uint8(u8A + u8B)
	<.main+6323 @0540e7> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6328 @0540ec> : 20                         load.i8
	<.main+6329 @0540ed> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6334 @0540f2> : 20                         load.i8
	<.main+6335 @0540f3> : 51                         add.i32
	<.main+6336 @0540f4> : 1f 08 20 05 00             load.ref <@052008> ;u8Add
	<.main+6341 @0540f9> : 25                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@0540fa> - <@05410d>): static u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6342 @0540fa> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6347 @0540ff> : 20                         load.i8
	<.main+6348 @054100> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6353 @054105> : 20                         load.i8
	<.main+6354 @054106> : 52                         sub.i32
	<.main+6355 @054107> : 1f 10 20 05 00             load.ref <@052010> ;u8Sub
	<.main+6360 @05410c> : 25                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@05410d> - <@054120>): static u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6361 @05410d> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6366 @054112> : 20                         load.i8
	<.main+6367 @054113> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6372 @054118> : 20                         load.i8
	<.main+6373 @054119> : 33                         mul.u32
	<.main+6374 @05411a> : 1f 18 20 05 00             load.ref <@052018> ;u8Mul
	<.main+6379 @05411f> : 25                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@054120> - <@054133>): static u8Div: uint8 := uint8(u8A / u8B)
	<.main+6380 @054120> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6385 @054125> : 20                         load.i8
	<.main+6386 @054126> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6391 @05412b> : 20                         load.i8
	<.main+6392 @05412c> : 34                         div.u32
	<.main+6393 @05412d> : 1f 20 20 05 00             load.ref <@052020> ;u8Div
	<.main+6398 @054132> : 25                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@054133> - <@054146>): static u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6399 @054133> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6404 @054138> : 20                         load.i8
	<.main+6405 @054139> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6410 @05413e> : 20                         load.i8
	<.main+6411 @05413f> : 35                         mod.u32
	<.main+6412 @054140> : 1f 28 20 05 00             load.ref <@052028> ;u8Mod
	<.main+6417 @054145> : 25                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@054146> - <@054159>): static u8And: uint8 := uint8(u8A & u8B)
	<.main+6418 @054146> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6423 @05414b> : 20                         load.i8
	<.main+6424 @05414c> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6429 @054151> : 20                         load.i8
	<.main+6430 @054152> : 31                         and.b32
	<.main+6431 @054153> : 1f 30 20 05 00             load.ref <@052030> ;u8And
	<.main+6436 @054158> : 25                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@054159> - <@05416c>): static u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6437 @054159> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6442 @05415e> : 20                         load.i8
	<.main+6443 @05415f> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6448 @054164> : 20                         load.i8
	<.main+6449 @054165> : 32                         or.b32
	<.main+6450 @054166> : 1f 38 20 05 00             load.ref <@052038> ;u8Ior
	<.main+6455 @05416b> : 25                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@05416c> - <@05417f>): static u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6456 @05416c> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6461 @054171> : 20                         load.i8
	<.main+6462 @054172> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6467 @054177> : 20                         load.i8
	<.main+6468 @054178> : 36                         xor.b32
	<.main+6469 @054179> : 1f 40 20 05 00             load.ref <@052040> ;u8Xor
	<.main+6474 @05417e> : 25                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@05417f> - <@054190>): static u8Shl: uint8 := int32((u8A) << shift)
	<.main+6475 @05417f> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6480 @054184> : 20                         load.i8
	<.main+6481 @054185> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6485 @054189> : 3a                         shl.b32
	<.main+6486 @05418a> : 1f 48 20 05 00             load.ref <@052048> ;u8Shl
	<.main+6491 @05418f> : 25                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@054190> - <@0541a1>): static u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6492 @054190> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6497 @054195> : 20                         load.i8
	<.main+6498 @054196> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6502 @05419a> : 3c                         sar.b32
	<.main+6503 @05419b> : 1f 50 20 05 00             load.ref <@052050> ;u8Shr
	<.main+6508 @0541a0> : 25                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@0541a1> - <@0541af>): static u8Not: bool := bool(!(u8B))
	<.main+6509 @0541a1> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6514 @0541a6> : 20                         load.i8
	<.main+6515 @0541a7> : 5a                         i32.2bool
	<.main+6516 @0541a8> : 0b                         not.b32
	<.main+6517 @0541a9> : 1f 58 20 05 00             load.ref <@052058> ;u8Not
	<.main+6522 @0541ae> : 25                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@0541af> - <@0541c2>): static u8Ceq: bool := bool(u8A == u8B)
	<.main+6523 @0541af> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6528 @0541b4> : 20                         load.i8
	<.main+6529 @0541b5> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6534 @0541ba> : 20                         load.i8
	<.main+6535 @0541bb> : 57                         ceq.i32
	<.main+6536 @0541bc> : 1f 60 20 05 00             load.ref <@052060> ;u8Ceq
	<.main+6541 @0541c1> : 25                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@0541c2> - <@0541d6>): static u8Cne: bool := bool(u8A != u8B)
	<.main+6542 @0541c2> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6547 @0541c7> : 20                         load.i8
	<.main+6548 @0541c8> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6553 @0541cd> : 20                         load.i8
	<.main+6554 @0541ce> : 57                         ceq.i32
	<.main+6555 @0541cf> : 0b                         not.b32
	<.main+6556 @0541d0> : 1f 68 20 05 00             load.ref <@052068> ;u8Cne
	<.main+6561 @0541d5> : 25                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@0541d6> - <@0541e9>): static u8Clt: bool := bool(u8A < u8B)
	<.main+6562 @0541d6> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6567 @0541db> : 20                         load.i8
	<.main+6568 @0541dc> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6573 @0541e1> : 20                         load.i8
	<.main+6574 @0541e2> : 38                         clt.u32
	<.main+6575 @0541e3> : 1f 70 20 05 00             load.ref <@052070> ;u8Clt
	<.main+6580 @0541e8> : 25                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@0541e9> - <@0541fd>): static u8Cle: bool := bool(u8A <= u8B)
	<.main+6581 @0541e9> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6586 @0541ee> : 20                         load.i8
	<.main+6587 @0541ef> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6592 @0541f4> : 20                         load.i8
	<.main+6593 @0541f5> : 39                         cgt.u32
	<.main+6594 @0541f6> : 0b                         not.b32
	<.main+6595 @0541f7> : 1f 78 20 05 00             load.ref <@052078> ;u8Cle
	<.main+6600 @0541fc> : 25                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@0541fd> - <@054210>): static u8Cgt: bool := bool(u8A > u8B)
	<.main+6601 @0541fd> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6606 @054202> : 20                         load.i8
	<.main+6607 @054203> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6612 @054208> : 20                         load.i8
	<.main+6613 @054209> : 39                         cgt.u32
	<.main+6614 @05420a> : 1f 80 20 05 00             load.ref <@052080> ;u8Cgt
	<.main+6619 @05420f> : 25                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@054210> - <@054224>): static u8Cge: bool := bool(u8A >= u8B)
	<.main+6620 @054210> : 1f e0 1f 05 00             load.ref <@051fe0> ;u8A
	<.main+6625 @054215> : 20                         load.i8
	<.main+6626 @054216> : 1f e8 1f 05 00             load.ref <@051fe8> ;u8B
	<.main+6631 @05421b> : 20                         load.i8
	<.main+6632 @05421c> : 38                         clt.u32
	<.main+6633 @05421d> : 0b                         not.b32
	<.main+6634 @05421e> : 1f 88 20 05 00             load.ref <@052088> ;u8Cge
	<.main+6639 @054223> : 25                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@054224> - <@05422f>): static i16A: int16 := a
	<.main+6640 @054224> : 1c 60 00 00 00             load.c32 96
	<.main+6645 @054229> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6650 @05422e> : 26                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@05422f> - <@05423a>): static i16B: int16 := b
	<.main+6651 @05422f> : 1c 2a 00 00 00             load.c32 42
	<.main+6656 @054234> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6661 @054239> : 26                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@05423a> - <@054246>): static i16Pls: int16 := int16(+i16B)
	<.main+6662 @05423a> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6667 @05423f> : 21                         load.i16
	<.main+6668 @054240> : 1f a0 20 05 00             load.ref <@0520a0> ;i16Pls
	<.main+6673 @054245> : 26                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@054246> - <@054253>): static i16Neg: int16 := int16(-i16B)
	<.main+6674 @054246> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6679 @05424b> : 21                         load.i16
	<.main+6680 @05424c> : 50                         neg.i32
	<.main+6681 @05424d> : 1f a8 20 05 00             load.ref <@0520a8> ;i16Neg
	<.main+6686 @054252> : 26                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@054253> - <@054260>): static i16Cmt: int16 := int16(~i16B)
	<.main+6687 @054253> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6692 @054258> : 21                         load.i16
	<.main+6693 @054259> : 30                         cmt.b32
	<.main+6694 @05425a> : 1f b0 20 05 00             load.ref <@0520b0> ;i16Cmt
	<.main+6699 @05425f> : 26                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@054260> - <@054273>): static i16Add: int16 := int16(i16A + i16B)
	<.main+6700 @054260> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6705 @054265> : 21                         load.i16
	<.main+6706 @054266> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6711 @05426b> : 21                         load.i16
	<.main+6712 @05426c> : 51                         add.i32
	<.main+6713 @05426d> : 1f b8 20 05 00             load.ref <@0520b8> ;i16Add
	<.main+6718 @054272> : 26                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@054273> - <@054286>): static i16Sub: int16 := int16(i16A - i16B)
	<.main+6719 @054273> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6724 @054278> : 21                         load.i16
	<.main+6725 @054279> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6730 @05427e> : 21                         load.i16
	<.main+6731 @05427f> : 52                         sub.i32
	<.main+6732 @054280> : 1f c0 20 05 00             load.ref <@0520c0> ;i16Sub
	<.main+6737 @054285> : 26                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@054286> - <@054299>): static i16Mul: int16 := int16(i16A * i16B)
	<.main+6738 @054286> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6743 @05428b> : 21                         load.i16
	<.main+6744 @05428c> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6749 @054291> : 21                         load.i16
	<.main+6750 @054292> : 53                         mul.i32
	<.main+6751 @054293> : 1f c8 20 05 00             load.ref <@0520c8> ;i16Mul
	<.main+6756 @054298> : 26                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@054299> - <@0542ac>): static i16Div: int16 := int16(i16A / i16B)
	<.main+6757 @054299> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6762 @05429e> : 21                         load.i16
	<.main+6763 @05429f> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6768 @0542a4> : 21                         load.i16
	<.main+6769 @0542a5> : 54                         div.i32
	<.main+6770 @0542a6> : 1f d0 20 05 00             load.ref <@0520d0> ;i16Div
	<.main+6775 @0542ab> : 26                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@0542ac> - <@0542bf>): static i16Mod: int16 := int16(i16A % i16B)
	<.main+6776 @0542ac> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6781 @0542b1> : 21                         load.i16
	<.main+6782 @0542b2> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6787 @0542b7> : 21                         load.i16
	<.main+6788 @0542b8> : 55                         mod.i32
	<.main+6789 @0542b9> : 1f d8 20 05 00             load.ref <@0520d8> ;i16Mod
	<.main+6794 @0542be> : 26                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@0542bf> - <@0542d2>): static i16And: int16 := int16(i16A & i16B)
	<.main+6795 @0542bf> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6800 @0542c4> : 21                         load.i16
	<.main+6801 @0542c5> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6806 @0542ca> : 21                         load.i16
	<.main+6807 @0542cb> : 31                         and.b32
	<.main+6808 @0542cc> : 1f e0 20 05 00             load.ref <@0520e0> ;i16And
	<.main+6813 @0542d1> : 26                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@0542d2> - <@0542e5>): static i16Ior: int16 := int16(i16A | i16B)
	<.main+6814 @0542d2> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6819 @0542d7> : 21                         load.i16
	<.main+6820 @0542d8> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6825 @0542dd> : 21                         load.i16
	<.main+6826 @0542de> : 32                         or.b32
	<.main+6827 @0542df> : 1f e8 20 05 00             load.ref <@0520e8> ;i16Ior
	<.main+6832 @0542e4> : 26                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@0542e5> - <@0542f8>): static i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6833 @0542e5> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6838 @0542ea> : 21                         load.i16
	<.main+6839 @0542eb> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6844 @0542f0> : 21                         load.i16
	<.main+6845 @0542f1> : 36                         xor.b32
	<.main+6846 @0542f2> : 1f f0 20 05 00             load.ref <@0520f0> ;i16Xor
	<.main+6851 @0542f7> : 26                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@0542f8> - <@054309>): static i16Shl: int16 := int32((i16A) << shift)
	<.main+6852 @0542f8> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6857 @0542fd> : 21                         load.i16
	<.main+6858 @0542fe> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6862 @054302> : 3a                         shl.b32
	<.main+6863 @054303> : 1f f8 20 05 00             load.ref <@0520f8> ;i16Shl
	<.main+6868 @054308> : 26                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@054309> - <@05431a>): static i16Shr: int16 := int32((i16A) >> shift)
	<.main+6869 @054309> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6874 @05430e> : 21                         load.i16
	<.main+6875 @05430f> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+6879 @054313> : 3c                         sar.b32
	<.main+6880 @054314> : 1f 00 21 05 00             load.ref <@052100> ;i16Shr
	<.main+6885 @054319> : 26                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@05431a> - <@054328>): static i16Not: bool := bool(!(i16B))
	<.main+6886 @05431a> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6891 @05431f> : 21                         load.i16
	<.main+6892 @054320> : 5a                         i32.2bool
	<.main+6893 @054321> : 0b                         not.b32
	<.main+6894 @054322> : 1f 08 21 05 00             load.ref <@052108> ;i16Not
	<.main+6899 @054327> : 25                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@054328> - <@05433b>): static i16Ceq: bool := bool(i16A == i16B)
	<.main+6900 @054328> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6905 @05432d> : 21                         load.i16
	<.main+6906 @05432e> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6911 @054333> : 21                         load.i16
	<.main+6912 @054334> : 57                         ceq.i32
	<.main+6913 @054335> : 1f 10 21 05 00             load.ref <@052110> ;i16Ceq
	<.main+6918 @05433a> : 25                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@05433b> - <@05434f>): static i16Cne: bool := bool(i16A != i16B)
	<.main+6919 @05433b> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6924 @054340> : 21                         load.i16
	<.main+6925 @054341> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6930 @054346> : 21                         load.i16
	<.main+6931 @054347> : 57                         ceq.i32
	<.main+6932 @054348> : 0b                         not.b32
	<.main+6933 @054349> : 1f 18 21 05 00             load.ref <@052118> ;i16Cne
	<.main+6938 @05434e> : 25                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@05434f> - <@054362>): static i16Clt: bool := bool(i16A < i16B)
	<.main+6939 @05434f> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6944 @054354> : 21                         load.i16
	<.main+6945 @054355> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6950 @05435a> : 21                         load.i16
	<.main+6951 @05435b> : 58                         clt.i32
	<.main+6952 @05435c> : 1f 20 21 05 00             load.ref <@052120> ;i16Clt
	<.main+6957 @054361> : 25                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@054362> - <@054376>): static i16Cle: bool := bool(i16A <= i16B)
	<.main+6958 @054362> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6963 @054367> : 21                         load.i16
	<.main+6964 @054368> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6969 @05436d> : 21                         load.i16
	<.main+6970 @05436e> : 59                         cgt.i32
	<.main+6971 @05436f> : 0b                         not.b32
	<.main+6972 @054370> : 1f 28 21 05 00             load.ref <@052128> ;i16Cle
	<.main+6977 @054375> : 25                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@054376> - <@054389>): static i16Cgt: bool := bool(i16A > i16B)
	<.main+6978 @054376> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+6983 @05437b> : 21                         load.i16
	<.main+6984 @05437c> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+6989 @054381> : 21                         load.i16
	<.main+6990 @054382> : 59                         cgt.i32
	<.main+6991 @054383> : 1f 30 21 05 00             load.ref <@052130> ;i16Cgt
	<.main+6996 @054388> : 25                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@054389> - <@05439d>): static i16Cge: bool := bool(i16A >= i16B)
	<.main+6997 @054389> : 1f 90 20 05 00             load.ref <@052090> ;i16A
	<.main+7002 @05438e> : 21                         load.i16
	<.main+7003 @05438f> : 1f 98 20 05 00             load.ref <@052098> ;i16B
	<.main+7008 @054394> : 21                         load.i16
	<.main+7009 @054395> : 58                         clt.i32
	<.main+7010 @054396> : 0b                         not.b32
	<.main+7011 @054397> : 1f 38 21 05 00             load.ref <@052138> ;i16Cge
	<.main+7016 @05439c> : 25                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@05439d> - <@0543a8>): static u16A: uint16 := a
	<.main+7017 @05439d> : 1c 60 00 00 00             load.c32 96
	<.main+7022 @0543a2> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7027 @0543a7> : 26                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@0543a8> - <@0543b3>): static u16B: uint16 := b
	<.main+7028 @0543a8> : 1c 2a 00 00 00             load.c32 42
	<.main+7033 @0543ad> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7038 @0543b2> : 26                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@0543b3> - <@0543bf>): static u16Pls: uint16 := uint16(+u16B)
	<.main+7039 @0543b3> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7044 @0543b8> : 21                         load.i16
	<.main+7045 @0543b9> : 1f 50 21 05 00             load.ref <@052150> ;u16Pls
	<.main+7050 @0543be> : 26                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@0543bf> - <@0543cc>): static u16Neg: uint16 := uint16(-u16B)
	<.main+7051 @0543bf> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7056 @0543c4> : 21                         load.i16
	<.main+7057 @0543c5> : 50                         neg.i32
	<.main+7058 @0543c6> : 1f 58 21 05 00             load.ref <@052158> ;u16Neg
	<.main+7063 @0543cb> : 26                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@0543cc> - <@0543d9>): static u16Cmt: uint16 := uint16(~u16B)
	<.main+7064 @0543cc> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7069 @0543d1> : 21                         load.i16
	<.main+7070 @0543d2> : 30                         cmt.b32
	<.main+7071 @0543d3> : 1f 60 21 05 00             load.ref <@052160> ;u16Cmt
	<.main+7076 @0543d8> : 26                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@0543d9> - <@0543ec>): static u16Add: uint16 := uint16(u16A + u16B)
	<.main+7077 @0543d9> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7082 @0543de> : 21                         load.i16
	<.main+7083 @0543df> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7088 @0543e4> : 21                         load.i16
	<.main+7089 @0543e5> : 51                         add.i32
	<.main+7090 @0543e6> : 1f 68 21 05 00             load.ref <@052168> ;u16Add
	<.main+7095 @0543eb> : 26                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@0543ec> - <@0543ff>): static u16Sub: uint16 := uint16(u16A - u16B)
	<.main+7096 @0543ec> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7101 @0543f1> : 21                         load.i16
	<.main+7102 @0543f2> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7107 @0543f7> : 21                         load.i16
	<.main+7108 @0543f8> : 52                         sub.i32
	<.main+7109 @0543f9> : 1f 70 21 05 00             load.ref <@052170> ;u16Sub
	<.main+7114 @0543fe> : 26                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@0543ff> - <@054412>): static u16Mul: uint16 := uint16(u16A * u16B)
	<.main+7115 @0543ff> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7120 @054404> : 21                         load.i16
	<.main+7121 @054405> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7126 @05440a> : 21                         load.i16
	<.main+7127 @05440b> : 33                         mul.u32
	<.main+7128 @05440c> : 1f 78 21 05 00             load.ref <@052178> ;u16Mul
	<.main+7133 @054411> : 26                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@054412> - <@054425>): static u16Div: uint16 := uint16(u16A / u16B)
	<.main+7134 @054412> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7139 @054417> : 21                         load.i16
	<.main+7140 @054418> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7145 @05441d> : 21                         load.i16
	<.main+7146 @05441e> : 34                         div.u32
	<.main+7147 @05441f> : 1f 80 21 05 00             load.ref <@052180> ;u16Div
	<.main+7152 @054424> : 26                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@054425> - <@054438>): static u16Mod: uint16 := uint16(u16A % u16B)
	<.main+7153 @054425> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7158 @05442a> : 21                         load.i16
	<.main+7159 @05442b> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7164 @054430> : 21                         load.i16
	<.main+7165 @054431> : 35                         mod.u32
	<.main+7166 @054432> : 1f 88 21 05 00             load.ref <@052188> ;u16Mod
	<.main+7171 @054437> : 26                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@054438> - <@05444b>): static u16And: uint16 := uint16(u16A & u16B)
	<.main+7172 @054438> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7177 @05443d> : 21                         load.i16
	<.main+7178 @05443e> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7183 @054443> : 21                         load.i16
	<.main+7184 @054444> : 31                         and.b32
	<.main+7185 @054445> : 1f 90 21 05 00             load.ref <@052190> ;u16And
	<.main+7190 @05444a> : 26                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@05444b> - <@05445e>): static u16Ior: uint16 := uint16(u16A | u16B)
	<.main+7191 @05444b> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7196 @054450> : 21                         load.i16
	<.main+7197 @054451> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7202 @054456> : 21                         load.i16
	<.main+7203 @054457> : 32                         or.b32
	<.main+7204 @054458> : 1f 98 21 05 00             load.ref <@052198> ;u16Ior
	<.main+7209 @05445d> : 26                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@05445e> - <@054471>): static u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+7210 @05445e> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7215 @054463> : 21                         load.i16
	<.main+7216 @054464> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7221 @054469> : 21                         load.i16
	<.main+7222 @05446a> : 36                         xor.b32
	<.main+7223 @05446b> : 1f a0 21 05 00             load.ref <@0521a0> ;u16Xor
	<.main+7228 @054470> : 26                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@054471> - <@054482>): static u16Shl: uint16 := int32((u16A) << shift)
	<.main+7229 @054471> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7234 @054476> : 21                         load.i16
	<.main+7235 @054477> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7239 @05447b> : 3a                         shl.b32
	<.main+7240 @05447c> : 1f a8 21 05 00             load.ref <@0521a8> ;u16Shl
	<.main+7245 @054481> : 26                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@054482> - <@054493>): static u16Shr: uint16 := int32((u16A) >> shift)
	<.main+7246 @054482> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7251 @054487> : 21                         load.i16
	<.main+7252 @054488> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7256 @05448c> : 3c                         sar.b32
	<.main+7257 @05448d> : 1f b0 21 05 00             load.ref <@0521b0> ;u16Shr
	<.main+7262 @054492> : 26                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@054493> - <@0544a1>): static u16Not: bool := bool(!(u16B))
	<.main+7263 @054493> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7268 @054498> : 21                         load.i16
	<.main+7269 @054499> : 5a                         i32.2bool
	<.main+7270 @05449a> : 0b                         not.b32
	<.main+7271 @05449b> : 1f b8 21 05 00             load.ref <@0521b8> ;u16Not
	<.main+7276 @0544a0> : 25                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@0544a1> - <@0544b4>): static u16Ceq: bool := bool(u16A == u16B)
	<.main+7277 @0544a1> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7282 @0544a6> : 21                         load.i16
	<.main+7283 @0544a7> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7288 @0544ac> : 21                         load.i16
	<.main+7289 @0544ad> : 57                         ceq.i32
	<.main+7290 @0544ae> : 1f c0 21 05 00             load.ref <@0521c0> ;u16Ceq
	<.main+7295 @0544b3> : 25                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@0544b4> - <@0544c8>): static u16Cne: bool := bool(u16A != u16B)
	<.main+7296 @0544b4> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7301 @0544b9> : 21                         load.i16
	<.main+7302 @0544ba> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7307 @0544bf> : 21                         load.i16
	<.main+7308 @0544c0> : 57                         ceq.i32
	<.main+7309 @0544c1> : 0b                         not.b32
	<.main+7310 @0544c2> : 1f c8 21 05 00             load.ref <@0521c8> ;u16Cne
	<.main+7315 @0544c7> : 25                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@0544c8> - <@0544db>): static u16Clt: bool := bool(u16A < u16B)
	<.main+7316 @0544c8> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7321 @0544cd> : 21                         load.i16
	<.main+7322 @0544ce> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7327 @0544d3> : 21                         load.i16
	<.main+7328 @0544d4> : 38                         clt.u32
	<.main+7329 @0544d5> : 1f d0 21 05 00             load.ref <@0521d0> ;u16Clt
	<.main+7334 @0544da> : 25                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@0544db> - <@0544ef>): static u16Cle: bool := bool(u16A <= u16B)
	<.main+7335 @0544db> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7340 @0544e0> : 21                         load.i16
	<.main+7341 @0544e1> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7346 @0544e6> : 21                         load.i16
	<.main+7347 @0544e7> : 39                         cgt.u32
	<.main+7348 @0544e8> : 0b                         not.b32
	<.main+7349 @0544e9> : 1f d8 21 05 00             load.ref <@0521d8> ;u16Cle
	<.main+7354 @0544ee> : 25                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@0544ef> - <@054502>): static u16Cgt: bool := bool(u16A > u16B)
	<.main+7355 @0544ef> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7360 @0544f4> : 21                         load.i16
	<.main+7361 @0544f5> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7366 @0544fa> : 21                         load.i16
	<.main+7367 @0544fb> : 39                         cgt.u32
	<.main+7368 @0544fc> : 1f e0 21 05 00             load.ref <@0521e0> ;u16Cgt
	<.main+7373 @054501> : 25                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@054502> - <@054516>): static u16Cge: bool := bool(u16A >= u16B)
	<.main+7374 @054502> : 1f 40 21 05 00             load.ref <@052140> ;u16A
	<.main+7379 @054507> : 21                         load.i16
	<.main+7380 @054508> : 1f 48 21 05 00             load.ref <@052148> ;u16B
	<.main+7385 @05450d> : 21                         load.i16
	<.main+7386 @05450e> : 38                         clt.u32
	<.main+7387 @05450f> : 0b                         not.b32
	<.main+7388 @054510> : 1f e8 21 05 00             load.ref <@0521e8> ;u16Cge
	<.main+7393 @054515> : 25                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@054516> - <@05451f>): static i32A: int32 := a
	<.main+7394 @054516> : 1c 60 00 00 00             load.c32 96
	<.main+7399 @05451b> : 2e f0 21 05                store.m32 <@0521f0> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@05451f> - <@054528>): static i32B: int32 := b
	<.main+7403 @05451f> : 1c 2a 00 00 00             load.c32 42
	<.main+7408 @054524> : 2e f8 21 05                store.m32 <@0521f8> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@054528> - <@054530>): static i32Pls: int32 := int32(+i32B)
	<.main+7412 @054528> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7416 @05452c> : 2e 00 22 05                store.m32 <@052200> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@054530> - <@054539>): static i32Neg: int32 := int32(-i32B)
	<.main+7420 @054530> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7424 @054534> : 50                         neg.i32
	<.main+7425 @054535> : 2e 08 22 05                store.m32 <@052208> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@054539> - <@054542>): static i32Cmt: int32 := int32(~i32B)
	<.main+7429 @054539> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7433 @05453d> : 30                         cmt.b32
	<.main+7434 @05453e> : 2e 10 22 05                store.m32 <@052210> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@054542> - <@05454f>): static i32Add: int32 := int32(i32A + i32B)
	<.main+7438 @054542> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7442 @054546> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7446 @05454a> : 51                         add.i32
	<.main+7447 @05454b> : 2e 18 22 05                store.m32 <@052218> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@05454f> - <@05455c>): static i32Sub: int32 := int32(i32A - i32B)
	<.main+7451 @05454f> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7455 @054553> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7459 @054557> : 52                         sub.i32
	<.main+7460 @054558> : 2e 20 22 05                store.m32 <@052220> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@05455c> - <@054569>): static i32Mul: int32 := int32(i32A * i32B)
	<.main+7464 @05455c> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7468 @054560> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7472 @054564> : 53                         mul.i32
	<.main+7473 @054565> : 2e 28 22 05                store.m32 <@052228> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@054569> - <@054576>): static i32Div: int32 := int32(i32A / i32B)
	<.main+7477 @054569> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7481 @05456d> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7485 @054571> : 54                         div.i32
	<.main+7486 @054572> : 2e 30 22 05                store.m32 <@052230> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@054576> - <@054583>): static i32Mod: int32 := int32(i32A % i32B)
	<.main+7490 @054576> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7494 @05457a> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7498 @05457e> : 55                         mod.i32
	<.main+7499 @05457f> : 2e 38 22 05                store.m32 <@052238> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@054583> - <@054590>): static i32And: int32 := int32(i32A & i32B)
	<.main+7503 @054583> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7507 @054587> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7511 @05458b> : 31                         and.b32
	<.main+7512 @05458c> : 2e 40 22 05                store.m32 <@052240> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@054590> - <@05459d>): static i32Ior: int32 := int32(i32A | i32B)
	<.main+7516 @054590> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7520 @054594> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7524 @054598> : 32                         or.b32
	<.main+7525 @054599> : 2e 48 22 05                store.m32 <@052248> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@05459d> - <@0545aa>): static i32Xor: int32 := int32(i32A ^ i32B)
	<.main+7529 @05459d> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7533 @0545a1> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7537 @0545a5> : 36                         xor.b32
	<.main+7538 @0545a6> : 2e 50 22 05                store.m32 <@052250> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@0545aa> - <@0545b7>): static i32Shl: int32 := int32(i32A << shift)
	<.main+7542 @0545aa> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7546 @0545ae> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7550 @0545b2> : 3a                         shl.b32
	<.main+7551 @0545b3> : 2e 58 22 05                store.m32 <@052258> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@0545b7> - <@0545c4>): static i32Shr: int32 := int32(i32A >> shift)
	<.main+7555 @0545b7> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7559 @0545bb> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7563 @0545bf> : 3c                         sar.b32
	<.main+7564 @0545c0> : 2e 60 22 05                store.m32 <@052260> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@0545c4> - <@0545d0>): static i32Not: bool := bool(!(i32B))
	<.main+7568 @0545c4> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7572 @0545c8> : 5a                         i32.2bool
	<.main+7573 @0545c9> : 0b                         not.b32
	<.main+7574 @0545ca> : 1f 68 22 05 00             load.ref <@052268> ;i32Not
	<.main+7579 @0545cf> : 25                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@0545d0> - <@0545df>): static i32Ceq: bool := bool(i32A == i32B)
	<.main+7580 @0545d0> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7584 @0545d4> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7588 @0545d8> : 57                         ceq.i32
	<.main+7589 @0545d9> : 1f 70 22 05 00             load.ref <@052270> ;i32Ceq
	<.main+7594 @0545de> : 25                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@0545df> - <@0545ef>): static i32Cne: bool := bool(i32A != i32B)
	<.main+7595 @0545df> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7599 @0545e3> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7603 @0545e7> : 57                         ceq.i32
	<.main+7604 @0545e8> : 0b                         not.b32
	<.main+7605 @0545e9> : 1f 78 22 05 00             load.ref <@052278> ;i32Cne
	<.main+7610 @0545ee> : 25                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@0545ef> - <@0545fe>): static i32Clt: bool := bool(i32A < i32B)
	<.main+7611 @0545ef> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7615 @0545f3> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7619 @0545f7> : 58                         clt.i32
	<.main+7620 @0545f8> : 1f 80 22 05 00             load.ref <@052280> ;i32Clt
	<.main+7625 @0545fd> : 25                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@0545fe> - <@05460e>): static i32Cle: bool := bool(i32A <= i32B)
	<.main+7626 @0545fe> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7630 @054602> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7634 @054606> : 59                         cgt.i32
	<.main+7635 @054607> : 0b                         not.b32
	<.main+7636 @054608> : 1f 88 22 05 00             load.ref <@052288> ;i32Cle
	<.main+7641 @05460d> : 25                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@05460e> - <@05461d>): static i32Cgt: bool := bool(i32A > i32B)
	<.main+7642 @05460e> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7646 @054612> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7650 @054616> : 59                         cgt.i32
	<.main+7651 @054617> : 1f 90 22 05 00             load.ref <@052290> ;i32Cgt
	<.main+7656 @05461c> : 25                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@05461d> - <@05462d>): static i32Cge: bool := bool(i32A >= i32B)
	<.main+7657 @05461d> : 2a f0 21 05                load.m32 <@0521f0> ;i32A
	<.main+7661 @054621> : 2a f8 21 05                load.m32 <@0521f8> ;i32B
	<.main+7665 @054625> : 58                         clt.i32
	<.main+7666 @054626> : 0b                         not.b32
	<.main+7667 @054627> : 1f 98 22 05 00             load.ref <@052298> ;i32Cge
	<.main+7672 @05462c> : 25                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@05462d> - <@054636>): static u32A: uint32 := a
	<.main+7673 @05462d> : 1c 60 00 00 00             load.c32 96
	<.main+7678 @054632> : 2e a0 22 05                store.m32 <@0522a0> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@054636> - <@05463f>): static u32B: uint32 := b
	<.main+7682 @054636> : 1c 2a 00 00 00             load.c32 42
	<.main+7687 @05463b> : 2e a8 22 05                store.m32 <@0522a8> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@05463f> - <@054647>): static u32Pls: uint32 := uint32(+u32B)
	<.main+7691 @05463f> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7695 @054643> : 2e b0 22 05                store.m32 <@0522b0> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@054647> - <@054650>): static u32Neg: uint32 := uint32(-u32B)
	<.main+7699 @054647> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7703 @05464b> : 50                         neg.i32
	<.main+7704 @05464c> : 2e b8 22 05                store.m32 <@0522b8> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@054650> - <@054659>): static u32Cmt: uint32 := uint32(~u32B)
	<.main+7708 @054650> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7712 @054654> : 30                         cmt.b32
	<.main+7713 @054655> : 2e c0 22 05                store.m32 <@0522c0> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@054659> - <@054666>): static u32Add: uint32 := uint32(u32A + u32B)
	<.main+7717 @054659> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7721 @05465d> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7725 @054661> : 51                         add.i32
	<.main+7726 @054662> : 2e c8 22 05                store.m32 <@0522c8> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@054666> - <@054673>): static u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7730 @054666> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7734 @05466a> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7738 @05466e> : 52                         sub.i32
	<.main+7739 @05466f> : 2e d0 22 05                store.m32 <@0522d0> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@054673> - <@054680>): static u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7743 @054673> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7747 @054677> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7751 @05467b> : 33                         mul.u32
	<.main+7752 @05467c> : 2e d8 22 05                store.m32 <@0522d8> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@054680> - <@05468d>): static u32Div: uint32 := uint32(u32A / u32B)
	<.main+7756 @054680> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7760 @054684> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7764 @054688> : 34                         div.u32
	<.main+7765 @054689> : 2e e0 22 05                store.m32 <@0522e0> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@05468d> - <@05469a>): static u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7769 @05468d> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7773 @054691> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7777 @054695> : 35                         mod.u32
	<.main+7778 @054696> : 2e e8 22 05                store.m32 <@0522e8> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@05469a> - <@0546a7>): static u32And: uint32 := uint32(u32A & u32B)
	<.main+7782 @05469a> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7786 @05469e> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7790 @0546a2> : 31                         and.b32
	<.main+7791 @0546a3> : 2e f0 22 05                store.m32 <@0522f0> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@0546a7> - <@0546b4>): static u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7795 @0546a7> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7799 @0546ab> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7803 @0546af> : 32                         or.b32
	<.main+7804 @0546b0> : 2e f8 22 05                store.m32 <@0522f8> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@0546b4> - <@0546c1>): static u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7808 @0546b4> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7812 @0546b8> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7816 @0546bc> : 36                         xor.b32
	<.main+7817 @0546bd> : 2e 00 23 05                store.m32 <@052300> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@0546c1> - <@0546ce>): static u32Shl: uint32 := uint32(u32A << shift)
	<.main+7821 @0546c1> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7825 @0546c5> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7829 @0546c9> : 3a                         shl.b32
	<.main+7830 @0546ca> : 2e 08 23 05                store.m32 <@052308> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@0546ce> - <@0546db>): static u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7834 @0546ce> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7838 @0546d2> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+7842 @0546d6> : 3b                         shr.b32
	<.main+7843 @0546d7> : 2e 10 23 05                store.m32 <@052310> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@0546db> - <@0546e7>): static u32Not: bool := bool(!(u32B))
	<.main+7847 @0546db> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7851 @0546df> : 5a                         i32.2bool
	<.main+7852 @0546e0> : 0b                         not.b32
	<.main+7853 @0546e1> : 1f 18 23 05 00             load.ref <@052318> ;u32Not
	<.main+7858 @0546e6> : 25                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@0546e7> - <@0546f6>): static u32Ceq: bool := bool(u32A == u32B)
	<.main+7859 @0546e7> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7863 @0546eb> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7867 @0546ef> : 57                         ceq.i32
	<.main+7868 @0546f0> : 1f 20 23 05 00             load.ref <@052320> ;u32Ceq
	<.main+7873 @0546f5> : 25                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@0546f6> - <@054706>): static u32Cne: bool := bool(u32A != u32B)
	<.main+7874 @0546f6> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7878 @0546fa> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7882 @0546fe> : 57                         ceq.i32
	<.main+7883 @0546ff> : 0b                         not.b32
	<.main+7884 @054700> : 1f 28 23 05 00             load.ref <@052328> ;u32Cne
	<.main+7889 @054705> : 25                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@054706> - <@054715>): static u32Clt: bool := bool(u32A < u32B)
	<.main+7890 @054706> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7894 @05470a> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7898 @05470e> : 38                         clt.u32
	<.main+7899 @05470f> : 1f 30 23 05 00             load.ref <@052330> ;u32Clt
	<.main+7904 @054714> : 25                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@054715> - <@054725>): static u32Cle: bool := bool(u32A <= u32B)
	<.main+7905 @054715> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7909 @054719> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7913 @05471d> : 39                         cgt.u32
	<.main+7914 @05471e> : 0b                         not.b32
	<.main+7915 @05471f> : 1f 38 23 05 00             load.ref <@052338> ;u32Cle
	<.main+7920 @054724> : 25                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@054725> - <@054734>): static u32Cgt: bool := bool(u32A > u32B)
	<.main+7921 @054725> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7925 @054729> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7929 @05472d> : 39                         cgt.u32
	<.main+7930 @05472e> : 1f 40 23 05 00             load.ref <@052340> ;u32Cgt
	<.main+7935 @054733> : 25                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@054734> - <@054744>): static u32Cge: bool := bool(u32A >= u32B)
	<.main+7936 @054734> : 2a a0 22 05                load.m32 <@0522a0> ;u32A
	<.main+7940 @054738> : 2a a8 22 05                load.m32 <@0522a8> ;u32B
	<.main+7944 @05473c> : 38                         clt.u32
	<.main+7945 @05473d> : 0b                         not.b32
	<.main+7946 @05473e> : 1f 48 23 05 00             load.ref <@052348> ;u32Cge
	<.main+7951 @054743> : 25                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@054744> - <@054751>): static i64A: int64 := a
	<.main+7952 @054744> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+7961 @05474d> : 2d 50 23 05                store.m64 <@052350> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@054751> - <@05475e>): static i64B: int64 := b
	<.main+7965 @054751> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+7974 @05475a> : 2d 58 23 05                store.m64 <@052358> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@05475e> - <@054766>): static i64Pls: int64 := int64(+i64B)
	<.main+7978 @05475e> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+7982 @054762> : 2d 60 23 05                store.m64 <@052360> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@054766> - <@05476f>): static i64Neg: int64 := int64(-i64B)
	<.main+7986 @054766> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+7990 @05476a> : 60                         neg.i64
	<.main+7991 @05476b> : 2d 68 23 05                store.m64 <@052368> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@05476f> - <@054778>): static i64Cmt: int64 := int64(~i64B)
	<.main+7995 @05476f> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+7999 @054773> : 40                         cmt.b64
	<.main+8000 @054774> : 2d 70 23 05                store.m64 <@052370> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@054778> - <@054785>): static i64Add: int64 := int64(i64A + i64B)
	<.main+8004 @054778> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8008 @05477c> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8012 @054780> : 61                         add.i64
	<.main+8013 @054781> : 2d 78 23 05                store.m64 <@052378> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@054785> - <@054792>): static i64Sub: int64 := int64(i64A - i64B)
	<.main+8017 @054785> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8021 @054789> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8025 @05478d> : 62                         sub.i64
	<.main+8026 @05478e> : 2d 80 23 05                store.m64 <@052380> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@054792> - <@05479f>): static i64Mul: int64 := int64(i64A * i64B)
	<.main+8030 @054792> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8034 @054796> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8038 @05479a> : 63                         mul.i64
	<.main+8039 @05479b> : 2d 88 23 05                store.m64 <@052388> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@05479f> - <@0547ac>): static i64Div: int64 := int64(i64A / i64B)
	<.main+8043 @05479f> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8047 @0547a3> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8051 @0547a7> : 64                         div.i64
	<.main+8052 @0547a8> : 2d 90 23 05                store.m64 <@052390> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@0547ac> - <@0547b9>): static i64Mod: int64 := int64(i64A % i64B)
	<.main+8056 @0547ac> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8060 @0547b0> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8064 @0547b4> : 65                         mod.i64
	<.main+8065 @0547b5> : 2d 98 23 05                store.m64 <@052398> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@0547b9> - <@0547c6>): static i64And: int64 := int64(i64A & i64B)
	<.main+8069 @0547b9> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8073 @0547bd> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8077 @0547c1> : 41                         and.b64
	<.main+8078 @0547c2> : 2d a0 23 05                store.m64 <@0523a0> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@0547c6> - <@0547d3>): static i64Ior: int64 := int64(i64A | i64B)
	<.main+8082 @0547c6> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8086 @0547ca> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8090 @0547ce> : 42                         or.b64
	<.main+8091 @0547cf> : 2d a8 23 05                store.m64 <@0523a8> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@0547d3> - <@0547e0>): static i64Xor: int64 := int64(i64A ^ i64B)
	<.main+8095 @0547d3> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8099 @0547d7> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8103 @0547db> : 46                         xor.b64
	<.main+8104 @0547dc> : 2d b0 23 05                store.m64 <@0523b0> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@0547e0> - <@0547ed>): static i64Shl: int64 := int64(i64A << shift)
	<.main+8108 @0547e0> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8112 @0547e4> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+8116 @0547e8> : 4a                         shl.b64
	<.main+8117 @0547e9> : 2d b8 23 05                store.m64 <@0523b8> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@0547ed> - <@0547fa>): static i64Shr: int64 := int64(i64A >> shift)
	<.main+8121 @0547ed> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8125 @0547f1> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+8129 @0547f5> : 4c                         sar.b64
	<.main+8130 @0547f6> : 2d c0 23 05                store.m64 <@0523c0> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@0547fa> - <@054806>): static i64Not: bool := bool(!(i64B))
	<.main+8134 @0547fa> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8138 @0547fe> : 6b                         i64.2bool
	<.main+8139 @0547ff> : 0b                         not.b32
	<.main+8140 @054800> : 1f c8 23 05 00             load.ref <@0523c8> ;i64Not
	<.main+8145 @054805> : 25                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@054806> - <@054815>): static i64Ceq: bool := bool(i64A == i64B)
	<.main+8146 @054806> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8150 @05480a> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8154 @05480e> : 67                         ceq.i64
	<.main+8155 @05480f> : 1f d0 23 05 00             load.ref <@0523d0> ;i64Ceq
	<.main+8160 @054814> : 25                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@054815> - <@054825>): static i64Cne: bool := bool(i64A != i64B)
	<.main+8161 @054815> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8165 @054819> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8169 @05481d> : 67                         ceq.i64
	<.main+8170 @05481e> : 0b                         not.b32
	<.main+8171 @05481f> : 1f d8 23 05 00             load.ref <@0523d8> ;i64Cne
	<.main+8176 @054824> : 25                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@054825> - <@054834>): static i64Clt: bool := bool(i64A < i64B)
	<.main+8177 @054825> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8181 @054829> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8185 @05482d> : 68                         clt.i64
	<.main+8186 @05482e> : 1f e0 23 05 00             load.ref <@0523e0> ;i64Clt
	<.main+8191 @054833> : 25                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@054834> - <@054844>): static i64Cle: bool := bool(i64A <= i64B)
	<.main+8192 @054834> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8196 @054838> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8200 @05483c> : 69                         cgt.i64
	<.main+8201 @05483d> : 0b                         not.b32
	<.main+8202 @05483e> : 1f e8 23 05 00             load.ref <@0523e8> ;i64Cle
	<.main+8207 @054843> : 25                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@054844> - <@054853>): static i64Cgt: bool := bool(i64A > i64B)
	<.main+8208 @054844> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8212 @054848> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8216 @05484c> : 69                         cgt.i64
	<.main+8217 @05484d> : 1f f0 23 05 00             load.ref <@0523f0> ;i64Cgt
	<.main+8222 @054852> : 25                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@054853> - <@054863>): static i64Cge: bool := bool(i64A >= i64B)
	<.main+8223 @054853> : 2b 50 23 05                load.m64 <@052350> ;i64A
	<.main+8227 @054857> : 2b 58 23 05                load.m64 <@052358> ;i64B
	<.main+8231 @05485b> : 68                         clt.i64
	<.main+8232 @05485c> : 0b                         not.b32
	<.main+8233 @05485d> : 1f f8 23 05 00             load.ref <@0523f8> ;i64Cge
	<.main+8238 @054862> : 25                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@054863> - <@054870>): static u64A: uint64 := a
	<.main+8239 @054863> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8248 @05486c> : 2d 00 24 05                store.m64 <@052400> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@054870> - <@05487d>): static u64B: uint64 := b
	<.main+8252 @054870> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8261 @054879> : 2d 08 24 05                store.m64 <@052408> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@05487d> - <@054885>): static u64Pls: uint64 := uint64(+u64B)
	<.main+8265 @05487d> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8269 @054881> : 2d 10 24 05                store.m64 <@052410> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@054885> - <@05488e>): static u64Neg: uint64 := uint64(-u64B)
	<.main+8273 @054885> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8277 @054889> : 60                         neg.i64
	<.main+8278 @05488a> : 2d 18 24 05                store.m64 <@052418> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@05488e> - <@054897>): static u64Cmt: uint64 := uint64(~u64B)
	<.main+8282 @05488e> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8286 @054892> : 40                         cmt.b64
	<.main+8287 @054893> : 2d 20 24 05                store.m64 <@052420> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@054897> - <@0548a4>): static u64Add: uint64 := uint64(u64A + u64B)
	<.main+8291 @054897> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8295 @05489b> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8299 @05489f> : 61                         add.i64
	<.main+8300 @0548a0> : 2d 28 24 05                store.m64 <@052428> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@0548a4> - <@0548b1>): static u64Sub: uint64 := uint64(u64A - u64B)
	<.main+8304 @0548a4> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8308 @0548a8> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8312 @0548ac> : 62                         sub.i64
	<.main+8313 @0548ad> : 2d 30 24 05                store.m64 <@052430> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@0548b1> - <@0548be>): static u64Mul: uint64 := uint64(u64A * u64B)
	<.main+8317 @0548b1> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8321 @0548b5> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8325 @0548b9> : 43                         mul.u64
	<.main+8326 @0548ba> : 2d 38 24 05                store.m64 <@052438> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@0548be> - <@0548cb>): static u64Div: uint64 := uint64(u64A / u64B)
	<.main+8330 @0548be> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8334 @0548c2> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8338 @0548c6> : 44                         div.u64
	<.main+8339 @0548c7> : 2d 40 24 05                store.m64 <@052440> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@0548cb> - <@0548d8>): static u64Mod: uint64 := uint64(u64A % u64B)
	<.main+8343 @0548cb> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8347 @0548cf> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8351 @0548d3> : 45                         mod.u64
	<.main+8352 @0548d4> : 2d 48 24 05                store.m64 <@052448> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@0548d8> - <@0548e5>): static u64And: uint64 := uint64(u64A & u64B)
	<.main+8356 @0548d8> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8360 @0548dc> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8364 @0548e0> : 41                         and.b64
	<.main+8365 @0548e1> : 2d 50 24 05                store.m64 <@052450> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@0548e5> - <@0548f2>): static u64Ior: uint64 := uint64(u64A | u64B)
	<.main+8369 @0548e5> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8373 @0548e9> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8377 @0548ed> : 42                         or.b64
	<.main+8378 @0548ee> : 2d 58 24 05                store.m64 <@052458> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@0548f2> - <@0548ff>): static u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+8382 @0548f2> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8386 @0548f6> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8390 @0548fa> : 46                         xor.b64
	<.main+8391 @0548fb> : 2d 60 24 05                store.m64 <@052460> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@0548ff> - <@05490c>): static u64Shl: uint64 := uint64(u64A << shift)
	<.main+8395 @0548ff> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8399 @054903> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+8403 @054907> : 4a                         shl.b64
	<.main+8404 @054908> : 2d 68 24 05                store.m64 <@052468> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@05490c> - <@054919>): static u64Shr: uint64 := uint64(u64A >> shift)
	<.main+8408 @05490c> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8412 @054910> : 2a 18 1e 05                load.m32 <@051e18> ;shift
	<.main+8416 @054914> : 4b                         shr.b64
	<.main+8417 @054915> : 2d 70 24 05                store.m64 <@052470> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@054919> - <@054925>): static u64Not: bool := bool(!(u64B))
	<.main+8421 @054919> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8425 @05491d> : 6b                         i64.2bool
	<.main+8426 @05491e> : 0b                         not.b32
	<.main+8427 @05491f> : 1f 78 24 05 00             load.ref <@052478> ;u64Not
	<.main+8432 @054924> : 25                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@054925> - <@054934>): static u64Ceq: bool := bool(u64A == u64B)
	<.main+8433 @054925> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8437 @054929> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8441 @05492d> : 67                         ceq.i64
	<.main+8442 @05492e> : 1f 80 24 05 00             load.ref <@052480> ;u64Ceq
	<.main+8447 @054933> : 25                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@054934> - <@054944>): static u64Cne: bool := bool(u64A != u64B)
	<.main+8448 @054934> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8452 @054938> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8456 @05493c> : 67                         ceq.i64
	<.main+8457 @05493d> : 0b                         not.b32
	<.main+8458 @05493e> : 1f 88 24 05 00             load.ref <@052488> ;u64Cne
	<.main+8463 @054943> : 25                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@054944> - <@054953>): static u64Clt: bool := bool(u64A < u64B)
	<.main+8464 @054944> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8468 @054948> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8472 @05494c> : 48                         clt.u64
	<.main+8473 @05494d> : 1f 90 24 05 00             load.ref <@052490> ;u64Clt
	<.main+8478 @054952> : 25                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@054953> - <@054963>): static u64Cle: bool := bool(u64A <= u64B)
	<.main+8479 @054953> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8483 @054957> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8487 @05495b> : 49                         cgt.u64
	<.main+8488 @05495c> : 0b                         not.b32
	<.main+8489 @05495d> : 1f 98 24 05 00             load.ref <@052498> ;u64Cle
	<.main+8494 @054962> : 25                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@054963> - <@054972>): static u64Cgt: bool := bool(u64A > u64B)
	<.main+8495 @054963> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8499 @054967> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8503 @05496b> : 49                         cgt.u64
	<.main+8504 @05496c> : 1f a0 24 05 00             load.ref <@0524a0> ;u64Cgt
	<.main+8509 @054971> : 25                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@054972> - <@054982>): static u64Cge: bool := bool(u64A >= u64B)
	<.main+8510 @054972> : 2b 00 24 05                load.m64 <@052400> ;u64A
	<.main+8514 @054976> : 2b 08 24 05                load.m64 <@052408> ;u64B
	<.main+8518 @05497a> : 48                         clt.u64
	<.main+8519 @05497b> : 0b                         not.b32
	<.main+8520 @05497c> : 1f a8 24 05 00             load.ref <@0524a8> ;u64Cge
	<.main+8525 @054981> : 25                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@054982> - <@05498b>): static f32A: float32 := a
	<.main+8526 @054982> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8531 @054987> : 2e b0 24 05                store.m32 <@0524b0> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@05498b> - <@054994>): static f32B: float32 := b
	<.main+8535 @05498b> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8540 @054990> : 2e b8 24 05                store.m32 <@0524b8> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@054994> - <@05499c>): static f32Pls: float32 := float32(+f32B)
	<.main+8544 @054994> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8548 @054998> : 2e c0 24 05                store.m32 <@0524c0> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@05499c> - <@0549a5>): static f32Neg: float32 := float32(-f32B)
	<.main+8552 @05499c> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8556 @0549a0> : 70                         neg.f32
	<.main+8557 @0549a1> : 2e c8 24 05                store.m32 <@0524c8> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@0549a5> - <@0549b2>): static f32Add: float32 := float32(f32A + f32B)
	<.main+8561 @0549a5> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8565 @0549a9> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8569 @0549ad> : 71                         add.f32
	<.main+8570 @0549ae> : 2e d0 24 05                store.m32 <@0524d0> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@0549b2> - <@0549bf>): static f32Sub: float32 := float32(f32A - f32B)
	<.main+8574 @0549b2> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8578 @0549b6> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8582 @0549ba> : 72                         sub.f32
	<.main+8583 @0549bb> : 2e d8 24 05                store.m32 <@0524d8> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@0549bf> - <@0549cc>): static f32Mul: float32 := float32(f32A * f32B)
	<.main+8587 @0549bf> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8591 @0549c3> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8595 @0549c7> : 73                         mul.f32
	<.main+8596 @0549c8> : 2e e0 24 05                store.m32 <@0524e0> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@0549cc> - <@0549d9>): static f32Div: float32 := float32(f32A / f32B)
	<.main+8600 @0549cc> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8604 @0549d0> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8608 @0549d4> : 74                         div.f32
	<.main+8609 @0549d5> : 2e e8 24 05                store.m32 <@0524e8> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@0549d9> - <@0549e6>): static f32Mod: float32 := float32(f32A % f32B)
	<.main+8613 @0549d9> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8617 @0549dd> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8621 @0549e1> : 75                         mod.f32
	<.main+8622 @0549e2> : 2e f0 24 05                store.m32 <@0524f0> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@0549e6> - <@0549f2>): static f32Not: bool := bool(!(f32B))
	<.main+8626 @0549e6> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8630 @0549ea> : 7c                         f32.2bool
	<.main+8631 @0549eb> : 0b                         not.b32
	<.main+8632 @0549ec> : 1f f8 24 05 00             load.ref <@0524f8> ;f32Not
	<.main+8637 @0549f1> : 25                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@0549f2> - <@054a01>): static f32Ceq: bool := bool(f32A == f32B)
	<.main+8638 @0549f2> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8642 @0549f6> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8646 @0549fa> : 77                         ceq.f32
	<.main+8647 @0549fb> : 1f 00 25 05 00             load.ref <@052500> ;f32Ceq
	<.main+8652 @054a00> : 25                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@054a01> - <@054a11>): static f32Cne: bool := bool(f32A != f32B)
	<.main+8653 @054a01> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8657 @054a05> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8661 @054a09> : 77                         ceq.f32
	<.main+8662 @054a0a> : 0b                         not.b32
	<.main+8663 @054a0b> : 1f 08 25 05 00             load.ref <@052508> ;f32Cne
	<.main+8668 @054a10> : 25                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@054a11> - <@054a20>): static f32Clt: bool := bool(f32A < f32B)
	<.main+8669 @054a11> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8673 @054a15> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8677 @054a19> : 78                         clt.f32
	<.main+8678 @054a1a> : 1f 10 25 05 00             load.ref <@052510> ;f32Clt
	<.main+8683 @054a1f> : 25                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@054a20> - <@054a30>): static f32Cle: bool := bool(f32A <= f32B)
	<.main+8684 @054a20> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8688 @054a24> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8692 @054a28> : 79                         cgt.f32
	<.main+8693 @054a29> : 0b                         not.b32
	<.main+8694 @054a2a> : 1f 18 25 05 00             load.ref <@052518> ;f32Cle
	<.main+8699 @054a2f> : 25                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@054a30> - <@054a3f>): static f32Cgt: bool := bool(f32A > f32B)
	<.main+8700 @054a30> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8704 @054a34> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8708 @054a38> : 79                         cgt.f32
	<.main+8709 @054a39> : 1f 20 25 05 00             load.ref <@052520> ;f32Cgt
	<.main+8714 @054a3e> : 25                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@054a3f> - <@054a4f>): static f32Cge: bool := bool(f32A >= f32B)
	<.main+8715 @054a3f> : 2a b0 24 05                load.m32 <@0524b0> ;f32A
	<.main+8719 @054a43> : 2a b8 24 05                load.m32 <@0524b8> ;f32B
	<.main+8723 @054a47> : 78                         clt.f32
	<.main+8724 @054a48> : 0b                         not.b32
	<.main+8725 @054a49> : 1f 28 25 05 00             load.ref <@052528> ;f32Cge
	<.main+8730 @054a4e> : 25                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@054a4f> - <@054a5c>): static f64A: float64 := a
	<.main+8731 @054a4f> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8740 @054a58> : 2d 30 25 05                store.m64 <@052530> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@054a5c> - <@054a69>): static f64B: float64 := b
	<.main+8744 @054a5c> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8753 @054a65> : 2d 38 25 05                store.m64 <@052538> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@054a69> - <@054a71>): static f64Pls: float64 := float64(+f64B)
	<.main+8757 @054a69> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8761 @054a6d> : 2d 40 25 05                store.m64 <@052540> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@054a71> - <@054a7a>): static f64Neg: float64 := float64(-f64B)
	<.main+8765 @054a71> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8769 @054a75> : 80                         neg.f64
	<.main+8770 @054a76> : 2d 48 25 05                store.m64 <@052548> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@054a7a> - <@054a87>): static f64Add: float64 := float64(f64A + f64B)
	<.main+8774 @054a7a> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8778 @054a7e> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8782 @054a82> : 81                         add.f64
	<.main+8783 @054a83> : 2d 50 25 05                store.m64 <@052550> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@054a87> - <@054a94>): static f64Sub: float64 := float64(f64A - f64B)
	<.main+8787 @054a87> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8791 @054a8b> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8795 @054a8f> : 82                         sub.f64
	<.main+8796 @054a90> : 2d 58 25 05                store.m64 <@052558> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@054a94> - <@054aa1>): static f64Mul: float64 := float64(f64A * f64B)
	<.main+8800 @054a94> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8804 @054a98> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8808 @054a9c> : 83                         mul.f64
	<.main+8809 @054a9d> : 2d 60 25 05                store.m64 <@052560> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@054aa1> - <@054aae>): static f64Div: float64 := float64(f64A / f64B)
	<.main+8813 @054aa1> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8817 @054aa5> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8821 @054aa9> : 84                         div.f64
	<.main+8822 @054aaa> : 2d 68 25 05                store.m64 <@052568> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@054aae> - <@054abb>): static f64Mod: float64 := float64(f64A % f64B)
	<.main+8826 @054aae> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8830 @054ab2> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8834 @054ab6> : 85                         mod.f64
	<.main+8835 @054ab7> : 2d 70 25 05                store.m64 <@052570> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@054abb> - <@054ac7>): static f64Not: bool := bool(!(f64B))
	<.main+8839 @054abb> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8843 @054abf> : 8d                         f64.2bool
	<.main+8844 @054ac0> : 0b                         not.b32
	<.main+8845 @054ac1> : 1f 78 25 05 00             load.ref <@052578> ;f64Not
	<.main+8850 @054ac6> : 25                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@054ac7> - <@054ad6>): static f64Ceq: bool := bool(f64A == f64B)
	<.main+8851 @054ac7> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8855 @054acb> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8859 @054acf> : 87                         ceq.f64
	<.main+8860 @054ad0> : 1f 80 25 05 00             load.ref <@052580> ;f64Ceq
	<.main+8865 @054ad5> : 25                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@054ad6> - <@054ae6>): static f64Cne: bool := bool(f64A != f64B)
	<.main+8866 @054ad6> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8870 @054ada> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8874 @054ade> : 87                         ceq.f64
	<.main+8875 @054adf> : 0b                         not.b32
	<.main+8876 @054ae0> : 1f 88 25 05 00             load.ref <@052588> ;f64Cne
	<.main+8881 @054ae5> : 25                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@054ae6> - <@054af5>): static f64Clt: bool := bool(f64A < f64B)
	<.main+8882 @054ae6> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8886 @054aea> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8890 @054aee> : 88                         clt.f64
	<.main+8891 @054aef> : 1f 90 25 05 00             load.ref <@052590> ;f64Clt
	<.main+8896 @054af4> : 25                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@054af5> - <@054b05>): static f64Cle: bool := bool(f64A <= f64B)
	<.main+8897 @054af5> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8901 @054af9> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8905 @054afd> : 89                         cgt.f64
	<.main+8906 @054afe> : 0b                         not.b32
	<.main+8907 @054aff> : 1f 98 25 05 00             load.ref <@052598> ;f64Cle
	<.main+8912 @054b04> : 25                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@054b05> - <@054b14>): static f64Cgt: bool := bool(f64A > f64B)
	<.main+8913 @054b05> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8917 @054b09> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8921 @054b0d> : 89                         cgt.f64
	<.main+8922 @054b0e> : 1f a0 25 05 00             load.ref <@0525a0> ;f64Cgt
	<.main+8927 @054b13> : 25                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@054b14> - <@054b24>): static f64Cge: bool := bool(f64A >= f64B)
	<.main+8928 @054b14> : 2b 30 25 05                load.m64 <@052530> ;f64A
	<.main+8932 @054b18> : 2b 38 25 05                load.m64 <@052538> ;f64B
	<.main+8936 @054b1c> : 88                         clt.f64
	<.main+8937 @054b1d> : 0b                         not.b32
	<.main+8938 @054b1e> : 1f a8 25 05 00             load.ref <@0525a8> ;f64Cge
	<.main+8943 @054b23> : 25                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@054b24> - <@054b2d>): static ptrA: pointer := null
	<.main+8944 @054b24> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8949 @054b29> : 2e b0 25 05                store.m32 <@0525b0> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@054b2d> - <@054b36>): static ptrB: pointer := pointer(shift)
	<.main+8953 @054b2d> : 1f 18 1e 05 00             load.ref <@051e18> ;shift
	<.main+8958 @054b32> : 2e b8 25 05                store.m32 <@0525b8> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@054b36> - <@054b45>): static ptrCeq: bool := bool(ptrA == ptrB)
	<.main+8962 @054b36> : 2a b0 25 05                load.m32 <@0525b0> ;ptrA
	<.main+8966 @054b3a> : 2a b8 25 05                load.m32 <@0525b8> ;ptrB
	<.main+8970 @054b3e> : 57                         ceq.i32
	<.main+8971 @054b3f> : 1f c0 25 05 00             load.ref <@0525c0> ;ptrCeq
	<.main+8976 @054b44> : 25                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@054b45> - <@054b55>): static ptrCne: bool := bool(ptrA != ptrB)
	<.main+8977 @054b45> : 2a b0 25 05                load.m32 <@0525b0> ;ptrA
	<.main+8981 @054b49> : 2a b8 25 05                load.m32 <@0525b8> ;ptrB
	<.main+8985 @054b4d> : 57                         ceq.i32
	<.main+8986 @054b4e> : 0b                         not.b32
	<.main+8987 @054b4f> : 1f c8 25 05 00             load.ref <@0525c8> ;ptrCne
	<.main+8992 @054b54> : 25                         store.i8
	test/lang/statementIf.ci:26: (5 bytes: <@054b55> - <@054b5a>): static t: int32 := 0
	<.main+8993 @054b55> : 19                         load.z32
	<.main+8994 @054b56> : 2e d0 25 05                store.m32 <@0525d0> ;t
	test/lang/statementFor.ci:12: (5 bytes: <@054b5a> - <@054b5f>): static forIdx: int32
	<.main+8998 @054b5a> : 19                         load.z32
	<.main+8999 @054b5b> : 2e d8 25 05                store.m32 <@0525d8> ;forIdx
	test/stdc/test.math.ci:3: (24 bytes: <@054b5f> - <@054b77>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9003 @054b5f> : 1a                         load.z64
	<.main+9004 @054b60> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9013 @054b69> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9018 @054b6e> : 02                         call
	<.main+9019 @054b6f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9023 @054b73> : 2d e0 25 05                store.m64 <@0525e0> ;testMathFloor_1
	test/stdc/test.math.ci:4: (24 bytes: <@054b77> - <@054b8f>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9027 @054b77> : 1a                         load.z64
	<.main+9028 @054b78> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9037 @054b81> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9042 @054b86> : 02                         call
	<.main+9043 @054b87> : 09 f8 ff ff                inc.sp(-8)
	<.main+9047 @054b8b> : 2d e8 25 05                store.m64 <@0525e8> ;testMathFloor_2
	test/stdc/test.math.ci:5: (24 bytes: <@054b8f> - <@054ba7>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9051 @054b8f> : 1a                         load.z64
	<.main+9052 @054b90> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9061 @054b99> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9066 @054b9e> : 02                         call
	<.main+9067 @054b9f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9071 @054ba3> : 2d f0 25 05                store.m64 <@0525f0> ;testMathFloor_3
	test/stdc/test.math.ci:6: (24 bytes: <@054ba7> - <@054bbf>): static testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+9075 @054ba7> : 1a                         load.z64
	<.main+9076 @054ba8> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9085 @054bb1> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9090 @054bb6> : 02                         call
	<.main+9091 @054bb7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9095 @054bbb> : 2d f8 25 05                store.m64 <@0525f8> ;testMathFloor_4
	test/stdc/test.math.ci:7: (24 bytes: <@054bbf> - <@054bd7>): static testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+9099 @054bbf> : 1a                         load.z64
	<.main+9100 @054bc0> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9109 @054bc9> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9114 @054bce> : 02                         call
	<.main+9115 @054bcf> : 09 f8 ff ff                inc.sp(-8)
	<.main+9119 @054bd3> : 2d 00 26 05                store.m64 <@052600> ;testMathFloor_5
	test/stdc/test.math.ci:8: (24 bytes: <@054bd7> - <@054bef>): static testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+9123 @054bd7> : 1a                         load.z64
	<.main+9124 @054bd8> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9133 @054be1> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+9138 @054be6> : 02                         call
	<.main+9139 @054be7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9143 @054beb> : 2d 08 26 05                store.m64 <@052608> ;testMathFloor_6
	test/stdc/test.math.ci:10: (29 bytes: <@054bef> - <@054c0c>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9147 @054bef> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9156 @054bf8> : 11 00                      dup.x64 sp(0)
	<.main+9158 @054bfa> : 1a                         load.z64
	<.main+9159 @054bfb> : 89                         cgt.f64
	<.main+9160 @054bfc> : 11 01                      dup.x64 sp(1)
	<.main+9162 @054bfe> : 1a                         load.z64
	<.main+9163 @054bff> : 88                         clt.f64
	<.main+9164 @054c00> : 52                         sub.i32
	<.main+9165 @054c01> : 13 02                      set.x32 sp(2)
	<.main+9167 @054c03> : 09 fc ff ff                inc.sp(-4)
	<.main+9171 @054c07> : 5d                         i32.2f64
	<.main+9172 @054c08> : 2d 10 26 05                store.m64 <@052610> ;testMathSign_1F
	test/stdc/test.math.ci:11: (21 bytes: <@054c0c> - <@054c21>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9176 @054c0c> : 1a                         load.z64
	<.main+9177 @054c0d> : 11 00                      dup.x64 sp(0)
	<.main+9179 @054c0f> : 1a                         load.z64
	<.main+9180 @054c10> : 89                         cgt.f64
	<.main+9181 @054c11> : 11 01                      dup.x64 sp(1)
	<.main+9183 @054c13> : 1a                         load.z64
	<.main+9184 @054c14> : 88                         clt.f64
	<.main+9185 @054c15> : 52                         sub.i32
	<.main+9186 @054c16> : 13 02                      set.x32 sp(2)
	<.main+9188 @054c18> : 09 fc ff ff                inc.sp(-4)
	<.main+9192 @054c1c> : 5d                         i32.2f64
	<.main+9193 @054c1d> : 2d 18 26 05                store.m64 <@052618> ;testMathSign_2F
	test/stdc/test.math.ci:12: (29 bytes: <@054c21> - <@054c3e>): static testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+9197 @054c21> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9206 @054c2a> : 11 00                      dup.x64 sp(0)
	<.main+9208 @054c2c> : 1a                         load.z64
	<.main+9209 @054c2d> : 89                         cgt.f64
	<.main+9210 @054c2e> : 11 01                      dup.x64 sp(1)
	<.main+9212 @054c30> : 1a                         load.z64
	<.main+9213 @054c31> : 88                         clt.f64
	<.main+9214 @054c32> : 52                         sub.i32
	<.main+9215 @054c33> : 13 02                      set.x32 sp(2)
	<.main+9217 @054c35> : 09 fc ff ff                inc.sp(-4)
	<.main+9221 @054c39> : 5d                         i32.2f64
	<.main+9222 @054c3a> : 2d 20 26 05                store.m64 <@052620> ;testMathSign_3F
	test/stdc/test.math.ci:13: (21 bytes: <@054c3e> - <@054c53>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9226 @054c3e> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9231 @054c43> : 10 00                      dup.x32 sp(0)
	<.main+9233 @054c45> : 19                         load.z32
	<.main+9234 @054c46> : 79                         cgt.f32
	<.main+9235 @054c47> : 10 01                      dup.x32 sp(1)
	<.main+9237 @054c49> : 19                         load.z32
	<.main+9238 @054c4a> : 78                         clt.f32
	<.main+9239 @054c4b> : 52                         sub.i32
	<.main+9240 @054c4c> : 13 01                      set.x32 sp(1)
	<.main+9242 @054c4e> : 5d                         i32.2f64
	<.main+9243 @054c4f> : 2d 28 26 05                store.m64 <@052628> ;testMathSign_1f
	test/stdc/test.math.ci:14: (17 bytes: <@054c53> - <@054c64>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9247 @054c53> : 19                         load.z32
	<.main+9248 @054c54> : 10 00                      dup.x32 sp(0)
	<.main+9250 @054c56> : 19                         load.z32
	<.main+9251 @054c57> : 79                         cgt.f32
	<.main+9252 @054c58> : 10 01                      dup.x32 sp(1)
	<.main+9254 @054c5a> : 19                         load.z32
	<.main+9255 @054c5b> : 78                         clt.f32
	<.main+9256 @054c5c> : 52                         sub.i32
	<.main+9257 @054c5d> : 13 01                      set.x32 sp(1)
	<.main+9259 @054c5f> : 5d                         i32.2f64
	<.main+9260 @054c60> : 2d 30 26 05                store.m64 <@052630> ;testMathSign_2f
	test/stdc/test.math.ci:15: (21 bytes: <@054c64> - <@054c79>): static testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+9264 @054c64> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9269 @054c69> : 10 00                      dup.x32 sp(0)
	<.main+9271 @054c6b> : 19                         load.z32
	<.main+9272 @054c6c> : 79                         cgt.f32
	<.main+9273 @054c6d> : 10 01                      dup.x32 sp(1)
	<.main+9275 @054c6f> : 19                         load.z32
	<.main+9276 @054c70> : 78                         clt.f32
	<.main+9277 @054c71> : 52                         sub.i32
	<.main+9278 @054c72> : 13 01                      set.x32 sp(1)
	<.main+9280 @054c74> : 5d                         i32.2f64
	<.main+9281 @054c75> : 2d 38 26 05                store.m64 <@052638> ;testMathSign_3f
	test/stdc/test.math.ci:17: (24 bytes: <@054c79> - <@054c91>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9285 @054c79> : 1a                         load.z64
	<.main+9286 @054c7a> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9295 @054c83> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+9300 @054c88> : 02                         call
	<.main+9301 @054c89> : 09 f8 ff ff                inc.sp(-8)
	<.main+9305 @054c8d> : 2d 40 26 05                store.m64 <@052640> ;testMathAbs_1F
	test/stdc/test.math.ci:18: (15 bytes: <@054c91> - <@054ca0>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9309 @054c91> : 1b                         load.z128
	<.main+9310 @054c92> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+9315 @054c97> : 02                         call
	<.main+9316 @054c98> : 09 f8 ff ff                inc.sp(-8)
	<.main+9320 @054c9c> : 2d 48 26 05                store.m64 <@052648> ;testMathAbs_2F
	test/stdc/test.math.ci:19: (24 bytes: <@054ca0> - <@054cb8>): static testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+9324 @054ca0> : 1a                         load.z64
	<.main+9325 @054ca1> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9334 @054caa> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+9339 @054caf> : 02                         call
	<.main+9340 @054cb0> : 09 f8 ff ff                inc.sp(-8)
	<.main+9344 @054cb4> : 2d 50 26 05                store.m64 <@052650> ;testMathAbs_3F
	test/stdc/test.math.ci:20: (21 bytes: <@054cb8> - <@054ccd>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9348 @054cb8> : 19                         load.z32
	<.main+9349 @054cb9> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9354 @054cbe> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+9359 @054cc3> : 02                         call
	<.main+9360 @054cc4> : 09 fc ff ff                inc.sp(-4)
	<.main+9364 @054cc8> : 7d                         f32.2f64
	<.main+9365 @054cc9> : 2d 58 26 05                store.m64 <@052658> ;testMathAbs_1f
	test/stdc/test.math.ci:21: (17 bytes: <@054ccd> - <@054cde>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9369 @054ccd> : 19                         load.z32
	<.main+9370 @054cce> : 19                         load.z32
	<.main+9371 @054ccf> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+9376 @054cd4> : 02                         call
	<.main+9377 @054cd5> : 09 fc ff ff                inc.sp(-4)
	<.main+9381 @054cd9> : 7d                         f32.2f64
	<.main+9382 @054cda> : 2d 60 26 05                store.m64 <@052660> ;testMathAbs_2f
	test/stdc/test.math.ci:22: (21 bytes: <@054cde> - <@054cf3>): static testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+9386 @054cde> : 19                         load.z32
	<.main+9387 @054cdf> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9392 @054ce4> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+9397 @054ce9> : 02                         call
	<.main+9398 @054cea> : 09 fc ff ff                inc.sp(-4)
	<.main+9402 @054cee> : 7d                         f32.2f64
	<.main+9403 @054cef> : 2d 68 26 05                store.m64 <@052668> ;testMathAbs_3f
	test/stdc/test.math.ci:24: (26 bytes: <@054cf3> - <@054d0d>): static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9407 @054cf3> : 19                         load.z32
	<.main+9408 @054cf4> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9413 @054cf9> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9418 @054cfe> : 1f 50 03 05 00             load.ref <@050350> ;Math.min(a: float32, b: float32): float32
	<.main+9423 @054d03> : 02                         call
	<.main+9424 @054d04> : 09 f8 ff ff                inc.sp(-8)
	<.main+9428 @054d08> : 7d                         f32.2f64
	<.main+9429 @054d09> : 2d 70 26 05                store.m64 <@052670> ;testMathMin_1f
	test/stdc/test.math.ci:25: (26 bytes: <@054d0d> - <@054d27>): static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9433 @054d0d> : 19                         load.z32
	<.main+9434 @054d0e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9439 @054d13> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9444 @054d18> : 1f 80 03 05 00             load.ref <@050380> ;Math.max(a: float32, b: float32): float32
	<.main+9449 @054d1d> : 02                         call
	<.main+9450 @054d1e> : 09 f8 ff ff                inc.sp(-8)
	<.main+9454 @054d22> : 7d                         f32.2f64
	<.main+9455 @054d23> : 2d 78 26 05                store.m64 <@052678> ;testMathMax_2f
	test/stdc/test.math.ci:26: (33 bytes: <@054d27> - <@054d48>): static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9459 @054d27> : 1a                         load.z64
	<.main+9460 @054d28> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9469 @054d31> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9478 @054d3a> : 1f 68 03 05 00             load.ref <@050368> ;Math.min(a: float64, b: float64): float64
	<.main+9483 @054d3f> : 02                         call
	<.main+9484 @054d40> : 09 f0 ff ff                inc.sp(-16)
	<.main+9488 @054d44> : 2d 80 26 05                store.m64 <@052680> ;testMathMin_1F
	test/stdc/test.math.ci:27: (33 bytes: <@054d48> - <@054d69>): static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9492 @054d48> : 1a                         load.z64
	<.main+9493 @054d49> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9502 @054d52> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9511 @054d5b> : 1f 98 03 05 00             load.ref <@050398> ;Math.max(a: float64, b: float64): float64
	<.main+9516 @054d60> : 02                         call
	<.main+9517 @054d61> : 09 f0 ff ff                inc.sp(-16)
	<.main+9521 @054d65> : 2d 88 26 05                store.m64 <@052688> ;testMathMax_2F
	test/stdc/test.math.ci:29: (27 bytes: <@054d69> - <@054d84>): static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9525 @054d69> : 19                         load.z32
	<.main+9526 @054d6a> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9531 @054d6f> : 19                         load.z32
	<.main+9532 @054d70> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9537 @054d75> : 1f b0 03 05 00             load.ref <@0503b0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9542 @054d7a> : 02                         call
	<.main+9543 @054d7b> : 09 f4 ff ff                inc.sp(-12)
	<.main+9547 @054d7f> : 7d                         f32.2f64
	<.main+9548 @054d80> : 2d 90 26 05                store.m64 <@052690> ;testMathClamp_1f
	test/stdc/test.math.ci:30: (34 bytes: <@054d84> - <@054da6>): static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9552 @054d84> : 1a                         load.z64
	<.main+9553 @054d85> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9562 @054d8e> : 1a                         load.z64
	<.main+9563 @054d8f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9572 @054d98> : 1f d0 03 05 00             load.ref <@0503d0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9577 @054d9d> : 02                         call
	<.main+9578 @054d9e> : 09 e8 ff ff                inc.sp(-24)
	<.main+9582 @054da2> : 2d 98 26 05                store.m64 <@052698> ;testMathClamp_1F
	test/stdc/test.math.ci:32: (25 bytes: <@054da6> - <@054dbf>): static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9586 @054da6> : 19                         load.z32
	<.main+9587 @054da7> : 10 00                      dup.x32 sp(0)
	<.main+9589 @054da9> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9594 @054dae> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9599 @054db3> : 10 03                      dup.x32 sp(3)
	<.main+9601 @054db5> : 72                         sub.f32
	<.main+9602 @054db6> : 73                         mul.f32
	<.main+9603 @054db7> : 71                         add.f32
	<.main+9604 @054db8> : 13 01                      set.x32 sp(1)
	<.main+9606 @054dba> : 7d                         f32.2f64
	<.main+9607 @054dbb> : 2d a0 26 05                store.m64 <@0526a0> ;testMathLerp_1f
	test/stdc/test.math.ci:33: (32 bytes: <@054dbf> - <@054ddf>): static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9611 @054dbf> : 1a                         load.z64
	<.main+9612 @054dc0> : 11 00                      dup.x64 sp(0)
	<.main+9614 @054dc2> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9623 @054dcb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9632 @054dd4> : 11 06                      dup.x64 sp(6)
	<.main+9634 @054dd6> : 82                         sub.f64
	<.main+9635 @054dd7> : 83                         mul.f64
	<.main+9636 @054dd8> : 81                         add.f64
	<.main+9637 @054dd9> : 14 02                      set.x64 sp(2)
	<.main+9639 @054ddb> : 2d a8 26 05                store.m64 <@0526a8> ;testMathLerp_1F
	test/stdc/test.math.ci:35: (64 bytes: <@054ddf> - <@054e1f>): static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9643 @054ddf> : 19                         load.z32
	<.main+9644 @054de0> : 19                         load.z32
	<.main+9645 @054de1> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9650 @054de6> : 10 02                      dup.x32 sp(2)
	<.main+9652 @054de8> : 72                         sub.f32
	<.main+9653 @054de9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9658 @054dee> : 10 03                      dup.x32 sp(3)
	<.main+9660 @054df0> : 72                         sub.f32
	<.main+9661 @054df1> : 74                         div.f32
	<.main+9662 @054df2> : 19                         load.z32
	<.main+9663 @054df3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9668 @054df8> : 1f b0 03 05 00             load.ref <@0503b0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9673 @054dfd> : 02                         call
	<.main+9674 @054dfe> : 09 f4 ff ff                inc.sp(-12)
	<.main+9678 @054e02> : 10 00                      dup.x32 sp(0)
	<.main+9680 @054e04> : 10 01                      dup.x32 sp(1)
	<.main+9682 @054e06> : 73                         mul.f32
	<.main+9683 @054e07> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9688 @054e0c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9693 @054e11> : 10 03                      dup.x32 sp(3)
	<.main+9695 @054e13> : 73                         mul.f32
	<.main+9696 @054e14> : 72                         sub.f32
	<.main+9697 @054e15> : 73                         mul.f32
	<.main+9698 @054e16> : 13 01                      set.x32 sp(1)
	<.main+9700 @054e18> : 13 01                      set.x32 sp(1)
	<.main+9702 @054e1a> : 7d                         f32.2f64
	<.main+9703 @054e1b> : 2d b0 26 05                store.m64 <@0526b0> ;testMathSmooth_1f
	test/stdc/test.math.ci:36: (82 bytes: <@054e1f> - <@054e71>): static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9707 @054e1f> : 1b                         load.z128
	<.main+9708 @054e20> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9717 @054e29> : 11 04                      dup.x64 sp(4)
	<.main+9719 @054e2b> : 82                         sub.f64
	<.main+9720 @054e2c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9729 @054e35> : 11 06                      dup.x64 sp(6)
	<.main+9731 @054e37> : 82                         sub.f64
	<.main+9732 @054e38> : 84                         div.f64
	<.main+9733 @054e39> : 1a                         load.z64
	<.main+9734 @054e3a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9743 @054e43> : 1f d0 03 05 00             load.ref <@0503d0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9748 @054e48> : 02                         call
	<.main+9749 @054e49> : 09 e8 ff ff                inc.sp(-24)
	<.main+9753 @054e4d> : 11 00                      dup.x64 sp(0)
	<.main+9755 @054e4f> : 11 02                      dup.x64 sp(2)
	<.main+9757 @054e51> : 83                         mul.f64
	<.main+9758 @054e52> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9767 @054e5b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9776 @054e64> : 11 06                      dup.x64 sp(6)
	<.main+9778 @054e66> : 83                         mul.f64
	<.main+9779 @054e67> : 82                         sub.f64
	<.main+9780 @054e68> : 83                         mul.f64
	<.main+9781 @054e69> : 14 02                      set.x64 sp(2)
	<.main+9783 @054e6b> : 14 02                      set.x64 sp(2)
	<.main+9785 @054e6d> : 2d b8 26 05                store.m64 <@0526b8> ;testMathSmooth_1F
	test/stdc/test.math.ci:38: (25 bytes: <@054e71> - <@054e8a>): static testMathMin_nan: float64 := Math.min()
	<.main+9789 @054e71> : 19                         load.z32
	<.main+9790 @054e72> : 0a 04 00 00                load.sp(+4)
	<.main+9794 @054e76> : 1a                         load.z64
	<.main+9795 @054e77> : 11 02                      dup.x64 sp(2)
	<.main+9797 @054e79> : 1f f0 03 05 00             load.ref <@0503f0> ;Math.min(data: float64[]): float64
	<.main+9802 @054e7e> : 02                         call
	<.main+9803 @054e7f> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9806 @054e82> : 09 f0 ff ff                inc.sp(-16)
	<.main+9810 @054e86> : 2d c0 26 05                store.m64 <@0526c0> ;testMathMin_nan
	test/stdc/test.math.ci:39: (110 bytes: <@054e8a> - <@054ef8>): static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9814 @054e8a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9823 @054e93> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9832 @054e9c> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9841 @054ea5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9850 @054eae> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9859 @054eb7> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9868 @054ec0> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9877 @054ec9> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9886 @054ed2> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9895 @054edb> : 1c 09 00 00 00             load.c32 9
	<.main+9900 @054ee0> : 0a 04 00 00                load.sp(+4)
	<.main+9904 @054ee4> : 1a                         load.z64
	<.main+9905 @054ee5> : 11 02                      dup.x64 sp(2)
	<.main+9907 @054ee7> : 1f f0 03 05 00             load.ref <@0503f0> ;Math.min(data: float64[]): float64
	<.main+9912 @054eec> : 02                         call
	<.main+9913 @054eed> : 17 16 02                   mov.x64 sp(22, 2)
	<.main+9916 @054ef0> : 09 a8 ff ff                inc.sp(-88)
	<.main+9920 @054ef4> : 2d c8 26 05                store.m64 <@0526c8> ;testMathMin_1
	test/stdc/test.math.ci:40: (25 bytes: <@054ef8> - <@054f11>): static testMathMax_nan: float64 := Math.max()
	<.main+9924 @054ef8> : 19                         load.z32
	<.main+9925 @054ef9> : 0a 04 00 00                load.sp(+4)
	<.main+9929 @054efd> : 1a                         load.z64
	<.main+9930 @054efe> : 11 02                      dup.x64 sp(2)
	<.main+9932 @054f00> : 1f 38 04 05 00             load.ref <@050438> ;Math.max(data: float64[]): float64
	<.main+9937 @054f05> : 02                         call
	<.main+9938 @054f06> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9941 @054f09> : 09 f0 ff ff                inc.sp(-16)
	<.main+9945 @054f0d> : 2d d0 26 05                store.m64 <@0526d0> ;testMathMax_nan
	test/stdc/test.math.ci:41: (110 bytes: <@054f11> - <@054f7f>): static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9949 @054f11> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9958 @054f1a> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9967 @054f23> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9976 @054f2c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9985 @054f35> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9994 @054f3e> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10003 @054f47>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10012 @054f50>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10021 @054f59>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10030 @054f62>: 1c 09 00 00 00             load.c32 9
	<.main+10035 @054f67>: 0a 04 00 00                load.sp(+4)
	<.main+10039 @054f6b>: 1a                         load.z64
	<.main+10040 @054f6c>: 11 02                      dup.x64 sp(2)
	<.main+10042 @054f6e>: 1f 38 04 05 00             load.ref <@050438> ;Math.max(data: float64[]): float64
	<.main+10047 @054f73>: 02                         call
	<.main+10048 @054f74>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10051 @054f77>: 09 a8 ff ff                inc.sp(-88)
	<.main+10055 @054f7b>: 2d d8 26 05                store.m64 <@0526d8> ;testMathMax_9
	test/stdc/test.math.ci:43: (25 bytes: <@054f7f> - <@054f98>): static testMathSum_0: float64 := Math.sum()
	<.main+10059 @054f7f>: 19                         load.z32
	<.main+10060 @054f80>: 0a 04 00 00                load.sp(+4)
	<.main+10064 @054f84>: 1a                         load.z64
	<.main+10065 @054f85>: 11 02                      dup.x64 sp(2)
	<.main+10067 @054f87>: 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+10072 @054f8c>: 02                         call
	<.main+10073 @054f8d>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10076 @054f90>: 09 f0 ff ff                inc.sp(-16)
	<.main+10080 @054f94>: 2d e0 26 05                store.m64 <@0526e0> ;testMathSum_0
	test/stdc/test.math.ci:44: (38 bytes: <@054f98> - <@054fbe>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10084 @054f98>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10093 @054fa1>: 1c 01 00 00 00             load.c32 1
	<.main+10098 @054fa6>: 0a 04 00 00                load.sp(+4)
	<.main+10102 @054faa>: 1a                         load.z64
	<.main+10103 @054fab>: 11 02                      dup.x64 sp(2)
	<.main+10105 @054fad>: 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+10110 @054fb2>: 02                         call
	<.main+10111 @054fb3>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10114 @054fb6>: 09 e8 ff ff                inc.sp(-24)
	<.main+10118 @054fba>: 2d e8 26 05                store.m64 <@0526e8> ;testMathSum_1
	test/stdc/test.math.ci:45: (47 bytes: <@054fbe> - <@054fed>): static testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+10122 @054fbe>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10131 @054fc7>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10140 @054fd0>: 1c 02 00 00 00             load.c32 2
	<.main+10145 @054fd5>: 0a 04 00 00                load.sp(+4)
	<.main+10149 @054fd9>: 1a                         load.z64
	<.main+10150 @054fda>: 11 02                      dup.x64 sp(2)
	<.main+10152 @054fdc>: 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+10157 @054fe1>: 02                         call
	<.main+10158 @054fe2>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10161 @054fe5>: 09 e0 ff ff                inc.sp(-32)
	<.main+10165 @054fe9>: 2d f0 26 05                store.m64 <@0526f0> ;testMathSum_3
	test/stdc/test.math.ci:46: (119 bytes: <@054fed> - <@055064>): static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+10169 @054fed>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10178 @054ff6>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10187 @054fff>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10196 @055008>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10205 @055011>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10214 @05501a>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10223 @055023>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10232 @05502c>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10241 @055035>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10250 @05503e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10259 @055047>: 1c 0a 00 00 00             load.c32 10
	<.main+10264 @05504c>: 0a 04 00 00                load.sp(+4)
	<.main+10268 @055050>: 1a                         load.z64
	<.main+10269 @055051>: 11 02                      dup.x64 sp(2)
	<.main+10271 @055053>: 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+10276 @055058>: 02                         call
	<.main+10277 @055059>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10280 @05505c>: 09 a0 ff ff                inc.sp(-96)
	<.main+10284 @055060>: 2d f8 26 05                store.m64 <@0526f8> ;testMathSum_55
	test/stdc/test.math.ci:48: (13 bytes: <@055064> - <@055071>): static testMathEval_x: float64 := 10
	<.main+10288 @055064>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10297 @05506d>: 2d 00 27 05                store.m64 <@052700> ;testMathEval_x
	test/stdc/test.math.ci:49: (29 bytes: <@055071> - <@05508e>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10301 @055071>: 19                         load.z32
	<.main+10302 @055072>: 0a 04 00 00                load.sp(+4)
	<.main+10306 @055076>: 1a                         load.z64
	<.main+10307 @055077>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10311 @05507b>: 11 04                      dup.x64 sp(4)
	<.main+10313 @05507d>: 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10318 @055082>: 02                         call
	<.main+10319 @055083>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10322 @055086>: 09 e8 ff ff                inc.sp(-24)
	<.main+10326 @05508a>: 2d 08 27 05                store.m64 <@052708> ;testMathEval_0
	test/stdc/test.math.ci:50: (13 bytes: <@05508e> - <@05509b>): static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+10330 @05508e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10339 @055097>: 2d 10 27 05                store.m64 <@052710> ;testMathEval_1
	test/stdc/test.math.ci:51: (28 bytes: <@05509b> - <@0550b7>): static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+10343 @05509b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10352 @0550a4>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10356 @0550a8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10365 @0550b1>: 83                         mul.f64
	<.main+10366 @0550b2>: 81                         add.f64
	<.main+10367 @0550b3>: 2d 18 27 05                store.m64 <@052718> ;testMathEval_2
	test/stdc/test.math.ci:52: (45 bytes: <@0550b7> - <@0550e4>): static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+10371 @0550b7>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10375 @0550bb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10384 @0550c4>: 11 02                      dup.x64 sp(2)
	<.main+10386 @0550c6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10395 @0550cf>: 11 06                      dup.x64 sp(6)
	<.main+10397 @0550d1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10406 @0550da>: 83                         mul.f64
	<.main+10407 @0550db>: 81                         add.f64
	<.main+10408 @0550dc>: 83                         mul.f64
	<.main+10409 @0550dd>: 81                         add.f64
	<.main+10410 @0550de>: 14 02                      set.x64 sp(2)
	<.main+10412 @0550e0>: 2d 20 27 05                store.m64 <@052720> ;testMathEval_3
	test/stdc/test.math.ci:53: (62 bytes: <@0550e4> - <@055122>): static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10416 @0550e4>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10420 @0550e8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10429 @0550f1>: 11 02                      dup.x64 sp(2)
	<.main+10431 @0550f3>: 11 04                      dup.x64 sp(4)
	<.main+10433 @0550f5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10442 @0550fe>: 11 02                      dup.x64 sp(2)
	<.main+10444 @055100>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10453 @055109>: 11 06                      dup.x64 sp(6)
	<.main+10455 @05510b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10464 @055114>: 83                         mul.f64
	<.main+10465 @055115>: 81                         add.f64
	<.main+10466 @055116>: 83                         mul.f64
	<.main+10467 @055117>: 81                         add.f64
	<.main+10468 @055118>: 14 02                      set.x64 sp(2)
	<.main+10470 @05511a>: 83                         mul.f64
	<.main+10471 @05511b>: 81                         add.f64
	<.main+10472 @05511c>: 14 02                      set.x64 sp(2)
	<.main+10474 @05511e>: 2d 28 27 05                store.m64 <@052728> ;testMathEval_4
	test/stdc/test.math.ci:54: (78 bytes: <@055122> - <@055170>): static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10478 @055122>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10487 @05512b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10496 @055134>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10505 @05513d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10514 @055146>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10523 @05514f>: 1c 05 00 00 00             load.c32 5
	<.main+10528 @055154>: 0a 04 00 00                load.sp(+4)
	<.main+10532 @055158>: 1a                         load.z64
	<.main+10533 @055159>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10537 @05515d>: 11 04                      dup.x64 sp(4)
	<.main+10539 @05515f>: 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10544 @055164>: 02                         call
	<.main+10545 @055165>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10548 @055168>: 09 c0 ff ff                inc.sp(-64)
	<.main+10552 @05516c>: 2d 30 27 05                store.m64 <@052730> ;testMathEval_5
	test/stdc/test.math.ci:55: (87 bytes: <@055170> - <@0551c7>): static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10556 @055170>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10565 @055179>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10574 @055182>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10583 @05518b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10592 @055194>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10601 @05519d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10610 @0551a6>: 1c 06 00 00 00             load.c32 6
	<.main+10615 @0551ab>: 0a 04 00 00                load.sp(+4)
	<.main+10619 @0551af>: 1a                         load.z64
	<.main+10620 @0551b0>: 2b 00 27 05                load.m64 <@052700> ;testMathEval_x
	<.main+10624 @0551b4>: 11 04                      dup.x64 sp(4)
	<.main+10626 @0551b6>: 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10631 @0551bb>: 02                         call
	<.main+10632 @0551bc>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10635 @0551bf>: 09 b8 ff ff                inc.sp(-72)
	<.main+10639 @0551c3>: 2d 38 27 05                store.m64 <@052738> ;testMathEval_6
	test/stdc/test.math.ci:57: (35 bytes: <@0551c7> - <@0551ea>): static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10643 @0551c7>: 1a                         load.z64
	<.main+10644 @0551c8>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10653 @0551d1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10662 @0551da>: 84                         div.f64
	<.main+10663 @0551db>: 19                         load.z32
	<.main+10664 @0551dc>: 1f 58 05 05 00             load.ref <@050558> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10669 @0551e1>: 02                         call
	<.main+10670 @0551e2>: 09 f4 ff ff                inc.sp(-12)
	<.main+10674 @0551e6>: 2d 40 27 05                store.m64 <@052740> ;testMathSin_f64
	test/stdc/test.math.ci:58: (49 bytes: <@0551ea> - <@05521b>): static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10678 @0551ea>: 1b                         load.z128
	<.main+10679 @0551eb>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10688 @0551f4>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10697 @0551fd>: 84                         div.f64
	<.main+10698 @0551fe>: 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+10703 @055203>: 02                         call
	<.main+10704 @055204>: 09 f8 ff ff                inc.sp(-8)
	<.main+10708 @055208>: 1c 01 00 00 00             load.c32 1
	<.main+10713 @05520d>: 1f 58 05 05 00             load.ref <@050558> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10718 @055212>: 02                         call
	<.main+10719 @055213>: 09 f4 ff ff                inc.sp(-12)
	<.main+10723 @055217>: 2d 48 27 05                store.m64 <@052748> ;testMathCos_f64
	test/stdc/test.math.ci:59: (34 bytes: <@05521b> - <@05523d>): static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10727 @05521b>: 1a                         load.z64
	<.main+10728 @05521c>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10737 @055225>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10746 @05522e>: 84                         div.f64
	<.main+10747 @05522f>: 1f a8 06 05 00             load.ref <@0506a8> ;Math.tan(arg: float64): float64
	<.main+10752 @055234>: 02                         call
	<.main+10753 @055235>: 09 f8 ff ff                inc.sp(-8)
	<.main+10757 @055239>: 2d 50 27 05                store.m64 <@052750> ;testMathTan_f64
	test/stdc/test.math.ci:60: (34 bytes: <@05523d> - <@05525f>): static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10761 @05523d>: 1a                         load.z64
	<.main+10762 @05523e>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10771 @055247>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10780 @055250>: 84                         div.f64
	<.main+10781 @055251>: 1f 20 08 05 00             load.ref <@050820> ;Math.sinh(x: float64): float64
	<.main+10786 @055256>: 02                         call
	<.main+10787 @055257>: 09 f8 ff ff                inc.sp(-8)
	<.main+10791 @05525b>: 2d 58 27 05                store.m64 <@052758> ;testMathSinh_f64
	test/stdc/test.math.ci:61: (34 bytes: <@05525f> - <@055281>): static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10795 @05525f>: 1a                         load.z64
	<.main+10796 @055260>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10805 @055269>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10814 @055272>: 84                         div.f64
	<.main+10815 @055273>: 1f 18 09 05 00             load.ref <@050918> ;Math.cosh(x: float64): float64
	<.main+10820 @055278>: 02                         call
	<.main+10821 @055279>: 09 f8 ff ff                inc.sp(-8)
	<.main+10825 @05527d>: 2d 60 27 05                store.m64 <@052760> ;testMathCosh_f64
	test/stdc/test.math.ci:63: (24 bytes: <@055281> - <@055299>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10829 @055281>: 1a                         load.z64
	<.main+10830 @055282>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10839 @05528b>: 1f 68 09 05 00             load.ref <@050968> ;Math.asin(x: float64): float64
	<.main+10844 @055290>: 02                         call
	<.main+10845 @055291>: 09 f8 ff ff                inc.sp(-8)
	<.main+10849 @055295>: 2d 68 27 05                store.m64 <@052768> ;testMathAsin_f64
	test/stdc/test.math.ci:64: (44 bytes: <@055299> - <@0552c5>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10853 @055299>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10862 @0552a2>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10871 @0552ab>: 84                         div.f64
	<.main+10872 @0552ac>: 1a                         load.z64
	<.main+10873 @0552ad>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10882 @0552b6>: 1f 68 09 05 00             load.ref <@050968> ;Math.asin(x: float64): float64
	<.main+10887 @0552bb>: 02                         call
	<.main+10888 @0552bc>: 09 f8 ff ff                inc.sp(-8)
	<.main+10892 @0552c0>: 82                         sub.f64
	<.main+10893 @0552c1>: 2d 70 27 05                store.m64 <@052770> ;testMathAcos_f64
	test/stdc/test.math.ci:67: (34 bytes: <@0552c5> - <@0552e7>): static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10897 @0552c5>: 19                         load.z32
	<.main+10898 @0552c6>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10903 @0552cb>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10908 @0552d0>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10913 @0552d5>: 1f d8 04 05 00             load.ref <@0504d8> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10918 @0552da>: 02                         call
	<.main+10919 @0552db>: 09 f4 ff ff                inc.sp(-12)
	<.main+10923 @0552df>: 19                         load.z32
	<.main+10924 @0552e0>: 57                         ceq.i32
	<.main+10925 @0552e1>: 1f 78 27 05 00             load.ref <@052778> ;testMathCmp_f32
	<.main+10930 @0552e6>: 25                         store.i8
	test/stdc/test.math.ci:68: (46 bytes: <@0552e7> - <@055315>): static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10931 @0552e7>: 19                         load.z32
	<.main+10932 @0552e8>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10941 @0552f1>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10950 @0552fa>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10959 @055303>: 1f 18 05 05 00             load.ref <@050518> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10964 @055308>: 02                         call
	<.main+10965 @055309>: 09 e8 ff ff                inc.sp(-24)
	<.main+10969 @05530d>: 19                         load.z32
	<.main+10970 @05530e>: 57                         ceq.i32
	<.main+10971 @05530f>: 1f 80 27 05 00             load.ref <@052780> ;testMathCmp_f64
	<.main+10976 @055314>: 25                         store.i8
	test/stdc/test.math.ci:70: (33 bytes: <@055315> - <@055336>): static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10977 @055315>: 1a                         load.z64
	<.main+10978 @055316>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10987 @05531f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10996 @055328>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11001 @05532d>: 02                         call
	<.main+11002 @05532e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11006 @055332>: 2d 88 27 05                store.m64 <@052788> ;testMathAbsMod_f64_0a
	test/stdc/test.math.ci:71: (24 bytes: <@055336> - <@05534e>): static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+11010 @055336>: 1b                         load.z128
	<.main+11011 @055337>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11020 @055340>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11025 @055345>: 02                         call
	<.main+11026 @055346>: 09 f0 ff ff                inc.sp(-16)
	<.main+11030 @05534a>: 2d 90 27 05                store.m64 <@052790> ;testMathAbsMod_f64_0b
	test/stdc/test.math.ci:72: (33 bytes: <@05534e> - <@05536f>): static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+11034 @05534e>: 1a                         load.z64
	<.main+11035 @05534f>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11044 @055358>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11053 @055361>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11058 @055366>: 02                         call
	<.main+11059 @055367>: 09 f0 ff ff                inc.sp(-16)
	<.main+11063 @05536b>: 2d 98 27 05                store.m64 <@052798> ;testMathAbsMod_f64_0c
	test/stdc/test.math.ci:74: (33 bytes: <@05536f> - <@055390>): static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+11067 @05536f>: 1a                         load.z64
	<.main+11068 @055370>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11077 @055379>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11086 @055382>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11091 @055387>: 02                         call
	<.main+11092 @055388>: 09 f0 ff ff                inc.sp(-16)
	<.main+11096 @05538c>: 2d a0 27 05                store.m64 <@0527a0> ;testMathAbsMod_f64_9a
	test/stdc/test.math.ci:75: (33 bytes: <@055390> - <@0553b1>): static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+11100 @055390>: 1a                         load.z64
	<.main+11101 @055391>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11110 @05539a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11119 @0553a3>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11124 @0553a8>: 02                         call
	<.main+11125 @0553a9>: 09 f0 ff ff                inc.sp(-16)
	<.main+11129 @0553ad>: 2d a8 27 05                store.m64 <@0527a8> ;testMathAbsMod_f64_9b
	test/stdc/test.math.ci:76: (33 bytes: <@0553b1> - <@0553d2>): static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+11133 @0553b1>: 1a                         load.z64
	<.main+11134 @0553b2>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11143 @0553bb>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11152 @0553c4>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11157 @0553c9>: 02                         call
	<.main+11158 @0553ca>: 09 f0 ff ff                inc.sp(-16)
	<.main+11162 @0553ce>: 2d b0 27 05                store.m64 <@0527b0> ;testMathAbsMod_f64_9c
	test/stdc/test.math.ci:77: (33 bytes: <@0553d2> - <@0553f3>): static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+11166 @0553d2>: 1a                         load.z64
	<.main+11167 @0553d3>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11176 @0553dc>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11185 @0553e5>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11190 @0553ea>: 02                         call
	<.main+11191 @0553eb>: 09 f0 ff ff                inc.sp(-16)
	<.main+11195 @0553ef>: 2d b8 27 05                store.m64 <@0527b8> ;testMathAbsMod_f64_9d
	test/stdc/test.math.ci:79: (33 bytes: <@0553f3> - <@055414>): static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+11199 @0553f3>: 1a                         load.z64
	<.main+11200 @0553f4>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11209 @0553fd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11218 @055406>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11223 @05540b>: 02                         call
	<.main+11224 @05540c>: 09 f0 ff ff                inc.sp(-16)
	<.main+11228 @055410>: 2d c0 27 05                store.m64 <@0527c0> ;testMathAbsMod_f64_8a
	test/stdc/test.math.ci:80: (33 bytes: <@055414> - <@055435>): static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+11232 @055414>: 1a                         load.z64
	<.main+11233 @055415>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11242 @05541e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11251 @055427>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11256 @05542c>: 02                         call
	<.main+11257 @05542d>: 09 f0 ff ff                inc.sp(-16)
	<.main+11261 @055431>: 2d c8 27 05                store.m64 <@0527c8> ;testMathAbsMod_f64_8b
	test/stdc/test.math.ci:81: (33 bytes: <@055435> - <@055456>): static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+11265 @055435>: 1a                         load.z64
	<.main+11266 @055436>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11275 @05543f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11284 @055448>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11289 @05544d>: 02                         call
	<.main+11290 @05544e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11294 @055452>: 2d d0 27 05                store.m64 <@0527d0> ;testMathAbsMod_f64_8c
	test/stdc/test.math.ci:82: (33 bytes: <@055456> - <@055477>): static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+11298 @055456>: 1a                         load.z64
	<.main+11299 @055457>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11308 @055460>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11317 @055469>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11322 @05546e>: 02                         call
	<.main+11323 @05546f>: 09 f0 ff ff                inc.sp(-16)
	<.main+11327 @055473>: 2d d8 27 05                store.m64 <@0527d8> ;testMathAbsMod_f64_8d
	test/stdc/test.math.ci:84: (25 bytes: <@055477> - <@055490>): static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+11331 @055477>: 19                         load.z32
	<.main+11332 @055478>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11337 @05547d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11342 @055482>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11347 @055487>: 02                         call
	<.main+11348 @055488>: 09 f8 ff ff                inc.sp(-8)
	<.main+11352 @05548c>: 2e e0 27 05                store.m32 <@0527e0> ;testMathAbsMod_f32_0a
	test/stdc/test.math.ci:85: (21 bytes: <@055490> - <@0554a5>): static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+11356 @055490>: 19                         load.z32
	<.main+11357 @055491>: 19                         load.z32
	<.main+11358 @055492>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11363 @055497>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11368 @05549c>: 02                         call
	<.main+11369 @05549d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11373 @0554a1>: 2e e8 27 05                store.m32 <@0527e8> ;testMathAbsMod_f32_0b
	test/stdc/test.math.ci:86: (25 bytes: <@0554a5> - <@0554be>): static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+11377 @0554a5>: 19                         load.z32
	<.main+11378 @0554a6>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11383 @0554ab>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11388 @0554b0>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11393 @0554b5>: 02                         call
	<.main+11394 @0554b6>: 09 f8 ff ff                inc.sp(-8)
	<.main+11398 @0554ba>: 2e f0 27 05                store.m32 <@0527f0> ;testMathAbsMod_f32_0c
	test/stdc/test.math.ci:88: (25 bytes: <@0554be> - <@0554d7>): static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+11402 @0554be>: 19                         load.z32
	<.main+11403 @0554bf>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11408 @0554c4>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11413 @0554c9>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11418 @0554ce>: 02                         call
	<.main+11419 @0554cf>: 09 f8 ff ff                inc.sp(-8)
	<.main+11423 @0554d3>: 2e f8 27 05                store.m32 <@0527f8> ;testMathAbsMod_f32_9a
	test/stdc/test.math.ci:89: (25 bytes: <@0554d7> - <@0554f0>): static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+11427 @0554d7>: 19                         load.z32
	<.main+11428 @0554d8>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11433 @0554dd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11438 @0554e2>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11443 @0554e7>: 02                         call
	<.main+11444 @0554e8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11448 @0554ec>: 2e 00 28 05                store.m32 <@052800> ;testMathAbsMod_f32_9b
	test/stdc/test.math.ci:90: (25 bytes: <@0554f0> - <@055509>): static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+11452 @0554f0>: 19                         load.z32
	<.main+11453 @0554f1>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11458 @0554f6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11463 @0554fb>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11468 @055500>: 02                         call
	<.main+11469 @055501>: 09 f8 ff ff                inc.sp(-8)
	<.main+11473 @055505>: 2e 08 28 05                store.m32 <@052808> ;testMathAbsMod_f32_9c
	test/stdc/test.math.ci:91: (25 bytes: <@055509> - <@055522>): static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+11477 @055509>: 19                         load.z32
	<.main+11478 @05550a>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11483 @05550f>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11488 @055514>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11493 @055519>: 02                         call
	<.main+11494 @05551a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11498 @05551e>: 2e 10 28 05                store.m32 <@052810> ;testMathAbsMod_f32_9d
	test/stdc/test.math.ci:93: (25 bytes: <@055522> - <@05553b>): static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+11502 @055522>: 19                         load.z32
	<.main+11503 @055523>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11508 @055528>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11513 @05552d>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11518 @055532>: 02                         call
	<.main+11519 @055533>: 09 f8 ff ff                inc.sp(-8)
	<.main+11523 @055537>: 2e 18 28 05                store.m32 <@052818> ;testMathAbsMod_f32_8a
	test/stdc/test.math.ci:94: (25 bytes: <@05553b> - <@055554>): static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+11527 @05553b>: 19                         load.z32
	<.main+11528 @05553c>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11533 @055541>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11538 @055546>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11543 @05554b>: 02                         call
	<.main+11544 @05554c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11548 @055550>: 2e 20 28 05                store.m32 <@052820> ;testMathAbsMod_f32_8b
	test/stdc/test.math.ci:95: (25 bytes: <@055554> - <@05556d>): static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+11552 @055554>: 19                         load.z32
	<.main+11553 @055555>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11558 @05555a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11563 @05555f>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11568 @055564>: 02                         call
	<.main+11569 @055565>: 09 f8 ff ff                inc.sp(-8)
	<.main+11573 @055569>: 2e 28 28 05                store.m32 <@052828> ;testMathAbsMod_f32_8c
	test/stdc/test.math.ci:96: (25 bytes: <@05556d> - <@055586>): static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+11577 @05556d>: 19                         load.z32
	<.main+11578 @05556e>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11583 @055573>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11588 @055578>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11593 @05557d>: 02                         call
	<.main+11594 @05557e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11598 @055582>: 2e 30 28 05                store.m32 <@052830> ;testMathAbsMod_f32_8d
	test/stdc/memory.ci:13: (18 bytes: <@055586> - <@055598>): pointer.fill(void(void(p1, 0), 1024));
	<.main+11602 @055586>: 2a 98 1a 05                load.m32 <@051a98> ;p1
	<.main+11606 @05558a>: 19                         load.z32
	<.main+11607 @05558b>: 1c 00 04 00 00             load.c32 1024
	<.main+11612 @055590>: 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11616 @055594>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (21 bytes: <@055598> - <@0555ad>): pointer.copy(void(void(p1, p3), 160));
	<.main+11620 @055598>: 2a 98 1a 05                load.m32 <@051a98> ;p1
	<.main+11624 @05559c>: 2a a8 1a 05                load.m32 <@051aa8> ;p3
	<.main+11628 @0555a0>: 1c a0 00 00 00             load.c32 160
	<.main+11633 @0555a5>: 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11637 @0555a9>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (13 bytes: <@0555ad> - <@0555ba>): free(p1);
	<.main+11641 @0555ad>: 2a 98 1a 05                load.m32 <@051a98> ;p1
	<.main+11645 @0555b1>: 19                         load.z32
	<.main+11646 @0555b2>: 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11650 @0555b6>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (13 bytes: <@0555ba> - <@0555c7>): free(p2);
	<.main+11654 @0555ba>: 2a a0 1a 05                load.m32 <@051aa0> ;p2
	<.main+11658 @0555be>: 19                         load.z32
	<.main+11659 @0555bf>: 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11663 @0555c3>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (13 bytes: <@0555c7> - <@0555d4>): free(p3);
	<.main+11667 @0555c7>: 2a a8 1a 05                load.m32 <@051aa8> ;p3
	<.main+11671 @0555cb>: 19                         load.z32
	<.main+11672 @0555cc>: 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11676 @0555d0>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (13 bytes: <@0555d4> - <@0555e1>): free(p4);
	<.main+11680 @0555d4>: 2a b0 1a 05                load.m32 <@051ab0> ;p4
	<.main+11684 @0555d8>: 19                         load.z32
	<.main+11685 @0555d9>: 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11689 @0555dd>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:26: (35 bytes: <@0555e1> - <@055604>): debug(void("val1", val1));
	<.main+11693 @0555e1>: 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+11698 @0555e6>: 1c 1a 00 00 00             load.c32 26
	<.main+11703 @0555eb>: 1c 0e 00 00 00             load.c32 14
	<.main+11708 @0555f0>: 19                         load.z32
	<.main+11709 @0555f1>: 1f 98 a3 03 00             load.ref <@03a398> ;"val1"
	<.main+11714 @0555f6>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11719 @0555fb>: 1f b8 1a 05 00             load.ref <@051ab8> ;val1
	<.main+11724 @055600>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (35 bytes: <@055604> - <@055627>): debug(void("val2", val2));
	<.main+11728 @055604>: 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+11733 @055609>: 1c 1b 00 00 00             load.c32 27
	<.main+11738 @05560e>: 1c 0e 00 00 00             load.c32 14
	<.main+11743 @055613>: 19                         load.z32
	<.main+11744 @055614>: 1f 9d a3 03 00             load.ref <@03a39d> ;"val2"
	<.main+11749 @055619>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11754 @05561e>: 1f c0 1a 05 00             load.ref <@051ac0> ;val2
	<.main+11759 @055623>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (22 bytes: <@055627> - <@05563d>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+11763 @055627>: 1f c0 1a 05 00             load.ref <@051ac0> ;val2
	<.main+11768 @05562c>: 1f b8 1a 05 00             load.ref <@051ab8> ;val1
	<.main+11773 @055631>: 2a 90 04 00                load.m32 <@000490>
	<.main+11777 @055635>: 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+11781 @055639>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (18 bytes: <@05563d> - <@05564f>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+11785 @05563d>: 1f b8 1a 05 00             load.ref <@051ab8> ;val1
	<.main+11790 @055642>: 19                         load.z32
	<.main+11791 @055643>: 2a 90 04 00                load.m32 <@000490>
	<.main+11795 @055647>: 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11799 @05564b>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (35 bytes: <@05564f> - <@055672>): debug(void("val1", val1));
	<.main+11803 @05564f>: 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+11808 @055654>: 1c 20 00 00 00             load.c32 32
	<.main+11813 @055659>: 1c 0e 00 00 00             load.c32 14
	<.main+11818 @05565e>: 19                         load.z32
	<.main+11819 @05565f>: 1f 98 a3 03 00             load.ref <@03a398> ;"val1"
	<.main+11824 @055664>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11829 @055669>: 1f b8 1a 05 00             load.ref <@051ab8> ;val1
	<.main+11834 @05566e>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (35 bytes: <@055672> - <@055695>): debug(void("val2", val2));
	<.main+11838 @055672>: 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+11843 @055677>: 1c 21 00 00 00             load.c32 33
	<.main+11848 @05567c>: 1c 0e 00 00 00             load.c32 14
	<.main+11853 @055681>: 19                         load.z32
	<.main+11854 @055682>: 1f 9d a3 03 00             load.ref <@03a39d> ;"val2"
	<.main+11859 @055687>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11864 @05568c>: 1f c0 1a 05 00             load.ref <@051ac0> ;val2
	<.main+11869 @055691>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:54: (46 bytes: <@055695> - <@0556c3>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+11873 @055695>: 19                         load.z32
	<.main+11874 @055696>: 04 1d 00 00                jmp <.main+11903 @0556b3>
	test/lang/array.ci:55: (21 bytes: <@05569a> - <@0556af>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+11878 @05569a>: 1c 2a 00 00 00             load.c32 42
	<.main+11883 @05569f>: 10 01                      dup.x32 sp(1)
	<.main+11885 @0556a1>: 51                         add.i32
	<.main+11886 @0556a2>: 5b                         i32.2i64
	<.main+11887 @0556a3>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+11892 @0556a8>: 10 03                      dup.x32 sp(3)
	<.main+11894 @0556aa>: 0d 08 00 00                mad.u32 8
	<.main+11898 @0556ae>: 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@0556af> - <@0556b3>): int32(i := int32(i + 1))
	<.main+11899 @0556af>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@0556b3> - <@0556bf>): bool(i < arrFixedNoInit.length)
	<.main+11903 @0556b3>: 10 00                      dup.x32 sp(0)
	<.main+11905 @0556b5>: 1c 07 00 00 00             load.c32 7
	<.main+11910 @0556ba>: 58                         clt.i32
	<.main+11911 @0556bb>: 05 df ff ff                jnz <.main+11878 @05569a>
	<.main+11915 @0556bf>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:82: (23 bytes: <@0556c3> - <@0556da>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+11919 @0556c3>: 1f 10 1c 05 00             load.ref <@051c10> ;strFixed
	<.main+11924 @0556c8>: 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+11929 @0556cd>: 1c 07 00 00 00             load.c32 7
	<.main+11934 @0556d2>: 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11938 @0556d6>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (35 bytes: <@0556da> - <@0556fd>): debug(void("string as variant", strFixed));
	<.main+11942 @0556da>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+11947 @0556df>: 1c 53 00 00 00             load.c32 83
	<.main+11952 @0556e4>: 1c 0e 00 00 00             load.c32 14
	<.main+11957 @0556e9>: 19                         load.z32
	<.main+11958 @0556ea>: 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+11963 @0556ef>: 1f d0 d2 03 00             load.ref <@03d2d0>
	<.main+11968 @0556f4>: 1f 10 1c 05 00             load.ref <@051c10> ;strFixed
	<.main+11973 @0556f9>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (35 bytes: <@0556fd> - <@055720>): debug(void("string to variant", variant(strFixed)));
	<.main+11977 @0556fd>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+11982 @055702>: 1c 54 00 00 00             load.c32 84
	<.main+11987 @055707>: 1c 0e 00 00 00             load.c32 14
	<.main+11992 @05570c>: 19                         load.z32
	<.main+11993 @05570d>: 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+11998 @055712>: 1f d0 d2 03 00             load.ref <@03d2d0>
	<.main+12003 @055717>: 1f 10 1c 05 00             load.ref <@051c10> ;strFixed
	<.main+12008 @05571c>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:87: (34 bytes: <@055720> - <@055742>): debug(void("string as variant", strArray));
	<.main+12012 @055720>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12017 @055725>: 1c 57 00 00 00             load.c32 87
	<.main+12022 @05572a>: 1c 0e 00 00 00             load.c32 14
	<.main+12027 @05572f>: 19                         load.z32
	<.main+12028 @055730>: 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+12033 @055735>: 1f 98 d4 03 00             load.ref <@03d498>
	<.main+12038 @05573a>: 2a 18 1c 05                load.m32 <@051c18> ;strArray
	<.main+12042 @05573e>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (34 bytes: <@055742> - <@055764>): debug(void("string to variant", variant(strArray)));
	<.main+12046 @055742>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12051 @055747>: 1c 58 00 00 00             load.c32 88
	<.main+12056 @05574c>: 1c 0e 00 00 00             load.c32 14
	<.main+12061 @055751>: 19                         load.z32
	<.main+12062 @055752>: 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+12067 @055757>: 1f 98 d4 03 00             load.ref <@03d498>
	<.main+12072 @05575c>: 2a 18 1c 05                load.m32 <@051c18> ;strArray
	<.main+12076 @055760>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:91: (34 bytes: <@055764> - <@055786>): debug(void("string as variant", strSlice));
	<.main+12080 @055764>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12085 @055769>: 1c 5b 00 00 00             load.c32 91
	<.main+12090 @05576e>: 1c 0e 00 00 00             load.c32 14
	<.main+12095 @055773>: 19                         load.z32
	<.main+12096 @055774>: 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+12101 @055779>: 1f c8 d5 03 00             load.ref <@03d5c8>
	<.main+12106 @05577e>: 2a 20 1c 05                load.m32 <@051c20> ;strSlice
	<.main+12110 @055782>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (34 bytes: <@055786> - <@0557a8>): debug(void("string to variant", variant(strSlice)));
	<.main+12114 @055786>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12119 @05578b>: 1c 5c 00 00 00             load.c32 92
	<.main+12124 @055790>: 1c 0e 00 00 00             load.c32 14
	<.main+12129 @055795>: 19                         load.z32
	<.main+12130 @055796>: 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+12135 @05579b>: 1f c8 d5 03 00             load.ref <@03d5c8>
	<.main+12140 @0557a0>: 2a 20 1c 05                load.m32 <@051c20> ;strSlice
	<.main+12144 @0557a4>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (53 bytes: <@0557a8> - <@0557dd>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+12148 @0557a8>: 2a d4 1b 05                load.m32 <@051bd4> ;arrSliceNoInit+4
	<.main+12152 @0557ac>: 19                         load.z32
	<.main+12153 @0557ad>: 38                         clt.u32
	<.main+12154 @0557ae>: 05 08 00 00                jnz <.main+12162 @0557b6>
	<.main+12158 @0557b2>: 04 2b 00 00                jmp <.main+12201 @0557dd>
	<.main+12162 @0557b6>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12167 @0557bb>: 1c 62 00 00 00             load.c32 98
	<.main+12172 @0557c0>: 1c fe ff ff ff             load.c32 -2
	<.main+12177 @0557c5>: 1c 80 00 00 00             load.c32 128
	<.main+12182 @0557ca>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12187 @0557cf>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12192 @0557d4>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12197 @0557d9>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (53 bytes: <@0557dd> - <@055812>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+12201 @0557dd>: 2a e4 1b 05                load.m32 <@051be4> ;arrSliceInitNull+4
	<.main+12205 @0557e1>: 19                         load.z32
	<.main+12206 @0557e2>: 57                         ceq.i32
	<.main+12207 @0557e3>: 06 08 00 00                jz <.main+12215 @0557eb>
	<.main+12211 @0557e7>: 04 2b 00 00                jmp <.main+12254 @055812>
	<.main+12215 @0557eb>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12220 @0557f0>: 1c 63 00 00 00             load.c32 99
	<.main+12225 @0557f5>: 1c fe ff ff ff             load.c32 -2
	<.main+12230 @0557fa>: 1c 80 00 00 00             load.c32 128
	<.main+12235 @0557ff>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12240 @055804>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12245 @055809>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12250 @05580e>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (61 bytes: <@055812> - <@05584f>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+12254 @055812>: 2b 90 1b 05                load.m64 <@051b90> ;arrFixedNoInit
	<.main+12258 @055816>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12267 @05581f>: 67                         ceq.i64
	<.main+12268 @055820>: 06 08 00 00                jz <.main+12276 @055828>
	<.main+12272 @055824>: 04 2b 00 00                jmp <.main+12315 @05584f>
	<.main+12276 @055828>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12281 @05582d>: 1c 65 00 00 00             load.c32 101
	<.main+12286 @055832>: 1c fe ff ff ff             load.c32 -2
	<.main+12291 @055837>: 1c 80 00 00 00             load.c32 128
	<.main+12296 @05583c>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12301 @055841>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12306 @055846>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12311 @05584b>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@05584f> - <@055868>): assertEq(void(7, arrFixedNoInit.length));
	<.main+12315 @05584f>: 1c 07 00 00 00             load.c32 7
	<.main+12320 @055854>: 1c 07 00 00 00             load.c32 7
	<.main+12325 @055859>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12330 @05585e>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12335 @055863>: 02                         call
	<.main+12336 @055864>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (24 bytes: <@055868> - <@055880>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+12340 @055868>: 1c 07 00 00 00             load.c32 7
	<.main+12345 @05586d>: 2a f4 1b 05                load.m32 <@051bf4> ;arrSliceInitFixed+4
	<.main+12349 @055871>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12354 @055876>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12359 @05587b>: 02                         call
	<.main+12360 @05587c>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (24 bytes: <@055880> - <@055898>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+12364 @055880>: 1c 07 00 00 00             load.c32 7
	<.main+12369 @055885>: 2a 04 1c 05                load.m32 <@051c04> ;arrSliceInitSlice+4
	<.main+12373 @055889>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12378 @05588e>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12383 @055893>: 02                         call
	<.main+12384 @055894>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@055898> - <@0558b8>): assertEq(void(0, lenSlice(null)));
	<.main+12388 @055898>: 19                         load.z32
	<.main+12389 @055899>: 1a                         load.z64
	<.main+12390 @05589a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12395 @05589f>: 1f 28 1c 05 00             load.ref <@051c28> ;lenSlice(values: int64[]): int32
	<.main+12400 @0558a4>: 02                         call
	<.main+12401 @0558a5>: 09 f8 ff ff                inc.sp(-8)
	<.main+12405 @0558a9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12410 @0558ae>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12415 @0558b3>: 02                         call
	<.main+12416 @0558b4>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (31 bytes: <@0558b8> - <@0558d7>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+12420 @0558b8>: 19                         load.z32
	<.main+12421 @0558b9>: 19                         load.z32
	<.main+12422 @0558ba>: 2b e0 1b 05                load.m64 <@051be0> ;arrSliceInitNull
	<.main+12426 @0558be>: 1f 28 1c 05 00             load.ref <@051c28> ;lenSlice(values: int64[]): int32
	<.main+12431 @0558c3>: 02                         call
	<.main+12432 @0558c4>: 09 f8 ff ff                inc.sp(-8)
	<.main+12436 @0558c8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12441 @0558cd>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12446 @0558d2>: 02                         call
	<.main+12447 @0558d3>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (41 bytes: <@0558d7> - <@055900>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+12451 @0558d7>: 1c 07 00 00 00             load.c32 7
	<.main+12456 @0558dc>: 19                         load.z32
	<.main+12457 @0558dd>: 1c 07 00 00 00             load.c32 7
	<.main+12462 @0558e2>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+12467 @0558e7>: 1f 28 1c 05 00             load.ref <@051c28> ;lenSlice(values: int64[]): int32
	<.main+12472 @0558ec>: 02                         call
	<.main+12473 @0558ed>: 09 f8 ff ff                inc.sp(-8)
	<.main+12477 @0558f1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12482 @0558f6>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12487 @0558fb>: 02                         call
	<.main+12488 @0558fc>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (35 bytes: <@055900> - <@055923>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+12492 @055900>: 1c 07 00 00 00             load.c32 7
	<.main+12497 @055905>: 19                         load.z32
	<.main+12498 @055906>: 2b f0 1b 05                load.m64 <@051bf0> ;arrSliceInitFixed
	<.main+12502 @05590a>: 1f 28 1c 05 00             load.ref <@051c28> ;lenSlice(values: int64[]): int32
	<.main+12507 @05590f>: 02                         call
	<.main+12508 @055910>: 09 f8 ff ff                inc.sp(-8)
	<.main+12512 @055914>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12517 @055919>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12522 @05591e>: 02                         call
	<.main+12523 @05591f>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (35 bytes: <@055923> - <@055946>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+12527 @055923>: 1c 07 00 00 00             load.c32 7
	<.main+12532 @055928>: 19                         load.z32
	<.main+12533 @055929>: 2b 00 1c 05                load.m64 <@051c00> ;arrSliceInitSlice
	<.main+12537 @05592d>: 1f 28 1c 05 00             load.ref <@051c28> ;lenSlice(values: int64[]): int32
	<.main+12542 @055932>: 02                         call
	<.main+12543 @055933>: 09 f8 ff ff                inc.sp(-8)
	<.main+12547 @055937>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12552 @05593c>: 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12557 @055941>: 02                         call
	<.main+12558 @055942>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (827 bytes: <@055946> - <@055c81>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+12562 @055946>: 19                         load.z32
	<.main+12563 @055947>: 04 2a 03 00                jmp <.main+13373 @055c71>
	test/lang/array.ci:119: (9 bytes: <@05594b> - <@055954>): expected: int64 := int32(42 + i)
	<.main+12567 @05594b>: 1c 2a 00 00 00             load.c32 42
	<.main+12572 @055950>: 10 01                      dup.x32 sp(1)
	<.main+12574 @055952>: 51                         add.i32
	<.main+12575 @055953>: 5b                         i32.2i64
	test/lang/array.ci:120: (62 bytes: <@055954> - <@055992>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+12576 @055954>: 11 00                      dup.x64 sp(0)
	<.main+12578 @055956>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+12583 @05595b>: 10 05                      dup.x32 sp(5)
	<.main+12585 @05595d>: 0d 08 00 00                mad.u32 8
	<.main+12589 @055961>: 23                         load.i64
	<.main+12590 @055962>: 67                         ceq.i64
	<.main+12591 @055963>: 06 08 00 00                jz <.main+12599 @05596b>
	<.main+12595 @055967>: 04 2b 00 00                jmp <.main+12638 @055992>
	<.main+12599 @05596b>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12604 @055970>: 1c 78 00 00 00             load.c32 120
	<.main+12609 @055975>: 1c fe ff ff ff             load.c32 -2
	<.main+12614 @05597a>: 1c 80 00 00 00             load.c32 128
	<.main+12619 @05597f>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12624 @055984>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12629 @055989>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12634 @05598e>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (61 bytes: <@055992> - <@0559cf>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+12638 @055992>: 11 00                      dup.x64 sp(0)
	<.main+12640 @055994>: 2a e8 1b 05                load.m32 <@051be8> ;arrArrayInitFixed
	<.main+12644 @055998>: 10 05                      dup.x32 sp(5)
	<.main+12646 @05599a>: 0d 08 00 00                mad.u32 8
	<.main+12650 @05599e>: 23                         load.i64
	<.main+12651 @05599f>: 67                         ceq.i64
	<.main+12652 @0559a0>: 06 08 00 00                jz <.main+12660 @0559a8>
	<.main+12656 @0559a4>: 04 2b 00 00                jmp <.main+12699 @0559cf>
	<.main+12660 @0559a8>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12665 @0559ad>: 1c 79 00 00 00             load.c32 121
	<.main+12670 @0559b2>: 1c fe ff ff ff             load.c32 -2
	<.main+12675 @0559b7>: 1c 80 00 00 00             load.c32 128
	<.main+12680 @0559bc>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12685 @0559c1>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12690 @0559c6>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12695 @0559cb>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (61 bytes: <@0559cf> - <@055a0c>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+12699 @0559cf>: 11 00                      dup.x64 sp(0)
	<.main+12701 @0559d1>: 2a f0 1b 05                load.m32 <@051bf0> ;arrSliceInitFixed
	<.main+12705 @0559d5>: 10 05                      dup.x32 sp(5)
	<.main+12707 @0559d7>: 0d 08 00 00                mad.u32 8
	<.main+12711 @0559db>: 23                         load.i64
	<.main+12712 @0559dc>: 67                         ceq.i64
	<.main+12713 @0559dd>: 06 08 00 00                jz <.main+12721 @0559e5>
	<.main+12717 @0559e1>: 04 2b 00 00                jmp <.main+12760 @055a0c>
	<.main+12721 @0559e5>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12726 @0559ea>: 1c 7a 00 00 00             load.c32 122
	<.main+12731 @0559ef>: 1c fe ff ff ff             load.c32 -2
	<.main+12736 @0559f4>: 1c 80 00 00 00             load.c32 128
	<.main+12741 @0559f9>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12746 @0559fe>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12751 @055a03>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12756 @055a08>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (68 bytes: <@055a0c> - <@055a50>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+12760 @055a0c>: 11 00                      dup.x64 sp(0)
	<.main+12762 @055a0e>: 1a                         load.z64
	<.main+12763 @055a0f>: 10 06                      dup.x32 sp(6)
	<.main+12765 @055a11>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+12770 @055a16>: 1f 30 1c 05 00             load.ref <@051c30> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12775 @055a1b>: 02                         call
	<.main+12776 @055a1c>: 09 f8 ff ff                inc.sp(-8)
	<.main+12780 @055a20>: 67                         ceq.i64
	<.main+12781 @055a21>: 06 08 00 00                jz <.main+12789 @055a29>
	<.main+12785 @055a25>: 04 2b 00 00                jmp <.main+12828 @055a50>
	<.main+12789 @055a29>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12794 @055a2e>: 1c 7c 00 00 00             load.c32 124
	<.main+12799 @055a33>: 1c fe ff ff ff             load.c32 -2
	<.main+12804 @055a38>: 1c 80 00 00 00             load.c32 128
	<.main+12809 @055a3d>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12814 @055a42>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12819 @055a47>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12824 @055a4c>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (67 bytes: <@055a50> - <@055a93>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+12828 @055a50>: 11 00                      dup.x64 sp(0)
	<.main+12830 @055a52>: 1a                         load.z64
	<.main+12831 @055a53>: 10 06                      dup.x32 sp(6)
	<.main+12833 @055a55>: 2a e8 1b 05                load.m32 <@051be8> ;arrArrayInitFixed
	<.main+12837 @055a59>: 1f 30 1c 05 00             load.ref <@051c30> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12842 @055a5e>: 02                         call
	<.main+12843 @055a5f>: 09 f8 ff ff                inc.sp(-8)
	<.main+12847 @055a63>: 67                         ceq.i64
	<.main+12848 @055a64>: 06 08 00 00                jz <.main+12856 @055a6c>
	<.main+12852 @055a68>: 04 2b 00 00                jmp <.main+12895 @055a93>
	<.main+12856 @055a6c>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12861 @055a71>: 1c 7d 00 00 00             load.c32 125
	<.main+12866 @055a76>: 1c fe ff ff ff             load.c32 -2
	<.main+12871 @055a7b>: 1c 80 00 00 00             load.c32 128
	<.main+12876 @055a80>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12881 @055a85>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12886 @055a8a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12891 @055a8f>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (67 bytes: <@055a93> - <@055ad6>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+12895 @055a93>: 11 00                      dup.x64 sp(0)
	<.main+12897 @055a95>: 1a                         load.z64
	<.main+12898 @055a96>: 10 06                      dup.x32 sp(6)
	<.main+12900 @055a98>: 2a f0 1b 05                load.m32 <@051bf0> ;arrSliceInitFixed
	<.main+12904 @055a9c>: 1f 30 1c 05 00             load.ref <@051c30> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12909 @055aa1>: 02                         call
	<.main+12910 @055aa2>: 09 f8 ff ff                inc.sp(-8)
	<.main+12914 @055aa6>: 67                         ceq.i64
	<.main+12915 @055aa7>: 06 08 00 00                jz <.main+12923 @055aaf>
	<.main+12919 @055aab>: 04 2b 00 00                jmp <.main+12962 @055ad6>
	<.main+12923 @055aaf>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12928 @055ab4>: 1c 7e 00 00 00             load.c32 126
	<.main+12933 @055ab9>: 1c fe ff ff ff             load.c32 -2
	<.main+12938 @055abe>: 1c 80 00 00 00             load.c32 128
	<.main+12943 @055ac3>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+12948 @055ac8>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12953 @055acd>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12958 @055ad2>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (68 bytes: <@055ad6> - <@055b1a>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+12962 @055ad6>: 11 00                      dup.x64 sp(0)
	<.main+12964 @055ad8>: 1a                         load.z64
	<.main+12965 @055ad9>: 10 06                      dup.x32 sp(6)
	<.main+12967 @055adb>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+12972 @055ae0>: 1f 40 1c 05 00             load.ref <@051c40> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+12977 @055ae5>: 02                         call
	<.main+12978 @055ae6>: 09 f8 ff ff                inc.sp(-8)
	<.main+12982 @055aea>: 67                         ceq.i64
	<.main+12983 @055aeb>: 06 08 00 00                jz <.main+12991 @055af3>
	<.main+12987 @055aef>: 04 2b 00 00                jmp <.main+13030 @055b1a>
	<.main+12991 @055af3>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+12996 @055af8>: 1c 80 00 00 00             load.c32 128
	<.main+13001 @055afd>: 1c fe ff ff ff             load.c32 -2
	<.main+13006 @055b02>: 1c 80 00 00 00             load.c32 128
	<.main+13011 @055b07>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13016 @055b0c>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13021 @055b11>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13026 @055b16>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (67 bytes: <@055b1a> - <@055b5d>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+13030 @055b1a>: 11 00                      dup.x64 sp(0)
	<.main+13032 @055b1c>: 1a                         load.z64
	<.main+13033 @055b1d>: 10 06                      dup.x32 sp(6)
	<.main+13035 @055b1f>: 2a e8 1b 05                load.m32 <@051be8> ;arrArrayInitFixed
	<.main+13039 @055b23>: 1f 40 1c 05 00             load.ref <@051c40> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13044 @055b28>: 02                         call
	<.main+13045 @055b29>: 09 f8 ff ff                inc.sp(-8)
	<.main+13049 @055b2d>: 67                         ceq.i64
	<.main+13050 @055b2e>: 06 08 00 00                jz <.main+13058 @055b36>
	<.main+13054 @055b32>: 04 2b 00 00                jmp <.main+13097 @055b5d>
	<.main+13058 @055b36>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+13063 @055b3b>: 1c 81 00 00 00             load.c32 129
	<.main+13068 @055b40>: 1c fe ff ff ff             load.c32 -2
	<.main+13073 @055b45>: 1c 80 00 00 00             load.c32 128
	<.main+13078 @055b4a>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13083 @055b4f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13088 @055b54>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13093 @055b59>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (67 bytes: <@055b5d> - <@055ba0>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+13097 @055b5d>: 11 00                      dup.x64 sp(0)
	<.main+13099 @055b5f>: 1a                         load.z64
	<.main+13100 @055b60>: 10 06                      dup.x32 sp(6)
	<.main+13102 @055b62>: 2a f0 1b 05                load.m32 <@051bf0> ;arrSliceInitFixed
	<.main+13106 @055b66>: 1f 40 1c 05 00             load.ref <@051c40> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13111 @055b6b>: 02                         call
	<.main+13112 @055b6c>: 09 f8 ff ff                inc.sp(-8)
	<.main+13116 @055b70>: 67                         ceq.i64
	<.main+13117 @055b71>: 06 08 00 00                jz <.main+13125 @055b79>
	<.main+13121 @055b75>: 04 2b 00 00                jmp <.main+13164 @055ba0>
	<.main+13125 @055b79>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+13130 @055b7e>: 1c 82 00 00 00             load.c32 130
	<.main+13135 @055b83>: 1c fe ff ff ff             load.c32 -2
	<.main+13140 @055b88>: 1c 80 00 00 00             load.c32 128
	<.main+13145 @055b8d>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13150 @055b92>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13155 @055b97>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13160 @055b9c>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (73 bytes: <@055ba0> - <@055be9>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+13164 @055ba0>: 11 00                      dup.x64 sp(0)
	<.main+13166 @055ba2>: 1a                         load.z64
	<.main+13167 @055ba3>: 10 06                      dup.x32 sp(6)
	<.main+13169 @055ba5>: 1c 07 00 00 00             load.c32 7
	<.main+13174 @055baa>: 1f 90 1b 05 00             load.ref <@051b90> ;arrFixedNoInit
	<.main+13179 @055baf>: 1f 50 1c 05 00             load.ref <@051c50> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13184 @055bb4>: 02                         call
	<.main+13185 @055bb5>: 09 f4 ff ff                inc.sp(-12)
	<.main+13189 @055bb9>: 67                         ceq.i64
	<.main+13190 @055bba>: 06 08 00 00                jz <.main+13198 @055bc2>
	<.main+13194 @055bbe>: 04 2b 00 00                jmp <.main+13237 @055be9>
	<.main+13198 @055bc2>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+13203 @055bc7>: 1c 84 00 00 00             load.c32 132
	<.main+13208 @055bcc>: 1c fe ff ff ff             load.c32 -2
	<.main+13213 @055bd1>: 1c 80 00 00 00             load.c32 128
	<.main+13218 @055bd6>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13223 @055bdb>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13228 @055be0>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13233 @055be5>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (67 bytes: <@055be9> - <@055c2c>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+13237 @055be9>: 11 00                      dup.x64 sp(0)
	<.main+13239 @055beb>: 1a                         load.z64
	<.main+13240 @055bec>: 10 06                      dup.x32 sp(6)
	<.main+13242 @055bee>: 2b f0 1b 05                load.m64 <@051bf0> ;arrSliceInitFixed
	<.main+13246 @055bf2>: 1f 50 1c 05 00             load.ref <@051c50> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13251 @055bf7>: 02                         call
	<.main+13252 @055bf8>: 09 f4 ff ff                inc.sp(-12)
	<.main+13256 @055bfc>: 67                         ceq.i64
	<.main+13257 @055bfd>: 06 08 00 00                jz <.main+13265 @055c05>
	<.main+13261 @055c01>: 04 2b 00 00                jmp <.main+13304 @055c2c>
	<.main+13265 @055c05>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+13270 @055c0a>: 1c 86 00 00 00             load.c32 134
	<.main+13275 @055c0f>: 1c fe ff ff ff             load.c32 -2
	<.main+13280 @055c14>: 1c 80 00 00 00             load.c32 128
	<.main+13285 @055c19>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13290 @055c1e>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13295 @055c23>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13300 @055c28>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (61 bytes: <@055c2c> - <@055c69>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+13304 @055c2c>: 11 00                      dup.x64 sp(0)
	<.main+13306 @055c2e>: 2a 00 1c 05                load.m32 <@051c00> ;arrSliceInitSlice
	<.main+13310 @055c32>: 10 05                      dup.x32 sp(5)
	<.main+13312 @055c34>: 0d 08 00 00                mad.u32 8
	<.main+13316 @055c38>: 23                         load.i64
	<.main+13317 @055c39>: 67                         ceq.i64
	<.main+13318 @055c3a>: 06 08 00 00                jz <.main+13326 @055c42>
	<.main+13322 @055c3e>: 04 2b 00 00                jmp <.main+13365 @055c69>
	<.main+13326 @055c42>: 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+13331 @055c47>: 1c 88 00 00 00             load.c32 136
	<.main+13336 @055c4c>: 1c fe ff ff ff             load.c32 -2
	<.main+13341 @055c51>: 1c 80 00 00 00             load.c32 128
	<.main+13346 @055c56>: 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+13351 @055c5b>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13356 @055c60>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13361 @055c65>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13365 @055c69>: 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@055c6d> - <@055c71>): int32(i := int32(i + 1))
	<.main+13369 @055c6d>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@055c71> - <@055c7d>): bool(i < arrFixedNoInit.length)
	<.main+13373 @055c71>: 10 00                      dup.x32 sp(0)
	<.main+13375 @055c73>: 1c 07 00 00 00             load.c32 7
	<.main+13380 @055c78>: 58                         clt.i32
	<.main+13381 @055c79>: 05 d2 fc ff                jnz <.main+12567 @05594b>
	<.main+13385 @055c7d>: 09 fc ff ff                inc.sp(-4)
	test/lang/method.ci:78: (21 bytes: <@055c81> - <@055c96>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+13389 @055c81>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13393 @055c85>: 1c 01 00 00 00             load.c32 1
	<.main+13398 @055c8a>: 13 04                      set.x32 sp(4)
	<.main+13400 @055c8c>: 1f b0 1c 05 00             load.ref <@051cb0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13405 @055c91>: 02                         call
	<.main+13406 @055c92>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (20 bytes: <@055c96> - <@055caa>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+13410 @055c96>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13414 @055c9a>: 1c 01 00 00 00             load.c32 1
	<.main+13419 @055c9f>: 13 04                      set.x32 sp(4)
	<.main+13421 @055ca1>: 2a 60 1d 05                load.m32 <@051d60> ;recordMethodTest+8
	<.main+13425 @055ca5>: 02                         call
	<.main+13426 @055ca6>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (19 bytes: <@055caa> - <@055cbd>): staticMethod(void(recordMethodTest, 2));
	<.main+13430 @055caa>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13434 @055cae>: 1c 02 00 00 00             load.c32 2
	<.main+13439 @055cb3>: 1f 68 1d 05 00             load.ref <@051d68> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13444 @055cb8>: 02                         call
	<.main+13445 @055cb9>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (19 bytes: <@055cbd> - <@055cd0>): virtualMethod(void(recordMethodTest, 2));
	<.main+13449 @055cbd>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13453 @055cc1>: 1c 02 00 00 00             load.c32 2
	<.main+13458 @055cc6>: 1f b0 1d 05 00             load.ref <@051db0> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13463 @055ccb>: 02                         call
	<.main+13464 @055ccc>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (21 bytes: <@055cd0> - <@055ce5>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+13468 @055cd0>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13472 @055cd4>: 1c 03 00 00 00             load.c32 3
	<.main+13477 @055cd9>: 13 04                      set.x32 sp(4)
	<.main+13479 @055cdb>: 1f b0 1c 05 00             load.ref <@051cb0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13484 @055ce0>: 02                         call
	<.main+13485 @055ce1>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (21 bytes: <@055ce5> - <@055cfa>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13489 @055ce5>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13493 @055ce9>: 1c 03 00 00 00             load.c32 3
	<.main+13498 @055cee>: 13 04                      set.x32 sp(4)
	<.main+13500 @055cf0>: 1f e0 1c 05 00             load.ref <@051ce0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13505 @055cf5>: 02                         call
	<.main+13506 @055cf6>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (20 bytes: <@055cfa> - <@055d0e>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13510 @055cfa>: 2c 58 1d 05                load.m128 <@051d58> ;recordMethodTest
	<.main+13514 @055cfe>: 1c 03 00 00 00             load.c32 3
	<.main+13519 @055d03>: 13 04                      set.x32 sp(4)
	<.main+13521 @055d05>: 2a 60 1d 05                load.m32 <@051d60> ;recordMethodTest+8
	<.main+13525 @055d09>: 02                         call
	<.main+13526 @055d0a>: 09 f0 ff ff                inc.sp(-16)
	test/lang/statementIf.ci:4: (39 bytes: <@055d0e> - <@055d35>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+13530 @055d0e>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13535 @055d13>: 1c 04 00 00 00             load.c32 4
	<.main+13540 @055d18>: 1c 0e 00 00 00             load.c32 14
	<.main+13545 @055d1d>: 1c 01 00 00 00             load.c32 1
	<.main+13550 @055d22>: 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+13555 @055d27>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13560 @055d2c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13565 @055d31>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@055d35> - <@055d5c>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+13569 @055d35>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13574 @055d3a>: 1c 0c 00 00 00             load.c32 12
	<.main+13579 @055d3f>: 1c 0e 00 00 00             load.c32 14
	<.main+13584 @055d44>: 1c 03 00 00 00             load.c32 3
	<.main+13589 @055d49>: 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+13594 @055d4e>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13599 @055d53>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13604 @055d58>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@055d5c> - <@055d83>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+13608 @055d5c>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13613 @055d61>: 1c 16 00 00 00             load.c32 22
	<.main+13618 @055d66>: 1c 0e 00 00 00             load.c32 14
	<.main+13623 @055d6b>: 1c 06 00 00 00             load.c32 6
	<.main+13628 @055d70>: 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+13633 @055d75>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13638 @055d7a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13643 @055d7f>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:28: (49 bytes: <@055d83> - <@055db4>): if (bool(t == 0))
	<.main+13647 @055d83>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13651 @055d87>: 19                         load.z32
	<.main+13652 @055d88>: 57                         ceq.i32
	<.main+13653 @055d89>: 06 2b 00 00                jz <.main+13696 @055db4>
	test/lang/statementIf.ci:29: (39 bytes: <@055d8d> - <@055db4>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+13657 @055d8d>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13662 @055d92>: 1c 1d 00 00 00             load.c32 29
	<.main+13667 @055d97>: 1c 0e 00 00 00             load.c32 14
	<.main+13672 @055d9c>: 1c 07 00 00 00             load.c32 7
	<.main+13677 @055da1>: 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+13682 @055da6>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13687 @055dab>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13692 @055db0>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (49 bytes: <@055db4> - <@055de5>): if (bool(t != 0))
	<.main+13696 @055db4>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13700 @055db8>: 19                         load.z32
	<.main+13701 @055db9>: 57                         ceq.i32
	<.main+13702 @055dba>: 05 2b 00 00                jnz <.main+13745 @055de5>
	test/lang/statementIf.ci:33: (39 bytes: <@055dbe> - <@055de5>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+13706 @055dbe>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13711 @055dc3>: 1c 21 00 00 00             load.c32 33
	<.main+13716 @055dc8>: 1c 0e 00 00 00             load.c32 14
	<.main+13721 @055dcd>: 1c 08 00 00 00             load.c32 8
	<.main+13726 @055dd2>: 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+13731 @055dd7>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13736 @055ddc>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13741 @055de1>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (92 bytes: <@055de5> - <@055e41>): if (bool(t == 0))
	<.main+13745 @055de5>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13749 @055de9>: 19                         load.z32
	<.main+13750 @055dea>: 57                         ceq.i32
	<.main+13751 @055deb>: 06 2f 00 00                jz <.main+13798 @055e1a>
	test/lang/statementIf.ci:37: (39 bytes: <@055def> - <@055e16>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13755 @055def>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13760 @055df4>: 1c 25 00 00 00             load.c32 37
	<.main+13765 @055df9>: 1c 0e 00 00 00             load.c32 14
	<.main+13770 @055dfe>: 1c 09 00 00 00             load.c32 9
	<.main+13775 @055e03>: 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+13780 @055e08>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13785 @055e0d>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13790 @055e12>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13794 @055e16>: 04 2b 00 00                jmp <.main+13837 @055e41>
	test/lang/statementIf.ci:40: (39 bytes: <@055e1a> - <@055e41>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+13798 @055e1a>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13803 @055e1f>: 1c 28 00 00 00             load.c32 40
	<.main+13808 @055e24>: 1c 0e 00 00 00             load.c32 14
	<.main+13813 @055e29>: 1c 0a 00 00 00             load.c32 10
	<.main+13818 @055e2e>: 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+13823 @055e33>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13828 @055e38>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13833 @055e3d>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (92 bytes: <@055e41> - <@055e9d>): if (bool(t != 0))
	<.main+13837 @055e41>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13841 @055e45>: 19                         load.z32
	<.main+13842 @055e46>: 57                         ceq.i32
	<.main+13843 @055e47>: 05 2f 00 00                jnz <.main+13890 @055e76>
	test/lang/statementIf.ci:44: (39 bytes: <@055e4b> - <@055e72>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+13847 @055e4b>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13852 @055e50>: 1c 2c 00 00 00             load.c32 44
	<.main+13857 @055e55>: 1c 0e 00 00 00             load.c32 14
	<.main+13862 @055e5a>: 1c 0b 00 00 00             load.c32 11
	<.main+13867 @055e5f>: 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+13872 @055e64>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13877 @055e69>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13882 @055e6e>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13886 @055e72>: 04 2b 00 00                jmp <.main+13929 @055e9d>
	test/lang/statementIf.ci:47: (39 bytes: <@055e76> - <@055e9d>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+13890 @055e76>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13895 @055e7b>: 1c 2f 00 00 00             load.c32 47
	<.main+13900 @055e80>: 1c 0e 00 00 00             load.c32 14
	<.main+13905 @055e85>: 1c 0c 00 00 00             load.c32 12
	<.main+13910 @055e8a>: 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+13915 @055e8f>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13920 @055e94>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13925 @055e99>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (377 bytes: <@055e9d> - <@056016>): if (bool(t == 0))
	<.main+13929 @055e9d>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13933 @055ea1>: 19                         load.z32
	<.main+13934 @055ea2>: 57                         ceq.i32
	<.main+13935 @055ea3>: 06 2f 00 00                jz <.main+13982 @055ed2>
	test/lang/statementIf.ci:51: (39 bytes: <@055ea7> - <@055ece>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13939 @055ea7>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+13944 @055eac>: 1c 33 00 00 00             load.c32 51
	<.main+13949 @055eb1>: 1c 0e 00 00 00             load.c32 14
	<.main+13954 @055eb6>: 1c 09 00 00 00             load.c32 9
	<.main+13959 @055ebb>: 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+13964 @055ec0>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13969 @055ec5>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+13974 @055eca>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13978 @055ece>: 04 48 01 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:53: (324 bytes: <@055ed2> - <@056016>): if (bool(t == 1))
	<.main+13982 @055ed2>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+13986 @055ed6>: 1c 01 00 00 00             load.c32 1
	<.main+13991 @055edb>: 57                         ceq.i32
	<.main+13992 @055edc>: 06 2f 00 00                jz <.main+14039 @055f0b>
	test/lang/statementIf.ci:54: (39 bytes: <@055ee0> - <@055f07>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+13996 @055ee0>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14001 @055ee5>: 1c 36 00 00 00             load.c32 54
	<.main+14006 @055eea>: 1c 0e 00 00 00             load.c32 14
	<.main+14011 @055eef>: 1c 0a 00 00 00             load.c32 10
	<.main+14016 @055ef4>: 1f d5 c9 04 00             load.ref <@04c9d5> ;"t == 1"
	<.main+14021 @055ef9>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14026 @055efe>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14031 @055f03>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14035 @055f07>: 04 0f 01 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:56: (267 bytes: <@055f0b> - <@056016>): if (bool(t == 2))
	<.main+14039 @055f0b>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+14043 @055f0f>: 1c 02 00 00 00             load.c32 2
	<.main+14048 @055f14>: 57                         ceq.i32
	<.main+14049 @055f15>: 06 2f 00 00                jz <.main+14096 @055f44>
	test/lang/statementIf.ci:57: (39 bytes: <@055f19> - <@055f40>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+14053 @055f19>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14058 @055f1e>: 1c 39 00 00 00             load.c32 57
	<.main+14063 @055f23>: 1c 0e 00 00 00             load.c32 14
	<.main+14068 @055f28>: 1c 0a 00 00 00             load.c32 10
	<.main+14073 @055f2d>: 1f dc c9 04 00             load.ref <@04c9dc> ;"t == 2"
	<.main+14078 @055f32>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14083 @055f37>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14088 @055f3c>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14092 @055f40>: 04 d6 00 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:59: (210 bytes: <@055f44> - <@056016>): if (bool(t == 3))
	<.main+14096 @055f44>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+14100 @055f48>: 1c 03 00 00 00             load.c32 3
	<.main+14105 @055f4d>: 57                         ceq.i32
	<.main+14106 @055f4e>: 06 2f 00 00                jz <.main+14153 @055f7d>
	test/lang/statementIf.ci:60: (39 bytes: <@055f52> - <@055f79>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+14110 @055f52>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14115 @055f57>: 1c 3c 00 00 00             load.c32 60
	<.main+14120 @055f5c>: 1c 0e 00 00 00             load.c32 14
	<.main+14125 @055f61>: 1c 0a 00 00 00             load.c32 10
	<.main+14130 @055f66>: 1f e3 c9 04 00             load.ref <@04c9e3> ;"t == 3"
	<.main+14135 @055f6b>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14140 @055f70>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14145 @055f75>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14149 @055f79>: 04 9d 00 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:62: (153 bytes: <@055f7d> - <@056016>): if (bool(t == 4))
	<.main+14153 @055f7d>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+14157 @055f81>: 1c 04 00 00 00             load.c32 4
	<.main+14162 @055f86>: 57                         ceq.i32
	<.main+14163 @055f87>: 06 2f 00 00                jz <.main+14210 @055fb6>
	test/lang/statementIf.ci:63: (39 bytes: <@055f8b> - <@055fb2>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+14167 @055f8b>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14172 @055f90>: 1c 3f 00 00 00             load.c32 63
	<.main+14177 @055f95>: 1c 0e 00 00 00             load.c32 14
	<.main+14182 @055f9a>: 1c 0a 00 00 00             load.c32 10
	<.main+14187 @055f9f>: 1f ea c9 04 00             load.ref <@04c9ea> ;"t == 4"
	<.main+14192 @055fa4>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14197 @055fa9>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14202 @055fae>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14206 @055fb2>: 04 64 00 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:65: (96 bytes: <@055fb6> - <@056016>): if (bool(t == 5))
	<.main+14210 @055fb6>: 2a d0 25 05                load.m32 <@0525d0> ;t
	<.main+14214 @055fba>: 1c 05 00 00 00             load.c32 5
	<.main+14219 @055fbf>: 57                         ceq.i32
	<.main+14220 @055fc0>: 06 2f 00 00                jz <.main+14267 @055fef>
	test/lang/statementIf.ci:66: (39 bytes: <@055fc4> - <@055feb>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+14224 @055fc4>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14229 @055fc9>: 1c 42 00 00 00             load.c32 66
	<.main+14234 @055fce>: 1c 0e 00 00 00             load.c32 14
	<.main+14239 @055fd3>: 1c 0a 00 00 00             load.c32 10
	<.main+14244 @055fd8>: 1f f1 c9 04 00             load.ref <@04c9f1> ;"t == 5"
	<.main+14249 @055fdd>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14254 @055fe2>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14259 @055fe7>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14263 @055feb>: 04 2b 00 00                jmp <.main+14306 @056016>
	test/lang/statementIf.ci:69: (39 bytes: <@055fef> - <@056016>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+14267 @055fef>: 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+14272 @055ff4>: 1c 45 00 00 00             load.c32 69
	<.main+14277 @055ff9>: 1c 0e 00 00 00             load.c32 14
	<.main+14282 @055ffe>: 1c 0a 00 00 00             load.c32 10
	<.main+14287 @056003>: 1f f8 c9 04 00             load.ref <@04c9f8> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14292 @056008>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14297 @05600d>: 1f d0 25 05 00             load.ref <@0525d0> ;t
	<.main+14302 @056012>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@056016> - <@056045>): for ( ; ; )
	<.main+14306 @056016>: 04 2b 00 00                jmp <.main+14349 @056041>
	test/lang/statementFor.ci:4: (35 bytes: <@05601a> - <@05603d>): debug("for ( ; ; )");
	<.main+14310 @05601a>: 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+14315 @05601f>: 1c 04 00 00 00             load.c32 4
	<.main+14320 @056024>: 1c 0e 00 00 00             load.c32 14
	<.main+14325 @056029>: 19                         load.z32
	<.main+14326 @05602a>: 1f fa ca 04 00             load.ref <@04cafa> ;"for ( ; ; )"
	<.main+14331 @05602f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14336 @056034>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14341 @056039>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@05603d> - <@056041>): break;
	<.main+14345 @05603d>: 04 08 00 00                jmp <.main+14353 @056045>
	:: (4 bytes: <@056041> - <@056045>)
	<.main+14349 @056041>: 04 d9 ff ff                jmp <.main+14310 @05601a>
	test/lang/statementFor.ci:8: (59 bytes: <@056045> - <@056080>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+14353 @056045>: 19                         load.z32
	<.main+14354 @056046>: 04 2a 00 00                jmp <.main+14396 @056070>
	test/lang/statementFor.ci:9: (34 bytes: <@05604a> - <@05606c>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+14358 @05604a>: 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+14363 @05604f>: 1c 09 00 00 00             load.c32 9
	<.main+14368 @056054>: 1c 0e 00 00 00             load.c32 14
	<.main+14373 @056059>: 19                         load.z32
	<.main+14374 @05605a>: 1f 06 cb 04 00             load.ref <@04cb06> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14379 @05605f>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14384 @056064>: 0a 18 00 00                load.sp(+24)
	<.main+14388 @056068>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@05606c> - <@056070>): int32(i := int32(i + 1))
	<.main+14392 @05606c>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@056070> - <@05607c>): bool(i < 2)
	<.main+14396 @056070>: 10 00                      dup.x32 sp(0)
	<.main+14398 @056072>: 1c 02 00 00 00             load.c32 2
	<.main+14403 @056077>: 58                         clt.i32
	<.main+14404 @056078>: 05 d2 ff ff                jnz <.main+14358 @05604a>
	<.main+14408 @05607c>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:13: (70 bytes: <@056080> - <@0560c6>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+14412 @056080>: 19                         load.z32
	<.main+14413 @056081>: 2e d8 25 05                store.m32 <@0525d8> ;forIdx
	<.main+14417 @056085>: 04 33 00 00                jmp <.main+14468 @0560b8>
	test/lang/statementFor.ci:14: (35 bytes: <@056089> - <@0560ac>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+14421 @056089>: 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+14426 @05608e>: 1c 0e 00 00 00             load.c32 14
	<.main+14431 @056093>: 1c 0e 00 00 00             load.c32 14
	<.main+14436 @056098>: 19                         load.z32
	<.main+14437 @056099>: 1f 2c cb 04 00             load.ref <@04cb2c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14442 @05609e>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14447 @0560a3>: 1f d8 25 05 00             load.ref <@0525d8> ;forIdx
	<.main+14452 @0560a8>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (12 bytes: <@0560ac> - <@0560b8>): int32(forIdx := int32(forIdx + 1))
	<.main+14456 @0560ac>: 2a d8 25 05                load.m32 <@0525d8> ;forIdx
	<.main+14460 @0560b0>: 0c 01 00 00                inc.i32(+1)
	<.main+14464 @0560b4>: 2e d8 25 05                store.m32 <@0525d8> ;forIdx
	test/lang/statementFor.ci:13: (14 bytes: <@0560b8> - <@0560c6>): bool(forIdx < 2)
	<.main+14468 @0560b8>: 2a d8 25 05                load.m32 <@0525d8> ;forIdx
	<.main+14472 @0560bc>: 1c 02 00 00 00             load.c32 2
	<.main+14477 @0560c1>: 58                         clt.i32
	<.main+14478 @0560c2>: 05 c7 ff ff                jnz <.main+14421 @056089>
	test/lang/statementFor.ci:17: (75 bytes: <@0560c6> - <@056111>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14482 @0560c6>: 19                         load.z32
	<.main+14483 @0560c7>: 04 3a 00 00                jmp <.main+14541 @056101>
	test/lang/statementFor.ci:18: (16 bytes: <@0560cb> - <@0560db>): if (bool(i < 2))
	<.main+14487 @0560cb>: 10 00                      dup.x32 sp(0)
	<.main+14489 @0560cd>: 1c 02 00 00 00             load.c32 2
	<.main+14494 @0560d2>: 58                         clt.i32
	<.main+14495 @0560d3>: 06 08 00 00                jz <.main+14503 @0560db>
	test/lang/statementFor.ci:19: (4 bytes: <@0560d7> - <@0560db>): continue;
	<.main+14499 @0560d7>: 04 26 00 00                jmp <.main+14537 @0560fd>
	test/lang/statementFor.ci:21: (34 bytes: <@0560db> - <@0560fd>): debug(void("for with continue", i));
	<.main+14503 @0560db>: 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+14508 @0560e0>: 1c 15 00 00 00             load.c32 21
	<.main+14513 @0560e5>: 1c 0e 00 00 00             load.c32 14
	<.main+14518 @0560ea>: 19                         load.z32
	<.main+14519 @0560eb>: 1f 56 cb 04 00             load.ref <@04cb56> ;"for with continue"
	<.main+14524 @0560f0>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14529 @0560f5>: 0a 18 00 00                load.sp(+24)
	<.main+14533 @0560f9>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@0560fd> - <@056101>): int32(i := int32(i + 1))
	<.main+14537 @0560fd>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@056101> - <@05610d>): bool(i < 7)
	<.main+14541 @056101>: 10 00                      dup.x32 sp(0)
	<.main+14543 @056103>: 1c 07 00 00 00             load.c32 7
	<.main+14548 @056108>: 58                         clt.i32
	<.main+14549 @056109>: 05 c2 ff ff                jnz <.main+14487 @0560cb>
	<.main+14553 @05610d>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@056111> - <@05615c>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14557 @056111>: 19                         load.z32
	<.main+14558 @056112>: 04 3a 00 00                jmp <.main+14616 @05614c>
	test/lang/statementFor.ci:25: (16 bytes: <@056116> - <@056126>): if (bool(i > 2))
	<.main+14562 @056116>: 10 00                      dup.x32 sp(0)
	<.main+14564 @056118>: 1c 02 00 00 00             load.c32 2
	<.main+14569 @05611d>: 59                         cgt.i32
	<.main+14570 @05611e>: 06 08 00 00                jz <.main+14578 @056126>
	test/lang/statementFor.ci:26: (4 bytes: <@056122> - <@056126>): break;
	<.main+14574 @056122>: 04 36 00 00                jmp <.main+14628 @056158>
	test/lang/statementFor.ci:28: (34 bytes: <@056126> - <@056148>): debug(void("for with break", i));
	<.main+14578 @056126>: 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+14583 @05612b>: 1c 1c 00 00 00             load.c32 28
	<.main+14588 @056130>: 1c 0e 00 00 00             load.c32 14
	<.main+14593 @056135>: 19                         load.z32
	<.main+14594 @056136>: 1f 68 cb 04 00             load.ref <@04cb68> ;"for with break"
	<.main+14599 @05613b>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14604 @056140>: 0a 18 00 00                load.sp(+24)
	<.main+14608 @056144>: 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@056148> - <@05614c>): int32(i := int32(i + 1))
	<.main+14612 @056148>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@05614c> - <@056158>): bool(i < 7)
	<.main+14616 @05614c>: 10 00                      dup.x32 sp(0)
	<.main+14618 @05614e>: 1c 07 00 00 00             load.c32 7
	<.main+14623 @056153>: 58                         clt.i32
	<.main+14624 @056154>: 05 c2 ff ff                jnz <.main+14562 @056116>
	<.main+14628 @056158>: 09 fc ff ff                inc.sp(-4)
	<.main+14632 @05615c>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 277.02] > .main
[ 277.69]  > funAdd(x: int32, y: int32): int32
[ 277.70]  < return
[ 277.72]  > funAdd(x: int32, y: int32): int32
[ 277.73]  < return
[ 277.74]  > funMul(x: int32, y: int32): int32
[ 277.76]  < return
[ 277.77]  > funMul(x: int32, y: int32): int32
[ 277.78]  < return
[ 277.80]  > fib(n: uint32): uint32
[ 277.81]   > fib(n: uint32): uint32
[ 277.83]    > fib(n: uint32): uint32
[ 277.84]     > fib(n: uint32): uint32
[ 277.86]      > fib(n: uint32): uint32
[ 277.87]       > fib(n: uint32): uint32
[ 277.88]        > fib(n: uint32): uint32
[ 277.90]         > fib(n: uint32): uint32
[ 277.91]          > fib(n: uint32): uint32
[ 277.93]           > fib(n: uint32): uint32
[ 277.94]            > fib(n: uint32): uint32
[ 277.95]             > fib(n: uint32): uint32
[ 277.97]              > fib(n: uint32): uint32
[ 277.98]              < return
[ 277.99]              > fib(n: uint32): uint32
[ 278.00]              < return
[ 278.01]             < return
[ 278.02]             > fib(n: uint32): uint32
[ 278.03]             < return
[ 278.04]            < return
[ 278.05]            > fib(n: uint32): uint32
[ 278.06]             > fib(n: uint32): uint32
[ 278.08]             < return
[ 278.09]             > fib(n: uint32): uint32
[ 278.10]             < return
[ 278.11]            < return
[ 278.12]           < return
[ 278.12]           > fib(n: uint32): uint32
[ 278.14]            > fib(n: uint32): uint32
[ 278.15]             > fib(n: uint32): uint32
[ 278.16]             < return
[ 278.18]             > fib(n: uint32): uint32
[ 278.19]             < return
[ 278.20]            < return
[ 278.21]            > fib(n: uint32): uint32
[ 278.23]            < return
[ 278.23]           < return
[ 278.24]          < return
[ 278.25]          > fib(n: uint32): uint32
[ 278.26]           > fib(n: uint32): uint32
[ 278.28]            > fib(n: uint32): uint32
[ 278.29]             > fib(n: uint32): uint32
[ 278.31]             < return
[ 278.31]             > fib(n: uint32): uint32
[ 278.33]             < return
[ 278.34]            < return
[ 278.35]            > fib(n: uint32): uint32
[ 278.36]            < return
[ 278.37]           < return
[ 278.38]           > fib(n: uint32): uint32
[ 278.39]            > fib(n: uint32): uint32
[ 278.40]            < return
[ 278.41]            > fib(n: uint32): uint32
[ 278.42]            < return
[ 278.43]           < return
[ 278.44]          < return
[ 278.45]         < return
[ 278.46]         > fib(n: uint32): uint32
[ 278.47]          > fib(n: uint32): uint32
[ 278.49]           > fib(n: uint32): uint32
[ 278.50]            > fib(n: uint32): uint32
[ 278.51]             > fib(n: uint32): uint32
[ 278.53]             < return
[ 278.54]             > fib(n: uint32): uint32
[ 278.55]             < return
[ 278.56]            < return
[ 278.57]            > fib(n: uint32): uint32
[ 278.58]            < return
[ 278.59]           < return
[ 278.60]           > fib(n: uint32): uint32
[ 278.61]            > fib(n: uint32): uint32
[ 278.62]            < return
[ 278.63]            > fib(n: uint32): uint32
[ 278.64]            < return
[ 278.65]           < return
[ 278.66]          < return
[ 278.67]          > fib(n: uint32): uint32
[ 278.68]           > fib(n: uint32): uint32
[ 278.70]            > fib(n: uint32): uint32
[ 278.71]            < return
[ 278.72]            > fib(n: uint32): uint32
[ 278.73]            < return
[ 278.74]           < return
[ 278.75]           > fib(n: uint32): uint32
[ 278.76]           < return
[ 278.77]          < return
[ 278.78]         < return
[ 278.79]        < return
[ 278.80]        > fib(n: uint32): uint32
[ 278.81]         > fib(n: uint32): uint32
[ 278.82]          > fib(n: uint32): uint32
[ 278.84]           > fib(n: uint32): uint32
[ 278.85]            > fib(n: uint32): uint32
[ 278.87]             > fib(n: uint32): uint32
[ 278.88]             < return
[ 278.89]             > fib(n: uint32): uint32
[ 278.90]             < return
[ 278.91]            < return
[ 278.92]            > fib(n: uint32): uint32
[ 278.93]            < return
[ 278.94]           < return
[ 278.95]           > fib(n: uint32): uint32
[ 278.96]            > fib(n: uint32): uint32
[ 278.97]            < return
[ 278.98]            > fib(n: uint32): uint32
[ 279.00]            < return
[ 279.00]           < return
[ 279.01]          < return
[ 279.02]          > fib(n: uint32): uint32
[ 279.04]           > fib(n: uint32): uint32
[ 279.05]            > fib(n: uint32): uint32
[ 279.06]            < return
[ 279.07]            > fib(n: uint32): uint32
[ 279.08]            < return
[ 279.09]           < return
[ 279.10]           > fib(n: uint32): uint32
[ 279.11]           < return
[ 279.12]          < return
[ 279.13]         < return
[ 279.14]         > fib(n: uint32): uint32
[ 279.15]          > fib(n: uint32): uint32
[ 279.17]           > fib(n: uint32): uint32
[ 279.18]            > fib(n: uint32): uint32
[ 279.19]            < return
[ 279.20]            > fib(n: uint32): uint32
[ 279.22]            < return
[ 279.23]           < return
[ 279.23]           > fib(n: uint32): uint32
[ 279.25]           < return
[ 279.25]          < return
[ 279.26]          > fib(n: uint32): uint32
[ 279.28]           > fib(n: uint32): uint32
[ 279.29]           < return
[ 279.30]           > fib(n: uint32): uint32
[ 279.31]           < return
[ 279.32]          < return
[ 279.33]         < return
[ 279.34]        < return
[ 279.34]       < return
[ 279.35]       > fib(n: uint32): uint32
[ 279.37]        > fib(n: uint32): uint32
[ 279.38]         > fib(n: uint32): uint32
[ 279.40]          > fib(n: uint32): uint32
[ 279.42]           > fib(n: uint32): uint32
[ 279.43]            > fib(n: uint32): uint32
[ 279.44]             > fib(n: uint32): uint32
[ 279.46]             < return
[ 279.47]             > fib(n: uint32): uint32
[ 279.48]             < return
[ 279.49]            < return
[ 279.50]            > fib(n: uint32): uint32
[ 279.51]            < return
[ 279.52]           < return
[ 279.53]           > fib(n: uint32): uint32
[ 279.54]            > fib(n: uint32): uint32
[ 279.55]            < return
[ 279.56]            > fib(n: uint32): uint32
[ 279.57]            < return
[ 279.58]           < return
[ 279.59]          < return
[ 279.60]          > fib(n: uint32): uint32
[ 279.61]           > fib(n: uint32): uint32
[ 279.63]            > fib(n: uint32): uint32
[ 279.64]            < return
[ 279.65]            > fib(n: uint32): uint32
[ 279.66]            < return
[ 279.67]           < return
[ 279.68]           > fib(n: uint32): uint32
[ 279.69]           < return
[ 279.70]          < return
[ 279.71]         < return
[ 279.72]         > fib(n: uint32): uint32
[ 279.73]          > fib(n: uint32): uint32
[ 279.75]           > fib(n: uint32): uint32
[ 279.76]            > fib(n: uint32): uint32
[ 279.77]            < return
[ 279.79]            > fib(n: uint32): uint32
[ 279.80]            < return
[ 279.81]           < return
[ 279.82]           > fib(n: uint32): uint32
[ 279.83]           < return
[ 279.84]          < return
[ 279.85]          > fib(n: uint32): uint32
[ 279.86]           > fib(n: uint32): uint32
[ 279.87]           < return
[ 279.88]           > fib(n: uint32): uint32
[ 279.90]           < return
[ 279.90]          < return
[ 279.91]         < return
[ 279.92]        < return
[ 279.93]        > fib(n: uint32): uint32
[ 279.94]         > fib(n: uint32): uint32
[ 279.96]          > fib(n: uint32): uint32
[ 279.97]           > fib(n: uint32): uint32
[ 279.99]            > fib(n: uint32): uint32
[ 280.00]            < return
[ 280.01]            > fib(n: uint32): uint32
[ 280.02]            < return
[ 280.03]           < return
[ 280.04]           > fib(n: uint32): uint32
[ 280.05]           < return
[ 280.06]          < return
[ 280.07]          > fib(n: uint32): uint32
[ 280.08]           > fib(n: uint32): uint32
[ 280.09]           < return
[ 280.10]           > fib(n: uint32): uint32
[ 280.12]           < return
[ 280.12]          < return
[ 280.13]         < return
[ 280.14]         > fib(n: uint32): uint32
[ 280.15]          > fib(n: uint32): uint32
[ 280.17]           > fib(n: uint32): uint32
[ 280.18]           < return
[ 280.19]           > fib(n: uint32): uint32
[ 280.20]           < return
[ 280.21]          < return
[ 280.22]          > fib(n: uint32): uint32
[ 280.23]          < return
[ 280.24]         < return
[ 280.25]        < return
[ 280.26]       < return
[ 280.26]      < return
[ 280.27]      > fib(n: uint32): uint32
[ 280.29]       > fib(n: uint32): uint32
[ 280.30]        > fib(n: uint32): uint32
[ 280.32]         > fib(n: uint32): uint32
[ 280.34]          > fib(n: uint32): uint32
[ 280.35]           > fib(n: uint32): uint32
[ 280.36]            > fib(n: uint32): uint32
[ 280.38]             > fib(n: uint32): uint32
[ 280.40]             < return
[ 280.41]             > fib(n: uint32): uint32
[ 280.42]             < return
[ 280.43]            < return
[ 280.44]            > fib(n: uint32): uint32
[ 280.45]            < return
[ 280.46]           < return
[ 280.47]           > fib(n: uint32): uint32
[ 280.48]            > fib(n: uint32): uint32
[ 280.50]            < return
[ 280.50]            > fib(n: uint32): uint32
[ 280.52]            < return
[ 280.52]           < return
[ 280.53]          < return
[ 280.54]          > fib(n: uint32): uint32
[ 280.56]           > fib(n: uint32): uint32
[ 280.57]            > fib(n: uint32): uint32
[ 280.58]            < return
[ 280.59]            > fib(n: uint32): uint32
[ 280.60]            < return
[ 280.61]           < return
[ 280.62]           > fib(n: uint32): uint32
[ 280.63]           < return
[ 280.64]          < return
[ 280.65]         < return
[ 280.66]         > fib(n: uint32): uint32
[ 280.67]          > fib(n: uint32): uint32
[ 280.69]           > fib(n: uint32): uint32
[ 280.70]            > fib(n: uint32): uint32
[ 280.71]            < return
[ 280.72]            > fib(n: uint32): uint32
[ 280.73]            < return
[ 280.74]           < return
[ 280.75]           > fib(n: uint32): uint32
[ 280.76]           < return
[ 280.77]          < return
[ 280.78]          > fib(n: uint32): uint32
[ 280.79]           > fib(n: uint32): uint32
[ 280.81]           < return
[ 280.81]           > fib(n: uint32): uint32
[ 280.83]           < return
[ 280.83]          < return
[ 280.84]         < return
[ 280.85]        < return
[ 280.86]        > fib(n: uint32): uint32
[ 280.87]         > fib(n: uint32): uint32
[ 280.89]          > fib(n: uint32): uint32
[ 280.90]           > fib(n: uint32): uint32
[ 280.91]            > fib(n: uint32): uint32
[ 280.93]            < return
[ 280.94]            > fib(n: uint32): uint32
[ 280.95]            < return
[ 280.96]           < return
[ 280.96]           > fib(n: uint32): uint32
[ 280.98]           < return
[ 280.99]          < return
[ 280.99]          > fib(n: uint32): uint32
[ 281.01]           > fib(n: uint32): uint32
[ 281.02]           < return
[ 281.03]           > fib(n: uint32): uint32
[ 281.04]           < return
[ 281.05]          < return
[ 281.06]         < return
[ 281.06]         > fib(n: uint32): uint32
[ 281.08]          > fib(n: uint32): uint32
[ 281.09]           > fib(n: uint32): uint32
[ 281.11]           < return
[ 281.11]           > fib(n: uint32): uint32
[ 281.13]           < return
[ 281.13]          < return
[ 281.14]          > fib(n: uint32): uint32
[ 281.16]          < return
[ 281.16]         < return
[ 281.17]        < return
[ 281.18]       < return
[ 281.19]       > fib(n: uint32): uint32
[ 281.20]        > fib(n: uint32): uint32
[ 281.22]         > fib(n: uint32): uint32
[ 281.23]          > fib(n: uint32): uint32
[ 281.25]           > fib(n: uint32): uint32
[ 281.26]            > fib(n: uint32): uint32
[ 281.27]            < return
[ 281.28]            > fib(n: uint32): uint32
[ 281.29]            < return
[ 281.30]           < return
[ 281.31]           > fib(n: uint32): uint32
[ 281.32]           < return
[ 281.33]          < return
[ 281.34]          > fib(n: uint32): uint32
[ 281.36]           > fib(n: uint32): uint32
[ 281.37]           < return
[ 281.39]           > fib(n: uint32): uint32
[ 281.40]           < return
[ 281.41]          < return
[ 281.42]         < return
[ 281.43]         > fib(n: uint32): uint32
[ 281.44]          > fib(n: uint32): uint32
[ 281.45]           > fib(n: uint32): uint32
[ 281.46]           < return
[ 281.47]           > fib(n: uint32): uint32
[ 281.49]           < return
[ 281.50]          < return
[ 281.50]          > fib(n: uint32): uint32
[ 281.52]          < return
[ 281.52]         < return
[ 281.53]        < return
[ 281.54]        > fib(n: uint32): uint32
[ 281.56]         > fib(n: uint32): uint32
[ 281.57]          > fib(n: uint32): uint32
[ 281.58]           > fib(n: uint32): uint32
[ 281.60]           < return
[ 281.61]           > fib(n: uint32): uint32
[ 281.62]           < return
[ 281.63]          < return
[ 281.63]          > fib(n: uint32): uint32
[ 281.65]          < return
[ 281.65]         < return
[ 281.66]         > fib(n: uint32): uint32
[ 281.68]          > fib(n: uint32): uint32
[ 281.69]          < return
[ 281.70]          > fib(n: uint32): uint32
[ 281.71]          < return
[ 281.72]         < return
[ 281.73]        < return
[ 281.74]       < return
[ 281.74]      < return
[ 281.75]     < return
[ 281.76]     > fib(n: uint32): uint32
[ 281.77]      > fib(n: uint32): uint32
[ 281.79]       > fib(n: uint32): uint32
[ 281.80]        > fib(n: uint32): uint32
[ 281.82]         > fib(n: uint32): uint32
[ 281.83]          > fib(n: uint32): uint32
[ 281.85]           > fib(n: uint32): uint32
[ 281.86]            > fib(n: uint32): uint32
[ 281.87]             > fib(n: uint32): uint32
[ 281.89]             < return
[ 281.90]             > fib(n: uint32): uint32
[ 281.92]             < return
[ 281.93]            < return
[ 281.93]            > fib(n: uint32): uint32
[ 281.95]            < return
[ 281.95]           < return
[ 281.96]           > fib(n: uint32): uint32
[ 281.98]            > fib(n: uint32): uint32
[ 281.99]            < return
[ 282.00]            > fib(n: uint32): uint32
[ 282.01]            < return
[ 282.02]           < return
[ 282.03]          < return
[ 282.04]          > fib(n: uint32): uint32
[ 282.05]           > fib(n: uint32): uint32
[ 282.06]            > fib(n: uint32): uint32
[ 282.08]            < return
[ 282.09]            > fib(n: uint32): uint32
[ 282.10]            < return
[ 282.11]           < return
[ 282.12]           > fib(n: uint32): uint32
[ 282.13]           < return
[ 282.14]          < return
[ 282.14]         < return
[ 282.15]         > fib(n: uint32): uint32
[ 282.17]          > fib(n: uint32): uint32
[ 282.18]           > fib(n: uint32): uint32
[ 282.19]            > fib(n: uint32): uint32
[ 282.21]            < return
[ 282.22]            > fib(n: uint32): uint32
[ 282.23]            < return
[ 282.24]           < return
[ 282.25]           > fib(n: uint32): uint32
[ 282.26]           < return
[ 282.27]          < return
[ 282.27]          > fib(n: uint32): uint32
[ 282.29]           > fib(n: uint32): uint32
[ 282.30]           < return
[ 282.31]           > fib(n: uint32): uint32
[ 282.32]           < return
[ 282.33]          < return
[ 282.34]         < return
[ 282.35]        < return
[ 282.36]        > fib(n: uint32): uint32
[ 282.37]         > fib(n: uint32): uint32
[ 282.38]          > fib(n: uint32): uint32
[ 282.40]           > fib(n: uint32): uint32
[ 282.41]            > fib(n: uint32): uint32
[ 282.42]            < return
[ 282.43]            > fib(n: uint32): uint32
[ 282.44]            < return
[ 282.45]           < return
[ 282.46]           > fib(n: uint32): uint32
[ 282.48]           < return
[ 282.48]          < return
[ 282.49]          > fib(n: uint32): uint32
[ 282.51]           > fib(n: uint32): uint32
[ 282.52]           < return
[ 282.53]           > fib(n: uint32): uint32
[ 282.54]           < return
[ 282.55]          < return
[ 282.56]         < return
[ 282.56]         > fib(n: uint32): uint32
[ 282.58]          > fib(n: uint32): uint32
[ 282.59]           > fib(n: uint32): uint32
[ 282.61]           < return
[ 282.61]           > fib(n: uint32): uint32
[ 282.63]           < return
[ 282.63]          < return
[ 282.64]          > fib(n: uint32): uint32
[ 282.66]          < return
[ 282.66]         < return
[ 282.67]        < return
[ 282.68]       < return
[ 282.69]       > fib(n: uint32): uint32
[ 282.70]        > fib(n: uint32): uint32
[ 282.72]         > fib(n: uint32): uint32
[ 282.73]          > fib(n: uint32): uint32
[ 282.75]           > fib(n: uint32): uint32
[ 282.76]            > fib(n: uint32): uint32
[ 282.77]            < return
[ 282.78]            > fib(n: uint32): uint32
[ 282.79]            < return
[ 282.80]           < return
[ 282.81]           > fib(n: uint32): uint32
[ 282.82]           < return
[ 282.83]          < return
[ 282.84]          > fib(n: uint32): uint32
[ 282.85]           > fib(n: uint32): uint32
[ 282.87]           < return
[ 282.87]           > fib(n: uint32): uint32
[ 282.89]           < return
[ 282.89]          < return
[ 282.90]         < return
[ 282.91]         > fib(n: uint32): uint32
[ 282.93]          > fib(n: uint32): uint32
[ 282.94]           > fib(n: uint32): uint32
[ 282.95]           < return
[ 282.96]           > fib(n: uint32): uint32
[ 282.97]           < return
[ 282.98]          < return
[ 282.99]          > fib(n: uint32): uint32
[ 283.00]          < return
[ 283.01]         < return
[ 283.02]        < return
[ 283.03]        > fib(n: uint32): uint32
[ 283.04]         > fib(n: uint32): uint32
[ 283.06]          > fib(n: uint32): uint32
[ 283.07]           > fib(n: uint32): uint32
[ 283.08]           < return
[ 283.09]           > fib(n: uint32): uint32
[ 283.11]           < return
[ 283.11]          < return
[ 283.12]          > fib(n: uint32): uint32
[ 283.13]          < return
[ 283.14]         < return
[ 283.15]         > fib(n: uint32): uint32
[ 283.17]          > fib(n: uint32): uint32
[ 283.18]          < return
[ 283.19]          > fib(n: uint32): uint32
[ 283.20]          < return
[ 283.21]         < return
[ 283.22]        < return
[ 283.23]       < return
[ 283.23]      < return
[ 283.24]      > fib(n: uint32): uint32
[ 283.25]       > fib(n: uint32): uint32
[ 283.27]        > fib(n: uint32): uint32
[ 283.28]         > fib(n: uint32): uint32
[ 283.30]          > fib(n: uint32): uint32
[ 283.31]           > fib(n: uint32): uint32
[ 283.32]            > fib(n: uint32): uint32
[ 283.34]            < return
[ 283.35]            > fib(n: uint32): uint32
[ 283.36]            < return
[ 283.37]           < return
[ 283.38]           > fib(n: uint32): uint32
[ 283.39]           < return
[ 283.40]          < return
[ 283.40]          > fib(n: uint32): uint32
[ 283.42]           > fib(n: uint32): uint32
[ 283.43]           < return
[ 283.44]           > fib(n: uint32): uint32
[ 283.45]           < return
[ 283.46]          < return
[ 283.47]         < return
[ 283.48]         > fib(n: uint32): uint32
[ 283.49]          > fib(n: uint32): uint32
[ 283.50]           > fib(n: uint32): uint32
[ 283.52]           < return
[ 283.53]           > fib(n: uint32): uint32
[ 283.54]           < return
[ 283.55]          < return
[ 283.56]          > fib(n: uint32): uint32
[ 283.57]          < return
[ 283.58]         < return
[ 283.58]        < return
[ 283.59]        > fib(n: uint32): uint32
[ 283.61]         > fib(n: uint32): uint32
[ 283.62]          > fib(n: uint32): uint32
[ 283.63]           > fib(n: uint32): uint32
[ 283.65]           < return
[ 283.66]           > fib(n: uint32): uint32
[ 283.67]           < return
[ 283.68]          < return
[ 283.69]          > fib(n: uint32): uint32
[ 283.70]          < return
[ 283.71]         < return
[ 283.71]         > fib(n: uint32): uint32
[ 283.73]          > fib(n: uint32): uint32
[ 283.74]          < return
[ 283.75]          > fib(n: uint32): uint32
[ 283.76]          < return
[ 283.77]         < return
[ 283.78]        < return
[ 283.79]       < return
[ 283.80]       > fib(n: uint32): uint32
[ 283.81]        > fib(n: uint32): uint32
[ 283.82]         > fib(n: uint32): uint32
[ 283.84]          > fib(n: uint32): uint32
[ 283.85]           > fib(n: uint32): uint32
[ 283.87]           < return
[ 283.87]           > fib(n: uint32): uint32
[ 283.89]           < return
[ 283.89]          < return
[ 283.90]          > fib(n: uint32): uint32
[ 283.92]          < return
[ 283.93]         < return
[ 283.93]         > fib(n: uint32): uint32
[ 283.95]          > fib(n: uint32): uint32
[ 283.96]          < return
[ 283.97]          > fib(n: uint32): uint32
[ 283.98]          < return
[ 283.99]         < return
[ 284.00]        < return
[ 284.01]        > fib(n: uint32): uint32
[ 284.02]         > fib(n: uint32): uint32
[ 284.03]          > fib(n: uint32): uint32
[ 284.05]          < return
[ 284.06]          > fib(n: uint32): uint32
[ 284.07]          < return
[ 284.08]         < return
[ 284.08]         > fib(n: uint32): uint32
[ 284.10]         < return
[ 284.11]        < return
[ 284.11]       < return
[ 284.12]      < return
[ 284.13]     < return
[ 284.14]    < return
[ 284.15]    > fib(n: uint32): uint32
[ 284.16]     > fib(n: uint32): uint32
[ 284.17]      > fib(n: uint32): uint32
[ 284.19]       > fib(n: uint32): uint32
[ 284.20]        > fib(n: uint32): uint32
[ 284.22]         > fib(n: uint32): uint32
[ 284.23]          > fib(n: uint32): uint32
[ 284.24]           > fib(n: uint32): uint32
[ 284.26]            > fib(n: uint32): uint32
[ 284.27]             > fib(n: uint32): uint32
[ 284.28]             < return
[ 284.29]             > fib(n: uint32): uint32
[ 284.31]             < return
[ 284.31]            < return
[ 284.32]            > fib(n: uint32): uint32
[ 284.34]            < return
[ 284.34]           < return
[ 284.35]           > fib(n: uint32): uint32
[ 284.37]            > fib(n: uint32): uint32
[ 284.39]            < return
[ 284.40]            > fib(n: uint32): uint32
[ 284.42]            < return
[ 284.42]           < return
[ 284.43]          < return
[ 284.44]          > fib(n: uint32): uint32
[ 284.45]           > fib(n: uint32): uint32
[ 284.47]            > fib(n: uint32): uint32
[ 284.48]            < return
[ 284.49]            > fib(n: uint32): uint32
[ 284.50]            < return
[ 284.51]           < return
[ 284.52]           > fib(n: uint32): uint32
[ 284.53]           < return
[ 284.54]          < return
[ 284.55]         < return
[ 284.56]         > fib(n: uint32): uint32
[ 284.57]          > fib(n: uint32): uint32
[ 284.58]           > fib(n: uint32): uint32
[ 284.60]            > fib(n: uint32): uint32
[ 284.61]            < return
[ 284.63]            > fib(n: uint32): uint32
[ 284.64]            < return
[ 284.65]           < return
[ 284.66]           > fib(n: uint32): uint32
[ 284.67]           < return
[ 284.68]          < return
[ 284.69]          > fib(n: uint32): uint32
[ 284.70]           > fib(n: uint32): uint32
[ 284.71]           < return
[ 284.72]           > fib(n: uint32): uint32
[ 284.73]           < return
[ 284.74]          < return
[ 284.75]         < return
[ 284.76]        < return
[ 284.77]        > fib(n: uint32): uint32
[ 284.78]         > fib(n: uint32): uint32
[ 284.79]          > fib(n: uint32): uint32
[ 284.81]           > fib(n: uint32): uint32
[ 284.82]            > fib(n: uint32): uint32
[ 284.83]            < return
[ 284.84]            > fib(n: uint32): uint32
[ 284.86]            < return
[ 284.87]           < return
[ 284.87]           > fib(n: uint32): uint32
[ 284.89]           < return
[ 284.89]          < return
[ 284.90]          > fib(n: uint32): uint32
[ 284.92]           > fib(n: uint32): uint32
[ 284.93]           < return
[ 284.94]           > fib(n: uint32): uint32
[ 284.95]           < return
[ 284.96]          < return
[ 284.97]         < return
[ 284.98]         > fib(n: uint32): uint32
[ 284.99]          > fib(n: uint32): uint32
[ 285.00]           > fib(n: uint32): uint32
[ 285.02]           < return
[ 285.02]           > fib(n: uint32): uint32
[ 285.04]           < return
[ 285.05]          < return
[ 285.06]          > fib(n: uint32): uint32
[ 285.07]          < return
[ 285.08]         < return
[ 285.08]        < return
[ 285.09]       < return
[ 285.10]       > fib(n: uint32): uint32
[ 285.11]        > fib(n: uint32): uint32
[ 285.13]         > fib(n: uint32): uint32
[ 285.14]          > fib(n: uint32): uint32
[ 285.16]           > fib(n: uint32): uint32
[ 285.17]            > fib(n: uint32): uint32
[ 285.18]            < return
[ 285.19]            > fib(n: uint32): uint32
[ 285.20]            < return
[ 285.21]           < return
[ 285.22]           > fib(n: uint32): uint32
[ 285.23]           < return
[ 285.24]          < return
[ 285.25]          > fib(n: uint32): uint32
[ 285.26]           > fib(n: uint32): uint32
[ 285.28]           < return
[ 285.29]           > fib(n: uint32): uint32
[ 285.30]           < return
[ 285.31]          < return
[ 285.31]         < return
[ 285.32]         > fib(n: uint32): uint32
[ 285.34]          > fib(n: uint32): uint32
[ 285.35]           > fib(n: uint32): uint32
[ 285.37]           < return
[ 285.37]           > fib(n: uint32): uint32
[ 285.39]           < return
[ 285.39]          < return
[ 285.40]          > fib(n: uint32): uint32
[ 285.42]          < return
[ 285.43]         < return
[ 285.43]        < return
[ 285.44]        > fib(n: uint32): uint32
[ 285.45]         > fib(n: uint32): uint32
[ 285.47]          > fib(n: uint32): uint32
[ 285.48]           > fib(n: uint32): uint32
[ 285.50]           < return
[ 285.51]           > fib(n: uint32): uint32
[ 285.52]           < return
[ 285.53]          < return
[ 285.54]          > fib(n: uint32): uint32
[ 285.55]          < return
[ 285.56]         < return
[ 285.56]         > fib(n: uint32): uint32
[ 285.58]          > fib(n: uint32): uint32
[ 285.59]          < return
[ 285.60]          > fib(n: uint32): uint32
[ 285.62]          < return
[ 285.62]         < return
[ 285.63]        < return
[ 285.64]       < return
[ 285.65]      < return
[ 285.66]      > fib(n: uint32): uint32
[ 285.67]       > fib(n: uint32): uint32
[ 285.69]        > fib(n: uint32): uint32
[ 285.70]         > fib(n: uint32): uint32
[ 285.72]          > fib(n: uint32): uint32
[ 285.73]           > fib(n: uint32): uint32
[ 285.75]            > fib(n: uint32): uint32
[ 285.76]            < return
[ 285.77]            > fib(n: uint32): uint32
[ 285.78]            < return
[ 285.79]           < return
[ 285.80]           > fib(n: uint32): uint32
[ 285.81]           < return
[ 285.82]          < return
[ 285.83]          > fib(n: uint32): uint32
[ 285.84]           > fib(n: uint32): uint32
[ 285.85]           < return
[ 285.86]           > fib(n: uint32): uint32
[ 285.88]           < return
[ 285.88]          < return
[ 285.89]         < return
[ 285.90]         > fib(n: uint32): uint32
[ 285.91]          > fib(n: uint32): uint32
[ 285.93]           > fib(n: uint32): uint32
[ 285.94]           < return
[ 285.95]           > fib(n: uint32): uint32
[ 285.96]           < return
[ 285.97]          < return
[ 285.98]          > fib(n: uint32): uint32
[ 285.99]          < return
[ 286.00]         < return
[ 286.01]        < return
[ 286.02]        > fib(n: uint32): uint32
[ 286.03]         > fib(n: uint32): uint32
[ 286.05]          > fib(n: uint32): uint32
[ 286.06]           > fib(n: uint32): uint32
[ 286.07]           < return
[ 286.08]           > fib(n: uint32): uint32
[ 286.09]           < return
[ 286.10]          < return
[ 286.11]          > fib(n: uint32): uint32
[ 286.12]          < return
[ 286.13]         < return
[ 286.14]         > fib(n: uint32): uint32
[ 286.15]          > fib(n: uint32): uint32
[ 286.17]          < return
[ 286.18]          > fib(n: uint32): uint32
[ 286.19]          < return
[ 286.20]         < return
[ 286.21]        < return
[ 286.21]       < return
[ 286.22]       > fib(n: uint32): uint32
[ 286.24]        > fib(n: uint32): uint32
[ 286.25]         > fib(n: uint32): uint32
[ 286.27]          > fib(n: uint32): uint32
[ 286.28]           > fib(n: uint32): uint32
[ 286.29]           < return
[ 286.30]           > fib(n: uint32): uint32
[ 286.31]           < return
[ 286.32]          < return
[ 286.33]          > fib(n: uint32): uint32
[ 286.34]          < return
[ 286.35]         < return
[ 286.36]         > fib(n: uint32): uint32
[ 286.38]          > fib(n: uint32): uint32
[ 286.39]          < return
[ 286.40]          > fib(n: uint32): uint32
[ 286.42]          < return
[ 286.43]         < return
[ 286.44]        < return
[ 286.45]        > fib(n: uint32): uint32
[ 286.47]         > fib(n: uint32): uint32
[ 286.49]          > fib(n: uint32): uint32
[ 286.51]          < return
[ 286.52]          > fib(n: uint32): uint32
[ 286.54]          < return
[ 286.56]         < return
[ 286.56]         > fib(n: uint32): uint32
[ 286.58]         < return
[ 286.59]        < return
[ 286.60]       < return
[ 286.60]      < return
[ 286.61]     < return
[ 286.62]     > fib(n: uint32): uint32
[ 286.63]      > fib(n: uint32): uint32
[ 286.65]       > fib(n: uint32): uint32
[ 286.66]        > fib(n: uint32): uint32
[ 286.68]         > fib(n: uint32): uint32
[ 286.69]          > fib(n: uint32): uint32
[ 286.70]           > fib(n: uint32): uint32
[ 286.72]            > fib(n: uint32): uint32
[ 286.73]            < return
[ 286.74]            > fib(n: uint32): uint32
[ 286.75]            < return
[ 286.76]           < return
[ 286.77]           > fib(n: uint32): uint32
[ 286.78]           < return
[ 286.79]          < return
[ 286.80]          > fib(n: uint32): uint32
[ 286.81]           > fib(n: uint32): uint32
[ 286.83]           < return
[ 286.83]           > fib(n: uint32): uint32
[ 286.85]           < return
[ 286.86]          < return
[ 286.86]         < return
[ 286.87]         > fib(n: uint32): uint32
[ 286.89]          > fib(n: uint32): uint32
[ 286.90]           > fib(n: uint32): uint32
[ 286.91]           < return
[ 286.92]           > fib(n: uint32): uint32
[ 286.94]           < return
[ 286.95]          < return
[ 286.95]          > fib(n: uint32): uint32
[ 286.97]          < return
[ 286.98]         < return
[ 286.98]        < return
[ 286.99]        > fib(n: uint32): uint32
[ 287.01]         > fib(n: uint32): uint32
[ 287.02]          > fib(n: uint32): uint32
[ 287.04]           > fib(n: uint32): uint32
[ 287.05]           < return
[ 287.06]           > fib(n: uint32): uint32
[ 287.07]           < return
[ 287.08]          < return
[ 287.09]          > fib(n: uint32): uint32
[ 287.10]          < return
[ 287.11]         < return
[ 287.12]         > fib(n: uint32): uint32
[ 287.13]          > fib(n: uint32): uint32
[ 287.14]          < return
[ 287.15]          > fib(n: uint32): uint32
[ 287.17]          < return
[ 287.18]         < return
[ 287.18]        < return
[ 287.19]       < return
[ 287.20]       > fib(n: uint32): uint32
[ 287.21]        > fib(n: uint32): uint32
[ 287.23]         > fib(n: uint32): uint32
[ 287.24]          > fib(n: uint32): uint32
[ 287.26]           > fib(n: uint32): uint32
[ 287.27]           < return
[ 287.28]           > fib(n: uint32): uint32
[ 287.29]           < return
[ 287.30]          < return
[ 287.31]          > fib(n: uint32): uint32
[ 287.32]          < return
[ 287.33]         < return
[ 287.34]         > fib(n: uint32): uint32
[ 287.35]          > fib(n: uint32): uint32
[ 287.36]          < return
[ 287.37]          > fib(n: uint32): uint32
[ 287.39]          < return
[ 287.39]         < return
[ 287.40]        < return
[ 287.41]        > fib(n: uint32): uint32
[ 287.43]         > fib(n: uint32): uint32
[ 287.44]          > fib(n: uint32): uint32
[ 287.45]          < return
[ 287.46]          > fib(n: uint32): uint32
[ 287.47]          < return
[ 287.48]         < return
[ 287.49]         > fib(n: uint32): uint32
[ 287.50]         < return
[ 287.51]        < return
[ 287.52]       < return
[ 287.53]      < return
[ 287.54]      > fib(n: uint32): uint32
[ 287.55]       > fib(n: uint32): uint32
[ 287.56]        > fib(n: uint32): uint32
[ 287.58]         > fib(n: uint32): uint32
[ 287.59]          > fib(n: uint32): uint32
[ 287.61]           > fib(n: uint32): uint32
[ 287.62]           < return
[ 287.63]           > fib(n: uint32): uint32
[ 287.64]           < return
[ 287.65]          < return
[ 287.66]          > fib(n: uint32): uint32
[ 287.67]          < return
[ 287.68]         < return
[ 287.69]         > fib(n: uint32): uint32
[ 287.70]          > fib(n: uint32): uint32
[ 287.71]          < return
[ 287.72]          > fib(n: uint32): uint32
[ 287.74]          < return
[ 287.74]         < return
[ 287.75]        < return
[ 287.76]        > fib(n: uint32): uint32
[ 287.77]         > fib(n: uint32): uint32
[ 287.79]          > fib(n: uint32): uint32
[ 287.80]          < return
[ 287.81]          > fib(n: uint32): uint32
[ 287.82]          < return
[ 287.83]         < return
[ 287.84]         > fib(n: uint32): uint32
[ 287.85]         < return
[ 287.86]        < return
[ 287.87]       < return
[ 287.88]       > fib(n: uint32): uint32
[ 287.89]        > fib(n: uint32): uint32
[ 287.91]         > fib(n: uint32): uint32
[ 287.92]          > fib(n: uint32): uint32
[ 287.93]          < return
[ 287.94]          > fib(n: uint32): uint32
[ 287.95]          < return
[ 287.96]         < return
[ 287.97]         > fib(n: uint32): uint32
[ 287.98]         < return
[ 287.99]        < return
[ 288.00]        > fib(n: uint32): uint32
[ 288.01]         > fib(n: uint32): uint32
[ 288.03]         < return
[ 288.04]         > fib(n: uint32): uint32
[ 288.05]         < return
[ 288.06]        < return
[ 288.07]       < return
[ 288.07]      < return
[ 288.08]     < return
[ 288.09]    < return
[ 288.10]   < return
[ 288.11]   > fib(n: uint32): uint32
[ 288.12]    > fib(n: uint32): uint32
[ 288.13]     > fib(n: uint32): uint32
[ 288.15]      > fib(n: uint32): uint32
[ 288.16]       > fib(n: uint32): uint32
[ 288.18]        > fib(n: uint32): uint32
[ 288.19]         > fib(n: uint32): uint32
[ 288.21]          > fib(n: uint32): uint32
[ 288.22]           > fib(n: uint32): uint32
[ 288.24]            > fib(n: uint32): uint32
[ 288.25]             > fib(n: uint32): uint32
[ 288.26]             < return
[ 288.27]             > fib(n: uint32): uint32
[ 288.29]             < return
[ 288.29]            < return
[ 288.30]            > fib(n: uint32): uint32
[ 288.31]            < return
[ 288.32]           < return
[ 288.33]           > fib(n: uint32): uint32
[ 288.35]            > fib(n: uint32): uint32
[ 288.36]            < return
[ 288.37]            > fib(n: uint32): uint32
[ 288.39]            < return
[ 288.40]           < return
[ 288.41]          < return
[ 288.42]          > fib(n: uint32): uint32
[ 288.45]           > fib(n: uint32): uint32
[ 288.47]            > fib(n: uint32): uint32
[ 288.49]            < return
[ 288.50]            > fib(n: uint32): uint32
[ 288.52]            < return
[ 288.53]           < return
[ 288.54]           > fib(n: uint32): uint32
[ 288.55]           < return
[ 288.56]          < return
[ 288.57]         < return
[ 288.57]         > fib(n: uint32): uint32
[ 288.59]          > fib(n: uint32): uint32
[ 288.60]           > fib(n: uint32): uint32
[ 288.62]            > fib(n: uint32): uint32
[ 288.63]            < return
[ 288.64]            > fib(n: uint32): uint32
[ 288.65]            < return
[ 288.66]           < return
[ 288.67]           > fib(n: uint32): uint32
[ 288.68]           < return
[ 288.69]          < return
[ 288.70]          > fib(n: uint32): uint32
[ 288.71]           > fib(n: uint32): uint32
[ 288.72]           < return
[ 288.73]           > fib(n: uint32): uint32
[ 288.75]           < return
[ 288.75]          < return
[ 288.76]         < return
[ 288.77]        < return
[ 288.78]        > fib(n: uint32): uint32
[ 288.79]         > fib(n: uint32): uint32
[ 288.81]          > fib(n: uint32): uint32
[ 288.82]           > fib(n: uint32): uint32
[ 288.83]            > fib(n: uint32): uint32
[ 288.85]            < return
[ 288.86]            > fib(n: uint32): uint32
[ 288.87]            < return
[ 288.88]           < return
[ 288.89]           > fib(n: uint32): uint32
[ 288.90]           < return
[ 288.91]          < return
[ 288.92]          > fib(n: uint32): uint32
[ 288.93]           > fib(n: uint32): uint32
[ 288.94]           < return
[ 288.95]           > fib(n: uint32): uint32
[ 288.96]           < return
[ 288.97]          < return
[ 288.98]         < return
[ 288.99]         > fib(n: uint32): uint32
[ 289.00]          > fib(n: uint32): uint32
[ 289.02]           > fib(n: uint32): uint32
[ 289.03]           < return
[ 289.04]           > fib(n: uint32): uint32
[ 289.05]           < return
[ 289.06]          < return
[ 289.07]          > fib(n: uint32): uint32
[ 289.08]          < return
[ 289.09]         < return
[ 289.10]        < return
[ 289.10]       < return
[ 289.11]       > fib(n: uint32): uint32
[ 289.13]        > fib(n: uint32): uint32
[ 289.14]         > fib(n: uint32): uint32
[ 289.15]          > fib(n: uint32): uint32
[ 289.17]           > fib(n: uint32): uint32
[ 289.18]            > fib(n: uint32): uint32
[ 289.19]            < return
[ 289.20]            > fib(n: uint32): uint32
[ 289.22]            < return
[ 289.23]           < return
[ 289.23]           > fib(n: uint32): uint32
[ 289.25]           < return
[ 289.25]          < return
[ 289.26]          > fib(n: uint32): uint32
[ 289.28]           > fib(n: uint32): uint32
[ 289.29]           < return
[ 289.30]           > fib(n: uint32): uint32
[ 289.31]           < return
[ 289.32]          < return
[ 289.33]         < return
[ 289.34]         > fib(n: uint32): uint32
[ 289.35]          > fib(n: uint32): uint32
[ 289.36]           > fib(n: uint32): uint32
[ 289.38]           < return
[ 289.38]           > fib(n: uint32): uint32
[ 289.40]           < return
[ 289.41]          < return
[ 289.42]          > fib(n: uint32): uint32
[ 289.43]          < return
[ 289.44]         < return
[ 289.44]        < return
[ 289.45]        > fib(n: uint32): uint32
[ 289.47]         > fib(n: uint32): uint32
[ 289.48]          > fib(n: uint32): uint32
[ 289.50]           > fib(n: uint32): uint32
[ 289.51]           < return
[ 289.52]           > fib(n: uint32): uint32
[ 289.54]           < return
[ 289.55]          < return
[ 289.56]          > fib(n: uint32): uint32
[ 289.57]          < return
[ 289.58]         < return
[ 289.59]         > fib(n: uint32): uint32
[ 289.60]          > fib(n: uint32): uint32
[ 289.61]          < return
[ 289.62]          > fib(n: uint32): uint32
[ 289.64]          < return
[ 289.64]         < return
[ 289.65]        < return
[ 289.66]       < return
[ 289.67]      < return
[ 289.68]      > fib(n: uint32): uint32
[ 289.69]       > fib(n: uint32): uint32
[ 289.71]        > fib(n: uint32): uint32
[ 289.72]         > fib(n: uint32): uint32
[ 289.73]          > fib(n: uint32): uint32
[ 289.75]           > fib(n: uint32): uint32
[ 289.76]            > fib(n: uint32): uint32
[ 289.77]            < return
[ 289.78]            > fib(n: uint32): uint32
[ 289.80]            < return
[ 289.80]           < return
[ 289.81]           > fib(n: uint32): uint32
[ 289.82]           < return
[ 289.83]          < return
[ 289.84]          > fib(n: uint32): uint32
[ 289.86]           > fib(n: uint32): uint32
[ 289.87]           < return
[ 289.88]           > fib(n: uint32): uint32
[ 289.89]           < return
[ 289.90]          < return
[ 289.91]         < return
[ 289.92]         > fib(n: uint32): uint32
[ 289.93]          > fib(n: uint32): uint32
[ 289.94]           > fib(n: uint32): uint32
[ 289.96]           < return
[ 289.97]           > fib(n: uint32): uint32
[ 289.98]           < return
[ 289.99]          < return
[ 290.00]          > fib(n: uint32): uint32
[ 290.01]          < return
[ 290.02]         < return
[ 290.02]        < return
[ 290.03]        > fib(n: uint32): uint32
[ 290.05]         > fib(n: uint32): uint32
[ 290.06]          > fib(n: uint32): uint32
[ 290.07]           > fib(n: uint32): uint32
[ 290.09]           < return
[ 290.10]           > fib(n: uint32): uint32
[ 290.11]           < return
[ 290.12]          < return
[ 290.13]          > fib(n: uint32): uint32
[ 290.14]          < return
[ 290.15]         < return
[ 290.16]         > fib(n: uint32): uint32
[ 290.17]          > fib(n: uint32): uint32
[ 290.18]          < return
[ 290.19]          > fib(n: uint32): uint32
[ 290.21]          < return
[ 290.22]         < return
[ 290.22]        < return
[ 290.23]       < return
[ 290.24]       > fib(n: uint32): uint32
[ 290.25]        > fib(n: uint32): uint32
[ 290.27]         > fib(n: uint32): uint32
[ 290.28]          > fib(n: uint32): uint32
[ 290.30]           > fib(n: uint32): uint32
[ 290.31]           < return
[ 290.32]           > fib(n: uint32): uint32
[ 290.33]           < return
[ 290.34]          < return
[ 290.35]          > fib(n: uint32): uint32
[ 290.36]          < return
[ 290.37]         < return
[ 290.38]         > fib(n: uint32): uint32
[ 290.39]          > fib(n: uint32): uint32
[ 290.40]          < return
[ 290.42]          > fib(n: uint32): uint32
[ 290.43]          < return
[ 290.44]         < return
[ 290.44]        < return
[ 290.45]        > fib(n: uint32): uint32
[ 290.47]         > fib(n: uint32): uint32
[ 290.49]          > fib(n: uint32): uint32
[ 290.50]          < return
[ 290.51]          > fib(n: uint32): uint32
[ 290.52]          < return
[ 290.53]         < return
[ 290.54]         > fib(n: uint32): uint32
[ 290.55]         < return
[ 290.56]        < return
[ 290.56]       < return
[ 290.57]      < return
[ 290.58]     < return
[ 290.59]     > fib(n: uint32): uint32
[ 290.60]      > fib(n: uint32): uint32
[ 290.62]       > fib(n: uint32): uint32
[ 290.63]        > fib(n: uint32): uint32
[ 290.65]         > fib(n: uint32): uint32
[ 290.66]          > fib(n: uint32): uint32
[ 290.68]           > fib(n: uint32): uint32
[ 290.69]            > fib(n: uint32): uint32
[ 290.70]            < return
[ 290.71]            > fib(n: uint32): uint32
[ 290.72]            < return
[ 290.73]           < return
[ 290.74]           > fib(n: uint32): uint32
[ 290.75]           < return
[ 290.76]          < return
[ 290.77]          > fib(n: uint32): uint32
[ 290.79]           > fib(n: uint32): uint32
[ 290.80]           < return
[ 290.81]           > fib(n: uint32): uint32
[ 290.82]           < return
[ 290.83]          < return
[ 290.84]         < return
[ 290.85]         > fib(n: uint32): uint32
[ 290.86]          > fib(n: uint32): uint32
[ 290.88]           > fib(n: uint32): uint32
[ 290.89]           < return
[ 290.90]           > fib(n: uint32): uint32
[ 290.91]           < return
[ 290.92]          < return
[ 290.93]          > fib(n: uint32): uint32
[ 290.94]          < return
[ 290.95]         < return
[ 290.96]        < return
[ 290.96]        > fib(n: uint32): uint32
[ 290.98]         > fib(n: uint32): uint32
[ 290.99]          > fib(n: uint32): uint32
[ 291.01]           > fib(n: uint32): uint32
[ 291.02]           < return
[ 291.03]           > fib(n: uint32): uint32
[ 291.04]           < return
[ 291.05]          < return
[ 291.06]          > fib(n: uint32): uint32
[ 291.07]          < return
[ 291.08]         < return
[ 291.09]         > fib(n: uint32): uint32
[ 291.10]          > fib(n: uint32): uint32
[ 291.12]          < return
[ 291.12]          > fib(n: uint32): uint32
[ 291.14]          < return
[ 291.15]         < return
[ 291.15]        < return
[ 291.16]       < return
[ 291.17]       > fib(n: uint32): uint32
[ 291.18]        > fib(n: uint32): uint32
[ 291.20]         > fib(n: uint32): uint32
[ 291.21]          > fib(n: uint32): uint32
[ 291.23]           > fib(n: uint32): uint32
[ 291.24]           < return
[ 291.25]           > fib(n: uint32): uint32
[ 291.26]           < return
[ 291.27]          < return
[ 291.28]          > fib(n: uint32): uint32
[ 291.29]          < return
[ 291.30]         < return
[ 291.31]         > fib(n: uint32): uint32
[ 291.32]          > fib(n: uint32): uint32
[ 291.34]          < return
[ 291.35]          > fib(n: uint32): uint32
[ 291.36]          < return
[ 291.37]         < return
[ 291.37]        < return
[ 291.38]        > fib(n: uint32): uint32
[ 291.40]         > fib(n: uint32): uint32
[ 291.41]          > fib(n: uint32): uint32
[ 291.42]          < return
[ 291.43]          > fib(n: uint32): uint32
[ 291.44]          < return
[ 291.45]         < return
[ 291.46]         > fib(n: uint32): uint32
[ 291.48]         < return
[ 291.48]        < return
[ 291.49]       < return
[ 291.50]      < return
[ 291.51]      > fib(n: uint32): uint32
[ 291.52]       > fib(n: uint32): uint32
[ 291.54]        > fib(n: uint32): uint32
[ 291.55]         > fib(n: uint32): uint32
[ 291.56]          > fib(n: uint32): uint32
[ 291.58]           > fib(n: uint32): uint32
[ 291.59]           < return
[ 291.60]           > fib(n: uint32): uint32
[ 291.61]           < return
[ 291.62]          < return
[ 291.63]          > fib(n: uint32): uint32
[ 291.64]          < return
[ 291.65]         < return
[ 291.66]         > fib(n: uint32): uint32
[ 291.68]          > fib(n: uint32): uint32
[ 291.69]          < return
[ 291.70]          > fib(n: uint32): uint32
[ 291.71]          < return
[ 291.72]         < return
[ 291.73]        < return
[ 291.73]        > fib(n: uint32): uint32
[ 291.75]         > fib(n: uint32): uint32
[ 291.76]          > fib(n: uint32): uint32
[ 291.78]          < return
[ 291.79]          > fib(n: uint32): uint32
[ 291.80]          < return
[ 291.81]         < return
[ 291.81]         > fib(n: uint32): uint32
[ 291.83]         < return
[ 291.84]        < return
[ 291.84]       < return
[ 291.85]       > fib(n: uint32): uint32
[ 291.87]        > fib(n: uint32): uint32
[ 291.88]         > fib(n: uint32): uint32
[ 291.89]          > fib(n: uint32): uint32
[ 291.91]          < return
[ 291.92]          > fib(n: uint32): uint32
[ 291.93]          < return
[ 291.94]         < return
[ 291.95]         > fib(n: uint32): uint32
[ 291.96]         < return
[ 291.97]        < return
[ 291.98]        > fib(n: uint32): uint32
[ 291.99]         > fib(n: uint32): uint32
[ 292.00]         < return
[ 292.01]         > fib(n: uint32): uint32
[ 292.03]         < return
[ 292.04]        < return
[ 292.05]       < return
[ 292.05]      < return
[ 292.06]     < return
[ 292.07]    < return
[ 292.08]    > fib(n: uint32): uint32
[ 292.09]     > fib(n: uint32): uint32
[ 292.11]      > fib(n: uint32): uint32
[ 292.12]       > fib(n: uint32): uint32
[ 292.13]        > fib(n: uint32): uint32
[ 292.15]         > fib(n: uint32): uint32
[ 292.16]          > fib(n: uint32): uint32
[ 292.18]           > fib(n: uint32): uint32
[ 292.19]            > fib(n: uint32): uint32
[ 292.20]            < return
[ 292.21]            > fib(n: uint32): uint32
[ 292.23]            < return
[ 292.23]           < return
[ 292.24]           > fib(n: uint32): uint32
[ 292.25]           < return
[ 292.26]          < return
[ 292.27]          > fib(n: uint32): uint32
[ 292.29]           > fib(n: uint32): uint32
[ 292.30]           < return
[ 292.31]           > fib(n: uint32): uint32
[ 292.32]           < return
[ 292.33]          < return
[ 292.34]         < return
[ 292.35]         > fib(n: uint32): uint32
[ 292.36]          > fib(n: uint32): uint32
[ 292.38]           > fib(n: uint32): uint32
[ 292.40]           < return
[ 292.41]           > fib(n: uint32): uint32
[ 292.42]           < return
[ 292.43]          < return
[ 292.44]          > fib(n: uint32): uint32
[ 292.45]          < return
[ 292.46]         < return
[ 292.46]        < return
[ 292.47]        > fib(n: uint32): uint32
[ 292.49]         > fib(n: uint32): uint32
[ 292.50]          > fib(n: uint32): uint32
[ 292.52]           > fib(n: uint32): uint32
[ 292.53]           < return
[ 292.54]           > fib(n: uint32): uint32
[ 292.55]           < return
[ 292.56]          < return
[ 292.57]          > fib(n: uint32): uint32
[ 292.58]          < return
[ 292.59]         < return
[ 292.60]         > fib(n: uint32): uint32
[ 292.61]          > fib(n: uint32): uint32
[ 292.62]          < return
[ 292.63]          > fib(n: uint32): uint32
[ 292.64]          < return
[ 292.65]         < return
[ 292.66]        < return
[ 292.67]       < return
[ 292.68]       > fib(n: uint32): uint32
[ 292.69]        > fib(n: uint32): uint32
[ 292.71]         > fib(n: uint32): uint32
[ 292.72]          > fib(n: uint32): uint32
[ 292.74]           > fib(n: uint32): uint32
[ 292.75]           < return
[ 292.76]           > fib(n: uint32): uint32
[ 292.77]           < return
[ 292.78]          < return
[ 292.79]          > fib(n: uint32): uint32
[ 292.80]          < return
[ 292.81]         < return
[ 292.81]         > fib(n: uint32): uint32
[ 292.83]          > fib(n: uint32): uint32
[ 292.84]          < return
[ 292.85]          > fib(n: uint32): uint32
[ 292.86]          < return
[ 292.87]         < return
[ 292.88]        < return
[ 292.89]        > fib(n: uint32): uint32
[ 292.90]         > fib(n: uint32): uint32
[ 292.92]          > fib(n: uint32): uint32
[ 292.93]          < return
[ 292.94]          > fib(n: uint32): uint32
[ 292.95]          < return
[ 292.96]         < return
[ 292.97]         > fib(n: uint32): uint32
[ 292.98]         < return
[ 292.99]        < return
[ 293.00]       < return
[ 293.00]      < return
[ 293.01]      > fib(n: uint32): uint32
[ 293.03]       > fib(n: uint32): uint32
[ 293.04]        > fib(n: uint32): uint32
[ 293.05]         > fib(n: uint32): uint32
[ 293.07]          > fib(n: uint32): uint32
[ 293.08]           > fib(n: uint32): uint32
[ 293.09]           < return
[ 293.10]           > fib(n: uint32): uint32
[ 293.12]           < return
[ 293.12]          < return
[ 293.13]          > fib(n: uint32): uint32
[ 293.14]          < return
[ 293.15]         < return
[ 293.16]         > fib(n: uint32): uint32
[ 293.18]          > fib(n: uint32): uint32
[ 293.19]          < return
[ 293.20]          > fib(n: uint32): uint32
[ 293.21]          < return
[ 293.22]         < return
[ 293.23]        < return
[ 293.24]        > fib(n: uint32): uint32
[ 293.25]         > fib(n: uint32): uint32
[ 293.26]          > fib(n: uint32): uint32
[ 293.28]          < return
[ 293.29]          > fib(n: uint32): uint32
[ 293.30]          < return
[ 293.31]         < return
[ 293.32]         > fib(n: uint32): uint32
[ 293.33]         < return
[ 293.34]        < return
[ 293.35]       < return
[ 293.36]       > fib(n: uint32): uint32
[ 293.37]        > fib(n: uint32): uint32
[ 293.39]         > fib(n: uint32): uint32
[ 293.40]          > fib(n: uint32): uint32
[ 293.41]          < return
[ 293.42]          > fib(n: uint32): uint32
[ 293.43]          < return
[ 293.44]         < return
[ 293.45]         > fib(n: uint32): uint32
[ 293.46]         < return
[ 293.47]        < return
[ 293.48]        > fib(n: uint32): uint32
[ 293.50]         > fib(n: uint32): uint32
[ 293.51]         < return
[ 293.52]         > fib(n: uint32): uint32
[ 293.53]         < return
[ 293.54]        < return
[ 293.55]       < return
[ 293.56]      < return
[ 293.56]     < return
[ 293.57]     > fib(n: uint32): uint32
[ 293.59]      > fib(n: uint32): uint32
[ 293.60]       > fib(n: uint32): uint32
[ 293.62]        > fib(n: uint32): uint32
[ 293.63]         > fib(n: uint32): uint32
[ 293.64]          > fib(n: uint32): uint32
[ 293.66]           > fib(n: uint32): uint32
[ 293.67]           < return
[ 293.68]           > fib(n: uint32): uint32
[ 293.69]           < return
[ 293.70]          < return
[ 293.71]          > fib(n: uint32): uint32
[ 293.72]          < return
[ 293.73]         < return
[ 293.74]         > fib(n: uint32): uint32
[ 293.75]          > fib(n: uint32): uint32
[ 293.77]          < return
[ 293.78]          > fib(n: uint32): uint32
[ 293.79]          < return
[ 293.80]         < return
[ 293.81]        < return
[ 293.81]        > fib(n: uint32): uint32
[ 293.83]         > fib(n: uint32): uint32
[ 293.84]          > fib(n: uint32): uint32
[ 293.86]          < return
[ 293.87]          > fib(n: uint32): uint32
[ 293.88]          < return
[ 293.89]         < return
[ 293.89]         > fib(n: uint32): uint32
[ 293.91]         < return
[ 293.92]        < return
[ 293.92]       < return
[ 293.93]       > fib(n: uint32): uint32
[ 293.95]        > fib(n: uint32): uint32
[ 293.96]         > fib(n: uint32): uint32
[ 293.98]          > fib(n: uint32): uint32
[ 293.99]          < return
[ 294.00]          > fib(n: uint32): uint32
[ 294.01]          < return
[ 294.02]         < return
[ 294.03]         > fib(n: uint32): uint32
[ 294.04]         < return
[ 294.05]        < return
[ 294.06]        > fib(n: uint32): uint32
[ 294.07]         > fib(n: uint32): uint32
[ 294.08]         < return
[ 294.09]         > fib(n: uint32): uint32
[ 294.10]         < return
[ 294.11]        < return
[ 294.12]       < return
[ 294.13]      < return
[ 294.14]      > fib(n: uint32): uint32
[ 294.15]       > fib(n: uint32): uint32
[ 294.17]        > fib(n: uint32): uint32
[ 294.18]         > fib(n: uint32): uint32
[ 294.19]          > fib(n: uint32): uint32
[ 294.21]          < return
[ 294.22]          > fib(n: uint32): uint32
[ 294.23]          < return
[ 294.24]         < return
[ 294.25]         > fib(n: uint32): uint32
[ 294.26]         < return
[ 294.27]        < return
[ 294.28]        > fib(n: uint32): uint32
[ 294.29]         > fib(n: uint32): uint32
[ 294.30]         < return
[ 294.31]         > fib(n: uint32): uint32
[ 294.32]         < return
[ 294.33]        < return
[ 294.34]       < return
[ 294.35]       > fib(n: uint32): uint32
[ 294.37]        > fib(n: uint32): uint32
[ 294.38]         > fib(n: uint32): uint32
[ 294.39]         < return
[ 294.40]         > fib(n: uint32): uint32
[ 294.41]         < return
[ 294.42]        < return
[ 294.43]        > fib(n: uint32): uint32
[ 294.44]        < return
[ 294.45]       < return
[ 294.46]      < return
[ 294.47]     < return
[ 294.48]    < return
[ 294.48]   < return
[ 294.49]  < return
[ 294.55]  > typename.name(type: typename): .cstr
[ 294.57]  < return
[ 294.59]  > typename.file(type: typename): .cstr
[ 294.61]  < return
[ 294.62]  > typename.line(type: typename): int32
[ 294.64]  < return
[ 294.65]  > typename.base(type: typename): typename
[ 294.66]  < return
[ 294.67]  > typename.name(type: typename): .cstr
[ 294.69]  < return
[ 294.71]  > typename.file(type: typename): .cstr
[ 294.73]  < return
[ 294.74]  > typename.line(type: typename): int32
[ 294.76]  < return
[ 294.77]  > typename.base(type: typename): typename
[ 294.78]  < return
[ 294.80]  > typename.base(type: typename): typename
[ 294.82]  < return
[ 294.88]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 294.89]  < return
[ 294.91]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 294.92]  < return
[ 294.93]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 294.95]  < return
[ 294.96]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 294.98]  < return
[ 295.00]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.01]  < return
[ 295.02]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.04]  < return
[ 295.05]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 295.07]  < return
[ 295.08]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 295.09]  < return
[ 295.11]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 295.12]  < return
[ 295.13]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.15]  < return
[ 295.16]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.18]  < return
[ 295.19]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.20]  < return
[ 295.22]  > float64.sin(x: float64): float64
[ 295.25]  < return
[ 295.26]  > float64.cos(x: float64): float64
[ 295.28]  < return
[ 295.29]  > float64.tan(x: float64): float64
[ 295.31]  < return
[ 295.32]  > float64.log(x: float64): float64
[ 295.34]  < return
[ 295.35]  > float64.exp(x: float64): float64
[ 295.37]  < return
[ 295.38]  > float64.pow(x: float64, y: float64): float64
[ 295.40]  < return
[ 295.41]  > float64.sqrt(x: float64): float64
[ 295.43]  < return
[ 295.44]  > float64.atan2(x: float64, y: float64): float64
[ 295.46]  < return
[ 295.47]  > float32.sin(x: float32): float32
[ 295.49]  < return
[ 295.50]  > float32.cos(x: float32): float32
[ 295.51]  < return
[ 295.52]  > float32.tan(x: float32): float32
[ 295.54]  < return
[ 295.56]  > float32.log(x: float32): float32
[ 295.57]  < return
[ 295.58]  > float32.exp(x: float32): float32
[ 295.60]  < return
[ 295.61]  > float32.pow(x: float32, y: float32): float32
[ 295.62]  < return
[ 295.64]  > float32.sqrt(x: float32): float32
[ 295.65]  < return
[ 295.66]  > float32.atan2(x: float32, y: float32): float32
[ 295.68]  < return
[ 295.69]  > uint32.pop(value: int32): int32
[ 295.71]  < return
[ 295.72]  > uint32.swap(value: int32): int32
[ 295.73]  < return
[ 295.74]  > uint32.bsr(value: int32): int32
[ 295.76]  < return
[ 295.77]  > uint32.bsf(value: int32): int32
[ 295.79]  < return
[ 295.80]  > uint32.hib(value: int32): int32
[ 295.81]  < return
[ 295.82]  > uint32.lob(value: int32): int32
[ 295.84]  < return
[ 295.85]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 295.87]  < return
[ 295.88]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 295.89]  < return
[ 295.90]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 295.92]  < return
[ 295.93]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 295.95]  < return
[ 295.96]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 295.98]  < return
[ 295.99]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 296.01]  < return
[ 296.02]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 296.03]  < return
[ 296.05]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 296.06]  < return
[ 296.08]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 296.09]   > noError(ptr: pointer): void
[ 296.11]   < return
[ 296.12]   > halt(): void
[ 296.12]   < return
[ 296.13]  < return
[ 296.14]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 296.16]  < return
[ 296.17]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 296.18]   > stackOverflow(ptr: pointer): void
[ 296.20]    > stackOverflow(ptr: pointer): void
[ 296.21]     > stackOverflow(ptr: pointer): void
[ 296.23]      > stackOverflow(ptr: pointer): void
[ 296.24]       > stackOverflow(ptr: pointer): void
[ 296.26]        > stackOverflow(ptr: pointer): void
[ 296.27]         > stackOverflow(ptr: pointer): void
[ 296.28]          > stackOverflow(ptr: pointer): void
[ 296.30]           > stackOverflow(ptr: pointer): void
[ 296.31]            > stackOverflow(ptr: pointer): void
[ 296.32]             > stackOverflow(ptr: pointer): void
[ 296.34]              > stackOverflow(ptr: pointer): void
[ 296.35]               > stackOverflow(ptr: pointer): void
[ 296.37]                > stackOverflow(ptr: pointer): void
[ 296.39]                 > stackOverflow(ptr: pointer): void
[ 296.41]                  > stackOverflow(ptr: pointer): void
[ 296.42]                   > stackOverflow(ptr: pointer): void
[ 296.44]                    > stackOverflow(ptr: pointer): void
[ 296.45]                     > stackOverflow(ptr: pointer): void
[ 296.46]                      > stackOverflow(ptr: pointer): void
[ 296.48]                       > stackOverflow(ptr: pointer): void
[ 296.49]                        > stackOverflow(ptr: pointer): void
[ 296.50]                         > stackOverflow(ptr: pointer): void
[ 296.52]                          > stackOverflow(ptr: pointer): void
[ 296.53]                           > stackOverflow(ptr: pointer): void
[ 296.54]                            > stackOverflow(ptr: pointer): void
[ 296.56]                             > stackOverflow(ptr: pointer): void
[ 296.57]                              > stackOverflow(ptr: pointer): void
[ 296.58]                               > stackOverflow(ptr: pointer): void
[ 296.60]                                > stackOverflow(ptr: pointer): void
[ 296.61]                                 > stackOverflow(ptr: pointer): void
[ 296.62]                                  > stackOverflow(ptr: pointer): void
[ 296.64]                                   > stackOverflow(ptr: pointer): void
[ 296.65]                                    > stackOverflow(ptr: pointer): void
[ 296.66]                                     > stackOverflow(ptr: pointer): void
[ 296.68]                                      > stackOverflow(ptr: pointer): void
[ 296.69]                                       > stackOverflow(ptr: pointer): void
[ 296.70]                                        > stackOverflow(ptr: pointer): void
[ 296.72]                                         > stackOverflow(ptr: pointer): void
[ 296.73]                                          > stackOverflow(ptr: pointer): void
[ 296.74]                                           > stackOverflow(ptr: pointer): void
[ 296.76]                                            > stackOverflow(ptr: pointer): void
[ 296.77]                                             > stackOverflow(ptr: pointer): void
[ 296.78]                                              > stackOverflow(ptr: pointer): void
[ 296.80]                                               > stackOverflow(ptr: pointer): void
[ 296.81]                                                > stackOverflow(ptr: pointer): void
[ 296.82]                                                 > stackOverflow(ptr: pointer): void
[ 296.84]                                                  > stackOverflow(ptr: pointer): void
[ 296.85]                                                   > stackOverflow(ptr: pointer): void
[ 296.86]                                                    > stackOverflow(ptr: pointer): void
[ 296.88]                                                     > stackOverflow(ptr: pointer): void
[ 296.89]                                                      > stackOverflow(ptr: pointer): void
[ 296.90]                                                       > stackOverflow(ptr: pointer): void
[ 296.92]                                                        > stackOverflow(ptr: pointer): void
[ 296.93]                                                         > stackOverflow(ptr: pointer): void
[ 296.94]                                                          > stackOverflow(ptr: pointer): void
[ 296.96]                                                           > stackOverflow(ptr: pointer): void
[ 296.98]                                                            > stackOverflow(ptr: pointer): void
[ 296.99]                                                             > stackOverflow(ptr: pointer): void
[ 297.00]                                                              > stackOverflow(ptr: pointer): void
[ 297.02]                                                               > stackOverflow(ptr: pointer): void
[ 297.03]                                                                > stackOverflow(ptr: pointer): void
[ 297.04]                                                                 > stackOverflow(ptr: pointer): void
[ 297.06]                                                                  > stackOverflow(ptr: pointer): void
[ 297.07]                                                                  < return
[ 297.08]                                                                 < return
[ 297.08]                                                                < return
[ 297.09]                                                               < return
[ 297.10]                                                              < return
[ 297.10]                                                             < return
[ 297.11]                                                            < return
[ 297.12]                                                           < return
[ 297.12]                                                          < return
[ 297.13]                                                         < return
[ 297.14]                                                        < return
[ 297.14]                                                       < return
[ 297.15]                                                      < return
[ 297.16]                                                     < return
[ 297.16]                                                    < return
[ 297.17]                                                   < return
[ 297.18]                                                  < return
[ 297.18]                                                 < return
[ 297.19]                                                < return
[ 297.20]                                               < return
[ 297.20]                                              < return
[ 297.21]                                             < return
[ 297.22]                                            < return
[ 297.23]                                           < return
[ 297.23]                                          < return
[ 297.24]                                         < return
[ 297.25]                                        < return
[ 297.25]                                       < return
[ 297.26]                                      < return
[ 297.26]                                     < return
[ 297.27]                                    < return
[ 297.28]                                   < return
[ 297.29]                                  < return
[ 297.29]                                 < return
[ 297.30]                                < return
[ 297.31]                               < return
[ 297.31]                              < return
[ 297.32]                             < return
[ 297.32]                            < return
[ 297.33]                           < return
[ 297.34]                          < return
[ 297.35]                         < return
[ 297.35]                        < return
[ 297.36]                       < return
[ 297.37]                      < return
[ 297.37]                     < return
[ 297.38]                    < return
[ 297.38]                   < return
[ 297.39]                  < return
[ 297.40]                 < return
[ 297.40]                < return
[ 297.41]               < return
[ 297.42]              < return
[ 297.43]             < return
[ 297.43]            < return
[ 297.44]           < return
[ 297.44]          < return
[ 297.45]         < return
[ 297.46]        < return
[ 297.46]       < return
[ 297.48]      < return
[ 297.48]     < return
[ 297.49]    < return
[ 297.50]   < return
[ 297.50]  < return
[ 297.51]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 297.52]   > divisionByZero(args: pointer): void
[ 297.54]   < return
[ 297.55]  < return
[ 297.56]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 297.57]   > invalidInstruction(args: pointer): void
[ 297.58]   < return
[ 297.59]  < return
[ 297.60]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 297.61]   > invalidMemoryAccess(args: pointer): void
[ 297.63]   < return
[ 297.63]  < return
[ 297.64]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 297.65]   > abortExecution(args: pointer): void
[ 297.68]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 297.77]    < return
[ 297.78]   < return
[ 297.79]  < return
[ 299.38]  > Math.floor(x: float64): float64
[ 299.39]   > Math.modf(x: float64, intPart: float64): float64
[ 299.40]   < return
[ 299.41]  < return
[ 299.43]  > Math.floor(x: float64): float64
[ 299.43]   > Math.modf(x: float64, intPart: float64): float64
[ 299.44]   < return
[ 299.45]  < return
[ 299.47]  > Math.floor(x: float64): float64
[ 299.47]   > Math.modf(x: float64, intPart: float64): float64
[ 299.49]   < return
[ 299.49]  < return
[ 299.51]  > Math.floor(x: float64): float64
[ 299.51]   > Math.modf(x: float64, intPart: float64): float64
[ 299.52]    > Math.modf(x: float64, intPart: float64): float64
[ 299.53]    < return
[ 299.54]   < return
[ 299.55]  < return
[ 299.56]  > Math.floor(x: float64): float64
[ 299.57]   > Math.modf(x: float64, intPart: float64): float64
[ 299.58]    > Math.modf(x: float64, intPart: float64): float64
[ 299.59]    < return
[ 299.60]   < return
[ 299.61]  < return
[ 299.62]  > Math.floor(x: float64): float64
[ 299.63]   > Math.modf(x: float64, intPart: float64): float64
[ 299.64]    > Math.modf(x: float64, intPart: float64): float64
[ 299.65]    < return
[ 299.66]   < return
[ 299.66]  < return
[ 299.76]  > Math.abs(x: float64): float64
[ 299.77]  < return
[ 299.79]  > Math.abs(x: float64): float64
[ 299.80]  < return
[ 299.81]  > Math.abs(x: float64): float64
[ 299.82]  < return
[ 299.83]  > Math.abs(x: float32): float32
[ 299.84]  < return
[ 299.86]  > Math.abs(x: float32): float32
[ 299.87]  < return
[ 299.88]  > Math.abs(x: float32): float32
[ 299.89]  < return
[ 299.91]  > Math.min(a: float32, b: float32): float32
[ 299.92]  < return
[ 299.93]  > Math.max(a: float32, b: float32): float32
[ 299.94]  < return
[ 299.96]  > Math.min(a: float64, b: float64): float64
[ 299.97]  < return
[ 299.98]  > Math.max(a: float64, b: float64): float64
[ 299.99]  < return
[ 300.01]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 300.02]  < return
[ 300.04]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 300.05]  < return
[ 300.10]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 300.11]  < return
[ 300.15]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 300.16]  < return
[ 300.19]  > Math.min(data: float64[]): float64
[ 300.20]  < return
[ 300.23]  > Math.min(data: float64[]): float64
[ 300.27]  < return
[ 300.29]  > Math.max(data: float64[]): float64
[ 300.30]  < return
[ 300.33]  > Math.max(data: float64[]): float64
[ 300.38]  < return
[ 300.40]  > Math.sum(data: float64[]): float64
[ 300.42]  < return
[ 300.44]  > Math.sum(data: float64[]): float64
[ 300.46]  < return
[ 300.48]  > Math.sum(data: float64[]): float64
[ 300.50]  < return
[ 300.53]  > Math.sum(data: float64[]): float64
[ 300.58]  < return
[ 300.60]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 300.62]  < return
[ 300.69]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 300.72]  < return
[ 300.75]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 300.80]  < return
[ 300.82]  > Math.sinCos(arg: float64, quad: int32): float64
[ 300.85]  < return
[ 300.87]  > Math.abs(x: float64): float64
[ 300.87]  < return
[ 300.88]  > Math.sinCos(arg: float64, quad: int32): float64
[ 300.92]  < return
[ 300.93]  > Math.tan(arg: float64): float64
[ 300.95]   > Math.modf(x: float64, intPart: float64): float64
[ 300.96]   < return
[ 300.99]  < return
[ 301.00]  > Math.sinh(x: float64): float64
[ 301.02]   > float64.exp(x: float64): float64
[ 301.03]   < return
[ 301.04]   > float64.exp(x: float64): float64
[ 301.05]   < return
[ 301.06]  < return
[ 301.08]  > Math.cosh(x: float64): float64
[ 301.09]   > float64.exp(x: float64): float64
[ 301.11]   < return
[ 301.11]   > float64.exp(x: float64): float64
[ 301.13]   < return
[ 301.13]  < return
[ 301.15]  > Math.asin(x: float64): float64
[ 301.17]   > float64.sqrt(x: float64): float64
[ 301.18]   < return
[ 301.19]   > float64.atan2(x: float64, y: float64): float64
[ 301.20]   < return
[ 301.21]  < return
[ 301.23]  > Math.asin(x: float64): float64
[ 301.25]   > float64.sqrt(x: float64): float64
[ 301.26]   < return
[ 301.27]   > float64.atan2(x: float64, y: float64): float64
[ 301.28]   < return
[ 301.29]  < return
[ 301.31]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 301.32]  < return
[ 301.35]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 301.36]  < return
[ 301.38]  > Math.absMod(val: float64, mod: float64): float64
[ 301.39]  < return
[ 301.40]  > Math.absMod(val: float64, mod: float64): float64
[ 301.41]  < return
[ 301.43]  > Math.absMod(val: float64, mod: float64): float64
[ 301.44]  < return
[ 301.45]  > Math.absMod(val: float64, mod: float64): float64
[ 301.46]  < return
[ 301.48]  > Math.absMod(val: float64, mod: float64): float64
[ 301.49]  < return
[ 301.50]  > Math.absMod(val: float64, mod: float64): float64
[ 301.51]  < return
[ 301.53]  > Math.absMod(val: float64, mod: float64): float64
[ 301.54]  < return
[ 301.55]  > Math.absMod(val: float64, mod: float64): float64
[ 301.56]  < return
[ 301.58]  > Math.absMod(val: float64, mod: float64): float64
[ 301.59]  < return
[ 301.60]  > Math.absMod(val: float64, mod: float64): float64
[ 301.61]  < return
[ 301.63]  > Math.absMod(val: float64, mod: float64): float64
[ 301.64]  < return
[ 301.65]  > Math.absMod(val: float32, mod: float32): float32
[ 301.66]  < return
[ 301.68]  > Math.absMod(val: float32, mod: float32): float32
[ 301.69]  < return
[ 301.70]  > Math.absMod(val: float32, mod: float32): float32
[ 301.71]  < return
[ 301.73]  > Math.absMod(val: float32, mod: float32): float32
[ 301.74]  < return
[ 301.75]  > Math.absMod(val: float32, mod: float32): float32
[ 301.76]  < return
[ 301.78]  > Math.absMod(val: float32, mod: float32): float32
[ 301.79]  < return
[ 301.80]  > Math.absMod(val: float32, mod: float32): float32
[ 301.81]  < return
[ 301.83]  > Math.absMod(val: float32, mod: float32): float32
[ 301.84]  < return
[ 301.85]  > Math.absMod(val: float32, mod: float32): float32
[ 301.86]  < return
[ 301.88]  > Math.absMod(val: float32, mod: float32): float32
[ 301.89]  < return
[ 301.90]  > Math.absMod(val: float32, mod: float32): float32
[ 301.91]  < return
[ 301.93]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 301.95]  < return
[ 301.96]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 301.98]  < return
[ 301.99]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 302.01]  < return
[ 302.02]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 302.04]  < return
[ 302.06]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 302.07]  < return
[ 302.09]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 302.11]  < return
[ 302.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 302.15]  < return
[ 302.17]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 302.19]  < return
[ 302.20]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 302.22]  < return
[ 302.24]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 302.26]  < return
[ 302.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 302.30]  < return
[ 302.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 302.34]  < return
[ 302.50]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 302.51]  < return
[ 302.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 302.61]  < return
[ 302.64]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 302.73]  < return
[ 302.76]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 302.79]  < return
[ 302.81]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 302.83]  < return
[ 302.85]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 302.88]  < return
[ 302.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 302.92]  < return
[ 302.95]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 302.96]  < return
[ 302.98]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 302.99]  < return
[ 303.01]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.01]  < return
[ 303.03]  > lenSlice(values: int64[]): int32
[ 303.05]  < return
[ 303.06]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.07]  < return
[ 303.08]  > lenSlice(values: int64[]): int32
[ 303.10]  < return
[ 303.11]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.12]  < return
[ 303.14]  > lenSlice(values: int64[]): int32
[ 303.15]  < return
[ 303.17]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.18]  < return
[ 303.19]  > lenSlice(values: int64[]): int32
[ 303.20]  < return
[ 303.22]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.23]  < return
[ 303.24]  > lenSlice(values: int64[]): int32
[ 303.26]  < return
[ 303.27]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 303.28]  < return
[ 303.35]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.36]  < return
[ 303.38]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.40]  < return
[ 303.42]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.44]  < return
[ 303.46]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.48]  < return
[ 303.50]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.52]  < return
[ 303.54]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.56]  < return
[ 303.58]  > nthSlice(idx: int32, values: int64[]): int64
[ 303.60]  < return
[ 303.62]  > nthSlice(idx: int32, values: int64[]): int64
[ 303.63]  < return
[ 303.71]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.73]  < return
[ 303.75]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.77]  < return
[ 303.79]  > nthFixed(idx: int32, values: int64[7]): int64
[ 303.81]  < return
[ 303.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.85]  < return
[ 303.87]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.89]  < return
[ 303.91]  > nthArray(idx: int32, values: int64[*]): int64
[ 303.93]  < return
[ 303.95]  > nthSlice(idx: int32, values: int64[]): int64
[ 303.97]  < return
[ 303.99]  > nthSlice(idx: int32, values: int64[]): int64
[ 304.00]  < return
[ 304.08]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.10]  < return
[ 304.12]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.14]  < return
[ 304.16]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.18]  < return
[ 304.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.22]  < return
[ 304.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.25]  < return
[ 304.28]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.29]  < return
[ 304.32]  > nthSlice(idx: int32, values: int64[]): int64
[ 304.33]  < return
[ 304.35]  > nthSlice(idx: int32, values: int64[]): int64
[ 304.37]  < return
[ 304.46]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.48]  < return
[ 304.50]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.52]  < return
[ 304.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.55]  < return
[ 304.58]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.59]  < return
[ 304.61]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.63]  < return
[ 304.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.67]  < return
[ 304.69]  > nthSlice(idx: int32, values: int64[]): int64
[ 304.71]  < return
[ 304.73]  > nthSlice(idx: int32, values: int64[]): int64
[ 304.75]  < return
[ 304.83]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.84]  < return
[ 304.86]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.88]  < return
[ 304.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 304.92]  < return
[ 304.94]  > nthArray(idx: int32, values: int64[*]): int64
[ 304.96]  < return
[ 304.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.00]  < return
[ 305.02]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.03]  < return
[ 305.06]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.07]  < return
[ 305.09]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.11]  < return
[ 305.19]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.21]  < return
[ 305.23]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.25]  < return
[ 305.27]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.29]  < return
[ 305.31]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.32]  < return
[ 305.35]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.36]  < return
[ 305.39]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.41]  < return
[ 305.43]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.44]  < return
[ 305.47]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.48]  < return
[ 305.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.58]  < return
[ 305.60]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.62]  < return
[ 305.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 305.66]  < return
[ 305.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.69]  < return
[ 305.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.73]  < return
[ 305.75]  > nthArray(idx: int32, values: int64[*]): int64
[ 305.77]  < return
[ 305.80]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.81]  < return
[ 305.83]  > nthSlice(idx: int32, values: int64[]): int64
[ 305.85]  < return
[ 305.89]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 305.91]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 306.00]   < return
[ 306.01]  < return
[ 306.02]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 306.04]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 306.13]   < return
[ 306.14]  < return
[ 306.16]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 306.18]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 306.19]   < return
[ 306.20]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 306.22]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 306.37]    < return
[ 306.38]   < return
[ 306.39]  < return
[ 306.40]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 306.42]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 306.44]   < return
[ 306.45]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 306.46]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 306.61]    < return
[ 306.62]   < return
[ 306.63]  < return
[ 306.65]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 306.66]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 306.75]   < return
[ 306.76]  < return
[ 306.78]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 306.80]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 306.88]   < return
[ 306.89]  < return
[ 306.91]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 306.93]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 307.02]   < return
[ 307.03]  < return
[ 307.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 307.07]  < return
[ 307.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 307.12]  < return
[ 307.13]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 307.16]  < return
[ 307.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 307.21]  < return
[ 307.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 307.27]  < return
[ 307.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 307.33]  < return
[ 307.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 307.38]  < return
[ 307.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 307.42]  < return
[ 307.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 307.48]  < return
[ 307.50]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 307.53]  < return
[ 307.57]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 307.59]  < return
[ 307.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 307.65]  < return
[ 307.72]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 307.75]  < return
[ 307.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 307.80]  < return
[ 307.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 307.86]  < return
[ 307.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 307.92]  < return
[ 307.95]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 307.97]  < return
[ 308.02]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 308.04]  < return
[ 308.07]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 308.10]  < return
[ 308.13]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 308.15]  < return
[ 308.18]  > halt(): void
[ 308.19]  < return
[ 308.19] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:59: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:75: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(225464)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(225160)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 352608(344.3 Kb)
memory[heap] @056160; size: 1219998(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 328208(320.5 Kb)
memory[code] @000000; size: 19241(18.8 Kb)
memory[data] @000000; size: 2674(2.6 Kb)

---------- heap memory:
memory[free] @056178; size: 1219952(1.2 Mb)

---------- Profile functions: 79/113, coverage: 69.91%
::[.005c20, .005c20): exec(2), time(0.016 ms): halt(): void
::[.005f68, .005f68): exec(3), time(0.047 ms): typename.base(type: typename): typename
::[.006168, .006168): exec(2), time(0.036 ms): typename.file(type: typename): .cstr
::[.006368, .006368): exec(2), time(0.034 ms): typename.line(type: typename): int32
::[.006568, .006568): exec(2), time(0.042 ms): typename.name(type: typename): .cstr
::[.006d00, .006d00): exec(40), time(1.728 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0075e0, .0075e0): exec(7), time(1.643 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007880, .007880): exec(8), time(0.129 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007bb8, .007bb8): exec(2), time(0.032 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007ef0, .007ef0): exec(2), time(0.034 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008220, .008220): exec(1), time(0.017 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0084c8, .0084c8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0086d0, .0086d0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008838, .008838): exec(0), time(0.000 ms): System.rand(): int32
::[.0089a0, .0089a0): exec(0), time(0.000 ms): System.time(): int32
::[.008b08, .008b08): exec(0), time(0.000 ms): System.clock(): int32
::[.008c70, .008c70): exec(0), time(0.000 ms): System.millis(): int64
::[.008e70, .008e70): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0091a8, .0091a8): exec(7), time(0.107 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0094d8, .0094d8): exec(7), time(0.113 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0096d8, .0096d8): exec(1), time(0.015 ms): uint32.pop(value: int32): int32
::[.0098d8, .0098d8): exec(1), time(0.015 ms): uint32.swap(value: int32): int32
::[.009ad8, .009ad8): exec(1), time(0.015 ms): uint32.bsr(value: int32): int32
::[.009cd8, .009cd8): exec(1), time(0.015 ms): uint32.bsf(value: int32): int32
::[.009ed8, .009ed8): exec(1), time(0.015 ms): uint32.hib(value: int32): int32
::[.00a0d8, .00a0d8): exec(1), time(0.014 ms): uint32.lob(value: int32): int32
::[.00a400, .00a400): exec(1), time(0.015 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a728, .00a728): exec(1), time(0.015 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00a928, .00a928): exec(1), time(0.017 ms): float32.sin(x: float32): float32
::[.00ab28, .00ab28): exec(1), time(0.015 ms): float32.cos(x: float32): float32
::[.00ad28, .00ad28): exec(1), time(0.015 ms): float32.tan(x: float32): float32
::[.00af28, .00af28): exec(1), time(0.016 ms): float32.log(x: float32): float32
::[.00b128, .00b128): exec(1), time(0.014 ms): float32.exp(x: float32): float32
::[.00b3c0, .00b3c0): exec(1), time(0.016 ms): float32.pow(x: float32, y: float32): float32
::[.00b5c0, .00b5c0): exec(1), time(0.015 ms): float32.sqrt(x: float32): float32
::[.00b858, .00b858): exec(1), time(0.018 ms): float32.atan2(x: float32, y: float32): float32
::[.00ba50, .00ba50): exec(1), time(0.032 ms): float64.sin(x: float64): float64
::[.00bc48, .00bc48): exec(1), time(0.019 ms): float64.cos(x: float64): float64
::[.00be40, .00be40): exec(1), time(0.016 ms): float64.tan(x: float64): float64
::[.00c038, .00c038): exec(1), time(0.018 ms): float64.log(x: float64): float64
::[.00c230, .00c230): exec(5), time(0.069 ms): float64.exp(x: float64): float64
::[.00c4c0, .00c4c0): exec(1), time(0.017 ms): float64.pow(x: float64, y: float64): float64
::[.00c6b8, .00c6b8): exec(3), time(0.042 ms): float64.sqrt(x: float64): float64
::[.00c948, .00c948): exec(3), time(0.045 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:75:[.050210, .05026e): exec(8), time(0.086 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.050270, .0502c6): exec(10), time(0.123 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.0502c8, .0502e0): exec(6), time(0.213-0.113 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.0502e0, .0502f2): exec(3), time(0.028 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.0502f8, .05030a): exec(4), time(0.039 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.050310, .05032b): exec(11), time(0.104 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.050330, .05034b): exec(11), time(0.106 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.050350, .050361): exec(1), time(0.009 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.050368, .050379): exec(1), time(0.009 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.050380, .050391): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.050398, .0503a9): exec(1), time(0.010 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.0503b0, .0503ce): exec(2), time(0.022 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.0503d0, .0503ee): exec(2), time(0.022 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.0503f0, .050438): exec(2), time(0.059 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.050438, .050480): exec(2), time(0.064 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.050480, .0504a8): exec(4), time(0.108 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.0504a8, .0504d7): exec(3), time(0.096 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.0504d8, .050511): exec(1), time(0.012 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.050518, .050551): exec(1), time(0.012 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.050558, .0506a7): exec(2), time(0.064 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.0506a8, .05081b): exec(1), time(0.053-0.010 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.050820, .050911): exec(1), time(0.060-0.028 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.050918, .050963): exec(1), time(0.053-0.026 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.050968, .050a0e): exec(2), time(0.124-0.055 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.050a10, .050a17): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.050a18, .050a1f): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.050a20, .050a9b): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.050aa0, .050abf): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.050ac0, .050b24): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.050b28, .050b4e): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.050b50, .050b82): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.050b88, .050bba): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.050bc0, .050c09): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.050c10, .050c8e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.050c90, .050ccf): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.050cd0, .050d17): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.050d18, .050d3c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.050d40, .050d4e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.050d50, .050da4): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.050db8, .051049): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.051050, .051067): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.051068, .051099): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.0510b0, .0510c9): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.0510d0, .0510d7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.0510d8, .0510e5): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:27:[.0510e8, .051119): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:40:[.051120, .051135): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:52:[.051138, .0512d9): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:4:[.051770, .051771): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.051778, .051780): exec(2), time(0.027 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.0517b8, .0517c0): exec(2), time(0.025 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.0517c0, .0517f6): exec(753), time(16.695 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.051ac8, .051ac9): exec(1), time(0.015 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.051ad0, .051ae8): exec(64-64), time(1.311 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.051ae8, .051af4): exec(1-1), time(0.014 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.051af8, .051b3c): exec(1-1), time(0.127-0.098 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.051b40, .051b4d): exec(1-1), time(0.015 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.051b50, .051b52): exec(1-1), time(0.013 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.051c28, .051c2c): exec(5), time(0.075 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.051c30, .051c3c): exec(21), time(0.374 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.051c40, .051c4c): exec(21), time(0.369 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.051c50, .051c5c): exec(14), time(0.245 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.051cb0, .051cd7): exec(3), time(0.406-0.330 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.051ce0, .051d07): exec(4), time(0.528-0.427 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.051d08, .051d2f): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.051d30, .051d57): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.051d68, .051daa): exec(1), time(0.229-0.191 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.051db0, .051def): exec(1), time(0.228-0.190 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.052834, .056160): exec(1), time(31.179-23.700 ms): .main

---------- Profile statements: 875/1125, coverage: 77.78%
lib/stdlib.ci:77:[.050219, .05021a) exec(8), time(0.047-0.047 ms): <assertEq+9>
lib/stdlib.ci:76:[.050210, .05021a) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:80:[.05021e, .050229) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:81:[.050229, .050234) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:82:[.050234, .050237) exec(0), time(0.000 ms): <assertEq+36>
::[.050237, .050243) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:79:[.05021a, .050243) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:84:[.050243, .050269) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.050288, .050299) exec(3), time(0.051-0.051 ms): <modf+24>
lib/std/math.ci:26:[.050299, .0502a0) exec(3), time(0.003-0.003 ms): <modf+41>
lib/std/math.ci:27:[.0502a0, .0502a3) exec(3), time(0.017-0.017 ms): <modf+48>
lib/std/math.ci:24:[.050280, .0502a7) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.0502a7, .0502ab) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.0502ab, .0502af) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.050270, .0502af) exec(10-3), time(0.004-0.004 ms): <modf+0>
lib/std/math.ci:32:[.0502af, .0502bb) exec(7), time(0.004-0.004 ms): <modf+63>
lib/std/math.ci:33:[.0502bb, .0502c3) exec(7), time(0.005-0.005 ms): <modf+75>
lib/std/math.ci:34:[.0502c3, .0502c6) exec(7), time(0.042-0.042 ms): <modf+83>
lib/std/math.ci:48:[.0502c8, .0502c9) exec(6), time(0.001-0.001 ms): <floor+0>
lib/std/math.ci:49:[.0502c9, .0502dd) exec(6), time(0.152-0.152 ms): <floor+1>
lib/std/math.ci:50:[.0502dd, .0502e0) exec(6), time(0.035-0.035 ms): <floor+21>
lib/std/math.ci:79:[.0502e8, .0502ee) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:78:[.0502e0, .0502ee) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.0502ee, .0502f2) exec(2), time(0.012-0.012 ms): <abs+14>
lib/std/math.ci:87:[.050300, .050306) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:86:[.0502f8, .050306) exec(4-1), time(0.001-0.001 ms): <abs+0>
lib/std/math.ci:89:[.050306, .05030a) exec(3), time(0.019-0.019 ms): <abs+14>
lib/std/math.ci:95:[.05031f, .050327) exec(4), time(0.025-0.025 ms): <absMod+15>
lib/std/math.ci:94:[.050310, .050327) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:97:[.050327, .05032b) exec(7), time(0.042-0.042 ms): <absMod+23>
lib/std/math.ci:103:[.05033f, .050347) exec(4), time(0.025-0.025 ms): <absMod+15>
lib/std/math.ci:102:[.050330, .050347) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:105:[.050347, .05034b) exec(7), time(0.042-0.042 ms): <absMod+23>
lib/std/math.ci:117:[.050359, .05035d) exec(1), time(0.007-0.007 ms): <min+9>
lib/std/math.ci:116:[.050350, .05035d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.05035d, .050361) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.050371, .050375) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:124:[.050368, .050375) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.050375, .050379) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.050389, .05038d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.050380, .05038d) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.05038d, .050391) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:147:[.0503a1, .0503a5) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.050398, .0503a5) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.0503a5, .0503a9) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:161:[.0503b9, .0503bd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.0503b0, .0503bd) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.0503c6, .0503ca) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:163:[.0503bd, .0503ca) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.0503ca, .0503ce) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:172:[.0503d9, .0503dd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.0503d0, .0503dd) exec(2), time(0.001-0.001 ms): <clamp+0>
lib/std/math.ci:175:[.0503e6, .0503ea) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:174:[.0503dd, .0503ea) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:177:[.0503ea, .0503ee) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:203:[.0503f8, .0503fd) exec(1), time(0.006-0.006 ms): <min+8>
lib/std/math.ci:202:[.0503f0, .0503fd) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.0503fd, .050400) exec(1), time(0.000 ms): <min+13>
lib/std/math.ci:208:[.050419, .050424) exec(2), time(0.001-0.001 ms): <min+41>
lib/std/math.ci:207:[.050409, .050424) exec(8-2), time(0.006-0.006 ms): <min+25>
lib/std/math.ci:206:[.050424, .050428) exec(8), time(0.005-0.005 ms): <min+52>
lib/std/math.ci:206:[.050428, .050431) exec(9), time(0.007-0.007 ms): <min+56>
lib/std/math.ci:206:[.050400, .050435) exec(1), time(0.001-0.001 ms): <min+16>
lib/std/math.ci:211:[.050435, .050438) exec(1), time(0.006-0.006 ms): <min+69>
lib/std/math.ci:217:[.050440, .050445) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:216:[.050438, .050445) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.050445, .050448) exec(1), time(0.000 ms): <max+13>
lib/std/math.ci:222:[.050461, .05046c) exec(2), time(0.002-0.002 ms): <max+41>
lib/std/math.ci:221:[.050451, .05046c) exec(8-2), time(0.006-0.006 ms): <max+25>
lib/std/math.ci:220:[.05046c, .050470) exec(8), time(0.004-0.004 ms): <max+52>
lib/std/math.ci:220:[.050470, .050479) exec(9), time(0.004-0.004 ms): <max+56>
lib/std/math.ci:220:[.050448, .05047d) exec(1), time(0.001-0.001 ms): <max+16>
lib/std/math.ci:225:[.05047d, .050480) exec(1), time(0.013-0.013 ms): <max+69>
lib/std/math.ci:230:[.050480, .050481) exec(4), time(0.003-0.003 ms): <sum+0>
lib/std/math.ci:232:[.050486, .050494) exec(13), time(0.013-0.013 ms): <sum+6>
lib/std/math.ci:231:[.050494, .050498) exec(13), time(0.003-0.003 ms): <sum+20>
lib/std/math.ci:231:[.050498, .0504a1) exec(17), time(0.008-0.008 ms): <sum+24>
lib/std/math.ci:231:[.050481, .0504a5) exec(4), time(0.004-0.004 ms): <sum+1>
lib/std/math.ci:234:[.0504a5, .0504a8) exec(4), time(0.024-0.024 ms): <sum+37>
lib/std/math.ci:257:[.0504a8, .0504a9) exec(3), time(0.000 ms): <eval+0>
lib/std/math.ci:259:[.0504b3, .0504c4) exec(11), time(0.013-0.013 ms): <eval+11>
lib/std/math.ci:258:[.0504c4, .0504c8) exec(11), time(0.006-0.006 ms): <eval+28>
lib/std/math.ci:258:[.0504c8, .0504d0) exec(14), time(0.009-0.009 ms): <eval+32>
lib/std/math.ci:258:[.0504a9, .0504d4) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:261:[.0504d4, .0504d7) exec(3), time(0.018-0.018 ms): <eval+44>
lib/std/math.ci:268:[.0504ed, .0504f5) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.0504e1, .0504f5) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.050505, .05050d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.0504f9, .05050d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.0504d8, .05050d) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:276:[.05050d, .050511) exec(1), time(0.007-0.007 ms): <cmp+53>
lib/std/math.ci:283:[.05052d, .050535) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.050521, .050535) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:288:[.050545, .05054d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.050539, .05054d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.050518, .05054d) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:291:[.05054d, .050551) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:309:[.050558, .05055a) exec(2), time(0.002-0.002 ms): <sinCos+0>
lib/std/math.ci:311:[.050562, .050563) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.050563, .05056b) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.05055a, .05056b) exec(2), time(0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:315:[.05056b, .05056c) exec(2), time(0.000 ms): <sinCos+19>
lib/std/math.ci:316:[.05056c, .050584) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:318:[.050594, .050595) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.050595, .0505a7) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.0505a7, .0505ab) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.0505ab, .0505ac) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.0505ac, .0505ca) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.0505ca, .0505dc) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.0505e4, .0505e7) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:328:[.0505e7, .0505ef) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:329:[.0505ef, .0505f6) exec(2), time(0.002-0.002 ms): <sinCos+151>
lib/std/math.ci:330:[.0505f6, .0505fc) exec(2), time(0.001-0.001 ms): <sinCos+158>
lib/std/math.ci:317:[.050584, .050600) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:333:[.050608, .050616) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:332:[.050600, .050616) exec(2-1), time(0.000 ms): <sinCos+168>
lib/std/math.ci:336:[.050622, .050623) exec(1), time(0.000 ms): <sinCos+202>
lib/std/math.ci:335:[.050616, .050623) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:339:[.050623, .050628) exec(2), time(0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:340:[.050628, .050668) exec(2), time(0.005-0.005 ms): <sinCos+208>
lib/std/math.ci:341:[.050668, .05069b) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:342:[.05069b, .0506a7) exec(2), time(0.013-0.013 ms): <sinCos+323>
lib/std/math.ci:365:[.0506a8, .0506a9) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.0506a9, .0506aa) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:369:[.0506b2, .0506b7) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.0506b7, .0506c1) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.0506aa, .0506c1) exec(1), time(0.000 ms): <tan+2>
lib/std/math.ci:372:[.0506c1, .0506d9) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.0506d9, .0506da) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:375:[.0506da, .0506ea) exec(1), time(0.017-0.017 ms): <tan+50>
lib/std/math.ci:376:[.0506ea, .0506f3) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:380:[.050707, .050715) exec(1), time(0.000 ms): <tan+95>
lib/std/math.ci:381:[.050715, .05071f) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.05072f, .05073a) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.05073a, .050744) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.050754, .050762) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.050762, .05076d) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.050748, .05076d) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.050723, .05076d) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.0506fb, .05076d) exec(1), time(0.002-0.002 ms): <tan+83>
lib/std/math.ci:378:[.0506f3, .05076d) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.05076d, .050772) exec(1), time(0.001-0.001 ms): <tan+197>
lib/std/math.ci:393:[.050772, .0507b2) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.0507b2, .0507d9) exec(1), time(0.001-0.001 ms): <tan+266>
lib/std/math.ci:398:[.0507ea, .0507f3) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.0507e2, .0507f3) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.0507f3, .050801) exec(1), time(0.001-0.001 ms): <tan+331>
lib/std/math.ci:396:[.0507d9, .050801) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.05080a, .050814) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:402:[.050801, .050814) exec(1), time(0.001-0.001 ms): <tan+345>
lib/std/math.ci:405:[.050814, .05081b) exec(1), time(0.007-0.007 ms): <tan+364>
lib/std/math.ci:421:[.050820, .050821) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:423:[.050829, .05082e) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.05082e, .050838) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.050821, .050838) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.050848, .05085f) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.050838, .05085f) exec(1), time(0.000 ms): <sinh+24>
lib/std/math.ci:431:[.05085f, .050860) exec(1), time(0.001-0.001 ms): <sinh+63>
lib/std/math.ci:433:[.050870, .05088a) exec(1), time(0.043-0.043 ms): <sinh+80>
lib/std/math.ci:436:[.05088e, .050893) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.050893, .0508c8) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.0508c8, .0508f3) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.050860, .0508f7) exec(1), time(0.043-0.043 ms): <sinh+64>
lib/std/math.ci:442:[.050900, .05090a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.0508f7, .05090a) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:444:[.05090a, .050911) exec(1), time(0.007-0.007 ms): <sinh+234>
lib/std/math.ci:450:[.050920, .050925) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.050918, .050925) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:453:[.050935, .050948) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.050925, .050948) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:455:[.050948, .050963) exec(1), time(0.047-0.047 ms): <cosh+48>
lib/std/math.ci:466:[.050970, .050974) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.050968, .050974) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:469:[.050974, .050975) exec(2), time(0.001-0.001 ms): <asin+12>
lib/std/math.ci:471:[.05097d, .050987) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.050987, .05098c) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.050975, .05098c) exec(2), time(0.002-0.002 ms): <asin+13>
lib/std/math.ci:477:[.05099c, .0509a5) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.05098c, .0509a5) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.0509a5, .0509b8) exec(2), time(0.043-0.043 ms): <asin+61>
lib/std/math.ci:482:[.0509c8, .0509e6) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:485:[.0509ea, .0509f4) exec(2), time(0.043-0.043 ms): <asin+130>
lib/std/math.ci:481:[.0509b8, .0509f4) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:489:[.0509fd, .050a07) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:488:[.0509f4, .050a07) exec(2), time(0.002-0.002 ms): <asin+140>
lib/std/math.ci:491:[.050a07, .050a0e) exec(2), time(0.012-0.012 ms): <asin+159>
::[.050a13, .050a16) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.050a10, .050a17) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.050a1b, .050a1e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.050a18, .050a1f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.050a3f, .050a44) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.050a44, .050a4c) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.050a59, .050a66) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.050a4c, .050a6b) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.050a20, .050a6f) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.050a6f, .050a74) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.050a74, .050a7c) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.050a89, .050a96) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.050a7c, .050a9b) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.050aa0, .050aab) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.050ab2, .050aba) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.050aab, .050abf) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.050ac0, .050ad7) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.050ad7, .050ae7) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.050ae7, .050af6) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.050af6, .050b09) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.050b14, .050b1f) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.050b09, .050b24) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.050b34, .050b38) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.050b28, .050b38) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.050b38, .050b39) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.050b3d, .050b41) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.050b41, .050b4b) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.050b39, .050b4b) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.050b4b, .050b4e) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.050b65, .050b68) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.050b55, .050b68) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.050b68, .050b6c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.050b6c, .050b76) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.050b50, .050b7a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.050b7a, .050b82) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.050b88, .050b8d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.050ba2, .050ba5) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.050b92, .050ba5) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.050ba5, .050ba9) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.050ba9, .050bb3) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.050b8d, .050bb7) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.050bb7, .050bba) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.050bdf, .050bea) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.050bc5, .050bea) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.050bea, .050bee) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.050bee, .050bfa) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.050bc0, .050bfe) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.050bfe, .050c09) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.050c10, .050c1d) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.050c1d, .050c2a) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.050c33, .050c3e) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.050c2a, .050c3e) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.050c63, .050c6e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.050c43, .050c6e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.050c6e, .050c72) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.050c72, .050c7b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.050c3e, .050c7f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.050c7f, .050c8e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.050c90, .050c91) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.050c96, .050cac) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.050cb8, .050cbc) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.050cac, .050cbc) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.050cbc, .050cc0) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.050cc0, .050cc8) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.050c91, .050ccc) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.050ccc, .050ccf) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.050cdf, .050cea) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.050cd0, .050cea) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.050cf9, .050d04) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.050cea, .050d04) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.050d04, .050d17) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.050d18, .050d3c) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.050d40, .050d4e) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.050d5e, .050d62) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.050d55, .050d62) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.050d62, .050d6e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.050d6e, .050d76) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.050d76, .050d7a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.050d7a, .050d84) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.050d50, .050d88) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.050d91, .050d99) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.050d88, .050d99) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.050d99, .050da0) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.050da0, .050da4) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.050db8, .050db9) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.050db9, .050dbd) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.050dbd, .050dc0) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.050dc0, .050df6) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.050df6, .050e2b) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.050e2f, .050e4a) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.050e4a, .050e51) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.050e51, .050e59) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.050e2b, .050e59) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.050e61, .050e76) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.050e59, .050e76) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.050e76, .050e80) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.050e80, .050e87) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.050e92, .050e9c) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.050e87, .050e9c) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.050ea7, .050eaf) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.050ecd, .050f01) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.050f01, .050f0c) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.050f0c, .050f14) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.050f14, .050f1c) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.050f1c, .050f24) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.050ec9, .050f24) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.050eaf, .050f24) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.050f24, .050f58) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.050f58, .050f63) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.050f63, .050f6b) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.050e9c, .050f6b) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.050f6f, .050fa3) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.050fa3, .050fae) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.050fae, .050fb6) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.050fb6, .050fbe) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.050fbe, .050fc6) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.050f6b, .050fc6) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.050fcb, .050fff) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.050fff, .051010) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.051010, .051018) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.051018, .05101c) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.05101c, .051025) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.050fc6, .051029) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.051032, .05103a) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.051029, .05103a) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.05103a, .051041) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.051041, .051049) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.051050, .051067) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.051068, .051069) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.051071, .051078) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.051078, .05107d) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.051069, .05107d) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.05107d, .051099) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.0510b0, .0510c9) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.0510d3, .0510d6) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.0510d0, .0510d7) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.0510db, .0510de) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.0510de, .0510e1) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.0510e1, .0510e4) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.0510d8, .0510e5) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:32:[.0510eb, .0510ee) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:32:[.0510ee, .0510f1) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:32:[.0510f1, .0510f4) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:33:[.0510f4, .0510f7) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:33:[.0510f7, .0510fa) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:33:[.0510fa, .0510fd) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:33:[.0510fd, .051100) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:34:[.051100, .051103) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:34:[.051103, .051106) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:34:[.051106, .051109) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:34:[.051109, .05110c) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:35:[.05110c, .05110f) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:35:[.05110f, .051112) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:35:[.051112, .051115) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:35:[.051115, .051118) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:31:[.0510e8, .051119) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:41:[.051125, .05112a) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:41:[.05112a, .05112f) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:41:[.05112f, .051134) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:41:[.051120, .051135) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:54:[.05113c, .051141) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:54:[.051141, .05114a) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:54:[.05114a, .051153) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:54:[.051153, .05115c) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:55:[.05115c, .051165) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:55:[.051165, .05116e) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:55:[.05116e, .051177) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:55:[.051177, .051180) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:56:[.051180, .051189) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:56:[.051189, .051192) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:56:[.051192, .05119b) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:56:[.05119b, .0511a4) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:57:[.0511a4, .0511ad) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:57:[.0511ad, .0511b6) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:57:[.0511b6, .0511bf) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:57:[.0511bf, .0511c8) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:53:[.051138, .0511c8) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:61:[.051208, .05124c) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:62:[.05124c, .051290) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:63:[.051290, .0512d4) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:59:[.0511c8, .0512d9) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:8:[.051778, .051780) exec(2), time(0.018-0.018 ms): <funAdd+0>
test/lang/function.ci:34:[.0517b8, .0517c0) exec(2), time(0.017-0.017 ms): <funMul+0>
test/lang/function.ci:40:[.0517cc, .0517d0) exec(377), time(2.787-2.787 ms): <fib+12>
test/lang/function.ci:39:[.0517c0, .0517d0) exec(753-377), time(0.713-0.713 ms): <fib+0>
test/lang/function.ci:42:[.0517d0, .0517f6) exec(376-375), time(16.688-16.688 ms): <fib+16>
test/stdc/tryExec.ci:15:[.051ad0, .051ad4) exec(64-1), time(0.039-0.039 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.051ad4, .051ae3) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.051ae8, .051aef) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.051afc, .051b03) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.051b03, .051b0a) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.051b0a, .051b11) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.051af8, .051b11) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.051b11, .051b37) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.051b40, .051b45) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.051b45, .051b48) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.051b50, .051b52) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.051c28, .051c2c) exec(5), time(0.038-0.038 ms): <lenSlice+0>
test/lang/array.ci:104:[.051c30, .051c3c) exec(21), time(0.203-0.203 ms): <nthFixed+0>
test/lang/array.ci:105:[.051c40, .051c4c) exec(21), time(0.200-0.200 ms): <nthArray+0>
test/lang/array.ci:106:[.051c50, .051c5c) exec(14), time(0.136-0.136 ms): <nthSlice+0>
test/lang/method.ci:11:[.051cb0, .051cd6) exec(3), time(0.364-0.364 ms): <staticMethod+0>
test/lang/method.ci:41:[.051ce0, .051d06) exec(4), time(0.470-0.470 ms): <virtualMethod+0>
test/lang/method.ci:48:[.051d08, .051d2e) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.051d30, .051d56) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.051d68, .051d8b) exec(1), time(0.027-0.027 ms): <staticMethod+0>
test/lang/method.ci:87:[.051d99, .051da9) exec(1), time(0.184-0.184 ms): <staticMethod+49>
test/lang/method.ci:86:[.051d8b, .051da9) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.051db0, .051dd3) exec(1), time(0.027-0.027 ms): <virtualMethod+0>
test/lang/method.ci:93:[.051de1, .051dee) exec(1), time(0.182-0.182 ms): <virtualMethod+49>
test/lang/method.ci:92:[.051dd3, .051dee) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.052834, .052842) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.052842, .052850) exec(1), time(0.002-0.002 ms): <.main+14>
::[.052859, .052860) exec(1), time(0.002-0.002 ms): <.main+37>
::[.052860, .052865) exec(1), time(0.001-0.001 ms): <.main+44>
::[.052865, .05286a) exec(1), time(0.001-0.001 ms): <.main+49>
lib/std/string.ci:223:[.052850, .05286a) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.05286a, .05286f) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/emit.ci:4:[.05286f, .052874) exec(1), time(0.001-0.001 ms): <.main+59>
test/lang/emit.ci:6:[.052874, .05287d) exec(1), time(0.001-0.001 ms): <.main+64>
test/lang/emit.ci:7:[.05287d, .052886) exec(1), time(0.001-0.001 ms): <.main+73>
test/lang/emit.ci:9:[.052886, .052893) exec(1), time(0.002-0.002 ms): <.main+82>
test/lang/emit.ci:10:[.052893, .0528a2) exec(1), time(0.002-0.002 ms): <.main+95>
test/lang/emit.ci:17:[.0528a2, .0528ab) exec(1), time(0.001-0.001 ms): <.main+110>
test/lang/emit.ci:18:[.0528ab, .0528b5) exec(1), time(0.002-0.002 ms): <.main+119>
test/lang/emit.ci:19:[.0528b5, .0528c3) exec(1), time(0.002-0.002 ms): <.main+129>
test/lang/emit.ci:20:[.0528c3, .0528d0) exec(1), time(0.001-0.001 ms): <.main+143>
test/lang/emit.ci:23:[.0528d0, .0528de) exec(1), time(0.002-0.002 ms): <.main+156>
test/lang/inlineMacros.ci:10:[.0528de, .0528e7) exec(1), time(0.001-0.001 ms): <.main+170>
test/lang/inlineMacros.ci:11:[.0528e7, .0528f0) exec(1), time(0.001-0.001 ms): <.main+179>
test/lang/inlineMacros.ci:12:[.0528f0, .0528f9) exec(1), time(0.001-0.001 ms): <.main+188>
test/lang/inlineMacros.ci:13:[.0528f9, .052902) exec(1), time(0.001-0.001 ms): <.main+197>
test/lang/inlineMacros.ci:15:[.052902, .052907) exec(1), time(0.001-0.001 ms): <.main+206>
test/lang/inlineMacros.ci:16:[.052907, .05290c) exec(1), time(0.001-0.001 ms): <.main+211>
test/lang/inlineMacros.ci:17:[.05290c, .052911) exec(1), time(0.001-0.001 ms): <.main+216>
test/lang/inlineMacros.ci:19:[.052911, .05291a) exec(1), time(0.001-0.001 ms): <.main+221>
test/lang/inlineMacros.ci:20:[.05291a, .052922) exec(1), time(0.001-0.001 ms): <.main+230>
test/lang/inlineMacros.ci:21:[.052922, .052932) exec(1), time(0.002-0.002 ms): <.main+238>
test/lang/inlineMacros.ci:23:[.052932, .05293f) exec(1), time(0.002-0.002 ms): <.main+254>
test/lang/inlineMacros.ci:24:[.05293f, .05294c) exec(1), time(0.002-0.002 ms): <.main+267>
test/lang/inlineMacros.ci:25:[.05294c, .052965) exec(1), time(0.004-0.004 ms): <.main+280>
test/lang/inlineMacros.ci:27:[.052965, .052981) exec(1), time(0.004-0.004 ms): <.main+305>
test/lang/inlineMacros.ci:28:[.052981, .05299b) exec(1), time(0.010-0.010 ms): <.main+333>
test/lang/inlineMacros.ci:29:[.05299b, .0529c1) exec(1), time(0.005-0.005 ms): <.main+359>
test/lang/inlineMacros.ci:31:[.0529c1, .0529e6) exec(1), time(0.006-0.006 ms): <.main+397>
test/lang/inlineMacros.ci:32:[.0529e6, .052a09) exec(1), time(0.006-0.006 ms): <.main+434>
test/lang/inlineMacros.ci:33:[.052a09, .052a38) exec(1), time(0.008-0.008 ms): <.main+469>
test/lang/inlineMacros.ci:35:[.052a38, .052a5d) exec(1), time(0.005-0.005 ms): <.main+516>
test/lang/inlineMacros.ci:36:[.052a5d, .052a80) exec(1), time(0.005-0.005 ms): <.main+553>
test/lang/inlineMacros.ci:37:[.052a80, .052aaf) exec(1), time(0.007-0.007 ms): <.main+588>
test/lang/inlineMacros.ci:41:[.052aaf, .052ac8) exec(1), time(0.003-0.003 ms): <.main+635>
test/lang/inlineMacros.ci:42:[.052ac8, .052add) exec(1), time(0.003-0.003 ms): <.main+660>
test/lang/inlineMacros.ci:43:[.052add, .052af4) exec(1), time(0.005-0.005 ms): <.main+681>
test/lang/inlineMacros.ci:44:[.052af4, .052b0b) exec(1), time(0.004-0.004 ms): <.main+704>
test/lang/inlineMacros.ci:45:[.052b0b, .052b36) exec(1), time(0.007-0.007 ms): <.main+727>
test/lang/inlineMacros.ci:46:[.052b36, .052b61) exec(1), time(0.007-0.007 ms): <.main+770>
test/lang/inlineMacros.ci:50:[.052b61, .052ba3) exec(1), time(0.003-0.003 ms): <.main+813>
test/lang/inlineMacros.ci:51:[.052ba3, .052be5) exec(1), time(0.010-0.010 ms): <.main+879>
test/lang/inlineMacros.ci:52:[.052be5, .052c23) exec(1), time(0.004-0.004 ms): <.main+945>
test/lang/inlineMacros.ci:53:[.052c23, .052c61) exec(1), time(0.009-0.009 ms): <.main+1007>
test/lang/inlineMacros.ci:54:[.052c61, .052cb3) exec(1), time(0.005-0.005 ms): <.main+1069>
test/lang/inlineMacros.ci:55:[.052cb3, .052d05) exec(1), time(0.010-0.010 ms): <.main+1151>
test/lang/inlineMacros.ci:59:[.052d05, .052d62) exec(1), time(0.015-0.015 ms): <.main+1233>
test/lang/inlineMacros.ci:60:[.052d62, .052dbf) exec(1), time(0.016-0.016 ms): <.main+1326>
test/lang/inlineMacros.ci:61:[.052dbf, .052e18) exec(1), time(0.015-0.015 ms): <.main+1419>
test/lang/inlineMacros.ci:62:[.052e18, .052e71) exec(1), time(0.015-0.015 ms): <.main+1508>
test/lang/inlineMacros.ci:63:[.052e71, .052ede) exec(1), time(0.017-0.017 ms): <.main+1597>
test/lang/inlineMacros.ci:64:[.052ede, .052f4b) exec(1), time(0.019-0.019 ms): <.main+1706>
test/lang/inlineMacros.ci:68:[.052f4b, .052fa8) exec(1), time(0.014-0.014 ms): <.main+1815>
test/lang/inlineMacros.ci:69:[.052fa8, .053005) exec(1), time(0.015-0.015 ms): <.main+1908>
test/lang/inlineMacros.ci:70:[.053005, .05305e) exec(1), time(0.014-0.014 ms): <.main+2001>
test/lang/inlineMacros.ci:71:[.05305e, .0530b7) exec(1), time(0.015-0.015 ms): <.main+2090>
test/lang/inlineMacros.ci:72:[.0530b7, .053124) exec(1), time(0.017-0.017 ms): <.main+2179>
test/lang/inlineMacros.ci:73:[.053124, .053191) exec(1), time(0.018-0.018 ms): <.main+2288>
test/lang/overload.inline.ci:9:[.053191, .05319a) exec(1), time(0.001-0.001 ms): <.main+2397>
test/lang/overload.inline.ci:10:[.05319a, .0531a3) exec(1), time(0.001-0.001 ms): <.main+2406>
test/lang/overload.inline.ci:11:[.0531a3, .0531ac) exec(1), time(0.001-0.001 ms): <.main+2415>
test/lang/overload.inline.ci:12:[.0531ac, .0531b5) exec(1), time(0.002-0.002 ms): <.main+2424>
test/lang/overload.inline.ci:13:[.0531b5, .0531be) exec(1), time(0.001-0.001 ms): <.main+2433>
test/lang/overload.inline.ci:28:[.0531be, .0531cb) exec(1), time(0.001-0.001 ms): <.main+2442>
test/lang/overload.inline.ci:29:[.0531cb, .0531e7) exec(1), time(0.004-0.004 ms): <.main+2455>
test/lang/initByRef.ci:7:[.0531e7, .0531f4) exec(1), time(0.001-0.001 ms): <.main+2483>
test/lang/initByRef.ci:8:[.0531f4, .0531fd) exec(1), time(0.001-0.001 ms): <.main+2496>
test/lang/initByRef.ci:9:[.0531fd, .053206) exec(1), time(0.001-0.001 ms): <.main+2505>
test/lang/initByRef.ci:10:[.053206, .053214) exec(1), time(0.002-0.002 ms): <.main+2514>
test/lang/initByRef.ci:12:[.053214, .05321d) exec(1), time(0.002-0.002 ms): <.main+2528>
test/lang/initByRef.ci:13:[.05321d, .053225) exec(1), time(0.001-0.001 ms): <.main+2537>
test/lang/initByRef.ci:14:[.053225, .05322d) exec(1), time(0.002-0.002 ms): <.main+2545>
test/lang/initByRef.ci:16:[.05322d, .053236) exec(1), time(0.001-0.001 ms): <.main+2553>
test/lang/initByRef.ci:17:[.053236, .05323f) exec(1), time(0.001-0.001 ms): <.main+2562>
test/lang/initByRef.ci:18:[.05323f, .05324d) exec(1), time(0.002-0.002 ms): <.main+2571>
test/lang/initByRef.ci:19:[.05324d, .053256) exec(1), time(0.001-0.001 ms): <.main+2585>
test/lang/initByRef.ci:20:[.053256, .05325f) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:21:[.05325f, .053268) exec(1), time(0.002-0.002 ms): <.main+2603>
test/lang/initByRef.ci:23:[.053268, .053271) exec(1), time(0.001-0.001 ms): <.main+2612>
test/lang/initByRef.ci:24:[.053271, .05327f) exec(1), time(0.002-0.002 ms): <.main+2621>
test/lang/initByRef.ci:25:[.05327f, .053288) exec(1), time(0.001-0.001 ms): <.main+2635>
test/lang/initByRef.ci:27:[.053288, .053290) exec(1), time(0.001-0.001 ms): <.main+2644>
test/lang/initByRef.ci:28:[.053290, .053298) exec(1), time(0.001-0.001 ms): <.main+2652>
test/lang/initByRef.ci:29:[.053298, .0532a0) exec(1), time(0.001-0.001 ms): <.main+2660>
test/lang/initByRef.ci:30:[.0532a0, .0532a8) exec(1), time(0.001-0.001 ms): <.main+2668>
test/lang/initByRef.ci:31:[.0532a8, .0532b0) exec(1), time(0.001-0.001 ms): <.main+2676>
test/lang/initByRef.ci:32:[.0532b0, .0532b8) exec(1), time(0.002-0.002 ms): <.main+2684>
test/lang/initByRef.ci:35:[.0532b8, .0532c1) exec(1), time(0.001-0.001 ms): <.main+2692>
test/lang/initByRef.ci:36:[.0532c1, .0532ca) exec(1), time(0.001-0.001 ms): <.main+2701>
test/lang/initByRef.ci:37:[.0532ca, .0532d3) exec(1), time(0.001-0.001 ms): <.main+2710>
test/lang/initByRef.ci:38:[.0532d3, .0532dc) exec(1), time(0.001-0.001 ms): <.main+2719>
test/lang/initByRef.ci:39:[.0532dc, .0532e5) exec(1), time(0.001-0.001 ms): <.main+2728>
test/lang/initByRef.ci:40:[.0532e5, .0532ee) exec(1), time(0.001-0.001 ms): <.main+2737>
test/lang/initByRef.ci:41:[.0532ee, .0532f7) exec(1), time(0.002-0.002 ms): <.main+2746>
test/lang/initByRef.ci:42:[.0532f7, .053300) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/initByRef.ci:43:[.053300, .053309) exec(1), time(0.001-0.001 ms): <.main+2764>
test/lang/initByRef.ci:44:[.053309, .053312) exec(1), time(0.001-0.001 ms): <.main+2773>
test/lang/initByRef.ci:45:[.053312, .05331b) exec(1), time(0.001-0.001 ms): <.main+2782>
test/lang/initByRef.ci:46:[.05331b, .053324) exec(1), time(0.001-0.001 ms): <.main+2791>
test/lang/initByRef.ci:47:[.053324, .05332d) exec(1), time(0.001-0.001 ms): <.main+2800>
test/lang/initByRef.ci:48:[.05332d, .053336) exec(1), time(0.001-0.001 ms): <.main+2809>
test/lang/initByRef.ci:49:[.053336, .05333f) exec(1), time(0.001-0.001 ms): <.main+2818>
test/lang/initByRef.ci:50:[.05333f, .053348) exec(1), time(0.001-0.001 ms): <.main+2827>
test/lang/initByRef.ci:51:[.053348, .053351) exec(1), time(0.001-0.001 ms): <.main+2836>
test/lang/initByRef.ci:52:[.053351, .05335a) exec(1), time(0.001-0.001 ms): <.main+2845>
test/lang/initByRef.ci:55:[.05335a, .053368) exec(1), time(0.002-0.002 ms): <.main+2854>
test/lang/initByRef.ci:56:[.053368, .053376) exec(1), time(0.002-0.002 ms): <.main+2868>
test/lang/initByRef.ci:57:[.053376, .053384) exec(1), time(0.002-0.002 ms): <.main+2882>
test/lang/initByRef.ci:58:[.053384, .053392) exec(1), time(0.002-0.002 ms): <.main+2896>
test/lang/initByRef.ci:59:[.053392, .0533a0) exec(1), time(0.002-0.002 ms): <.main+2910>
test/lang/initByRef.ci:60:[.0533a0, .0533ae) exec(1), time(0.002-0.002 ms): <.main+2924>
test/lang/initByRef.ci:61:[.0533ae, .0533bc) exec(1), time(0.002-0.002 ms): <.main+2938>
test/lang/initByRef.ci:62:[.0533bc, .0533ca) exec(1), time(0.002-0.002 ms): <.main+2952>
test/lang/initByRef.ci:63:[.0533ca, .0533d8) exec(1), time(0.002-0.002 ms): <.main+2966>
test/lang/initByRef.ci:64:[.0533d8, .0533e6) exec(1), time(0.001-0.001 ms): <.main+2980>
test/lang/initByRef.ci:65:[.0533e6, .0533f4) exec(1), time(0.001-0.001 ms): <.main+2994>
test/lang/initByRef.ci:66:[.0533f4, .053402) exec(1), time(0.001-0.001 ms): <.main+3008>
test/lang/initByRef.ci:67:[.053402, .053410) exec(1), time(0.001-0.001 ms): <.main+3022>
test/lang/initByRef.ci:68:[.053410, .05341e) exec(1), time(0.002-0.002 ms): <.main+3036>
test/lang/initByRef.ci:69:[.05341e, .05342c) exec(1), time(0.002-0.002 ms): <.main+3050>
test/lang/initByRef.ci:70:[.05342c, .05343a) exec(1), time(0.002-0.002 ms): <.main+3064>
test/lang/initByRef.ci:71:[.05343a, .053448) exec(1), time(0.002-0.002 ms): <.main+3078>
test/lang/initByRef.ci:72:[.053448, .053456) exec(1), time(0.002-0.002 ms): <.main+3092>
test/lang/initByRef.ci:75:[.053456, .05345f) exec(1), time(0.002-0.002 ms): <.main+3106>
test/lang/initByRef.ci:76:[.05345f, .053468) exec(1), time(0.001-0.001 ms): <.main+3115>
test/lang/initByRef.ci:77:[.053468, .053471) exec(1), time(0.001-0.001 ms): <.main+3124>
test/lang/initByRef.ci:78:[.053471, .05347a) exec(1), time(0.002-0.002 ms): <.main+3133>
test/lang/initByRef.ci:79:[.05347a, .053483) exec(1), time(0.001-0.001 ms): <.main+3142>
test/lang/initByRef.ci:80:[.053483, .05348c) exec(1), time(0.001-0.001 ms): <.main+3151>
test/lang/initByRef.ci:81:[.05348c, .053495) exec(1), time(0.001-0.001 ms): <.main+3160>
test/lang/initByRef.ci:82:[.053495, .05349e) exec(1), time(0.001-0.001 ms): <.main+3169>
test/lang/initByRef.ci:83:[.05349e, .0534a7) exec(1), time(0.001-0.001 ms): <.main+3178>
test/lang/initByRef.ci:84:[.0534a7, .0534b0) exec(1), time(0.001-0.001 ms): <.main+3187>
test/lang/initByRef.ci:85:[.0534b0, .0534b9) exec(1), time(0.001-0.001 ms): <.main+3196>
test/lang/initByRef.ci:86:[.0534b9, .0534c2) exec(1), time(0.002-0.002 ms): <.main+3205>
test/lang/initByRef.ci:87:[.0534c2, .0534cb) exec(1), time(0.001-0.001 ms): <.main+3214>
test/lang/initByRef.ci:88:[.0534cb, .0534d4) exec(1), time(0.001-0.001 ms): <.main+3223>
test/lang/initByRef.ci:89:[.0534d4, .0534dd) exec(1), time(0.001-0.001 ms): <.main+3232>
test/lang/initByRef.ci:90:[.0534dd, .0534e6) exec(1), time(0.001-0.001 ms): <.main+3241>
test/lang/initByRef.ci:91:[.0534e6, .0534ef) exec(1), time(0.002-0.002 ms): <.main+3250>
test/lang/initByRef.ci:92:[.0534ef, .0534f8) exec(1), time(0.001-0.001 ms): <.main+3259>
test/lang/initByRef.ci:95:[.0534f8, .053501) exec(1), time(0.001-0.001 ms): <.main+3268>
test/lang/initByRef.ci:96:[.053501, .05350f) exec(1), time(0.001-0.001 ms): <.main+3277>
test/lang/initByRef.ci:97:[.05350f, .053518) exec(1), time(0.001-0.001 ms): <.main+3291>
test/lang/initByRef.ci:99:[.053518, .053521) exec(1), time(0.001-0.001 ms): <.main+3300>
test/lang/initByRef.ci:105:[.053521, .05352e) exec(1), time(0.002-0.002 ms): <.main+3309>
test/lang/initByRef.ci:108:[.05352e, .053536) exec(1), time(0.001-0.001 ms): <.main+3322>
test/lang/function.ci:12:[.053536, .05354f) exec(1), time(0.027-0.027 ms): <.main+3330>
test/lang/function.ci:15:[.05354f, .053558) exec(1), time(0.001-0.001 ms): <.main+3355>
test/lang/function.ci:18:[.053558, .053570) exec(1), time(0.024-0.024 ms): <.main+3364>
test/lang/function.ci:21:[.053570, .053579) exec(1), time(0.001-0.001 ms): <.main+3388>
test/lang/function.ci:24:[.053579, .053591) exec(1), time(0.025-0.025 ms): <.main+3397>
test/lang/function.ci:27:[.053591, .053599) exec(1), time(0.001-0.001 ms): <.main+3421>
test/lang/function.ci:30:[.053599, .0535b1) exec(1), time(0.024-0.024 ms): <.main+3429>
test/lang/function.ci:46:[.0535b1, .0535c5) exec(1), time(16.706-16.706 ms): <.main+3453>
test/lang/reflect.ci:3:[.0535c5, .0535cd) exec(1), time(0.001-0.001 ms): <.main+3473>
test/lang/reflect.ci:4:[.0535cd, .0535d5) exec(1), time(0.001-0.001 ms): <.main+3481>
test/lang/reflect.ci:5:[.0535d5, .0535dd) exec(1), time(0.002-0.002 ms): <.main+3489>
test/lang/reflect.ci:6:[.0535dd, .0535e5) exec(1), time(0.001-0.001 ms): <.main+3497>
test/lang/reflect.ci:7:[.0535e5, .0535ed) exec(1), time(0.001-0.001 ms): <.main+3505>
test/lang/reflect.ci:8:[.0535ed, .0535f5) exec(1), time(0.001-0.001 ms): <.main+3513>
test/lang/reflect.ci:9:[.0535f5, .0535fd) exec(1), time(0.001-0.001 ms): <.main+3521>
test/lang/reflect.ci:10:[.0535fd, .053605) exec(1), time(0.001-0.001 ms): <.main+3529>
test/lang/reflect.ci:11:[.053605, .05360d) exec(1), time(0.001-0.001 ms): <.main+3537>
test/lang/reflect.ci:12:[.05360d, .053615) exec(1), time(0.002-0.002 ms): <.main+3545>
test/lang/reflect.ci:13:[.053615, .05361d) exec(1), time(0.001-0.001 ms): <.main+3553>
test/lang/reflect.ci:14:[.05361d, .053625) exec(1), time(0.001-0.001 ms): <.main+3561>
test/lang/reflect.ci:15:[.053625, .05362d) exec(1), time(0.001-0.001 ms): <.main+3569>
test/lang/reflect.ci:16:[.05362d, .053635) exec(1), time(0.001-0.001 ms): <.main+3577>
test/lang/reflect.ci:17:[.053635, .05363d) exec(1), time(0.002-0.002 ms): <.main+3585>
test/lang/reflect.ci:18:[.05363d, .053645) exec(1), time(0.001-0.001 ms): <.main+3593>
test/lang/reflect.ci:19:[.053645, .05364d) exec(1), time(0.001-0.001 ms): <.main+3601>
test/lang/reflect.ci:20:[.05364d, .053655) exec(1), time(0.001-0.001 ms): <.main+3609>
test/lang/reflect.ci:30:[.053655, .05365e) exec(1), time(0.001-0.001 ms): <.main+3617>
test/lang/reflect.ci:31:[.05365e, .05366a) exec(1), time(0.034-0.034 ms): <.main+3626>
test/lang/reflect.ci:32:[.05366a, .053677) exec(1), time(0.003-0.003 ms): <.main+3638>
test/lang/reflect.ci:33:[.053677, .053684) exec(1), time(0.003-0.003 ms): <.main+3651>
test/lang/reflect.ci:34:[.053684, .053690) exec(1), time(0.026-0.026 ms): <.main+3664>
test/lang/reflect.ci:35:[.053690, .05369c) exec(1), time(0.026-0.026 ms): <.main+3676>
test/lang/reflect.ci:37:[.05369c, .0536a8) exec(1), time(0.026-0.026 ms): <.main+3688>
test/lang/reflect.ci:38:[.0536a8, .0536b4) exec(1), time(0.026-0.026 ms): <.main+3700>
test/lang/reflect.ci:39:[.0536b4, .0536c1) exec(1), time(0.003-0.003 ms): <.main+3712>
test/lang/reflect.ci:40:[.0536c1, .0536ce) exec(1), time(0.003-0.003 ms): <.main+3725>
test/lang/reflect.ci:41:[.0536ce, .0536da) exec(1), time(0.028-0.028 ms): <.main+3738>
test/lang/reflect.ci:42:[.0536da, .0536e6) exec(1), time(0.027-0.027 ms): <.main+3750>
test/lang/reflect.ci:44:[.0536e6, .0536f2) exec(1), time(0.026-0.026 ms): <.main+3762>
test/lang/reflect.ci:45:[.0536f2, .0536ff) exec(1), time(0.002-0.002 ms): <.main+3774>
test/lang/reflect.ci:46:[.0536ff, .05370c) exec(1), time(0.002-0.002 ms): <.main+3787>
test/lang/reflect.ci:48:[.05370c, .053718) exec(1), time(0.024-0.024 ms): <.main+3800>
test/lang/reflect.ci:49:[.053718, .053725) exec(1), time(0.003-0.003 ms): <.main+3812>
test/lang/reflect.ci:50:[.053725, .053732) exec(1), time(0.003-0.003 ms): <.main+3825>
test/stdc/number.ci:3:[.053732, .05373f) exec(1), time(0.001-0.001 ms): <.main+3838>
test/stdc/number.ci:4:[.05373f, .05374c) exec(1), time(0.001-0.001 ms): <.main+3851>
test/stdc/number.ci:6:[.05374c, .053755) exec(1), time(0.002-0.002 ms): <.main+3864>
test/stdc/number.ci:7:[.053755, .05375e) exec(1), time(0.002-0.002 ms): <.main+3873>
test/stdc/number.ci:14:[.05375e, .053769) exec(1), time(0.002-0.002 ms): <.main+3882>
test/stdc/number.ci:15:[.053769, .053774) exec(1), time(0.002-0.002 ms): <.main+3893>
test/stdc/number.ci:16:[.053774, .05377f) exec(1), time(0.002-0.002 ms): <.main+3904>
test/stdc/number.ci:18:[.05377f, .0537a5) exec(1), time(0.009-0.009 ms): <.main+3915>
test/stdc/number.ci:19:[.0537a5, .0537c9) exec(1), time(0.009-0.009 ms): <.main+3953>
test/stdc/number.ci:21:[.0537c9, .0537df) exec(1), time(0.027-0.027 ms): <.main+3989>
test/stdc/number.ci:22:[.0537df, .0537f5) exec(1), time(0.026-0.026 ms): <.main+4011>
test/stdc/number.ci:23:[.0537f5, .053807) exec(1), time(0.027-0.027 ms): <.main+4033>
test/stdc/number.ci:25:[.053807, .05381d) exec(1), time(0.032-0.032 ms): <.main+4051>
test/stdc/number.ci:26:[.05381d, .053833) exec(1), time(0.026-0.026 ms): <.main+4073>
test/stdc/number.ci:27:[.053833, .053845) exec(1), time(0.026-0.026 ms): <.main+4095>
test/stdc/number.ci:29:[.053845, .05385b) exec(1), time(0.027-0.027 ms): <.main+4113>
test/stdc/number.ci:30:[.05385b, .053871) exec(1), time(0.027-0.027 ms): <.main+4135>
test/stdc/number.ci:31:[.053871, .053883) exec(1), time(0.026-0.026 ms): <.main+4157>
test/stdc/number.ci:33:[.053883, .053899) exec(1), time(0.026-0.026 ms): <.main+4175>
test/stdc/number.ci:34:[.053899, .0538af) exec(1), time(0.026-0.026 ms): <.main+4197>
test/stdc/number.ci:35:[.0538af, .0538c1) exec(1), time(0.027-0.027 ms): <.main+4219>
test/stdc/number.ci:37:[.0538c1, .0538d7) exec(1), time(0.044-0.044 ms): <.main+4237>
test/stdc/number.ci:38:[.0538d7, .0538ed) exec(1), time(0.030-0.030 ms): <.main+4259>
test/stdc/number.ci:39:[.0538ed, .053903) exec(1), time(0.026-0.026 ms): <.main+4281>
test/stdc/number.ci:40:[.053903, .053919) exec(1), time(0.031-0.031 ms): <.main+4303>
test/stdc/number.ci:41:[.053919, .05392a) exec(1), time(0.025-0.025 ms): <.main+4325>
test/stdc/number.ci:42:[.05392a, .053944) exec(1), time(0.030-0.030 ms): <.main+4342>
test/stdc/number.ci:43:[.053944, .053955) exec(1), time(0.026-0.026 ms): <.main+4368>
test/stdc/number.ci:44:[.053955, .05396a) exec(1), time(0.028-0.028 ms): <.main+4385>
test/stdc/number.ci:46:[.05396a, .05397c) exec(1), time(0.029-0.029 ms): <.main+4406>
test/stdc/number.ci:47:[.05397c, .05398e) exec(1), time(0.027-0.027 ms): <.main+4424>
test/stdc/number.ci:48:[.05398e, .0539a0) exec(1), time(0.027-0.027 ms): <.main+4442>
test/stdc/number.ci:49:[.0539a0, .0539b6) exec(1), time(0.028-0.028 ms): <.main+4460>
test/stdc/number.ci:50:[.0539b6, .0539c3) exec(1), time(0.025-0.025 ms): <.main+4482>
test/stdc/number.ci:51:[.0539c3, .0539d9) exec(1), time(0.027-0.027 ms): <.main+4495>
test/stdc/number.ci:52:[.0539d9, .0539ea) exec(1), time(0.026-0.026 ms): <.main+4517>
test/stdc/number.ci:53:[.0539ea, .0539fb) exec(1), time(0.028-0.028 ms): <.main+4534>
test/stdc/number.ci:55:[.0539fb, .053a07) exec(1), time(0.025-0.025 ms): <.main+4551>
test/stdc/number.ci:56:[.053a07, .053a13) exec(1), time(0.025-0.025 ms): <.main+4563>
test/stdc/number.ci:57:[.053a13, .053a1f) exec(1), time(0.024-0.024 ms): <.main+4575>
test/stdc/number.ci:58:[.053a1f, .053a2b) exec(1), time(0.025-0.025 ms): <.main+4587>
test/stdc/number.ci:59:[.053a2b, .053a37) exec(1), time(0.025-0.025 ms): <.main+4599>
test/stdc/number.ci:60:[.053a37, .053a43) exec(1), time(0.025-0.025 ms): <.main+4611>
test/stdc/number.ci:62:[.053a43, .053a55) exec(1), time(0.026-0.026 ms): <.main+4623>
test/stdc/number.ci:63:[.053a55, .053a67) exec(1), time(0.026-0.026 ms): <.main+4641>
test/stdc/number.ci:65:[.053a67, .053a7b) exec(1), time(0.028-0.028 ms): <.main+4659>
test/stdc/number.ci:66:[.053a7b, .053a8f) exec(1), time(0.028-0.028 ms): <.main+4679>
test/stdc/memory.ci:7:[.053a8f, .053aa1) exec(1), time(0.026-0.026 ms): <.main+4699>
test/stdc/memory.ci:8:[.053aa1, .053ab3) exec(1), time(0.026-0.026 ms): <.main+4717>
test/stdc/memory.ci:9:[.053ab3, .053ac5) exec(1), time(0.026-0.026 ms): <.main+4735>
test/stdc/memory.ci:10:[.053ac5, .053ad7) exec(1), time(0.027-0.027 ms): <.main+4753>
test/stdc/memory.ci:23:[.053ad7, .053ae4) exec(1), time(0.001-0.001 ms): <.main+4771>
test/stdc/memory.ci:24:[.053ae4, .053af1) exec(1), time(0.001-0.001 ms): <.main+4784>
test/stdc/tryExec.ci:46:[.053af1, .053b03) exec(1), time(0.062-0.062 ms): <.main+4797>
test/stdc/tryExec.ci:47:[.053b03, .053b15) exec(1), time(0.028-0.028 ms): <.main+4815>
test/stdc/tryExec.ci:48:[.053b15, .053b27) exec(1), time(1.339-1.339 ms): <.main+4833>
test/stdc/tryExec.ci:49:[.053b27, .053b39) exec(1), time(0.043-0.043 ms): <.main+4851>
test/stdc/tryExec.ci:50:[.053b39, .053b4b) exec(1), time(0.041-0.041 ms): <.main+4869>
test/stdc/tryExec.ci:51:[.053b4b, .053b5d) exec(1), time(0.042-0.042 ms): <.main+4887>
test/stdc/tryExec.ci:52:[.053b5d, .053b6f) exec(1), time(0.155-0.155 ms): <.main+4905>
test/lang/array.ci:59:[.053b6f, .053b78) exec(1), time(0.001-0.001 ms): <.main+4923>
test/lang/array.ci:60:[.053b78, .053b82) exec(1), time(0.002-0.002 ms): <.main+4932>
test/lang/array.ci:63:[.053b82, .053b8b) exec(1), time(0.002-0.002 ms): <.main+4942>
test/lang/array.ci:64:[.053b8b, .053b99) exec(1), time(0.002-0.002 ms): <.main+4951>
test/lang/array.ci:67:[.053b99, .053ba1) exec(1), time(0.001-0.001 ms): <.main+4965>
test/lang/array.ci:68:[.053ba1, .053ba9) exec(1), time(0.002-0.002 ms): <.main+4973>
test/lang/array.ci:71:[.053ba9, .053bb1) exec(1), time(0.001-0.001 ms): <.main+4981>
test/lang/array.ci:86:[.053bb1, .053bba) exec(1), time(0.001-0.001 ms): <.main+4989>
test/lang/array.ci:90:[.053bba, .053bc8) exec(1), time(0.002-0.002 ms): <.main+4998>
test/lang/member.ci:35:[.053bc8, .053bcd) exec(1), time(0.001-0.001 ms): <.main+5012>
test/lang/member.ci:38:[.053bcd, .053bd6) exec(1), time(0.001-0.001 ms): <.main+5017>
test/lang/member.ci:41:[.053bd6, .053bdf) exec(1), time(0.001-0.001 ms): <.main+5026>
test/lang/member.ci:47:[.053be8, .053bf1) exec(1), time(0.002-0.002 ms): <.main+5044>
test/lang/member.ci:47:[.053bdf, .053bf1) exec(1-1), time(0.000 ms): <.main+5035>
test/lang/member.ci:50:[.053bfa, .053c03) exec(1), time(0.002-0.002 ms): <.main+5062>
test/lang/member.ci:50:[.053bf1, .053c03) exec(1-1), time(0.000 ms): <.main+5053>
test/lang/member.ci:55:[.053c0c, .053c15) exec(1), time(0.002-0.002 ms): <.main+5080>
test/lang/member.ci:56:[.053c15, .053c1e) exec(1), time(0.001-0.001 ms): <.main+5089>
test/lang/member.ci:57:[.053c1e, .053c27) exec(1), time(0.001-0.001 ms): <.main+5098>
test/lang/member.ci:60:[.053c27, .053c30) exec(1), time(0.002-0.002 ms): <.main+5107>
test/lang/member.ci:61:[.053c30, .053c39) exec(1), time(0.002-0.002 ms): <.main+5116>
test/lang/member.ci:65:[.053c39, .053c42) exec(1), time(0.001-0.001 ms): <.main+5125>
test/lang/member.ci:66:[.053c42, .053c4b) exec(1), time(0.001-0.001 ms): <.main+5134>
test/lang/member.ci:53:[.053c03, .053c4b) exec(1-1), time(0.000 ms): <.main+5071>
test/lang/method.ci:18:[.053c4b, .053c54) exec(1), time(0.002-0.002 ms): <.main+5143>
::[.053c5d, .053c65) exec(1), time(0.002-0.002 ms): <.main+5161>
::[.053c65, .053c6e) exec(1), time(0.001-0.001 ms): <.main+5169>
test/lang/method.ci:62:[.053c54, .053c6e) exec(1-1), time(0.000 ms): <.main+5152>
test/lang/recUnion.ci:26:[.053c75, .053c7c) exec(1), time(0.002-0.002 ms): <.main+5185>
test/lang/recUnion.ci:26:[.053c7c, .053c83) exec(1), time(0.003-0.003 ms): <.main+5192>
test/lang/recUnion.ci:26:[.053c6e, .053c83) exec(1-1), time(0.000 ms): <.main+5178>
test/lang/recUnion.ci:27:[.053c8a, .053c95) exec(1), time(0.002-0.002 ms): <.main+5206>
test/lang/recUnion.ci:27:[.053c95, .053c9c) exec(1), time(0.002-0.002 ms): <.main+5217>
test/lang/recUnion.ci:27:[.053c83, .053c9c) exec(1-1), time(0.000 ms): <.main+5199>
test/lang/recUnion.ci:28:[.053ca7, .053cb2) exec(1), time(0.003-0.003 ms): <.main+5235>
test/lang/recUnion.ci:28:[.053cb2, .053cbd) exec(1), time(0.002-0.002 ms): <.main+5246>
test/lang/recUnion.ci:28:[.053c9c, .053cbd) exec(1-1), time(0.000 ms): <.main+5224>
test/lang/recUnion.ci:30:[.053cbd, .053cc6) exec(1), time(0.001-0.001 ms): <.main+5257>
test/lang/recUnion.ci:31:[.053ccd, .053cd4) exec(1), time(0.003-0.003 ms): <.main+5273>
test/lang/recUnion.ci:31:[.053cd4, .053cdf) exec(1), time(0.002-0.002 ms): <.main+5280>
test/lang/recUnion.ci:31:[.053cc6, .053cdf) exec(1-1), time(0.000 ms): <.main+5266>
test/lang/useOperator.ci:5:[.053cdf, .053ce8) exec(1), time(0.001-0.001 ms): <.main+5291>
test/lang/useOperator.ci:7:[.053ce8, .053cf3) exec(1), time(0.002-0.002 ms): <.main+5300>
test/lang/useOperator.ci:8:[.053cf3, .053cfe) exec(1), time(0.002-0.002 ms): <.main+5311>
test/lang/useOperator.ci:17:[.053cfe, .053d11) exec(1), time(0.005-0.005 ms): <.main+5322>
test/lang/useOperator.ci:18:[.053d11, .053d24) exec(1), time(0.005-0.005 ms): <.main+5341>
test/lang/useOperator.ci:19:[.053d24, .053d37) exec(1), time(0.005-0.005 ms): <.main+5360>
test/lang/useOperator.ci:22:[.053d37, .053d44) exec(1), time(0.004-0.004 ms): <.main+5379>
test/lang/useOperator.ci:23:[.053d44, .053d57) exec(1), time(0.006-0.006 ms): <.main+5392>
test/lang/useOperator.ci:24:[.053d57, .053d6b) exec(1), time(0.007-0.007 ms): <.main+5411>
test/lang/useOperator.ci:25:[.053d6b, .053d7e) exec(1), time(0.005-0.005 ms): <.main+5431>
test/lang/useOperator.ci:26:[.053d7e, .053d92) exec(1), time(0.006-0.006 ms): <.main+5450>
test/lang/useOperator.ci:27:[.053d92, .053da5) exec(1), time(0.005-0.005 ms): <.main+5470>
test/lang/useOperator.ci:28:[.053da5, .053db9) exec(1), time(0.006-0.006 ms): <.main+5489>
test/lang/useOperator.ci:30:[.053db9, .053dc4) exec(1), time(0.003-0.003 ms): <.main+5509>
test/lang/useOperator.ci:31:[.053dc4, .053dcf) exec(1), time(0.002-0.002 ms): <.main+5520>
test/lang/useOperator.ci:32:[.053dcf, .053ddb) exec(1), time(0.003-0.003 ms): <.main+5531>
test/lang/useOperator.ci:33:[.053ddb, .053de8) exec(1), time(0.004-0.004 ms): <.main+5543>
test/lang/useOperator.ci:34:[.053de8, .053df5) exec(1), time(0.004-0.004 ms): <.main+5556>
test/lang/useOperator.ci:35:[.053df5, .053e08) exec(1), time(0.006-0.006 ms): <.main+5569>
test/lang/useOperator.ci:36:[.053e08, .053e1b) exec(1), time(0.006-0.006 ms): <.main+5588>
test/lang/useOperator.ci:37:[.053e1b, .053e2e) exec(1), time(0.006-0.006 ms): <.main+5607>
test/lang/useOperator.ci:38:[.053e2e, .053e41) exec(1), time(0.006-0.006 ms): <.main+5626>
test/lang/useOperator.ci:39:[.053e41, .053e54) exec(1), time(0.006-0.006 ms): <.main+5645>
test/lang/useOperator.ci:40:[.053e54, .053e67) exec(1), time(0.006-0.006 ms): <.main+5664>
test/lang/useOperator.ci:41:[.053e67, .053e7a) exec(1), time(0.006-0.006 ms): <.main+5683>
test/lang/useOperator.ci:42:[.053e7a, .053e8d) exec(1), time(0.005-0.005 ms): <.main+5702>
test/lang/useOperator.ci:43:[.053e8d, .053e9e) exec(1), time(0.004-0.004 ms): <.main+5721>
test/lang/useOperator.ci:44:[.053e9e, .053eaf) exec(1), time(0.004-0.004 ms): <.main+5738>
test/lang/useOperator.ci:45:[.053eaf, .053ebd) exec(1), time(0.005-0.005 ms): <.main+5755>
test/lang/useOperator.ci:46:[.053ebd, .053ed0) exec(1), time(0.006-0.006 ms): <.main+5769>
test/lang/useOperator.ci:47:[.053ed0, .053ee4) exec(1), time(0.007-0.007 ms): <.main+5788>
test/lang/useOperator.ci:48:[.053ee4, .053ef7) exec(1), time(0.006-0.006 ms): <.main+5808>
test/lang/useOperator.ci:49:[.053ef7, .053f0b) exec(1), time(0.006-0.006 ms): <.main+5827>
test/lang/useOperator.ci:50:[.053f0b, .053f1e) exec(1), time(0.005-0.005 ms): <.main+5847>
test/lang/useOperator.ci:51:[.053f1e, .053f32) exec(1), time(0.006-0.006 ms): <.main+5866>
test/lang/useOperator.ci:53:[.053f32, .053f3d) exec(1), time(0.002-0.002 ms): <.main+5886>
test/lang/useOperator.ci:54:[.053f3d, .053f48) exec(1), time(0.003-0.003 ms): <.main+5897>
test/lang/useOperator.ci:55:[.053f48, .053f54) exec(1), time(0.003-0.003 ms): <.main+5908>
test/lang/useOperator.ci:56:[.053f54, .053f61) exec(1), time(0.004-0.004 ms): <.main+5920>
test/lang/useOperator.ci:57:[.053f61, .053f6e) exec(1), time(0.004-0.004 ms): <.main+5933>
test/lang/useOperator.ci:58:[.053f6e, .053f81) exec(1), time(0.006-0.006 ms): <.main+5946>
test/lang/useOperator.ci:59:[.053f81, .053f94) exec(1), time(0.006-0.006 ms): <.main+5965>
test/lang/useOperator.ci:60:[.053f94, .053fa7) exec(1), time(0.006-0.006 ms): <.main+5984>
test/lang/useOperator.ci:61:[.053fa7, .053fba) exec(1), time(0.006-0.006 ms): <.main+6003>
test/lang/useOperator.ci:62:[.053fba, .053fcd) exec(1), time(0.006-0.006 ms): <.main+6022>
test/lang/useOperator.ci:63:[.053fcd, .053fe0) exec(1), time(0.006-0.006 ms): <.main+6041>
test/lang/useOperator.ci:64:[.053fe0, .053ff3) exec(1), time(0.006-0.006 ms): <.main+6060>
test/lang/useOperator.ci:65:[.053ff3, .054006) exec(1), time(0.005-0.005 ms): <.main+6079>
test/lang/useOperator.ci:66:[.054006, .054017) exec(1), time(0.005-0.005 ms): <.main+6098>
test/lang/useOperator.ci:67:[.054017, .054028) exec(1), time(0.005-0.005 ms): <.main+6115>
test/lang/useOperator.ci:68:[.054028, .054036) exec(1), time(0.005-0.005 ms): <.main+6132>
test/lang/useOperator.ci:69:[.054036, .054049) exec(1), time(0.006-0.006 ms): <.main+6146>
test/lang/useOperator.ci:70:[.054049, .05405d) exec(1), time(0.006-0.006 ms): <.main+6165>
test/lang/useOperator.ci:71:[.05405d, .054070) exec(1), time(0.006-0.006 ms): <.main+6185>
test/lang/useOperator.ci:72:[.054070, .054084) exec(1), time(0.006-0.006 ms): <.main+6204>
test/lang/useOperator.ci:73:[.054084, .054097) exec(1), time(0.005-0.005 ms): <.main+6224>
test/lang/useOperator.ci:74:[.054097, .0540ab) exec(1), time(0.006-0.006 ms): <.main+6243>
test/lang/useOperator.ci:76:[.0540ab, .0540b6) exec(1), time(0.002-0.002 ms): <.main+6263>
test/lang/useOperator.ci:77:[.0540b6, .0540c1) exec(1), time(0.002-0.002 ms): <.main+6274>
test/lang/useOperator.ci:78:[.0540c1, .0540cd) exec(1), time(0.004-0.004 ms): <.main+6285>
test/lang/useOperator.ci:79:[.0540cd, .0540da) exec(1), time(0.004-0.004 ms): <.main+6297>
test/lang/useOperator.ci:80:[.0540da, .0540e7) exec(1), time(0.004-0.004 ms): <.main+6310>
test/lang/useOperator.ci:81:[.0540e7, .0540fa) exec(1), time(0.006-0.006 ms): <.main+6323>
test/lang/useOperator.ci:82:[.0540fa, .05410d) exec(1), time(0.006-0.006 ms): <.main+6342>
test/lang/useOperator.ci:83:[.05410d, .054120) exec(1), time(0.006-0.006 ms): <.main+6361>
test/lang/useOperator.ci:84:[.054120, .054133) exec(1), time(0.005-0.005 ms): <.main+6380>
test/lang/useOperator.ci:85:[.054133, .054146) exec(1), time(0.006-0.006 ms): <.main+6399>
test/lang/useOperator.ci:86:[.054146, .054159) exec(1), time(0.006-0.006 ms): <.main+6418>
test/lang/useOperator.ci:87:[.054159, .05416c) exec(1), time(0.006-0.006 ms): <.main+6437>
test/lang/useOperator.ci:88:[.05416c, .05417f) exec(1), time(0.006-0.006 ms): <.main+6456>
test/lang/useOperator.ci:89:[.05417f, .054190) exec(1), time(0.004-0.004 ms): <.main+6475>
test/lang/useOperator.ci:90:[.054190, .0541a1) exec(1), time(0.005-0.005 ms): <.main+6492>
test/lang/useOperator.ci:91:[.0541a1, .0541af) exec(1), time(0.005-0.005 ms): <.main+6509>
test/lang/useOperator.ci:92:[.0541af, .0541c2) exec(1), time(0.005-0.005 ms): <.main+6523>
test/lang/useOperator.ci:93:[.0541c2, .0541d6) exec(1), time(0.007-0.007 ms): <.main+6542>
test/lang/useOperator.ci:94:[.0541d6, .0541e9) exec(1), time(0.006-0.006 ms): <.main+6562>
test/lang/useOperator.ci:95:[.0541e9, .0541fd) exec(1), time(0.007-0.007 ms): <.main+6581>
test/lang/useOperator.ci:96:[.0541fd, .054210) exec(1), time(0.006-0.006 ms): <.main+6601>
test/lang/useOperator.ci:97:[.054210, .054224) exec(1), time(0.006-0.006 ms): <.main+6620>
test/lang/useOperator.ci:99:[.054224, .05422f) exec(1), time(0.002-0.002 ms): <.main+6640>
test/lang/useOperator.ci:100:[.05422f, .05423a) exec(1), time(0.002-0.002 ms): <.main+6651>
test/lang/useOperator.ci:101:[.05423a, .054246) exec(1), time(0.004-0.004 ms): <.main+6662>
test/lang/useOperator.ci:102:[.054246, .054253) exec(1), time(0.004-0.004 ms): <.main+6674>
test/lang/useOperator.ci:103:[.054253, .054260) exec(1), time(0.005-0.005 ms): <.main+6687>
test/lang/useOperator.ci:104:[.054260, .054273) exec(1), time(0.006-0.006 ms): <.main+6700>
test/lang/useOperator.ci:105:[.054273, .054286) exec(1), time(0.006-0.006 ms): <.main+6719>
test/lang/useOperator.ci:106:[.054286, .054299) exec(1), time(0.005-0.005 ms): <.main+6738>
test/lang/useOperator.ci:107:[.054299, .0542ac) exec(1), time(0.006-0.006 ms): <.main+6757>
test/lang/useOperator.ci:108:[.0542ac, .0542bf) exec(1), time(0.006-0.006 ms): <.main+6776>
test/lang/useOperator.ci:109:[.0542bf, .0542d2) exec(1), time(0.006-0.006 ms): <.main+6795>
test/lang/useOperator.ci:110:[.0542d2, .0542e5) exec(1), time(0.006-0.006 ms): <.main+6814>
test/lang/useOperator.ci:111:[.0542e5, .0542f8) exec(1), time(0.006-0.006 ms): <.main+6833>
test/lang/useOperator.ci:112:[.0542f8, .054309) exec(1), time(0.005-0.005 ms): <.main+6852>
test/lang/useOperator.ci:113:[.054309, .05431a) exec(1), time(0.005-0.005 ms): <.main+6869>
test/lang/useOperator.ci:114:[.05431a, .054328) exec(1), time(0.005-0.005 ms): <.main+6886>
test/lang/useOperator.ci:115:[.054328, .05433b) exec(1), time(0.005-0.005 ms): <.main+6900>
test/lang/useOperator.ci:116:[.05433b, .05434f) exec(1), time(0.007-0.007 ms): <.main+6919>
test/lang/useOperator.ci:117:[.05434f, .054362) exec(1), time(0.006-0.006 ms): <.main+6939>
test/lang/useOperator.ci:118:[.054362, .054376) exec(1), time(0.007-0.007 ms): <.main+6958>
test/lang/useOperator.ci:119:[.054376, .054389) exec(1), time(0.006-0.006 ms): <.main+6978>
test/lang/useOperator.ci:120:[.054389, .05439d) exec(1), time(0.007-0.007 ms): <.main+6997>
test/lang/useOperator.ci:122:[.05439d, .0543a8) exec(1), time(0.003-0.003 ms): <.main+7017>
test/lang/useOperator.ci:123:[.0543a8, .0543b3) exec(1), time(0.003-0.003 ms): <.main+7028>
test/lang/useOperator.ci:124:[.0543b3, .0543bf) exec(1), time(0.003-0.003 ms): <.main+7039>
test/lang/useOperator.ci:125:[.0543bf, .0543cc) exec(1), time(0.004-0.004 ms): <.main+7051>
test/lang/useOperator.ci:126:[.0543cc, .0543d9) exec(1), time(0.005-0.005 ms): <.main+7064>
test/lang/useOperator.ci:127:[.0543d9, .0543ec) exec(1), time(0.006-0.006 ms): <.main+7077>
test/lang/useOperator.ci:128:[.0543ec, .0543ff) exec(1), time(0.006-0.006 ms): <.main+7096>
test/lang/useOperator.ci:129:[.0543ff, .054412) exec(1), time(0.006-0.006 ms): <.main+7115>
test/lang/useOperator.ci:130:[.054412, .054425) exec(1), time(0.006-0.006 ms): <.main+7134>
test/lang/useOperator.ci:131:[.054425, .054438) exec(1), time(0.006-0.006 ms): <.main+7153>
test/lang/useOperator.ci:132:[.054438, .05444b) exec(1), time(0.006-0.006 ms): <.main+7172>
test/lang/useOperator.ci:133:[.05444b, .05445e) exec(1), time(0.006-0.006 ms): <.main+7191>
test/lang/useOperator.ci:134:[.05445e, .054471) exec(1), time(0.006-0.006 ms): <.main+7210>
test/lang/useOperator.ci:135:[.054471, .054482) exec(1), time(0.005-0.005 ms): <.main+7229>
test/lang/useOperator.ci:136:[.054482, .054493) exec(1), time(0.005-0.005 ms): <.main+7246>
test/lang/useOperator.ci:137:[.054493, .0544a1) exec(1), time(0.005-0.005 ms): <.main+7263>
test/lang/useOperator.ci:138:[.0544a1, .0544b4) exec(1), time(0.006-0.006 ms): <.main+7277>
test/lang/useOperator.ci:139:[.0544b4, .0544c8) exec(1), time(0.007-0.007 ms): <.main+7296>
test/lang/useOperator.ci:140:[.0544c8, .0544db) exec(1), time(0.006-0.006 ms): <.main+7316>
test/lang/useOperator.ci:141:[.0544db, .0544ef) exec(1), time(0.007-0.007 ms): <.main+7335>
test/lang/useOperator.ci:142:[.0544ef, .054502) exec(1), time(0.006-0.006 ms): <.main+7355>
test/lang/useOperator.ci:143:[.054502, .054516) exec(1), time(0.007-0.007 ms): <.main+7374>
test/lang/useOperator.ci:145:[.054516, .05451f) exec(1), time(0.002-0.002 ms): <.main+7394>
test/lang/useOperator.ci:146:[.05451f, .054528) exec(1), time(0.002-0.002 ms): <.main+7403>
test/lang/useOperator.ci:147:[.054528, .054530) exec(1), time(0.002-0.002 ms): <.main+7412>
test/lang/useOperator.ci:148:[.054530, .054539) exec(1), time(0.003-0.003 ms): <.main+7420>
test/lang/useOperator.ci:149:[.054539, .054542) exec(1), time(0.003-0.003 ms): <.main+7429>
test/lang/useOperator.ci:150:[.054542, .05454f) exec(1), time(0.003-0.003 ms): <.main+7438>
test/lang/useOperator.ci:151:[.05454f, .05455c) exec(1), time(0.003-0.003 ms): <.main+7451>
test/lang/useOperator.ci:152:[.05455c, .054569) exec(1), time(0.003-0.003 ms): <.main+7464>
test/lang/useOperator.ci:153:[.054569, .054576) exec(1), time(0.004-0.004 ms): <.main+7477>
test/lang/useOperator.ci:154:[.054576, .054583) exec(1), time(0.004-0.004 ms): <.main+7490>
test/lang/useOperator.ci:155:[.054583, .054590) exec(1), time(0.004-0.004 ms): <.main+7503>
test/lang/useOperator.ci:156:[.054590, .05459d) exec(1), time(0.003-0.003 ms): <.main+7516>
test/lang/useOperator.ci:157:[.05459d, .0545aa) exec(1), time(0.003-0.003 ms): <.main+7529>
test/lang/useOperator.ci:158:[.0545aa, .0545b7) exec(1), time(0.003-0.003 ms): <.main+7542>
test/lang/useOperator.ci:159:[.0545b7, .0545c4) exec(1), time(0.003-0.003 ms): <.main+7555>
test/lang/useOperator.ci:160:[.0545c4, .0545d0) exec(1), time(0.005-0.005 ms): <.main+7568>
test/lang/useOperator.ci:161:[.0545d0, .0545df) exec(1), time(0.004-0.004 ms): <.main+7580>
test/lang/useOperator.ci:162:[.0545df, .0545ef) exec(1), time(0.005-0.005 ms): <.main+7595>
test/lang/useOperator.ci:163:[.0545ef, .0545fe) exec(1), time(0.004-0.004 ms): <.main+7611>
test/lang/useOperator.ci:164:[.0545fe, .05460e) exec(1), time(0.006-0.006 ms): <.main+7626>
test/lang/useOperator.ci:165:[.05460e, .05461d) exec(1), time(0.004-0.004 ms): <.main+7642>
test/lang/useOperator.ci:166:[.05461d, .05462d) exec(1), time(0.005-0.005 ms): <.main+7657>
test/lang/useOperator.ci:168:[.05462d, .054636) exec(1), time(0.001-0.001 ms): <.main+7673>
test/lang/useOperator.ci:169:[.054636, .05463f) exec(1), time(0.001-0.001 ms): <.main+7682>
test/lang/useOperator.ci:170:[.05463f, .054647) exec(1), time(0.001-0.001 ms): <.main+7691>
test/lang/useOperator.ci:171:[.054647, .054650) exec(1), time(0.002-0.002 ms): <.main+7699>
test/lang/useOperator.ci:172:[.054650, .054659) exec(1), time(0.002-0.002 ms): <.main+7708>
test/lang/useOperator.ci:173:[.054659, .054666) exec(1), time(0.003-0.003 ms): <.main+7717>
test/lang/useOperator.ci:174:[.054666, .054673) exec(1), time(0.003-0.003 ms): <.main+7730>
test/lang/useOperator.ci:175:[.054673, .054680) exec(1), time(0.004-0.004 ms): <.main+7743>
test/lang/useOperator.ci:176:[.054680, .05468d) exec(1), time(0.004-0.004 ms): <.main+7756>
test/lang/useOperator.ci:177:[.05468d, .05469a) exec(1), time(0.004-0.004 ms): <.main+7769>
test/lang/useOperator.ci:178:[.05469a, .0546a7) exec(1), time(0.004-0.004 ms): <.main+7782>
test/lang/useOperator.ci:179:[.0546a7, .0546b4) exec(1), time(0.003-0.003 ms): <.main+7795>
test/lang/useOperator.ci:180:[.0546b4, .0546c1) exec(1), time(0.003-0.003 ms): <.main+7808>
test/lang/useOperator.ci:181:[.0546c1, .0546ce) exec(1), time(0.003-0.003 ms): <.main+7821>
test/lang/useOperator.ci:182:[.0546ce, .0546db) exec(1), time(0.003-0.003 ms): <.main+7834>
test/lang/useOperator.ci:183:[.0546db, .0546e7) exec(1), time(0.004-0.004 ms): <.main+7847>
test/lang/useOperator.ci:184:[.0546e7, .0546f6) exec(1), time(0.004-0.004 ms): <.main+7859>
test/lang/useOperator.ci:185:[.0546f6, .054706) exec(1), time(0.005-0.005 ms): <.main+7874>
test/lang/useOperator.ci:186:[.054706, .054715) exec(1), time(0.005-0.005 ms): <.main+7890>
test/lang/useOperator.ci:187:[.054715, .054725) exec(1), time(0.006-0.006 ms): <.main+7905>
test/lang/useOperator.ci:188:[.054725, .054734) exec(1), time(0.005-0.005 ms): <.main+7921>
test/lang/useOperator.ci:189:[.054734, .054744) exec(1), time(0.005-0.005 ms): <.main+7936>
test/lang/useOperator.ci:191:[.054744, .054751) exec(1), time(0.002-0.002 ms): <.main+7952>
test/lang/useOperator.ci:192:[.054751, .05475e) exec(1), time(0.002-0.002 ms): <.main+7965>
test/lang/useOperator.ci:193:[.05475e, .054766) exec(1), time(0.002-0.002 ms): <.main+7978>
test/lang/useOperator.ci:194:[.054766, .05476f) exec(1), time(0.003-0.003 ms): <.main+7986>
test/lang/useOperator.ci:195:[.05476f, .054778) exec(1), time(0.003-0.003 ms): <.main+7995>
test/lang/useOperator.ci:196:[.054778, .054785) exec(1), time(0.004-0.004 ms): <.main+8004>
test/lang/useOperator.ci:197:[.054785, .054792) exec(1), time(0.004-0.004 ms): <.main+8017>
test/lang/useOperator.ci:198:[.054792, .05479f) exec(1), time(0.004-0.004 ms): <.main+8030>
test/lang/useOperator.ci:199:[.05479f, .0547ac) exec(1), time(0.004-0.004 ms): <.main+8043>
test/lang/useOperator.ci:200:[.0547ac, .0547b9) exec(1), time(0.004-0.004 ms): <.main+8056>
test/lang/useOperator.ci:201:[.0547b9, .0547c6) exec(1), time(0.004-0.004 ms): <.main+8069>
test/lang/useOperator.ci:202:[.0547c6, .0547d3) exec(1), time(0.004-0.004 ms): <.main+8082>
test/lang/useOperator.ci:203:[.0547d3, .0547e0) exec(1), time(0.004-0.004 ms): <.main+8095>
test/lang/useOperator.ci:204:[.0547e0, .0547ed) exec(1), time(0.004-0.004 ms): <.main+8108>
test/lang/useOperator.ci:205:[.0547ed, .0547fa) exec(1), time(0.004-0.004 ms): <.main+8121>
test/lang/useOperator.ci:206:[.0547fa, .054806) exec(1), time(0.004-0.004 ms): <.main+8134>
test/lang/useOperator.ci:207:[.054806, .054815) exec(1), time(0.004-0.004 ms): <.main+8146>
test/lang/useOperator.ci:208:[.054815, .054825) exec(1), time(0.005-0.005 ms): <.main+8161>
test/lang/useOperator.ci:209:[.054825, .054834) exec(1), time(0.004-0.004 ms): <.main+8177>
test/lang/useOperator.ci:210:[.054834, .054844) exec(1), time(0.005-0.005 ms): <.main+8192>
test/lang/useOperator.ci:211:[.054844, .054853) exec(1), time(0.004-0.004 ms): <.main+8208>
test/lang/useOperator.ci:212:[.054853, .054863) exec(1), time(0.005-0.005 ms): <.main+8223>
test/lang/useOperator.ci:214:[.054863, .054870) exec(1), time(0.001-0.001 ms): <.main+8239>
test/lang/useOperator.ci:215:[.054870, .05487d) exec(1), time(0.002-0.002 ms): <.main+8252>
test/lang/useOperator.ci:216:[.05487d, .054885) exec(1), time(0.002-0.002 ms): <.main+8265>
test/lang/useOperator.ci:217:[.054885, .05488e) exec(1), time(0.003-0.003 ms): <.main+8273>
test/lang/useOperator.ci:218:[.05488e, .054897) exec(1), time(0.003-0.003 ms): <.main+8282>
test/lang/useOperator.ci:219:[.054897, .0548a4) exec(1), time(0.004-0.004 ms): <.main+8291>
test/lang/useOperator.ci:220:[.0548a4, .0548b1) exec(1), time(0.004-0.004 ms): <.main+8304>
test/lang/useOperator.ci:221:[.0548b1, .0548be) exec(1), time(0.003-0.003 ms): <.main+8317>
test/lang/useOperator.ci:222:[.0548be, .0548cb) exec(1), time(0.003-0.003 ms): <.main+8330>
test/lang/useOperator.ci:223:[.0548cb, .0548d8) exec(1), time(0.003-0.003 ms): <.main+8343>
test/lang/useOperator.ci:224:[.0548d8, .0548e5) exec(1), time(0.004-0.004 ms): <.main+8356>
test/lang/useOperator.ci:225:[.0548e5, .0548f2) exec(1), time(0.004-0.004 ms): <.main+8369>
test/lang/useOperator.ci:226:[.0548f2, .0548ff) exec(1), time(0.004-0.004 ms): <.main+8382>
test/lang/useOperator.ci:227:[.0548ff, .05490c) exec(1), time(0.004-0.004 ms): <.main+8395>
test/lang/useOperator.ci:228:[.05490c, .054919) exec(1), time(0.003-0.003 ms): <.main+8408>
test/lang/useOperator.ci:229:[.054919, .054925) exec(1), time(0.004-0.004 ms): <.main+8421>
test/lang/useOperator.ci:230:[.054925, .054934) exec(1), time(0.004-0.004 ms): <.main+8433>
test/lang/useOperator.ci:231:[.054934, .054944) exec(1), time(0.006-0.006 ms): <.main+8448>
test/lang/useOperator.ci:232:[.054944, .054953) exec(1), time(0.005-0.005 ms): <.main+8464>
test/lang/useOperator.ci:233:[.054953, .054963) exec(1), time(0.006-0.006 ms): <.main+8479>
test/lang/useOperator.ci:234:[.054963, .054972) exec(1), time(0.004-0.004 ms): <.main+8495>
test/lang/useOperator.ci:235:[.054972, .054982) exec(1), time(0.005-0.005 ms): <.main+8510>
test/lang/useOperator.ci:237:[.054982, .05498b) exec(1), time(0.002-0.002 ms): <.main+8526>
test/lang/useOperator.ci:238:[.05498b, .054994) exec(1), time(0.002-0.002 ms): <.main+8535>
test/lang/useOperator.ci:239:[.054994, .05499c) exec(1), time(0.002-0.002 ms): <.main+8544>
test/lang/useOperator.ci:240:[.05499c, .0549a5) exec(1), time(0.003-0.003 ms): <.main+8552>
test/lang/useOperator.ci:242:[.0549a5, .0549b2) exec(1), time(0.003-0.003 ms): <.main+8561>
test/lang/useOperator.ci:243:[.0549b2, .0549bf) exec(1), time(0.003-0.003 ms): <.main+8574>
test/lang/useOperator.ci:244:[.0549bf, .0549cc) exec(1), time(0.004-0.004 ms): <.main+8587>
test/lang/useOperator.ci:245:[.0549cc, .0549d9) exec(1), time(0.004-0.004 ms): <.main+8600>
test/lang/useOperator.ci:246:[.0549d9, .0549e6) exec(1), time(0.004-0.004 ms): <.main+8613>
test/lang/useOperator.ci:252:[.0549e6, .0549f2) exec(1), time(0.005-0.005 ms): <.main+8626>
test/lang/useOperator.ci:253:[.0549f2, .054a01) exec(1), time(0.005-0.005 ms): <.main+8638>
test/lang/useOperator.ci:254:[.054a01, .054a11) exec(1), time(0.005-0.005 ms): <.main+8653>
test/lang/useOperator.ci:255:[.054a11, .054a20) exec(1), time(0.005-0.005 ms): <.main+8669>
test/lang/useOperator.ci:256:[.054a20, .054a30) exec(1), time(0.006-0.006 ms): <.main+8684>
test/lang/useOperator.ci:257:[.054a30, .054a3f) exec(1), time(0.004-0.004 ms): <.main+8700>
test/lang/useOperator.ci:258:[.054a3f, .054a4f) exec(1), time(0.006-0.006 ms): <.main+8715>
test/lang/useOperator.ci:260:[.054a4f, .054a5c) exec(1), time(0.002-0.002 ms): <.main+8731>
test/lang/useOperator.ci:261:[.054a5c, .054a69) exec(1), time(0.002-0.002 ms): <.main+8744>
test/lang/useOperator.ci:262:[.054a69, .054a71) exec(1), time(0.001-0.001 ms): <.main+8757>
test/lang/useOperator.ci:263:[.054a71, .054a7a) exec(1), time(0.002-0.002 ms): <.main+8765>
test/lang/useOperator.ci:265:[.054a7a, .054a87) exec(1), time(0.004-0.004 ms): <.main+8774>
test/lang/useOperator.ci:266:[.054a87, .054a94) exec(1), time(0.004-0.004 ms): <.main+8787>
test/lang/useOperator.ci:267:[.054a94, .054aa1) exec(1), time(0.003-0.003 ms): <.main+8800>
test/lang/useOperator.ci:268:[.054aa1, .054aae) exec(1), time(0.004-0.004 ms): <.main+8813>
test/lang/useOperator.ci:269:[.054aae, .054abb) exec(1), time(0.004-0.004 ms): <.main+8826>
test/lang/useOperator.ci:275:[.054abb, .054ac7) exec(1), time(0.005-0.005 ms): <.main+8839>
test/lang/useOperator.ci:276:[.054ac7, .054ad6) exec(1), time(0.005-0.005 ms): <.main+8851>
test/lang/useOperator.ci:277:[.054ad6, .054ae6) exec(1), time(0.005-0.005 ms): <.main+8866>
test/lang/useOperator.ci:278:[.054ae6, .054af5) exec(1), time(0.005-0.005 ms): <.main+8882>
test/lang/useOperator.ci:279:[.054af5, .054b05) exec(1), time(0.005-0.005 ms): <.main+8897>
test/lang/useOperator.ci:280:[.054b05, .054b14) exec(1), time(0.005-0.005 ms): <.main+8913>
test/lang/useOperator.ci:281:[.054b14, .054b24) exec(1), time(0.006-0.006 ms): <.main+8928>
test/lang/useOperator.ci:283:[.054b24, .054b2d) exec(1), time(0.001-0.001 ms): <.main+8944>
test/lang/useOperator.ci:284:[.054b2d, .054b36) exec(1), time(0.002-0.002 ms): <.main+8953>
test/lang/useOperator.ci:299:[.054b36, .054b45) exec(1), time(0.005-0.005 ms): <.main+8962>
test/lang/useOperator.ci:300:[.054b45, .054b55) exec(1), time(0.005-0.005 ms): <.main+8977>
test/lang/statementIf.ci:26:[.054b55, .054b5a) exec(1), time(0.002-0.002 ms): <.main+8993>
test/lang/statementFor.ci:12:[.054b5a, .054b5f) exec(1), time(0.002-0.002 ms): <.main+8998>
test/stdc/test.math.ci:3:[.054b5f, .054b77) exec(1), time(0.040-0.040 ms): <.main+9003>
test/stdc/test.math.ci:4:[.054b77, .054b8f) exec(1), time(0.039-0.039 ms): <.main+9027>
test/stdc/test.math.ci:5:[.054b8f, .054ba7) exec(1), time(0.039-0.039 ms): <.main+9051>
test/stdc/test.math.ci:6:[.054ba7, .054bbf) exec(1), time(0.056-0.056 ms): <.main+9075>
test/stdc/test.math.ci:7:[.054bbf, .054bd7) exec(1), time(0.056-0.056 ms): <.main+9099>
test/stdc/test.math.ci:8:[.054bd7, .054bef) exec(1), time(0.056-0.056 ms): <.main+9123>
test/stdc/test.math.ci:10:[.054bef, .054c0c) exec(1), time(0.014-0.014 ms): <.main+9147>
test/stdc/test.math.ci:11:[.054c0c, .054c21) exec(1), time(0.013-0.013 ms): <.main+9176>
test/stdc/test.math.ci:12:[.054c21, .054c3e) exec(1), time(0.013-0.013 ms): <.main+9197>
test/stdc/test.math.ci:13:[.054c3e, .054c53) exec(1), time(0.012-0.012 ms): <.main+9226>
test/stdc/test.math.ci:14:[.054c53, .054c64) exec(1), time(0.012-0.012 ms): <.main+9247>
test/stdc/test.math.ci:15:[.054c64, .054c79) exec(1), time(0.012-0.012 ms): <.main+9264>
test/stdc/test.math.ci:17:[.054c79, .054c91) exec(1), time(0.023-0.023 ms): <.main+9285>
test/stdc/test.math.ci:18:[.054c91, .054ca0) exec(1), time(0.021-0.021 ms): <.main+9309>
test/stdc/test.math.ci:19:[.054ca0, .054cb8) exec(1), time(0.021-0.021 ms): <.main+9324>
test/stdc/test.math.ci:20:[.054cb8, .054ccd) exec(1), time(0.023-0.023 ms): <.main+9348>
test/stdc/test.math.ci:21:[.054ccd, .054cde) exec(1), time(0.023-0.023 ms): <.main+9369>
test/stdc/test.math.ci:22:[.054cde, .054cf3) exec(1), time(0.022-0.022 ms): <.main+9386>
test/stdc/test.math.ci:24:[.054cf3, .054d0d) exec(1), time(0.024-0.024 ms): <.main+9407>
test/stdc/test.math.ci:25:[.054d0d, .054d27) exec(1), time(0.024-0.024 ms): <.main+9433>
test/stdc/test.math.ci:26:[.054d27, .054d48) exec(1), time(0.023-0.023 ms): <.main+9459>
test/stdc/test.math.ci:27:[.054d48, .054d69) exec(1), time(0.023-0.023 ms): <.main+9492>
test/stdc/test.math.ci:29:[.054d69, .054d84) exec(1), time(0.026-0.026 ms): <.main+9525>
test/stdc/test.math.ci:30:[.054d84, .054da6) exec(1), time(0.025-0.025 ms): <.main+9552>
test/stdc/test.math.ci:32:[.054da6, .054dbf) exec(1), time(0.012-0.012 ms): <.main+9586>
test/stdc/test.math.ci:33:[.054dbf, .054ddf) exec(1), time(0.011-0.011 ms): <.main+9611>
test/stdc/test.math.ci:35:[.054ddf, .054e1f) exec(1), time(0.047-0.047 ms): <.main+9643>
test/stdc/test.math.ci:36:[.054e1f, .054e71) exec(1), time(0.045-0.045 ms): <.main+9707>
test/stdc/test.math.ci:38:[.054e71, .054e8a) exec(1), time(0.027-0.027 ms): <.main+9789>
test/stdc/test.math.ci:39:[.054e8a, .054ef8) exec(1), time(0.075-0.075 ms): <.main+9814>
test/stdc/test.math.ci:40:[.054ef8, .054f11) exec(1), time(0.027-0.027 ms): <.main+9924>
test/stdc/test.math.ci:41:[.054f11, .054f7f) exec(1), time(0.085-0.085 ms): <.main+9949>
test/stdc/test.math.ci:43:[.054f7f, .054f98) exec(1), time(0.030-0.030 ms): <.main+10059>
test/stdc/test.math.ci:44:[.054f98, .054fbe) exec(1), time(0.035-0.035 ms): <.main+10084>
test/stdc/test.math.ci:45:[.054fbe, .054fed) exec(1), time(0.039-0.039 ms): <.main+10122>
test/stdc/test.math.ci:46:[.054fed, .055064) exec(1), time(0.081-0.081 ms): <.main+10169>
test/stdc/test.math.ci:48:[.055064, .055071) exec(1), time(0.002-0.002 ms): <.main+10288>
test/stdc/test.math.ci:49:[.055071, .05508e) exec(1), time(0.031-0.031 ms): <.main+10301>
test/stdc/test.math.ci:50:[.05508e, .05509b) exec(1), time(0.002-0.002 ms): <.main+10330>
test/stdc/test.math.ci:51:[.05509b, .0550b7) exec(1), time(0.006-0.006 ms): <.main+10343>
test/stdc/test.math.ci:52:[.0550b7, .0550e4) exec(1), time(0.013-0.013 ms): <.main+10371>
test/stdc/test.math.ci:53:[.0550e4, .055122) exec(1), time(0.020-0.020 ms): <.main+10416>
test/stdc/test.math.ci:54:[.055122, .055170) exec(1), time(0.059-0.059 ms): <.main+10478>
test/stdc/test.math.ci:55:[.055170, .0551c7) exec(1), time(0.071-0.071 ms): <.main+10556>
test/stdc/test.math.ci:57:[.0551c7, .0551ea) exec(1), time(0.048-0.048 ms): <.main+10643>
test/stdc/test.math.ci:58:[.0551ea, .05521b) exec(1), time(0.066-0.066 ms): <.main+10678>
test/stdc/test.math.ci:59:[.05521b, .05523d) exec(1), time(0.068-0.068 ms): <.main+10727>
test/stdc/test.math.ci:60:[.05523d, .05525f) exec(1), time(0.076-0.076 ms): <.main+10761>
test/stdc/test.math.ci:61:[.05525f, .055281) exec(1), time(0.069-0.069 ms): <.main+10795>
test/stdc/test.math.ci:63:[.055281, .055299) exec(1), time(0.076-0.076 ms): <.main+10829>
test/stdc/test.math.ci:64:[.055299, .0552c5) exec(1), time(0.080-0.080 ms): <.main+10853>
test/stdc/test.math.ci:67:[.0552c5, .0552e7) exec(1), time(0.031-0.031 ms): <.main+10897>
test/stdc/test.math.ci:68:[.0552e7, .055315) exec(1), time(0.031-0.031 ms): <.main+10931>
test/stdc/test.math.ci:70:[.055315, .055336) exec(1), time(0.024-0.024 ms): <.main+10977>
test/stdc/test.math.ci:71:[.055336, .05534e) exec(1), time(0.022-0.022 ms): <.main+11010>
test/stdc/test.math.ci:72:[.05534e, .05536f) exec(1), time(0.024-0.024 ms): <.main+11034>
test/stdc/test.math.ci:74:[.05536f, .055390) exec(1), time(0.023-0.023 ms): <.main+11067>
test/stdc/test.math.ci:75:[.055390, .0553b1) exec(1), time(0.023-0.023 ms): <.main+11100>
test/stdc/test.math.ci:76:[.0553b1, .0553d2) exec(1), time(0.023-0.023 ms): <.main+11133>
test/stdc/test.math.ci:77:[.0553d2, .0553f3) exec(1), time(0.023-0.023 ms): <.main+11166>
test/stdc/test.math.ci:79:[.0553f3, .055414) exec(1), time(0.023-0.023 ms): <.main+11199>
test/stdc/test.math.ci:80:[.055414, .055435) exec(1), time(0.024-0.024 ms): <.main+11232>
test/stdc/test.math.ci:81:[.055435, .055456) exec(1), time(0.024-0.024 ms): <.main+11265>
test/stdc/test.math.ci:82:[.055456, .055477) exec(1), time(0.024-0.024 ms): <.main+11298>
test/stdc/test.math.ci:84:[.055477, .055490) exec(1), time(0.024-0.024 ms): <.main+11331>
test/stdc/test.math.ci:85:[.055490, .0554a5) exec(1), time(0.023-0.023 ms): <.main+11356>
test/stdc/test.math.ci:86:[.0554a5, .0554be) exec(1), time(0.023-0.023 ms): <.main+11377>
test/stdc/test.math.ci:88:[.0554be, .0554d7) exec(1), time(0.024-0.024 ms): <.main+11402>
test/stdc/test.math.ci:89:[.0554d7, .0554f0) exec(1), time(0.023-0.023 ms): <.main+11427>
test/stdc/test.math.ci:90:[.0554f0, .055509) exec(1), time(0.023-0.023 ms): <.main+11452>
test/stdc/test.math.ci:91:[.055509, .055522) exec(1), time(0.023-0.023 ms): <.main+11477>
test/stdc/test.math.ci:93:[.055522, .05553b) exec(1), time(0.023-0.023 ms): <.main+11502>
test/stdc/test.math.ci:94:[.05553b, .055554) exec(1), time(0.024-0.024 ms): <.main+11527>
test/stdc/test.math.ci:95:[.055554, .05556d) exec(1), time(0.024-0.024 ms): <.main+11552>
test/stdc/test.math.ci:96:[.05556d, .055586) exec(1), time(0.024-0.024 ms): <.main+11577>
test/stdc/memory.ci:13:[.055586, .055598) exec(1), time(0.031-0.031 ms): <.main+11602>
test/stdc/memory.ci:14:[.055598, .0555ad) exec(1), time(0.031-0.031 ms): <.main+11620>
test/stdc/memory.ci:17:[.0555ad, .0555ba) exec(1), time(0.029-0.029 ms): <.main+11641>
test/stdc/memory.ci:18:[.0555ba, .0555c7) exec(1), time(0.030-0.030 ms): <.main+11654>
test/stdc/memory.ci:19:[.0555c7, .0555d4) exec(1), time(0.030-0.030 ms): <.main+11667>
test/stdc/memory.ci:20:[.0555d4, .0555e1) exec(1), time(0.029-0.029 ms): <.main+11680>
test/stdc/memory.ci:26:[.0555e1, .055604) exec(1), time(0.040-0.040 ms): <.main+11693>
test/stdc/memory.ci:27:[.055604, .055627) exec(1), time(0.042-0.042 ms): <.main+11728>
test/stdc/memory.ci:29:[.055627, .05563d) exec(1), time(0.032-0.032 ms): <.main+11763>
test/stdc/memory.ci:30:[.05563d, .05564f) exec(1), time(0.032-0.032 ms): <.main+11785>
test/stdc/memory.ci:32:[.05564f, .055672) exec(1), time(0.040-0.040 ms): <.main+11803>
test/stdc/memory.ci:33:[.055672, .055695) exec(1), time(0.038-0.038 ms): <.main+11838>
test/lang/array.ci:55:[.05569a, .0556af) exec(7), time(0.062-0.062 ms): <.main+11878>
test/lang/array.ci:54:[.0556af, .0556b3) exec(7), time(0.003-0.003 ms): <.main+11899>
test/lang/array.ci:54:[.0556b3, .0556bf) exec(8), time(0.033-0.033 ms): <.main+11903>
test/lang/array.ci:54:[.055695, .0556c3) exec(1), time(0.006-0.006 ms): <.main+11873>
test/lang/array.ci:82:[.0556c3, .0556da) exec(1), time(0.031-0.031 ms): <.main+11919>
test/lang/array.ci:83:[.0556da, .0556fd) exec(1), time(0.096-0.096 ms): <.main+11942>
test/lang/array.ci:84:[.0556fd, .055720) exec(1), time(0.117-0.117 ms): <.main+11977>
test/lang/array.ci:87:[.055720, .055742) exec(1), time(0.049-0.049 ms): <.main+12012>
test/lang/array.ci:88:[.055742, .055764) exec(1), time(0.044-0.044 ms): <.main+12046>
test/lang/array.ci:91:[.055764, .055786) exec(1), time(0.041-0.041 ms): <.main+12080>
test/lang/array.ci:92:[.055786, .0557a8) exec(1), time(0.041-0.041 ms): <.main+12114>
test/lang/array.ci:98:[.0557a8, .0557dd) exec(1), time(0.005-0.005 ms): <.main+12148>
test/lang/array.ci:99:[.0557dd, .055812) exec(1), time(0.005-0.005 ms): <.main+12201>
test/lang/array.ci:101:[.055812, .05584f) exec(1), time(0.006-0.006 ms): <.main+12254>
test/lang/array.ci:108:[.05584f, .055868) exec(1), time(0.024-0.024 ms): <.main+12315>
test/lang/array.ci:109:[.055868, .055880) exec(1), time(0.024-0.024 ms): <.main+12340>
test/lang/array.ci:110:[.055880, .055898) exec(1), time(0.024-0.024 ms): <.main+12364>
test/lang/array.ci:112:[.055898, .0558b8) exec(1), time(0.052-0.052 ms): <.main+12388>
test/lang/array.ci:113:[.0558b8, .0558d7) exec(1), time(0.051-0.051 ms): <.main+12420>
test/lang/array.ci:114:[.0558d7, .055900) exec(1), time(0.052-0.052 ms): <.main+12451>
test/lang/array.ci:115:[.055900, .055923) exec(1), time(0.051-0.051 ms): <.main+12492>
test/lang/array.ci:116:[.055923, .055946) exec(1), time(0.050-0.050 ms): <.main+12527>
test/lang/array.ci:119:[.05594b, .055954) exec(7), time(0.029-0.029 ms): <.main+12567>
test/lang/array.ci:120:[.055954, .055992) exec(7), time(0.062-0.062 ms): <.main+12576>
test/lang/array.ci:121:[.055992, .0559cf) exec(7), time(0.064-0.064 ms): <.main+12638>
test/lang/array.ci:122:[.0559cf, .055a0c) exec(7), time(0.062-0.062 ms): <.main+12699>
test/lang/array.ci:124:[.055a0c, .055a50) exec(7), time(0.261-0.261 ms): <.main+12760>
test/lang/array.ci:125:[.055a50, .055a93) exec(7), time(0.258-0.258 ms): <.main+12828>
test/lang/array.ci:126:[.055a93, .055ad6) exec(7), time(0.255-0.255 ms): <.main+12895>
test/lang/array.ci:128:[.055ad6, .055b1a) exec(7), time(0.254-0.254 ms): <.main+12962>
test/lang/array.ci:129:[.055b1a, .055b5d) exec(7), time(0.260-0.260 ms): <.main+13030>
test/lang/array.ci:130:[.055b5d, .055ba0) exec(7), time(0.263-0.263 ms): <.main+13097>
test/lang/array.ci:132:[.055ba0, .055be9) exec(7), time(0.266-0.266 ms): <.main+13164>
test/lang/array.ci:134:[.055be9, .055c2c) exec(7), time(0.262-0.262 ms): <.main+13237>
test/lang/array.ci:136:[.055c2c, .055c69) exec(7), time(0.065-0.065 ms): <.main+13304>
test/lang/array.ci:118:[.055c6d, .055c71) exec(7), time(0.005-0.005 ms): <.main+13369>
test/lang/array.ci:118:[.055c71, .055c7d) exec(8), time(0.033-0.033 ms): <.main+13373>
test/lang/array.ci:118:[.055946, .055c81) exec(1), time(0.006-0.006 ms): <.main+12562>
test/lang/method.ci:78:[.055c81, .055c96) exec(1), time(0.130-0.130 ms): <.main+13389>
test/lang/method.ci:79:[.055c96, .055caa) exec(1), time(0.134-0.134 ms): <.main+13410>
test/lang/method.ci:97:[.055caa, .055cbd) exec(1), time(0.242-0.242 ms): <.main+13430>
test/lang/method.ci:98:[.055cbd, .055cd0) exec(1), time(0.242-0.242 ms): <.main+13449>
test/lang/method.ci:101:[.055cd0, .055ce5) exec(1), time(0.130-0.130 ms): <.main+13468>
test/lang/method.ci:102:[.055ce5, .055cfa) exec(1), time(0.130-0.130 ms): <.main+13489>
test/lang/method.ci:103:[.055cfa, .055d0e) exec(1), time(0.135-0.135 ms): <.main+13510>
test/lang/statementIf.ci:4:[.055d0e, .055d35) exec(1), time(0.038-0.038 ms): <.main+13530>
test/lang/statementIf.ci:12:[.055d35, .055d5c) exec(1), time(0.043-0.043 ms): <.main+13569>
test/lang/statementIf.ci:22:[.055d5c, .055d83) exec(1), time(0.039-0.039 ms): <.main+13608>
test/lang/statementIf.ci:29:[.055d8d, .055db4) exec(1), time(0.045-0.045 ms): <.main+13657>
test/lang/statementIf.ci:28:[.055d83, .055db4) exec(1-1), time(0.000 ms): <.main+13647>
test/lang/statementIf.ci:33:[.055dbe, .055de5) exec(0), time(0.000 ms): <.main+13706>
test/lang/statementIf.ci:32:[.055db4, .055de5) exec(1), time(0.004-0.004 ms): <.main+13696>
test/lang/statementIf.ci:37:[.055def, .055e16) exec(1), time(0.044-0.044 ms): <.main+13755>
test/lang/statementIf.ci:40:[.055e1a, .055e41) exec(0), time(0.000 ms): <.main+13798>
test/lang/statementIf.ci:36:[.055de5, .055e41) exec(1), time(0.046-0.046 ms): <.main+13745>
test/lang/statementIf.ci:44:[.055e4b, .055e72) exec(0), time(0.000 ms): <.main+13847>
test/lang/statementIf.ci:47:[.055e76, .055e9d) exec(1), time(0.052-0.052 ms): <.main+13890>
test/lang/statementIf.ci:43:[.055e41, .055e9d) exec(1-1), time(0.000 ms): <.main+13837>
test/lang/statementIf.ci:51:[.055ea7, .055ece) exec(1), time(0.045-0.045 ms): <.main+13939>
test/lang/statementIf.ci:54:[.055ee0, .055f07) exec(0), time(0.000 ms): <.main+13996>
test/lang/statementIf.ci:57:[.055f19, .055f40) exec(0), time(0.000 ms): <.main+14053>
test/lang/statementIf.ci:60:[.055f52, .055f79) exec(0), time(0.000 ms): <.main+14110>
test/lang/statementIf.ci:63:[.055f8b, .055fb2) exec(0), time(0.000 ms): <.main+14167>
test/lang/statementIf.ci:66:[.055fc4, .055feb) exec(0), time(0.000 ms): <.main+14224>
test/lang/statementIf.ci:69:[.055fef, .056016) exec(0), time(0.000 ms): <.main+14267>
test/lang/statementIf.ci:65:[.055fb6, .056016) exec(0), time(0.000 ms): <.main+14210>
test/lang/statementIf.ci:62:[.055f7d, .056016) exec(0), time(0.000 ms): <.main+14153>
test/lang/statementIf.ci:59:[.055f44, .056016) exec(0), time(0.000 ms): <.main+14096>
test/lang/statementIf.ci:56:[.055f0b, .056016) exec(0), time(0.000 ms): <.main+14039>
test/lang/statementIf.ci:53:[.055ed2, .056016) exec(0), time(0.000 ms): <.main+13982>
test/lang/statementIf.ci:50:[.055e9d, .056016) exec(1), time(0.047-0.047 ms): <.main+13929>
test/lang/statementFor.ci:4:[.05601a, .05603d) exec(1), time(0.035-0.035 ms): <.main+14310>
test/lang/statementFor.ci:5:[.05603d, .056041) exec(1), time(0.000 ms): <.main+14345>
::[.056041, .056045) exec(1), time(0.000 ms): <.main+14349>
test/lang/statementFor.ci:3:[.056016, .056045) exec(1-1), time(0.000 ms): <.main+14306>
test/lang/statementFor.ci:9:[.05604a, .05606c) exec(2), time(0.078-0.078 ms): <.main+14358>
test/lang/statementFor.ci:8:[.05606c, .056070) exec(2), time(0.000 ms): <.main+14392>
test/lang/statementFor.ci:8:[.056070, .05607c) exec(3), time(0.012-0.012 ms): <.main+14396>
test/lang/statementFor.ci:8:[.056045, .056080) exec(1), time(0.006-0.006 ms): <.main+14353>
test/lang/statementFor.ci:14:[.056089, .0560ac) exec(2), time(0.079-0.079 ms): <.main+14421>
test/lang/statementFor.ci:13:[.0560ac, .0560b8) exec(2), time(0.006-0.006 ms): <.main+14456>
test/lang/statementFor.ci:13:[.0560b8, .0560c6) exec(3), time(0.019-0.019 ms): <.main+14468>
test/lang/statementFor.ci:13:[.056080, .0560c6) exec(1-1), time(0.000 ms): <.main+14412>
test/lang/statementFor.ci:19:[.0560d7, .0560db) exec(2), time(0.001-0.001 ms): <.main+14499>
test/lang/statementFor.ci:18:[.0560cb, .0560db) exec(7-2), time(0.022-0.022 ms): <.main+14487>
test/lang/statementFor.ci:21:[.0560db, .0560fd) exec(5), time(0.196-0.196 ms): <.main+14503>
test/lang/statementFor.ci:17:[.0560fd, .056101) exec(7), time(0.003-0.003 ms): <.main+14537>
test/lang/statementFor.ci:17:[.056101, .05610d) exec(8), time(0.036-0.036 ms): <.main+14541>
test/lang/statementFor.ci:17:[.0560c6, .056111) exec(1), time(0.006-0.006 ms): <.main+14482>
test/lang/statementFor.ci:26:[.056122, .056126) exec(1), time(0.001-0.001 ms): <.main+14574>
test/lang/statementFor.ci:25:[.056116, .056126) exec(4-1), time(0.013-0.013 ms): <.main+14562>
test/lang/statementFor.ci:28:[.056126, .056148) exec(3), time(0.119-0.119 ms): <.main+14578>
test/lang/statementFor.ci:24:[.056148, .05614c) exec(3), time(0.002-0.002 ms): <.main+14612>
test/lang/statementFor.ci:24:[.05614c, .056158) exec(4), time(0.018-0.018 ms): <.main+14616>
test/lang/statementFor.ci:24:[.056111, .05615c) exec(1), time(0.003-0.003 ms): <.main+14557>

---------- Exitcode: 0, time: 31.187 ms
