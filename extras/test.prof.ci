
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:40: debug: inline file: `lib/std/debug.ci`
lib/std/debug.ci:65: warn: adding implicit cast variant(message: char[*])
lib/std/debug.ci:67: warn: adding implicit cast variant(expected: int32)
lib/std/debug.ci:68: warn: adding implicit cast variant(returned: int32)
lib/std/debug.ci:69: warn: adding implicit cast variant[](extras: variant[1])
lib/stdlib.ci:43: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:239: warn: adding implicit cast float64(signed(data.length): int32)
lib/std/math.ci:257: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:309: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:315: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:319: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:323: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:323: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:327: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:332: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:367: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:371: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:379: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:396: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:399: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:421: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:426: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:432: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:448: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:451: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:463: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:469: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:474: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:479: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:481: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:497: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:521: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:524: warn: adding implicit cast float64(180: int32)
lib/stdlib.ci:46: debug: inline file: `lib/std/math/Complex.ci`
lib/std/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:47: debug: inline file: `lib/std/math/Vector4f.ci`
lib/stdlib.ci:48: debug: inline file: `lib/std/math/Matrix4f.ci`
lib/std/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
lib/std/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(1: int32)
lib/stdlib.ci:49: debug: inline file: `lib/std/math/Vector2d.ci`
lib/stdlib.ci:54: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:117: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
lib/std/string.ci:123: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
lib/std/string.ci:129: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:137: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:137: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:139: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:162: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:165: warn: adding implicit cast uint64(0: int32)
lib/std/string.ci:165: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:166: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:180: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:190: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:197: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:204: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:209: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:210: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:210: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:212: warn: adding implicit cast char(0: int32)
lib/std/string.ci:225: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:225: warn: adding implicit cast int32('-': char)
lib/std/string.ci:225: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:227: warn: adding implicit cast int32('-': char)
lib/std/string.ci:229: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:229: warn: adding implicit cast int32('-': char)
lib/std/string.ci:229: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:231: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:231: warn: adding implicit cast int32('-': char)
lib/std/string.ci:231: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:248: warn: adding implicit cast float64(0: int32)
lib/std/string.ci:248: warn: adding implicit cast int32('-': char)
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.showSign := false
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.precision := 0
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:120: warn: adding implicit cast char(0: int32)
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:14: debug: inline file: `test/std/number.ci`
test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:15: debug: inline file: `test/std/memory.ci`
test/test.ci:16: debug: inline file: `test/std/tryExec.ci`
test/std/tryExec.ci:25: warn: variable `abortExecution.NotEquals` hides previous declaration
test/std/tryExec.ci:25: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/std/tryExec.ci:31: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:20: debug: inline file: `test/lang/init.reference.ci`
test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:21: debug: inline file: `test/lang/init.variable.ci`
test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
test/test.ci:24: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:25: debug: inline file: `test/lang/reflect.ci`
test/test.ci:29: debug: inline file: `test/lang/init.member.ci`
test/lang/init.member.ci:81: warn: ignoring nested comment
test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
test/test.ci:30: debug: inline file: `test/lang/init.method.ci`
test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:31: debug: inline file: `test/lang/init.array.ci`
test/lang/init.array.ci:2: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/init.array.ci:11: warn: adding implicit cast int64(42: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(43: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(44: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(45: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(46: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(47: int32)
test/lang/init.array.ci:11: warn: adding implicit cast int64(48: int32)
test/lang/init.array.ci:34: warn: adding implicit cast char(0: int32)
test/lang/init.array.ci:48: warn: adding implicit cast uint32(0: int32)
test/lang/init.array.ci:49: warn: adding implicit cast int64(42: int32)
test/test.ci:33: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:34: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:41: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:45: debug: inline file: `test/lang/stmt.if.ci`
test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:46: debug: inline file: `test/lang/stmt.for.ci`
test/test.ci:49: debug: inline file: `test/std/test.math.ci`
test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:314: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:317: warn: using default type initializer: e := 0
lib/std/math.ci:321: warn: using default type initializer: f := 0
lib/std/math.ci:373: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:430: warn: using default type initializer: Math.sinh.result := 0
lib/std/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
test/lang/init.method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006018>, cast: static const inline)
.field file: function (size: 0, offs: <@006218>, cast: static const inline)
.field line: function (size: 0, offs: <@006418>, cast: static const inline)
.field name: function (size: 0, offs: <@006618>, cast: static const inline)
.usages:
	test/lang/stmt.if.ci:77: referenced as `typename`
	test/lang/stmt.if.ci:77: referenced as `typename`
	test/lang/stmt.if.ci:73: referenced as `typename`
	test/lang/init.array.ci:2: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/init.reference.ci:99: referenced as `typename`
	test/lang/init.reference.ci:99: referenced as `typename`
	test/lang/init.reference.ci:97: referenced as `typename`
	test/lang/init.reference.ci:97: referenced as `typename`
	test/lang/init.reference.ci:92: referenced as `typename`
	test/lang/init.reference.ci:91: referenced as `typename`
	test/lang/init.reference.ci:90: referenced as `typename`
	test/lang/init.reference.ci:89: referenced as `typename`
	test/lang/init.reference.ci:88: referenced as `typename`
	test/lang/init.reference.ci:88: referenced as `typename`
	test/lang/init.reference.ci:87: referenced as `typename`
	test/lang/init.reference.ci:86: referenced as `typename`
	test/lang/init.reference.ci:85: referenced as `typename`
	test/lang/init.reference.ci:84: referenced as `typename`
	test/lang/init.reference.ci:83: referenced as `typename`
	test/lang/init.reference.ci:82: referenced as `typename`
	test/lang/init.reference.ci:81: referenced as `typename`
	test/lang/init.reference.ci:80: referenced as `typename`
	test/lang/init.reference.ci:79: referenced as `typename`
	test/lang/init.reference.ci:78: referenced as `typename`
	test/lang/init.reference.ci:77: referenced as `typename`
	test/lang/init.reference.ci:76: referenced as `typename`
	test/lang/init.reference.ci:75: referenced as `typename`
	test/lang/init.reference.ci:68: referenced as `typename`
	test/lang/init.reference.ci:48: referenced as `typename`
	test/lang/init.reference.ci:32: referenced as `typename`
	test/lang/init.reference.ci:25: referenced as `typename`
	test/lang/init.reference.ci:19: referenced as `typename`
	test/lang/init.reference.ci:3: referenced as `typename`
	lib/stdlib.ci:39: referenced as `typename`
	lib/stdlib.ci:37: referenced as `typename`
	internal usages: 10
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:37: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006018>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006218>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006418>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006618>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/init.method.ci:90: referenced as `void`
	test/lang/init.method.ci:84: referenced as `void`
	test/lang/init.method.ci:57: referenced as `void`
	test/lang/init.method.ci:47: referenced as `void`
	test/lang/init.method.ci:40: referenced as `void`
	test/lang/init.method.ci:32: referenced as `void`
	test/lang/init.method.ci:25: referenced as `void`
	test/lang/init.method.ci:18: referenced as `void`
	test/lang/init.method.ci:10: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/init.reference.ci:75: referenced as `void`
	test/lang/init.reference.ci:55: referenced as `void`
	test/lang/init.reference.ci:35: referenced as `void`
	test/std/tryExec.ci:43: referenced as `void`
	test/std/tryExec.ci:38: referenced as `void`
	test/std/tryExec.ci:24: referenced as `void`
	test/std/tryExec.ci:20: referenced as `void`
	test/std/tryExec.ci:14: referenced as `void`
	test/std/tryExec.ci:11: referenced as `void`
	lib/std/debug.ci:61: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/std/test.math.ci:68: referenced as `bool`
	test/std/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/init.reference.ci:76: referenced as `bool`
	test/lang/init.reference.ci:56: referenced as `bool`
	test/lang/init.reference.ci:36: referenced as `bool`
	lib/std/string.ci:114: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:468: referenced as `bool`
	lib/std/math.ci:420: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/std/math.ci:364: referenced as `bool`
	lib/std/debug.ci:45: referenced as `bool`
	lib/std/debug.ci:43: referenced as `bool`
	lib/std/debug.ci:41: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/init.array.ci:40: referenced as `char`
	test/lang/init.array.ci:37: referenced as `char`
	test/lang/init.array.ci:34: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/init.reference.ci:77: referenced as `char`
	test/lang/init.reference.ci:57: referenced as `char`
	test/lang/init.reference.ci:37: referenced as `char`
	test/std/tryExec.ci:26: referenced as `char`
	test/lang/emit.ci:29: referenced as `char`
	lib/std/string.ci:262: referenced as `char`
	lib/std/string.ci:259: referenced as `char`
	lib/std/string.ci:248: referenced as `char`
	lib/std/string.ci:234: referenced as `char`
	lib/std/string.ci:231: referenced as `char`
	lib/std/string.ci:229: referenced as `char`
	lib/std/string.ci:227: referenced as `char`
	lib/std/string.ci:225: referenced as `char`
	lib/std/string.ci:223: referenced as `char`
	lib/std/string.ci:221: referenced as `char`
	lib/std/string.ci:219: referenced as `char`
	lib/std/string.ci:217: referenced as `char`
	lib/std/string.ci:174: referenced as `char`
	lib/std/string.ci:149: referenced as `char`
	lib/std/string.ci:146: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:127: referenced as `char`
	lib/std/string.ci:127: referenced as `char`
	lib/std/string.ci:120: referenced as `char`
	lib/std/string.ci:98: referenced as `char`
	lib/std/string.ci:98: referenced as `char`
	lib/std/string.ci:95: referenced as `char`
	lib/std/string.ci:95: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/std/debug.ci:61: referenced as `char`
	lib/std/debug.ci:43: referenced as `char`
	lib/std/debug.ci:41: referenced as `char`
	lib/std/debug.ci:36: referenced as `char`
	lib/std/debug.ci:34: referenced as `char`
	lib/std/debug.ci:31: referenced as `char`
	lib/std/debug.ci:29: referenced as `char`
	lib/std/debug.ci:26: referenced as `char`
	lib/std/debug.ci:24: referenced as `char`
	lib/std/debug.ci:21: referenced as `char`
	lib/std/debug.ci:19: referenced as `char`
	lib/std/debug.ci:16: referenced as `char`
	lib/std/debug.ci:14: referenced as `char`
	lib/std/debug.ci:11: referenced as `char`
	lib/std/debug.ci:9: referenced as `char`
	lib/std/debug.ci:6: referenced as `char`
	lib/std/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/init.reference.ci:78: referenced as `int8`
	test/lang/init.reference.ci:58: referenced as `int8`
	test/lang/init.reference.ci:38: referenced as `int8`
	lib/std/string.ci:231: referenced as `int8`
	lib/stdlib.ci:25: referenced as `int8`
	lib/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/init.reference.ci:79: referenced as `int16`
	test/lang/init.reference.ci:59: referenced as `int16`
	test/lang/init.reference.ci:39: referenced as `int16`
	lib/std/string.ci:229: referenced as `int16`
	lib/stdlib.ci:28: referenced as `int16`
	lib/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/stmt.for.ci:24: referenced as `int`
	test/lang/stmt.for.ci:17: referenced as `int`
	test/lang/stmt.for.ci:12: referenced as `int`
	test/lang/stmt.for.ci:8: referenced as `int`
	test/lang/stmt.if.ci:26: referenced as `int`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/init.array.ci:66: referenced as `int`
	test/lang/init.array.ci:54: referenced as `int`
	test/lang/init.array.ci:53: referenced as `int`
	test/lang/init.array.ci:52: referenced as `int`
	test/lang/init.array.ci:51: referenced as `int`
	test/lang/init.array.ci:3: referenced as `int32`
	test/lang/init.method.ci:90: referenced as `int`
	test/lang/init.method.ci:84: referenced as `int`
	test/lang/init.method.ci:57: referenced as `int`
	test/lang/init.method.ci:47: referenced as `int`
	test/lang/init.method.ci:40: referenced as `int`
	test/lang/init.method.ci:32: referenced as `int`
	test/lang/init.method.ci:25: referenced as `int`
	test/lang/init.method.ci:18: referenced as `int`
	test/lang/init.method.ci:10: referenced as `int`
	test/lang/init.member.ci:40: referenced as `int`
	test/lang/init.member.ci:37: referenced as `int`
	test/lang/init.member.ci:34: referenced as `int`
	test/lang/init.member.ci:19: referenced as `int`
	test/lang/init.member.ci:16: referenced as `int`
	test/lang/init.member.ci:13: referenced as `int`
	test/lang/init.member.ci:10: referenced as `int`
	test/lang/init.member.ci:6: referenced as `int`
	test/lang/init.member.ci:5: referenced as `int`
	test/lang/reflect.ci:50: referenced as `int`
	test/lang/reflect.ci:49: referenced as `int`
	test/lang/reflect.ci:46: referenced as `int`
	test/lang/reflect.ci:45: referenced as `int`
	test/lang/reflect.ci:42: referenced as `int`
	test/lang/reflect.ci:40: referenced as `int`
	test/lang/reflect.ci:39: referenced as `int`
	test/lang/reflect.ci:35: referenced as `int`
	test/lang/reflect.ci:33: referenced as `int`
	test/lang/reflect.ci:32: referenced as `int`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int`
	test/lang/reflect.ci:19: referenced as `int`
	test/lang/reflect.ci:18: referenced as `int`
	test/lang/reflect.ci:17: referenced as `int`
	test/lang/reflect.ci:16: referenced as `int`
	test/lang/reflect.ci:15: referenced as `int`
	test/lang/reflect.ci:14: referenced as `int`
	test/lang/reflect.ci:13: referenced as `int`
	test/lang/reflect.ci:12: referenced as `int`
	test/lang/reflect.ci:11: referenced as `int`
	test/lang/reflect.ci:10: referenced as `int`
	test/lang/reflect.ci:9: referenced as `int`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int`
	test/lang/reflect.ci:7: referenced as `int`
	test/lang/reflect.ci:6: referenced as `int`
	test/lang/reflect.ci:5: referenced as `int`
	test/lang/reflect.ci:4: referenced as `int`
	test/lang/reflect.ci:3: referenced as `int`
	test/lang/function.ci:33: referenced as `int`
	test/lang/function.ci:33: referenced as `int`
	test/lang/function.ci:33: referenced as `int`
	test/lang/function.ci:30: referenced as `int`
	test/lang/function.ci:27: referenced as `int`
	test/lang/function.ci:27: referenced as `int`
	test/lang/function.ci:27: referenced as `int`
	test/lang/function.ci:24: referenced as `int`
	test/lang/function.ci:21: referenced as `int`
	test/lang/function.ci:21: referenced as `int`
	test/lang/function.ci:21: referenced as `int`
	test/lang/function.ci:18: referenced as `int`
	test/lang/function.ci:15: referenced as `int`
	test/lang/function.ci:15: referenced as `int`
	test/lang/function.ci:15: referenced as `int`
	test/lang/function.ci:12: referenced as `int`
	test/lang/function.ci:7: referenced as `int`
	test/lang/function.ci:7: referenced as `int`
	test/lang/function.ci:7: referenced as `int`
	test/lang/init.variable.ci:7: referenced as `int`
	test/lang/init.variable.ci:3: referenced as `int`
	test/lang/init.reference.ci:80: referenced as `int32`
	test/lang/init.reference.ci:60: referenced as `int32`
	test/lang/init.reference.ci:40: referenced as `int32`
	test/lang/init.reference.ci:4: referenced as `int32`
	test/std/tryExec.ci:53: referenced as `int`
	test/std/tryExec.ci:52: referenced as `int`
	test/std/tryExec.ci:51: referenced as `int`
	test/std/tryExec.ci:50: referenced as `int`
	test/std/tryExec.ci:49: referenced as `int`
	test/std/tryExec.ci:48: referenced as `int`
	test/std/tryExec.ci:47: referenced as `int`
	test/std/tryExec.ci:40: referenced as `int`
	test/std/tryExec.ci:39: referenced as `int32`
	test/std/tryExec.ci:28: referenced as `int`
	test/std/tryExec.ci:27: referenced as `int`
	test/std/tryExec.ci:21: referenced as `int`
	test/std/memory.ci:4: referenced as `int`
	test/std/memory.ci:3: referenced as `int`
	test/std/number.ci:66: referenced as `int32`
	test/std/number.ci:65: referenced as `int32`
	test/std/number.ci:63: referenced as `int32`
	test/std/number.ci:62: referenced as `int32`
	test/std/number.ci:60: referenced as `int32`
	test/std/number.ci:59: referenced as `int32`
	test/std/number.ci:58: referenced as `int32`
	test/std/number.ci:57: referenced as `int32`
	test/std/number.ci:55: referenced as `int32`
	test/std/number.ci:35: referenced as `int32`
	test/std/number.ci:34: referenced as `int32`
	test/std/number.ci:33: referenced as `int32`
	test/std/number.ci:31: referenced as `int32`
	test/std/number.ci:30: referenced as `int32`
	test/std/number.ci:29: referenced as `int32`
	test/std/number.ci:27: referenced as `int32`
	test/std/number.ci:26: referenced as `int32`
	test/std/number.ci:25: referenced as `int32`
	test/std/number.ci:23: referenced as `int32`
	test/std/number.ci:22: referenced as `int32`
	test/std/number.ci:21: referenced as `int32`
	test/std/number.ci:19: referenced as `int32`
	test/std/number.ci:18: referenced as `int32`
	test/std/number.ci:16: referenced as `int`
	test/std/number.ci:15: referenced as `int`
	test/std/number.ci:14: referenced as `int`
	test/std/number.ci:12: referenced as `int`
	test/std/number.ci:12: referenced as `int`
	test/std/number.ci:12: referenced as `int`
	test/std/number.ci:10: referenced as `int`
	test/std/number.ci:10: referenced as `int`
	test/std/number.ci:10: referenced as `int`
	test/lang/overload.inline.ci:7: referenced as `int`
	test/lang/overload.inline.ci:7: referenced as `int`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int`
	test/lang/inlineMacros.ci:72: referenced as `int`
	test/lang/inlineMacros.ci:71: referenced as `int`
	test/lang/inlineMacros.ci:70: referenced as `int`
	test/lang/inlineMacros.ci:69: referenced as `int`
	test/lang/inlineMacros.ci:68: referenced as `int`
	test/lang/inlineMacros.ci:67: referenced as `int`
	test/lang/inlineMacros.ci:67: referenced as `int`
	test/lang/inlineMacros.ci:67: referenced as `int`
	test/lang/inlineMacros.ci:67: referenced as `int`
	test/lang/inlineMacros.ci:66: referenced as `int`
	test/lang/inlineMacros.ci:66: referenced as `int`
	test/lang/inlineMacros.ci:66: referenced as `int`
	test/lang/inlineMacros.ci:66: referenced as `int`
	test/lang/inlineMacros.ci:64: referenced as `int`
	test/lang/inlineMacros.ci:63: referenced as `int`
	test/lang/inlineMacros.ci:62: referenced as `int`
	test/lang/inlineMacros.ci:61: referenced as `int`
	test/lang/inlineMacros.ci:60: referenced as `int`
	test/lang/inlineMacros.ci:59: referenced as `int`
	test/lang/inlineMacros.ci:58: referenced as `int`
	test/lang/inlineMacros.ci:58: referenced as `int`
	test/lang/inlineMacros.ci:58: referenced as `int`
	test/lang/inlineMacros.ci:58: referenced as `int`
	test/lang/inlineMacros.ci:57: referenced as `int`
	test/lang/inlineMacros.ci:57: referenced as `int`
	test/lang/inlineMacros.ci:57: referenced as `int`
	test/lang/inlineMacros.ci:57: referenced as `int`
	test/lang/inlineMacros.ci:55: referenced as `int`
	test/lang/inlineMacros.ci:54: referenced as `int`
	test/lang/inlineMacros.ci:53: referenced as `int`
	test/lang/inlineMacros.ci:52: referenced as `int`
	test/lang/inlineMacros.ci:51: referenced as `int`
	test/lang/inlineMacros.ci:50: referenced as `int`
	test/lang/inlineMacros.ci:49: referenced as `int`
	test/lang/inlineMacros.ci:49: referenced as `int`
	test/lang/inlineMacros.ci:49: referenced as `int`
	test/lang/inlineMacros.ci:49: referenced as `int`
	test/lang/inlineMacros.ci:48: referenced as `int`
	test/lang/inlineMacros.ci:48: referenced as `int`
	test/lang/inlineMacros.ci:48: referenced as `int`
	test/lang/inlineMacros.ci:48: referenced as `int`
	test/lang/inlineMacros.ci:46: referenced as `int`
	test/lang/inlineMacros.ci:45: referenced as `int`
	test/lang/inlineMacros.ci:44: referenced as `int`
	test/lang/inlineMacros.ci:43: referenced as `int`
	test/lang/inlineMacros.ci:42: referenced as `int`
	test/lang/inlineMacros.ci:41: referenced as `int`
	test/lang/inlineMacros.ci:40: referenced as `int`
	test/lang/inlineMacros.ci:40: referenced as `int`
	test/lang/inlineMacros.ci:40: referenced as `int`
	test/lang/inlineMacros.ci:40: referenced as `int`
	test/lang/inlineMacros.ci:39: referenced as `int`
	test/lang/inlineMacros.ci:39: referenced as `int`
	test/lang/inlineMacros.ci:39: referenced as `int`
	test/lang/inlineMacros.ci:39: referenced as `int`
	test/lang/inlineMacros.ci:37: referenced as `int`
	test/lang/inlineMacros.ci:36: referenced as `int`
	test/lang/inlineMacros.ci:35: referenced as `int`
	test/lang/inlineMacros.ci:33: referenced as `int`
	test/lang/inlineMacros.ci:32: referenced as `int`
	test/lang/inlineMacros.ci:31: referenced as `int`
	test/lang/inlineMacros.ci:29: referenced as `int`
	test/lang/inlineMacros.ci:28: referenced as `int`
	test/lang/inlineMacros.ci:27: referenced as `int`
	test/lang/inlineMacros.ci:25: referenced as `int`
	test/lang/inlineMacros.ci:24: referenced as `int`
	test/lang/inlineMacros.ci:23: referenced as `int`
	test/lang/inlineMacros.ci:21: referenced as `int`
	test/lang/inlineMacros.ci:20: referenced as `int`
	test/lang/inlineMacros.ci:19: referenced as `int`
	test/lang/inlineMacros.ci:17: referenced as `int`
	test/lang/inlineMacros.ci:16: referenced as `int`
	test/lang/inlineMacros.ci:15: referenced as `int`
	test/lang/inlineMacros.ci:13: referenced as `int`
	test/lang/inlineMacros.ci:12: referenced as `int`
	test/lang/inlineMacros.ci:11: referenced as `int`
	test/lang/inlineMacros.ci:10: referenced as `int`
	test/lang/inlineMacros.ci:8: referenced as `int`
	test/lang/inlineMacros.ci:8: referenced as `int`
	test/lang/inlineMacros.ci:7: referenced as `int`
	test/lang/inlineMacros.ci:7: referenced as `int`
	test/lang/inlineMacros.ci:6: referenced as `int`
	test/lang/inlineMacros.ci:6: referenced as `int`
	test/lang/inlineMacros.ci:5: referenced as `int`
	test/lang/inlineMacros.ci:5: referenced as `int`
	test/lang/inlineMacros.ci:4: referenced as `int`
	test/lang/inlineMacros.ci:4: referenced as `int`
	test/lang/inlineMacros.ci:3: referenced as `int`
	test/lang/inlineMacros.ci:3: referenced as `int`
	test/lang/emit.ci:29: referenced as `int`
	test/lang/emit.ci:25: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:13: referenced as `int32`
	test/lang/emit.ci:13: referenced as `int32`
	test/lang/emit.ci:13: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:262: referenced as `int`
	lib/std/string.ci:262: referenced as `int`
	lib/std/string.ci:262: referenced as `int`
	lib/std/string.ci:259: referenced as `int`
	lib/std/string.ci:234: referenced as `int`
	lib/std/string.ci:234: referenced as `int`
	lib/std/string.ci:231: referenced as `int`
	lib/std/string.ci:229: referenced as `int`
	lib/std/string.ci:227: referenced as `int32`
	lib/std/string.ci:227: referenced as `int`
	lib/std/string.ci:225: referenced as `int`
	lib/std/string.ci:223: referenced as `int`
	lib/std/string.ci:221: referenced as `int`
	lib/std/string.ci:219: referenced as `int`
	lib/std/string.ci:217: referenced as `int`
	lib/std/string.ci:203: referenced as `int`
	lib/std/string.ci:172: referenced as `int`
	lib/std/string.ci:157: referenced as `int`
	lib/std/string.ci:148: referenced as `int`
	lib/std/string.ci:144: referenced as `int`
	lib/std/string.ci:144: referenced as `int`
	lib/std/string.ci:128: referenced as `int`
	lib/std/string.ci:127: referenced as `int`
	lib/std/string.ci:127: referenced as `int`
	lib/std/string.ci:123: referenced as `int`
	lib/std/string.ci:117: referenced as `int`
	lib/std/string.ci:88: referenced as `int`
	lib/std/string.ci:73: referenced as `int`
	lib/std/string.ci:63: referenced as `int`
	lib/std/string.ci:62: referenced as `int`
	lib/std/string.ci:61: referenced as `int`
	lib/std/string.ci:61: referenced as `int`
	lib/std/string.ci:52: referenced as `int`
	lib/std/string.ci:48: referenced as `int`
	lib/std/string.ci:47: referenced as `int`
	lib/std/string.ci:46: referenced as `int`
	lib/std/string.ci:37: referenced as `int`
	lib/std/string.ci:36: referenced as `int`
	lib/std/string.ci:27: referenced as `int`
	lib/std/string.ci:26: referenced as `int`
	lib/std/string.ci:25: referenced as `int`
	lib/std/string.ci:16: referenced as `int`
	lib/std/string.ci:15: referenced as `int`
	lib/std/string.ci:8: referenced as `int`
	lib/std/string.ci:4: referenced as `int`
	lib/std/math.ci:375: referenced as `int`
	lib/std/math.ci:375: referenced as `int`
	lib/std/math.ci:326: referenced as `int`
	lib/std/math.ci:294: referenced as `int`
	lib/std/math.ci:279: referenced as `int`
	lib/std/math.ci:264: referenced as `int`
	lib/std/math.ci:257: referenced as `int`
	lib/std/math.ci:231: referenced as `int`
	lib/std/math.ci:220: referenced as `int`
	lib/std/math.ci:206: referenced as `int`
	lib/std/math.ci:67: referenced as `int`
	lib/std/math.ci:67: referenced as `int`
	lib/std/math.ci:64: referenced as `int`
	lib/std/math.ci:64: referenced as `int`
	lib/std/debug.ci:74: referenced as `int`
	lib/std/debug.ci:74: referenced as `int`
	lib/std/debug.ci:61: referenced as `int`
	lib/std/debug.ci:61: referenced as `int`
	lib/stdlib.ci:37: referenced as `int`
	lib/stdlib.ci:31: referenced as `int32`
	lib/stdlib.ci:19: referenced as `int32`
	internal usages: 38
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/stmt.if.ci:77: referenced as `integer`
	test/lang/stmt.if.ci:73: referenced as `integer`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/init.array.ci:67: referenced as `integer`
	test/lang/init.array.ci:54: referenced as `integer`
	test/lang/init.array.ci:54: referenced as `integer`
	test/lang/init.array.ci:53: referenced as `integer`
	test/lang/init.array.ci:53: referenced as `integer`
	test/lang/init.array.ci:52: referenced as `integer`
	test/lang/init.array.ci:52: referenced as `integer`
	test/lang/init.array.ci:51: referenced as `integer`
	test/lang/init.array.ci:30: referenced as `integer`
	test/lang/init.array.ci:27: referenced as `integer`
	test/lang/init.array.ci:26: referenced as `integer`
	test/lang/init.array.ci:23: referenced as `integer`
	test/lang/init.array.ci:22: referenced as `integer`
	test/lang/init.array.ci:19: referenced as `integer`
	test/lang/init.array.ci:18: referenced as `integer`
	test/lang/init.array.ci:11: referenced as `integer`
	test/lang/init.array.ci:2: referenced as `integer`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/init.reference.ci:81: referenced as `int64`
	test/lang/init.reference.ci:61: referenced as `int64`
	test/lang/init.reference.ci:41: referenced as `int64`
	test/lang/init.reference.ci:29: referenced as `integer`
	test/lang/init.reference.ci:28: referenced as `integer`
	test/lang/init.reference.ci:27: referenced as `integer`
	test/lang/init.reference.ci:25: referenced as `integer`
	test/lang/init.reference.ci:24: referenced as `integer`
	test/lang/init.reference.ci:23: referenced as `integer`
	test/lang/init.reference.ci:16: referenced as `integer`
	test/lang/init.reference.ci:14: referenced as `integer`
	test/lang/init.reference.ci:13: referenced as `integer`
	test/lang/init.reference.ci:12: referenced as `integer`
	test/lang/init.reference.ci:8: referenced as `integer`
	test/lang/init.reference.ci:7: referenced as `integer`
	test/lang/init.reference.ci:3: referenced as `integer`
	test/std/memory.ci:30: referenced as `int64`
	test/std/memory.ci:29: referenced as `int64`
	test/std/memory.ci:24: referenced as `int64`
	test/std/memory.ci:23: referenced as `int64`
	test/lang/emit.ci:26: referenced as `int64`
	test/lang/emit.ci:24: referenced as `int64`
	test/lang/emit.ci:21: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	lib/std/string.ci:254: referenced as `int64`
	lib/std/string.ci:250: referenced as `int64`
	lib/std/string.ci:225: referenced as `int64`
	lib/stdlib.ci:34: referenced as `int64`
	lib/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/init.reference.ci:82: referenced as `uint8`
	test/lang/init.reference.ci:62: referenced as `uint8`
	test/lang/init.reference.ci:42: referenced as `uint8`
	test/std/tryExec.ci:16: referenced as `byte`
	lib/std/string.ci:223: referenced as `uint8`
	lib/stdlib.ci:25: referenced as `uint8`
	lib/stdlib.ci:13: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/init.reference.ci:83: referenced as `uint16`
	test/lang/init.reference.ci:63: referenced as `uint16`
	test/lang/init.reference.ci:43: referenced as `uint16`
	lib/std/string.ci:221: referenced as `uint16`
	lib/stdlib.ci:28: referenced as `uint16`
	lib/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0097b8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009ae8>, cast: static const inline)
.field pop: function (size: 0, offs: <@009ce8>, cast: static const inline)
.field swap: function (size: 0, offs: <@009ee8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00a0e8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00a2e8>, cast: static const inline)
.field hib: function (size: 0, offs: <@00a4e8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a6e8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/init.reference.ci:84: referenced as `uint32`
	test/lang/init.reference.ci:64: referenced as `uint32`
	test/lang/init.reference.ci:44: referenced as `uint32`
	test/std/number.ci:63: referenced as `uint32`
	test/std/number.ci:62: referenced as `uint32`
	test/std/number.ci:60: referenced as `uint32`
	test/std/number.ci:59: referenced as `uint32`
	test/std/number.ci:58: referenced as `uint32`
	test/std/number.ci:57: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:55: referenced as `uint32`
	test/std/number.ci:35: referenced as `uint32`
	test/std/number.ci:34: referenced as `uint32`
	test/std/number.ci:33: referenced as `uint32`
	test/std/number.ci:31: referenced as `uint32`
	test/std/number.ci:30: referenced as `uint32`
	test/std/number.ci:29: referenced as `uint32`
	test/std/number.ci:27: referenced as `uint32`
	test/std/number.ci:26: referenced as `uint32`
	test/std/number.ci:25: referenced as `uint32`
	test/std/number.ci:23: referenced as `uint32`
	test/std/number.ci:22: referenced as `uint32`
	test/std/number.ci:21: referenced as `uint32`
	lib/std/string.ci:219: referenced as `uint32`
	lib/stdlib.ci:31: referenced as `uint32`
	lib/stdlib.ci:19: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0097b8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/std/number.ci:62: referenced as `zxt`
	test/std/number.ci:31: referenced as `zxt`
	test/std/number.ci:30: referenced as `zxt`
	test/std/number.ci:29: referenced as `zxt`
	test/std/number.ci:23: referenced as `zxt`
	test/std/number.ci:22: referenced as `zxt`
	test/std/number.ci:21: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ae8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/std/number.ci:63: referenced as `sxt`
	test/std/number.ci:35: referenced as `sxt`
	test/std/number.ci:34: referenced as `sxt`
	test/std/number.ci:33: referenced as `sxt`
	test/std/number.ci:27: referenced as `sxt`
	test/std/number.ci:26: referenced as `sxt`
	test/std/number.ci:25: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ce8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/std/number.ci:55: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ee8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/std/number.ci:56: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0e8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/std/number.ci:57: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2e8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/std/number.ci:58: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a4e8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/std/number.ci:59: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a6e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	test/std/number.ci:60: referenced as `lob`
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00aa10>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00ad38>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/init.reference.ci:85: referenced as `uint64`
	test/lang/init.reference.ci:65: referenced as `uint64`
	test/lang/init.reference.ci:45: referenced as `uint64`
	test/std/number.ci:66: referenced as `uint64`
	test/std/number.ci:65: referenced as `uint64`
	lib/std/string.ci:254: referenced as `uint64`
	lib/std/string.ci:250: referenced as `uint64`
	lib/std/string.ci:231: referenced as `uint64`
	lib/std/string.ci:229: referenced as `uint64`
	lib/std/string.ci:227: referenced as `uint64`
	lib/std/string.ci:225: referenced as `uint64`
	lib/std/string.ci:223: referenced as `uint64`
	lib/std/string.ci:221: referenced as `uint64`
	lib/std/string.ci:219: referenced as `uint64`
	lib/std/string.ci:217: referenced as `uint64`
	lib/std/string.ci:217: referenced as `uint64`
	lib/std/string.ci:144: referenced as `uint64`
	lib/stdlib.ci:34: referenced as `uint64`
	lib/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00aa10>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(29)
.usages:
	test/std/number.ci:65: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad38>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(30)
.usages:
	test/std/number.ci:66: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00af38>, cast: static const inline)
.field cos: function (size: 0, offs: <@00b138>, cast: static const inline)
.field tan: function (size: 0, offs: <@00b338>, cast: static const inline)
.field log: function (size: 0, offs: <@00b538>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b738>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b9d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00bbd0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00be68>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:96: referenced as `float32`
	test/std/test.math.ci:95: referenced as `float32`
	test/std/test.math.ci:94: referenced as `float32`
	test/std/test.math.ci:93: referenced as `float32`
	test/std/test.math.ci:91: referenced as `float32`
	test/std/test.math.ci:90: referenced as `float32`
	test/std/test.math.ci:89: referenced as `float32`
	test/std/test.math.ci:88: referenced as `float32`
	test/std/test.math.ci:86: referenced as `float32`
	test/std/test.math.ci:85: referenced as `float32`
	test/std/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/init.reference.ci:86: referenced as `float32`
	test/lang/init.reference.ci:66: referenced as `float32`
	test/lang/init.reference.ci:46: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:7: referenced as `float32`
	test/std/number.ci:6: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:19: referenced as `float32`
	test/lang/emit.ci:19: referenced as `float32`
	test/lang/emit.ci:16: referenced as `float32`
	test/lang/emit.ci:16: referenced as `float32`
	test/lang/emit.ci:16: referenced as `float32`
	test/lang/emit.ci:16: referenced as `float32`
	lib/std/string.ci:259: referenced as `float32`
	lib/std/math/Matrix4f.ci:174: referenced as `float32`
	lib/std/math/Matrix4f.ci:173: referenced as `float32`
	lib/std/math/Matrix4f.ci:163: referenced as `float32`
	lib/std/math/Matrix4f.ci:160: referenced as `float32`
	lib/std/math/Matrix4f.ci:137: referenced as `float32`
	lib/std/math/Matrix4f.ci:136: referenced as `float32`
	lib/std/math/Matrix4f.ci:136: referenced as `float32`
	lib/std/math/Matrix4f.ci:135: referenced as `float32`
	lib/std/math/Matrix4f.ci:135: referenced as `float32`
	lib/std/math/Matrix4f.ci:133: referenced as `float32`
	lib/std/math/Matrix4f.ci:132: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:129: referenced as `float32`
	lib/std/math/Matrix4f.ci:128: referenced as `float32`
	lib/std/math/Matrix4f.ci:127: referenced as `float32`
	lib/std/math/Matrix4f.ci:126: referenced as `float32`
	lib/std/math/Matrix4f.ci:125: referenced as `float32`
	lib/std/math/Matrix4f.ci:124: referenced as `float32`
	lib/std/math/Matrix4f.ci:123: referenced as `float32`
	lib/std/math/Matrix4f.ci:122: referenced as `float32`
	lib/std/math/Matrix4f.ci:112: referenced as `float32`
	lib/std/math/Matrix4f.ci:111: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:57: referenced as `float32`
	lib/std/math/Matrix4f.ci:55: referenced as `float32`
	lib/std/math/Matrix4f.ci:53: referenced as `float32`
	lib/std/math/Matrix4f.ci:51: referenced as `float32`
	lib/std/math/Matrix4f.ci:48: referenced as `float32`
	lib/std/math/Matrix4f.ci:46: referenced as `float32`
	lib/std/math/Matrix4f.ci:44: referenced as `float32`
	lib/std/math/Matrix4f.ci:42: referenced as `float32`
	lib/std/math/Matrix4f.ci:39: referenced as `float32`
	lib/std/math/Matrix4f.ci:37: referenced as `float32`
	lib/std/math/Matrix4f.ci:35: referenced as `float32`
	lib/std/math/Matrix4f.ci:33: referenced as `float32`
	lib/std/math/Matrix4f.ci:30: referenced as `float32`
	lib/std/math/Matrix4f.ci:28: referenced as `float32`
	lib/std/math/Matrix4f.ci:26: referenced as `float32`
	lib/std/math/Matrix4f.ci:24: referenced as `float32`
	lib/std/math/Matrix4f.ci:7: referenced as `float32`
	lib/std/math/Matrix4f.ci:4: referenced as `float32`
	lib/std/math/Vector4f.ci:111: referenced as `float32`
	lib/std/math/Vector4f.ci:111: referenced as `float32`
	lib/std/math/Vector4f.ci:106: referenced as `float32`
	lib/std/math/Vector4f.ci:100: referenced as `float32`
	lib/std/math/Vector4f.ci:96: referenced as `float32`
	lib/std/math/Vector4f.ci:92: referenced as `float32`
	lib/std/math/Vector4f.ci:88: referenced as `float32`
	lib/std/math/Vector4f.ci:88: referenced as `float32`
	lib/std/math/Vector4f.ci:38: referenced as `float32`
	lib/std/math/Vector4f.ci:35: referenced as `float32`
	lib/std/math/Vector4f.ci:32: referenced as `float32`
	lib/std/math/Vector4f.ci:32: referenced as `float32`
	lib/std/math/Vector4f.ci:29: referenced as `float32`
	lib/std/math/Vector4f.ci:29: referenced as `float32`
	lib/std/math/Vector4f.ci:29: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:13: referenced as `float32`
	lib/std/math/Vector4f.ci:11: referenced as `float32`
	lib/std/math/Vector4f.ci:9: referenced as `float32`
	lib/std/math/Vector4f.ci:7: referenced as `float32`
	lib/std/math/Vector4f.ci:4: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af38>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/std/number.ci:46: referenced as `sin`
	test/lang/emit.ci:16: referenced as `sin`
	lib/std/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b138>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/std/number.ci:47: referenced as `cos`
	lib/std/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/std/number.ci:48: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b538>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/std/number.ci:49: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b738>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/std/number.ci:50: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b9d0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(36)
.usages:
	test/std/number.ci:51: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bbd0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(37)
.usages:
	test/std/number.ci:52: referenced as `sqrt`
	lib/std/math/Vector4f.ci:106: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be68>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(38)
.usages:
	test/std/number.ci:53: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00c060>, cast: static const inline)
.field cos: function (size: 0, offs: <@00c258>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c450>, cast: static const inline)
.field log: function (size: 0, offs: <@00c648>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c840>, cast: static const inline)
.field pow: function (size: 0, offs: <@00cad0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00ccc8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00cf58>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:82: referenced as `float64`
	test/std/test.math.ci:81: referenced as `float64`
	test/std/test.math.ci:80: referenced as `float64`
	test/std/test.math.ci:79: referenced as `float64`
	test/std/test.math.ci:77: referenced as `float64`
	test/std/test.math.ci:76: referenced as `float64`
	test/std/test.math.ci:75: referenced as `float64`
	test/std/test.math.ci:74: referenced as `float64`
	test/std/test.math.ci:72: referenced as `float64`
	test/std/test.math.ci:71: referenced as `float64`
	test/std/test.math.ci:70: referenced as `float64`
	test/std/test.math.ci:64: referenced as `float64`
	test/std/test.math.ci:63: referenced as `float64`
	test/std/test.math.ci:61: referenced as `float64`
	test/std/test.math.ci:60: referenced as `float64`
	test/std/test.math.ci:59: referenced as `float64`
	test/std/test.math.ci:58: referenced as `float64`
	test/std/test.math.ci:57: referenced as `float64`
	test/std/test.math.ci:55: referenced as `float64`
	test/std/test.math.ci:54: referenced as `float64`
	test/std/test.math.ci:53: referenced as `float64`
	test/std/test.math.ci:52: referenced as `float64`
	test/std/test.math.ci:51: referenced as `float64`
	test/std/test.math.ci:50: referenced as `float64`
	test/std/test.math.ci:49: referenced as `float64`
	test/std/test.math.ci:48: referenced as `float64`
	test/std/test.math.ci:46: referenced as `float64`
	test/std/test.math.ci:45: referenced as `float64`
	test/std/test.math.ci:44: referenced as `float64`
	test/std/test.math.ci:43: referenced as `float64`
	test/std/test.math.ci:41: referenced as `float64`
	test/std/test.math.ci:40: referenced as `float64`
	test/std/test.math.ci:39: referenced as `float64`
	test/std/test.math.ci:38: referenced as `float64`
	test/std/test.math.ci:36: referenced as `float64`
	test/std/test.math.ci:35: referenced as `float64`
	test/std/test.math.ci:33: referenced as `float64`
	test/std/test.math.ci:32: referenced as `float64`
	test/std/test.math.ci:30: referenced as `float64`
	test/std/test.math.ci:29: referenced as `float64`
	test/std/test.math.ci:27: referenced as `float64`
	test/std/test.math.ci:26: referenced as `float64`
	test/std/test.math.ci:25: referenced as `float64`
	test/std/test.math.ci:24: referenced as `float64`
	test/std/test.math.ci:22: referenced as `float64`
	test/std/test.math.ci:21: referenced as `float64`
	test/std/test.math.ci:20: referenced as `float64`
	test/std/test.math.ci:19: referenced as `float64`
	test/std/test.math.ci:18: referenced as `float64`
	test/std/test.math.ci:17: referenced as `float64`
	test/std/test.math.ci:15: referenced as `float64`
	test/std/test.math.ci:14: referenced as `float64`
	test/std/test.math.ci:13: referenced as `float64`
	test/std/test.math.ci:12: referenced as `float64`
	test/std/test.math.ci:11: referenced as `float64`
	test/std/test.math.ci:10: referenced as `float64`
	test/std/test.math.ci:8: referenced as `float64`
	test/std/test.math.ci:7: referenced as `float64`
	test/std/test.math.ci:6: referenced as `float64`
	test/std/test.math.ci:5: referenced as `float64`
	test/std/test.math.ci:4: referenced as `float64`
	test/std/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/init.variable.ci:15: referenced as `float64`
	test/lang/init.variable.ci:14: referenced as `float64`
	test/lang/init.variable.ci:11: referenced as `float64`
	test/lang/init.variable.ci:10: referenced as `float64`
	test/lang/init.reference.ci:87: referenced as `float64`
	test/lang/init.reference.ci:67: referenced as `float64`
	test/lang/init.reference.ci:47: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:4: referenced as `float64`
	test/std/number.ci:3: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:21: referenced as `float64`
	test/lang/emit.ci:21: referenced as `float64`
	lib/std/string.ci:259: referenced as `float64`
	lib/std/string.ci:253: referenced as `float64`
	lib/std/string.ci:249: referenced as `float64`
	lib/std/string.ci:234: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:9: referenced as `float64`
	lib/std/math/Vector2d.ci:7: referenced as `float64`
	lib/std/math/Vector2d.ci:4: referenced as `float64`
	lib/std/math/Complex.ci:187: referenced as `float64`
	lib/std/math/Complex.ci:187: referenced as `float64`
	lib/std/math/Complex.ci:151: referenced as `float64`
	lib/std/math/Complex.ci:151: referenced as `float64`
	lib/std/math/Complex.ci:149: referenced as `float64`
	lib/std/math/Complex.ci:149: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:142: referenced as `float64`
	lib/std/math/Complex.ci:141: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:137: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:132: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:118: referenced as `float64`
	lib/std/math/Complex.ci:114: referenced as `float64`
	lib/std/math/Complex.ci:112: referenced as `float64`
	lib/std/math/Complex.ci:109: referenced as `float64`
	lib/std/math/Complex.ci:107: referenced as `float64`
	lib/std/math/Complex.ci:99: referenced as `float64`
	lib/std/math/Complex.ci:98: referenced as `float64`
	lib/std/math/Complex.ci:92: referenced as `float64`
	lib/std/math/Complex.ci:91: referenced as `float64`
	lib/std/math/Complex.ci:83: referenced as `float64`
	lib/std/math/Complex.ci:81: referenced as `float64`
	lib/std/math/Complex.ci:73: referenced as `float64`
	lib/std/math/Complex.ci:71: referenced as `float64`
	lib/std/math/Complex.ci:66: referenced as `float64`
	lib/std/math/Complex.ci:64: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:24: referenced as `float64`
	lib/std/math/Complex.ci:8: referenced as `float64`
	lib/std/math/Complex.ci:5: referenced as `float64`
	lib/std/math.ci:524: referenced as `float64`
	lib/std/math.ci:524: referenced as `float64`
	lib/std/math.ci:521: referenced as `float64`
	lib/std/math.ci:521: referenced as `float64`
	lib/std/math.ci:497: referenced as `float64`
	lib/std/math.ci:484: referenced as `float64`
	lib/std/math.ci:481: referenced as `float64`
	lib/std/math.ci:479: referenced as `float64`
	lib/std/math.ci:479: referenced as `float64`
	lib/std/math.ci:462: referenced as `float64`
	lib/std/math.ci:462: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:447: referenced as `float64`
	lib/std/math.ci:447: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:430: referenced as `float64`
	lib/std/math.ci:427: referenced as `float64`
	lib/std/math.ci:410: referenced as `float64`
	lib/std/math.ci:408: referenced as `float64`
	lib/std/math.ci:408: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:391: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:373: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:351: referenced as `float64`
	lib/std/math.ci:351: referenced as `float64`
	lib/std/math.ci:348: referenced as `float64`
	lib/std/math.ci:345: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:338: referenced as `float64`
	lib/std/math.ci:321: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:314: referenced as `float64`
	lib/std/math.ci:308: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:294: referenced as `float64`
	lib/std/math.ci:294: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:243: referenced as `float64`
	lib/std/math.ci:243: referenced as `float64`
	lib/std/math.ci:238: referenced as `float64`
	lib/std/math.ci:238: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c060>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/std/number.ci:37: referenced as `sin`
	lib/std/math/Complex.ci:187: referenced as `sin`
	lib/std/math/Complex.ci:151: referenced as `sin`
	lib/std/math/Complex.ci:149: referenced as `sin`
	lib/std/math/Complex.ci:142: referenced as `sin`
	lib/std/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c258>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/std/number.ci:38: referenced as `cos`
	lib/std/math/Complex.ci:187: referenced as `cos`
	lib/std/math/Complex.ci:151: referenced as `cos`
	lib/std/math/Complex.ci:149: referenced as `cos`
	lib/std/math/Complex.ci:141: referenced as `cos`
	lib/std/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c450>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/std/number.ci:39: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c648>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/std/number.ci:40: referenced as `log`
	lib/std/math/Complex.ci:138: referenced as `log`
	lib/std/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c840>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/std/number.ci:41: referenced as `exp`
	lib/std/math/Complex.ci:139: referenced as `exp`
	lib/std/math/Complex.ci:129: referenced as `exp`
	lib/std/math/Complex.ci:129: referenced as `exp`
	lib/std/math.ci:454: referenced as `exp`
	lib/std/math.ci:454: referenced as `exp`
	lib/std/math.ci:452: referenced as `exp`
	lib/std/math.ci:432: referenced as `exp`
	lib/std/math.ci:432: referenced as `exp`
	lib/std/math.ci:427: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cad0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(44)
.usages:
	test/std/number.ci:42: referenced as `pow`
	lib/std/string.ci:253: referenced as `pow`
	lib/std/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ccc8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(45)
.usages:
	test/std/number.ci:43: referenced as `sqrt`
	lib/std/math/Complex.ci:112: referenced as `sqrt`
	lib/std/math.ci:479: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cf58>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(46)
.usages:
	test/std/number.ci:44: referenced as `atan2`
	lib/std/math/Complex.ci:114: referenced as `atan2`
	lib/std/math.ci:484: referenced as `atan2`
	lib/std/math.ci:481: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007e90>, cast: static const inline)
.field fill: function (size: 0, offs: <@0081c8>, cast: static const inline)
.field copy: function (size: 0, offs: <@008500>, cast: static const inline)
.field move: function (size: 0, offs: <@008830>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/init.reference.ci:108: referenced as `pointer`
	test/lang/init.reference.ci:95: referenced as `pointer`
	test/lang/init.reference.ci:95: referenced as `pointer`
	test/lang/init.reference.ci:90: referenced as `pointer`
	test/lang/init.reference.ci:70: referenced as `pointer`
	test/lang/init.reference.ci:52: referenced as `pointer`
	test/lang/init.reference.ci:51: referenced as `pointer`
	test/lang/init.reference.ci:50: referenced as `pointer`
	test/lang/init.reference.ci:50: referenced as `pointer`
	test/lang/init.reference.ci:49: referenced as `pointer`
	test/lang/init.reference.ci:48: referenced as `pointer`
	test/lang/init.reference.ci:47: referenced as `pointer`
	test/lang/init.reference.ci:46: referenced as `pointer`
	test/lang/init.reference.ci:45: referenced as `pointer`
	test/lang/init.reference.ci:44: referenced as `pointer`
	test/lang/init.reference.ci:43: referenced as `pointer`
	test/lang/init.reference.ci:42: referenced as `pointer`
	test/lang/init.reference.ci:41: referenced as `pointer`
	test/lang/init.reference.ci:40: referenced as `pointer`
	test/lang/init.reference.ci:39: referenced as `pointer`
	test/lang/init.reference.ci:38: referenced as `pointer`
	test/lang/init.reference.ci:37: referenced as `pointer`
	test/lang/init.reference.ci:36: referenced as `pointer`
	test/lang/init.reference.ci:35: referenced as `pointer`
	test/lang/init.reference.ci:30: referenced as `pointer`
	test/lang/init.reference.ci:23: referenced as `pointer`
	test/lang/init.reference.ci:17: referenced as `pointer`
	test/lang/init.reference.ci:9: referenced as `pointer`
	test/std/tryExec.ci:43: referenced as `pointer`
	test/std/tryExec.ci:38: referenced as `pointer`
	test/std/tryExec.ci:24: referenced as `pointer`
	test/std/tryExec.ci:20: referenced as `pointer`
	test/std/tryExec.ci:14: referenced as `pointer`
	test/std/tryExec.ci:11: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:14: referenced as `pointer`
	test/std/memory.ci:13: referenced as `pointer`
	test/std/memory.ci:10: referenced as `pointer`
	test/std/memory.ci:9: referenced as `pointer`
	test/std/memory.ci:8: referenced as `pointer`
	test/std/memory.ci:7: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:4: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/lang/emit.ci:29: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e90>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/std/memory.ci:5: referenced as `alloc`
	test/std/memory.ci:4: referenced as `alloc`
	test/std/memory.ci:3: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0081c8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: uint8 (size: 4, offs: <+8>, cast: variable(u32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(11)
.usages:
	test/std/memory.ci:30: referenced as `fill`
	test/std/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008500>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	test/std/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008830>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	test/std/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.field as: function (size: 0, offs: <@005cd8>, cast: static const inline)
.usages:
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/init.reference.ci:105: referenced as `variant`
	test/lang/init.reference.ci:96: referenced as `variant`
	test/lang/init.reference.ci:96: referenced as `variant`
	test/lang/init.reference.ci:91: referenced as `variant`
	test/lang/init.reference.ci:72: referenced as `variant`
	test/lang/init.reference.ci:71: referenced as `variant`
	test/lang/init.reference.ci:71: referenced as `variant`
	test/lang/init.reference.ci:70: referenced as `variant`
	test/lang/init.reference.ci:69: referenced as `variant`
	test/lang/init.reference.ci:68: referenced as `variant`
	test/lang/init.reference.ci:67: referenced as `variant`
	test/lang/init.reference.ci:66: referenced as `variant`
	test/lang/init.reference.ci:65: referenced as `variant`
	test/lang/init.reference.ci:64: referenced as `variant`
	test/lang/init.reference.ci:63: referenced as `variant`
	test/lang/init.reference.ci:62: referenced as `variant`
	test/lang/init.reference.ci:61: referenced as `variant`
	test/lang/init.reference.ci:60: referenced as `variant`
	test/lang/init.reference.ci:59: referenced as `variant`
	test/lang/init.reference.ci:58: referenced as `variant`
	test/lang/init.reference.ci:57: referenced as `variant`
	test/lang/init.reference.ci:56: referenced as `variant`
	test/lang/init.reference.ci:55: referenced as `variant`
	test/lang/init.reference.ci:51: referenced as `variant`
	test/lang/init.reference.ci:31: referenced as `variant`
	test/lang/init.reference.ci:24: referenced as `variant`
	test/lang/init.reference.ci:18: referenced as `variant`
	test/lang/init.reference.ci:10: referenced as `variant`
	lib/std/debug.ci:65: referenced as `variant`
	lib/std/debug.ci:56: referenced as `variant`
	lib/std/debug.ci:53: referenced as `variant`
	lib/std/debug.ci:50: referenced as `variant`
	lib/std/debug.ci:41: referenced as `variant`
	lib/std/debug.ci:34: referenced as `variant`
	lib/std/debug.ci:29: referenced as `variant`
	lib/std/debug.ci:24: referenced as `variant`
	lib/std/debug.ci:19: referenced as `variant`
	lib/std/debug.ci:14: referenced as `variant`
	lib/std/debug.ci:9: referenced as `variant`
	lib/std/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005cd8>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/init.reference.ci:89: referenced as `function`
	test/lang/init.reference.ci:69: referenced as `function`
	test/lang/init.reference.ci:49: referenced as `function`
	test/lang/init.reference.ci:20: referenced as `function`
	lib/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@0068b8>, cast: static const inline)
.field as: function (size: 0, offs: <@006b50>, cast: static const inline)
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/init.variable.ci:41: referenced as `object`
	test/lang/init.variable.ci:13: referenced as `object`
	test/lang/init.reference.ci:92: referenced as `object`
	test/lang/init.reference.ci:72: referenced as `object`
	test/lang/init.reference.ci:52: referenced as `object`
	test/lang/init.reference.ci:21: referenced as `object`
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b8>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/stmt.if.ci:73: referenced as `null`
	test/lang/stmt.if.ci:22: referenced as `null`
	test/lang/stmt.if.ci:19: referenced as `null`
	test/lang/stmt.if.ci:15: referenced as `null`
	test/lang/stmt.if.ci:12: referenced as `null`
	test/lang/stmt.if.ci:8: referenced as `null`
	test/lang/stmt.if.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/init.array.ci:60: referenced as `null`
	test/lang/init.array.ci:19: referenced as `null`
	test/lang/init.array.ci:18: referenced as `null`
	test/lang/init.array.ci:2: referenced as `null`
	test/lang/init.method.ci:92: referenced as `null`
	test/lang/init.method.ci:86: referenced as `null`
	test/lang/init.reference.ci:21: referenced as `null`
	test/lang/init.reference.ci:20: referenced as `null`
	test/lang/init.reference.ci:19: referenced as `null`
	test/lang/init.reference.ci:18: referenced as `null`
	test/lang/init.reference.ci:17: referenced as `null`
	test/lang/init.reference.ci:16: referenced as `null`
	test/lang/init.reference.ci:3: referenced as `null`
	test/std/tryExec.ci:53: referenced as `null`
	test/std/tryExec.ci:52: referenced as `null`
	test/std/tryExec.ci:51: referenced as `null`
	test/std/tryExec.ci:50: referenced as `null`
	test/std/tryExec.ci:49: referenced as `null`
	test/std/tryExec.ci:48: referenced as `null`
	test/std/tryExec.ci:48: referenced as `null`
	test/std/tryExec.ci:47: referenced as `null`
	test/std/tryExec.ci:39: referenced as `null`
	test/std/memory.ci:4: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/std/debug.ci:74: referenced as `null`
	lib/std/debug.ci:56: referenced as `null`
	lib/std/debug.ci:38: referenced as `null`
	lib/std/debug.ci:36: referenced as `null`
	lib/std/debug.ci:31: referenced as `null`
	lib/std/debug.ci:26: referenced as `null`
	lib/std/debug.ci:21: referenced as `null`
	lib/std/debug.ci:16: referenced as `null`
	lib/std/debug.ci:11: referenced as `null`
	lib/std/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000d38>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000dd8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001198>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001238>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0014b8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a58>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001df0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001fd0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0021a0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002370>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002540>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002710>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002a10>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002e60>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003290>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036c0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c20>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004180>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0045b0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@0049e0>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004e10>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005240>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005410>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@0055e0>, cast: static const typename(void))
.usages:
	test/std/tryExec.ci:44: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:29: referenced as `emit`
	test/lang/emit.ci:21: referenced as `emit`
	test/lang/emit.ci:19: referenced as `emit`
	test/lang/emit.ci:16: referenced as `emit`
	test/lang/emit.ci:13: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/std/math/Vector2d.ci:40: referenced as `emit`
	lib/std/math/Vector2d.ci:37: referenced as `emit`
	lib/std/math/Vector2d.ci:34: referenced as `emit`
	lib/std/math/Vector2d.ci:31: referenced as `emit`
	lib/std/math/Vector2d.ci:28: referenced as `emit`
	lib/std/math/Vector2d.ci:25: referenced as `emit`
	lib/std/math/Vector2d.ci:22: referenced as `emit`
	lib/std/math/Vector4f.ci:100: referenced as `emit`
	lib/std/math/Vector4f.ci:96: referenced as `emit`
	lib/std/math/Vector4f.ci:92: referenced as `emit`
	lib/std/math/Vector4f.ci:82: referenced as `emit`
	lib/std/math/Vector4f.ci:80: referenced as `emit`
	lib/std/math/Vector4f.ci:77: referenced as `emit`
	lib/std/math/Vector4f.ci:75: referenced as `emit`
	lib/std/math/Vector4f.ci:73: referenced as `emit`
	lib/std/math/Vector4f.ci:71: referenced as `emit`
	lib/std/math/Vector4f.ci:69: referenced as `emit`
	lib/std/math/Vector4f.ci:26: referenced as `emit`
	lib/std/math/Complex.ci:76: referenced as `emit`
	lib/std/math/Complex.ci:69: referenced as `emit`
	lib/std/math/Complex.ci:62: referenced as `emit`
	lib/std/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/std/tryExec.ci:44: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001198>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:100: referenced as `p4x`
	lib/std/math/Vector4f.ci:96: referenced as `p4x`
	lib/std/math/Vector4f.ci:92: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/std/math/Vector4f.ci:92: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/std/math/Vector4f.ci:100: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001238>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0014b8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/std/tryExec.ci:44: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/std/tryExec.ci:44: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a58>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001df0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001fd0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0021a0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002370>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002540>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002710>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a10>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/std/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	lib/std/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002e60>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `add`
	lib/std/math/Vector2d.ci:22: referenced as `add`
	lib/std/math/Vector4f.ci:71: referenced as `add`
	lib/std/math/Complex.ci:77: referenced as `add`
	lib/std/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	lib/std/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `p2d`
	lib/std/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003290>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `sub`
	lib/std/math/Vector4f.ci:73: referenced as `sub`
	lib/std/math/Complex.ci:78: referenced as `sub`
	lib/std/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	lib/std/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/std/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `p2d`
	lib/std/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036c0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:28: referenced as `mul`
	lib/std/math/Vector4f.ci:75: referenced as `mul`
	lib/std/math/Complex.ci:78: referenced as `mul`
	lib/std/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/std/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	lib/std/math/Vector2d.ci:28: referenced as `p2d`
	lib/std/math/Complex.ci:78: referenced as `p2d`
	lib/std/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c20>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:16: referenced as `div`
	test/lang/emit.ci:13: referenced as `div`
	lib/std/math/Vector2d.ci:31: referenced as `div`
	lib/std/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
	test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	lib/std/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004180>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0045b0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	lib/std/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0049e0>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e10>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005240>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:80: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/std/math/Vector4f.ci:80: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	lib/std/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005410>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	lib/std/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0055e0>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Complex.ci:78: referenced as `swz`
	lib/std/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	lib/std/math/Complex.ci:78: referenced as `x2`
	lib/std/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005a38>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007310>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(8)
.usages:
	test/lang/stmt.if.ci:69: referenced as `raise`
	test/lang/stmt.if.ci:69: referenced as `raise`
	test/lang/stmt.if.ci:66: referenced as `raise`
	test/lang/stmt.if.ci:66: referenced as `raise`
	test/lang/stmt.if.ci:63: referenced as `raise`
	test/lang/stmt.if.ci:63: referenced as `raise`
	test/lang/stmt.if.ci:60: referenced as `raise`
	test/lang/stmt.if.ci:60: referenced as `raise`
	test/lang/stmt.if.ci:57: referenced as `raise`
	test/lang/stmt.if.ci:57: referenced as `raise`
	test/lang/stmt.if.ci:54: referenced as `raise`
	test/lang/stmt.if.ci:54: referenced as `raise`
	test/lang/stmt.if.ci:51: referenced as `raise`
	test/lang/stmt.if.ci:51: referenced as `raise`
	test/lang/stmt.if.ci:47: referenced as `raise`
	test/lang/stmt.if.ci:47: referenced as `raise`
	test/lang/stmt.if.ci:44: referenced as `raise`
	test/lang/stmt.if.ci:44: referenced as `raise`
	test/lang/stmt.if.ci:40: referenced as `raise`
	test/lang/stmt.if.ci:40: referenced as `raise`
	test/lang/stmt.if.ci:37: referenced as `raise`
	test/lang/stmt.if.ci:37: referenced as `raise`
	test/lang/stmt.if.ci:33: referenced as `raise`
	test/lang/stmt.if.ci:33: referenced as `raise`
	test/lang/stmt.if.ci:29: referenced as `raise`
	test/lang/stmt.if.ci:29: referenced as `raise`
	test/lang/stmt.if.ci:22: referenced as `raise`
	test/lang/stmt.if.ci:22: referenced as `raise`
	test/lang/stmt.if.ci:19: referenced as `raise`
	test/lang/stmt.if.ci:19: referenced as `raise`
	test/lang/stmt.if.ci:15: referenced as `raise`
	test/lang/stmt.if.ci:15: referenced as `raise`
	test/lang/stmt.if.ci:12: referenced as `raise`
	test/lang/stmt.if.ci:12: referenced as `raise`
	test/lang/stmt.if.ci:8: referenced as `raise`
	test/lang/stmt.if.ci:8: referenced as `raise`
	test/lang/stmt.if.ci:4: referenced as `raise`
	test/lang/stmt.if.ci:4: referenced as `raise`
	lib/std/debug.ci:71: referenced as `raise`
	lib/std/debug.ci:71: referenced as `raise`
	lib/std/debug.ci:71: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/std/debug.ci:71: referenced as `abort`
	lib/std/debug.ci:38: referenced as `abort`
	lib/std/debug.ci:36: referenced as `abort`
	lib/std/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/std/debug.ci:31: referenced as `error`
	lib/std/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/std/debug.ci:26: referenced as `warn`
	lib/std/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/std/debug.ci:21: referenced as `info`
	lib/std/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/stmt.if.ci:69: referenced as `debug`
	test/lang/stmt.if.ci:66: referenced as `debug`
	test/lang/stmt.if.ci:63: referenced as `debug`
	test/lang/stmt.if.ci:60: referenced as `debug`
	test/lang/stmt.if.ci:57: referenced as `debug`
	test/lang/stmt.if.ci:54: referenced as `debug`
	test/lang/stmt.if.ci:51: referenced as `debug`
	test/lang/stmt.if.ci:47: referenced as `debug`
	test/lang/stmt.if.ci:44: referenced as `debug`
	test/lang/stmt.if.ci:40: referenced as `debug`
	test/lang/stmt.if.ci:37: referenced as `debug`
	test/lang/stmt.if.ci:33: referenced as `debug`
	test/lang/stmt.if.ci:29: referenced as `debug`
	test/lang/stmt.if.ci:22: referenced as `debug`
	test/lang/stmt.if.ci:19: referenced as `debug`
	test/lang/stmt.if.ci:15: referenced as `debug`
	test/lang/stmt.if.ci:12: referenced as `debug`
	test/lang/stmt.if.ci:8: referenced as `debug`
	test/lang/stmt.if.ci:4: referenced as `debug`
	lib/std/debug.ci:16: referenced as `debug`
	lib/std/debug.ci:14: referenced as `debug`
	lib/std/debug.ci:11: referenced as `debug`
	lib/std/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/std/debug.ci:6: referenced as `verbose`
	lib/std/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/std/debug.ci:26: referenced as `noTrace`
	lib/std/debug.ci:24: referenced as `noTrace`
	lib/std/debug.ci:21: referenced as `noTrace`
	lib/std/debug.ci:19: referenced as `noTrace`
	lib/std/debug.ci:11: referenced as `noTrace`
	lib/std/debug.ci:9: referenced as `noTrace`
	lib/std/debug.ci:6: referenced as `noTrace`
	lib/std/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/std/debug.ci:71: referenced as `defTrace`
	lib/std/debug.ci:38: referenced as `defTrace`
	lib/std/debug.ci:36: referenced as `defTrace`
	lib/std/debug.ci:34: referenced as `defTrace`
	lib/std/debug.ci:31: referenced as `defTrace`
	lib/std/debug.ci:29: referenced as `defTrace`
	lib/std/debug.ci:16: referenced as `defTrace`
	lib/std/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bf0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
	test/std/tryExec.ci:53: referenced as `tryExec`
	test/std/tryExec.ci:52: referenced as `tryExec`
	test/std/tryExec.ci:51: referenced as `tryExec`
	test/std/tryExec.ci:50: referenced as `tryExec`
	test/std/tryExec.ci:49: referenced as `tryExec`
	test/std/tryExec.ci:48: referenced as `tryExec`
	test/std/tryExec.ci:47: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008860>
.name: 'System'
.field exit: function (size: 0, offs: <@008ad8>, cast: static const inline)
.field srand: function (size: 0, offs: <@008ce0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008e48>, cast: static const inline)
.field time: function (size: 0, offs: <@008fb0>, cast: static const inline)
.field clock: function (size: 0, offs: <@009118>, cast: static const inline)
.field millis: function (size: 0, offs: <@009280>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009480>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008ad8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(14)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008ce0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(15)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e48>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(16)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008fb0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009118>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009280>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(19)
.usages:
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009480>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(20)
.usages:
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:470: referenced as `true`
	lib/std/math.ci:423: referenced as `true`
	lib/std/math.ci:384: referenced as `true`
	lib/std/math.ci:380: referenced as `true`
	lib/std/math.ci:369: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:242: referenced as `false`
	lib/std/string.ci:114: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:468: referenced as `false`
	lib/std/math.ci:420: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/std/math.ci:364: referenced as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'lib/stdlib.ci:13'
.param .result: int8 (size: 1, offs: <+0>, cast: i32)
.param value: uint8 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'lib/stdlib.ci:16'
.param .result: int16 (size: 2, offs: <+0>, cast: i32)
.param value: uint16 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'lib/stdlib.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	lib/std/math.ci:239: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'lib/stdlib.ci:22'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'lib/stdlib.ci:25'
.param .result: uint8 (size: 1, offs: <+0>, cast: u32)
.param value: int8 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'lib/stdlib.ci:28'
.param .result: uint16 (size: 2, offs: <+0>, cast: u32)
.param value: int16 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'lib/stdlib.ci:31'
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'lib/stdlib.ci:34'
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param value: int64 (size: 8, offs: <+8>, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:37'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	test/std/memory.ci:30: referenced as `sizeof`
	test/std/memory.ci:29: referenced as `sizeof`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/stmt.for.ci:28: referenced as `debug`
	test/lang/stmt.for.ci:21: referenced as `debug`
	test/lang/stmt.for.ci:14: referenced as `debug`
	test/lang/stmt.for.ci:9: referenced as `debug`
	test/lang/init.array.ci:41: referenced as `debug`
	test/lang/init.array.ci:38: referenced as `debug`
	test/lang/init.array.ci:35: referenced as `debug`
	test/std/memory.ci:33: referenced as `debug`
	test/std/memory.ci:32: referenced as `debug`
	test/std/memory.ci:27: referenced as `debug`
	test/std/memory.ci:26: referenced as `debug`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/stmt.for.ci:4: referenced as `debug`
	test/lang/init.method.ci:91: referenced as `debug`
	test/lang/init.method.ci:85: referenced as `debug`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/init.method.ci:58: referenced as `trace`
	test/lang/init.method.ci:48: referenced as `trace`
	test/lang/init.method.ci:41: referenced as `trace`
	test/lang/init.method.ci:11: referenced as `trace`
	lib/std/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/stmt.if.ci:78: referenced as `error`
	test/lang/stmt.if.ci:74: referenced as `error`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/std/tryExec.ci:35: referenced as `abort`
	lib/std/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/std/debug.ci:45: referenced as `abort`
	lib/std/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:162: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/init.array.ci:84: referenced as `assert`
	test/lang/init.array.ci:82: referenced as `assert`
	test/lang/init.array.ci:80: referenced as `assert`
	test/lang/init.array.ci:78: referenced as `assert`
	test/lang/init.array.ci:77: referenced as `assert`
	test/lang/init.array.ci:76: referenced as `assert`
	test/lang/init.array.ci:74: referenced as `assert`
	test/lang/init.array.ci:73: referenced as `assert`
	test/lang/init.array.ci:72: referenced as `assert`
	test/lang/init.array.ci:70: referenced as `assert`
	test/lang/init.array.ci:69: referenced as `assert`
	test/lang/init.array.ci:68: referenced as `assert`
	test/lang/init.array.ci:49: referenced as `assert`
	test/lang/init.array.ci:48: referenced as `assert`
	lib/std/string.ci:204: referenced as `assert`
	lib/std/string.ci:197: referenced as `assert`
	lib/std/string.ci:190: referenced as `assert`
	lib/std/string.ci:185: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@011588>
.name: 'NotEquals'
.file: 'lib/std/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field extras: variant[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: '@public'
.usages:
	lib/std/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/std/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/std/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/std/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/std/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.offset: <+16>
.name: 'extras'
.file: 'lib/std/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 103
.offset: <@059148>
.name: 'assertEq'
.file: 'lib/std/debug.ci:61'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	extras: variant[1] := {
		void(extras[0] := (message));
	};
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.extras := (extras));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (103 bytes: <@059148> - <@0591af>)
	lib/std/debug.ci:62: (10 bytes: <@059148> - <@059152>): if (returned == expected)
	<assertEq @059148>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @05914a>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @05914c>    : 57                         ceq.i32
	<assertEq+5 @05914d>    : 06 05 00 00                jz <assertEq+10 @059152>
	lib/std/debug.ci:63: (1 byte: <@059151> - <@059152>): return;
	<assertEq+9 @059151>    : 03                         ret
	lib/std/debug.ci:65: (13 bytes: <@059152> - <@05915f>): extras: variant[1] := {...}
	<assertEq+10 @059152>   : 09 08 00 00                inc.sp(+8)
	lib/std/debug.ci:65: (9 bytes: <@059156> - <@05915f>): extras[0] := (message);
	<assertEq+14 @059156>   : 1f 48 1a 01 00             load.ref <@011a48>
	<assertEq+19 @05915b>   : 10 04                      dup.x32 sp(4)
	<assertEq+21 @05915d>   : 14 02                      set.x64 sp(2)
	lib/std/debug.ci:66: (37 bytes: <@05915f> - <@059184>): details: NotEquals := {...}
	<assertEq+23 @05915f>   : 09 18 00 00                inc.sp(+24)
	lib/std/debug.ci:67: (11 bytes: <@059163> - <@05916e>): details.expected := (expected);
	<assertEq+27 @059163>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+32 @059168>   : 0a 30 00 00                load.sp(+48)
	<assertEq+36 @05916c>   : 14 02                      set.x64 sp(2)
	lib/std/debug.ci:68: (11 bytes: <@05916e> - <@059179>): details.returned := (returned);
	<assertEq+38 @05916e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+43 @059173>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+47 @059177>   : 14 04                      set.x64 sp(4)
	lib/std/debug.ci:69: (11 bytes: <@059179> - <@059184>): details.extras := (extras);
	<assertEq+49 @059179>   : 1c 01 00 00 00             load.c32 1
	<assertEq+54 @05917e>   : 0a 1c 00 00                load.sp(+28)
	<assertEq+58 @059182>   : 14 06                      set.x64 sp(6)
	lib/std/debug.ci:71: (38 bytes: <@059184> - <@0591aa>): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+60 @059184>   : 1f b0 e3 00 00             load.ref <@00e3b0> ;"lib/std/debug.ci"
	<assertEq+65 @059189>   : 1c 47 00 00 00             load.c32 71
	<assertEq+70 @05918e>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+75 @059193>   : 1c 80 00 00 00             load.c32 128
	<assertEq+80 @059198>   : 1f 8c e6 00 00             load.ref <@00e68c> ;"assertion failed"
	<assertEq+85 @05919d>   : 1f 88 15 01 00             load.ref <@011588> ;NotEquals
	<assertEq+90 @0591a2>   : 0a 18 00 00                load.sp(+24)
	<assertEq+94 @0591a6>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+98 @0591aa>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+102 @0591ae>  : 03                         ret
.usages:
	lib/std/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/std/debug.ci:74'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/init.array.ci:64: referenced as `assertEq`
	test/lang/init.array.ci:63: referenced as `assertEq`
	test/lang/init.array.ci:62: referenced as `assertEq`
	test/lang/init.array.ci:61: referenced as `assertEq`
	test/lang/init.array.ci:60: referenced as `assertEq`
	test/lang/init.array.ci:58: referenced as `assertEq`
	test/lang/init.array.ci:57: referenced as `assertEq`
	test/lang/init.array.ci:56: referenced as `assertEq`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@012780>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@0591b0>, cast: static const function)
.field floor: function (size: 24, offs: <@059208>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@059220>, cast: static const function)
.field abs: function (size: 18, offs: <@059238>, cast: static const function)
.field absMod: function (size: 27, offs: <@059250>, cast: static const function)
.field absMod: function (size: 27, offs: <@059270>, cast: static const function)
.field min: function (size: 17, offs: <@059290>, cast: static const function)
.field min: function (size: 17, offs: <@0592a8>, cast: static const function)
.field max: function (size: 17, offs: <@0592c0>, cast: static const function)
.field max: function (size: 17, offs: <@0592d8>, cast: static const function)
.field clamp: function (size: 30, offs: <@0592f0>, cast: static const function)
.field clamp: function (size: 30, offs: <@059310>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@059330>, cast: static const function)
.field max: function (size: 79, offs: <@059380>, cast: static const function)
.field sum: function (size: 40, offs: <@0593d0>, cast: static const function)
.field mean: function (size: 20, offs: <@0593f8>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@059410>, cast: static const function)
.field cmp: function (size: 57, offs: <@059440>, cast: static const function)
.field cmp: function (size: 57, offs: <@059480>, cast: static const function)
.field sinCos: function (size: 335, offs: <@0594c0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@059610>, cast: static const function)
.field sinh: function (size: 241, offs: <@059790>, cast: static const function)
.field cosh: function (size: 75, offs: <@059888>, cast: static const function)
.field asin: function (size: 173, offs: <@0598d8>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/std/test.math.ci:96: referenced as `Math`
	test/std/test.math.ci:95: referenced as `Math`
	test/std/test.math.ci:94: referenced as `Math`
	test/std/test.math.ci:93: referenced as `Math`
	test/std/test.math.ci:91: referenced as `Math`
	test/std/test.math.ci:90: referenced as `Math`
	test/std/test.math.ci:89: referenced as `Math`
	test/std/test.math.ci:88: referenced as `Math`
	test/std/test.math.ci:86: referenced as `Math`
	test/std/test.math.ci:85: referenced as `Math`
	test/std/test.math.ci:84: referenced as `Math`
	test/std/test.math.ci:82: referenced as `Math`
	test/std/test.math.ci:81: referenced as `Math`
	test/std/test.math.ci:80: referenced as `Math`
	test/std/test.math.ci:79: referenced as `Math`
	test/std/test.math.ci:77: referenced as `Math`
	test/std/test.math.ci:76: referenced as `Math`
	test/std/test.math.ci:75: referenced as `Math`
	test/std/test.math.ci:74: referenced as `Math`
	test/std/test.math.ci:72: referenced as `Math`
	test/std/test.math.ci:71: referenced as `Math`
	test/std/test.math.ci:70: referenced as `Math`
	test/std/test.math.ci:68: referenced as `Math`
	test/std/test.math.ci:67: referenced as `Math`
	test/std/test.math.ci:64: referenced as `Math`
	test/std/test.math.ci:63: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:55: referenced as `Math`
	test/std/test.math.ci:54: referenced as `Math`
	test/std/test.math.ci:53: referenced as `Math`
	test/std/test.math.ci:52: referenced as `Math`
	test/std/test.math.ci:51: referenced as `Math`
	test/std/test.math.ci:50: referenced as `Math`
	test/std/test.math.ci:49: referenced as `Math`
	test/std/test.math.ci:46: referenced as `Math`
	test/std/test.math.ci:45: referenced as `Math`
	test/std/test.math.ci:44: referenced as `Math`
	test/std/test.math.ci:43: referenced as `Math`
	test/std/test.math.ci:41: referenced as `Math`
	test/std/test.math.ci:40: referenced as `Math`
	test/std/test.math.ci:39: referenced as `Math`
	test/std/test.math.ci:38: referenced as `Math`
	test/std/test.math.ci:36: referenced as `Math`
	test/std/test.math.ci:35: referenced as `Math`
	test/std/test.math.ci:33: referenced as `Math`
	test/std/test.math.ci:32: referenced as `Math`
	test/std/test.math.ci:30: referenced as `Math`
	test/std/test.math.ci:29: referenced as `Math`
	test/std/test.math.ci:27: referenced as `Math`
	test/std/test.math.ci:26: referenced as `Math`
	test/std/test.math.ci:25: referenced as `Math`
	test/std/test.math.ci:24: referenced as `Math`
	test/std/test.math.ci:22: referenced as `Math`
	test/std/test.math.ci:21: referenced as `Math`
	test/std/test.math.ci:20: referenced as `Math`
	test/std/test.math.ci:19: referenced as `Math`
	test/std/test.math.ci:18: referenced as `Math`
	test/std/test.math.ci:17: referenced as `Math`
	test/std/test.math.ci:15: referenced as `Math`
	test/std/test.math.ci:14: referenced as `Math`
	test/std/test.math.ci:13: referenced as `Math`
	test/std/test.math.ci:12: referenced as `Math`
	test/std/test.math.ci:11: referenced as `Math`
	test/std/test.math.ci:10: referenced as `Math`
	test/std/test.math.ci:8: referenced as `Math`
	test/std/test.math.ci:7: referenced as `Math`
	test/std/test.math.ci:6: referenced as `Math`
	test/std/test.math.ci:5: referenced as `Math`
	test/std/test.math.ci:4: referenced as `Math`
	test/std/test.math.ci:3: referenced as `Math`
	lib/std/string.ci:249: referenced as `Math`
	lib/std/string.ci:249: referenced as `Math`
	lib/std/math/Complex.ci:151: referenced as `Math`
	lib/std/math/Complex.ci:151: referenced as `Math`
	lib/std/math/Complex.ci:149: referenced as `Math`
	lib/std/math/Complex.ci:149: referenced as `Math`
	lib/std/math/Complex.ci:90: referenced as `Math`
	lib/std/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/std/test.math.ci:61: referenced as `pi`
	test/std/test.math.ci:60: referenced as `pi`
	test/std/test.math.ci:59: referenced as `pi`
	test/std/test.math.ci:58: referenced as `pi`
	test/std/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:524: referenced as `pi`
	lib/std/math.ci:521: referenced as `pi`
	lib/std/math.ci:497: referenced as `pi`
	lib/std/math.ci:481: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:476: referenced as `nan`
	lib/std/math.ci:397: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@0591b0>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@0591b0> - <@059206>)
	lib/std/math.ci:23: (63 bytes: <@0591b0> - <@0591ef>): if (x < (1))
	<modf @0591b0>      : 11 02                      dup.x64 sp(2)
	<modf+2 @0591b2>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0591bb>   : 88                         clt.f64
	<modf+12 @0591bc>   : 06 33 00 00                jz <modf+63 @0591ef>
	lib/std/math.ci:24: (39 bytes: <@0591c0> - <@0591e7>): if (x < (0))
	<modf+16 @0591c0>   : 11 02                      dup.x64 sp(2)
	<modf+18 @0591c2>   : 1a                         load.z64
	<modf+19 @0591c3>   : 88                         clt.f64
	<modf+20 @0591c4>   : 06 23 00 00                jz <modf+55 @0591e7>
	lib/std/math.ci:25: (17 bytes: <@0591c8> - <@0591d9>): result: float64 := -modf(-x, &intPart)
	<modf+24 @0591c8>   : 1a                         load.z64
	<modf+25 @0591c9>   : 11 04                      dup.x64 sp(4)
	<modf+27 @0591cb>   : 80                         neg.f64
	<modf+28 @0591cc>   : 10 05                      dup.x32 sp(5)
	<modf+30 @0591ce>   : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @0591d3>   : 02                         call
	<modf+36 @0591d4>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @0591d8>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@0591d9> - <@0591e0>): intPart := -intPart;
	<modf+41 @0591d9>   : 10 03                      dup.x32 sp(3)
	<modf+43 @0591db>   : 29                         load.i64
	<modf+44 @0591dc>   : 80                         neg.f64
	<modf+45 @0591dd>   : 10 05                      dup.x32 sp(5)
	<modf+47 @0591df>   : 2e                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0591e0> - <@0591e3>): return .result := result;
	<modf+48 @0591e0>   : 14 06                      set.x64 sp(6)
	<modf+50 @0591e2>   : 03                         ret
	<modf+51 @0591e3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0591e7> - <@0591eb>): intPart := (0);
	<modf+55 @0591e7>   : 1a                         load.z64
	<modf+56 @0591e8>   : 10 03                      dup.x32 sp(3)
	<modf+58 @0591ea>   : 2e                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0591eb> - <@0591ef>): return .result := x;
	<modf+59 @0591eb>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @0591ee>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0591ef> - <@0591fb>): result: float64 := x % (1)
	<modf+63 @0591ef>   : 11 02                      dup.x64 sp(2)
	<modf+65 @0591f1>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @0591fa>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@0591fb> - <@059203>): intPart := x - result;
	<modf+75 @0591fb>   : 11 04                      dup.x64 sp(4)
	<modf+77 @0591fd>   : 11 02                      dup.x64 sp(2)
	<modf+79 @0591ff>   : 82                         sub.f64
	<modf+80 @059200>   : 10 05                      dup.x32 sp(5)
	<modf+82 @059202>   : 2e                         store.i64
	lib/std/math.ci:34: (3 bytes: <@059203> - <@059206>): return .result := result;
	<modf+83 @059203>   : 14 06                      set.x64 sp(6)
	<modf+85 @059205>   : 03                         ret
.usages:
	lib/std/string.ci:249: referenced as `modf`
	lib/std/math.ci:374: referenced as `modf`
	lib/std/math.ci:322: referenced as `modf`
	lib/std/math.ci:318: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@059208>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <@059208> - <@059220>)
	lib/std/math.ci:48: (1 byte: <@059208> - <@059209>): result: float64
	<floor @059208>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@059209> - <@05921d>): modf(x, &result);
	<floor+1 @059209>    : 11 05                      dup.x64 sp(5)
	<floor+3 @05920b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @05920f>    : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @059214>   : 02                         call
	<floor+13 @059215>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @059219>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@05921d> - <@059220>): return .result := result;
	<floor+21 @05921d>   : 14 05                      set.x64 sp(5)
	<floor+23 @05921f>   : 03                         ret
.usages:
	test/std/test.math.ci:8: referenced as `floor`
	test/std/test.math.ci:7: referenced as `floor`
	test/std/test.math.ci:6: referenced as `floor`
	test/std/test.math.ci:5: referenced as `floor`
	test/std/test.math.ci:4: referenced as `floor`
	test/std/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:15: referenced as `sign`
	test/std/test.math.ci:14: referenced as `sign`
	test/std/test.math.ci:13: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:12: referenced as `sign`
	test/std/test.math.ci:11: referenced as `sign`
	test/std/test.math.ci:10: referenced as `sign`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@059220>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@059220> - <@059232>)
	lib/std/math.ci:78: (14 bytes: <@059220> - <@05922e>): if (x < (0))
	<abs @059220>      : 10 01                      dup.x32 sp(1)
	<abs+2 @059222>    : 19                         load.z32
	<abs+3 @059223>    : 78                         clt.f32
	<abs+4 @059224>    : 06 0a 00 00                jz <abs+14 @05922e>
	lib/std/math.ci:79: (6 bytes: <@059228> - <@05922e>): return .result := -x;
	<abs+8 @059228>    : 10 01                      dup.x32 sp(1)
	<abs+10 @05922a>   : 70                         neg.f32
	<abs+11 @05922b>   : 13 03                      set.x32 sp(3)
	<abs+13 @05922d>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@05922e> - <@059232>): return .result := x;
	<abs+14 @05922e>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @059231>   : 03                         ret
.usages:
	test/std/test.math.ci:22: referenced as `abs`
	test/std/test.math.ci:21: referenced as `abs`
	test/std/test.math.ci:20: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@059238>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@059238> - <@05924a>)
	lib/std/math.ci:86: (14 bytes: <@059238> - <@059246>): if (x < (0))
	<abs @059238>      : 11 01                      dup.x64 sp(1)
	<abs+2 @05923a>    : 1a                         load.z64
	<abs+3 @05923b>    : 88                         clt.f64
	<abs+4 @05923c>    : 06 0a 00 00                jz <abs+14 @059246>
	lib/std/math.ci:87: (6 bytes: <@059240> - <@059246>): return .result := -x;
	<abs+8 @059240>    : 11 01                      dup.x64 sp(1)
	<abs+10 @059242>   : 80                         neg.f64
	<abs+11 @059243>   : 14 05                      set.x64 sp(5)
	<abs+13 @059245>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@059246> - <@05924a>): return .result := x;
	<abs+14 @059246>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @059249>   : 03                         ret
.usages:
	test/std/test.math.ci:19: referenced as `abs`
	test/std/test.math.ci:18: referenced as `abs`
	test/std/test.math.ci:17: referenced as `abs`
	lib/std/string.ci:249: referenced as `abs`
	lib/std/math/Complex.ci:90: referenced as `abs`
	lib/std/math/Complex.ci:90: referenced as `abs`
	lib/std/math.ci:348: referenced as `abs`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@059250>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@059250> - <@05926b>)
	lib/std/math.ci:94: (23 bytes: <@059250> - <@059267>): if ((val := val % mod) < (0))
	<absMod @059250>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @059252>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @059254>    : 75                         mod.f32
	<absMod+5 @059255>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @059257>    : 13 04                      set.x32 sp(4)
	<absMod+9 @059259>    : 19                         load.z32
	<absMod+10 @05925a>   : 78                         clt.f32
	<absMod+11 @05925b>   : 06 0c 00 00                jz <absMod+23 @059267>
	lib/std/math.ci:95: (8 bytes: <@05925f> - <@059267>): return .result := val + mod;
	<absMod+15 @05925f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @059261>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @059263>   : 71                         add.f32
	<absMod+20 @059264>   : 13 04                      set.x32 sp(4)
	<absMod+22 @059266>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@059267> - <@05926b>): return .result := val;
	<absMod+23 @059267>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @05926a>   : 03                         ret
.usages:
	test/std/test.math.ci:96: referenced as `absMod`
	test/std/test.math.ci:95: referenced as `absMod`
	test/std/test.math.ci:94: referenced as `absMod`
	test/std/test.math.ci:93: referenced as `absMod`
	test/std/test.math.ci:91: referenced as `absMod`
	test/std/test.math.ci:90: referenced as `absMod`
	test/std/test.math.ci:89: referenced as `absMod`
	test/std/test.math.ci:88: referenced as `absMod`
	test/std/test.math.ci:86: referenced as `absMod`
	test/std/test.math.ci:85: referenced as `absMod`
	test/std/test.math.ci:84: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@059270>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@059270> - <@05928b>)
	lib/std/math.ci:102: (23 bytes: <@059270> - <@059287>): if ((val := val % mod) < (0))
	<absMod @059270>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @059272>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @059274>    : 85                         mod.f64
	<absMod+5 @059275>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @059277>    : 14 07                      set.x64 sp(7)
	<absMod+9 @059279>    : 1a                         load.z64
	<absMod+10 @05927a>   : 88                         clt.f64
	<absMod+11 @05927b>   : 06 0c 00 00                jz <absMod+23 @059287>
	lib/std/math.ci:103: (8 bytes: <@05927f> - <@059287>): return .result := val + mod;
	<absMod+15 @05927f>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @059281>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @059283>   : 81                         add.f64
	<absMod+20 @059284>   : 14 07                      set.x64 sp(7)
	<absMod+22 @059286>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@059287> - <@05928b>): return .result := val;
	<absMod+23 @059287>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @05928a>   : 03                         ret
.usages:
	test/std/test.math.ci:82: referenced as `absMod`
	test/std/test.math.ci:81: referenced as `absMod`
	test/std/test.math.ci:80: referenced as `absMod`
	test/std/test.math.ci:79: referenced as `absMod`
	test/std/test.math.ci:77: referenced as `absMod`
	test/std/test.math.ci:76: referenced as `absMod`
	test/std/test.math.ci:75: referenced as `absMod`
	test/std/test.math.ci:74: referenced as `absMod`
	test/std/test.math.ci:72: referenced as `absMod`
	test/std/test.math.ci:71: referenced as `absMod`
	test/std/test.math.ci:70: referenced as `absMod`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@059290>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@059290> - <@0592a1>)
	lib/std/math.ci:116: (13 bytes: <@059290> - <@05929d>): if (a < b)
	<min @059290>      : 10 02                      dup.x32 sp(2)
	<min+2 @059292>    : 10 02                      dup.x32 sp(2)
	<min+4 @059294>    : 78                         clt.f32
	<min+5 @059295>    : 06 08 00 00                jz <min+13 @05929d>
	lib/std/math.ci:117: (4 bytes: <@059299> - <@05929d>): return .result := a;
	<min+9 @059299>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @05929c>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@05929d> - <@0592a1>): return .result := b;
	<min+13 @05929d>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @0592a0>   : 03                         ret
.usages:
	test/std/test.math.ci:24: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0592a8>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0592a8> - <@0592b9>)
	lib/std/math.ci:124: (13 bytes: <@0592a8> - <@0592b5>): if (a < b)
	<min @0592a8>      : 11 03                      dup.x64 sp(3)
	<min+2 @0592aa>    : 11 03                      dup.x64 sp(3)
	<min+4 @0592ac>    : 88                         clt.f64
	<min+5 @0592ad>    : 06 08 00 00                jz <min+13 @0592b5>
	lib/std/math.ci:125: (4 bytes: <@0592b1> - <@0592b5>): return .result := a;
	<min+9 @0592b1>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @0592b4>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@0592b5> - <@0592b9>): return .result := b;
	<min+13 @0592b5>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @0592b8>   : 03                         ret
.usages:
	test/std/test.math.ci:26: referenced as `min`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0592c0>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0592c0> - <@0592d1>)
	lib/std/math.ci:138: (13 bytes: <@0592c0> - <@0592cd>): if (a > b)
	<max @0592c0>      : 10 02                      dup.x32 sp(2)
	<max+2 @0592c2>    : 10 02                      dup.x32 sp(2)
	<max+4 @0592c4>    : 79                         cgt.f32
	<max+5 @0592c5>    : 06 08 00 00                jz <max+13 @0592cd>
	lib/std/math.ci:139: (4 bytes: <@0592c9> - <@0592cd>): return .result := a;
	<max+9 @0592c9>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @0592cc>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@0592cd> - <@0592d1>): return .result := b;
	<max+13 @0592cd>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @0592d0>   : 03                         ret
.usages:
	test/std/test.math.ci:25: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0592d8>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0592d8> - <@0592e9>)
	lib/std/math.ci:146: (13 bytes: <@0592d8> - <@0592e5>): if (a > b)
	<max @0592d8>      : 11 03                      dup.x64 sp(3)
	<max+2 @0592da>    : 11 03                      dup.x64 sp(3)
	<max+4 @0592dc>    : 89                         cgt.f64
	<max+5 @0592dd>    : 06 08 00 00                jz <max+13 @0592e5>
	lib/std/math.ci:147: (4 bytes: <@0592e1> - <@0592e5>): return .result := a;
	<max+9 @0592e1>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @0592e4>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@0592e5> - <@0592e9>): return .result := b;
	<max+13 @0592e5>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @0592e8>   : 03                         ret
.usages:
	test/std/test.math.ci:27: referenced as `max`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0592f0>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@0592f0> - <@05930e>)
	lib/std/math.ci:160: (13 bytes: <@0592f0> - <@0592fd>): if (t < a)
	<clamp @0592f0>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @0592f2>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @0592f4>    : 78                         clt.f32
	<clamp+5 @0592f5>    : 06 08 00 00                jz <clamp+13 @0592fd>
	lib/std/math.ci:161: (4 bytes: <@0592f9> - <@0592fd>): return .result := a;
	<clamp+9 @0592f9>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @0592fc>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@0592fd> - <@05930a>): if (t > b)
	<clamp+13 @0592fd>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @0592ff>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @059301>   : 79                         cgt.f32
	<clamp+18 @059302>   : 06 08 00 00                jz <clamp+26 @05930a>
	lib/std/math.ci:164: (4 bytes: <@059306> - <@05930a>): return .result := b;
	<clamp+22 @059306>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @059309>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@05930a> - <@05930e>): return .result := t;
	<clamp+26 @05930a>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @05930d>   : 03                         ret
.usages:
	test/std/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@059310>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@059310> - <@05932e>)
	lib/std/math.ci:171: (13 bytes: <@059310> - <@05931d>): if (t < a)
	<clamp @059310>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @059312>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @059314>    : 88                         clt.f64
	<clamp+5 @059315>    : 06 08 00 00                jz <clamp+13 @05931d>
	lib/std/math.ci:172: (4 bytes: <@059319> - <@05931d>): return .result := a;
	<clamp+9 @059319>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @05931c>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@05931d> - <@05932a>): if (t > b)
	<clamp+13 @05931d>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @05931f>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @059321>   : 89                         cgt.f64
	<clamp+18 @059322>   : 06 08 00 00                jz <clamp+26 @05932a>
	lib/std/math.ci:175: (4 bytes: <@059326> - <@05932a>): return .result := b;
	<clamp+22 @059326>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @059329>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@05932a> - <@05932e>): return .result := t;
	<clamp+26 @05932a>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @05932d>   : 03                         ret
.usages:
	test/std/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/std/test.math.ci:32: referenced as `lerp`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/std/test.math.ci:33: referenced as `lerp`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/std/test.math.ci:35: referenced as `smooth`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/std/test.math.ci:36: referenced as `smooth`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@059330>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@059330> - <@05937f>)
	lib/std/math.ci:202: (20 bytes: <@059330> - <@059344>): if (data.length == (0))
	<min @059330>      : 10 02                      dup.x32 sp(2)
	<min+2 @059332>    : 19                         load.z32
	<min+3 @059333>    : 57                         ceq.i32
	<min+4 @059334>    : 06 10 00 00                jz <min+20 @059344>
	lib/std/math.ci:203: (12 bytes: <@059338> - <@059344>): return .result := nan;
	<min+8 @059338>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @059341>   : 14 05                      set.x64 sp(5)
	<min+19 @059343>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@059344> - <@059347>): result: float64 := data[0]
	<min+20 @059344>   : 10 01                      dup.x32 sp(1)
	<min+22 @059346>   : 29                         load.i64
	lib/std/math.ci:206: (53 bytes: <@059347> - <@05937c>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+23 @059347>   : 1c 01 00 00 00             load.c32 1
	<min+28 @05934c>   : 04 23 00 00                jmp <min+63 @05936f>
	lib/std/math.ci:207: (27 bytes: <@059350> - <@05936b>): if (result > data[i])
	<min+32 @059350>   : 11 01                      dup.x64 sp(1)
	<min+34 @059352>   : 10 06                      dup.x32 sp(6)
	<min+36 @059354>   : 10 03                      dup.x32 sp(3)
	<min+38 @059356>   : 0d 08 00 00                mad.u32 8
	<min+42 @05935a>   : 29                         load.i64
	<min+43 @05935b>   : 89                         cgt.f64
	<min+44 @05935c>   : 06 0f 00 00                jz <min+59 @05936b>
	lib/std/math.ci:208: (11 bytes: <@059360> - <@05936b>): result := data[i];
	<min+48 @059360>   : 10 04                      dup.x32 sp(4)
	<min+50 @059362>   : 10 01                      dup.x32 sp(1)
	<min+52 @059364>   : 0d 08 00 00                mad.u32 8
	<min+56 @059368>   : 29                         load.i64
	<min+57 @059369>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@05936b> - <@05936f>): i := i + 1
	<min+59 @05936b>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@05936f> - <@059378>): i < (data.length)
	<min+63 @05936f>   : 10 00                      dup.x32 sp(0)
	<min+65 @059371>   : 10 06                      dup.x32 sp(6)
	<min+67 @059373>   : 58                         clt.i32
	<min+68 @059374>   : 05 dc ff ff                jnz <min+32 @059350>
	<min+72 @059378>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@05937c> - <@05937f>): return .result := result;
	<min+76 @05937c>   : 14 05                      set.x64 sp(5)
	<min+78 @05937e>   : 03                         ret
.usages:
	test/std/test.math.ci:39: referenced as `min`
	test/std/test.math.ci:38: referenced as `min`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@059380>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@059380> - <@0593cf>)
	lib/std/math.ci:216: (20 bytes: <@059380> - <@059394>): if (data.length == (0))
	<max @059380>      : 10 02                      dup.x32 sp(2)
	<max+2 @059382>    : 19                         load.z32
	<max+3 @059383>    : 57                         ceq.i32
	<max+4 @059384>    : 06 10 00 00                jz <max+20 @059394>
	lib/std/math.ci:217: (12 bytes: <@059388> - <@059394>): return .result := nan;
	<max+8 @059388>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @059391>   : 14 05                      set.x64 sp(5)
	<max+19 @059393>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@059394> - <@059397>): result: float64 := data[0]
	<max+20 @059394>   : 10 01                      dup.x32 sp(1)
	<max+22 @059396>   : 29                         load.i64
	lib/std/math.ci:220: (53 bytes: <@059397> - <@0593cc>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+23 @059397>   : 1c 01 00 00 00             load.c32 1
	<max+28 @05939c>   : 04 23 00 00                jmp <max+63 @0593bf>
	lib/std/math.ci:221: (27 bytes: <@0593a0> - <@0593bb>): if (result < data[i])
	<max+32 @0593a0>   : 11 01                      dup.x64 sp(1)
	<max+34 @0593a2>   : 10 06                      dup.x32 sp(6)
	<max+36 @0593a4>   : 10 03                      dup.x32 sp(3)
	<max+38 @0593a6>   : 0d 08 00 00                mad.u32 8
	<max+42 @0593aa>   : 29                         load.i64
	<max+43 @0593ab>   : 88                         clt.f64
	<max+44 @0593ac>   : 06 0f 00 00                jz <max+59 @0593bb>
	lib/std/math.ci:222: (11 bytes: <@0593b0> - <@0593bb>): result := data[i];
	<max+48 @0593b0>   : 10 04                      dup.x32 sp(4)
	<max+50 @0593b2>   : 10 01                      dup.x32 sp(1)
	<max+52 @0593b4>   : 0d 08 00 00                mad.u32 8
	<max+56 @0593b8>   : 29                         load.i64
	<max+57 @0593b9>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@0593bb> - <@0593bf>): i := i + 1
	<max+59 @0593bb>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@0593bf> - <@0593c8>): i < (data.length)
	<max+63 @0593bf>   : 10 00                      dup.x32 sp(0)
	<max+65 @0593c1>   : 10 06                      dup.x32 sp(6)
	<max+67 @0593c3>   : 58                         clt.i32
	<max+68 @0593c4>   : 05 dc ff ff                jnz <max+32 @0593a0>
	<max+72 @0593c8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@0593cc> - <@0593cf>): return .result := result;
	<max+76 @0593cc>   : 14 05                      set.x64 sp(5)
	<max+78 @0593ce>   : 03                         ret
.usages:
	test/std/test.math.ci:41: referenced as `max`
	test/std/test.math.ci:40: referenced as `max`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@0593d0>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@0593d0> - <@0593f8>)
	lib/std/math.ci:230: (1 byte: <@0593d0> - <@0593d1>): result: float64 := 0
	<sum @0593d0>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@0593d1> - <@0593f5>): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+1 @0593d1>    : 6a                         i64.2i32
	<sum+2 @0593d2>    : 04 16 00 00                jmp <sum+24 @0593e8>
	lib/std/math.ci:232: (14 bytes: <@0593d6> - <@0593e4>): result := result + data[i];
	<sum+6 @0593d6>    : 11 01                      dup.x64 sp(1)
	<sum+8 @0593d8>    : 10 06                      dup.x32 sp(6)
	<sum+10 @0593da>   : 10 03                      dup.x32 sp(3)
	<sum+12 @0593dc>   : 0d 08 00 00                mad.u32 8
	<sum+16 @0593e0>   : 29                         load.i64
	<sum+17 @0593e1>   : 81                         add.f64
	<sum+18 @0593e2>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@0593e4> - <@0593e8>): i := i + 1
	<sum+20 @0593e4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@0593e8> - <@0593f1>): i < (data.length)
	<sum+24 @0593e8>   : 10 00                      dup.x32 sp(0)
	<sum+26 @0593ea>   : 10 06                      dup.x32 sp(6)
	<sum+28 @0593ec>   : 58                         clt.i32
	<sum+29 @0593ed>   : 05 e9 ff ff                jnz <sum+6 @0593d6>
	<sum+33 @0593f1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@0593f5> - <@0593f8>): return .result := result;
	<sum+37 @0593f5>   : 14 05                      set.x64 sp(5)
	<sum+39 @0593f7>   : 03                         ret
.usages:
	test/std/test.math.ci:46: referenced as `sum`
	test/std/test.math.ci:45: referenced as `sum`
	test/std/test.math.ci:44: referenced as `sum`
	test/std/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:239: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 20
.offset: <@0593f8>
.name: 'mean'
.file: 'lib/std/math.ci:238'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
}
.instructions: (20 bytes: <@0593f8> - <@05940c>)
	lib/std/math.ci:239: (20 bytes: <@0593f8> - <@05940c>): return .result := sum(...data) / (signed(data.length));
	<mean @0593f8>      : 1a                         load.z64
	<mean+1 @0593f9>    : 11 03                      dup.x64 sp(3)
	<mean+3 @0593fb>    : 1f d0 93 05 00             load.ref <@0593d0> ;Math.sum(data: float64[]): float64
	<mean+8 @059400>    : 02                         call
	<mean+9 @059401>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @059405>   : 10 04                      dup.x32 sp(4)
	<mean+15 @059407>   : 5d                         i32.2f64
	<mean+16 @059408>   : 84                         div.f64
	<mean+17 @059409>   : 14 05                      set.x64 sp(5)
	<mean+19 @05940b>   : 03                         ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/std/test.math.ci:50: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:246'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/std/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:249: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:249'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/std/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:252: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:252'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/std/test.math.ci:53: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@059410>
.name: 'eval'
.file: 'lib/std/math.ci:255'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@059410> - <@05943f>)
	lib/std/math.ci:256: (1 byte: <@059410> - <@059411>): result: float64 := 0
	<eval @059410>      : 1a                         load.z64
	lib/std/math.ci:257: (43 bytes: <@059411> - <@05943c>): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+1 @059411>    : 10 04                      dup.x32 sp(4)
	<eval+3 @059413>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @059417>    : 04 19 00 00                jmp <eval+32 @059430>
	lib/std/math.ci:258: (17 bytes: <@05941b> - <@05942c>): result := result * x + polynomial[i];
	<eval+11 @05941b>   : 11 01                      dup.x64 sp(1)
	<eval+13 @05941d>   : 11 08                      dup.x64 sp(8)
	<eval+15 @05941f>   : 83                         mul.f64
	<eval+16 @059420>   : 10 06                      dup.x32 sp(6)
	<eval+18 @059422>   : 10 03                      dup.x32 sp(3)
	<eval+20 @059424>   : 0d 08 00 00                mad.u32 8
	<eval+24 @059428>   : 29                         load.i64
	<eval+25 @059429>   : 81                         add.f64
	<eval+26 @05942a>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:257: (4 bytes: <@05942c> - <@059430>): i := i - 1
	<eval+28 @05942c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:257: (8 bytes: <@059430> - <@059438>): i >= 0
	<eval+32 @059430>   : 10 00                      dup.x32 sp(0)
	<eval+34 @059432>   : 19                         load.z32
	<eval+35 @059433>   : 58                         clt.i32
	<eval+36 @059434>   : 06 e7 ff ff                jz <eval+11 @05941b>
	<eval+40 @059438>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:260: (3 bytes: <@05943c> - <@05943f>): return .result := result;
	<eval+44 @05943c>   : 14 07                      set.x64 sp(7)
	<eval+46 @05943e>   : 03                         ret
.usages:
	test/std/test.math.ci:55: referenced as `eval`
	test/std/test.math.ci:54: referenced as `eval`
	test/std/test.math.ci:49: referenced as `eval`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@059440>
.name: 'cmp'
.file: 'lib/std/math.ci:264'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float32(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@059440> - <@059479>)
	lib/std/math.ci:265: (53 bytes: <@059440> - <@059475>): if (a < b)
	<cmp @059440>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @059442>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @059444>    : 78                         clt.f32
	<cmp+5 @059445>    : 06 1c 00 00                jz <cmp+33 @059461>
	lib/std/math.ci:266: (20 bytes: <@059449> - <@05945d>): if (eps < (b - a))
	<cmp+9 @059449>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @05944b>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @05944d>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @05944f>   : 72                         sub.f32
	<cmp+16 @059450>   : 78                         clt.f32
	<cmp+17 @059451>   : 06 0c 00 00                jz <cmp+29 @05945d>
	lib/std/math.ci:267: (8 bytes: <@059455> - <@05945d>): return .result := -1;
	<cmp+21 @059455>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05945a>   : 13 05                      set.x32 sp(5)
	<cmp+28 @05945c>   : 03                         ret
	<cmp+29 @05945d>   : 04 18 00 00                jmp <cmp+53 @059475>
	lib/std/math.ci:271: (20 bytes: <@059461> - <@059475>): if (eps < (a - b))
	<cmp+33 @059461>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @059463>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @059465>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @059467>   : 72                         sub.f32
	<cmp+40 @059468>   : 78                         clt.f32
	<cmp+41 @059469>   : 06 0c 00 00                jz <cmp+53 @059475>
	lib/std/math.ci:272: (8 bytes: <@05946d> - <@059475>): return .result := +1;
	<cmp+45 @05946d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @059472>   : 13 05                      set.x32 sp(5)
	<cmp+52 @059474>   : 03                         ret
	lib/std/math.ci:275: (4 bytes: <@059475> - <@059479>): return .result := 0;
	<cmp+53 @059475>   : 19                         load.z32
	<cmp+54 @059476>   : 13 05                      set.x32 sp(5)
	<cmp+56 @059478>   : 03                         ret
.usages:
	test/std/test.math.ci:67: referenced as `cmp`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@059480>
.name: 'cmp'
.file: 'lib/std/math.ci:279'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float64(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@059480> - <@0594b9>)
	lib/std/math.ci:280: (53 bytes: <@059480> - <@0594b5>): if (a < b)
	<cmp @059480>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @059482>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @059484>    : 88                         clt.f64
	<cmp+5 @059485>    : 06 1c 00 00                jz <cmp+33 @0594a1>
	lib/std/math.ci:281: (20 bytes: <@059489> - <@05949d>): if (eps < (b - a))
	<cmp+9 @059489>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @05948b>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @05948d>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @05948f>   : 82                         sub.f64
	<cmp+16 @059490>   : 88                         clt.f64
	<cmp+17 @059491>   : 06 0c 00 00                jz <cmp+29 @05949d>
	lib/std/math.ci:282: (8 bytes: <@059495> - <@05949d>): return .result := -1;
	<cmp+21 @059495>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05949a>   : 13 08                      set.x32 sp(8)
	<cmp+28 @05949c>   : 03                         ret
	<cmp+29 @05949d>   : 04 18 00 00                jmp <cmp+53 @0594b5>
	lib/std/math.ci:286: (20 bytes: <@0594a1> - <@0594b5>): if (eps < (a - b))
	<cmp+33 @0594a1>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @0594a3>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @0594a5>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @0594a7>   : 82                         sub.f64
	<cmp+40 @0594a8>   : 88                         clt.f64
	<cmp+41 @0594a9>   : 06 0c 00 00                jz <cmp+53 @0594b5>
	lib/std/math.ci:287: (8 bytes: <@0594ad> - <@0594b5>): return .result := +1;
	<cmp+45 @0594ad>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @0594b2>   : 13 08                      set.x32 sp(8)
	<cmp+52 @0594b4>   : 03                         ret
	lib/std/math.ci:290: (4 bytes: <@0594b5> - <@0594b9>): return .result := 0;
	<cmp+53 @0594b5>   : 19                         load.z32
	<cmp+54 @0594b6>   : 13 08                      set.x32 sp(8)
	<cmp+56 @0594b8>   : 03                         ret
.usages:
	test/std/test.math.ci:68: referenced as `cmp`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@0594c0>
.name: 'sinCos'
.file: 'lib/std/math.ci:294'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@0594c0> - <@05960f>)
	lib/std/math.ci:308: (2 bytes: <@0594c0> - <@0594c2>): x: float64 := arg
	<sinCos @0594c0>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:309: (17 bytes: <@0594c2> - <@0594d3>): if (x < (0))
	<sinCos+2 @0594c2>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @0594c4>    : 1a                         load.z64
	<sinCos+5 @0594c5>    : 88                         clt.f64
	<sinCos+6 @0594c6>    : 06 0d 00 00                jz <sinCos+19 @0594d3>
	lib/std/math.ci:310: (1 byte: <@0594ca> - <@0594cb>): x := -x;
	<sinCos+10 @0594ca>   : 80                         neg.f64
	lib/std/math.ci:311: (8 bytes: <@0594cb> - <@0594d3>): quad := quad + 2;
	<sinCos+11 @0594cb>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @0594cd>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @0594d1>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:314: (1 byte: <@0594d3> - <@0594d4>): y: float64
	<sinCos+19 @0594d3>   : 1a                         load.z64
	lib/std/math.ci:315: (24 bytes: <@0594d4> - <@0594ec>): x := x * (1) / PIO2;
	<sinCos+20 @0594d4>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @0594d6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @0594df>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @0594e8>   : 84                         div.f64
	<sinCos+41 @0594e9>   : 83                         mul.f64
	<sinCos+42 @0594ea>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:316: (124 bytes: <@0594ec> - <@059568>): if (x > (32764))
	<sinCos+44 @0594ec>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @0594ee>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @0594f7>   : 89                         cgt.f64
	<sinCos+56 @0594f8>   : 06 54 00 00                jz <sinCos+140 @05954c>
	lib/std/math.ci:317: (1 byte: <@0594fc> - <@0594fd>): e: float64
	<sinCos+60 @0594fc>   : 1b                         load.z128
	lib/std/math.ci:318: (18 bytes: <@0594fd> - <@05950f>): y := modf(x, &e);
	<sinCos+61 @0594fd>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @0594ff>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @059503>   : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @059508>   : 02                         call
	<sinCos+73 @059509>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @05950d>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:319: (4 bytes: <@05950f> - <@059513>): e := e + (quad);
	<sinCos+79 @05950f>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @059511>   : 5d                         i32.2f64
	<sinCos+82 @059512>   : 81                         add.f64
	lib/std/math.ci:321: (1 byte: <@059513> - <@059514>): f: float64
	<sinCos+83 @059513>   : 1b                         load.z128
	lib/std/math.ci:322: (30 bytes: <@059514> - <@059532>): modf(0.250000 * e, &f);
	<sinCos+84 @059514>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @05951d>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @05951f>   : 83                         mul.f64
	<sinCos+96 @059520>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @059524>  : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @059529>  : 02                         call
	<sinCos+106 @05952a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @05952e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:323: (18 bytes: <@059532> - <@059544>): quad := (e - (4) * f);
	<sinCos+114 @059532>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @059534>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @05953d>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @05953f>  : 83                         mul.f64
	<sinCos+128 @059540>  : 82                         sub.f64
	<sinCos+129 @059541>  : 8a                         f64.2i32
	<sinCos+130 @059542>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @059544>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @059548>  : 04 20 00 00                jmp <sinCos+168 @059568>
	lib/std/math.ci:326: (3 bytes: <@05954c> - <@05954f>): k: int32 := x
	<sinCos+140 @05954c>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @05954e>  : 8a                         f64.2i32
	lib/std/math.ci:327: (8 bytes: <@05954f> - <@059557>): y := x - (k);
	<sinCos+143 @05954f>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @059551>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @059553>  : 5d                         i32.2f64
	<sinCos+148 @059554>  : 82                         sub.f64
	<sinCos+149 @059555>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:328: (7 bytes: <@059557> - <@05955e>): quad := quad + k;
	<sinCos+151 @059557>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @059559>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @05955b>  : 51                         add.i32
	<sinCos+156 @05955c>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:329: (6 bytes: <@05955e> - <@059564>): quad := quad & 3;
	<sinCos+158 @05955e>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @059560>  : 3f 02                      b32.and 0x003
	<sinCos+162 @059562>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @059564>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:331: (22 bytes: <@059568> - <@05957e>): if (quad & 1)
	<sinCos+168 @059568>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @05956a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @05956c>  : 06 12 00 00                jz <sinCos+190 @05957e>
	lib/std/math.ci:332: (14 bytes: <@059570> - <@05957e>): y := (1) - y;
	<sinCos+176 @059570>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @059579>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @05957b>  : 82                         sub.f64
	<sinCos+188 @05957c>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:334: (13 bytes: <@05957e> - <@05958b>): if (quad > 1)
	<sinCos+190 @05957e>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @059580>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @059585>  : 59                         cgt.i32
	<sinCos+198 @059586>  : 06 05 00 00                jz <sinCos+203 @05958b>
	lib/std/math.ci:335: (1 byte: <@05958a> - <@05958b>): y := -y;
	<sinCos+202 @05958a>  : 80                         neg.f64
	lib/std/math.ci:338: (5 bytes: <@05958b> - <@059590>): ysq: float64 := y * y
	<sinCos+203 @05958b>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @05958d>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @05958f>  : 83                         mul.f64
	lib/std/math.ci:339: (64 bytes: <@059590> - <@0595d0>): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+208 @059590>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @059599>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @05959b>  : 83                         mul.f64
	<sinCos+220 @05959c>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @0595a5>  : 81                         add.f64
	<sinCos+230 @0595a6>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @0595a8>  : 83                         mul.f64
	<sinCos+233 @0595a9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @0595b2>  : 81                         add.f64
	<sinCos+243 @0595b3>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @0595b5>  : 83                         mul.f64
	<sinCos+246 @0595b6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @0595bf>  : 81                         add.f64
	<sinCos+256 @0595c0>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @0595c2>  : 83                         mul.f64
	<sinCos+259 @0595c3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @0595cc>  : 81                         add.f64
	<sinCos+269 @0595cd>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @0595cf>  : 83                         mul.f64
	lib/std/math.ci:340: (51 bytes: <@0595d0> - <@059603>): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+272 @0595d0>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @0595d2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @0595db>  : 81                         add.f64
	<sinCos+284 @0595dc>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @0595de>  : 83                         mul.f64
	<sinCos+287 @0595df>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @0595e8>  : 81                         add.f64
	<sinCos+297 @0595e9>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @0595eb>  : 83                         mul.f64
	<sinCos+300 @0595ec>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @0595f5>  : 81                         add.f64
	<sinCos+310 @0595f6>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @0595f8>  : 83                         mul.f64
	<sinCos+313 @0595f9>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @059602>  : 81                         add.f64
	lib/std/math.ci:341: (12 bytes: <@059603> - <@05960f>): return .result := temp1 / temp2;
	<sinCos+323 @059603>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @059605>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @059607>  : 84                         div.f64
	<sinCos+328 @059608>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @05960a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @05960e>  : 03                         ret
.usages:
	lib/std/math.ci:348: referenced as `sinCos`
	lib/std/math.ci:345: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:345'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/std/test.math.ci:57: referenced as `sin`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:348'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/std/test.math.ci:58: referenced as `cos`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@059610>
.name: 'tan'
.file: 'lib/std/math.ci:351'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else if (bool(i == 1)) {
		float64(x := float64((1) - x));
		bool(complement := true);
	}
	else if (bool(i == 2)) {
		bool(negate := bool(!negate));
		bool(complement := true);
	}
	else if (bool(i == 3)) {
		float64(x := float64((1) - x));
		bool(negate := bool(!negate));
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@059610> - <@05978a>)
	lib/std/math.ci:364: (1 byte: <@059610> - <@059611>): complement: bool := false
	<tan @059610>      : 19                         load.z32
	lib/std/math.ci:365: (1 byte: <@059611> - <@059612>): negate: bool := false
	<tan+1 @059611>    : 19                         load.z32
	lib/std/math.ci:367: (23 bytes: <@059612> - <@059629>): if (arg < (0))
	<tan+2 @059612>    : 11 03                      dup.x64 sp(3)
	<tan+4 @059614>    : 1a                         load.z64
	<tan+5 @059615>    : 88                         clt.f64
	<tan+6 @059616>    : 06 13 00 00                jz <tan+25 @059629>
	lib/std/math.ci:368: (5 bytes: <@05961a> - <@05961f>): arg := -arg;
	<tan+10 @05961a>   : 11 03                      dup.x64 sp(3)
	<tan+12 @05961c>   : 80                         neg.f64
	<tan+13 @05961d>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:369: (10 bytes: <@05961f> - <@059629>): negate := true;
	<tan+15 @05961f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @059624>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @059628>   : 2b                         store.i8
	lib/std/math.ci:371: (24 bytes: <@059629> - <@059641>): arg := (2) * arg / PIO2;
	<tan+25 @059629>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @059632>   : 11 05                      dup.x64 sp(5)
	<tan+36 @059634>   : 83                         mul.f64
	<tan+37 @059635>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @05963e>   : 84                         div.f64
	<tan+47 @05963f>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:373: (1 byte: <@059641> - <@059642>): e: float64
	<tan+49 @059641>   : 1b                         load.z128
	lib/std/math.ci:374: (16 bytes: <@059642> - <@059652>): x: float64 := modf(arg, &e)
	<tan+50 @059642>   : 11 07                      dup.x64 sp(7)
	<tan+52 @059644>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @059648>   : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @05964d>   : 02                         call
	<tan+62 @05964e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:375: (9 bytes: <@059652> - <@05965b>): i: int32 := int32(e) % 4
	<tan+66 @059652>   : 11 02                      dup.x64 sp(2)
	<tan+68 @059654>   : 8a                         f64.2i32
	<tan+69 @059655>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @05965a>   : 55                         mod.i32
	lib/std/math.ci:377: (122 bytes: <@05965b> - <@0596d5>): if (i == 0)
	<tan+75 @05965b>   : 10 00                      dup.x32 sp(0)
	<tan+77 @05965d>   : 19                         load.z32
	<tan+78 @05965e>   : 57                         ceq.i32
	<tan+79 @05965f>   : 05 76 00 00                jnz <tan+197 @0596d5>
	lib/std/math.ci:378: (114 bytes: <@059663> - <@0596d5>): if (i == 1)
	<tan+83 @059663>   : 10 00                      dup.x32 sp(0)
	<tan+85 @059665>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @05966a>   : 57                         ceq.i32
	<tan+91 @05966b>   : 06 20 00 00                jz <tan+123 @05968b>
	lib/std/math.ci:379: (14 bytes: <@05966f> - <@05967d>): x := (1) - x;
	<tan+95 @05966f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @059678>  : 11 03                      dup.x64 sp(3)
	<tan+106 @05967a>  : 82                         sub.f64
	<tan+107 @05967b>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:380: (10 bytes: <@05967d> - <@059687>): complement := true;
	<tan+109 @05967d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @059682>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @059686>  : 2b                         store.i8
	<tan+119 @059687>  : 04 4e 00 00                jmp <tan+197 @0596d5>
	lib/std/math.ci:382: (74 bytes: <@05968b> - <@0596d5>): if (i == 2)
	<tan+123 @05968b>  : 10 00                      dup.x32 sp(0)
	<tan+125 @05968d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @059692>  : 57                         ceq.i32
	<tan+131 @059693>  : 06 1d 00 00                jz <tan+160 @0596b0>
	lib/std/math.ci:383: (11 bytes: <@059697> - <@0596a2>): negate := !negate;
	<tan+135 @059697>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @05969b>  : 26                         load.i8
	<tan+140 @05969c>  : 0b                         not.b32
	<tan+141 @05969d>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @0596a1>  : 2b                         store.i8
	lib/std/math.ci:384: (10 bytes: <@0596a2> - <@0596ac>): complement := true;
	<tan+146 @0596a2>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @0596a7>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @0596ab>  : 2b                         store.i8
	<tan+156 @0596ac>  : 04 29 00 00                jmp <tan+197 @0596d5>
	lib/std/math.ci:386: (37 bytes: <@0596b0> - <@0596d5>): if (i == 3)
	<tan+160 @0596b0>  : 10 00                      dup.x32 sp(0)
	<tan+162 @0596b2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @0596b7>  : 57                         ceq.i32
	<tan+168 @0596b8>  : 06 1d 00 00                jz <tan+197 @0596d5>
	lib/std/math.ci:387: (14 bytes: <@0596bc> - <@0596ca>): x := (1) - x;
	<tan+172 @0596bc>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @0596c5>  : 11 03                      dup.x64 sp(3)
	<tan+183 @0596c7>  : 82                         sub.f64
	<tan+184 @0596c8>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:388: (11 bytes: <@0596ca> - <@0596d5>): negate := !negate;
	<tan+186 @0596ca>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @0596ce>  : 26                         load.i8
	<tan+191 @0596cf>  : 0b                         not.b32
	<tan+192 @0596d0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @0596d4>  : 2b                         store.i8
	lib/std/math.ci:391: (5 bytes: <@0596d5> - <@0596da>): xsq: float64 := x * x
	<tan+197 @0596d5>  : 11 01                      dup.x64 sp(1)
	<tan+199 @0596d7>  : 11 03                      dup.x64 sp(3)
	<tan+201 @0596d9>  : 83                         mul.f64
	lib/std/math.ci:392: (64 bytes: <@0596da> - <@05971a>): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+202 @0596da>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @0596e3>  : 11 02                      dup.x64 sp(2)
	<tan+213 @0596e5>  : 83                         mul.f64
	<tan+214 @0596e6>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @0596ef>  : 81                         add.f64
	<tan+224 @0596f0>  : 11 02                      dup.x64 sp(2)
	<tan+226 @0596f2>  : 83                         mul.f64
	<tan+227 @0596f3>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @0596fc>  : 81                         add.f64
	<tan+237 @0596fd>  : 11 02                      dup.x64 sp(2)
	<tan+239 @0596ff>  : 83                         mul.f64
	<tan+240 @059700>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @059709>  : 81                         add.f64
	<tan+250 @05970a>  : 11 02                      dup.x64 sp(2)
	<tan+252 @05970c>  : 83                         mul.f64
	<tan+253 @05970d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @059716>  : 81                         add.f64
	<tan+263 @059717>  : 11 05                      dup.x64 sp(5)
	<tan+265 @059719>  : 83                         mul.f64
	lib/std/math.ci:393: (39 bytes: <@05971a> - <@059741>): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+266 @05971a>  : 11 02                      dup.x64 sp(2)
	<tan+268 @05971c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @059725>  : 81                         add.f64
	<tan+278 @059726>  : 11 04                      dup.x64 sp(4)
	<tan+280 @059728>  : 83                         mul.f64
	<tan+281 @059729>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @059732>  : 81                         add.f64
	<tan+291 @059733>  : 11 04                      dup.x64 sp(4)
	<tan+293 @059735>  : 83                         mul.f64
	<tan+294 @059736>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @05973f>  : 81                         add.f64
	<tan+304 @059740>  : 84                         div.f64
	lib/std/math.ci:395: (47 bytes: <@059741> - <@059770>): if (complement)
	<tan+305 @059741>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @059745>  : 26                         load.i8
	<tan+310 @059746>  : 06 2a 00 00                jz <tan+352 @059770>
	lib/std/math.ci:396: (24 bytes: <@05974a> - <@059762>): if (result == (0))
	<tan+314 @05974a>  : 11 00                      dup.x64 sp(0)
	<tan+316 @05974c>  : 1a                         load.z64
	<tan+317 @05974d>  : 87                         ceq.f64
	<tan+318 @05974e>  : 06 14 00 00                jz <tan+338 @059762>
	lib/std/math.ci:397: (16 bytes: <@059752> - <@059762>): return .result := nan;
	<tan+322 @059752>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @05975b>  : 14 10                      set.x64 sp(16)
	<tan+333 @05975d>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @059761>  : 03                         ret
	lib/std/math.ci:399: (14 bytes: <@059762> - <@059770>): result := (1) / result;
	<tan+338 @059762>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @05976b>  : 11 02                      dup.x64 sp(2)
	<tan+349 @05976d>  : 84                         div.f64
	<tan+350 @05976e>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:401: (19 bytes: <@059770> - <@059783>): if (negate)
	<tan+352 @059770>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @059774>  : 26                         load.i8
	<tan+357 @059775>  : 06 0e 00 00                jz <tan+371 @059783>
	lib/std/math.ci:402: (10 bytes: <@059779> - <@059783>): return .result := -result;
	<tan+361 @059779>  : 11 00                      dup.x64 sp(0)
	<tan+363 @05977b>  : 80                         neg.f64
	<tan+364 @05977c>  : 14 10                      set.x64 sp(16)
	<tan+366 @05977e>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @059782>  : 03                         ret
	lib/std/math.ci:404: (7 bytes: <@059783> - <@05978a>): return .result := result;
	<tan+371 @059783>  : 14 0e                      set.x64 sp(14)
	<tan+373 @059785>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @059789>  : 03                         ret
.usages:
	test/std/test.math.ci:59: referenced as `tan`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@059790>
.name: 'sinh'
.file: 'lib/std/math.ci:408'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@059790> - <@059881>)
	lib/std/math.ci:420: (1 byte: <@059790> - <@059791>): negate: bool := false
	<sinh @059790>      : 19                         load.z32
	lib/std/math.ci:421: (23 bytes: <@059791> - <@0597a8>): if (x < (0))
	<sinh+1 @059791>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @059793>    : 1a                         load.z64
	<sinh+4 @059794>    : 88                         clt.f64
	<sinh+5 @059795>    : 06 13 00 00                jz <sinh+24 @0597a8>
	lib/std/math.ci:422: (5 bytes: <@059799> - <@05979e>): x := -x;
	<sinh+9 @059799>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @05979b>   : 80                         neg.f64
	<sinh+12 @05979c>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:423: (10 bytes: <@05979e> - <@0597a8>): negate := true;
	<sinh+14 @05979e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @0597a3>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @0597a7>   : 2b                         store.i8
	lib/std/math.ci:426: (39 bytes: <@0597a8> - <@0597cf>): if (x > (21))
	<sinh+24 @0597a8>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @0597aa>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @0597b3>   : 89                         cgt.f64
	<sinh+36 @0597b4>   : 06 1b 00 00                jz <sinh+63 @0597cf>
	lib/std/math.ci:427: (23 bytes: <@0597b8> - <@0597cf>): return .result := float64.exp(x) / (2);
	<sinh+40 @0597b8>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @0597ba>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+46 @0597be>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @0597c7>   : 84                         div.f64
	<sinh+56 @0597c8>   : 14 06                      set.x64 sp(6)
	<sinh+58 @0597ca>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @0597ce>   : 03                         ret
	lib/std/math.ci:430: (1 byte: <@0597cf> - <@0597d0>): result: float64
	<sinh+63 @0597cf>   : 1a                         load.z64
	lib/std/math.ci:431: (151 bytes: <@0597d0> - <@059867>): if (x > 0.500000)
	<sinh+64 @0597d0>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @0597d2>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @0597db>   : 89                         cgt.f64
	<sinh+76 @0597dc>   : 06 22 00 00                jz <sinh+110 @0597fe>
	lib/std/math.ci:432: (26 bytes: <@0597e0> - <@0597fa>): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+80 @0597e0>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @0597e2>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+86 @0597e6>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @0597e8>   : 80                         neg.f64
	<sinh+89 @0597e9>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+93 @0597ed>   : 82                         sub.f64
	<sinh+94 @0597ee>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @0597f7>  : 84                         div.f64
	<sinh+104 @0597f8>  : 14 02                      set.x64 sp(2)
	<sinh+106 @0597fa>  : 04 6d 00 00                jmp <sinh+215 @059867>
	lib/std/math.ci:435: (5 bytes: <@0597fe> - <@059803>): sq: float64 := x * x
	<sinh+110 @0597fe>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @059800>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @059802>  : 83                         mul.f64
	lib/std/math.ci:436: (53 bytes: <@059803> - <@059838>): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+115 @059803>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05980c>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @05980e>  : 83                         mul.f64
	<sinh+127 @05980f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @059818>  : 81                         add.f64
	<sinh+137 @059819>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @05981b>  : 83                         mul.f64
	<sinh+140 @05981c>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @059825>  : 81                         add.f64
	<sinh+150 @059826>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @059828>  : 83                         mul.f64
	<sinh+153 @059829>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @059832>  : 81                         add.f64
	<sinh+163 @059833>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @059835>  : 83                         mul.f64
	<sinh+166 @059836>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:437: (43 bytes: <@059838> - <@059863>): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+168 @059838>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @05983a>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @05983c>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @059845>  : 81                         add.f64
	<sinh+182 @059846>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @059848>  : 83                         mul.f64
	<sinh+185 @059849>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @059852>  : 81                         add.f64
	<sinh+195 @059853>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @059855>  : 83                         mul.f64
	<sinh+198 @059856>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @05985f>  : 81                         add.f64
	<sinh+208 @059860>  : 84                         div.f64
	<sinh+209 @059861>  : 14 04                      set.x64 sp(4)
	<sinh+211 @059863>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:440: (19 bytes: <@059867> - <@05987a>): if (negate)
	<sinh+215 @059867>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @05986b>  : 26                         load.i8
	<sinh+220 @05986c>  : 06 0e 00 00                jz <sinh+234 @05987a>
	lib/std/math.ci:441: (10 bytes: <@059870> - <@05987a>): return .result := -result;
	<sinh+224 @059870>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @059872>  : 80                         neg.f64
	<sinh+227 @059873>  : 14 08                      set.x64 sp(8)
	<sinh+229 @059875>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @059879>  : 03                         ret
	lib/std/math.ci:443: (7 bytes: <@05987a> - <@059881>): return .result := result;
	<sinh+234 @05987a>  : 14 06                      set.x64 sp(6)
	<sinh+236 @05987c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @059880>  : 03                         ret
.usages:
	test/std/test.math.ci:60: referenced as `sinh`
	lib/std/math/Complex.ci:151: referenced as `sinh`
	lib/std/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@059888>
.name: 'cosh'
.file: 'lib/std/math.ci:447'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@059888> - <@0598d3>)
	lib/std/math.ci:448: (13 bytes: <@059888> - <@059895>): if (x < (0))
	<cosh @059888>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @05988a>    : 1a                         load.z64
	<cosh+3 @05988b>    : 88                         clt.f64
	<cosh+4 @05988c>    : 06 09 00 00                jz <cosh+13 @059895>
	lib/std/math.ci:449: (5 bytes: <@059890> - <@059895>): x := -x;
	<cosh+8 @059890>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @059892>   : 80                         neg.f64
	<cosh+11 @059893>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:451: (35 bytes: <@059895> - <@0598b8>): if (x > (21))
	<cosh+13 @059895>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @059897>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @0598a0>   : 89                         cgt.f64
	<cosh+25 @0598a1>   : 06 17 00 00                jz <cosh+48 @0598b8>
	lib/std/math.ci:452: (19 bytes: <@0598a5> - <@0598b8>): return .result := float64.exp(x) / (2);
	<cosh+29 @0598a5>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @0598a7>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+35 @0598ab>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @0598b4>   : 84                         div.f64
	<cosh+45 @0598b5>   : 14 05                      set.x64 sp(5)
	<cosh+47 @0598b7>   : 03                         ret
	lib/std/math.ci:454: (27 bytes: <@0598b8> - <@0598d3>): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+48 @0598b8>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @0598ba>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+54 @0598be>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @0598c0>   : 80                         neg.f64
	<cosh+57 @0598c1>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+61 @0598c5>   : 81                         add.f64
	<cosh+62 @0598c6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @0598cf>   : 84                         div.f64
	<cosh+72 @0598d0>   : 14 05                      set.x64 sp(5)
	<cosh+74 @0598d2>   : 03                         ret
.usages:
	test/std/test.math.ci:61: referenced as `cosh`
	lib/std/math/Complex.ci:151: referenced as `cosh`
	lib/std/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.offset: <@0598d8>
.name: 'asin'
.file: 'lib/std/math.ci:462'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <@0598d8> - <@059985>)
	lib/std/math.ci:463: (12 bytes: <@0598d8> - <@0598e4>): if (x == (0))
	<asin @0598d8>      : 11 01                      dup.x64 sp(1)
	<asin+2 @0598da>    : 1a                         load.z64
	<asin+3 @0598db>    : 87                         ceq.f64
	<asin+4 @0598dc>    : 06 08 00 00                jz <asin+12 @0598e4>
	lib/std/math.ci:465: (4 bytes: <@0598e0> - <@0598e4>): return .result := x;
	<asin+8 @0598e0>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @0598e3>   : 03                         ret
	lib/std/math.ci:468: (1 byte: <@0598e4> - <@0598e5>): negate: bool := false
	<asin+12 @0598e4>   : 19                         load.z32
	lib/std/math.ci:469: (23 bytes: <@0598e5> - <@0598fc>): if (x < (0))
	<asin+13 @0598e5>   : 11 02                      dup.x64 sp(2)
	<asin+15 @0598e7>   : 1a                         load.z64
	<asin+16 @0598e8>   : 88                         clt.f64
	<asin+17 @0598e9>   : 06 13 00 00                jz <asin+36 @0598fc>
	lib/std/math.ci:470: (10 bytes: <@0598ed> - <@0598f7>): negate := true;
	<asin+21 @0598ed>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @0598f2>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @0598f6>   : 2b                         store.i8
	lib/std/math.ci:471: (5 bytes: <@0598f7> - <@0598fc>): x := -x;
	<asin+31 @0598f7>   : 11 02                      dup.x64 sp(2)
	<asin+33 @0598f9>   : 80                         neg.f64
	<asin+34 @0598fa>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:474: (32 bytes: <@0598fc> - <@05991c>): if (x > (1))
	<asin+36 @0598fc>   : 11 02                      dup.x64 sp(2)
	<asin+38 @0598fe>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @059907>   : 89                         cgt.f64
	<asin+48 @059908>   : 06 14 00 00                jz <asin+68 @05991c>
	lib/std/math.ci:476: (16 bytes: <@05990c> - <@05991c>): return .result := nan;
	<asin+52 @05990c>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @059915>   : 14 06                      set.x64 sp(6)
	<asin+63 @059917>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @05991b>   : 03                         ret
	lib/std/math.ci:479: (19 bytes: <@05991c> - <@05992f>): result: float64 := float64.sqrt((1) - x * x)
	<asin+68 @05991c>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @059925>   : 11 04                      dup.x64 sp(4)
	<asin+79 @059927>   : 11 06                      dup.x64 sp(6)
	<asin+81 @059929>   : 83                         mul.f64
	<asin+82 @05992a>   : 82                         sub.f64
	<asin+83 @05992b>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:480: (60 bytes: <@05992f> - <@05996b>): if (x > 0.700000)
	<asin+87 @05992f>   : 11 04                      dup.x64 sp(4)
	<asin+89 @059931>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @05993a>   : 89                         cgt.f64
	<asin+99 @05993b>   : 06 26 00 00                jz <asin+137 @059961>
	lib/std/math.ci:481: (30 bytes: <@05993f> - <@05995d>): result := pi / (2) - float64.atan2(result, x);
	<asin+103 @05993f>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @059948>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @059951>  : 84                         div.f64
	<asin+122 @059952>  : 11 02                      dup.x64 sp(2)
	<asin+124 @059954>  : 11 08                      dup.x64 sp(8)
	<asin+126 @059956>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @05995a>  : 82                         sub.f64
	<asin+131 @05995b>  : 14 02                      set.x64 sp(2)
	<asin+133 @05995d>  : 04 0e 00 00                jmp <asin+147 @05996b>
	lib/std/math.ci:484: (10 bytes: <@059961> - <@05996b>): result := float64.atan2(x, result);
	<asin+137 @059961>  : 11 04                      dup.x64 sp(4)
	<asin+139 @059963>  : 11 02                      dup.x64 sp(2)
	<asin+141 @059965>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @059969>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:487: (19 bytes: <@05996b> - <@05997e>): if (negate)
	<asin+147 @05996b>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @05996f>  : 26                         load.i8
	<asin+152 @059970>  : 06 0e 00 00                jz <asin+166 @05997e>
	lib/std/math.ci:488: (10 bytes: <@059974> - <@05997e>): return .result := -result;
	<asin+156 @059974>  : 11 00                      dup.x64 sp(0)
	<asin+158 @059976>  : 80                         neg.f64
	<asin+159 @059977>  : 14 08                      set.x64 sp(8)
	<asin+161 @059979>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @05997d>  : 03                         ret
	lib/std/math.ci:490: (7 bytes: <@05997e> - <@059985>): return .result := result;
	<asin+166 @05997e>  : 14 06                      set.x64 sp(6)
	<asin+168 @059980>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @059984>  : 03                         ret
.usages:
	test/std/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:497: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:497'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/std/test.math.ci:64: referenced as `acos`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:521'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:524'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01b7c0>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math/Complex.ci:189: referenced as `Complex`
	lib/std/math/Complex.ci:187: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:182: referenced as `Complex`
	lib/std/math/Complex.ci:180: referenced as `Complex`
	lib/std/math/Complex.ci:178: referenced as `Complex`
	lib/std/math/Complex.ci:175: referenced as `Complex`
	lib/std/math/Complex.ci:173: referenced as `Complex`
	lib/std/math/Complex.ci:171: referenced as `Complex`
	lib/std/math/Complex.ci:169: referenced as `Complex`
	lib/std/math/Complex.ci:166: referenced as `Complex`
	lib/std/math/Complex.ci:164: referenced as `Complex`
	lib/std/math/Complex.ci:151: referenced as `Complex`
	lib/std/math/Complex.ci:149: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:117: referenced as `Complex`
	lib/std/math/Complex.ci:117: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:112: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:107: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:81: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: referenced as `Complex`
	lib/std/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math/Complex.ci:187: referenced as `re`
	lib/std/math/Complex.ci:187: referenced as `re`
	lib/std/math/Complex.ci:151: referenced as `re`
	lib/std/math/Complex.ci:151: referenced as `re`
	lib/std/math/Complex.ci:149: referenced as `re`
	lib/std/math/Complex.ci:149: referenced as `re`
	lib/std/math/Complex.ci:141: referenced as `re`
	lib/std/math/Complex.ci:139: referenced as `re`
	lib/std/math/Complex.ci:138: referenced as `re`
	lib/std/math/Complex.ci:129: referenced as `re`
	lib/std/math/Complex.ci:129: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:120: referenced as `re`
	lib/std/math/Complex.ci:120: referenced as `re`
	lib/std/math/Complex.ci:118: referenced as `re`
	lib/std/math/Complex.ci:118: referenced as `re`
	lib/std/math/Complex.ci:114: referenced as `re`
	lib/std/math/Complex.ci:112: referenced as `re`
	lib/std/math/Complex.ci:112: referenced as `re`
	lib/std/math/Complex.ci:101: referenced as `re`
	lib/std/math/Complex.ci:102: referenced as `re`
	lib/std/math/Complex.ci:101: referenced as `re`
	lib/std/math/Complex.ci:99: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:94: referenced as `re`
	lib/std/math/Complex.ci:95: referenced as `re`
	lib/std/math/Complex.ci:94: referenced as `re`
	lib/std/math/Complex.ci:92: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:90: referenced as `re`
	lib/std/math/Complex.ci:83: referenced as `re`
	lib/std/math/Complex.ci:81: referenced as `re`
	lib/std/math/Complex.ci:73: referenced as `re`
	lib/std/math/Complex.ci:71: referenced as `re`
	lib/std/math/Complex.ci:66: referenced as `re`
	lib/std/math/Complex.ci:64: referenced as `re`
	lib/std/math/Complex.ci:33: referenced as `re`
	lib/std/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math/Complex.ci:187: referenced as `im`
	lib/std/math/Complex.ci:187: referenced as `im`
	lib/std/math/Complex.ci:151: referenced as `im`
	lib/std/math/Complex.ci:151: referenced as `im`
	lib/std/math/Complex.ci:149: referenced as `im`
	lib/std/math/Complex.ci:149: referenced as `im`
	lib/std/math/Complex.ci:142: referenced as `im`
	lib/std/math/Complex.ci:139: referenced as `im`
	lib/std/math/Complex.ci:138: referenced as `im`
	lib/std/math/Complex.ci:129: referenced as `im`
	lib/std/math/Complex.ci:129: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:121: referenced as `im`
	lib/std/math/Complex.ci:121: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:114: referenced as `im`
	lib/std/math/Complex.ci:112: referenced as `im`
	lib/std/math/Complex.ci:112: referenced as `im`
	lib/std/math/Complex.ci:102: referenced as `im`
	lib/std/math/Complex.ci:102: referenced as `im`
	lib/std/math/Complex.ci:101: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:98: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:94: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:91: referenced as `im`
	lib/std/math/Complex.ci:90: referenced as `im`
	lib/std/math/Complex.ci:83: referenced as `im`
	lib/std/math/Complex.ci:81: referenced as `im`
	lib/std/math/Complex.ci:73: referenced as `im`
	lib/std/math/Complex.ci:71: referenced as `im`
	lib/std/math/Complex.ci:66: referenced as `im`
	lib/std/math/Complex.ci:64: referenced as `im`
	lib/std/math/Complex.ci:34: referenced as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@059988>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@059988> - <@05998f>)
	lib/std/math/Complex.ci:25: (7 bytes: <@059988> - <@05998f>): return .result := {...};
	<Complex @059988>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@05998b> - <@05998e>): .result.im := (0)
	<Complex+3 @05998b>    : 1a                         load.z64
	<Complex+4 @05998c>    : 14 07                      set.x64 sp(7)
	<Complex+6 @05998e>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@059990>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@059990> - <@059997>)
	lib/std/math/Complex.ci:32: (7 bytes: <@059990> - <@059997>): return .result := {...};
	<Complex @059990>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Complex.ci:34: (3 bytes: <@059993> - <@059996>): .result.im := im;
	<Complex+3 @059993>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @059996>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:189: referenced as `Complex`
	lib/std/math/Complex.ci:187: referenced as `Complex`
	lib/std/math/Complex.ci:151: referenced as `Complex`
	lib/std/math/Complex.ci:149: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:81: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	lib/std/math/Vector4f.ci:69: referenced as `neg`
	lib/std/math/Complex.ci:171: referenced as `neg`
	lib/std/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	lib/std/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math/Complex.ci:175: referenced as `add`
	lib/std/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/std/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math/Complex.ci:175: referenced as `sub`
	lib/std/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math/Complex.ci:175: referenced as `mul`
	lib/std/math/Complex.ci:175: referenced as `mul`
	lib/std/math/Complex.ci:173: referenced as `mul`
	lib/std/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@059998>
.name: 'div'
.file: 'lib/std/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@059998> - <@059a13>)
	lib/std/math/Complex.ci:90: (79 bytes: <@059998> - <@0599e7>): if (Math.abs(b.re) >= Math.abs(b.im))
	<div @059998>      : 1a                         load.z64
	<div+1 @059999>    : 11 03                      dup.x64 sp(3)
	<div+3 @05999b>    : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<div+8 @0599a0>    : 02                         call
	<div+9 @0599a1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @0599a5>   : 1a                         load.z64
	<div+14 @0599a6>   : 11 07                      dup.x64 sp(7)
	<div+16 @0599a8>   : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<div+21 @0599ad>   : 02                         call
	<div+22 @0599ae>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @0599b2>   : 88                         clt.f64
	<div+27 @0599b3>   : 05 34 00 00                jnz <div+79 @0599e7>
	lib/std/math/Complex.ci:91: (5 bytes: <@0599b7> - <@0599bc>): r: float64 := b.im / b.re
	<div+31 @0599b7>   : 11 03                      dup.x64 sp(3)
	<div+33 @0599b9>   : 11 03                      dup.x64 sp(3)
	<div+35 @0599bb>   : 84                         div.f64
	lib/std/math/Complex.ci:92: (8 bytes: <@0599bc> - <@0599c4>): den: float64 := b.re + r * b.im
	<div+36 @0599bc>   : 11 03                      dup.x64 sp(3)
	<div+38 @0599be>   : 11 02                      dup.x64 sp(2)
	<div+40 @0599c0>   : 11 09                      dup.x64 sp(9)
	<div+42 @0599c2>   : 83                         mul.f64
	<div+43 @0599c3>   : 81                         add.f64
	lib/std/math/Complex.ci:93: (31 bytes: <@0599c4> - <@0599e3>): return .result := {...};
	<div+44 @0599c4>   : 11 09                      dup.x64 sp(9)
	<div+46 @0599c6>   : 11 04                      dup.x64 sp(4)
	<div+48 @0599c8>   : 11 0f                      dup.x64 sp(15)
	<div+50 @0599ca>   : 83                         mul.f64
	<div+51 @0599cb>   : 81                         add.f64
	<div+52 @0599cc>   : 11 02                      dup.x64 sp(2)
	<div+54 @0599ce>   : 84                         div.f64
	<div+55 @0599cf>   : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:95: (13 bytes: <@0599d1> - <@0599de>): .result.im := (a.im - r * a.re) / den;
	<div+57 @0599d1>   : 11 0b                      dup.x64 sp(11)
	<div+59 @0599d3>   : 11 04                      dup.x64 sp(4)
	<div+61 @0599d5>   : 11 0d                      dup.x64 sp(13)
	<div+63 @0599d7>   : 83                         mul.f64
	<div+64 @0599d8>   : 82                         sub.f64
	<div+65 @0599d9>   : 11 02                      dup.x64 sp(2)
	<div+67 @0599db>   : 84                         div.f64
	<div+68 @0599dc>   : 14 11                      set.x64 sp(17)
	<div+70 @0599de>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @0599e2>   : 03                         ret
	<div+75 @0599e3>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math/Complex.ci:98: (5 bytes: <@0599e7> - <@0599ec>): r: float64 := b.re / b.im
	<div+79 @0599e7>   : 11 01                      dup.x64 sp(1)
	<div+81 @0599e9>   : 11 05                      dup.x64 sp(5)
	<div+83 @0599eb>   : 84                         div.f64
	lib/std/math/Complex.ci:99: (8 bytes: <@0599ec> - <@0599f4>): den: float64 := b.im + r * b.re
	<div+84 @0599ec>   : 11 05                      dup.x64 sp(5)
	<div+86 @0599ee>   : 11 02                      dup.x64 sp(2)
	<div+88 @0599f0>   : 11 07                      dup.x64 sp(7)
	<div+90 @0599f2>   : 83                         mul.f64
	<div+91 @0599f3>   : 81                         add.f64
	lib/std/math/Complex.ci:100: (31 bytes: <@0599f4> - <@059a13>): return .result := {...};
	<div+92 @0599f4>   : 11 09                      dup.x64 sp(9)
	<div+94 @0599f6>   : 11 04                      dup.x64 sp(4)
	<div+96 @0599f8>   : 83                         mul.f64
	<div+97 @0599f9>   : 11 0d                      dup.x64 sp(13)
	<div+99 @0599fb>   : 81                         add.f64
	<div+100 @0599fc>  : 11 02                      dup.x64 sp(2)
	<div+102 @0599fe>  : 84                         div.f64
	<div+103 @0599ff>  : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:102: (13 bytes: <@059a01> - <@059a0e>): .result.im := (a.im * r - a.re) / den;
	<div+105 @059a01>  : 11 0b                      dup.x64 sp(11)
	<div+107 @059a03>  : 11 04                      dup.x64 sp(4)
	<div+109 @059a05>  : 83                         mul.f64
	<div+110 @059a06>  : 11 0b                      dup.x64 sp(11)
	<div+112 @059a08>  : 82                         sub.f64
	<div+113 @059a09>  : 11 02                      dup.x64 sp(2)
	<div+115 @059a0b>  : 84                         div.f64
	<div+116 @059a0c>  : 14 11                      set.x64 sp(17)
	<div+118 @059a0e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @059a12>  : 03                         ret
.usages:
	lib/std/math/Complex.ci:175: referenced as `div`
	lib/std/math/Complex.ci:173: referenced as `div`
	lib/std/math/Complex.ci:166: referenced as `div`
	lib/std/math/Complex.ci:164: referenced as `div`
	lib/std/math/Complex.ci:109: referenced as `div`
	lib/std/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math/Complex.ci:171: referenced as `div`
	lib/std/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math/Complex.ci:189: referenced as `abs`
	lib/std/math/Complex.ci:136: referenced as `abs`
	lib/std/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math/Complex.ci:189: referenced as `arg`
	lib/std/math/Complex.ci:137: referenced as `arg`
	lib/std/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@059a18>
.name: 'inv'
.file: 'lib/std/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@059a18> - <@059a37>)
	lib/std/math/Complex.ci:118: (11 bytes: <@059a18> - <@059a23>): d: float64 := a.re * a.re + a.im * a.im
	<inv @059a18>      : 11 01                      dup.x64 sp(1)
	<inv+2 @059a1a>    : 11 03                      dup.x64 sp(3)
	<inv+4 @059a1c>    : 83                         mul.f64
	<inv+5 @059a1d>    : 11 05                      dup.x64 sp(5)
	<inv+7 @059a1f>    : 11 07                      dup.x64 sp(7)
	<inv+9 @059a21>    : 83                         mul.f64
	<inv+10 @059a22>   : 81                         add.f64
	lib/std/math/Complex.ci:119: (20 bytes: <@059a23> - <@059a37>): return .result := {...};
	<inv+11 @059a23>   : 11 03                      dup.x64 sp(3)
	<inv+13 @059a25>   : 11 02                      dup.x64 sp(2)
	<inv+15 @059a27>   : 84                         div.f64
	<inv+16 @059a28>   : 14 09                      set.x64 sp(9)
	lib/std/math/Complex.ci:121: (8 bytes: <@059a2a> - <@059a32>): .result.im := -a.im / d;
	<inv+18 @059a2a>   : 11 05                      dup.x64 sp(5)
	<inv+20 @059a2c>   : 80                         neg.f64
	<inv+21 @059a2d>   : 11 02                      dup.x64 sp(2)
	<inv+23 @059a2f>   : 84                         div.f64
	<inv+24 @059a30>   : 14 0b                      set.x64 sp(11)
	<inv+26 @059a32>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @059a36>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:184: referenced as `inv`
	lib/std/math/Complex.ci:182: referenced as `inv`
	lib/std/math/Complex.ci:180: referenced as `inv`
	lib/std/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math/Complex.ci:175: referenced as `exp`
	lib/std/math/Complex.ci:175: referenced as `exp`
	lib/std/math/Complex.ci:173: referenced as `exp`
	lib/std/math/Complex.ci:173: referenced as `exp`
	lib/std/math/Complex.ci:171: referenced as `exp`
	lib/std/math/Complex.ci:171: referenced as `exp`
	lib/std/math/Complex.ci:169: referenced as `exp`
	lib/std/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@059a38>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@059a38> - <@059a9c>)
	lib/std/math/Complex.ci:136: (23 bytes: <@059a38> - <@059a4f>): r: float64 := abs(a)
	<pow @059a38>      : 12 05                      dup.x128 sp(5)
	<pow+2 @059a3a>    : 11 00                      dup.x64 sp(0)
	<pow+4 @059a3c>    : 11 02                      dup.x64 sp(2)
	<pow+6 @059a3e>    : 83                         mul.f64
	<pow+7 @059a3f>    : 11 04                      dup.x64 sp(4)
	<pow+9 @059a41>    : 11 06                      dup.x64 sp(6)
	<pow+11 @059a43>   : 83                         mul.f64
	<pow+12 @059a44>   : 81                         add.f64
	<pow+13 @059a45>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<pow+17 @059a49>   : 14 04                      set.x64 sp(4)
	<pow+19 @059a4b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:137: (16 bytes: <@059a4f> - <@059a5f>): t: float64 := arg(a)
	<pow+23 @059a4f>   : 12 07                      dup.x128 sp(7)
	<pow+25 @059a51>   : 11 00                      dup.x64 sp(0)
	<pow+27 @059a53>   : 11 04                      dup.x64 sp(4)
	<pow+29 @059a55>   : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @059a59>   : 14 04                      set.x64 sp(4)
	<pow+35 @059a5b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:138: (15 bytes: <@059a5f> - <@059a6e>): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+39 @059a5f>   : 11 05                      dup.x64 sp(5)
	<pow+41 @059a61>   : 11 02                      dup.x64 sp(2)
	<pow+43 @059a63>   : 83                         mul.f64
	<pow+44 @059a64>   : 11 09                      dup.x64 sp(9)
	<pow+46 @059a66>   : 11 06                      dup.x64 sp(6)
	<pow+48 @059a68>   : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<pow+52 @059a6c>   : 83                         mul.f64
	<pow+53 @059a6d>   : 81                         add.f64
	lib/std/math/Complex.ci:139: (19 bytes: <@059a6e> - <@059a81>): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+54 @059a6e>   : 11 04                      dup.x64 sp(4)
	<pow+56 @059a70>   : 11 09                      dup.x64 sp(9)
	<pow+58 @059a72>   : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @059a76>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @059a78>   : 80                         neg.f64
	<pow+65 @059a79>   : 11 06                      dup.x64 sp(6)
	<pow+67 @059a7b>   : 83                         mul.f64
	<pow+68 @059a7c>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<pow+72 @059a80>   : 83                         mul.f64
	lib/std/math/Complex.ci:140: (27 bytes: <@059a81> - <@059a9c>): return .result := {...};
	<pow+73 @059a81>   : 11 00                      dup.x64 sp(0)
	<pow+75 @059a83>   : 11 04                      dup.x64 sp(4)
	<pow+77 @059a85>   : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<pow+81 @059a89>   : 83                         mul.f64
	<pow+82 @059a8a>   : 14 13                      set.x64 sp(19)
	lib/std/math/Complex.ci:142: (11 bytes: <@059a8c> - <@059a97>): .result.im := v * float64.sin(u);
	<pow+84 @059a8c>   : 11 00                      dup.x64 sp(0)
	<pow+86 @059a8e>   : 11 04                      dup.x64 sp(4)
	<pow+88 @059a90>   : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<pow+92 @059a94>   : 83                         mul.f64
	<pow+93 @059a95>   : 14 15                      set.x64 sp(21)
	<pow+95 @059a97>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @059a9b>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:180: referenced as `sin`
	lib/std/math/Complex.ci:166: referenced as `sin`
	lib/std/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:178: referenced as `cos`
	lib/std/math/Complex.ci:166: referenced as `cos`
	lib/std/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020e10>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:2'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/std/math/Matrix4f.ci:173: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:163: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:160: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:20: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:18: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:16: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:14: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:10: referenced as `vec4f`
	lib/std/math/Vector4f.ci:111: referenced as `vec4f`
	lib/std/math/Vector4f.ci:108: referenced as `vec4f`
	lib/std/math/Vector4f.ci:106: referenced as `vec4f`
	lib/std/math/Vector4f.ci:103: referenced as `vec4f`
	lib/std/math/Vector4f.ci:103: referenced as `vec4f`
	lib/std/math/Vector4f.ci:100: referenced as `vec4f`
	lib/std/math/Vector4f.ci:100: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:85: referenced as `vec4f`
	lib/std/math/Vector4f.ci:85: referenced as `vec4f`
	lib/std/math/Vector4f.ci:85: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:69: referenced as `vec4f`
	lib/std/math/Vector4f.ci:69: referenced as `vec4f`
	lib/std/math/Vector4f.ci:35: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector4f.ci:4'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector4f.ci:130'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `x`
	lib/std/math/Matrix4f.ci:165: referenced as `x`
	lib/std/math/Matrix4f.ci:125: referenced as `x`
	lib/std/math/Matrix4f.ci:122: referenced as `x`
	lib/std/math/Vector4f.ci:111: referenced as `x`
	lib/std/math/Vector4f.ci:103: referenced as `x`
	lib/std/math/Vector4f.ci:103: referenced as `x`
	lib/std/math/Vector4f.ci:103: referenced as `x`
	lib/std/math/Vector4f.ci:103: referenced as `x`
	lib/std/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `y`
	lib/std/math/Matrix4f.ci:166: referenced as `y`
	lib/std/math/Matrix4f.ci:126: referenced as `y`
	lib/std/math/Matrix4f.ci:123: referenced as `y`
	lib/std/math/Vector4f.ci:111: referenced as `y`
	lib/std/math/Vector4f.ci:103: referenced as `y`
	lib/std/math/Vector4f.ci:103: referenced as `y`
	lib/std/math/Vector4f.ci:103: referenced as `y`
	lib/std/math/Vector4f.ci:103: referenced as `y`
	lib/std/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `z`
	lib/std/math/Matrix4f.ci:167: referenced as `z`
	lib/std/math/Matrix4f.ci:127: referenced as `z`
	lib/std/math/Matrix4f.ci:124: referenced as `z`
	lib/std/math/Vector4f.ci:111: referenced as `z`
	lib/std/math/Vector4f.ci:103: referenced as `z`
	lib/std/math/Vector4f.ci:103: referenced as `z`
	lib/std/math/Vector4f.ci:103: referenced as `z`
	lib/std/math/Vector4f.ci:103: referenced as `z`
	lib/std/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/std/math/Vector4f.ci:111: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.param w: float32 (size: 4, offs: <+16>, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))))
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:119: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:118: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:117: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:116: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:38: referenced as `vec4f`
	lib/std/math/Vector4f.ci:35: referenced as `vec4f`
	lib/std/math/Vector4f.ci:32: referenced as `vec4f`
	lib/std/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	lib/std/math/Vector4f.ci:103: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/std/math/Matrix4f.ci:160: referenced as `vec4f`
	lib/std/math/Vector4f.ci:108: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/std/math/Vector4f.ci:108: referenced as `div`
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/std/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	lib/std/math/Vector2d.ci:34: referenced as `min`
	lib/std/math/Vector4f.ci:85: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/std/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	lib/std/math/Vector2d.ci:37: referenced as `max`
	lib/std/math/Vector4f.ci:85: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'lib/std/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: vec4f (size: 16, offs: <+32>, cast: val)
.param max: vec4f (size: 16, offs: <+48>, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(void(max(void(vec, min)), max))
.usages:
	lib/std/math/Vector4f.ci:88: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'lib/std/math/Vector4f.ci:88'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: float32 (size: 4, offs: <+20>, cast: f32)
.param max: float32 (size: 4, offs: <+24>, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(void(void(vec, vec4f(min)), vec4f(max)))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Vector4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Vector4f.ci:106: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Vector4f.ci:96'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Vector4f.ci:100'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/std/math/Vector4f.ci:103'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'lib/std/math/Vector4f.ci:106'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/std/math/Matrix4f.ci:112: referenced as `length`
	lib/std/math/Vector4f.ci:108: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/std/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math/Vector4f.ci:111'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@024b98>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:2'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/std/math/Matrix4f.ci:173: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:163: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:111: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:98: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:84: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:82: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:80: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:75: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/std/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/std/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:116: referenced as `x`
	lib/std/math/Matrix4f.ci:100: referenced as `x`
	lib/std/math/Matrix4f.ci:100: referenced as `x`
	lib/std/math/Matrix4f.ci:84: referenced as `x`
	lib/std/math/Matrix4f.ci:82: referenced as `x`
	lib/std/math/Matrix4f.ci:80: referenced as `x`
	lib/std/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:117: referenced as `y`
	lib/std/math/Matrix4f.ci:101: referenced as `y`
	lib/std/math/Matrix4f.ci:101: referenced as `y`
	lib/std/math/Matrix4f.ci:84: referenced as `y`
	lib/std/math/Matrix4f.ci:82: referenced as `y`
	lib/std/math/Matrix4f.ci:80: referenced as `y`
	lib/std/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:118: referenced as `z`
	lib/std/math/Matrix4f.ci:102: referenced as `z`
	lib/std/math/Matrix4f.ci:102: referenced as `z`
	lib/std/math/Matrix4f.ci:84: referenced as `z`
	lib/std/math/Matrix4f.ci:82: referenced as `z`
	lib/std/math/Matrix4f.ci:80: referenced as `z`
	lib/std/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `w`
	lib/std/math/Matrix4f.ci:119: referenced as `w`
	lib/std/math/Matrix4f.ci:103: referenced as `w`
	lib/std/math/Matrix4f.ci:103: referenced as `w`
	lib/std/math/Matrix4f.ci:84: referenced as `w`
	lib/std/math/Matrix4f.ci:82: referenced as `w`
	lib/std/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `xx`
	lib/std/math/Matrix4f.ci:165: referenced as `xx`
	lib/std/math/Matrix4f.ci:140: referenced as `xx`
	lib/std/math/Matrix4f.ci:89: referenced as `xx`
	lib/std/math/Matrix4f.ci:89: referenced as `xx`
	lib/std/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `xy`
	lib/std/math/Matrix4f.ci:165: referenced as `xy`
	lib/std/math/Matrix4f.ci:141: referenced as `xy`
	lib/std/math/Matrix4f.ci:89: referenced as `xy`
	lib/std/math/Matrix4f.ci:90: referenced as `xy`
	lib/std/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `xz`
	lib/std/math/Matrix4f.ci:165: referenced as `xz`
	lib/std/math/Matrix4f.ci:142: referenced as `xz`
	lib/std/math/Matrix4f.ci:89: referenced as `xz`
	lib/std/math/Matrix4f.ci:91: referenced as `xz`
	lib/std/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `xw`
	lib/std/math/Matrix4f.ci:165: referenced as `xw`
	lib/std/math/Matrix4f.ci:143: referenced as `xw`
	lib/std/math/Matrix4f.ci:89: referenced as `xw`
	lib/std/math/Matrix4f.ci:92: referenced as `xw`
	lib/std/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `yx`
	lib/std/math/Matrix4f.ci:166: referenced as `yx`
	lib/std/math/Matrix4f.ci:145: referenced as `yx`
	lib/std/math/Matrix4f.ci:90: referenced as `yx`
	lib/std/math/Matrix4f.ci:89: referenced as `yx`
	lib/std/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `yy`
	lib/std/math/Matrix4f.ci:166: referenced as `yy`
	lib/std/math/Matrix4f.ci:146: referenced as `yy`
	lib/std/math/Matrix4f.ci:90: referenced as `yy`
	lib/std/math/Matrix4f.ci:90: referenced as `yy`
	lib/std/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `yz`
	lib/std/math/Matrix4f.ci:166: referenced as `yz`
	lib/std/math/Matrix4f.ci:147: referenced as `yz`
	lib/std/math/Matrix4f.ci:90: referenced as `yz`
	lib/std/math/Matrix4f.ci:91: referenced as `yz`
	lib/std/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `yw`
	lib/std/math/Matrix4f.ci:166: referenced as `yw`
	lib/std/math/Matrix4f.ci:148: referenced as `yw`
	lib/std/math/Matrix4f.ci:90: referenced as `yw`
	lib/std/math/Matrix4f.ci:92: referenced as `yw`
	lib/std/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `zx`
	lib/std/math/Matrix4f.ci:167: referenced as `zx`
	lib/std/math/Matrix4f.ci:150: referenced as `zx`
	lib/std/math/Matrix4f.ci:91: referenced as `zx`
	lib/std/math/Matrix4f.ci:89: referenced as `zx`
	lib/std/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `zy`
	lib/std/math/Matrix4f.ci:167: referenced as `zy`
	lib/std/math/Matrix4f.ci:151: referenced as `zy`
	lib/std/math/Matrix4f.ci:91: referenced as `zy`
	lib/std/math/Matrix4f.ci:90: referenced as `zy`
	lib/std/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `zz`
	lib/std/math/Matrix4f.ci:167: referenced as `zz`
	lib/std/math/Matrix4f.ci:152: referenced as `zz`
	lib/std/math/Matrix4f.ci:91: referenced as `zz`
	lib/std/math/Matrix4f.ci:91: referenced as `zz`
	lib/std/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `zw`
	lib/std/math/Matrix4f.ci:167: referenced as `zw`
	lib/std/math/Matrix4f.ci:153: referenced as `zw`
	lib/std/math/Matrix4f.ci:91: referenced as `zw`
	lib/std/math/Matrix4f.ci:92: referenced as `zw`
	lib/std/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `wx`
	lib/std/math/Matrix4f.ci:168: referenced as `wx`
	lib/std/math/Matrix4f.ci:92: referenced as `wx`
	lib/std/math/Matrix4f.ci:89: referenced as `wx`
	lib/std/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `wy`
	lib/std/math/Matrix4f.ci:168: referenced as `wy`
	lib/std/math/Matrix4f.ci:92: referenced as `wy`
	lib/std/math/Matrix4f.ci:90: referenced as `wy`
	lib/std/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `wz`
	lib/std/math/Matrix4f.ci:168: referenced as `wz`
	lib/std/math/Matrix4f.ci:92: referenced as `wz`
	lib/std/math/Matrix4f.ci:91: referenced as `wz`
	lib/std/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `ww`
	lib/std/math/Matrix4f.ci:168: referenced as `ww`
	lib/std/math/Matrix4f.ci:92: referenced as `ww`
	lib/std/math/Matrix4f.ci:92: referenced as `ww`
	lib/std/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@059aa0>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
}
.instructions: (49 bytes: <@059aa0> - <@059ad1>)
	lib/std/math/Matrix4f.ci:66: (49 bytes: <@059aa0> - <@059ad1>): return .result := {...};
	<mat4f @059aa0>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@059aa3> - <@059aa6>): .result.xy := xy;
	<mat4f+3 @059aa3>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@059aa6> - <@059aa9>): .result.xz := xz;
	<mat4f+6 @059aa6>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@059aa9> - <@059aac>): .result.xw := xw;
	<mat4f+9 @059aa9>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@059aac> - <@059aaf>): .result.yx := yx;
	<mat4f+12 @059aac>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@059aaf> - <@059ab2>): .result.yy := yy;
	<mat4f+15 @059aaf>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@059ab2> - <@059ab5>): .result.yz := yz;
	<mat4f+18 @059ab2>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@059ab5> - <@059ab8>): .result.yw := yw;
	<mat4f+21 @059ab5>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@059ab8> - <@059abb>): .result.zx := zx;
	<mat4f+24 @059ab8>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@059abb> - <@059abe>): .result.zy := zy;
	<mat4f+27 @059abb>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@059abe> - <@059ac1>): .result.zz := zz;
	<mat4f+30 @059abe>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@059ac1> - <@059ac4>): .result.zw := zw;
	<mat4f+33 @059ac1>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@059ac4> - <@059ac7>): .result.wx := wx;
	<mat4f+36 @059ac4>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@059ac7> - <@059aca>): .result.wy := wy;
	<mat4f+39 @059ac7>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@059aca> - <@059acd>): .result.wz := wz;
	<mat4f+42 @059aca>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@059acd> - <@059ad0>): .result.ww := ww;
	<mat4f+45 @059acd>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @059ad0>   : 03                         ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@059ad8>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@059ad8> - <@059aed>)
	lib/std/math/Matrix4f.ci:76: (21 bytes: <@059ad8> - <@059aed>): return .result := {...};
	<mat4f @059ad8>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @059ada>    : 2a                         load.i128
	<mat4f+3 @059adb>    : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@059add> - <@059ae2>): .result.y := y;
	<mat4f+5 @059add>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @059adf>    : 2a                         load.i128
	<mat4f+8 @059ae0>    : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@059ae2> - <@059ae7>): .result.z := z;
	<mat4f+10 @059ae2>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @059ae4>   : 2a                         load.i128
	<mat4f+13 @059ae5>   : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@059ae7> - <@059aec>): .result.w := w;
	<mat4f+15 @059ae7>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @059ae9>   : 2a                         load.i128
	<mat4f+18 @059aea>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @059aec>   : 03                         ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/std/math/Matrix4f.ci:103: referenced as `dp4`
	lib/std/math/Matrix4f.ci:102: referenced as `dp4`
	lib/std/math/Matrix4f.ci:101: referenced as `dp4`
	lib/std/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@059af0>
.name: 'transpose'
.file: 'lib/std/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <@059af0> - <@059b21>)
	lib/std/math/Matrix4f.ci:88: (49 bytes: <@059af0> - <@059b21>): return .result := {...};
	<transpose @059af0>      : 16 11 01                   mov.x32 sp(17, 1)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@059af3> - <@059af6>): .result.xy := mat.yx;
	<transpose+3 @059af3>    : 16 12 05                   mov.x32 sp(18, 5)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@059af6> - <@059af9>): .result.xz := mat.zx;
	<transpose+6 @059af6>    : 16 13 09                   mov.x32 sp(19, 9)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@059af9> - <@059afc>): .result.xw := mat.wx;
	<transpose+9 @059af9>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@059afc> - <@059aff>): .result.yx := mat.xy;
	<transpose+12 @059afc>   : 16 15 02                   mov.x32 sp(21, 2)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@059aff> - <@059b02>): .result.yy := mat.yy;
	<transpose+15 @059aff>   : 16 16 06                   mov.x32 sp(22, 6)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@059b02> - <@059b05>): .result.yz := mat.zy;
	<transpose+18 @059b02>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@059b05> - <@059b08>): .result.yw := mat.wy;
	<transpose+21 @059b05>   : 16 18 0e                   mov.x32 sp(24, 14)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@059b08> - <@059b0b>): .result.zx := mat.xz;
	<transpose+24 @059b08>   : 16 19 03                   mov.x32 sp(25, 3)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@059b0b> - <@059b0e>): .result.zy := mat.yz;
	<transpose+27 @059b0b>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@059b0e> - <@059b11>): .result.zz := mat.zz;
	<transpose+30 @059b0e>   : 16 1b 0b                   mov.x32 sp(27, 11)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@059b11> - <@059b14>): .result.zw := mat.wz;
	<transpose+33 @059b11>   : 16 1c 0f                   mov.x32 sp(28, 15)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@059b14> - <@059b17>): .result.wx := mat.xw;
	<transpose+36 @059b14>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@059b17> - <@059b1a>): .result.wy := mat.yw;
	<transpose+39 @059b17>   : 16 1e 08                   mov.x32 sp(30, 8)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@059b1a> - <@059b1d>): .result.wz := mat.zw;
	<transpose+42 @059b1a>   : 16 1f 0c                   mov.x32 sp(31, 12)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@059b1d> - <@059b20>): .result.ww := mat.ww;
	<transpose+45 @059b1d>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @059b20>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 245
.offset: <@059b28>
.name: 'mul'
.file: 'lib/std/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (245 bytes: <@059b28> - <@059c1d>)
	lib/std/math/Matrix4f.ci:98: (28 bytes: <@059b28> - <@059b44>): transposed: mat4f := transpose(rhs)
	<mul @059b28>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @059b2c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @059b2e>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @059b32>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @059b36>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @059b3a>   : 1f f0 9a 05 00             load.ref <@059af0> ;transpose(mat: mat4f): mat4f
	<mul+23 @059b3f>   : 02                         call
	<mul+24 @059b40>   : 09 c0 ff ff                inc.sp(-64)
	lib/std/math/Matrix4f.ci:99: (217 bytes: <@059b44> - <@059c1d>): return .result := {...};
	<mul+28 @059b44>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @059b48>   : 10 13                      dup.x32 sp(19)
	<mul+34 @059b4a>   : 10 01                      dup.x32 sp(1)
	<mul+36 @059b4c>   : 0c 30 00 00                inc.i32(+48)
	<mul+40 @059b50>   : 2a                         load.i128
	<mul+41 @059b51>   : 10 04                      dup.x32 sp(4)
	<mul+43 @059b53>   : 2a                         load.i128
	<mul+44 @059b54>   : 9b                         dp4.v4f
	<mul+45 @059b55>   : 10 02                      dup.x32 sp(2)
	<mul+47 @059b57>   : 0c 20 00 00                inc.i32(+32)
	<mul+51 @059b5b>   : 2a                         load.i128
	<mul+52 @059b5c>   : 10 05                      dup.x32 sp(5)
	<mul+54 @059b5e>   : 2a                         load.i128
	<mul+55 @059b5f>   : 9b                         dp4.v4f
	<mul+56 @059b60>   : 10 03                      dup.x32 sp(3)
	<mul+58 @059b62>   : 0c 10 00 00                inc.i32(+16)
	<mul+62 @059b66>   : 2a                         load.i128
	<mul+63 @059b67>   : 10 06                      dup.x32 sp(6)
	<mul+65 @059b69>   : 2a                         load.i128
	<mul+66 @059b6a>   : 9b                         dp4.v4f
	<mul+67 @059b6b>   : 10 04                      dup.x32 sp(4)
	<mul+69 @059b6d>   : 2a                         load.i128
	<mul+70 @059b6e>   : 10 07                      dup.x32 sp(7)
	<mul+72 @059b70>   : 2a                         load.i128
	<mul+73 @059b71>   : 9b                         dp4.v4f
	<mul+74 @059b72>   : 15 02                      set.x128 sp(2)
	<mul+76 @059b74>   : 15 17                      set.x128 sp(23)
	lib/std/math/Matrix4f.ci:101: (54 bytes: <@059b76> - <@059bac>): .result.y := dp4(transposed, lhs.y);
	<mul+78 @059b76>   : 0a 00 00 00                load.sp(+0)
	<mul+82 @059b7a>   : 10 13                      dup.x32 sp(19)
	<mul+84 @059b7c>   : 0c 10 00 00                inc.i32(+16)
	<mul+88 @059b80>   : 10 01                      dup.x32 sp(1)
	<mul+90 @059b82>   : 0c 30 00 00                inc.i32(+48)
	<mul+94 @059b86>   : 2a                         load.i128
	<mul+95 @059b87>   : 10 04                      dup.x32 sp(4)
	<mul+97 @059b89>   : 2a                         load.i128
	<mul+98 @059b8a>   : 9b                         dp4.v4f
	<mul+99 @059b8b>   : 10 02                      dup.x32 sp(2)
	<mul+101 @059b8d>  : 0c 20 00 00                inc.i32(+32)
	<mul+105 @059b91>  : 2a                         load.i128
	<mul+106 @059b92>  : 10 05                      dup.x32 sp(5)
	<mul+108 @059b94>  : 2a                         load.i128
	<mul+109 @059b95>  : 9b                         dp4.v4f
	<mul+110 @059b96>  : 10 03                      dup.x32 sp(3)
	<mul+112 @059b98>  : 0c 10 00 00                inc.i32(+16)
	<mul+116 @059b9c>  : 2a                         load.i128
	<mul+117 @059b9d>  : 10 06                      dup.x32 sp(6)
	<mul+119 @059b9f>  : 2a                         load.i128
	<mul+120 @059ba0>  : 9b                         dp4.v4f
	<mul+121 @059ba1>  : 10 04                      dup.x32 sp(4)
	<mul+123 @059ba3>  : 2a                         load.i128
	<mul+124 @059ba4>  : 10 07                      dup.x32 sp(7)
	<mul+126 @059ba6>  : 2a                         load.i128
	<mul+127 @059ba7>  : 9b                         dp4.v4f
	<mul+128 @059ba8>  : 15 02                      set.x128 sp(2)
	<mul+130 @059baa>  : 15 1b                      set.x128 sp(27)
	lib/std/math/Matrix4f.ci:102: (54 bytes: <@059bac> - <@059be2>): .result.z := dp4(transposed, lhs.z);
	<mul+132 @059bac>  : 0a 00 00 00                load.sp(+0)
	<mul+136 @059bb0>  : 10 13                      dup.x32 sp(19)
	<mul+138 @059bb2>  : 0c 20 00 00                inc.i32(+32)
	<mul+142 @059bb6>  : 10 01                      dup.x32 sp(1)
	<mul+144 @059bb8>  : 0c 30 00 00                inc.i32(+48)
	<mul+148 @059bbc>  : 2a                         load.i128
	<mul+149 @059bbd>  : 10 04                      dup.x32 sp(4)
	<mul+151 @059bbf>  : 2a                         load.i128
	<mul+152 @059bc0>  : 9b                         dp4.v4f
	<mul+153 @059bc1>  : 10 02                      dup.x32 sp(2)
	<mul+155 @059bc3>  : 0c 20 00 00                inc.i32(+32)
	<mul+159 @059bc7>  : 2a                         load.i128
	<mul+160 @059bc8>  : 10 05                      dup.x32 sp(5)
	<mul+162 @059bca>  : 2a                         load.i128
	<mul+163 @059bcb>  : 9b                         dp4.v4f
	<mul+164 @059bcc>  : 10 03                      dup.x32 sp(3)
	<mul+166 @059bce>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @059bd2>  : 2a                         load.i128
	<mul+171 @059bd3>  : 10 06                      dup.x32 sp(6)
	<mul+173 @059bd5>  : 2a                         load.i128
	<mul+174 @059bd6>  : 9b                         dp4.v4f
	<mul+175 @059bd7>  : 10 04                      dup.x32 sp(4)
	<mul+177 @059bd9>  : 2a                         load.i128
	<mul+178 @059bda>  : 10 07                      dup.x32 sp(7)
	<mul+180 @059bdc>  : 2a                         load.i128
	<mul+181 @059bdd>  : 9b                         dp4.v4f
	<mul+182 @059bde>  : 15 02                      set.x128 sp(2)
	<mul+184 @059be0>  : 15 1f                      set.x128 sp(31)
	lib/std/math/Matrix4f.ci:103: (54 bytes: <@059be2> - <@059c18>): .result.w := dp4(transposed, lhs.w);
	<mul+186 @059be2>  : 0a 00 00 00                load.sp(+0)
	<mul+190 @059be6>  : 10 13                      dup.x32 sp(19)
	<mul+192 @059be8>  : 0c 30 00 00                inc.i32(+48)
	<mul+196 @059bec>  : 10 01                      dup.x32 sp(1)
	<mul+198 @059bee>  : 0c 30 00 00                inc.i32(+48)
	<mul+202 @059bf2>  : 2a                         load.i128
	<mul+203 @059bf3>  : 10 04                      dup.x32 sp(4)
	<mul+205 @059bf5>  : 2a                         load.i128
	<mul+206 @059bf6>  : 9b                         dp4.v4f
	<mul+207 @059bf7>  : 10 02                      dup.x32 sp(2)
	<mul+209 @059bf9>  : 0c 20 00 00                inc.i32(+32)
	<mul+213 @059bfd>  : 2a                         load.i128
	<mul+214 @059bfe>  : 10 05                      dup.x32 sp(5)
	<mul+216 @059c00>  : 2a                         load.i128
	<mul+217 @059c01>  : 9b                         dp4.v4f
	<mul+218 @059c02>  : 10 03                      dup.x32 sp(3)
	<mul+220 @059c04>  : 0c 10 00 00                inc.i32(+16)
	<mul+224 @059c08>  : 2a                         load.i128
	<mul+225 @059c09>  : 10 06                      dup.x32 sp(6)
	<mul+227 @059c0b>  : 2a                         load.i128
	<mul+228 @059c0c>  : 9b                         dp4.v4f
	<mul+229 @059c0d>  : 10 04                      dup.x32 sp(4)
	<mul+231 @059c0f>  : 2a                         load.i128
	<mul+232 @059c10>  : 10 07                      dup.x32 sp(7)
	<mul+234 @059c12>  : 2a                         load.i128
	<mul+235 @059c13>  : 9b                         dp4.v4f
	<mul+236 @059c14>  : 15 02                      set.x128 sp(2)
	<mul+238 @059c16>  : 15 23                      set.x128 sp(35)
	<mul+240 @059c18>  : 09 c0 ff ff                inc.sp(-64)
	<mul+244 @059c1c>  : 03                         ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 454
.offset: <@059c20>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (454 bytes: <@059c20> - <@059de6>)
	lib/std/math/Matrix4f.ci:112: (18 bytes: <@059c20> - <@059c32>): len: float32 := length(direction)
	<rotation @059c20>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @059c22>    : 2a                         load.i128
	<rotation+3 @059c23>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @059c25>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @059c27>    : 9a                         dp3.v4f
	<rotation+8 @059c28>    : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<rotation+12 @059c2c>   : 13 04                      set.x32 sp(4)
	<rotation+14 @059c2e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math/Matrix4f.ci:113: (82 bytes: <@059c32> - <@059c84>): if ((len) < 0.000000)
	<rotation+18 @059c32>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @059c34>   : 7d                         f32.2f64
	<rotation+21 @059c35>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @059c3e>   : 88                         clt.f64
	<rotation+31 @059c3f>   : 06 45 00 00                jz <rotation+100 @059c84>
	lib/std/math/Matrix4f.ci:114: (36 bytes: <@059c43> - <@059c67>): trace("invalid direction of rotation", direction);
	<rotation+35 @059c43>   : 1f 48 48 02 00             load.ref <@024848> ;"lib/std/math/Matrix4f.ci"
	<rotation+40 @059c48>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @059c4d>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @059c52>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @059c57>   : 1f 01 4b 02 00             load.ref <@024b01> ;"invalid direction of rotation"
	<rotation+60 @059c5c>   : 1f 10 0e 02 00             load.ref <@020e10> ;vec4f
	<rotation+65 @059c61>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @059c63>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/math/Matrix4f.ci:115: (29 bytes: <@059c67> - <@059c84>): return .result := {...};
	<rotation+71 @059c67>   : 19                         load.z32
	<rotation+72 @059c68>   : 19                         load.z32
	<rotation+73 @059c69>   : 19                         load.z32
	<rotation+74 @059c6a>   : 19                         load.z32
	<rotation+75 @059c6b>   : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:117: (6 bytes: <@059c6d> - <@059c73>): .result.y := vec4f(0, 0, 0, 0);
	<rotation+77 @059c6d>   : 19                         load.z32
	<rotation+78 @059c6e>   : 19                         load.z32
	<rotation+79 @059c6f>   : 19                         load.z32
	<rotation+80 @059c70>   : 19                         load.z32
	<rotation+81 @059c71>   : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:118: (6 bytes: <@059c73> - <@059c79>): .result.z := vec4f(0, 0, 0, 0);
	<rotation+83 @059c73>   : 19                         load.z32
	<rotation+84 @059c74>   : 19                         load.z32
	<rotation+85 @059c75>   : 19                         load.z32
	<rotation+86 @059c76>   : 19                         load.z32
	<rotation+87 @059c77>   : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:119: (6 bytes: <@059c79> - <@059c7f>): .result.w := vec4f(0, 0, 0, 0);
	<rotation+89 @059c79>   : 19                         load.z32
	<rotation+90 @059c7a>   : 19                         load.z32
	<rotation+91 @059c7b>   : 19                         load.z32
	<rotation+92 @059c7c>   : 19                         load.z32
	<rotation+93 @059c7d>   : 15 15                      set.x128 sp(21)
	<rotation+95 @059c7f>   : 09 fc ff ff                inc.sp(-4)
	<rotation+99 @059c83>   : 03                         ret
	lib/std/math/Matrix4f.ci:122: (6 bytes: <@059c84> - <@059c8a>): x: float32 := direction.x / len
	<rotation+100 @059c84>  : 10 03                      dup.x32 sp(3)
	<rotation+102 @059c86>  : 28                         load.i32
	<rotation+103 @059c87>  : 10 01                      dup.x32 sp(1)
	<rotation+105 @059c89>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:123: (10 bytes: <@059c8a> - <@059c94>): y: float32 := direction.y / len
	<rotation+106 @059c8a>  : 10 04                      dup.x32 sp(4)
	<rotation+108 @059c8c>  : 0c 04 00 00                inc.i32(+4)
	<rotation+112 @059c90>  : 28                         load.i32
	<rotation+113 @059c91>  : 10 02                      dup.x32 sp(2)
	<rotation+115 @059c93>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:124: (10 bytes: <@059c94> - <@059c9e>): z: float32 := direction.z / len
	<rotation+116 @059c94>  : 10 05                      dup.x32 sp(5)
	<rotation+118 @059c96>  : 0c 08 00 00                inc.i32(+8)
	<rotation+122 @059c9a>  : 28                         load.i32
	<rotation+123 @059c9b>  : 10 03                      dup.x32 sp(3)
	<rotation+125 @059c9d>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:125: (3 bytes: <@059c9e> - <@059ca1>): cx: float32 := center.x
	<rotation+126 @059c9e>  : 10 07                      dup.x32 sp(7)
	<rotation+128 @059ca0>  : 28                         load.i32
	lib/std/math/Matrix4f.ci:126: (7 bytes: <@059ca1> - <@059ca8>): cy: float32 := center.y
	<rotation+129 @059ca1>  : 10 08                      dup.x32 sp(8)
	<rotation+131 @059ca3>  : 0c 04 00 00                inc.i32(+4)
	<rotation+135 @059ca7>  : 28                         load.i32
	lib/std/math/Matrix4f.ci:127: (7 bytes: <@059ca8> - <@059caf>): cz: float32 := center.z
	<rotation+136 @059ca8>  : 10 09                      dup.x32 sp(9)
	<rotation+138 @059caa>  : 0c 08 00 00                inc.i32(+8)
	<rotation+142 @059cae>  : 28                         load.i32
	lib/std/math/Matrix4f.ci:128: (5 bytes: <@059caf> - <@059cb4>): xx: float32 := x * x
	<rotation+143 @059caf>  : 10 05                      dup.x32 sp(5)
	<rotation+145 @059cb1>  : 10 06                      dup.x32 sp(6)
	<rotation+147 @059cb3>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:129: (5 bytes: <@059cb4> - <@059cb9>): xy: float32 := x * y
	<rotation+148 @059cb4>  : 10 06                      dup.x32 sp(6)
	<rotation+150 @059cb6>  : 10 06                      dup.x32 sp(6)
	<rotation+152 @059cb8>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:130: (5 bytes: <@059cb9> - <@059cbe>): xz: float32 := x * z
	<rotation+153 @059cb9>  : 10 07                      dup.x32 sp(7)
	<rotation+155 @059cbb>  : 10 06                      dup.x32 sp(6)
	<rotation+157 @059cbd>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:131: (5 bytes: <@059cbe> - <@059cc3>): yy: float32 := y * y
	<rotation+158 @059cbe>  : 10 07                      dup.x32 sp(7)
	<rotation+160 @059cc0>  : 10 08                      dup.x32 sp(8)
	<rotation+162 @059cc2>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:132: (5 bytes: <@059cc3> - <@059cc8>): yz: float32 := y * z
	<rotation+163 @059cc3>  : 10 08                      dup.x32 sp(8)
	<rotation+165 @059cc5>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @059cc7>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:133: (5 bytes: <@059cc8> - <@059ccd>): zz: float32 := z * z
	<rotation+168 @059cc8>  : 10 08                      dup.x32 sp(8)
	<rotation+170 @059cca>  : 10 09                      dup.x32 sp(9)
	<rotation+172 @059ccc>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:135: (6 bytes: <@059ccd> - <@059cd3>): s: float32 := float32.sin(angle)
	<rotation+173 @059ccd>  : 10 0e                      dup.x32 sp(14)
	<rotation+175 @059ccf>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	lib/std/math/Matrix4f.ci:136: (6 bytes: <@059cd3> - <@059cd9>): c: float32 := float32.cos(angle)
	<rotation+179 @059cd3>  : 10 0f                      dup.x32 sp(15)
	<rotation+181 @059cd5>  : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	lib/std/math/Matrix4f.ci:137: (8 bytes: <@059cd9> - <@059ce1>): k: float32 := (1) - c
	<rotation+185 @059cd9>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+190 @059cde>  : 10 01                      dup.x32 sp(1)
	<rotation+192 @059ce0>  : 72                         sub.f32
	lib/std/math/Matrix4f.ci:139: (261 bytes: <@059ce1> - <@059de6>): return .result := {...};
	<rotation+193 @059ce1>  : 10 08                      dup.x32 sp(8)
	<rotation+195 @059ce3>  : 10 06                      dup.x32 sp(6)
	<rotation+197 @059ce5>  : 10 05                      dup.x32 sp(5)
	<rotation+199 @059ce7>  : 71                         add.f32
	<rotation+200 @059ce8>  : 10 03                      dup.x32 sp(3)
	<rotation+202 @059cea>  : 73                         mul.f32
	<rotation+203 @059ceb>  : 71                         add.f32
	<rotation+204 @059cec>  : 13 15                      set.x32 sp(21)
	lib/std/math/Matrix4f.ci:141: (13 bytes: <@059cee> - <@059cfb>): .result.xy := xy * k - z * s;
	<rotation+206 @059cee>  : 10 07                      dup.x32 sp(7)
	<rotation+208 @059cf0>  : 10 01                      dup.x32 sp(1)
	<rotation+210 @059cf2>  : 73                         mul.f32
	<rotation+211 @059cf3>  : 10 0d                      dup.x32 sp(13)
	<rotation+213 @059cf5>  : 10 04                      dup.x32 sp(4)
	<rotation+215 @059cf7>  : 73                         mul.f32
	<rotation+216 @059cf8>  : 72                         sub.f32
	<rotation+217 @059cf9>  : 13 16                      set.x32 sp(22)
	lib/std/math/Matrix4f.ci:142: (13 bytes: <@059cfb> - <@059d08>): .result.xz := xz * k + y * s;
	<rotation+219 @059cfb>  : 10 06                      dup.x32 sp(6)
	<rotation+221 @059cfd>  : 10 01                      dup.x32 sp(1)
	<rotation+223 @059cff>  : 73                         mul.f32
	<rotation+224 @059d00>  : 10 0e                      dup.x32 sp(14)
	<rotation+226 @059d02>  : 10 04                      dup.x32 sp(4)
	<rotation+228 @059d04>  : 73                         mul.f32
	<rotation+229 @059d05>  : 71                         add.f32
	<rotation+230 @059d06>  : 13 17                      set.x32 sp(23)
	lib/std/math/Matrix4f.ci:143: (43 bytes: <@059d08> - <@059d33>): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+232 @059d08>  : 10 0b                      dup.x32 sp(11)
	<rotation+234 @059d0a>  : 10 06                      dup.x32 sp(6)
	<rotation+236 @059d0c>  : 10 05                      dup.x32 sp(5)
	<rotation+238 @059d0e>  : 71                         add.f32
	<rotation+239 @059d0f>  : 73                         mul.f32
	<rotation+240 @059d10>  : 10 0f                      dup.x32 sp(15)
	<rotation+242 @059d12>  : 10 0c                      dup.x32 sp(12)
	<rotation+244 @059d14>  : 10 10                      dup.x32 sp(16)
	<rotation+246 @059d16>  : 73                         mul.f32
	<rotation+247 @059d17>  : 10 0c                      dup.x32 sp(12)
	<rotation+249 @059d19>  : 10 10                      dup.x32 sp(16)
	<rotation+251 @059d1b>  : 73                         mul.f32
	<rotation+252 @059d1c>  : 71                         add.f32
	<rotation+253 @059d1d>  : 73                         mul.f32
	<rotation+254 @059d1e>  : 72                         sub.f32
	<rotation+255 @059d1f>  : 10 01                      dup.x32 sp(1)
	<rotation+257 @059d21>  : 73                         mul.f32
	<rotation+258 @059d22>  : 10 0b                      dup.x32 sp(11)
	<rotation+260 @059d24>  : 10 0e                      dup.x32 sp(14)
	<rotation+262 @059d26>  : 73                         mul.f32
	<rotation+263 @059d27>  : 10 0b                      dup.x32 sp(11)
	<rotation+265 @059d29>  : 10 10                      dup.x32 sp(16)
	<rotation+267 @059d2b>  : 73                         mul.f32
	<rotation+268 @059d2c>  : 72                         sub.f32
	<rotation+269 @059d2d>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @059d2f>  : 73                         mul.f32
	<rotation+272 @059d30>  : 71                         add.f32
	<rotation+273 @059d31>  : 13 18                      set.x32 sp(24)
	lib/std/math/Matrix4f.ci:145: (13 bytes: <@059d33> - <@059d40>): .result.yx := xy * k + z * s;
	<rotation+275 @059d33>  : 10 07                      dup.x32 sp(7)
	<rotation+277 @059d35>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @059d37>  : 73                         mul.f32
	<rotation+280 @059d38>  : 10 0d                      dup.x32 sp(13)
	<rotation+282 @059d3a>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @059d3c>  : 73                         mul.f32
	<rotation+285 @059d3d>  : 71                         add.f32
	<rotation+286 @059d3e>  : 13 19                      set.x32 sp(25)
	lib/std/math/Matrix4f.ci:146: (13 bytes: <@059d40> - <@059d4d>): .result.yy := yy + (xx + zz) * c;
	<rotation+288 @059d40>  : 10 05                      dup.x32 sp(5)
	<rotation+290 @059d42>  : 10 09                      dup.x32 sp(9)
	<rotation+292 @059d44>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @059d46>  : 71                         add.f32
	<rotation+295 @059d47>  : 10 03                      dup.x32 sp(3)
	<rotation+297 @059d49>  : 73                         mul.f32
	<rotation+298 @059d4a>  : 71                         add.f32
	<rotation+299 @059d4b>  : 13 1a                      set.x32 sp(26)
	lib/std/math/Matrix4f.ci:147: (13 bytes: <@059d4d> - <@059d5a>): .result.yz := yz * k - x * s;
	<rotation+301 @059d4d>  : 10 04                      dup.x32 sp(4)
	<rotation+303 @059d4f>  : 10 01                      dup.x32 sp(1)
	<rotation+305 @059d51>  : 73                         mul.f32
	<rotation+306 @059d52>  : 10 0f                      dup.x32 sp(15)
	<rotation+308 @059d54>  : 10 04                      dup.x32 sp(4)
	<rotation+310 @059d56>  : 73                         mul.f32
	<rotation+311 @059d57>  : 72                         sub.f32
	<rotation+312 @059d58>  : 13 1b                      set.x32 sp(27)
	lib/std/math/Matrix4f.ci:148: (43 bytes: <@059d5a> - <@059d85>): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+314 @059d5a>  : 10 0a                      dup.x32 sp(10)
	<rotation+316 @059d5c>  : 10 09                      dup.x32 sp(9)
	<rotation+318 @059d5e>  : 10 05                      dup.x32 sp(5)
	<rotation+320 @059d60>  : 71                         add.f32
	<rotation+321 @059d61>  : 73                         mul.f32
	<rotation+322 @059d62>  : 10 0e                      dup.x32 sp(14)
	<rotation+324 @059d64>  : 10 0d                      dup.x32 sp(13)
	<rotation+326 @059d66>  : 10 11                      dup.x32 sp(17)
	<rotation+328 @059d68>  : 73                         mul.f32
	<rotation+329 @059d69>  : 10 0c                      dup.x32 sp(12)
	<rotation+331 @059d6b>  : 10 10                      dup.x32 sp(16)
	<rotation+333 @059d6d>  : 73                         mul.f32
	<rotation+334 @059d6e>  : 71                         add.f32
	<rotation+335 @059d6f>  : 73                         mul.f32
	<rotation+336 @059d70>  : 72                         sub.f32
	<rotation+337 @059d71>  : 10 01                      dup.x32 sp(1)
	<rotation+339 @059d73>  : 73                         mul.f32
	<rotation+340 @059d74>  : 10 0a                      dup.x32 sp(10)
	<rotation+342 @059d76>  : 10 10                      dup.x32 sp(16)
	<rotation+344 @059d78>  : 73                         mul.f32
	<rotation+345 @059d79>  : 10 0d                      dup.x32 sp(13)
	<rotation+347 @059d7b>  : 10 0f                      dup.x32 sp(15)
	<rotation+349 @059d7d>  : 73                         mul.f32
	<rotation+350 @059d7e>  : 72                         sub.f32
	<rotation+351 @059d7f>  : 10 04                      dup.x32 sp(4)
	<rotation+353 @059d81>  : 73                         mul.f32
	<rotation+354 @059d82>  : 71                         add.f32
	<rotation+355 @059d83>  : 13 1c                      set.x32 sp(28)
	lib/std/math/Matrix4f.ci:150: (13 bytes: <@059d85> - <@059d92>): .result.zx := xz * k - y * s;
	<rotation+357 @059d85>  : 10 06                      dup.x32 sp(6)
	<rotation+359 @059d87>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @059d89>  : 73                         mul.f32
	<rotation+362 @059d8a>  : 10 0e                      dup.x32 sp(14)
	<rotation+364 @059d8c>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @059d8e>  : 73                         mul.f32
	<rotation+367 @059d8f>  : 72                         sub.f32
	<rotation+368 @059d90>  : 13 1d                      set.x32 sp(29)
	lib/std/math/Matrix4f.ci:151: (13 bytes: <@059d92> - <@059d9f>): .result.zy := yz * k + x * s;
	<rotation+370 @059d92>  : 10 04                      dup.x32 sp(4)
	<rotation+372 @059d94>  : 10 01                      dup.x32 sp(1)
	<rotation+374 @059d96>  : 73                         mul.f32
	<rotation+375 @059d97>  : 10 0f                      dup.x32 sp(15)
	<rotation+377 @059d99>  : 10 04                      dup.x32 sp(4)
	<rotation+379 @059d9b>  : 73                         mul.f32
	<rotation+380 @059d9c>  : 71                         add.f32
	<rotation+381 @059d9d>  : 13 1e                      set.x32 sp(30)
	lib/std/math/Matrix4f.ci:152: (13 bytes: <@059d9f> - <@059dac>): .result.zz := zz + (xx + yy) * c;
	<rotation+383 @059d9f>  : 10 03                      dup.x32 sp(3)
	<rotation+385 @059da1>  : 10 09                      dup.x32 sp(9)
	<rotation+387 @059da3>  : 10 07                      dup.x32 sp(7)
	<rotation+389 @059da5>  : 71                         add.f32
	<rotation+390 @059da6>  : 10 03                      dup.x32 sp(3)
	<rotation+392 @059da8>  : 73                         mul.f32
	<rotation+393 @059da9>  : 71                         add.f32
	<rotation+394 @059daa>  : 13 1f                      set.x32 sp(31)
	lib/std/math/Matrix4f.ci:153: (43 bytes: <@059dac> - <@059dd7>): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+396 @059dac>  : 10 09                      dup.x32 sp(9)
	<rotation+398 @059dae>  : 10 09                      dup.x32 sp(9)
	<rotation+400 @059db0>  : 10 07                      dup.x32 sp(7)
	<rotation+402 @059db2>  : 71                         add.f32
	<rotation+403 @059db3>  : 73                         mul.f32
	<rotation+404 @059db4>  : 10 0d                      dup.x32 sp(13)
	<rotation+406 @059db6>  : 10 0d                      dup.x32 sp(13)
	<rotation+408 @059db8>  : 10 11                      dup.x32 sp(17)
	<rotation+410 @059dba>  : 73                         mul.f32
	<rotation+411 @059dbb>  : 10 0d                      dup.x32 sp(13)
	<rotation+413 @059dbd>  : 10 11                      dup.x32 sp(17)
	<rotation+415 @059dbf>  : 73                         mul.f32
	<rotation+416 @059dc0>  : 71                         add.f32
	<rotation+417 @059dc1>  : 73                         mul.f32
	<rotation+418 @059dc2>  : 72                         sub.f32
	<rotation+419 @059dc3>  : 10 01                      dup.x32 sp(1)
	<rotation+421 @059dc5>  : 73                         mul.f32
	<rotation+422 @059dc6>  : 10 0c                      dup.x32 sp(12)
	<rotation+424 @059dc8>  : 10 0f                      dup.x32 sp(15)
	<rotation+426 @059dca>  : 73                         mul.f32
	<rotation+427 @059dcb>  : 10 0c                      dup.x32 sp(12)
	<rotation+429 @059dcd>  : 10 11                      dup.x32 sp(17)
	<rotation+431 @059dcf>  : 73                         mul.f32
	<rotation+432 @059dd0>  : 72                         sub.f32
	<rotation+433 @059dd1>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @059dd3>  : 73                         mul.f32
	<rotation+436 @059dd4>  : 71                         add.f32
	<rotation+437 @059dd5>  : 13 20                      set.x32 sp(32)
	lib/std/math/Matrix4f.ci:155: (10 bytes: <@059dd7> - <@059de1>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+439 @059dd7>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+444 @059ddc>  : 19                         load.z32
	<rotation+445 @059ddd>  : 19                         load.z32
	<rotation+446 @059dde>  : 19                         load.z32
	<rotation+447 @059ddf>  : 15 24                      set.x128 sp(36)
	<rotation+449 @059de1>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+453 @059de5>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:160: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 88
.offset: <@059de8>
.name: 'translation'
.file: 'lib/std/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (88 bytes: <@059de8> - <@059e40>)
	lib/std/math/Matrix4f.ci:164: (88 bytes: <@059de8> - <@059e40>): return .result := {...};
	<translation @059de8>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @059ded>    : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:165: (3 bytes: <@059def> - <@059df2>): .result.xy := (0);
	<translation+7 @059def>    : 19                         load.z32
	<translation+8 @059df0>    : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:165: (3 bytes: <@059df2> - <@059df5>): .result.xz := (0);
	<translation+10 @059df2>   : 19                         load.z32
	<translation+11 @059df3>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:165: (8 bytes: <@059df5> - <@059dfd>): .result.xw := direction.x * amount;
	<translation+13 @059df5>   : 10 02                      dup.x32 sp(2)
	<translation+15 @059df7>   : 28                         load.i32
	<translation+16 @059df8>   : 10 02                      dup.x32 sp(2)
	<translation+18 @059dfa>   : 73                         mul.f32
	<translation+19 @059dfb>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:166: (3 bytes: <@059dfd> - <@059e00>): .result.yx := (0);
	<translation+21 @059dfd>   : 19                         load.z32
	<translation+22 @059dfe>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:166: (7 bytes: <@059e00> - <@059e07>): .result.yy := (1);
	<translation+24 @059e00>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @059e05>   : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:166: (3 bytes: <@059e07> - <@059e0a>): .result.yz := (0);
	<translation+31 @059e07>   : 19                         load.z32
	<translation+32 @059e08>   : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:166: (12 bytes: <@059e0a> - <@059e16>): .result.yw := direction.y * amount;
	<translation+34 @059e0a>   : 10 02                      dup.x32 sp(2)
	<translation+36 @059e0c>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @059e10>   : 28                         load.i32
	<translation+41 @059e11>   : 10 02                      dup.x32 sp(2)
	<translation+43 @059e13>   : 73                         mul.f32
	<translation+44 @059e14>   : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:167: (3 bytes: <@059e16> - <@059e19>): .result.zx := (0);
	<translation+46 @059e16>   : 19                         load.z32
	<translation+47 @059e17>   : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:167: (3 bytes: <@059e19> - <@059e1c>): .result.zy := (0);
	<translation+49 @059e19>   : 19                         load.z32
	<translation+50 @059e1a>   : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:167: (7 bytes: <@059e1c> - <@059e23>): .result.zz := (1);
	<translation+52 @059e1c>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @059e21>   : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:167: (12 bytes: <@059e23> - <@059e2f>): .result.zw := direction.z * amount;
	<translation+59 @059e23>   : 10 02                      dup.x32 sp(2)
	<translation+61 @059e25>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @059e29>   : 28                         load.i32
	<translation+66 @059e2a>   : 10 02                      dup.x32 sp(2)
	<translation+68 @059e2c>   : 73                         mul.f32
	<translation+69 @059e2d>   : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@059e2f> - <@059e32>): .result.wx := (0);
	<translation+71 @059e2f>   : 19                         load.z32
	<translation+72 @059e30>   : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@059e32> - <@059e35>): .result.wy := (0);
	<translation+74 @059e32>   : 19                         load.z32
	<translation+75 @059e33>   : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@059e35> - <@059e38>): .result.wz := (0);
	<translation+77 @059e35>   : 19                         load.z32
	<translation+78 @059e36>   : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:168: (7 bytes: <@059e38> - <@059e3f>): .result.ww := (1);
	<translation+80 @059e38>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @059e3d>   : 13 13                      set.x32 sp(19)
	<translation+87 @059e3f>   : 03                         ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 217
.offset: <@059e40>
.name: 'scale'
.file: 'lib/std/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (217 bytes: <@059e40> - <@059f19>)
	lib/std/math/Matrix4f.ci:175: (217 bytes: <@059e40> - <@059f19>): return .result := {...};
	<scale @059e40>      : 10 02                      dup.x32 sp(2)
	<scale+2 @059e42>    : 28                         load.i32
	<scale+3 @059e43>    : 10 02                      dup.x32 sp(2)
	<scale+5 @059e45>    : 73                         mul.f32
	<scale+6 @059e46>    : 10 00                      dup.x32 sp(0)
	<scale+8 @059e48>    : 19                         load.z32
	<scale+9 @059e49>    : 78                         clt.f32
	<scale+10 @059e4a>   : 06 0b 00 00                jz <scale+21 @059e55>
	<scale+14 @059e4e>   : 10 00                      dup.x32 sp(0)
	<scale+16 @059e50>   : 70                         neg.f32
	<scale+17 @059e51>   : 04 06 00 00                jmp <scale+23 @059e57>
	<scale+21 @059e55>   : 10 00                      dup.x32 sp(0)
	<scale+23 @059e57>   : 7d                         f32.2f64
	<scale+24 @059e58>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @059e61>   : 88                         clt.f64
	<scale+34 @059e62>   : 06 09 00 00                jz <scale+43 @059e6b>
	<scale+38 @059e66>   : 19                         load.z32
	<scale+39 @059e67>   : 04 0c 00 00                jmp <scale+51 @059e73>
	<scale+43 @059e6b>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @059e70>   : 10 01                      dup.x32 sp(1)
	<scale+50 @059e72>   : 74                         div.f32
	<scale+51 @059e73>   : 13 01                      set.x32 sp(1)
	<scale+53 @059e75>   : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@059e77> - <@059e7a>): .result.xy := (0);
	<scale+55 @059e77>   : 19                         load.z32
	<scale+56 @059e78>   : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@059e7a> - <@059e7d>): .result.xz := (0);
	<scale+58 @059e7a>   : 19                         load.z32
	<scale+59 @059e7b>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@059e7d> - <@059e80>): .result.xw := (0);
	<scale+61 @059e7d>   : 19                         load.z32
	<scale+62 @059e7e>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@059e80> - <@059e83>): .result.yx := (0);
	<scale+64 @059e80>   : 19                         load.z32
	<scale+65 @059e81>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:177: (59 bytes: <@059e83> - <@059ebe>): .result.yy := rcp(direction.y * amount);
	<scale+67 @059e83>   : 10 02                      dup.x32 sp(2)
	<scale+69 @059e85>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @059e89>   : 28                         load.i32
	<scale+74 @059e8a>   : 10 02                      dup.x32 sp(2)
	<scale+76 @059e8c>   : 73                         mul.f32
	<scale+77 @059e8d>   : 10 00                      dup.x32 sp(0)
	<scale+79 @059e8f>   : 19                         load.z32
	<scale+80 @059e90>   : 78                         clt.f32
	<scale+81 @059e91>   : 06 0b 00 00                jz <scale+92 @059e9c>
	<scale+85 @059e95>   : 10 00                      dup.x32 sp(0)
	<scale+87 @059e97>   : 70                         neg.f32
	<scale+88 @059e98>   : 04 06 00 00                jmp <scale+94 @059e9e>
	<scale+92 @059e9c>   : 10 00                      dup.x32 sp(0)
	<scale+94 @059e9e>   : 7d                         f32.2f64
	<scale+95 @059e9f>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @059ea8>  : 88                         clt.f64
	<scale+105 @059ea9>  : 06 09 00 00                jz <scale+114 @059eb2>
	<scale+109 @059ead>  : 19                         load.z32
	<scale+110 @059eae>  : 04 0c 00 00                jmp <scale+122 @059eba>
	<scale+114 @059eb2>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @059eb7>  : 10 01                      dup.x32 sp(1)
	<scale+121 @059eb9>  : 74                         div.f32
	<scale+122 @059eba>  : 13 01                      set.x32 sp(1)
	<scale+124 @059ebc>  : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@059ebe> - <@059ec1>): .result.yz := (0);
	<scale+126 @059ebe>  : 19                         load.z32
	<scale+127 @059ebf>  : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@059ec1> - <@059ec4>): .result.yw := (0);
	<scale+129 @059ec1>  : 19                         load.z32
	<scale+130 @059ec2>  : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@059ec4> - <@059ec7>): .result.zx := (0);
	<scale+132 @059ec4>  : 19                         load.z32
	<scale+133 @059ec5>  : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@059ec7> - <@059eca>): .result.zy := (0);
	<scale+135 @059ec7>  : 19                         load.z32
	<scale+136 @059ec8>  : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:178: (59 bytes: <@059eca> - <@059f05>): .result.zz := rcp(direction.z * amount);
	<scale+138 @059eca>  : 10 02                      dup.x32 sp(2)
	<scale+140 @059ecc>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @059ed0>  : 28                         load.i32
	<scale+145 @059ed1>  : 10 02                      dup.x32 sp(2)
	<scale+147 @059ed3>  : 73                         mul.f32
	<scale+148 @059ed4>  : 10 00                      dup.x32 sp(0)
	<scale+150 @059ed6>  : 19                         load.z32
	<scale+151 @059ed7>  : 78                         clt.f32
	<scale+152 @059ed8>  : 06 0b 00 00                jz <scale+163 @059ee3>
	<scale+156 @059edc>  : 10 00                      dup.x32 sp(0)
	<scale+158 @059ede>  : 70                         neg.f32
	<scale+159 @059edf>  : 04 06 00 00                jmp <scale+165 @059ee5>
	<scale+163 @059ee3>  : 10 00                      dup.x32 sp(0)
	<scale+165 @059ee5>  : 7d                         f32.2f64
	<scale+166 @059ee6>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @059eef>  : 88                         clt.f64
	<scale+176 @059ef0>  : 06 09 00 00                jz <scale+185 @059ef9>
	<scale+180 @059ef4>  : 19                         load.z32
	<scale+181 @059ef5>  : 04 0c 00 00                jmp <scale+193 @059f01>
	<scale+185 @059ef9>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @059efe>  : 10 01                      dup.x32 sp(1)
	<scale+192 @059f00>  : 74                         div.f32
	<scale+193 @059f01>  : 13 01                      set.x32 sp(1)
	<scale+195 @059f03>  : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@059f05> - <@059f08>): .result.zw := (0);
	<scale+197 @059f05>  : 19                         load.z32
	<scale+198 @059f06>  : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@059f08> - <@059f0b>): .result.wx := (0);
	<scale+200 @059f08>  : 19                         load.z32
	<scale+201 @059f09>  : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@059f0b> - <@059f0e>): .result.wy := (0);
	<scale+203 @059f0b>  : 19                         load.z32
	<scale+204 @059f0c>  : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@059f0e> - <@059f11>): .result.wz := (0);
	<scale+206 @059f0e>  : 19                         load.z32
	<scale+207 @059f0f>  : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:179: (7 bytes: <@059f11> - <@059f18>): .result.ww := (1);
	<scale+209 @059f11>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @059f16>  : 13 13                      set.x32 sp(19)
	<scale+216 @059f18>  : 03                         ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@029c40>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:2'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `vec2d`
	lib/std/math/Vector2d.ci:43: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector2d.ci:4'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `x`
	lib/std/math/Vector2d.ci:43: referenced as `x`
	lib/std/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `y`
	lib/std/math/Vector2d.ci:43: referenced as `y`
	lib/std/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@059f20>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@059f20> - <@059f27>)
	lib/std/math/Vector2d.ci:15: (7 bytes: <@059f20> - <@059f27>): return .result := {...};
	<vec2d @059f20>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Vector2d.ci:17: (3 bytes: <@059f23> - <@059f26>): .result.y := y;
	<vec2d+3 @059f23>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @059f26>    : 03                         ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/std/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/std/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'lib/std/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/std/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@059f28>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@059f28> - <@059f4e>)
	lib/std/string.ci:5: (16 bytes: <@059f28> - <@059f38>): if ((str) == null)
	<length @059f28>      : 10 01                      dup.x32 sp(1)
	<length+2 @059f2a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @059f2f>    : 57                         ceq.i32
	<length+8 @059f30>    : 06 08 00 00                jz <length+16 @059f38>
	lib/std/string.ci:6: (4 bytes: <@059f34> - <@059f38>): return .result := 0;
	<length+12 @059f34>   : 19                         load.z32
	<length+13 @059f35>   : 13 03                      set.x32 sp(3)
	<length+15 @059f37>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@059f38> - <@059f39>): result: int32 := 0
	<length+16 @059f38>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@059f39> - <@059f4b>): for ( ; str[result]; result := result + 1)
	<length+17 @059f39>   : 04 08 00 00                jmp <length+25 @059f41>
	lib/std/string.ci:9: (4 bytes: <@059f3d> - <@059f41>): result := result + 1
	<length+21 @059f3d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@059f41> - <@059f4b>): str[result]
	<length+25 @059f41>   : 10 02                      dup.x32 sp(2)
	<length+27 @059f43>   : 10 01                      dup.x32 sp(1)
	<length+29 @059f45>   : 51                         add.i32
	<length+30 @059f46>   : 26                         load.i8
	<length+31 @059f47>   : 05 f6 ff ff                jnz <length+21 @059f3d>
	lib/std/string.ci:11: (3 bytes: <@059f4b> - <@059f4e>): return .result := result;
	<length+35 @059f4b>   : 13 03                      set.x32 sp(3)
	<length+37 @059f4d>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@059f50>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@059f50> - <@059f82>)
	lib/std/string.ci:16: (42 bytes: <@059f50> - <@059f7a>): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf @059f50>      : 19                         load.z32
	<indexOf+1 @059f51>    : 04 1b 00 00                jmp <indexOf+28 @059f6c>
	lib/std/string.ci:17: (19 bytes: <@059f55> - <@059f68>): if (str[i] == chr)
	<indexOf+5 @059f55>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @059f57>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @059f59>    : 51                         add.i32
	<indexOf+10 @059f5a>   : 26                         load.i8
	<indexOf+11 @059f5b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @059f5f>   : 26                         load.i8
	<indexOf+16 @059f60>   : 57                         ceq.i32
	<indexOf+17 @059f61>   : 06 07 00 00                jz <indexOf+24 @059f68>
	lib/std/string.ci:18: (3 bytes: <@059f65> - <@059f68>): return .result := i;
	<indexOf+21 @059f65>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @059f67>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@059f68> - <@059f6c>): i := i + 1
	<indexOf+24 @059f68>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@059f6c> - <@059f76>): str[i]
	<indexOf+28 @059f6c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @059f6e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @059f70>   : 51                         add.i32
	<indexOf+33 @059f71>   : 26                         load.i8
	<indexOf+34 @059f72>   : 05 e3 ff ff                jnz <indexOf+5 @059f55>
	<indexOf+38 @059f76>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@059f7a> - <@059f82>): return .result := -1;
	<indexOf+42 @059f7a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @059f7f>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @059f81>   : 03                         ret
.usages:
	lib/std/string.ci:98: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@059f88>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@059f88> - <@059fba>)
	lib/std/string.ci:26: (5 bytes: <@059f88> - <@059f8d>): result: int32 := -1
	<lastIndexOf @059f88>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@059f8d> - <@059fb7>): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+5 @059f8d>    : 19                         load.z32
	<lastIndexOf+6 @059f8e>    : 04 1b 00 00                jmp <lastIndexOf+33 @059fa9>
	lib/std/string.ci:28: (19 bytes: <@059f92> - <@059fa5>): if (str[i] == chr)
	<lastIndexOf+10 @059f92>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @059f94>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @059f96>   : 51                         add.i32
	<lastIndexOf+15 @059f97>   : 26                         load.i8
	<lastIndexOf+16 @059f98>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @059f9c>   : 26                         load.i8
	<lastIndexOf+21 @059f9d>   : 57                         ceq.i32
	<lastIndexOf+22 @059f9e>   : 06 07 00 00                jz <lastIndexOf+29 @059fa5>
	lib/std/string.ci:29: (3 bytes: <@059fa2> - <@059fa5>): result := i;
	<lastIndexOf+26 @059fa2>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@059fa5> - <@059fa9>): i := i + 1
	<lastIndexOf+29 @059fa5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@059fa9> - <@059fb3>): str[i]
	<lastIndexOf+33 @059fa9>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @059fab>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @059fad>   : 51                         add.i32
	<lastIndexOf+38 @059fae>   : 26                         load.i8
	<lastIndexOf+39 @059faf>   : 05 e3 ff ff                jnz <lastIndexOf+10 @059f92>
	<lastIndexOf+43 @059fb3>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@059fb7> - <@059fba>): return .result := result;
	<lastIndexOf+47 @059fb7>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @059fb9>   : 03                         ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@059fc0>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@059fc0> - <@05a009>)
	lib/std/string.ci:37: (62 bytes: <@059fc0> - <@059ffe>): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith @059fc0>      : 19                         load.z32
	<startsWith+1 @059fc1>    : 04 2d 00 00                jmp <startsWith+46 @059fee>
	lib/std/string.ci:38: (37 bytes: <@059fc5> - <@059fea>): if (cmp(str[i], with[i]) != 0)
	<startsWith+5 @059fc5>    : 19                         load.z32
	<startsWith+6 @059fc6>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @059fc8>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @059fca>   : 51                         add.i32
	<startsWith+11 @059fcb>   : 26                         load.i8
	<startsWith+12 @059fcc>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @059fce>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @059fd0>   : 51                         add.i32
	<startsWith+17 @059fd1>   : 26                         load.i8
	<startsWith+18 @059fd2>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @059fd4>   : 02                         call
	<startsWith+21 @059fd5>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @059fd9>   : 19                         load.z32
	<startsWith+26 @059fda>   : 57                         ceq.i32
	<startsWith+27 @059fdb>   : 05 0f 00 00                jnz <startsWith+42 @059fea>
	lib/std/string.ci:39: (11 bytes: <@059fdf> - <@059fea>): return .result := false;
	<startsWith+31 @059fdf>   : 19                         load.z32
	<startsWith+32 @059fe0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @059fe4>   : 2b                         store.i8
	<startsWith+37 @059fe5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @059fe9>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@059fea> - <@059fee>): i := i + 1
	<startsWith+42 @059fea>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@059fee> - <@059ffa>): (with[i]) != 0
	<startsWith+46 @059fee>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @059ff0>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @059ff2>   : 51                         add.i32
	<startsWith+51 @059ff3>   : 26                         load.i8
	<startsWith+52 @059ff4>   : 19                         load.z32
	<startsWith+53 @059ff5>   : 57                         ceq.i32
	<startsWith+54 @059ff6>   : 06 cf ff ff                jz <startsWith+5 @059fc5>
	<startsWith+58 @059ffa>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@059ffe> - <@05a009>): return .result := true;
	<startsWith+62 @059ffe>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @05a003>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @05a007>   : 2b                         store.i8
	<startsWith+72 @05a008>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@05a010>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@05a010> - <@05a08e>)
	lib/std/string.ci:47: (13 bytes: <@05a010> - <@05a01d>): withLen: int32 := length(with)
	<endsWith @05a010>      : 19                         load.z32
	<endsWith+1 @05a011>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @05a013>    : 1f 28 9f 05 00             load.ref <@059f28> ;length(str: char[*]): int32
	<endsWith+8 @05a018>    : 02                         call
	<endsWith+9 @05a019>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@05a01d> - <@05a02a>): strLen: int32 := length(str)
	<endsWith+13 @05a01d>   : 19                         load.z32
	<endsWith+14 @05a01e>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @05a020>   : 1f 28 9f 05 00             load.ref <@059f28> ;length(str: char[*]): int32
	<endsWith+21 @05a025>   : 02                         call
	<endsWith+22 @05a026>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@05a02a> - <@05a03e>): if (strLen < withLen)
	<endsWith+26 @05a02a>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @05a02c>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @05a02e>   : 58                         clt.i32
	<endsWith+31 @05a02f>   : 06 0f 00 00                jz <endsWith+46 @05a03e>
	lib/std/string.ci:50: (11 bytes: <@05a033> - <@05a03e>): return .result := false;
	<endsWith+35 @05a033>   : 19                         load.z32
	<endsWith+36 @05a034>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @05a038>   : 2b                         store.i8
	<endsWith+41 @05a039>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @05a03d>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@05a03e> - <@05a07f>): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+46 @05a03e>   : 19                         load.z32
	<endsWith+47 @05a03f>   : 04 33 00 00                jmp <endsWith+98 @05a072>
	lib/std/string.ci:53: (43 bytes: <@05a043> - <@05a06e>): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+51 @05a043>   : 19                         load.z32
	<endsWith+52 @05a044>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @05a046>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @05a048>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @05a04a>   : 52                         sub.i32
	<endsWith+59 @05a04b>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @05a04d>   : 51                         add.i32
	<endsWith+62 @05a04e>   : 51                         add.i32
	<endsWith+63 @05a04f>   : 26                         load.i8
	<endsWith+64 @05a050>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @05a052>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @05a054>   : 51                         add.i32
	<endsWith+69 @05a055>   : 26                         load.i8
	<endsWith+70 @05a056>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @05a058>   : 02                         call
	<endsWith+73 @05a059>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @05a05d>   : 19                         load.z32
	<endsWith+78 @05a05e>   : 57                         ceq.i32
	<endsWith+79 @05a05f>   : 05 0f 00 00                jnz <endsWith+94 @05a06e>
	lib/std/string.ci:54: (11 bytes: <@05a063> - <@05a06e>): return .result := false;
	<endsWith+83 @05a063>   : 19                         load.z32
	<endsWith+84 @05a064>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @05a068>   : 2b                         store.i8
	<endsWith+89 @05a069>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @05a06d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@05a06e> - <@05a072>): i := i + 1
	<endsWith+94 @05a06e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@05a072> - <@05a07b>): i < withLen
	<endsWith+98 @05a072>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @05a074>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @05a076>  : 58                         clt.i32
	<endsWith+103 @05a077>  : 05 cc ff ff                jnz <endsWith+51 @05a043>
	<endsWith+107 @05a07b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@05a07f> - <@05a08e>): return .result := true;
	<endsWith+111 @05a07f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @05a084>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @05a088>  : 2b                         store.i8
	<endsWith+121 @05a089>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @05a08d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@05a090>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@05a090> - <@05a0cf>)
	lib/std/string.ci:62: (1 byte: <@05a090> - <@05a091>): result: int32 := 0
	<compare @05a090>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@05a091> - <@05a0cc>): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+1 @05a091>    : 19                         load.z32
	<compare+2 @05a092>    : 04 2e 00 00                jmp <compare+48 @05a0c0>
	lib/std/string.ci:64: (22 bytes: <@05a096> - <@05a0ac>): result := cmp(str[i], with[i]);
	<compare+6 @05a096>    : 19                         load.z32
	<compare+7 @05a097>    : 10 06                      dup.x32 sp(6)
	<compare+9 @05a099>    : 10 02                      dup.x32 sp(2)
	<compare+11 @05a09b>   : 51                         add.i32
	<compare+12 @05a09c>   : 26                         load.i8
	<compare+13 @05a09d>   : 10 06                      dup.x32 sp(6)
	<compare+15 @05a09f>   : 10 03                      dup.x32 sp(3)
	<compare+17 @05a0a1>   : 51                         add.i32
	<compare+18 @05a0a2>   : 26                         load.i8
	<compare+19 @05a0a3>   : 10 06                      dup.x32 sp(6)
	<compare+21 @05a0a5>   : 02                         call
	<compare+22 @05a0a6>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @05a0aa>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@05a0ac> - <@05a0bc>): if ((str[i]) == 0)
	<compare+28 @05a0ac>   : 10 05                      dup.x32 sp(5)
	<compare+30 @05a0ae>   : 10 01                      dup.x32 sp(1)
	<compare+32 @05a0b0>   : 51                         add.i32
	<compare+33 @05a0b1>   : 26                         load.i8
	<compare+34 @05a0b2>   : 19                         load.z32
	<compare+35 @05a0b3>   : 57                         ceq.i32
	<compare+36 @05a0b4>   : 06 08 00 00                jz <compare+44 @05a0bc>
	lib/std/string.ci:66: (4 bytes: <@05a0b8> - <@05a0bc>): break;
	<compare+40 @05a0b8>   : 04 10 00 00                jmp <compare+56 @05a0c8>
	lib/std/string.ci:63: (4 bytes: <@05a0bc> - <@05a0c0>): i := i + 1
	<compare+44 @05a0bc>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@05a0c0> - <@05a0c8>): result == 0
	<compare+48 @05a0c0>   : 10 01                      dup.x32 sp(1)
	<compare+50 @05a0c2>   : 19                         load.z32
	<compare+51 @05a0c3>   : 57                         ceq.i32
	<compare+52 @05a0c4>   : 05 d2 ff ff                jnz <compare+6 @05a096>
	<compare+56 @05a0c8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@05a0cc> - <@05a0cf>): return .result := result;
	<compare+60 @05a0cc>   : 13 05                      set.x32 sp(5)
	<compare+62 @05a0ce>   : 03                         ret
.usages:
	lib/std/string.ci:95: referenced as `compare`
	lib/std/string.ci:94: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@05a118>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@05a118> - <@05a13c>)
	lib/std/string.ci:84: (36 bytes: <@05a118> - <@05a13c>): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp @05a118>      : 19                         load.z32
	<ignCaseCmp+1 @05a119>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @05a11d>    : 26                         load.i8
	<ignCaseCmp+6 @05a11e>    : 1f d0 a0 05 00             load.ref <@05a0d0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @05a123>   : 02                         call
	<ignCaseCmp+12 @05a124>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @05a128>   : 19                         load.z32
	<ignCaseCmp+17 @05a129>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @05a12d>   : 26                         load.i8
	<ignCaseCmp+22 @05a12e>   : 1f d0 a0 05 00             load.ref <@05a0d0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @05a133>   : 02                         call
	<ignCaseCmp+28 @05a134>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @05a138>   : 52                         sub.i32
	<ignCaseCmp+33 @05a139>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @05a13b>   : 03                         ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@05a140>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@05a140> - <@05a14e>)
	lib/std/string.ci:89: (14 bytes: <@05a140> - <@05a14e>): return .result := chr - with;
	<caseCmp @05a140>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @05a144>    : 26                         load.i8
	<caseCmp+5 @05a145>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @05a149>    : 26                         load.i8
	<caseCmp+10 @05a14a>   : 52                         sub.i32
	<caseCmp+11 @05a14b>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @05a14d>   : 03                         ret
.usages:
	lib/std/string.ci:95: referenced as `caseCmp`
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'lib/std/string.ci:95'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:98'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:182: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02f2e8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:112'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:263: referenced as `FormatFlags`
	lib/std/string.ci:259: referenced as `FormatFlags`
	lib/std/string.ci:241: referenced as `FormatFlags`
	lib/std/string.ci:235: referenced as `FormatFlags`
	lib/std/string.ci:234: referenced as `FormatFlags`
	lib/std/string.ci:231: referenced as `FormatFlags`
	lib/std/string.ci:229: referenced as `FormatFlags`
	lib/std/string.ci:227: referenced as `FormatFlags`
	lib/std/string.ci:225: referenced as `FormatFlags`
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:221: referenced as `FormatFlags`
	lib/std/string.ci:219: referenced as `FormatFlags`
	lib/std/string.ci:217: referenced as `FormatFlags`
	lib/std/string.ci:144: referenced as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'lib/std/string.ci:114'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	lib/std/string.ci:242: referenced as `showSign`
	lib/std/string.ci:236: referenced as `showSign`
	lib/std/string.ci:236: referenced as `showSign`
	lib/std/string.ci:151: referenced as `showSign`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'lib/std/string.ci:117'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	lib/std/string.ci:253: referenced as `precision`
	lib/std/string.ci:243: referenced as `precision`
	lib/std/string.ci:245: referenced as `precision`
	lib/std/string.ci:237: referenced as `precision`
	lib/std/string.ci:239: referenced as `precision`
	lib/std/string.ci:157: referenced as `precision`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'lib/std/string.ci:120'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:244: referenced as `padChr`
	lib/std/string.ci:238: referenced as `padChr`
	lib/std/string.ci:238: referenced as `padChr`
	lib/std/string.ci:174: referenced as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'lib/std/string.ci:123'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:245: referenced as `padLen`
	lib/std/string.ci:239: referenced as `padLen`
	lib/std/string.ci:239: referenced as `padLen`
	lib/std/string.ci:172: referenced as `padLen`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@05a150>
.name: 'append'
.file: 'lib/std/string.ci:127'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@05a150> - <@05a1a4>)
	lib/std/string.ci:128: (56 bytes: <@05a150> - <@05a188>): for (i: int32 := 0; value[i]; i := i + 1)
	<append @05a150>      : 19                         load.z32
	<append+1 @05a151>    : 04 29 00 00                jmp <append+42 @05a17a>
	lib/std/string.ci:129: (13 bytes: <@05a155> - <@05a162>): if (pos >= (output.length))
	<append+5 @05a155>    : 10 03                      dup.x32 sp(3)
	<append+7 @05a157>    : 10 06                      dup.x32 sp(6)
	<append+9 @05a159>    : 58                         clt.i32
	<append+10 @05a15a>   : 05 08 00 00                jnz <append+18 @05a162>
	lib/std/string.ci:130: (4 bytes: <@05a15e> - <@05a162>): break;
	<append+14 @05a15e>   : 04 26 00 00                jmp <append+52 @05a184>
	lib/std/string.ci:132: (12 bytes: <@05a162> - <@05a16e>): output[pos] := value[i];
	<append+18 @05a162>   : 10 02                      dup.x32 sp(2)
	<append+20 @05a164>   : 10 01                      dup.x32 sp(1)
	<append+22 @05a166>   : 51                         add.i32
	<append+23 @05a167>   : 26                         load.i8
	<append+24 @05a168>   : 10 05                      dup.x32 sp(5)
	<append+26 @05a16a>   : 10 05                      dup.x32 sp(5)
	<append+28 @05a16c>   : 51                         add.i32
	<append+29 @05a16d>   : 2b                         store.i8
	lib/std/string.ci:133: (8 bytes: <@05a16e> - <@05a176>): pos := pos + 1;
	<append+30 @05a16e>   : 10 03                      dup.x32 sp(3)
	<append+32 @05a170>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @05a174>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:128: (4 bytes: <@05a176> - <@05a17a>): i := i + 1
	<append+38 @05a176>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:128: (10 bytes: <@05a17a> - <@05a184>): value[i]
	<append+42 @05a17a>   : 10 02                      dup.x32 sp(2)
	<append+44 @05a17c>   : 10 01                      dup.x32 sp(1)
	<append+46 @05a17e>   : 51                         add.i32
	<append+47 @05a17f>   : 26                         load.i8
	<append+48 @05a180>   : 05 d5 ff ff                jnz <append+5 @05a155>
	<append+52 @05a184>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:136: (17 bytes: <@05a188> - <@05a199>): if (pos >= (output.length))
	<append+56 @05a188>   : 10 02                      dup.x32 sp(2)
	<append+58 @05a18a>   : 10 05                      dup.x32 sp(5)
	<append+60 @05a18c>   : 58                         clt.i32
	<append+61 @05a18d>   : 05 0c 00 00                jnz <append+73 @05a199>
	lib/std/string.ci:137: (8 bytes: <@05a191> - <@05a199>): pos := (output.length - (1));
	<append+65 @05a191>   : 10 04                      dup.x32 sp(4)
	<append+67 @05a193>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @05a197>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:139: (7 bytes: <@05a199> - <@05a1a0>): output[pos] := (0);
	<append+73 @05a199>   : 19                         load.z32
	<append+74 @05a19a>   : 10 04                      dup.x32 sp(4)
	<append+76 @05a19c>   : 10 04                      dup.x32 sp(4)
	<append+78 @05a19e>   : 51                         add.i32
	<append+79 @05a19f>   : 2b                         store.i8
	lib/std/string.ci:140: (4 bytes: <@05a1a0> - <@05a1a4>): return .result := pos;
	<append+80 @05a1a0>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @05a1a3>   : 03                         ret
.usages:
	lib/std/string.ci:252: referenced as `append`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 707
.offset: <@05a1b8>
.name: 'append'
.file: 'lib/std/string.ci:144'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <@05a1b8> - <@05a47b>)
	lib/std/string.ci:148: (1 byte: <@05a1b8> - <@05a1b9>): len: int32 := 0
	<append @05a1b8>      : 19                         load.z32
	lib/std/string.ci:149: (4 bytes: <@05a1b9> - <@05a1bd>): digits: char[80] := {...}
	<append+1 @05a1b9>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:151: (28 bytes: <@05a1bd> - <@05a1d9>): if (format.showSign)
	<append+5 @05a1bd>    : 10 16                      dup.x32 sp(22)
	<append+7 @05a1bf>    : 26                         load.i8
	<append+8 @05a1c0>    : 06 19 00 00                jz <append+33 @05a1d9>
	lib/std/string.ci:152: (21 bytes: <@05a1c4> - <@05a1d9>): if ((sign) == 0)
	<append+12 @05a1c4>   : 0a 64 00 00                load.sp(+100)
	<append+16 @05a1c8>   : 26                         load.i8
	<append+17 @05a1c9>   : 19                         load.z32
	<append+18 @05a1ca>   : 57                         ceq.i32
	<append+19 @05a1cb>   : 06 0e 00 00                jz <append+33 @05a1d9>
	lib/std/string.ci:153: (10 bytes: <@05a1cf> - <@05a1d9>): sign := '+';
	<append+23 @05a1cf>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @05a1d4>   : 0a 68 00 00                load.sp(+104)
	<append+32 @05a1d8>   : 2b                         store.i8
	lib/std/string.ci:157: (7 bytes: <@05a1d9> - <@05a1e0>): radix: int32 := format.precision
	<append+33 @05a1d9>   : 10 16                      dup.x32 sp(22)
	<append+35 @05a1db>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @05a1df>   : 28                         load.i32
	lib/std/string.ci:158: (15 bytes: <@05a1e0> - <@05a1ef>): if (radix == 0)
	<append+40 @05a1e0>   : 10 00                      dup.x32 sp(0)
	<append+42 @05a1e2>   : 19                         load.z32
	<append+43 @05a1e3>   : 57                         ceq.i32
	<append+44 @05a1e4>   : 06 0b 00 00                jz <append+55 @05a1ef>
	lib/std/string.ci:159: (7 bytes: <@05a1e8> - <@05a1ef>): radix := 10;
	<append+48 @05a1e8>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @05a1ed>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:161: (54 bytes: <@05a1ef> - <@05a225>): assert(radix > 1, "radix is too small", radix);
	<append+55 @05a1ef>   : 10 00                      dup.x32 sp(0)
	<append+57 @05a1f1>   : 1c 01 00 00 00             load.c32 1
	<append+62 @05a1f6>   : 59                         cgt.i32
	<append+63 @05a1f7>   : 06 08 00 00                jz <append+71 @05a1ff>
	<append+67 @05a1fb>   : 04 2a 00 00                jmp <append+109 @05a225>
	<append+71 @05a1ff>   : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+76 @05a204>   : 1c a1 00 00 00             load.c32 161
	<append+81 @05a209>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @05a20e>   : 1c 80 00 00 00             load.c32 128
	<append+91 @05a213>   : 1f 97 ba 02 00             load.ref <@02ba97> ;"radix is too small"
	<append+96 @05a218>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+101 @05a21d>  : 0a 18 00 00                load.sp(+24)
	<append+105 @05a221>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (53 bytes: <@05a225> - <@05a25a>): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+109 @05a225>  : 10 00                      dup.x32 sp(0)
	<append+111 @05a227>  : 20 b4 a1 05                load.m32 <@05a1b4> ;append.radixDigits+4
	<append+115 @05a22b>  : 58                         clt.i32
	<append+116 @05a22c>  : 06 08 00 00                jz <append+124 @05a234>
	<append+120 @05a230>  : 04 2a 00 00                jmp <append+162 @05a25a>
	<append+124 @05a234>  : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+129 @05a239>  : 1c a2 00 00 00             load.c32 162
	<append+134 @05a23e>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @05a243>  : 1c 80 00 00 00             load.c32 128
	<append+144 @05a248>  : 1f aa ba 02 00             load.ref <@02baaa> ;"radix is too big"
	<append+149 @05a24d>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+154 @05a252>  : 0a 18 00 00                load.sp(+24)
	<append+158 @05a256>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:165: (49 bytes: <@05a25a> - <@05a28b>): for ( ; value > (0); value := value / (radix))
	<append+162 @05a25a>  : 04 29 00 00                jmp <append+203 @05a283>
	lib/std/string.ci:166: (29 bytes: <@05a25e> - <@05a27b>): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+166 @05a25e>  : 20 b0 a1 05                load.m32 <@05a1b0> ;append.radixDigits
	<append+170 @05a262>  : 11 19                      dup.x64 sp(25)
	<append+172 @05a264>  : 10 03                      dup.x32 sp(3)
	<append+174 @05a266>  : 5b                         i32.2i64
	<append+175 @05a267>  : 45                         mod.u64
	<append+176 @05a268>  : 6a                         i64.2i32
	<append+177 @05a269>  : 51                         add.i32
	<append+178 @05a26a>  : 26                         load.i8
	<append+179 @05a26b>  : 0a 08 00 00                load.sp(+8)
	<append+183 @05a26f>  : 10 17                      dup.x32 sp(23)
	<append+185 @05a271>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @05a275>  : 10 00                      dup.x32 sp(0)
	<append+191 @05a277>  : 13 19                      set.x32 sp(25)
	<append+193 @05a279>  : 51                         add.i32
	<append+194 @05a27a>  : 2b                         store.i8
	lib/std/string.ci:165: (8 bytes: <@05a27b> - <@05a283>): value := value / (radix)
	<append+195 @05a27b>  : 11 18                      dup.x64 sp(24)
	<append+197 @05a27d>  : 10 02                      dup.x32 sp(2)
	<append+199 @05a27f>  : 5b                         i32.2i64
	<append+200 @05a280>  : 44                         div.u64
	<append+201 @05a281>  : 14 1a                      set.x64 sp(26)
	lib/std/string.ci:165: (8 bytes: <@05a283> - <@05a28b>): value > (0)
	<append+203 @05a283>  : 11 18                      dup.x64 sp(24)
	<append+205 @05a285>  : 1a                         load.z64
	<append+206 @05a286>  : 49                         cgt.u64
	<append+207 @05a287>  : 05 d7 ff ff                jnz <append+166 @05a25e>
	lib/std/string.ci:168: (29 bytes: <@05a28b> - <@05a2a8>): if (len == 0)
	<append+211 @05a28b>  : 10 15                      dup.x32 sp(21)
	<append+213 @05a28d>  : 19                         load.z32
	<append+214 @05a28e>  : 57                         ceq.i32
	<append+215 @05a28f>  : 06 19 00 00                jz <append+240 @05a2a8>
	lib/std/string.ci:169: (21 bytes: <@05a293> - <@05a2a8>): digits[len := len + 1] := '0';
	<append+219 @05a293>  : 1c 30 00 00 00             load.c32 48
	<append+224 @05a298>  : 0a 08 00 00                load.sp(+8)
	<append+228 @05a29c>  : 10 17                      dup.x32 sp(23)
	<append+230 @05a29e>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @05a2a2>  : 10 00                      dup.x32 sp(0)
	<append+236 @05a2a4>  : 13 19                      set.x32 sp(25)
	<append+238 @05a2a6>  : 51                         add.i32
	<append+239 @05a2a7>  : 2b                         store.i8
	lib/std/string.ci:172: (10 bytes: <@05a2a8> - <@05a2b2>): maxLen: int32 := format.padLen - len
	<append+240 @05a2a8>  : 10 17                      dup.x32 sp(23)
	<append+242 @05a2aa>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @05a2ae>  : 28                         load.i32
	<append+247 @05a2af>  : 10 16                      dup.x32 sp(22)
	<append+249 @05a2b1>  : 52                         sub.i32
	lib/std/string.ci:174: (7 bytes: <@05a2b2> - <@05a2b9>): padChr: char := format.padChr
	<append+250 @05a2b2>  : 10 18                      dup.x32 sp(24)
	<append+252 @05a2b4>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @05a2b8>  : 26                         load.i8
	lib/std/string.ci:175: (21 bytes: <@05a2b9> - <@05a2ce>): if (padChr == '')
	<append+257 @05a2b9>  : 0a 00 00 00                load.sp(+0)
	<append+261 @05a2bd>  : 26                         load.i8
	<append+262 @05a2be>  : 19                         load.z32
	<append+263 @05a2bf>  : 57                         ceq.i32
	<append+264 @05a2c0>  : 06 0e 00 00                jz <append+278 @05a2ce>
	lib/std/string.ci:176: (10 bytes: <@05a2c4> - <@05a2ce>): padChr := ' ';
	<append+268 @05a2c4>  : 1c 20 00 00 00             load.c32 32
	<append+273 @05a2c9>  : 0a 04 00 00                load.sp(+4)
	<append+277 @05a2cd>  : 2b                         store.i8
	lib/std/string.ci:180: (207 bytes: <@05a2ce> - <@05a39d>): if ((sign) != 0)
	<append+278 @05a2ce>  : 0a 70 00 00                load.sp(+112)
	<append+282 @05a2d2>  : 26                         load.i8
	<append+283 @05a2d3>  : 19                         load.z32
	<append+284 @05a2d4>  : 57                         ceq.i32
	<append+285 @05a2d5>  : 05 c8 00 00                jnz <append+485 @05a39d>
	lib/std/string.ci:181: (8 bytes: <@05a2d9> - <@05a2e1>): maxLen := maxLen - 1;
	<append+289 @05a2d9>  : 10 01                      dup.x32 sp(1)
	<append+291 @05a2db>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @05a2df>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:182: (117 bytes: <@05a2e1> - <@05a356>): if (contains(whiteSpace, padChr))
	<append+297 @05a2e1>  : 19                         load.z32
	<append+298 @05a2e2>  : 20 a8 a1 05                load.m32 <@05a1a8> ;append.whiteSpace
	<append+302 @05a2e6>  : 0a 08 00 00                load.sp(+8)
	<append+306 @05a2ea>  : 26                         load.i8
	<append+307 @05a2eb>  : 1f 50 9f 05 00             load.ref <@059f50> ;indexOf(str: char[*], chr: char): int32
	<append+312 @05a2f0>  : 02                         call
	<append+313 @05a2f1>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @05a2f5>  : 19                         load.z32
	<append+318 @05a2f6>  : 58                         clt.i32
	<append+319 @05a2f7>  : 05 5f 00 00                jnz <append+414 @05a356>
	lib/std/string.ci:184: (91 bytes: <@05a2fb> - <@05a356>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+323 @05a2fb>  : 04 53 00 00                jmp <append+406 @05a34e>
	lib/std/string.ci:185: (52 bytes: <@05a2ff> - <@05a333>): assert(pos < (output.length));
	<append+327 @05a2ff>  : 10 1d                      dup.x32 sp(29)
	<append+329 @05a301>  : 10 20                      dup.x32 sp(32)
	<append+331 @05a303>  : 58                         clt.i32
	<append+332 @05a304>  : 06 08 00 00                jz <append+340 @05a30c>
	<append+336 @05a308>  : 04 2b 00 00                jmp <append+379 @05a333>
	<append+340 @05a30c>  : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+345 @05a311>  : 1c b9 00 00 00             load.c32 185
	<append+350 @05a316>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @05a31b>  : 1c 80 00 00 00             load.c32 128
	<append+360 @05a320>  : 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<append+365 @05a325>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+370 @05a32a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @05a32f>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:186: (11 bytes: <@05a333> - <@05a33e>): output[pos] := padChr;
	<append+379 @05a333>  : 0a 00 00 00                load.sp(+0)
	<append+383 @05a337>  : 26                         load.i8
	<append+384 @05a338>  : 10 1f                      dup.x32 sp(31)
	<append+386 @05a33a>  : 10 1f                      dup.x32 sp(31)
	<append+388 @05a33c>  : 51                         add.i32
	<append+389 @05a33d>  : 2b                         store.i8
	lib/std/string.ci:187: (8 bytes: <@05a33e> - <@05a346>): pos := pos + 1;
	<append+390 @05a33e>  : 10 1d                      dup.x32 sp(29)
	<append+392 @05a340>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @05a344>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:184: (8 bytes: <@05a346> - <@05a34e>): maxLen := maxLen - 1
	<append+398 @05a346>  : 10 01                      dup.x32 sp(1)
	<append+400 @05a348>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @05a34c>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:184: (8 bytes: <@05a34e> - <@05a356>): maxLen > 0
	<append+406 @05a34e>  : 10 01                      dup.x32 sp(1)
	<append+408 @05a350>  : 19                         load.z32
	<append+409 @05a351>  : 59                         cgt.i32
	<append+410 @05a352>  : 05 ad ff ff                jnz <append+327 @05a2ff>
	lib/std/string.ci:190: (52 bytes: <@05a356> - <@05a38a>): assert(pos < (output.length));
	<append+414 @05a356>  : 10 1d                      dup.x32 sp(29)
	<append+416 @05a358>  : 10 20                      dup.x32 sp(32)
	<append+418 @05a35a>  : 58                         clt.i32
	<append+419 @05a35b>  : 06 08 00 00                jz <append+427 @05a363>
	<append+423 @05a35f>  : 04 2b 00 00                jmp <append+466 @05a38a>
	<append+427 @05a363>  : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+432 @05a368>  : 1c be 00 00 00             load.c32 190
	<append+437 @05a36d>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @05a372>  : 1c 80 00 00 00             load.c32 128
	<append+447 @05a377>  : 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<append+452 @05a37c>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+457 @05a381>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @05a386>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:191: (11 bytes: <@05a38a> - <@05a395>): output[pos] := sign;
	<append+466 @05a38a>  : 0a 70 00 00                load.sp(+112)
	<append+470 @05a38e>  : 26                         load.i8
	<append+471 @05a38f>  : 10 1f                      dup.x32 sp(31)
	<append+473 @05a391>  : 10 1f                      dup.x32 sp(31)
	<append+475 @05a393>  : 51                         add.i32
	<append+476 @05a394>  : 2b                         store.i8
	lib/std/string.ci:192: (8 bytes: <@05a395> - <@05a39d>): pos := pos + 1;
	<append+477 @05a395>  : 10 1d                      dup.x32 sp(29)
	<append+479 @05a397>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @05a39b>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:196: (91 bytes: <@05a39d> - <@05a3f8>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+485 @05a39d>  : 04 53 00 00                jmp <append+568 @05a3f0>
	lib/std/string.ci:197: (52 bytes: <@05a3a1> - <@05a3d5>): assert(pos < (output.length));
	<append+489 @05a3a1>  : 10 1d                      dup.x32 sp(29)
	<append+491 @05a3a3>  : 10 20                      dup.x32 sp(32)
	<append+493 @05a3a5>  : 58                         clt.i32
	<append+494 @05a3a6>  : 06 08 00 00                jz <append+502 @05a3ae>
	<append+498 @05a3aa>  : 04 2b 00 00                jmp <append+541 @05a3d5>
	<append+502 @05a3ae>  : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+507 @05a3b3>  : 1c c5 00 00 00             load.c32 197
	<append+512 @05a3b8>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @05a3bd>  : 1c 80 00 00 00             load.c32 128
	<append+522 @05a3c2>  : 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<append+527 @05a3c7>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+532 @05a3cc>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @05a3d1>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:198: (11 bytes: <@05a3d5> - <@05a3e0>): output[pos] := padChr;
	<append+541 @05a3d5>  : 0a 00 00 00                load.sp(+0)
	<append+545 @05a3d9>  : 26                         load.i8
	<append+546 @05a3da>  : 10 1f                      dup.x32 sp(31)
	<append+548 @05a3dc>  : 10 1f                      dup.x32 sp(31)
	<append+550 @05a3de>  : 51                         add.i32
	<append+551 @05a3df>  : 2b                         store.i8
	lib/std/string.ci:199: (8 bytes: <@05a3e0> - <@05a3e8>): pos := pos + 1;
	<append+552 @05a3e0>  : 10 1d                      dup.x32 sp(29)
	<append+554 @05a3e2>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @05a3e6>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:196: (8 bytes: <@05a3e8> - <@05a3f0>): maxLen := maxLen - 1
	<append+560 @05a3e8>  : 10 01                      dup.x32 sp(1)
	<append+562 @05a3ea>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @05a3ee>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:196: (8 bytes: <@05a3f0> - <@05a3f8>): maxLen > 0
	<append+568 @05a3f0>  : 10 01                      dup.x32 sp(1)
	<append+570 @05a3f2>  : 19                         load.z32
	<append+571 @05a3f3>  : 59                         cgt.i32
	<append+572 @05a3f4>  : 05 ad ff ff                jnz <append+489 @05a3a1>
	lib/std/string.ci:203: (99 bytes: <@05a3f8> - <@05a45b>): for (i: int32 := 0; i < len; i := i + 1)
	<append+576 @05a3f8>  : 19                         load.z32
	<append+577 @05a3f9>  : 04 55 00 00                jmp <append+662 @05a44e>
	lib/std/string.ci:204: (52 bytes: <@05a3fd> - <@05a431>): assert(i < (output.length));
	<append+581 @05a3fd>  : 10 00                      dup.x32 sp(0)
	<append+583 @05a3ff>  : 10 21                      dup.x32 sp(33)
	<append+585 @05a401>  : 58                         clt.i32
	<append+586 @05a402>  : 06 08 00 00                jz <append+594 @05a40a>
	<append+590 @05a406>  : 04 2b 00 00                jmp <append+633 @05a431>
	<append+594 @05a40a>  : 1f f8 b6 02 00             load.ref <@02b6f8> ;"lib/std/string.ci"
	<append+599 @05a40f>  : 1c cc 00 00 00             load.c32 204
	<append+604 @05a414>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @05a419>  : 1c 80 00 00 00             load.c32 128
	<append+614 @05a41e>  : 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<append+619 @05a423>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+624 @05a428>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @05a42d>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:205: (17 bytes: <@05a431> - <@05a442>): output[pos] := digits[len - i];
	<append+633 @05a431>  : 0a 10 00 00                load.sp(+16)
	<append+637 @05a435>  : 10 19                      dup.x32 sp(25)
	<append+639 @05a437>  : 10 02                      dup.x32 sp(2)
	<append+641 @05a439>  : 52                         sub.i32
	<append+642 @05a43a>  : 51                         add.i32
	<append+643 @05a43b>  : 26                         load.i8
	<append+644 @05a43c>  : 10 20                      dup.x32 sp(32)
	<append+646 @05a43e>  : 10 20                      dup.x32 sp(32)
	<append+648 @05a440>  : 51                         add.i32
	<append+649 @05a441>  : 2b                         store.i8
	lib/std/string.ci:206: (8 bytes: <@05a442> - <@05a44a>): pos := pos + 1;
	<append+650 @05a442>  : 10 1e                      dup.x32 sp(30)
	<append+652 @05a444>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @05a448>  : 13 1f                      set.x32 sp(31)
	lib/std/string.ci:203: (4 bytes: <@05a44a> - <@05a44e>): i := i + 1
	<append+658 @05a44a>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:203: (9 bytes: <@05a44e> - <@05a457>): i < len
	<append+662 @05a44e>  : 10 00                      dup.x32 sp(0)
	<append+664 @05a450>  : 10 19                      dup.x32 sp(25)
	<append+666 @05a452>  : 58                         clt.i32
	<append+667 @05a453>  : 05 aa ff ff                jnz <append+581 @05a3fd>
	<append+671 @05a457>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:209: (17 bytes: <@05a45b> - <@05a46c>): if (pos >= (output.length))
	<append+675 @05a45b>  : 10 1d                      dup.x32 sp(29)
	<append+677 @05a45d>  : 10 20                      dup.x32 sp(32)
	<append+679 @05a45f>  : 58                         clt.i32
	<append+680 @05a460>  : 05 0c 00 00                jnz <append+692 @05a46c>
	lib/std/string.ci:210: (8 bytes: <@05a464> - <@05a46c>): pos := (output.length - (1));
	<append+684 @05a464>  : 10 1f                      dup.x32 sp(31)
	<append+686 @05a466>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @05a46a>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:212: (7 bytes: <@05a46c> - <@05a473>): output[pos] := (0);
	<append+692 @05a46c>  : 19                         load.z32
	<append+693 @05a46d>  : 10 1f                      dup.x32 sp(31)
	<append+695 @05a46f>  : 10 1f                      dup.x32 sp(31)
	<append+697 @05a471>  : 51                         add.i32
	<append+698 @05a472>  : 2b                         store.i8
	lib/std/string.ci:213: (8 bytes: <@05a473> - <@05a47b>): return .result := pos;
	<append+699 @05a473>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @05a476>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @05a47a>  : 03                         ret
.usages:
	lib/std/string.ci:254: referenced as `append`
	lib/std/string.ci:250: referenced as `append`
	lib/std/string.ci:231: referenced as `append`
	lib/std/string.ci:229: referenced as `append`
	lib/std/string.ci:227: referenced as `append`
	lib/std/string.ci:225: referenced as `append`
	lib/std/string.ci:223: referenced as `append`
	lib/std/string.ci:221: referenced as `append`
	lib/std/string.ci:219: referenced as `append`
	lib/std/string.ci:217: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:217'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:219'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:221'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:225'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:227'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	lib/std/string.ci:264: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:229'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:231'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 227
.offset: <@05a480>
.name: 'append'
.file: 'lib/std/string.ci:234'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
	return int32(.result := pos);
}
.instructions: (227 bytes: <@05a480> - <@05a563>)
	lib/std/string.ci:235: (44 bytes: <@05a480> - <@05a4ac>): formatInt: FormatFlags := {...}
	<append @05a480>      : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:236: (8 bytes: <@05a484> - <@05a48c>): formatInt.showSign := format.showSign;
	<append+4 @05a484>    : 10 05                      dup.x32 sp(5)
	<append+6 @05a486>    : 26                         load.i8
	<append+7 @05a487>    : 0a 04 00 00                load.sp(+4)
	<append+11 @05a48b>   : 2b                         store.i8
	lib/std/string.ci:237: (3 bytes: <@05a48c> - <@05a48f>): formatInt.precision := 0;
	<append+12 @05a48c>   : 19                         load.z32
	<append+13 @05a48d>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:238: (12 bytes: <@05a48f> - <@05a49b>): formatInt.padChr := format.padChr;
	<append+15 @05a48f>   : 10 05                      dup.x32 sp(5)
	<append+17 @05a491>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @05a495>   : 26                         load.i8
	<append+22 @05a496>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @05a49a>   : 2b                         store.i8
	lib/std/string.ci:239: (17 bytes: <@05a49b> - <@05a4ac>): formatInt.padLen := format.padLen - format.precision;
	<append+27 @05a49b>   : 10 05                      dup.x32 sp(5)
	<append+29 @05a49d>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @05a4a1>   : 28                         load.i32
	<append+34 @05a4a2>   : 10 06                      dup.x32 sp(6)
	<append+36 @05a4a4>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @05a4a8>   : 28                         load.i32
	<append+41 @05a4a9>   : 52                         sub.i32
	<append+42 @05a4aa>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:241: (32 bytes: <@05a4ac> - <@05a4cc>): formatDec: FormatFlags := {...}
	<append+44 @05a4ac>   : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:242: (6 bytes: <@05a4b0> - <@05a4b6>): formatDec.showSign := false;
	<append+48 @05a4b0>   : 19                         load.z32
	<append+49 @05a4b1>   : 0a 04 00 00                load.sp(+4)
	<append+53 @05a4b5>   : 2b                         store.i8
	lib/std/string.ci:243: (3 bytes: <@05a4b6> - <@05a4b9>): formatDec.precision := 0;
	<append+54 @05a4b6>   : 19                         load.z32
	<append+55 @05a4b7>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:244: (10 bytes: <@05a4b9> - <@05a4c3>): formatDec.padChr := '0';
	<append+57 @05a4b9>   : 1c 30 00 00 00             load.c32 48
	<append+62 @05a4be>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @05a4c2>   : 2b                         store.i8
	lib/std/string.ci:245: (9 bytes: <@05a4c3> - <@05a4cc>): formatDec.padLen := format.precision;
	<append+67 @05a4c3>   : 10 09                      dup.x32 sp(9)
	<append+69 @05a4c5>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @05a4c9>   : 28                         load.i32
	<append+74 @05a4ca>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:248: (18 bytes: <@05a4cc> - <@05a4de>): sign: char := value < (0) ? ('-') : 0
	<append+76 @05a4cc>   : 11 0a                      dup.x64 sp(10)
	<append+78 @05a4ce>   : 1a                         load.z64
	<append+79 @05a4cf>   : 88                         clt.f64
	<append+80 @05a4d0>   : 06 0d 00 00                jz <append+93 @05a4dd>
	<append+84 @05a4d4>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @05a4d9>   : 04 05 00 00                jmp <append+94 @05a4de>
	<append+93 @05a4dd>   : 19                         load.z32
	lib/std/string.ci:249: (27 bytes: <@05a4de> - <@05a4f9>): fract: float64 := Math.modf(Math.abs(value), &value)
	<append+94 @05a4de>   : 1b                         load.z128
	<append+95 @05a4df>   : 11 0f                      dup.x64 sp(15)
	<append+97 @05a4e1>   : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<append+102 @05a4e6>  : 02                         call
	<append+103 @05a4e7>  : 09 f8 ff ff                inc.sp(-8)
	<append+107 @05a4eb>  : 0a 3c 00 00                load.sp(+60)
	<append+111 @05a4ef>  : 1f b0 91 05 00             load.ref <@0591b0> ;Math.modf(x: float64, intPart: float64): float64
	<append+116 @05a4f4>  : 02                         call
	<append+117 @05a4f5>  : 09 f4 ff ff                inc.sp(-12)
	lib/std/string.ci:250: (29 bytes: <@05a4f9> - <@05a516>): pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	<append+121 @05a4f9>  : 19                         load.z32
	<append+122 @05a4fa>  : 11 11                      dup.x64 sp(17)
	<append+124 @05a4fc>  : 10 12                      dup.x32 sp(18)
	<append+126 @05a4fe>  : 0a 18 00 00                load.sp(+24)
	<append+130 @05a502>  : 26                         load.i8
	<append+131 @05a503>  : 11 12                      dup.x64 sp(18)
	<append+133 @05a505>  : 8b                         f64.2i64
	<append+134 @05a506>  : 0a 38 00 00                load.sp(+56)
	<append+138 @05a50a>  : 1f b8 a1 05 00             load.ref <@05a1b8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+143 @05a50f>  : 02                         call
	<append+144 @05a510>  : 09 e4 ff ff                inc.sp(-28)
	<append+148 @05a514>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:252: (22 bytes: <@05a516> - <@05a52c>): pos := append(output, pos, ".");
	<append+150 @05a516>  : 19                         load.z32
	<append+151 @05a517>  : 11 11                      dup.x64 sp(17)
	<append+153 @05a519>  : 10 12                      dup.x32 sp(18)
	<append+155 @05a51b>  : 1f 10 bb 02 00             load.ref <@02bb10> ;"."
	<append+160 @05a520>  : 1f 50 a1 05 00             load.ref <@05a150> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+165 @05a525>  : 02                         call
	<append+166 @05a526>  : 09 f0 ff ff                inc.sp(-16)
	<append+170 @05a52a>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:253: (22 bytes: <@05a52c> - <@05a542>): fract := fract * float64.pow(10, format.precision);
	<append+172 @05a52c>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+181 @05a535>  : 10 0e                      dup.x32 sp(14)
	<append+183 @05a537>  : 0c 04 00 00                inc.i32(+4)
	<append+187 @05a53b>  : 28                         load.i32
	<append+188 @05a53c>  : 5d                         i32.2f64
	<append+189 @05a53d>  : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<append+193 @05a541>  : 83                         mul.f64
	lib/std/string.ci:254: (25 bytes: <@05a542> - <@05a55b>): pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	<append+194 @05a542>  : 19                         load.z32
	<append+195 @05a543>  : 11 11                      dup.x64 sp(17)
	<append+197 @05a545>  : 10 12                      dup.x32 sp(18)
	<append+199 @05a547>  : 19                         load.z32
	<append+200 @05a548>  : 11 05                      dup.x64 sp(5)
	<append+202 @05a54a>  : 8b                         f64.2i64
	<append+203 @05a54b>  : 0a 28 00 00                load.sp(+40)
	<append+207 @05a54f>  : 1f b8 a1 05 00             load.ref <@05a1b8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+212 @05a554>  : 02                         call
	<append+213 @05a555>  : 09 e4 ff ff                inc.sp(-28)
	<append+217 @05a559>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:255: (8 bytes: <@05a55b> - <@05a563>): return .result := pos;
	<append+219 @05a55b>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+222 @05a55e>  : 09 d4 ff ff                inc.sp(-44)
	<append+226 @05a562>  : 03                         ret
.usages:
	lib/std/string.ci:259: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:259'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@05a578>
.name: 'append'
.file: 'lib/std/string.ci:262'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <@05a578> - <@05a5b7>)
	lib/std/string.ci:264: (63 bytes: <@05a578> - <@05a5b7>): return .result := append(output, pos, value, format);
	<append @05a578>      : 10 01                      dup.x32 sp(1)
	<append+2 @05a57a>    : 19                         load.z32
	<append+3 @05a57b>    : 11 05                      dup.x64 sp(5)
	<append+5 @05a57d>    : 10 06                      dup.x32 sp(6)
	<append+7 @05a57f>    : 10 04                      dup.x32 sp(4)
	<append+9 @05a581>    : 19                         load.z32
	<append+10 @05a582>   : 58                         clt.i32
	<append+11 @05a583>   : 06 0d 00 00                jz <append+24 @05a590>
	<append+15 @05a587>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @05a58c>   : 04 05 00 00                jmp <append+25 @05a591>
	<append+24 @05a590>   : 19                         load.z32
	<append+25 @05a591>   : 10 05                      dup.x32 sp(5)
	<append+27 @05a593>   : 19                         load.z32
	<append+28 @05a594>   : 58                         clt.i32
	<append+29 @05a595>   : 06 0b 00 00                jz <append+40 @05a5a0>
	<append+33 @05a599>   : 10 05                      dup.x32 sp(5)
	<append+35 @05a59b>   : 50                         neg.i32
	<append+36 @05a59c>   : 04 06 00 00                jmp <append+42 @05a5a2>
	<append+40 @05a5a0>   : 10 05                      dup.x32 sp(5)
	<append+42 @05a5a2>   : 5b                         i32.2i64
	<append+43 @05a5a3>   : 1f 68 a5 05 00             load.ref <@05a568> ;append.format
	<append+48 @05a5a8>   : 1f b8 a1 05 00             load.ref <@05a1b8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @05a5ad>   : 02                         call
	<append+54 @05a5ae>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @05a5b2>   : 13 01                      set.x32 sp(1)
	<append+60 @05a5b4>   : 13 06                      set.x32 sp(6)
	<append+62 @05a5b6>   : 03                         ret
.usages:
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5b8>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05a5c0>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5c8>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5d0>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5d8>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5e0>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
}
emitNfcF32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a5e8>
.name: 'emitNfcF32'
.file: 'test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin))
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:24: referenced as `floatAsInt32`
	test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:21'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:26: referenced as `floatAsInt64`
	test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a5f0>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05a5f8>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a600>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05a608>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@05a610>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:29'
.value: emit(void(int32(3), pointer("string")))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a618>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a620>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a628>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a630>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a638>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a640>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a648>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a650>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a658>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a660>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a668>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a670>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a678>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a680>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a688>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a690>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a698>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6a0>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6a8>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6b0>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6b8>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6c0>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6c8>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6d0>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6d8>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6e0>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6e8>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6f0>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a6f8>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a700>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a708>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a710>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a718>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a720>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a728>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a730>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a738>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a740>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a748>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a750>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a758>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a760>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a768>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a770>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a778>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a780>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a788>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a790>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a798>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a7a0>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a7a8>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0398a8>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0399d8>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@05a7b0>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@05a7b8>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a7c0>
.name: 'pi64'
.file: 'test/std/number.ci:3'
.value: 3.141593
.usages:
	test/std/number.ci:44: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:39: referenced as `pi64`
	test/std/number.ci:38: referenced as `pi64`
	test/std/number.ci:37: referenced as `pi64`
	test/std/number.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a7c8>
.name: 'e64'
.file: 'test/std/number.ci:4'
.value: 2.718282
.usages:
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a7d0>
.name: 'pi32'
.file: 'test/std/number.ci:6'
.value: pi64
.usages:
	test/std/number.ci:53: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:48: referenced as `pi32`
	test/std/number.ci:47: referenced as `pi32`
	test/std/number.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a7d8>
.name: 'e32'
.file: 'test/std/number.ci:7'
.value: e64
.usages:
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/std/number.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/std/number.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a7e0>
.name: 'r_comp'
.file: 'test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/std/number.ci:19: referenced as `r_comp`
	test/std/number.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a7e8>
.name: 'g_comp'
.file: 'test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/std/number.ci:19: referenced as `g_comp`
	test/std/number.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a7f0>
.name: 'b_comp'
.file: 'test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/std/number.ci:19: referenced as `b_comp`
	test/std/number.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a7f8>
.name: 'r5g6b5'
.file: 'test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:66: referenced as `r5g6b5`
	test/std/number.ci:65: referenced as `r5g6b5`
	test/std/number.ci:63: referenced as `r5g6b5`
	test/std/number.ci:62: referenced as `r5g6b5`
	test/std/number.ci:60: referenced as `r5g6b5`
	test/std/number.ci:59: referenced as `r5g6b5`
	test/std/number.ci:58: referenced as `r5g6b5`
	test/std/number.ci:57: referenced as `r5g6b5`
	test/std/number.ci:56: referenced as `r5g6b5`
	test/std/number.ci:55: referenced as `r5g6b5`
	test/std/number.ci:27: referenced as `r5g6b5`
	test/std/number.ci:26: referenced as `r5g6b5`
	test/std/number.ci:25: referenced as `r5g6b5`
	test/std/number.ci:23: referenced as `r5g6b5`
	test/std/number.ci:22: referenced as `r5g6b5`
	test/std/number.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a800>
.name: 'r8g8b8'
.file: 'test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:35: referenced as `r8g8b8`
	test/std/number.ci:34: referenced as `r8g8b8`
	test/std/number.ci:33: referenced as `r8g8b8`
	test/std/number.ci:31: referenced as `r8g8b8`
	test/std/number.ci:30: referenced as `r8g8b8`
	test/std/number.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a808>
.name: 'zxtR5'
.file: 'test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a810>
.name: 'zxtG6'
.file: 'test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a818>
.name: 'zxtB5'
.file: 'test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a820>
.name: 'sxtR5'
.file: 'test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a828>
.name: 'sxtG6'
.file: 'test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a830>
.name: 'sxtB5'
.file: 'test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a838>
.name: 'zxtR8'
.file: 'test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a840>
.name: 'zxtG8'
.file: 'test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a848>
.name: 'zxtB8'
.file: 'test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a850>
.name: 'sxtR8'
.file: 'test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a858>
.name: 'sxtG8'
.file: 'test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a860>
.name: 'sxtB8'
.file: 'test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a868>
.name: 'testSin_f64'
.file: 'test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a870>
.name: 'testCos_f64'
.file: 'test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a878>
.name: 'testTan_f64'
.file: 'test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a880>
.name: 'testLog_f64'
.file: 'test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a888>
.name: 'testExp_f64'
.file: 'test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a890>
.name: 'testPow_f64'
.file: 'test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a898>
.name: 'testSqrt_f64'
.file: 'test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05a8a0>
.name: 'testAtan_f64'
.file: 'test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8a8>
.name: 'testSin_f32'
.file: 'test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8b0>
.name: 'testCos_f32'
.file: 'test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8b8>
.name: 'testTan_f32'
.file: 'test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8c0>
.name: 'testLog_f32'
.file: 'test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8c8>
.name: 'testExp_f32'
.file: 'test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8d0>
.name: 'testPow_f32'
.file: 'test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8d8>
.name: 'testSqrt_f32'
.file: 'test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05a8e0>
.name: 'testAtan_f32'
.file: 'test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a8e8>
.name: 'testPopulation_u32'
.file: 'test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05a8f0>
.name: 'testSwapBits_u32'
.file: 'test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a8f8>
.name: 'testBitScanReverse_u32'
.file: 'test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a900>
.name: 'testBitScanForward_u32'
.file: 'test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a908>
.name: 'testHighBit_u32'
.file: 'test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a910>
.name: 'testLowBit_u32'
.file: 'test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a918>
.name: 'testZeroExtend_u32'
.file: 'test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a920>
.name: 'testSignExtend_u32'
.file: 'test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a928>
.name: 'testZeroExtend_u64'
.file: 'test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a930>
.name: 'testSignExtend_u64'
.file: 'test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/std/memory.ci:10: referenced as `malloc`
	test/std/memory.ci:9: referenced as `malloc`
	test/std/memory.ci:8: referenced as `malloc`
	test/std/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/std/memory.ci:20: referenced as `free`
	test/std/memory.ci:19: referenced as `free`
	test/std/memory.ci:18: referenced as `free`
	test/std/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05a938>
.name: 'p1'
.file: 'test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	test/std/memory.ci:17: referenced as `p1`
	test/std/memory.ci:14: referenced as `p1`
	test/std/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05a940>
.name: 'p2'
.file: 'test/std/memory.ci:8'
.value: malloc(80)
.usages:
	test/std/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05a948>
.name: 'p3'
.file: 'test/std/memory.ci:9'
.value: malloc(160)
.usages:
	test/std/memory.ci:19: referenced as `p3`
	test/std/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05a950>
.name: 'p4'
.file: 'test/std/memory.ci:10'
.value: malloc(820)
.usages:
	test/std/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05a958>
.name: 'val1'
.file: 'test/std/memory.ci:23'
.value: 42
.usages:
	test/std/memory.ci:32: referenced as `val1`
	test/std/memory.ci:30: referenced as `val1`
	test/std/memory.ci:29: referenced as `val1`
	test/std/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05a960>
.name: 'val2'
.file: 'test/std/memory.ci:24'
.value: 96
.usages:
	test/std/memory.ci:33: referenced as `val2`
	test/std/memory.ci:29: referenced as `val2`
	test/std/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@05a968>
.name: 'noError'
.file: 'test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@05a968> - <@05a969>)
	<noError @05a968>      : 03                         ret
.usages:
	test/std/tryExec.ci:47: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@05a970>
.name: 'stackOverflow'
.file: 'test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@05a970> - <@05a988>)
	test/std/tryExec.ci:16: (4 bytes: <@05a970> - <@05a974>): data: uint8[8192] := {...}
	<stackOverflow @05a970>      : 09 00 20 00                inc.sp(+8192)
	test/std/tryExec.ci:17: (15 bytes: <@05a974> - <@05a983>): stackOverflow(ptr);
	<stackOverflow+4 @05a974>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @05a978>    : 28                         load.i32
	<stackOverflow+9 @05a979>    : 1f 70 a9 05 00             load.ref <@05a970> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @05a97e>   : 02                         call
	<stackOverflow+15 @05a97f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @05a983>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @05a987>   : 03                         ret
.usages:
	test/std/tryExec.ci:49: referenced as `stackOverflow`
	test/std/tryExec.ci:17: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@05a988>
.name: 'divisionByZero'
.file: 'test/std/tryExec.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@05a988> - <@05a994>)
	test/std/tryExec.ci:21: (7 bytes: <@05a988> - <@05a98f>): value: int32 := 3 / 0
	<divisionByZero @05a988>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @05a98d>    : 19                         load.z32
	<divisionByZero+6 @05a98e>    : 54                         div.i32
	<divisionByZero+7 @05a98f>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @05a993>   : 03                         ret
.usages:
	test/std/tryExec.ci:50: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@05a998>
.name: 'abortExecution'
.file: 'test/std/tryExec.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@05a998> - <@05a9dc>)
	test/std/tryExec.ci:30: (25 bytes: <@05a998> - <@05a9b1>): details: NotEquals := {...}
	<abortExecution @05a998>      : 09 10 00 00                inc.sp(+16)
	test/std/tryExec.ci:31: (7 bytes: <@05a99c> - <@05a9a3>): details.message := ("assertion failed");
	<abortExecution+4 @05a99c>    : 1f 8c e6 00 00             load.ref <@00e68c> ;"assertion failed"
	<abortExecution+9 @05a9a1>    : 13 01                      set.x32 sp(1)
	test/std/tryExec.ci:32: (7 bytes: <@05a9a3> - <@05a9aa>): details.expected := 97;
	<abortExecution+11 @05a9a3>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @05a9a8>   : 13 02                      set.x32 sp(2)
	test/std/tryExec.ci:33: (7 bytes: <@05a9aa> - <@05a9b1>): details.returned := 77;
	<abortExecution+18 @05a9aa>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @05a9af>   : 13 03                      set.x32 sp(3)
	test/std/tryExec.ci:35: (38 bytes: <@05a9b1> - <@05a9d7>): abort("fatal error", details);
	<abortExecution+25 @05a9b1>   : 1f 88 d1 03 00             load.ref <@03d188> ;"test/std/tryExec.ci"
	<abortExecution+30 @05a9b6>   : 1c 23 00 00 00             load.c32 35
	<abortExecution+35 @05a9bb>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @05a9c0>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @05a9c5>   : 1f d0 d1 03 00             load.ref <@03d1d0> ;"fatal error"
	<abortExecution+50 @05a9ca>   : 1f e8 db 03 00             load.ref <@03dbe8> ;abortExecution.NotEquals
	<abortExecution+55 @05a9cf>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @05a9d3>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @05a9d7>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @05a9db>   : 03                         ret
.usages:
	test/std/tryExec.ci:53: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@05a9e0>
.name: 'invalidMemoryAccess'
.file: 'test/std/tryExec.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@05a9e0> - <@05a9ed>)
	test/std/tryExec.ci:39: (5 bytes: <@05a9e0> - <@05a9e5>): i32Ref: int32 := null
	<invalidMemoryAccess @05a9e0>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/std/tryExec.ci:40: (3 bytes: <@05a9e5> - <@05a9e8>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @05a9e5>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @05a9e7>    : 28                         load.i32
	<invalidMemoryAccess+8 @05a9e8>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @05a9ec>   : 03                         ret
.usages:
	test/std/tryExec.ci:52: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@05a9f0>
.name: 'invalidInstruction'
.file: 'test/std/tryExec.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@05a9f0> - <@05a9f2>)
	test/std/tryExec.ci:44: (2 bytes: <@05a9f0> - <@05a9f2>): emit(load.z32, ret);
	<invalidInstruction @05a9f0>      : 19                         load.z32
	<invalidInstruction+1 @05a9f1>    : 03                         ret
.usages:
	test/std/tryExec.ci:51: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05a9f8>
.name: 'tryExecErr0'
.file: 'test/std/tryExec.ci:47'
.value: tryExec(void(null, noError))
.usages:
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa00>
.name: 'tryExecErr1'
.file: 'test/std/tryExec.ci:48'
.value: tryExec(void(null, null))
.usages:
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa08>
.name: 'tryExecErr2'
.file: 'test/std/tryExec.ci:49'
.value: tryExec(void(null, stackOverflow))
.usages:
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa10>
.name: 'tryExecErr3'
.file: 'test/std/tryExec.ci:50'
.value: tryExec(void(null, divisionByZero))
.usages:
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa18>
.name: 'tryExecErr4'
.file: 'test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidInstruction))
.usages:
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa20>
.name: 'tryExecErr5'
.file: 'test/std/tryExec.ci:52'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aa28>
.name: 'tryExecErr6'
.file: 'test/std/tryExec.ci:53'
.value: tryExec(void(null, abortExecution))
.usages:
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05aa30>
.name: 'value'
.file: 'test/lang/init.reference.ci:7'
.value: 42
.usages:
	test/lang/init.reference.ci:99: referenced as `value`
	test/lang/init.reference.ci:97: referenced as `value`
	test/lang/init.reference.ci:96: referenced as `value`
	test/lang/init.reference.ci:95: referenced as `value`
	test/lang/init.reference.ci:27: referenced as `value`
	test/lang/init.reference.ci:10: referenced as `value`
	test/lang/init.reference.ci:9: referenced as `value`
	test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@05aa38>
.name: 'valueRef'
.file: 'test/lang/init.reference.ci:8'
.value: value
.usages:
	test/lang/init.reference.ci:29: referenced as `valueRef`
	test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aa40>
.name: 'valuePtr'
.file: 'test/lang/init.reference.ci:9'
.value: value
.usages:
	test/lang/init.reference.ci:30: referenced as `valuePtr`
	test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aa48>
.name: 'valueVar'
.file: 'test/lang/init.reference.ci:10'
.value: value
.usages:
	test/lang/init.reference.ci:31: referenced as `valueVar`
	test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05aa50>
.name: 'fromRef'
.file: 'test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@05aa58>
.name: 'fromPtr'
.file: 'test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@05aa60>
.name: 'fromVar'
.file: 'test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@05aa68>
.name: 'nullRef'
.file: 'test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aa70>
.name: 'nullPtr'
.file: 'test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aa78>
.name: 'nullVar'
.file: 'test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05aa80>
.name: 'nullTyp'
.file: 'test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@05aa88>
.name: 'nullFun'
.file: 'test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@05aa90>
.name: 'nullObj'
.file: 'test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aa98>
.name: 'typePtr'
.file: 'test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aaa0>
.name: 'typeVar'
.file: 'test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05aaa8>
.name: 'typeTyp'
.file: 'test/lang/init.reference.ci:25'
.value: int64
.usages:
	test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05aab0>
.name: 'local'
.file: 'test/lang/init.reference.ci:27'
.value: value
.usages:
	test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05aab8>
.name: 'copyVal'
.file: 'test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@05aac0>
.name: 'copyRef'
.file: 'test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aac8>
.name: 'copyPtr'
.file: 'test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aad0>
.name: 'copyVar'
.file: 'test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05aad8>
.name: 'copyTyp'
.file: 'test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aae0>
.name: 'ptrVoid'
.file: 'test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aae8>
.name: 'ptrBool'
.file: 'test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aaf0>
.name: 'ptrChar'
.file: 'test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05aaf8>
.name: 'ptrInt8'
.file: 'test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab00>
.name: 'ptrInt16'
.file: 'test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab08>
.name: 'ptrInt32'
.file: 'test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab10>
.name: 'ptrInt64'
.file: 'test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab18>
.name: 'ptrUint8'
.file: 'test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab20>
.name: 'ptrUint16'
.file: 'test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab28>
.name: 'ptrUint32'
.file: 'test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab30>
.name: 'ptrUint64'
.file: 'test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab38>
.name: 'ptrFloat32'
.file: 'test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab40>
.name: 'ptrFloat64'
.file: 'test/lang/init.reference.ci:47'
.value: float64
.usages:
	test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab48>
.name: 'ptrTypename'
.file: 'test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab50>
.name: 'ptrFunction'
.file: 'test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab58>
.name: 'ptrPointer'
.file: 'test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab60>
.name: 'ptrVariant'
.file: 'test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ab68>
.name: 'ptrObject'
.file: 'test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab70>
.name: 'varVoid'
.file: 'test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab78>
.name: 'varBool'
.file: 'test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab80>
.name: 'varChar'
.file: 'test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab88>
.name: 'varInt8'
.file: 'test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab90>
.name: 'varInt16'
.file: 'test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ab98>
.name: 'varInt32'
.file: 'test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aba0>
.name: 'varInt64'
.file: 'test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05aba8>
.name: 'varUint8'
.file: 'test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abb0>
.name: 'varUint16'
.file: 'test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abb8>
.name: 'varUint32'
.file: 'test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abc0>
.name: 'varUint64'
.file: 'test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abc8>
.name: 'varFloat32'
.file: 'test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abd0>
.name: 'varFloat64'
.file: 'test/lang/init.reference.ci:67'
.value: float64
.usages:
	test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abd8>
.name: 'varTypename'
.file: 'test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abe0>
.name: 'varFunction'
.file: 'test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abe8>
.name: 'varPointer'
.file: 'test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abf0>
.name: 'varVariant'
.file: 'test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05abf8>
.name: 'varObject'
.file: 'test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac00>
.name: 'typVoid'
.file: 'test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac08>
.name: 'typBool'
.file: 'test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac10>
.name: 'typChar'
.file: 'test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac18>
.name: 'typInt8'
.file: 'test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac20>
.name: 'typInt16'
.file: 'test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac28>
.name: 'typInt32'
.file: 'test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac30>
.name: 'typInt64'
.file: 'test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac38>
.name: 'typUint8'
.file: 'test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac40>
.name: 'typUint16'
.file: 'test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac48>
.name: 'typUint32'
.file: 'test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac50>
.name: 'typUint64'
.file: 'test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac58>
.name: 'typFloat32'
.file: 'test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac60>
.name: 'typFloat64'
.file: 'test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac68>
.name: 'typTypename'
.file: 'test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac70>
.name: 'typFunction'
.file: 'test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac78>
.name: 'typPointer'
.file: 'test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac80>
.name: 'typVariant'
.file: 'test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ac88>
.name: 'typObject'
.file: 'test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05ac90>
.name: 'valueOfPtr'
.file: 'test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05ac98>
.name: 'valueOfVar'
.file: 'test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05aca0>
.name: 'valueOfTyp'
.file: 'test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05aca8>
.name: 'typeOfValue'
.file: 'test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@05acb0>
.name: 'copyPtrFloat64'
.file: 'test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05acb8>
.name: 'copyVarFloat64'
.file: 'test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05acc0>
.name: 'variable'
.file: 'test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@05acc8>
.name: 'constant'
.file: 'test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@042128>
.name: 'ComplexVal'
.file: 'test/lang/init.variable.ci:9'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.usages:
	test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@0422f0>
.name: 'ComplexObj'
.file: 'test/lang/init.variable.ci:13'
.field re: float64 (size: 8, offs: <+4>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+12>, cast: const variable(f64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@0068b8>, cast: static const inline)
.field as: function (size: 0, offs: <@006b50>, cast: static const inline)
.usages:
	test/lang/init.variable.ci:41: referenced as `ComplexObj`
	test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+4>
.name: 're'
.file: 'test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	test/lang/init.variable.ci:41: referenced as `re`
	test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+12>
.name: 'im'
.file: 'test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b8>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
valInitImplicit: ComplexVal {
.kind: static variable(val)
.base: `ComplexVal`
.size: 16
.offset: <@05acd0>
.name: 'valInitImplicit'
.file: 'test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	void(valInitImplicit.re := (8));
	void(valInitImplicit.im := (0));
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: static variable(ref)
.base: `ComplexObj`
.size: 4
.offset: <@05ace0>
.name: 'objInitImplicit'
.file: 'test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	void(objInitImplicit := create(ComplexObj));
	void(objInitImplicit.re := (8));
	void(objInitImplicit.im := (0));
}
.usages:
}
objInitExplicit: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@05ace8>
.name: 'objInitExplicit'
.file: 'test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	void(objInitExplicit := create(ComplexObj));
	void(objInitExplicit.re := (8));
}
.usages:
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@05acf0>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@05acf0> - <@05acf1>)
	<empty @05acf0>      : 03                         ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@05acf8>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@05acf8> - <@05ad00>)
	test/lang/function.ci:8: (8 bytes: <@05acf8> - <@05ad00>): return .result := x + y;
	<funAdd @05acf8>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @05acfa>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @05acfc>    : 51                         add.i32
	<funAdd+5 @05acfd>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @05acff>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad00>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@05ad08>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad10>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@05ad18>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad20>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@05ad28>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad30>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@05ad38>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@05ad38> - <@05ad40>)
	test/lang/function.ci:34: (8 bytes: <@05ad38> - <@05ad40>): return .result := x * y;
	<funMul @05ad38>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @05ad3a>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @05ad3c>    : 53                         mul.i32
	<funMul+5 @05ad3d>    : 13 04                      set.x32 sp(4)
	<funMul+7 @05ad3f>    : 03                         ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@05ad40>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@05ad40> - <@05ad76>)
	test/lang/function.ci:39: (16 bytes: <@05ad40> - <@05ad50>): if (n <= (1))
	<fib @05ad40>      : 10 01                      dup.x32 sp(1)
	<fib+2 @05ad42>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @05ad47>    : 39                         cgt.u32
	<fib+8 @05ad48>    : 05 08 00 00                jnz <fib+16 @05ad50>
	test/lang/function.ci:40: (4 bytes: <@05ad4c> - <@05ad50>): return .result := n;
	<fib+12 @05ad4c>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @05ad4f>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@05ad50> - <@05ad76>): return .result := fib(n - (1)) + fib(n - (2));
	<fib+16 @05ad50>   : 19                         load.z32
	<fib+17 @05ad51>   : 10 02                      dup.x32 sp(2)
	<fib+19 @05ad53>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @05ad57>   : 1f 40 ad 05 00             load.ref <@05ad40> ;fib(n: uint32): uint32
	<fib+28 @05ad5c>   : 02                         call
	<fib+29 @05ad5d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @05ad61>   : 19                         load.z32
	<fib+34 @05ad62>   : 10 03                      dup.x32 sp(3)
	<fib+36 @05ad64>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @05ad68>   : 1f 40 ad 05 00             load.ref <@05ad40> ;fib(n: uint32): uint32
	<fib+45 @05ad6d>   : 02                         call
	<fib+46 @05ad6e>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @05ad72>   : 51                         add.i32
	<fib+51 @05ad73>   : 13 03                      set.x32 sp(3)
	<fib+53 @05ad75>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05ad78>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad80>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad88>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad90>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ad98>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ada0>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ada8>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adb0>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adb8>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adc0>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adc8>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05add0>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05add8>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ade0>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ade8>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adf0>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05adf8>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae00>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae08>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@044700>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@0068b8>, cast: static const inline)
.field as: function (size: 0, offs: <@006b50>, cast: static const inline)
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b8>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@044830>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@0068b8>, cast: static const inline)
.field as: function (size: 0, offs: <@006b50>, cast: static const inline)
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b8>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ae10>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@05ae18>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae20>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae28>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@05ae30>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae38>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ae40>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@05ae48>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae50>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae58>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@05ae60>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae68>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ae70>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae78>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae80>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@05ae88>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae90>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05ae98>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@045768>
.name: 'RecordMemberTest'
.file: 'test/lang/init.member.ci:2'
.field Inner: typename (size: 8, offs: <@045800>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@05aea0>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@05aea8>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@05aeb0>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@05aeb8>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@05aec0>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@05aec8>, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@045800>
.name: 'Inner'
.file: 'test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/init.member.ci:49: referenced as `Inner`
	test/lang/init.member.ci:46: referenced as `Inner`
	test/lang/init.member.ci:43: referenced as `Inner`
	test/lang/init.member.ci:25: referenced as `Inner`
	test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/init.member.ci:64: referenced as `member`
	test/lang/init.member.ci:59: referenced as `member`
	test/lang/init.member.ci:49: referenced as `member`
	test/lang/init.member.ci:46: referenced as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/init.member.ci:65: referenced as `constant`
	test/lang/init.member.ci:60: referenced as `constant`
	test/lang/init.member.ci:49: referenced as `constant`
	test/lang/init.member.ci:46: referenced as `constant`
	test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aea0>
.name: 'global'
.file: 'test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05aea8>
.name: 'globalInit'
.file: 'test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@05aeb0>
.name: 'globalConstant'
.file: 'test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@05aeb8>
.name: 'globalRec'
.file: 'test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	void(globalRec.constant := 4);
	void(globalRec.member := (0));
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@05aec0>
.name: 'globalRecInit'
.file: 'test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@05aec8>
.name: 'globalConstantRec'
.file: 'test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@05aed0>
.name: 'recordMemberTest'
.file: 'test/lang/init.member.ci:52'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0465f0>
.name: 'RecordMethodTest'
.file: 'test/lang/init.method.ci:4'
.field staticMethod: function (size: 39, offs: <@05aef0>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@05af18>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@05af20>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@05af48>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@05aef0>
.name: 'staticMethod'
.file: 'test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@05aef0> - <@05af17>)
	test/lang/init.method.ci:11: (38 bytes: <@05aef0> - <@05af16>): trace("staticMethod", x);
	<staticMethod @05aef0>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<staticMethod+5 @05aef5>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @05aefa>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @05aeff>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @05af04>   : 1f 22 62 04 00             load.ref <@046222> ;"staticMethod"
	<staticMethod+25 @05af09>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @05af0e>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @05af12>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @05af16>   : 03                         ret
.usages:
	test/lang/init.method.ci:101: referenced as `staticMethod`
	test/lang/init.method.ci:87: referenced as `staticMethod`
	test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@05af18>
.name: 'forwardMethod'
.file: 'test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/init.method.ci:103: referenced as `virtualMethod`
	test/lang/init.method.ci:93: referenced as `virtualMethod`
	test/lang/init.method.ci:79: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@05af20>
.name: 'virtualMethod'
.file: 'test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@05af20> - <@05af47>)
	test/lang/init.method.ci:41: (38 bytes: <@05af20> - <@05af46>): trace("virtualMethod", x);
	<virtualMethod @05af20>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<virtualMethod+5 @05af25>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @05af2a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @05af2f>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @05af34>   : 1f 0e 65 04 00             load.ref <@04650e> ;"virtualMethod"
	<virtualMethod+25 @05af39>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @05af3e>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @05af42>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @05af46>   : 03                         ret
.usages:
	test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@05af48>
.name: 'forwardMethod'
.file: 'test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@05af48> - <@05af6f>)
	test/lang/init.method.ci:48: (38 bytes: <@05af48> - <@05af6e>): trace("forwardMethod", x);
	<forwardMethod @05af48>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<forwardMethod+5 @05af4d>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @05af52>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @05af57>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @05af5c>   : 1f 95 62 04 00             load.ref <@046295> ;"forwardMethod"
	<forwardMethod+25 @05af61>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @05af66>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @05af6a>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @05af6e>   : 03                         ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@05af70>
.name: 'globalFunction'
.file: 'test/lang/init.method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@05af70> - <@05af97>)
	test/lang/init.method.ci:58: (38 bytes: <@05af70> - <@05af96>): trace("globalFunction", x);
	<globalFunction @05af70>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<globalFunction+5 @05af75>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @05af7a>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @05af7f>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @05af84>   : 1f 41 65 04 00             load.ref <@046541> ;"globalFunction"
	<globalFunction+25 @05af89>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @05af8e>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @05af92>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @05af96>   : 03                         ret
.usages:
	test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@05af98>
.name: 'recordMethodTest'
.file: 'test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/init.method.ci:103: referenced as `recordMethodTest`
	test/lang/init.method.ci:103: referenced as `recordMethodTest`
	test/lang/init.method.ci:102: referenced as `recordMethodTest`
	test/lang/init.method.ci:101: referenced as `recordMethodTest`
	test/lang/init.method.ci:98: referenced as `recordMethodTest`
	test/lang/init.method.ci:97: referenced as `recordMethodTest`
	test/lang/init.method.ci:79: referenced as `recordMethodTest`
	test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@05afa8>
.name: 'staticMethod'
.file: 'test/lang/init.method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@05afa8> - <@05afea>)
	test/lang/init.method.ci:85: (35 bytes: <@05afa8> - <@05afcb>): debug("extension.staticMethod");
	<staticMethod @05afa8>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<staticMethod+5 @05afad>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @05afb2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @05afb7>   : 19                         load.z32
	<staticMethod+16 @05afb8>   : 1f bd 65 04 00             load.ref <@0465bd> ;"extension.staticMethod"
	<staticMethod+21 @05afbd>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @05afc2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @05afc7>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.method.ci:86: (30 bytes: <@05afcb> - <@05afe9>): if ((this) != null)
	<staticMethod+35 @05afcb>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @05afcf>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @05afd4>   : 57                         ceq.i32
	<staticMethod+45 @05afd5>   : 05 14 00 00                jnz <staticMethod+65 @05afe9>
	test/lang/init.method.ci:87: (16 bytes: <@05afd9> - <@05afe9>): RecordMethodTest.staticMethod(this, x);
	<staticMethod+49 @05afd9>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @05afdb>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @05afdd>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @05afdf>   : 1f f0 ae 05 00             load.ref <@05aef0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @05afe4>   : 02                         call
	<staticMethod+61 @05afe5>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @05afe9>   : 03                         ret
.usages:
	test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@05aff0>
.name: 'virtualMethod'
.file: 'test/lang/init.method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@05aff0> - <@05b02f>)
	test/lang/init.method.ci:91: (35 bytes: <@05aff0> - <@05b013>): debug("extension.virtualMethod");
	<virtualMethod @05aff0>      : 1f 80 61 04 00             load.ref <@046180> ;"test/lang/init.method.ci"
	<virtualMethod+5 @05aff5>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @05affa>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @05afff>   : 19                         load.z32
	<virtualMethod+16 @05b000>   : 1f d4 65 04 00             load.ref <@0465d4> ;"extension.virtualMethod"
	<virtualMethod+21 @05b005>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @05b00a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @05b00f>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.method.ci:92: (27 bytes: <@05b013> - <@05b02e>): if ((this) != null)
	<virtualMethod+35 @05b013>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @05b017>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @05b01c>   : 57                         ceq.i32
	<virtualMethod+45 @05b01d>   : 05 11 00 00                jnz <virtualMethod+62 @05b02e>
	test/lang/init.method.ci:93: (13 bytes: <@05b021> - <@05b02e>): this.virtualMethod(this, x);
	<virtualMethod+49 @05b021>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @05b023>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @05b025>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @05b027>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @05b029>   : 02                         call
	<virtualMethod+58 @05b02a>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @05b02e>   : 03                         ret
.usages:
	test/lang/init.method.ci:98: referenced as `virtualMethod`
}
arrFixedInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@05b030>
.name: 'arrFixedInit'
.file: 'test/lang/init.array.ci:11'
.value: {
	void(arrFixedInit[0] := (42));
	void(arrFixedInit[1] := (43));
	void(arrFixedInit[2] := (44));
	void(arrFixedInit[3] := (45));
	void(arrFixedInit[4] := (46));
	void(arrFixedInit[5] := (47));
	void(arrFixedInit[6] := (48));
}
.usages:
	test/lang/init.array.ci:80: referenced as `arrFixedInit`
	test/lang/init.array.ci:76: referenced as `arrFixedInit`
	test/lang/init.array.ci:72: referenced as `arrFixedInit`
	test/lang/init.array.ci:68: referenced as `arrFixedInit`
	test/lang/init.array.ci:66: referenced as `arrFixedInit`
	test/lang/init.array.ci:64: referenced as `arrFixedInit`
	test/lang/init.array.ci:63: referenced as `arrFixedInit`
	test/lang/init.array.ci:62: referenced as `arrFixedInit`
	test/lang/init.array.ci:62: referenced as `arrFixedInit`
	test/lang/init.array.ci:58: referenced as `arrFixedInit`
	test/lang/init.array.ci:57: referenced as `arrFixedInit`
	test/lang/init.array.ci:56: referenced as `arrFixedInit`
	test/lang/init.array.ci:49: referenced as `arrFixedInit`
	test/lang/init.array.ci:23: referenced as `arrFixedInit`
	test/lang/init.array.ci:22: referenced as `arrFixedInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@05b068>
.name: 'arrArrayInitNull'
.file: 'test/lang/init.array.ci:18'
.value: null
.usages:
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@05b070>
.name: 'arrSliceInitNull'
.file: 'test/lang/init.array.ci:19'
.value: null
.usages:
	test/lang/init.array.ci:61: referenced as `arrSliceInitNull`
	test/lang/init.array.ci:48: referenced as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@05b078>
.name: 'arrArrayInitFixed'
.file: 'test/lang/init.array.ci:22'
.value: arrFixedInit
.usages:
	test/lang/init.array.ci:77: referenced as `arrArrayInitFixed`
	test/lang/init.array.ci:73: referenced as `arrArrayInitFixed`
	test/lang/init.array.ci:69: referenced as `arrArrayInitFixed`
	test/lang/init.array.ci:30: referenced as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@05b080>
.name: 'arrSliceInitFixed'
.file: 'test/lang/init.array.ci:23'
.value: arrFixedInit
.usages:
	test/lang/init.array.ci:82: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:78: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:74: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:70: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:63: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:57: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:27: referenced as `arrSliceInitFixed`
	test/lang/init.array.ci:26: referenced as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@05b088>
.name: 'arrArrayInitSlice'
.file: 'test/lang/init.array.ci:26'
.value: arrSliceInitFixed
.usages:
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@05b090>
.name: 'arrSliceInitSlice'
.file: 'test/lang/init.array.ci:27'
.value: arrSliceInitFixed
.usages:
	test/lang/init.array.ci:84: referenced as `arrSliceInitSlice`
	test/lang/init.array.ci:64: referenced as `arrSliceInitSlice`
	test/lang/init.array.ci:58: referenced as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@05b098>
.name: 'arrArrayInitPtr'
.file: 'test/lang/init.array.ci:30'
.value: arrArrayInitFixed
.usages:
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@05b0a0>
.name: 'strFixed'
.file: 'test/lang/init.array.ci:34'
.value: {
	void(strFixed[0] := 's');
	void(strFixed[1] := 't');
	void(strFixed[2] := 'r');
	void(strFixed[3] := 'i');
	void(strFixed[4] := 'n');
	void(strFixed[5] := 'g');
	void(strFixed[6] := (0));
}
.usages:
	test/lang/init.array.ci:35: referenced as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@05b0a8>
.name: 'strArray'
.file: 'test/lang/init.array.ci:37'
.value: "string"
.usages:
	test/lang/init.array.ci:38: referenced as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@05b0b0>
.name: 'strSlice'
.file: 'test/lang/init.array.ci:40'
.value: "string"
.usages:
	test/lang/init.array.ci:41: referenced as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@05b0b8>
.name: 'lenSlice'
.file: 'test/lang/init.array.ci:51'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: const variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@05b0b8> - <@05b0bc>)
	test/lang/init.array.ci:51: (4 bytes: <@05b0b8> - <@05b0bc>): return .result := values.length;
	<lenSlice @05b0b8>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @05b0bb>    : 03                         ret
.usages:
	test/lang/init.array.ci:64: referenced as `lenSlice`
	test/lang/init.array.ci:63: referenced as `lenSlice`
	test/lang/init.array.ci:62: referenced as `lenSlice`
	test/lang/init.array.ci:61: referenced as `lenSlice`
	test/lang/init.array.ci:60: referenced as `lenSlice`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@05b0c0>
.name: 'nthFixed'
.file: 'test/lang/init.array.ci:52'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@05b0c0> - <@05b0cc>)
	test/lang/init.array.ci:52: (12 bytes: <@05b0c0> - <@05b0cc>): return .result := values[idx];
	<nthFixed @05b0c0>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @05b0c2>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @05b0c4>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @05b0c8>    : 29                         load.i64
	<nthFixed+9 @05b0c9>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @05b0cb>   : 03                         ret
.usages:
	test/lang/init.array.ci:74: referenced as `nthFixed`
	test/lang/init.array.ci:73: referenced as `nthFixed`
	test/lang/init.array.ci:72: referenced as `nthFixed`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@05b0d0>
.name: 'nthArray'
.file: 'test/lang/init.array.ci:53'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@05b0d0> - <@05b0dc>)
	test/lang/init.array.ci:53: (12 bytes: <@05b0d0> - <@05b0dc>): return .result := values[idx];
	<nthArray @05b0d0>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @05b0d2>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @05b0d4>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @05b0d8>    : 29                         load.i64
	<nthArray+9 @05b0d9>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @05b0db>   : 03                         ret
.usages:
	test/lang/init.array.ci:78: referenced as `nthArray`
	test/lang/init.array.ci:77: referenced as `nthArray`
	test/lang/init.array.ci:76: referenced as `nthArray`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@05b0e0>
.name: 'nthSlice'
.file: 'test/lang/init.array.ci:54'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: const variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@05b0e0> - <@05b0ec>)
	test/lang/init.array.ci:54: (12 bytes: <@05b0e0> - <@05b0ec>): return .result := values[idx];
	<nthSlice @05b0e0>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @05b0e2>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @05b0e4>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @05b0e8>    : 29                         load.i64
	<nthSlice+9 @05b0e9>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @05b0eb>   : 03                         ret
.usages:
	test/lang/init.array.ci:82: referenced as `nthSlice`
	test/lang/init.array.ci:80: referenced as `nthSlice`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@049a58>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@049cb8>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@049f18>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@04a0e0>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@0068b8>, cast: static const inline)
.field as: function (size: 0, offs: <@006b50>, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b8>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@05b0f0>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@05b0f8>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@05b100>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@05b108>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@05b110>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04a580>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@04a9a8>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@04add0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@04b1f8>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04b620>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04ba48>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b118>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b120>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b128>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b130>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b138>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b140>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b148>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b150>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b158>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b160>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b168>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b170>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b178>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b180>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b188>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b190>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b198>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1a0>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1a8>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1b0>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1b8>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1c0>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1c8>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1d0>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1d8>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1e0>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1e8>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@05b1f0>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b1f8>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b200>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b208>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b210>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b218>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b220>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b228>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b230>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b238>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b240>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b248>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b250>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b258>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b260>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b268>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b270>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b278>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b280>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b288>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b290>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b298>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@05b2a0>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2a8>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2b0>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2b8>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2c0>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2c8>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2d0>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b2d8>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b2e0>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b2e8>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b2f0>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b2f8>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b300>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b308>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b310>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b318>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b320>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b328>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b330>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b338>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b340>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b348>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@05b350>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b358>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b360>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b368>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b370>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b378>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b380>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b388>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b390>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b398>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3a0>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3a8>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3b0>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3b8>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3c0>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3c8>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3d0>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3d8>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3e0>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3e8>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3f0>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b3f8>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@05b400>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b408>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b410>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b418>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b420>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b428>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b430>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b438>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b440>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b448>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b450>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b458>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b460>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b468>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b470>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b478>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b480>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b488>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b490>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b498>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b4a0>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b4a8>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@05b4b0>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4b8>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4c0>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4c8>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4d0>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4d8>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4e0>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b4e8>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b4f0>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b4f8>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b500>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b508>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b510>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b518>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b520>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b528>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b530>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b538>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b540>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b548>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b550>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b558>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b560>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b568>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b570>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b578>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b580>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b588>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b590>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b598>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5a0>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5a8>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5b0>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5b8>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5c0>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5c8>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5d0>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5d8>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5e0>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5e8>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5f0>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b5f8>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b600>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b608>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@05b610>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b618>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b620>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b628>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b630>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b638>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b640>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b648>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b650>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b658>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b660>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b668>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b670>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b678>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b680>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b688>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b690>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b698>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b6a0>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b6a8>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b6b0>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b6b8>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@05b6c0>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6c8>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6d0>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6d8>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6e0>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6e8>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6f0>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b6f8>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b700>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b708>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b710>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b718>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b720>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b728>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b730>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b738>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b740>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b748>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b750>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b758>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b760>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b768>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@05b770>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b778>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b780>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b788>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b790>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b798>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b7a0>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b7a8>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7b0>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7b8>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7c0>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7c8>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7d0>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7d8>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7e0>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7e8>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05b7f0>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b7f8>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b800>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b808>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b810>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b818>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b820>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b828>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b830>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b838>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b840>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b848>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b850>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b858>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b860>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b868>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b870>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b878>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b880>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b888>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b890>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b898>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b8a0>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b8a8>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05b8b0>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@05b8b8>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b8c0>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05b8c8>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b8d0>
.name: 't'
.file: 'test/lang/stmt.if.ci:26'
.value: 0
.usages:
	test/lang/stmt.if.ci:69: referenced as `t`
	test/lang/stmt.if.ci:66: referenced as `t`
	test/lang/stmt.if.ci:65: referenced as `t`
	test/lang/stmt.if.ci:63: referenced as `t`
	test/lang/stmt.if.ci:62: referenced as `t`
	test/lang/stmt.if.ci:60: referenced as `t`
	test/lang/stmt.if.ci:59: referenced as `t`
	test/lang/stmt.if.ci:57: referenced as `t`
	test/lang/stmt.if.ci:56: referenced as `t`
	test/lang/stmt.if.ci:54: referenced as `t`
	test/lang/stmt.if.ci:53: referenced as `t`
	test/lang/stmt.if.ci:51: referenced as `t`
	test/lang/stmt.if.ci:50: referenced as `t`
	test/lang/stmt.if.ci:47: referenced as `t`
	test/lang/stmt.if.ci:44: referenced as `t`
	test/lang/stmt.if.ci:43: referenced as `t`
	test/lang/stmt.if.ci:40: referenced as `t`
	test/lang/stmt.if.ci:37: referenced as `t`
	test/lang/stmt.if.ci:36: referenced as `t`
	test/lang/stmt.if.ci:33: referenced as `t`
	test/lang/stmt.if.ci:32: referenced as `t`
	test/lang/stmt.if.ci:29: referenced as `t`
	test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@05b8d8>
.name: 'forIdx'
.file: 'test/lang/stmt.for.ci:12'
.usages:
	test/lang/stmt.for.ci:14: referenced as `forIdx`
	test/lang/stmt.for.ci:13: referenced as `forIdx`
	test/lang/stmt.for.ci:13: referenced as `forIdx`
	test/lang/stmt.for.ci:13: referenced as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b8e0>
.name: 'testMathFloor_1'
.file: 'test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b8e8>
.name: 'testMathFloor_2'
.file: 'test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b8f0>
.name: 'testMathFloor_3'
.file: 'test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b8f8>
.name: 'testMathFloor_4'
.file: 'test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b900>
.name: 'testMathFloor_5'
.file: 'test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b908>
.name: 'testMathFloor_6'
.file: 'test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b910>
.name: 'testMathSign_1F'
.file: 'test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b918>
.name: 'testMathSign_2F'
.file: 'test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b920>
.name: 'testMathSign_3F'
.file: 'test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b928>
.name: 'testMathSign_1f'
.file: 'test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b930>
.name: 'testMathSign_2f'
.file: 'test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b938>
.name: 'testMathSign_3f'
.file: 'test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b940>
.name: 'testMathAbs_1F'
.file: 'test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b948>
.name: 'testMathAbs_2F'
.file: 'test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b950>
.name: 'testMathAbs_3F'
.file: 'test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b958>
.name: 'testMathAbs_1f'
.file: 'test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b960>
.name: 'testMathAbs_2f'
.file: 'test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b968>
.name: 'testMathAbs_3f'
.file: 'test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b970>
.name: 'testMathMin_1f'
.file: 'test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b978>
.name: 'testMathMax_2f'
.file: 'test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b980>
.name: 'testMathMin_1F'
.file: 'test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b988>
.name: 'testMathMax_2F'
.file: 'test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b990>
.name: 'testMathClamp_1f'
.file: 'test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b998>
.name: 'testMathClamp_1F'
.file: 'test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9a0>
.name: 'testMathLerp_1f'
.file: 'test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9a8>
.name: 'testMathLerp_1F'
.file: 'test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9b0>
.name: 'testMathSmooth_1f'
.file: 'test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9b8>
.name: 'testMathSmooth_1F'
.file: 'test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9c0>
.name: 'testMathMin_nan'
.file: 'test/std/test.math.ci:38'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9c8>
.name: 'testMathMin_1'
.file: 'test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9d0>
.name: 'testMathMax_nan'
.file: 'test/std/test.math.ci:40'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9d8>
.name: 'testMathMax_9'
.file: 'test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9e0>
.name: 'testMathSum_0'
.file: 'test/std/test.math.ci:43'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9e8>
.name: 'testMathSum_1'
.file: 'test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9f0>
.name: 'testMathSum_3'
.file: 'test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05b9f8>
.name: 'testMathSum_55'
.file: 'test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba00>
.name: 'testMathEval_x'
.file: 'test/std/test.math.ci:48'
.value: 10
.usages:
	test/std/test.math.ci:55: referenced as `testMathEval_x`
	test/std/test.math.ci:54: referenced as `testMathEval_x`
	test/std/test.math.ci:53: referenced as `testMathEval_x`
	test/std/test.math.ci:52: referenced as `testMathEval_x`
	test/std/test.math.ci:51: referenced as `testMathEval_x`
	test/std/test.math.ci:50: referenced as `testMathEval_x`
	test/std/test.math.ci:49: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba08>
.name: 'testMathEval_0'
.file: 'test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba10>
.name: 'testMathEval_1'
.file: 'test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba18>
.name: 'testMathEval_2'
.file: 'test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba20>
.name: 'testMathEval_3'
.file: 'test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba28>
.name: 'testMathEval_4'
.file: 'test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba30>
.name: 'testMathEval_5'
.file: 'test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba38>
.name: 'testMathEval_6'
.file: 'test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba40>
.name: 'testMathSin_f64'
.file: 'test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba48>
.name: 'testMathCos_f64'
.file: 'test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba50>
.name: 'testMathTan_f64'
.file: 'test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba58>
.name: 'testMathSinh_f64'
.file: 'test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba60>
.name: 'testMathCosh_f64'
.file: 'test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba68>
.name: 'testMathAsin_f64'
.file: 'test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba70>
.name: 'testMathAcos_f64'
.file: 'test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05ba78>
.name: 'testMathCmp_f32'
.file: 'test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@05ba80>
.name: 'testMathCmp_f64'
.file: 'test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba88>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba90>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05ba98>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05baa0>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05baa8>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bab0>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bab8>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bac0>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bac8>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bad0>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@05bad8>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bae0>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bae8>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05baf0>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05baf8>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb00>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb08>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb10>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb18>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb20>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb28>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@05bb30>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 14710
.offset: <@05bb34>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000d38>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000dd8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005a38>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@007310>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@007bf0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008860>, cast: static const typename(void))
.field true: bool (size: 1, offs: <@000000>, cast: static const val)
.field false: bool (size: 1, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 24, offs: <@011588>, cast: static const typename(val))
.field assertEq: function (size: 103, offs: <@059148>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@012780>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01b7c0>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@059988>, cast: static const function)
.field Complex: function (size: 7, offs: <@059990>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@059998>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@059a18>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@059a38>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@020e10>, cast: static const typename(val))
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@024b98>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@059aa0>, cast: static const function)
.field mat4f: function (size: 21, offs: <@059ad8>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@059af0>, cast: static const function)
.field mul: function (size: 245, offs: <@059b28>, cast: static const function)
.field rotation: function (size: 454, offs: <@059c20>, cast: static const function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@059de8>, cast: static const function)
.field scale: function (size: 217, offs: <@059e40>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@029c40>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@059f20>, cast: static const function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@059f28>, cast: static const function)
.field indexOf: function (size: 50, offs: <@059f50>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@059f88>, cast: static const function)
.field startsWith: function (size: 73, offs: <@059fc0>, cast: static const function)
.field endsWith: function (size: 126, offs: <@05a010>, cast: static const function)
.field compare: function (size: 63, offs: <@05a090>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@05a118>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@05a140>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@02f2e8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@05a150>, cast: static const function)
.field append: function (size: 707, offs: <@05a1b8>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 227, offs: <@05a480>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@05a578>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@05a5b8>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@05a5c0>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@05a5c8>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@05a5d0>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@05a5d8>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@05a5e0>, cast: static variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <@05a5e8>, cast: static variable(f32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@05a5f0>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@05a5f8>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@05a600>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@05a608>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@05a610>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@05a618>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@05a620>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@05a628>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@05a630>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@05a638>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@05a640>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@05a648>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@05a650>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@05a658>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@05a660>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@05a668>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@05a670>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@05a678>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@05a680>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@05a688>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@05a690>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@05a698>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@05a6a0>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@05a6a8>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@05a6b0>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@05a6b8>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@05a6c0>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@05a6c8>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@05a6d0>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@05a6d8>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@05a6e0>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@05a6e8>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@05a6f0>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@05a6f8>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@05a700>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@05a708>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@05a710>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@05a718>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@05a720>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@05a728>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@05a730>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@05a738>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@05a740>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@05a748>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@05a750>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@05a758>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@05a760>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@05a768>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@05a770>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@05a778>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@05a780>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@05a788>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@05a790>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@05a798>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@05a7a0>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@05a7a8>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@0398a8>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@0399d8>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@05a7b0>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@05a7b8>, cast: static variable(val))
.field pi64: float64 (size: 8, offs: <@05a7c0>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@05a7c8>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@05a7d0>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@05a7d8>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@05a7e0>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@05a7e8>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@05a7f0>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@05a7f8>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@05a800>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@05a808>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@05a810>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@05a818>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@05a820>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@05a828>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@05a830>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@05a838>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@05a840>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@05a848>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@05a850>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@05a858>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@05a860>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@05a868>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@05a870>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@05a878>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@05a880>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@05a888>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@05a890>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@05a898>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@05a8a0>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@05a8a8>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@05a8b0>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@05a8b8>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@05a8c0>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@05a8c8>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@05a8d0>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@05a8d8>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@05a8e0>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@05a8e8>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@05a8f0>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@05a8f8>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@05a900>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@05a908>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@05a910>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@05a918>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@05a920>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@05a928>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@05a930>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@05a938>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@05a940>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@05a948>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@05a950>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@05a958>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@05a960>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@05a968>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@05a970>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@05a988>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@05a998>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@05a9e0>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@05a9f0>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@05a9f8>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@05aa00>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@05aa08>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@05aa10>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@05aa18>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@05aa20>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@05aa28>, cast: static variable(i32))
.field value: int64 (size: 8, offs: <@05aa30>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@05aa38>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@05aa40>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@05aa48>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@05aa50>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@05aa58>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@05aa60>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@05aa68>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@05aa70>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@05aa78>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@05aa80>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@05aa88>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@05aa90>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@05aa98>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@05aaa0>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@05aaa8>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@05aab0>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@05aab8>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@05aac0>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@05aac8>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@05aad0>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@05aad8>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@05aae0>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@05aae8>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@05aaf0>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@05aaf8>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@05ab00>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@05ab08>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@05ab10>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@05ab18>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@05ab20>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@05ab28>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@05ab30>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@05ab38>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@05ab40>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@05ab48>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@05ab50>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@05ab58>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@05ab60>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@05ab68>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@05ab70>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@05ab78>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@05ab80>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@05ab88>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@05ab90>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@05ab98>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@05aba0>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@05aba8>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@05abb0>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@05abb8>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@05abc0>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@05abc8>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@05abd0>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@05abd8>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@05abe0>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@05abe8>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@05abf0>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@05abf8>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@05ac00>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@05ac08>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@05ac10>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@05ac18>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@05ac20>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@05ac28>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@05ac30>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@05ac38>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@05ac40>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@05ac48>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@05ac50>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@05ac58>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@05ac60>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@05ac68>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@05ac70>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@05ac78>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@05ac80>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@05ac88>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@05ac90>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@05ac98>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@05aca0>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@05aca8>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@05acb0>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@05acb8>, cast: static variable(ref))
.field variable: int32 (size: 4, offs: <@05acc0>, cast: static variable(i32))
.field constant: int32 (size: 4, offs: <@05acc8>, cast: static const variable(i32))
.field ComplexVal: typename (size: 16, offs: <@042128>, cast: static const typename(val))
.field ComplexObj: object (size: 20, offs: <@0422f0>, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, offs: <@05acd0>, cast: static variable(val))
.field objInitImplicit: ComplexObj (size: 4, offs: <@05ace0>, cast: static variable(ref))
.field objInitExplicit: object (size: 4, offs: <@05ace8>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@05acf0>, cast: static const function)
.field funAdd: function (size: 8, offs: <@05acf8>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@05ad00>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@05ad08>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@05ad10>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@05ad18>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@05ad20>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@05ad28>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@05ad30>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@05ad38>, cast: static const function)
.field fib: function (size: 54, offs: <@05ad40>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@05ad78>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@05ad80>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@05ad88>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@05ad90>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@05ad98>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@05ada0>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@05ada8>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@05adb0>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@05adb8>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@05adc0>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@05adc8>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@05add0>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@05add8>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@05ade0>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@05ade8>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@05adf0>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@05adf8>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@05ae00>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@05ae08>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@044700>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@044830>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@05ae10>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@05ae18>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@05ae20>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@05ae28>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@05ae30>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@05ae38>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@05ae40>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@05ae48>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@05ae50>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@05ae58>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@05ae60>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@05ae68>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@05ae70>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@05ae78>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@05ae80>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@05ae88>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@05ae90>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@05ae98>, cast: static variable(i32))
.field RecordMemberTest: typename (size: 32, offs: <@045768>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@05aed0>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@0465f0>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@05af70>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@05af98>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@05afa8>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@05aff0>, cast: static const function)
.field arrFixedInit: int64[7] (size: 56, offs: <@05b030>, cast: static variable(val))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@05b068>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@05b070>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@05b078>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@05b080>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@05b088>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@05b090>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@05b098>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@05b0a0>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@05b0a8>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@05b0b0>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@05b0b8>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@05b0c0>, cast: static const function)
.field nthArray: function (size: 12, offs: <@05b0d0>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@05b0e0>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@049a58>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@049cb8>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@049f18>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@04a0e0>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@05b0f0>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@05b0f8>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@05b100>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@05b108>, cast: static variable(val))
.field blue: color (size: 4, offs: <@05b110>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@04a580>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@04a9a8>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@04add0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@04b1f8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@04b620>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@04ba48>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@05b118>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@05b120>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@05b128>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@05b130>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@05b138>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@05b140>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@05b148>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@05b150>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@05b158>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@05b160>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@05b168>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@05b170>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@05b178>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@05b180>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@05b188>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@05b190>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@05b198>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@05b1a0>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@05b1a8>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@05b1b0>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@05b1b8>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@05b1c0>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@05b1c8>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@05b1d0>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@05b1d8>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@05b1e0>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@05b1e8>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@05b1f0>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@05b1f8>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@05b200>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@05b208>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@05b210>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@05b218>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@05b220>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@05b228>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@05b230>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@05b238>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@05b240>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@05b248>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@05b250>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@05b258>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@05b260>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@05b268>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@05b270>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@05b278>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@05b280>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@05b288>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@05b290>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@05b298>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@05b2a0>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@05b2a8>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@05b2b0>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@05b2b8>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@05b2c0>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@05b2c8>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@05b2d0>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@05b2d8>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@05b2e0>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@05b2e8>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@05b2f0>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@05b2f8>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@05b300>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@05b308>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@05b310>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@05b318>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@05b320>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@05b328>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@05b330>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@05b338>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@05b340>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@05b348>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@05b350>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@05b358>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@05b360>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@05b368>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@05b370>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@05b378>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@05b380>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@05b388>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@05b390>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@05b398>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@05b3a0>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@05b3a8>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@05b3b0>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@05b3b8>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@05b3c0>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@05b3c8>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@05b3d0>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@05b3d8>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@05b3e0>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@05b3e8>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@05b3f0>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@05b3f8>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@05b400>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@05b408>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@05b410>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@05b418>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@05b420>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@05b428>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@05b430>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@05b438>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@05b440>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@05b448>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@05b450>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@05b458>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@05b460>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@05b468>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@05b470>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@05b478>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@05b480>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@05b488>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@05b490>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@05b498>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@05b4a0>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@05b4a8>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@05b4b0>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@05b4b8>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@05b4c0>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@05b4c8>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@05b4d0>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@05b4d8>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@05b4e0>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@05b4e8>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@05b4f0>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@05b4f8>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@05b500>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@05b508>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@05b510>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@05b518>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@05b520>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@05b528>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@05b530>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@05b538>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@05b540>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@05b548>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@05b550>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@05b558>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@05b560>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@05b568>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@05b570>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@05b578>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@05b580>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@05b588>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@05b590>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@05b598>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@05b5a0>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@05b5a8>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@05b5b0>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@05b5b8>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@05b5c0>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@05b5c8>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@05b5d0>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@05b5d8>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@05b5e0>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@05b5e8>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@05b5f0>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@05b5f8>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@05b600>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@05b608>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@05b610>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@05b618>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@05b620>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@05b628>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@05b630>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@05b638>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@05b640>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@05b648>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@05b650>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@05b658>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@05b660>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@05b668>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@05b670>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@05b678>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@05b680>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@05b688>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@05b690>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@05b698>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@05b6a0>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@05b6a8>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@05b6b0>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@05b6b8>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@05b6c0>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@05b6c8>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@05b6d0>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@05b6d8>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@05b6e0>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@05b6e8>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@05b6f0>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@05b6f8>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@05b700>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@05b708>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@05b710>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@05b718>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@05b720>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@05b728>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@05b730>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@05b738>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@05b740>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@05b748>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@05b750>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@05b758>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@05b760>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@05b768>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@05b770>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@05b778>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@05b780>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@05b788>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@05b790>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@05b798>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@05b7a0>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@05b7a8>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@05b7b0>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@05b7b8>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@05b7c0>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@05b7c8>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@05b7d0>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@05b7d8>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@05b7e0>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@05b7e8>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@05b7f0>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@05b7f8>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@05b800>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@05b808>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@05b810>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@05b818>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@05b820>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@05b828>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@05b830>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@05b838>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@05b840>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@05b848>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@05b850>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@05b858>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@05b860>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@05b868>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@05b870>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@05b878>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@05b880>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@05b888>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@05b890>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@05b898>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@05b8a0>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@05b8a8>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@05b8b0>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@05b8b8>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@05b8c0>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@05b8c8>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@05b8d0>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@05b8d8>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@05b8e0>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@05b8e8>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@05b8f0>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@05b8f8>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@05b900>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@05b908>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@05b910>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@05b918>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@05b920>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@05b928>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@05b930>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@05b938>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@05b940>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@05b948>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@05b950>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@05b958>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@05b960>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@05b968>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@05b970>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@05b978>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@05b980>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@05b988>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@05b990>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@05b998>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@05b9a0>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@05b9a8>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@05b9b0>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@05b9b8>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@05b9c0>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@05b9c8>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@05b9d0>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@05b9d8>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@05b9e0>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@05b9e8>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@05b9f0>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@05b9f8>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@05ba00>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@05ba08>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@05ba10>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@05ba18>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@05ba20>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@05ba28>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@05ba30>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@05ba38>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@05ba40>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@05ba48>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@05ba50>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@05ba58>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@05ba60>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@05ba68>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@05ba70>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@05ba78>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@05ba80>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@05ba88>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@05ba90>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@05ba98>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@05baa0>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@05baa8>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@05bab0>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@05bab8>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@05bac0>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@05bac8>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@05bad0>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@05bad8>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@05bae0>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@05bae8>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@05baf0>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@05baf8>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@05bb00>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@05bb08>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@05bb10>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@05bb18>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@05bb20>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@05bb28>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@05bb30>, cast: static variable(f32))
.field .main: function (size: 14710, offs: <@05bb34>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static signed(value: uint8): int8 := int8(value);
		static signed(value: uint16): int16 := int16(value);
		static signed(value: uint32): int32 := int32(value);
		static signed(value: uint64): int64 := int64(value);
		static unsigned(value: int8): uint8 := uint8(value);
		static unsigned(value: int16): uint16 := uint16(value);
		static unsigned(value: int32): uint32 := uint32(value);
		static unsigned(value: int64): uint64 := uint64(value);
		static sizeof(type: typename): int32 := int32(type.size);
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static const assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				extras: variant[1] := {
					void(extras[0] := (message));
				};
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.extras := (extras));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static const mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float32(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float64(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else if (bool(i == 1)) {
					float64(x := float64((1) - x));
					bool(complement := true);
				}
				else if (bool(i == 2)) {
					bool(negate := bool(!negate));
					bool(complement := true);
				}
				else if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			data: float32[4];
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
		};
		static vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))));
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(void(max(void(vec, min)), max));
		static clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(void(void(vec, vec4f(min)), vec4f(max)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			data: float32[16];
			m: float32[4][4];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
		};
		static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static const transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static const rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static const translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const vec2d: struct {
			data: float64[2];
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
		};
		static const vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static const length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static const append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static const append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static const append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static emitNfcF32: float32 := emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static variable: int32;
		static const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static valInitImplicit: ComplexVal := {
			void(valInitImplicit.re := (8));
			void(valInitImplicit.im := (0));
		};
		static objInitImplicit: ComplexObj := {
			void(objInitImplicit := create(ComplexObj));
			void(objInitImplicit.re := (8));
			void(objInitImplicit.im := (0));
		};
		static objInitExplicit: object := {
			void(objInitExplicit := create(ComplexObj));
			void(objInitExplicit.re := (8));
		};
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				void(globalRec.constant := 4);
				void(globalRec.member := (0));
			};
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedInit: int64[7] := {
			void(arrFixedInit[0] := (42));
			void(arrFixedInit[1] := (43));
			void(arrFixedInit[2] := (44));
			void(arrFixedInit[3] := (45));
			void(arrFixedInit[4] := (46));
			void(arrFixedInit[5] := (47));
			void(arrFixedInit[6] := (48));
		};
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedInit;
		static arrSliceInitFixed: int64[] := arrFixedInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7] := {
			void(strFixed[0] := 's');
			void(strFixed[1] := 't');
			void(strFixed[2] := 'r');
			void(strFixed[3] := 'i');
			void(strFixed[4] := 'n');
			void(strFixed[5] := 'g');
			void(strFixed[6] := (0));
		};
		debug(void("string as variant", strFixed));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedInit[0] == (42)));
		static const lenSlice(const values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, const values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, const values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, const values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedInit.length));
		assertEq(void(arrFixedInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedInit.length, lenSlice(arrFixedInit)));
		assertEq(void(arrFixedInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else if (bool(t == 1)) {
				raise(void(void(void(raise.debug, 10), "t == 1"), t));
			}
			else if (bool(t == 2)) {
				raise(void(void(void(raise.debug, 10), "t == 2"), t));
			}
			else if (bool(t == 3)) {
				raise(void(void(void(raise.debug, 10), "t == 3"), t));
			}
			else if (bool(t == 4)) {
				raise(void(void(void(raise.debug, 10), "t == 4"), t));
			}
			else if (bool(t == 5)) {
				raise(void(void(void(raise.debug, 10), "t == 5"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14710 bytes: <@05bb34> - <@05f4aa>)
	lib/std/string.ci:145: (14 bytes: <@05bb34> - <@05bb42>): static const whiteSpace: char[] := " \t\n\r"
	<.main @05bb34>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @05bb39>    : 1f 54 ba 02 00             load.ref <@02ba54> ;" \t\n\r"
	<.main+10 @05bb3e>   : 23 a8 a1 05                store.m64 <@05a1a8> ;append.whiteSpace
	lib/std/string.ci:146: (14 bytes: <@05bb42> - <@05bb50>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @05bb42>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @05bb47>   : 1f 65 ba 02 00             load.ref <@02ba65> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @05bb4c>   : 23 b0 a1 05                store.m64 <@05a1b0> ;append.radixDigits
	lib/std/string.ci:263: (24 bytes: <@05bb50> - <@05bb68>): static const format: FormatFlags := {...}
	<.main+28 @05bb50>   : 19                         load.z32
	<.main+29 @05bb51>   : 1f 68 a5 05 00             load.ref <@05a568> ;append.format
	<.main+34 @05bb56>   : 2b                         store.i8
	:: (5 bytes: <@05bb57> - <@05bb5c>): format.precision := 0
	<.main+35 @05bb57>   : 19                         load.z32
	<.main+36 @05bb58>   : 24 6c a5 05                store.m32 <@05a56c> ;append.format+4
	:: (7 bytes: <@05bb5c> - <@05bb63>): format.padChr := (0)
	<.main+40 @05bb5c>   : 19                         load.z32
	<.main+41 @05bb5d>   : 1f 70 a5 05 00             load.ref <@05a570> ;append.format+8
	<.main+46 @05bb62>   : 2b                         store.i8
	:: (5 bytes: <@05bb63> - <@05bb68>): format.padLen := 0
	<.main+47 @05bb63>   : 19                         load.z32
	<.main+48 @05bb64>   : 24 74 a5 05                store.m32 <@05a574> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@05bb68> - <@05bb6d>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @05bb68>   : 19                         load.z32
	<.main+53 @05bb69>   : 24 b8 a5 05                store.m32 <@05a5b8> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@05bb6d> - <@05bb72>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @05bb6d>   : 1a                         load.z64
	<.main+58 @05bb6e>   : 23 c0 a5 05                store.m64 <@05a5c0> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@05bb72> - <@05bb7b>): static emitA: int32 := 42
	<.main+62 @05bb72>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @05bb77>   : 24 c8 a5 05                store.m32 <@05a5c8> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@05bb7b> - <@05bb84>): static emitB: int32 := 96
	<.main+71 @05bb7b>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @05bb80>   : 24 d0 a5 05                store.m32 <@05a5d0> ;emitB
	test/lang/emit.ci:10: (13 bytes: <@05bb84> - <@05bb91>): static emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+80 @05bb84>   : 20 c8 a5 05                load.m32 <@05a5c8> ;emitA
	<.main+84 @05bb88>   : 20 d0 a5 05                load.m32 <@05a5d0> ;emitB
	<.main+88 @05bb8c>   : 51                         add.i32
	<.main+89 @05bb8d>   : 24 d8 a5 05                store.m32 <@05a5d8> ;emitAddI32
	test/lang/emit.ci:13: (15 bytes: <@05bb91> - <@05bba0>): static emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+93 @05bb91>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @05bb96>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @05bb9b>  : 54                         div.i32
	<.main+104 @05bb9c>  : 24 e0 a5 05                store.m32 <@05a5e0> ;emitDivI32
	test/lang/emit.ci:16: (19 bytes: <@05bba0> - <@05bbb3>): static emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+108 @05bba0>  : 7f c3 f5 48 40             load.f32 3.140000
	<.main+113 @05bba5>  : 7f 00 00 00 40             load.f32 2.000000
	<.main+118 @05bbaa>  : 74                         div.f32
	<.main+119 @05bbab>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+123 @05bbaf>  : 24 e8 a5 05                store.m32 <@05a5e8> ;emitNfcF32
	test/lang/emit.ci:23: (9 bytes: <@05bbb3> - <@05bbbc>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+127 @05bbb3>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+132 @05bbb8>  : 24 f0 a5 05                store.m32 <@05a5f0> ;emitFloatAsInt1
	test/lang/emit.ci:24: (10 bytes: <@05bbbc> - <@05bbc6>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+136 @05bbbc>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+141 @05bbc1>  : 5b                         i32.2i64
	<.main+142 @05bbc2>  : 23 f8 a5 05                store.m64 <@05a5f8> ;emitFloatAsInt2
	test/lang/emit.ci:25: (14 bytes: <@05bbc6> - <@05bbd4>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+146 @05bbc6>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+155 @05bbcf>  : 6a                         i64.2i32
	<.main+156 @05bbd0>  : 24 00 a6 05                store.m32 <@05a600> ;emitFloatAsInt3
	test/lang/emit.ci:26: (13 bytes: <@05bbd4> - <@05bbe1>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+160 @05bbd4>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+169 @05bbdd>  : 23 08 a6 05                store.m64 <@05a608> ;emitFloatAsInt4
	test/lang/emit.ci:29: (14 bytes: <@05bbe1> - <@05bbef>): static emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+173 @05bbe1>  : 1c 03 00 00 00             load.c32 3
	<.main+178 @05bbe6>  : 1f 4d 3a 03 00             load.ref <@033a4d> ;"string"
	<.main+183 @05bbeb>  : 23 10 a6 05                store.m64 <@05a610> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@05bbef> - <@05bbf8>): static i3: int32 := 3
	<.main+187 @05bbef>  : 1c 03 00 00 00             load.c32 3
	<.main+192 @05bbf4>  : 24 18 a6 05                store.m32 <@05a618> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@05bbf8> - <@05bc01>): static i6: int32 := 6
	<.main+196 @05bbf8>  : 1c 06 00 00 00             load.c32 6
	<.main+201 @05bbfd>  : 24 20 a6 05                store.m32 <@05a620> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@05bc01> - <@05bc0a>): static i2: int32 := 2
	<.main+205 @05bc01>  : 1c 02 00 00 00             load.c32 2
	<.main+210 @05bc06>  : 24 28 a6 05                store.m32 <@05a628> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@05bc0a> - <@05bc13>): static i8: int32 := 8
	<.main+214 @05bc0a>  : 1c 08 00 00 00             load.c32 8
	<.main+219 @05bc0f>  : 24 30 a6 05                store.m32 <@05a630> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@05bc13> - <@05bc18>): static zeroVal: int32 := zero(3, 6)
	<.main+223 @05bc13>  : 19                         load.z32
	<.main+224 @05bc14>  : 24 38 a6 05                store.m32 <@05a638> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@05bc18> - <@05bc1d>): static zeroVar: int32 := zero(i3, i6)
	<.main+228 @05bc18>  : 19                         load.z32
	<.main+229 @05bc19>  : 24 40 a6 05                store.m32 <@05a640> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@05bc1d> - <@05bc22>): static zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+233 @05bc1d>  : 19                         load.z32
	<.main+234 @05bc1e>  : 24 48 a6 05                store.m32 <@05a648> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@05bc22> - <@05bc2b>): static lastVal: int32 := last(3, 6)
	<.main+238 @05bc22>  : 1c 06 00 00 00             load.c32 6
	<.main+243 @05bc27>  : 24 50 a6 05                store.m32 <@05a650> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@05bc2b> - <@05bc33>): static lastVar: int32 := last(i3, i6)
	<.main+247 @05bc2b>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+251 @05bc2f>  : 24 58 a6 05                store.m32 <@05a658> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@05bc33> - <@05bc43>): static lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+255 @05bc33>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+259 @05bc37>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @05bc3b>  : 0c ff ff ff                inc.i32(-1)
	<.main+267 @05bc3f>  : 24 60 a6 05                store.m32 <@05a660> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@05bc43> - <@05bc50>): static sum2Val: int32 := sum(3, 6)
	<.main+271 @05bc43>  : 1c 03 00 00 00             load.c32 3
	<.main+276 @05bc48>  : 0c 06 00 00                inc.i32(+6)
	<.main+280 @05bc4c>  : 24 68 a6 05                store.m32 <@05a668> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@05bc50> - <@05bc5d>): static sum2Var: int32 := sum(i3, i6)
	<.main+284 @05bc50>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+288 @05bc54>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+292 @05bc58>  : 51                         add.i32
	<.main+293 @05bc59>  : 24 70 a6 05                store.m32 <@05a670> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@05bc5d> - <@05bc76>): static sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+297 @05bc5d>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+301 @05bc61>  : 0c 01 00 00                inc.i32(+1)
	<.main+305 @05bc65>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+309 @05bc69>  : 0c 01 00 00                inc.i32(+1)
	<.main+313 @05bc6d>  : 51                         add.i32
	<.main+314 @05bc6e>  : 0c fe ff ff                inc.i32(-2)
	<.main+318 @05bc72>  : 24 78 a6 05                store.m32 <@05a678> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@05bc76> - <@05bc92>): static any2Val: int32 := any(3, 6)
	<.main+322 @05bc76>  : 1c 03 00 00 00             load.c32 3
	<.main+327 @05bc7b>  : 10 00                      dup.x32 sp(0)
	<.main+329 @05bc7d>  : 06 0a 00 00                jz <.main+339 @05bc87>
	<.main+333 @05bc81>  : 10 00                      dup.x32 sp(0)
	<.main+335 @05bc83>  : 04 09 00 00                jmp <.main+344 @05bc8c>
	<.main+339 @05bc87>  : 1c 06 00 00 00             load.c32 6
	<.main+344 @05bc8c>  : 13 01                      set.x32 sp(1)
	<.main+346 @05bc8e>  : 24 80 a6 05                store.m32 <@05a680> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@05bc92> - <@05bcac>): static any2Var: int32 := any(i3, i6)
	<.main+350 @05bc92>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+354 @05bc96>  : 10 00                      dup.x32 sp(0)
	<.main+356 @05bc98>  : 06 0a 00 00                jz <.main+366 @05bca2>
	<.main+360 @05bc9c>  : 10 00                      dup.x32 sp(0)
	<.main+362 @05bc9e>  : 04 08 00 00                jmp <.main+370 @05bca6>
	<.main+366 @05bca2>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+370 @05bca6>  : 13 01                      set.x32 sp(1)
	<.main+372 @05bca8>  : 24 88 a6 05                store.m32 <@05a688> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@05bcac> - <@05bcd2>): static any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+376 @05bcac>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+380 @05bcb0>  : 0c 01 00 00                inc.i32(+1)
	<.main+384 @05bcb4>  : 10 00                      dup.x32 sp(0)
	<.main+386 @05bcb6>  : 06 0a 00 00                jz <.main+396 @05bcc0>
	<.main+390 @05bcba>  : 10 00                      dup.x32 sp(0)
	<.main+392 @05bcbc>  : 04 0c 00 00                jmp <.main+404 @05bcc8>
	<.main+396 @05bcc0>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+400 @05bcc4>  : 0c 01 00 00                inc.i32(+1)
	<.main+404 @05bcc8>  : 13 01                      set.x32 sp(1)
	<.main+406 @05bcca>  : 0c ff ff ff                inc.i32(-1)
	<.main+410 @05bcce>  : 24 90 a6 05                store.m32 <@05a690> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@05bcd2> - <@05bcf7>): static min2Val: int32 := min(3, 6)
	<.main+414 @05bcd2>  : 1c 03 00 00 00             load.c32 3
	<.main+419 @05bcd7>  : 1c 06 00 00 00             load.c32 6
	<.main+424 @05bcdc>  : 10 01                      dup.x32 sp(1)
	<.main+426 @05bcde>  : 10 01                      dup.x32 sp(1)
	<.main+428 @05bce0>  : 58                         clt.i32
	<.main+429 @05bce1>  : 06 0a 00 00                jz <.main+439 @05bceb>
	<.main+433 @05bce5>  : 10 01                      dup.x32 sp(1)
	<.main+435 @05bce7>  : 04 06 00 00                jmp <.main+441 @05bced>
	<.main+439 @05bceb>  : 10 00                      dup.x32 sp(0)
	<.main+441 @05bced>  : 13 02                      set.x32 sp(2)
	<.main+443 @05bcef>  : 09 fc ff ff                inc.sp(-4)
	<.main+447 @05bcf3>  : 24 98 a6 05                store.m32 <@05a698> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@05bcf7> - <@05bd1a>): static min2Var: int32 := min(i3, i6)
	<.main+451 @05bcf7>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+455 @05bcfb>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+459 @05bcff>  : 10 01                      dup.x32 sp(1)
	<.main+461 @05bd01>  : 10 01                      dup.x32 sp(1)
	<.main+463 @05bd03>  : 58                         clt.i32
	<.main+464 @05bd04>  : 06 0a 00 00                jz <.main+474 @05bd0e>
	<.main+468 @05bd08>  : 10 01                      dup.x32 sp(1)
	<.main+470 @05bd0a>  : 04 06 00 00                jmp <.main+476 @05bd10>
	<.main+474 @05bd0e>  : 10 00                      dup.x32 sp(0)
	<.main+476 @05bd10>  : 13 02                      set.x32 sp(2)
	<.main+478 @05bd12>  : 09 fc ff ff                inc.sp(-4)
	<.main+482 @05bd16>  : 24 a0 a6 05                store.m32 <@05a6a0> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@05bd1a> - <@05bd49>): static min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+486 @05bd1a>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+490 @05bd1e>  : 0c 01 00 00                inc.i32(+1)
	<.main+494 @05bd22>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+498 @05bd26>  : 0c 01 00 00                inc.i32(+1)
	<.main+502 @05bd2a>  : 10 01                      dup.x32 sp(1)
	<.main+504 @05bd2c>  : 10 01                      dup.x32 sp(1)
	<.main+506 @05bd2e>  : 58                         clt.i32
	<.main+507 @05bd2f>  : 06 0a 00 00                jz <.main+517 @05bd39>
	<.main+511 @05bd33>  : 10 01                      dup.x32 sp(1)
	<.main+513 @05bd35>  : 04 06 00 00                jmp <.main+519 @05bd3b>
	<.main+517 @05bd39>  : 10 00                      dup.x32 sp(0)
	<.main+519 @05bd3b>  : 13 02                      set.x32 sp(2)
	<.main+521 @05bd3d>  : 09 fc ff ff                inc.sp(-4)
	<.main+525 @05bd41>  : 0c ff ff ff                inc.i32(-1)
	<.main+529 @05bd45>  : 24 a8 a6 05                store.m32 <@05a6a8> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@05bd49> - <@05bd6e>): static max2Val: int32 := max(3, 6)
	<.main+533 @05bd49>  : 1c 03 00 00 00             load.c32 3
	<.main+538 @05bd4e>  : 1c 06 00 00 00             load.c32 6
	<.main+543 @05bd53>  : 10 01                      dup.x32 sp(1)
	<.main+545 @05bd55>  : 10 01                      dup.x32 sp(1)
	<.main+547 @05bd57>  : 59                         cgt.i32
	<.main+548 @05bd58>  : 06 0a 00 00                jz <.main+558 @05bd62>
	<.main+552 @05bd5c>  : 10 01                      dup.x32 sp(1)
	<.main+554 @05bd5e>  : 04 06 00 00                jmp <.main+560 @05bd64>
	<.main+558 @05bd62>  : 10 00                      dup.x32 sp(0)
	<.main+560 @05bd64>  : 13 02                      set.x32 sp(2)
	<.main+562 @05bd66>  : 09 fc ff ff                inc.sp(-4)
	<.main+566 @05bd6a>  : 24 b0 a6 05                store.m32 <@05a6b0> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@05bd6e> - <@05bd91>): static max2Var: int32 := max(i3, i6)
	<.main+570 @05bd6e>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+574 @05bd72>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+578 @05bd76>  : 10 01                      dup.x32 sp(1)
	<.main+580 @05bd78>  : 10 01                      dup.x32 sp(1)
	<.main+582 @05bd7a>  : 59                         cgt.i32
	<.main+583 @05bd7b>  : 06 0a 00 00                jz <.main+593 @05bd85>
	<.main+587 @05bd7f>  : 10 01                      dup.x32 sp(1)
	<.main+589 @05bd81>  : 04 06 00 00                jmp <.main+595 @05bd87>
	<.main+593 @05bd85>  : 10 00                      dup.x32 sp(0)
	<.main+595 @05bd87>  : 13 02                      set.x32 sp(2)
	<.main+597 @05bd89>  : 09 fc ff ff                inc.sp(-4)
	<.main+601 @05bd8d>  : 24 b8 a6 05                store.m32 <@05a6b8> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@05bd91> - <@05bdc0>): static max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+605 @05bd91>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+609 @05bd95>  : 0c 01 00 00                inc.i32(+1)
	<.main+613 @05bd99>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+617 @05bd9d>  : 0c 01 00 00                inc.i32(+1)
	<.main+621 @05bda1>  : 10 01                      dup.x32 sp(1)
	<.main+623 @05bda3>  : 10 01                      dup.x32 sp(1)
	<.main+625 @05bda5>  : 59                         cgt.i32
	<.main+626 @05bda6>  : 06 0a 00 00                jz <.main+636 @05bdb0>
	<.main+630 @05bdaa>  : 10 01                      dup.x32 sp(1)
	<.main+632 @05bdac>  : 04 06 00 00                jmp <.main+638 @05bdb2>
	<.main+636 @05bdb0>  : 10 00                      dup.x32 sp(0)
	<.main+638 @05bdb2>  : 13 02                      set.x32 sp(2)
	<.main+640 @05bdb4>  : 09 fc ff ff                inc.sp(-4)
	<.main+644 @05bdb8>  : 0c ff ff ff                inc.i32(-1)
	<.main+648 @05bdbc>  : 24 c0 a6 05                store.m32 <@05a6c0> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@05bdc0> - <@05bdd9>): static sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+652 @05bdc0>  : 1c 03 00 00 00             load.c32 3
	<.main+657 @05bdc5>  : 1c 06 00 00 00             load.c32 6
	<.main+662 @05bdca>  : 1c 02 00 00 00             load.c32 2
	<.main+667 @05bdcf>  : 0c 08 00 00                inc.i32(+8)
	<.main+671 @05bdd3>  : 51                         add.i32
	<.main+672 @05bdd4>  : 51                         add.i32
	<.main+673 @05bdd5>  : 24 c8 a6 05                store.m32 <@05a6c8> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@05bdd9> - <@05bdee>): static sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+677 @05bdd9>  : 1c 03 00 00 00             load.c32 3
	<.main+682 @05bdde>  : 0c 06 00 00                inc.i32(+6)
	<.main+686 @05bde2>  : 0c 02 00 00                inc.i32(+2)
	<.main+690 @05bde6>  : 0c 08 00 00                inc.i32(+8)
	<.main+694 @05bdea>  : 24 d0 a6 05                store.m32 <@05a6d0> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@05bdee> - <@05be05>): static sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+698 @05bdee>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+702 @05bdf2>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+706 @05bdf6>  : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+710 @05bdfa>  : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+714 @05bdfe>  : 51                         add.i32
	<.main+715 @05bdff>  : 51                         add.i32
	<.main+716 @05be00>  : 51                         add.i32
	<.main+717 @05be01>  : 24 d8 a6 05                store.m32 <@05a6d8> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@05be05> - <@05be1c>): static sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+721 @05be05>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+725 @05be09>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+729 @05be0d>  : 51                         add.i32
	<.main+730 @05be0e>  : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+734 @05be12>  : 51                         add.i32
	<.main+735 @05be13>  : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+739 @05be17>  : 51                         add.i32
	<.main+740 @05be18>  : 24 e0 a6 05                store.m32 <@05a6e0> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@05be1c> - <@05be47>): static sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+744 @05be1c>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+748 @05be20>  : 0c 01 00 00                inc.i32(+1)
	<.main+752 @05be24>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+756 @05be28>  : 0c 01 00 00                inc.i32(+1)
	<.main+760 @05be2c>  : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+764 @05be30>  : 0c 01 00 00                inc.i32(+1)
	<.main+768 @05be34>  : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+772 @05be38>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @05be3c>  : 51                         add.i32
	<.main+777 @05be3d>  : 51                         add.i32
	<.main+778 @05be3e>  : 51                         add.i32
	<.main+779 @05be3f>  : 0c fc ff ff                inc.i32(-4)
	<.main+783 @05be43>  : 24 e8 a6 05                store.m32 <@05a6e8> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@05be47> - <@05be72>): static sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+787 @05be47>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+791 @05be4b>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @05be4f>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+799 @05be53>  : 0c 01 00 00                inc.i32(+1)
	<.main+803 @05be57>  : 51                         add.i32
	<.main+804 @05be58>  : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+808 @05be5c>  : 0c 01 00 00                inc.i32(+1)
	<.main+812 @05be60>  : 51                         add.i32
	<.main+813 @05be61>  : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+817 @05be65>  : 0c 01 00 00                inc.i32(+1)
	<.main+821 @05be69>  : 51                         add.i32
	<.main+822 @05be6a>  : 0c fc ff ff                inc.i32(-4)
	<.main+826 @05be6e>  : 24 f0 a6 05                store.m32 <@05a6f0> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@05be72> - <@05beb4>): static anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+830 @05be72>  : 1c 03 00 00 00             load.c32 3
	<.main+835 @05be77>  : 10 00                      dup.x32 sp(0)
	<.main+837 @05be79>  : 06 0a 00 00                jz <.main+847 @05be83>
	<.main+841 @05be7d>  : 10 00                      dup.x32 sp(0)
	<.main+843 @05be7f>  : 04 2f 00 00                jmp <.main+890 @05beae>
	<.main+847 @05be83>  : 1c 06 00 00 00             load.c32 6
	<.main+852 @05be88>  : 10 00                      dup.x32 sp(0)
	<.main+854 @05be8a>  : 06 0a 00 00                jz <.main+864 @05be94>
	<.main+858 @05be8e>  : 10 00                      dup.x32 sp(0)
	<.main+860 @05be90>  : 04 1c 00 00                jmp <.main+888 @05beac>
	<.main+864 @05be94>  : 1c 02 00 00 00             load.c32 2
	<.main+869 @05be99>  : 10 00                      dup.x32 sp(0)
	<.main+871 @05be9b>  : 06 0a 00 00                jz <.main+881 @05bea5>
	<.main+875 @05be9f>  : 10 00                      dup.x32 sp(0)
	<.main+877 @05bea1>  : 04 09 00 00                jmp <.main+886 @05beaa>
	<.main+881 @05bea5>  : 1c 08 00 00 00             load.c32 8
	<.main+886 @05beaa>  : 13 01                      set.x32 sp(1)
	<.main+888 @05beac>  : 13 01                      set.x32 sp(1)
	<.main+890 @05beae>  : 13 01                      set.x32 sp(1)
	<.main+892 @05beb0>  : 24 f8 a6 05                store.m32 <@05a6f8> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@05beb4> - <@05bef6>): static anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+896 @05beb4>  : 1c 03 00 00 00             load.c32 3
	<.main+901 @05beb9>  : 10 00                      dup.x32 sp(0)
	<.main+903 @05bebb>  : 06 0a 00 00                jz <.main+913 @05bec5>
	<.main+907 @05bebf>  : 10 00                      dup.x32 sp(0)
	<.main+909 @05bec1>  : 04 09 00 00                jmp <.main+918 @05beca>
	<.main+913 @05bec5>  : 1c 06 00 00 00             load.c32 6
	<.main+918 @05beca>  : 13 01                      set.x32 sp(1)
	<.main+920 @05becc>  : 10 00                      dup.x32 sp(0)
	<.main+922 @05bece>  : 06 0a 00 00                jz <.main+932 @05bed8>
	<.main+926 @05bed2>  : 10 00                      dup.x32 sp(0)
	<.main+928 @05bed4>  : 04 09 00 00                jmp <.main+937 @05bedd>
	<.main+932 @05bed8>  : 1c 02 00 00 00             load.c32 2
	<.main+937 @05bedd>  : 13 01                      set.x32 sp(1)
	<.main+939 @05bedf>  : 10 00                      dup.x32 sp(0)
	<.main+941 @05bee1>  : 06 0a 00 00                jz <.main+951 @05beeb>
	<.main+945 @05bee5>  : 10 00                      dup.x32 sp(0)
	<.main+947 @05bee7>  : 04 09 00 00                jmp <.main+956 @05bef0>
	<.main+951 @05beeb>  : 1c 08 00 00 00             load.c32 8
	<.main+956 @05bef0>  : 13 01                      set.x32 sp(1)
	<.main+958 @05bef2>  : 24 00 a7 05                store.m32 <@05a700> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@05bef6> - <@05bf34>): static anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+962 @05bef6>  : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+966 @05befa>  : 10 00                      dup.x32 sp(0)
	<.main+968 @05befc>  : 06 0a 00 00                jz <.main+978 @05bf06>
	<.main+972 @05bf00>  : 10 00                      dup.x32 sp(0)
	<.main+974 @05bf02>  : 04 2c 00 00                jmp <.main+1018 @05bf2e>
	<.main+978 @05bf06>  : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+982 @05bf0a>  : 10 00                      dup.x32 sp(0)
	<.main+984 @05bf0c>  : 06 0a 00 00                jz <.main+994 @05bf16>
	<.main+988 @05bf10>  : 10 00                      dup.x32 sp(0)
	<.main+990 @05bf12>  : 04 1a 00 00                jmp <.main+1016 @05bf2c>
	<.main+994 @05bf16>  : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+998 @05bf1a>  : 10 00                      dup.x32 sp(0)
	<.main+1000 @05bf1c> : 06 0a 00 00                jz <.main+1010 @05bf26>
	<.main+1004 @05bf20> : 10 00                      dup.x32 sp(0)
	<.main+1006 @05bf22> : 04 08 00 00                jmp <.main+1014 @05bf2a>
	<.main+1010 @05bf26> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1014 @05bf2a> : 13 01                      set.x32 sp(1)
	<.main+1016 @05bf2c> : 13 01                      set.x32 sp(1)
	<.main+1018 @05bf2e> : 13 01                      set.x32 sp(1)
	<.main+1020 @05bf30> : 24 08 a7 05                store.m32 <@05a708> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@05bf34> - <@05bf72>): static anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+1024 @05bf34> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1028 @05bf38> : 10 00                      dup.x32 sp(0)
	<.main+1030 @05bf3a> : 06 0a 00 00                jz <.main+1040 @05bf44>
	<.main+1034 @05bf3e> : 10 00                      dup.x32 sp(0)
	<.main+1036 @05bf40> : 04 08 00 00                jmp <.main+1044 @05bf48>
	<.main+1040 @05bf44> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1044 @05bf48> : 13 01                      set.x32 sp(1)
	<.main+1046 @05bf4a> : 10 00                      dup.x32 sp(0)
	<.main+1048 @05bf4c> : 06 0a 00 00                jz <.main+1058 @05bf56>
	<.main+1052 @05bf50> : 10 00                      dup.x32 sp(0)
	<.main+1054 @05bf52> : 04 08 00 00                jmp <.main+1062 @05bf5a>
	<.main+1058 @05bf56> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1062 @05bf5a> : 13 01                      set.x32 sp(1)
	<.main+1064 @05bf5c> : 10 00                      dup.x32 sp(0)
	<.main+1066 @05bf5e> : 06 0a 00 00                jz <.main+1076 @05bf68>
	<.main+1070 @05bf62> : 10 00                      dup.x32 sp(0)
	<.main+1072 @05bf64> : 04 08 00 00                jmp <.main+1080 @05bf6c>
	<.main+1076 @05bf68> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1080 @05bf6c> : 13 01                      set.x32 sp(1)
	<.main+1082 @05bf6e> : 24 10 a7 05                store.m32 <@05a710> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@05bf72> - <@05bfc4>): static anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1086 @05bf72> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1090 @05bf76> : 0c 01 00 00                inc.i32(+1)
	<.main+1094 @05bf7a> : 10 00                      dup.x32 sp(0)
	<.main+1096 @05bf7c> : 06 0a 00 00                jz <.main+1106 @05bf86>
	<.main+1100 @05bf80> : 10 00                      dup.x32 sp(0)
	<.main+1102 @05bf82> : 04 38 00 00                jmp <.main+1158 @05bfba>
	<.main+1106 @05bf86> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1110 @05bf8a> : 0c 01 00 00                inc.i32(+1)
	<.main+1114 @05bf8e> : 10 00                      dup.x32 sp(0)
	<.main+1116 @05bf90> : 06 0a 00 00                jz <.main+1126 @05bf9a>
	<.main+1120 @05bf94> : 10 00                      dup.x32 sp(0)
	<.main+1122 @05bf96> : 04 22 00 00                jmp <.main+1156 @05bfb8>
	<.main+1126 @05bf9a> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1130 @05bf9e> : 0c 01 00 00                inc.i32(+1)
	<.main+1134 @05bfa2> : 10 00                      dup.x32 sp(0)
	<.main+1136 @05bfa4> : 06 0a 00 00                jz <.main+1146 @05bfae>
	<.main+1140 @05bfa8> : 10 00                      dup.x32 sp(0)
	<.main+1142 @05bfaa> : 04 0c 00 00                jmp <.main+1154 @05bfb6>
	<.main+1146 @05bfae> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1150 @05bfb2> : 0c 01 00 00                inc.i32(+1)
	<.main+1154 @05bfb6> : 13 01                      set.x32 sp(1)
	<.main+1156 @05bfb8> : 13 01                      set.x32 sp(1)
	<.main+1158 @05bfba> : 13 01                      set.x32 sp(1)
	<.main+1160 @05bfbc> : 0c ff ff ff                inc.i32(-1)
	<.main+1164 @05bfc0> : 24 18 a7 05                store.m32 <@05a718> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@05bfc4> - <@05c016>): static anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1168 @05bfc4> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1172 @05bfc8> : 0c 01 00 00                inc.i32(+1)
	<.main+1176 @05bfcc> : 10 00                      dup.x32 sp(0)
	<.main+1178 @05bfce> : 06 0a 00 00                jz <.main+1188 @05bfd8>
	<.main+1182 @05bfd2> : 10 00                      dup.x32 sp(0)
	<.main+1184 @05bfd4> : 04 0c 00 00                jmp <.main+1196 @05bfe0>
	<.main+1188 @05bfd8> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1192 @05bfdc> : 0c 01 00 00                inc.i32(+1)
	<.main+1196 @05bfe0> : 13 01                      set.x32 sp(1)
	<.main+1198 @05bfe2> : 10 00                      dup.x32 sp(0)
	<.main+1200 @05bfe4> : 06 0a 00 00                jz <.main+1210 @05bfee>
	<.main+1204 @05bfe8> : 10 00                      dup.x32 sp(0)
	<.main+1206 @05bfea> : 04 0c 00 00                jmp <.main+1218 @05bff6>
	<.main+1210 @05bfee> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1214 @05bff2> : 0c 01 00 00                inc.i32(+1)
	<.main+1218 @05bff6> : 13 01                      set.x32 sp(1)
	<.main+1220 @05bff8> : 10 00                      dup.x32 sp(0)
	<.main+1222 @05bffa> : 06 0a 00 00                jz <.main+1232 @05c004>
	<.main+1226 @05bffe> : 10 00                      dup.x32 sp(0)
	<.main+1228 @05c000> : 04 0c 00 00                jmp <.main+1240 @05c00c>
	<.main+1232 @05c004> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1236 @05c008> : 0c 01 00 00                inc.i32(+1)
	<.main+1240 @05c00c> : 13 01                      set.x32 sp(1)
	<.main+1242 @05c00e> : 0c ff ff ff                inc.i32(-1)
	<.main+1246 @05c012> : 24 20 a7 05                store.m32 <@05a720> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@05c016> - <@05c073>): static minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+1250 @05c016> : 1c 03 00 00 00             load.c32 3
	<.main+1255 @05c01b> : 1c 06 00 00 00             load.c32 6
	<.main+1260 @05c020> : 1c 02 00 00 00             load.c32 2
	<.main+1265 @05c025> : 1c 08 00 00 00             load.c32 8
	<.main+1270 @05c02a> : 10 01                      dup.x32 sp(1)
	<.main+1272 @05c02c> : 10 01                      dup.x32 sp(1)
	<.main+1274 @05c02e> : 58                         clt.i32
	<.main+1275 @05c02f> : 06 0a 00 00                jz <.main+1285 @05c039>
	<.main+1279 @05c033> : 10 01                      dup.x32 sp(1)
	<.main+1281 @05c035> : 04 06 00 00                jmp <.main+1287 @05c03b>
	<.main+1285 @05c039> : 10 00                      dup.x32 sp(0)
	<.main+1287 @05c03b> : 13 02                      set.x32 sp(2)
	<.main+1289 @05c03d> : 09 fc ff ff                inc.sp(-4)
	<.main+1293 @05c041> : 10 01                      dup.x32 sp(1)
	<.main+1295 @05c043> : 10 01                      dup.x32 sp(1)
	<.main+1297 @05c045> : 58                         clt.i32
	<.main+1298 @05c046> : 06 0a 00 00                jz <.main+1308 @05c050>
	<.main+1302 @05c04a> : 10 01                      dup.x32 sp(1)
	<.main+1304 @05c04c> : 04 06 00 00                jmp <.main+1310 @05c052>
	<.main+1308 @05c050> : 10 00                      dup.x32 sp(0)
	<.main+1310 @05c052> : 13 02                      set.x32 sp(2)
	<.main+1312 @05c054> : 09 fc ff ff                inc.sp(-4)
	<.main+1316 @05c058> : 10 01                      dup.x32 sp(1)
	<.main+1318 @05c05a> : 10 01                      dup.x32 sp(1)
	<.main+1320 @05c05c> : 58                         clt.i32
	<.main+1321 @05c05d> : 06 0a 00 00                jz <.main+1331 @05c067>
	<.main+1325 @05c061> : 10 01                      dup.x32 sp(1)
	<.main+1327 @05c063> : 04 06 00 00                jmp <.main+1333 @05c069>
	<.main+1331 @05c067> : 10 00                      dup.x32 sp(0)
	<.main+1333 @05c069> : 13 02                      set.x32 sp(2)
	<.main+1335 @05c06b> : 09 fc ff ff                inc.sp(-4)
	<.main+1339 @05c06f> : 24 28 a7 05                store.m32 <@05a728> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@05c073> - <@05c0d0>): static minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+1343 @05c073> : 1c 03 00 00 00             load.c32 3
	<.main+1348 @05c078> : 1c 06 00 00 00             load.c32 6
	<.main+1353 @05c07d> : 10 01                      dup.x32 sp(1)
	<.main+1355 @05c07f> : 10 01                      dup.x32 sp(1)
	<.main+1357 @05c081> : 58                         clt.i32
	<.main+1358 @05c082> : 06 0a 00 00                jz <.main+1368 @05c08c>
	<.main+1362 @05c086> : 10 01                      dup.x32 sp(1)
	<.main+1364 @05c088> : 04 06 00 00                jmp <.main+1370 @05c08e>
	<.main+1368 @05c08c> : 10 00                      dup.x32 sp(0)
	<.main+1370 @05c08e> : 13 02                      set.x32 sp(2)
	<.main+1372 @05c090> : 09 fc ff ff                inc.sp(-4)
	<.main+1376 @05c094> : 1c 02 00 00 00             load.c32 2
	<.main+1381 @05c099> : 10 01                      dup.x32 sp(1)
	<.main+1383 @05c09b> : 10 01                      dup.x32 sp(1)
	<.main+1385 @05c09d> : 58                         clt.i32
	<.main+1386 @05c09e> : 06 0a 00 00                jz <.main+1396 @05c0a8>
	<.main+1390 @05c0a2> : 10 01                      dup.x32 sp(1)
	<.main+1392 @05c0a4> : 04 06 00 00                jmp <.main+1398 @05c0aa>
	<.main+1396 @05c0a8> : 10 00                      dup.x32 sp(0)
	<.main+1398 @05c0aa> : 13 02                      set.x32 sp(2)
	<.main+1400 @05c0ac> : 09 fc ff ff                inc.sp(-4)
	<.main+1404 @05c0b0> : 1c 08 00 00 00             load.c32 8
	<.main+1409 @05c0b5> : 10 01                      dup.x32 sp(1)
	<.main+1411 @05c0b7> : 10 01                      dup.x32 sp(1)
	<.main+1413 @05c0b9> : 58                         clt.i32
	<.main+1414 @05c0ba> : 06 0a 00 00                jz <.main+1424 @05c0c4>
	<.main+1418 @05c0be> : 10 01                      dup.x32 sp(1)
	<.main+1420 @05c0c0> : 04 06 00 00                jmp <.main+1426 @05c0c6>
	<.main+1424 @05c0c4> : 10 00                      dup.x32 sp(0)
	<.main+1426 @05c0c6> : 13 02                      set.x32 sp(2)
	<.main+1428 @05c0c8> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @05c0cc> : 24 30 a7 05                store.m32 <@05a730> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@05c0d0> - <@05c129>): static minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+1436 @05c0d0> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1440 @05c0d4> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1444 @05c0d8> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1448 @05c0dc> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1452 @05c0e0> : 10 01                      dup.x32 sp(1)
	<.main+1454 @05c0e2> : 10 01                      dup.x32 sp(1)
	<.main+1456 @05c0e4> : 58                         clt.i32
	<.main+1457 @05c0e5> : 06 0a 00 00                jz <.main+1467 @05c0ef>
	<.main+1461 @05c0e9> : 10 01                      dup.x32 sp(1)
	<.main+1463 @05c0eb> : 04 06 00 00                jmp <.main+1469 @05c0f1>
	<.main+1467 @05c0ef> : 10 00                      dup.x32 sp(0)
	<.main+1469 @05c0f1> : 13 02                      set.x32 sp(2)
	<.main+1471 @05c0f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1475 @05c0f7> : 10 01                      dup.x32 sp(1)
	<.main+1477 @05c0f9> : 10 01                      dup.x32 sp(1)
	<.main+1479 @05c0fb> : 58                         clt.i32
	<.main+1480 @05c0fc> : 06 0a 00 00                jz <.main+1490 @05c106>
	<.main+1484 @05c100> : 10 01                      dup.x32 sp(1)
	<.main+1486 @05c102> : 04 06 00 00                jmp <.main+1492 @05c108>
	<.main+1490 @05c106> : 10 00                      dup.x32 sp(0)
	<.main+1492 @05c108> : 13 02                      set.x32 sp(2)
	<.main+1494 @05c10a> : 09 fc ff ff                inc.sp(-4)
	<.main+1498 @05c10e> : 10 01                      dup.x32 sp(1)
	<.main+1500 @05c110> : 10 01                      dup.x32 sp(1)
	<.main+1502 @05c112> : 58                         clt.i32
	<.main+1503 @05c113> : 06 0a 00 00                jz <.main+1513 @05c11d>
	<.main+1507 @05c117> : 10 01                      dup.x32 sp(1)
	<.main+1509 @05c119> : 04 06 00 00                jmp <.main+1515 @05c11f>
	<.main+1513 @05c11d> : 10 00                      dup.x32 sp(0)
	<.main+1515 @05c11f> : 13 02                      set.x32 sp(2)
	<.main+1517 @05c121> : 09 fc ff ff                inc.sp(-4)
	<.main+1521 @05c125> : 24 38 a7 05                store.m32 <@05a738> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@05c129> - <@05c182>): static minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+1525 @05c129> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1529 @05c12d> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1533 @05c131> : 10 01                      dup.x32 sp(1)
	<.main+1535 @05c133> : 10 01                      dup.x32 sp(1)
	<.main+1537 @05c135> : 58                         clt.i32
	<.main+1538 @05c136> : 06 0a 00 00                jz <.main+1548 @05c140>
	<.main+1542 @05c13a> : 10 01                      dup.x32 sp(1)
	<.main+1544 @05c13c> : 04 06 00 00                jmp <.main+1550 @05c142>
	<.main+1548 @05c140> : 10 00                      dup.x32 sp(0)
	<.main+1550 @05c142> : 13 02                      set.x32 sp(2)
	<.main+1552 @05c144> : 09 fc ff ff                inc.sp(-4)
	<.main+1556 @05c148> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1560 @05c14c> : 10 01                      dup.x32 sp(1)
	<.main+1562 @05c14e> : 10 01                      dup.x32 sp(1)
	<.main+1564 @05c150> : 58                         clt.i32
	<.main+1565 @05c151> : 06 0a 00 00                jz <.main+1575 @05c15b>
	<.main+1569 @05c155> : 10 01                      dup.x32 sp(1)
	<.main+1571 @05c157> : 04 06 00 00                jmp <.main+1577 @05c15d>
	<.main+1575 @05c15b> : 10 00                      dup.x32 sp(0)
	<.main+1577 @05c15d> : 13 02                      set.x32 sp(2)
	<.main+1579 @05c15f> : 09 fc ff ff                inc.sp(-4)
	<.main+1583 @05c163> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1587 @05c167> : 10 01                      dup.x32 sp(1)
	<.main+1589 @05c169> : 10 01                      dup.x32 sp(1)
	<.main+1591 @05c16b> : 58                         clt.i32
	<.main+1592 @05c16c> : 06 0a 00 00                jz <.main+1602 @05c176>
	<.main+1596 @05c170> : 10 01                      dup.x32 sp(1)
	<.main+1598 @05c172> : 04 06 00 00                jmp <.main+1604 @05c178>
	<.main+1602 @05c176> : 10 00                      dup.x32 sp(0)
	<.main+1604 @05c178> : 13 02                      set.x32 sp(2)
	<.main+1606 @05c17a> : 09 fc ff ff                inc.sp(-4)
	<.main+1610 @05c17e> : 24 40 a7 05                store.m32 <@05a740> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@05c182> - <@05c1ef>): static minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1614 @05c182> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1618 @05c186> : 0c 01 00 00                inc.i32(+1)
	<.main+1622 @05c18a> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1626 @05c18e> : 0c 01 00 00                inc.i32(+1)
	<.main+1630 @05c192> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1634 @05c196> : 0c 01 00 00                inc.i32(+1)
	<.main+1638 @05c19a> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1642 @05c19e> : 0c 01 00 00                inc.i32(+1)
	<.main+1646 @05c1a2> : 10 01                      dup.x32 sp(1)
	<.main+1648 @05c1a4> : 10 01                      dup.x32 sp(1)
	<.main+1650 @05c1a6> : 58                         clt.i32
	<.main+1651 @05c1a7> : 06 0a 00 00                jz <.main+1661 @05c1b1>
	<.main+1655 @05c1ab> : 10 01                      dup.x32 sp(1)
	<.main+1657 @05c1ad> : 04 06 00 00                jmp <.main+1663 @05c1b3>
	<.main+1661 @05c1b1> : 10 00                      dup.x32 sp(0)
	<.main+1663 @05c1b3> : 13 02                      set.x32 sp(2)
	<.main+1665 @05c1b5> : 09 fc ff ff                inc.sp(-4)
	<.main+1669 @05c1b9> : 10 01                      dup.x32 sp(1)
	<.main+1671 @05c1bb> : 10 01                      dup.x32 sp(1)
	<.main+1673 @05c1bd> : 58                         clt.i32
	<.main+1674 @05c1be> : 06 0a 00 00                jz <.main+1684 @05c1c8>
	<.main+1678 @05c1c2> : 10 01                      dup.x32 sp(1)
	<.main+1680 @05c1c4> : 04 06 00 00                jmp <.main+1686 @05c1ca>
	<.main+1684 @05c1c8> : 10 00                      dup.x32 sp(0)
	<.main+1686 @05c1ca> : 13 02                      set.x32 sp(2)
	<.main+1688 @05c1cc> : 09 fc ff ff                inc.sp(-4)
	<.main+1692 @05c1d0> : 10 01                      dup.x32 sp(1)
	<.main+1694 @05c1d2> : 10 01                      dup.x32 sp(1)
	<.main+1696 @05c1d4> : 58                         clt.i32
	<.main+1697 @05c1d5> : 06 0a 00 00                jz <.main+1707 @05c1df>
	<.main+1701 @05c1d9> : 10 01                      dup.x32 sp(1)
	<.main+1703 @05c1db> : 04 06 00 00                jmp <.main+1709 @05c1e1>
	<.main+1707 @05c1df> : 10 00                      dup.x32 sp(0)
	<.main+1709 @05c1e1> : 13 02                      set.x32 sp(2)
	<.main+1711 @05c1e3> : 09 fc ff ff                inc.sp(-4)
	<.main+1715 @05c1e7> : 0c ff ff ff                inc.i32(-1)
	<.main+1719 @05c1eb> : 24 48 a7 05                store.m32 <@05a748> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@05c1ef> - <@05c25c>): static minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1723 @05c1ef> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+1727 @05c1f3> : 0c 01 00 00                inc.i32(+1)
	<.main+1731 @05c1f7> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+1735 @05c1fb> : 0c 01 00 00                inc.i32(+1)
	<.main+1739 @05c1ff> : 10 01                      dup.x32 sp(1)
	<.main+1741 @05c201> : 10 01                      dup.x32 sp(1)
	<.main+1743 @05c203> : 58                         clt.i32
	<.main+1744 @05c204> : 06 0a 00 00                jz <.main+1754 @05c20e>
	<.main+1748 @05c208> : 10 01                      dup.x32 sp(1)
	<.main+1750 @05c20a> : 04 06 00 00                jmp <.main+1756 @05c210>
	<.main+1754 @05c20e> : 10 00                      dup.x32 sp(0)
	<.main+1756 @05c210> : 13 02                      set.x32 sp(2)
	<.main+1758 @05c212> : 09 fc ff ff                inc.sp(-4)
	<.main+1762 @05c216> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+1766 @05c21a> : 0c 01 00 00                inc.i32(+1)
	<.main+1770 @05c21e> : 10 01                      dup.x32 sp(1)
	<.main+1772 @05c220> : 10 01                      dup.x32 sp(1)
	<.main+1774 @05c222> : 58                         clt.i32
	<.main+1775 @05c223> : 06 0a 00 00                jz <.main+1785 @05c22d>
	<.main+1779 @05c227> : 10 01                      dup.x32 sp(1)
	<.main+1781 @05c229> : 04 06 00 00                jmp <.main+1787 @05c22f>
	<.main+1785 @05c22d> : 10 00                      dup.x32 sp(0)
	<.main+1787 @05c22f> : 13 02                      set.x32 sp(2)
	<.main+1789 @05c231> : 09 fc ff ff                inc.sp(-4)
	<.main+1793 @05c235> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+1797 @05c239> : 0c 01 00 00                inc.i32(+1)
	<.main+1801 @05c23d> : 10 01                      dup.x32 sp(1)
	<.main+1803 @05c23f> : 10 01                      dup.x32 sp(1)
	<.main+1805 @05c241> : 58                         clt.i32
	<.main+1806 @05c242> : 06 0a 00 00                jz <.main+1816 @05c24c>
	<.main+1810 @05c246> : 10 01                      dup.x32 sp(1)
	<.main+1812 @05c248> : 04 06 00 00                jmp <.main+1818 @05c24e>
	<.main+1816 @05c24c> : 10 00                      dup.x32 sp(0)
	<.main+1818 @05c24e> : 13 02                      set.x32 sp(2)
	<.main+1820 @05c250> : 09 fc ff ff                inc.sp(-4)
	<.main+1824 @05c254> : 0c ff ff ff                inc.i32(-1)
	<.main+1828 @05c258> : 24 50 a7 05                store.m32 <@05a750> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@05c25c> - <@05c2b9>): static maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+1832 @05c25c> : 1c 03 00 00 00             load.c32 3
	<.main+1837 @05c261> : 1c 06 00 00 00             load.c32 6
	<.main+1842 @05c266> : 1c 02 00 00 00             load.c32 2
	<.main+1847 @05c26b> : 1c 08 00 00 00             load.c32 8
	<.main+1852 @05c270> : 10 01                      dup.x32 sp(1)
	<.main+1854 @05c272> : 10 01                      dup.x32 sp(1)
	<.main+1856 @05c274> : 59                         cgt.i32
	<.main+1857 @05c275> : 06 0a 00 00                jz <.main+1867 @05c27f>
	<.main+1861 @05c279> : 10 01                      dup.x32 sp(1)
	<.main+1863 @05c27b> : 04 06 00 00                jmp <.main+1869 @05c281>
	<.main+1867 @05c27f> : 10 00                      dup.x32 sp(0)
	<.main+1869 @05c281> : 13 02                      set.x32 sp(2)
	<.main+1871 @05c283> : 09 fc ff ff                inc.sp(-4)
	<.main+1875 @05c287> : 10 01                      dup.x32 sp(1)
	<.main+1877 @05c289> : 10 01                      dup.x32 sp(1)
	<.main+1879 @05c28b> : 59                         cgt.i32
	<.main+1880 @05c28c> : 06 0a 00 00                jz <.main+1890 @05c296>
	<.main+1884 @05c290> : 10 01                      dup.x32 sp(1)
	<.main+1886 @05c292> : 04 06 00 00                jmp <.main+1892 @05c298>
	<.main+1890 @05c296> : 10 00                      dup.x32 sp(0)
	<.main+1892 @05c298> : 13 02                      set.x32 sp(2)
	<.main+1894 @05c29a> : 09 fc ff ff                inc.sp(-4)
	<.main+1898 @05c29e> : 10 01                      dup.x32 sp(1)
	<.main+1900 @05c2a0> : 10 01                      dup.x32 sp(1)
	<.main+1902 @05c2a2> : 59                         cgt.i32
	<.main+1903 @05c2a3> : 06 0a 00 00                jz <.main+1913 @05c2ad>
	<.main+1907 @05c2a7> : 10 01                      dup.x32 sp(1)
	<.main+1909 @05c2a9> : 04 06 00 00                jmp <.main+1915 @05c2af>
	<.main+1913 @05c2ad> : 10 00                      dup.x32 sp(0)
	<.main+1915 @05c2af> : 13 02                      set.x32 sp(2)
	<.main+1917 @05c2b1> : 09 fc ff ff                inc.sp(-4)
	<.main+1921 @05c2b5> : 24 58 a7 05                store.m32 <@05a758> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@05c2b9> - <@05c316>): static maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+1925 @05c2b9> : 1c 03 00 00 00             load.c32 3
	<.main+1930 @05c2be> : 1c 06 00 00 00             load.c32 6
	<.main+1935 @05c2c3> : 10 01                      dup.x32 sp(1)
	<.main+1937 @05c2c5> : 10 01                      dup.x32 sp(1)
	<.main+1939 @05c2c7> : 59                         cgt.i32
	<.main+1940 @05c2c8> : 06 0a 00 00                jz <.main+1950 @05c2d2>
	<.main+1944 @05c2cc> : 10 01                      dup.x32 sp(1)
	<.main+1946 @05c2ce> : 04 06 00 00                jmp <.main+1952 @05c2d4>
	<.main+1950 @05c2d2> : 10 00                      dup.x32 sp(0)
	<.main+1952 @05c2d4> : 13 02                      set.x32 sp(2)
	<.main+1954 @05c2d6> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @05c2da> : 1c 02 00 00 00             load.c32 2
	<.main+1963 @05c2df> : 10 01                      dup.x32 sp(1)
	<.main+1965 @05c2e1> : 10 01                      dup.x32 sp(1)
	<.main+1967 @05c2e3> : 59                         cgt.i32
	<.main+1968 @05c2e4> : 06 0a 00 00                jz <.main+1978 @05c2ee>
	<.main+1972 @05c2e8> : 10 01                      dup.x32 sp(1)
	<.main+1974 @05c2ea> : 04 06 00 00                jmp <.main+1980 @05c2f0>
	<.main+1978 @05c2ee> : 10 00                      dup.x32 sp(0)
	<.main+1980 @05c2f0> : 13 02                      set.x32 sp(2)
	<.main+1982 @05c2f2> : 09 fc ff ff                inc.sp(-4)
	<.main+1986 @05c2f6> : 1c 08 00 00 00             load.c32 8
	<.main+1991 @05c2fb> : 10 01                      dup.x32 sp(1)
	<.main+1993 @05c2fd> : 10 01                      dup.x32 sp(1)
	<.main+1995 @05c2ff> : 59                         cgt.i32
	<.main+1996 @05c300> : 06 0a 00 00                jz <.main+2006 @05c30a>
	<.main+2000 @05c304> : 10 01                      dup.x32 sp(1)
	<.main+2002 @05c306> : 04 06 00 00                jmp <.main+2008 @05c30c>
	<.main+2006 @05c30a> : 10 00                      dup.x32 sp(0)
	<.main+2008 @05c30c> : 13 02                      set.x32 sp(2)
	<.main+2010 @05c30e> : 09 fc ff ff                inc.sp(-4)
	<.main+2014 @05c312> : 24 60 a7 05                store.m32 <@05a760> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@05c316> - <@05c36f>): static maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+2018 @05c316> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+2022 @05c31a> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+2026 @05c31e> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+2030 @05c322> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+2034 @05c326> : 10 01                      dup.x32 sp(1)
	<.main+2036 @05c328> : 10 01                      dup.x32 sp(1)
	<.main+2038 @05c32a> : 59                         cgt.i32
	<.main+2039 @05c32b> : 06 0a 00 00                jz <.main+2049 @05c335>
	<.main+2043 @05c32f> : 10 01                      dup.x32 sp(1)
	<.main+2045 @05c331> : 04 06 00 00                jmp <.main+2051 @05c337>
	<.main+2049 @05c335> : 10 00                      dup.x32 sp(0)
	<.main+2051 @05c337> : 13 02                      set.x32 sp(2)
	<.main+2053 @05c339> : 09 fc ff ff                inc.sp(-4)
	<.main+2057 @05c33d> : 10 01                      dup.x32 sp(1)
	<.main+2059 @05c33f> : 10 01                      dup.x32 sp(1)
	<.main+2061 @05c341> : 59                         cgt.i32
	<.main+2062 @05c342> : 06 0a 00 00                jz <.main+2072 @05c34c>
	<.main+2066 @05c346> : 10 01                      dup.x32 sp(1)
	<.main+2068 @05c348> : 04 06 00 00                jmp <.main+2074 @05c34e>
	<.main+2072 @05c34c> : 10 00                      dup.x32 sp(0)
	<.main+2074 @05c34e> : 13 02                      set.x32 sp(2)
	<.main+2076 @05c350> : 09 fc ff ff                inc.sp(-4)
	<.main+2080 @05c354> : 10 01                      dup.x32 sp(1)
	<.main+2082 @05c356> : 10 01                      dup.x32 sp(1)
	<.main+2084 @05c358> : 59                         cgt.i32
	<.main+2085 @05c359> : 06 0a 00 00                jz <.main+2095 @05c363>
	<.main+2089 @05c35d> : 10 01                      dup.x32 sp(1)
	<.main+2091 @05c35f> : 04 06 00 00                jmp <.main+2097 @05c365>
	<.main+2095 @05c363> : 10 00                      dup.x32 sp(0)
	<.main+2097 @05c365> : 13 02                      set.x32 sp(2)
	<.main+2099 @05c367> : 09 fc ff ff                inc.sp(-4)
	<.main+2103 @05c36b> : 24 68 a7 05                store.m32 <@05a768> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@05c36f> - <@05c3c8>): static maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+2107 @05c36f> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+2111 @05c373> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+2115 @05c377> : 10 01                      dup.x32 sp(1)
	<.main+2117 @05c379> : 10 01                      dup.x32 sp(1)
	<.main+2119 @05c37b> : 59                         cgt.i32
	<.main+2120 @05c37c> : 06 0a 00 00                jz <.main+2130 @05c386>
	<.main+2124 @05c380> : 10 01                      dup.x32 sp(1)
	<.main+2126 @05c382> : 04 06 00 00                jmp <.main+2132 @05c388>
	<.main+2130 @05c386> : 10 00                      dup.x32 sp(0)
	<.main+2132 @05c388> : 13 02                      set.x32 sp(2)
	<.main+2134 @05c38a> : 09 fc ff ff                inc.sp(-4)
	<.main+2138 @05c38e> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+2142 @05c392> : 10 01                      dup.x32 sp(1)
	<.main+2144 @05c394> : 10 01                      dup.x32 sp(1)
	<.main+2146 @05c396> : 59                         cgt.i32
	<.main+2147 @05c397> : 06 0a 00 00                jz <.main+2157 @05c3a1>
	<.main+2151 @05c39b> : 10 01                      dup.x32 sp(1)
	<.main+2153 @05c39d> : 04 06 00 00                jmp <.main+2159 @05c3a3>
	<.main+2157 @05c3a1> : 10 00                      dup.x32 sp(0)
	<.main+2159 @05c3a3> : 13 02                      set.x32 sp(2)
	<.main+2161 @05c3a5> : 09 fc ff ff                inc.sp(-4)
	<.main+2165 @05c3a9> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+2169 @05c3ad> : 10 01                      dup.x32 sp(1)
	<.main+2171 @05c3af> : 10 01                      dup.x32 sp(1)
	<.main+2173 @05c3b1> : 59                         cgt.i32
	<.main+2174 @05c3b2> : 06 0a 00 00                jz <.main+2184 @05c3bc>
	<.main+2178 @05c3b6> : 10 01                      dup.x32 sp(1)
	<.main+2180 @05c3b8> : 04 06 00 00                jmp <.main+2186 @05c3be>
	<.main+2184 @05c3bc> : 10 00                      dup.x32 sp(0)
	<.main+2186 @05c3be> : 13 02                      set.x32 sp(2)
	<.main+2188 @05c3c0> : 09 fc ff ff                inc.sp(-4)
	<.main+2192 @05c3c4> : 24 70 a7 05                store.m32 <@05a770> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@05c3c8> - <@05c435>): static maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2196 @05c3c8> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+2200 @05c3cc> : 0c 01 00 00                inc.i32(+1)
	<.main+2204 @05c3d0> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+2208 @05c3d4> : 0c 01 00 00                inc.i32(+1)
	<.main+2212 @05c3d8> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+2216 @05c3dc> : 0c 01 00 00                inc.i32(+1)
	<.main+2220 @05c3e0> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+2224 @05c3e4> : 0c 01 00 00                inc.i32(+1)
	<.main+2228 @05c3e8> : 10 01                      dup.x32 sp(1)
	<.main+2230 @05c3ea> : 10 01                      dup.x32 sp(1)
	<.main+2232 @05c3ec> : 59                         cgt.i32
	<.main+2233 @05c3ed> : 06 0a 00 00                jz <.main+2243 @05c3f7>
	<.main+2237 @05c3f1> : 10 01                      dup.x32 sp(1)
	<.main+2239 @05c3f3> : 04 06 00 00                jmp <.main+2245 @05c3f9>
	<.main+2243 @05c3f7> : 10 00                      dup.x32 sp(0)
	<.main+2245 @05c3f9> : 13 02                      set.x32 sp(2)
	<.main+2247 @05c3fb> : 09 fc ff ff                inc.sp(-4)
	<.main+2251 @05c3ff> : 10 01                      dup.x32 sp(1)
	<.main+2253 @05c401> : 10 01                      dup.x32 sp(1)
	<.main+2255 @05c403> : 59                         cgt.i32
	<.main+2256 @05c404> : 06 0a 00 00                jz <.main+2266 @05c40e>
	<.main+2260 @05c408> : 10 01                      dup.x32 sp(1)
	<.main+2262 @05c40a> : 04 06 00 00                jmp <.main+2268 @05c410>
	<.main+2266 @05c40e> : 10 00                      dup.x32 sp(0)
	<.main+2268 @05c410> : 13 02                      set.x32 sp(2)
	<.main+2270 @05c412> : 09 fc ff ff                inc.sp(-4)
	<.main+2274 @05c416> : 10 01                      dup.x32 sp(1)
	<.main+2276 @05c418> : 10 01                      dup.x32 sp(1)
	<.main+2278 @05c41a> : 59                         cgt.i32
	<.main+2279 @05c41b> : 06 0a 00 00                jz <.main+2289 @05c425>
	<.main+2283 @05c41f> : 10 01                      dup.x32 sp(1)
	<.main+2285 @05c421> : 04 06 00 00                jmp <.main+2291 @05c427>
	<.main+2289 @05c425> : 10 00                      dup.x32 sp(0)
	<.main+2291 @05c427> : 13 02                      set.x32 sp(2)
	<.main+2293 @05c429> : 09 fc ff ff                inc.sp(-4)
	<.main+2297 @05c42d> : 0c ff ff ff                inc.i32(-1)
	<.main+2301 @05c431> : 24 78 a7 05                store.m32 <@05a778> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@05c435> - <@05c4a2>): static maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2305 @05c435> : 20 18 a6 05                load.m32 <@05a618> ;i3
	<.main+2309 @05c439> : 0c 01 00 00                inc.i32(+1)
	<.main+2313 @05c43d> : 20 20 a6 05                load.m32 <@05a620> ;i6
	<.main+2317 @05c441> : 0c 01 00 00                inc.i32(+1)
	<.main+2321 @05c445> : 10 01                      dup.x32 sp(1)
	<.main+2323 @05c447> : 10 01                      dup.x32 sp(1)
	<.main+2325 @05c449> : 59                         cgt.i32
	<.main+2326 @05c44a> : 06 0a 00 00                jz <.main+2336 @05c454>
	<.main+2330 @05c44e> : 10 01                      dup.x32 sp(1)
	<.main+2332 @05c450> : 04 06 00 00                jmp <.main+2338 @05c456>
	<.main+2336 @05c454> : 10 00                      dup.x32 sp(0)
	<.main+2338 @05c456> : 13 02                      set.x32 sp(2)
	<.main+2340 @05c458> : 09 fc ff ff                inc.sp(-4)
	<.main+2344 @05c45c> : 20 28 a6 05                load.m32 <@05a628> ;i2
	<.main+2348 @05c460> : 0c 01 00 00                inc.i32(+1)
	<.main+2352 @05c464> : 10 01                      dup.x32 sp(1)
	<.main+2354 @05c466> : 10 01                      dup.x32 sp(1)
	<.main+2356 @05c468> : 59                         cgt.i32
	<.main+2357 @05c469> : 06 0a 00 00                jz <.main+2367 @05c473>
	<.main+2361 @05c46d> : 10 01                      dup.x32 sp(1)
	<.main+2363 @05c46f> : 04 06 00 00                jmp <.main+2369 @05c475>
	<.main+2367 @05c473> : 10 00                      dup.x32 sp(0)
	<.main+2369 @05c475> : 13 02                      set.x32 sp(2)
	<.main+2371 @05c477> : 09 fc ff ff                inc.sp(-4)
	<.main+2375 @05c47b> : 20 30 a6 05                load.m32 <@05a630> ;i8
	<.main+2379 @05c47f> : 0c 01 00 00                inc.i32(+1)
	<.main+2383 @05c483> : 10 01                      dup.x32 sp(1)
	<.main+2385 @05c485> : 10 01                      dup.x32 sp(1)
	<.main+2387 @05c487> : 59                         cgt.i32
	<.main+2388 @05c488> : 06 0a 00 00                jz <.main+2398 @05c492>
	<.main+2392 @05c48c> : 10 01                      dup.x32 sp(1)
	<.main+2394 @05c48e> : 04 06 00 00                jmp <.main+2400 @05c494>
	<.main+2398 @05c492> : 10 00                      dup.x32 sp(0)
	<.main+2400 @05c494> : 13 02                      set.x32 sp(2)
	<.main+2402 @05c496> : 09 fc ff ff                inc.sp(-4)
	<.main+2406 @05c49a> : 0c ff ff ff                inc.i32(-1)
	<.main+2410 @05c49e> : 24 80 a7 05                store.m32 <@05a780> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@05c4a2> - <@05c4ab>): static overload1: float32 := overload
	<.main+2414 @05c4a2> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2419 @05c4a7> : 24 88 a7 05                store.m32 <@05a788> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@05c4ab> - <@05c4b4>): static overload2: float32 := overload()
	<.main+2423 @05c4ab> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2428 @05c4b0> : 24 90 a7 05                store.m32 <@05a790> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@05c4b4> - <@05c4bd>): static overload3: float32 := overload(0)
	<.main+2432 @05c4b4> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2437 @05c4b9> : 24 98 a7 05                store.m32 <@05a798> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@05c4bd> - <@05c4c6>): static overload4: float32 := overload(0.000000)
	<.main+2441 @05c4bd> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2446 @05c4c2> : 24 a0 a7 05                store.m32 <@05a7a0> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@05c4c6> - <@05c4cf>): static overload5: float32 := overload(0, 0)
	<.main+2450 @05c4c6> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2455 @05c4cb> : 24 a8 a7 05                store.m32 <@05a7a8> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@05c4cf> - <@05c4dc>): static boilC: Celsius := Celsius(100.000000)
	<.main+2459 @05c4cf> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2468 @05c4d8> : 23 b0 a7 05                store.m64 <@05a7b0> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@05c4dc> - <@05c4f8>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2472 @05c4dc> : 21 b0 a7 05                load.m64 <@05a7b0> ;boilC
	<.main+2476 @05c4e0> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2485 @05c4e9> : 83                         mul.f64
	<.main+2486 @05c4ea> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2495 @05c4f3> : 81                         add.f64
	<.main+2496 @05c4f4> : 23 b8 a7 05                store.m64 <@05a7b8> ;boilF
	test/std/number.ci:3: (13 bytes: <@05c4f8> - <@05c505>): static pi64: float64 := 3.141593
	<.main+2500 @05c4f8> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+2509 @05c501> : 23 c0 a7 05                store.m64 <@05a7c0> ;pi64
	test/std/number.ci:4: (13 bytes: <@05c505> - <@05c512>): static e64: float64 := 2.718282
	<.main+2513 @05c505> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+2522 @05c50e> : 23 c8 a7 05                store.m64 <@05a7c8> ;e64
	test/std/number.ci:6: (9 bytes: <@05c512> - <@05c51b>): static pi32: float32 := pi64
	<.main+2526 @05c512> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+2530 @05c516> : 8c                         f64.2f32
	<.main+2531 @05c517> : 24 d0 a7 05                store.m32 <@05a7d0> ;pi32
	test/std/number.ci:7: (9 bytes: <@05c51b> - <@05c524>): static e32: float32 := e64
	<.main+2535 @05c51b> : 21 c8 a7 05                load.m64 <@05a7c8> ;e64
	<.main+2539 @05c51f> : 8c                         f64.2f32
	<.main+2540 @05c520> : 24 d8 a7 05                store.m32 <@05a7d8> ;e32
	test/std/number.ci:14: (11 bytes: <@05c524> - <@05c52f>): static r_comp: int32 := 14 << 3
	<.main+2544 @05c524> : 1c 0e 00 00 00             load.c32 14
	<.main+2549 @05c529> : 3f 43                      b32.shl 0x003
	<.main+2551 @05c52b> : 24 e0 a7 05                store.m32 <@05a7e0> ;r_comp
	test/std/number.ci:15: (11 bytes: <@05c52f> - <@05c53a>): static g_comp: int32 := 63 << 2
	<.main+2555 @05c52f> : 1c 3f 00 00 00             load.c32 63
	<.main+2560 @05c534> : 3f 42                      b32.shl 0x002
	<.main+2562 @05c536> : 24 e8 a7 05                store.m32 <@05a7e8> ;g_comp
	test/std/number.ci:16: (11 bytes: <@05c53a> - <@05c545>): static b_comp: int32 := 31 << 3
	<.main+2566 @05c53a> : 1c 1f 00 00 00             load.c32 31
	<.main+2571 @05c53f> : 3f 43                      b32.shl 0x003
	<.main+2573 @05c541> : 24 f0 a7 05                store.m32 <@05a7f0> ;b_comp
	test/std/number.ci:18: (38 bytes: <@05c545> - <@05c56b>): static r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+2577 @05c545> : 20 e0 a7 05                load.m32 <@05a7e0> ;r_comp
	<.main+2581 @05c549> : 3f 48                      b32.shl 0x008
	<.main+2583 @05c54b> : 1c 00 f8 00 00             load.c32 63488
	<.main+2588 @05c550> : 31                         and.b32
	<.main+2589 @05c551> : 20 e8 a7 05                load.m32 <@05a7e8> ;g_comp
	<.main+2593 @05c555> : 3f 43                      b32.shl 0x003
	<.main+2595 @05c557> : 1c e0 07 00 00             load.c32 2016
	<.main+2600 @05c55c> : 31                         and.b32
	<.main+2601 @05c55d> : 32                         or.b32
	<.main+2602 @05c55e> : 20 f0 a7 05                load.m32 <@05a7f0> ;b_comp
	<.main+2606 @05c562> : 3f c3                      b32.sar 0x003
	<.main+2608 @05c564> : 3f 05                      b32.and 0x01f
	<.main+2610 @05c566> : 32                         or.b32
	<.main+2611 @05c567> : 24 f8 a7 05                store.m32 <@05a7f8> ;r5g6b5
	test/std/number.ci:19: (36 bytes: <@05c56b> - <@05c58f>): static r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+2615 @05c56b> : 20 e0 a7 05                load.m32 <@05a7e0> ;r_comp
	<.main+2619 @05c56f> : 3f 50                      b32.shl 0x010
	<.main+2621 @05c571> : 1c 00 00 ff 00             load.c32 16711680
	<.main+2626 @05c576> : 31                         and.b32
	<.main+2627 @05c577> : 20 e8 a7 05                load.m32 <@05a7e8> ;g_comp
	<.main+2631 @05c57b> : 3f 48                      b32.shl 0x008
	<.main+2633 @05c57d> : 1c 00 ff 00 00             load.c32 65280
	<.main+2638 @05c582> : 31                         and.b32
	<.main+2639 @05c583> : 32                         or.b32
	<.main+2640 @05c584> : 20 f0 a7 05                load.m32 <@05a7f0> ;b_comp
	<.main+2644 @05c588> : 3f 08                      b32.and 0x0ff
	<.main+2646 @05c58a> : 32                         or.b32
	<.main+2647 @05c58b> : 24 00 a8 05                store.m32 <@05a800> ;r8g8b8
	test/std/number.ci:21: (22 bytes: <@05c58f> - <@05c5a5>): static zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+2651 @05c58f> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2655 @05c593> : 1c 0b 00 00 00             load.c32 11
	<.main+2660 @05c598> : 1c 05 00 00 00             load.c32 5
	<.main+2665 @05c59d> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2669 @05c5a1> : 24 08 a8 05                store.m32 <@05a808> ;zxtR5
	test/std/number.ci:22: (22 bytes: <@05c5a5> - <@05c5bb>): static zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+2673 @05c5a5> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2677 @05c5a9> : 1c 05 00 00 00             load.c32 5
	<.main+2682 @05c5ae> : 1c 06 00 00 00             load.c32 6
	<.main+2687 @05c5b3> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2691 @05c5b7> : 24 10 a8 05                store.m32 <@05a810> ;zxtG6
	test/std/number.ci:23: (18 bytes: <@05c5bb> - <@05c5cd>): static zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+2695 @05c5bb> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2699 @05c5bf> : 19                         load.z32
	<.main+2700 @05c5c0> : 1c 05 00 00 00             load.c32 5
	<.main+2705 @05c5c5> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2709 @05c5c9> : 24 18 a8 05                store.m32 <@05a818> ;zxtB5
	test/std/number.ci:25: (22 bytes: <@05c5cd> - <@05c5e3>): static sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+2713 @05c5cd> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2717 @05c5d1> : 1c 0b 00 00 00             load.c32 11
	<.main+2722 @05c5d6> : 1c 05 00 00 00             load.c32 5
	<.main+2727 @05c5db> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2731 @05c5df> : 24 20 a8 05                store.m32 <@05a820> ;sxtR5
	test/std/number.ci:26: (22 bytes: <@05c5e3> - <@05c5f9>): static sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+2735 @05c5e3> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2739 @05c5e7> : 1c 05 00 00 00             load.c32 5
	<.main+2744 @05c5ec> : 1c 06 00 00 00             load.c32 6
	<.main+2749 @05c5f1> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2753 @05c5f5> : 24 28 a8 05                store.m32 <@05a828> ;sxtG6
	test/std/number.ci:27: (18 bytes: <@05c5f9> - <@05c60b>): static sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+2757 @05c5f9> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+2761 @05c5fd> : 19                         load.z32
	<.main+2762 @05c5fe> : 1c 05 00 00 00             load.c32 5
	<.main+2767 @05c603> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2771 @05c607> : 24 30 a8 05                store.m32 <@05a830> ;sxtB5
	test/std/number.ci:29: (22 bytes: <@05c60b> - <@05c621>): static zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+2775 @05c60b> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2779 @05c60f> : 1c 10 00 00 00             load.c32 16
	<.main+2784 @05c614> : 1c 08 00 00 00             load.c32 8
	<.main+2789 @05c619> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2793 @05c61d> : 24 38 a8 05                store.m32 <@05a838> ;zxtR8
	test/std/number.ci:30: (22 bytes: <@05c621> - <@05c637>): static zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+2797 @05c621> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2801 @05c625> : 1c 08 00 00 00             load.c32 8
	<.main+2806 @05c62a> : 1c 08 00 00 00             load.c32 8
	<.main+2811 @05c62f> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2815 @05c633> : 24 40 a8 05                store.m32 <@05a840> ;zxtG8
	test/std/number.ci:31: (18 bytes: <@05c637> - <@05c649>): static zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+2819 @05c637> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2823 @05c63b> : 19                         load.z32
	<.main+2824 @05c63c> : 1c 08 00 00 00             load.c32 8
	<.main+2829 @05c641> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2833 @05c645> : 24 48 a8 05                store.m32 <@05a848> ;zxtB8
	test/std/number.ci:33: (22 bytes: <@05c649> - <@05c65f>): static sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+2837 @05c649> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2841 @05c64d> : 1c 10 00 00 00             load.c32 16
	<.main+2846 @05c652> : 1c 08 00 00 00             load.c32 8
	<.main+2851 @05c657> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2855 @05c65b> : 24 50 a8 05                store.m32 <@05a850> ;sxtR8
	test/std/number.ci:34: (22 bytes: <@05c65f> - <@05c675>): static sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+2859 @05c65f> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2863 @05c663> : 1c 08 00 00 00             load.c32 8
	<.main+2868 @05c668> : 1c 08 00 00 00             load.c32 8
	<.main+2873 @05c66d> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2877 @05c671> : 24 58 a8 05                store.m32 <@05a858> ;sxtG8
	test/std/number.ci:35: (18 bytes: <@05c675> - <@05c687>): static sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+2881 @05c675> : 20 00 a8 05                load.m32 <@05a800> ;r8g8b8
	<.main+2885 @05c679> : 19                         load.z32
	<.main+2886 @05c67a> : 1c 08 00 00 00             load.c32 8
	<.main+2891 @05c67f> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2895 @05c683> : 24 60 a8 05                store.m32 <@05a860> ;sxtB8
	test/std/number.ci:37: (22 bytes: <@05c687> - <@05c69d>): static testSin_f64: float64 := float64.sin(pi64 / (2))
	<.main+2899 @05c687> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+2903 @05c68b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2912 @05c694> : 84                         div.f64
	<.main+2913 @05c695> : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<.main+2917 @05c699> : 23 68 a8 05                store.m64 <@05a868> ;testSin_f64
	test/std/number.ci:38: (22 bytes: <@05c69d> - <@05c6b3>): static testCos_f64: float64 := float64.cos(pi64 / (2))
	<.main+2921 @05c69d> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+2925 @05c6a1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2934 @05c6aa> : 84                         div.f64
	<.main+2935 @05c6ab> : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<.main+2939 @05c6af> : 23 70 a8 05                store.m64 <@05a870> ;testCos_f64
	test/std/number.ci:39: (22 bytes: <@05c6b3> - <@05c6c9>): static testTan_f64: float64 := float64.tan(pi64 / (4))
	<.main+2943 @05c6b3> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+2947 @05c6b7> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+2956 @05c6c0> : 84                         div.f64
	<.main+2957 @05c6c1> : 01 29 00 00                nfc(41) ;float64.tan(x: float64): float64
	<.main+2961 @05c6c5> : 23 78 a8 05                store.m64 <@05a878> ;testTan_f64
	test/std/number.ci:40: (22 bytes: <@05c6c9> - <@05c6df>): static testLog_f64: float64 := float64.log(e64 * e64 * e64)
	<.main+2965 @05c6c9> : 21 c8 a7 05                load.m64 <@05a7c8> ;e64
	<.main+2969 @05c6cd> : 21 c8 a7 05                load.m64 <@05a7c8> ;e64
	<.main+2973 @05c6d1> : 83                         mul.f64
	<.main+2974 @05c6d2> : 21 c8 a7 05                load.m64 <@05a7c8> ;e64
	<.main+2978 @05c6d6> : 83                         mul.f64
	<.main+2979 @05c6d7> : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<.main+2983 @05c6db> : 23 80 a8 05                store.m64 <@05a880> ;testLog_f64
	test/std/number.ci:41: (17 bytes: <@05c6df> - <@05c6f0>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+2987 @05c6df> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+2996 @05c6e8> : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<.main+3000 @05c6ec> : 23 88 a8 05                store.m64 <@05a888> ;testExp_f64
	test/std/number.ci:42: (26 bytes: <@05c6f0> - <@05c70a>): static testPow_f64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+3004 @05c6f0> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+3008 @05c6f4> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+3012 @05c6f8> : 83                         mul.f64
	<.main+3013 @05c6f9> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3022 @05c702> : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<.main+3026 @05c706> : 23 90 a8 05                store.m64 <@05a890> ;testPow_f64
	test/std/number.ci:43: (17 bytes: <@05c70a> - <@05c71b>): static testSqrt_f64: float64 := float64.sqrt(pi64 * pi64)
	<.main+3030 @05c70a> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+3034 @05c70e> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+3038 @05c712> : 83                         mul.f64
	<.main+3039 @05c713> : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<.main+3043 @05c717> : 23 98 a8 05                store.m64 <@05a898> ;testSqrt_f64
	test/std/number.ci:44: (21 bytes: <@05c71b> - <@05c730>): static testAtan_f64: float64 := float64.atan2(pi64, 1.000000)
	<.main+3047 @05c71b> : 21 c0 a7 05                load.m64 <@05a7c0> ;pi64
	<.main+3051 @05c71f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3060 @05c728> : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<.main+3064 @05c72c> : 23 a0 a8 05                store.m64 <@05a8a0> ;testAtan_f64
	test/std/number.ci:46: (18 bytes: <@05c730> - <@05c742>): static testSin_f32: float32 := float32.sin(pi32 / (2))
	<.main+3068 @05c730> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3072 @05c734> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3077 @05c739> : 74                         div.f32
	<.main+3078 @05c73a> : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+3082 @05c73e> : 24 a8 a8 05                store.m32 <@05a8a8> ;testSin_f32
	test/std/number.ci:47: (18 bytes: <@05c742> - <@05c754>): static testCos_f32: float32 := float32.cos(pi32 / (2))
	<.main+3086 @05c742> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3090 @05c746> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3095 @05c74b> : 74                         div.f32
	<.main+3096 @05c74c> : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	<.main+3100 @05c750> : 24 b0 a8 05                store.m32 <@05a8b0> ;testCos_f32
	test/std/number.ci:48: (18 bytes: <@05c754> - <@05c766>): static testTan_f32: float32 := float32.tan(pi32 / (4))
	<.main+3104 @05c754> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3108 @05c758> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3113 @05c75d> : 74                         div.f32
	<.main+3114 @05c75e> : 01 21 00 00                nfc(33) ;float32.tan(x: float32): float32
	<.main+3118 @05c762> : 24 b8 a8 05                store.m32 <@05a8b8> ;testTan_f32
	test/std/number.ci:49: (22 bytes: <@05c766> - <@05c77c>): static testLog_f32: float32 := float32.log(e32 * e32 * e32)
	<.main+3122 @05c766> : 20 d8 a7 05                load.m32 <@05a7d8> ;e32
	<.main+3126 @05c76a> : 20 d8 a7 05                load.m32 <@05a7d8> ;e32
	<.main+3130 @05c76e> : 73                         mul.f32
	<.main+3131 @05c76f> : 20 d8 a7 05                load.m32 <@05a7d8> ;e32
	<.main+3135 @05c773> : 73                         mul.f32
	<.main+3136 @05c774> : 01 22 00 00                nfc(34) ;float32.log(x: float32): float32
	<.main+3140 @05c778> : 24 c0 a8 05                store.m32 <@05a8c0> ;testLog_f32
	test/std/number.ci:50: (13 bytes: <@05c77c> - <@05c789>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+3144 @05c77c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3149 @05c781> : 01 23 00 00                nfc(35) ;float32.exp(x: float32): float32
	<.main+3153 @05c785> : 24 c8 a8 05                store.m32 <@05a8c8> ;testExp_f32
	test/std/number.ci:51: (22 bytes: <@05c789> - <@05c79f>): static testPow_f32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+3157 @05c789> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3161 @05c78d> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3165 @05c791> : 73                         mul.f32
	<.main+3166 @05c792> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3171 @05c797> : 01 24 00 00                nfc(36) ;float32.pow(x: float32, y: float32): float32
	<.main+3175 @05c79b> : 24 d0 a8 05                store.m32 <@05a8d0> ;testPow_f32
	test/std/number.ci:52: (17 bytes: <@05c79f> - <@05c7b0>): static testSqrt_f32: float32 := float32.sqrt(pi32 * pi32)
	<.main+3179 @05c79f> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3183 @05c7a3> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3187 @05c7a7> : 73                         mul.f32
	<.main+3188 @05c7a8> : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<.main+3192 @05c7ac> : 24 d8 a8 05                store.m32 <@05a8d8> ;testSqrt_f32
	test/std/number.ci:53: (17 bytes: <@05c7b0> - <@05c7c1>): static testAtan_f32: float32 := float32.atan2(pi32, 1.000000)
	<.main+3196 @05c7b0> : 20 d0 a7 05                load.m32 <@05a7d0> ;pi32
	<.main+3200 @05c7b4> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3205 @05c7b9> : 01 26 00 00                nfc(38) ;float32.atan2(x: float32, y: float32): float32
	<.main+3209 @05c7bd> : 24 e0 a8 05                store.m32 <@05a8e0> ;testAtan_f32
	test/std/number.ci:55: (12 bytes: <@05c7c1> - <@05c7cd>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3213 @05c7c1> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3217 @05c7c5> : 01 17 00 00                nfc(23) ;uint32.pop(value: int32): int32
	<.main+3221 @05c7c9> : 24 e8 a8 05                store.m32 <@05a8e8> ;testPopulation_u32
	test/std/number.ci:56: (12 bytes: <@05c7cd> - <@05c7d9>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3225 @05c7cd> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3229 @05c7d1> : 01 18 00 00                nfc(24) ;uint32.swap(value: int32): int32
	<.main+3233 @05c7d5> : 24 f0 a8 05                store.m32 <@05a8f0> ;testSwapBits_u32
	test/std/number.ci:57: (12 bytes: <@05c7d9> - <@05c7e5>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3237 @05c7d9> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3241 @05c7dd> : 01 19 00 00                nfc(25) ;uint32.bsr(value: int32): int32
	<.main+3245 @05c7e1> : 24 f8 a8 05                store.m32 <@05a8f8> ;testBitScanReverse_u32
	test/std/number.ci:58: (12 bytes: <@05c7e5> - <@05c7f1>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3249 @05c7e5> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3253 @05c7e9> : 01 1a 00 00                nfc(26) ;uint32.bsf(value: int32): int32
	<.main+3257 @05c7ed> : 24 00 a9 05                store.m32 <@05a900> ;testBitScanForward_u32
	test/std/number.ci:59: (12 bytes: <@05c7f1> - <@05c7fd>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3261 @05c7f1> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3265 @05c7f5> : 01 1b 00 00                nfc(27) ;uint32.hib(value: int32): int32
	<.main+3269 @05c7f9> : 24 08 a9 05                store.m32 <@05a908> ;testHighBit_u32
	test/std/number.ci:60: (12 bytes: <@05c7fd> - <@05c809>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3273 @05c7fd> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3277 @05c801> : 01 1c 00 00                nfc(28) ;uint32.lob(value: int32): int32
	<.main+3281 @05c805> : 24 10 a9 05                store.m32 <@05a910> ;testLowBit_u32
	test/std/number.ci:62: (18 bytes: <@05c809> - <@05c81b>): static testZeroExtend_u32: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+3285 @05c809> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3289 @05c80d> : 19                         load.z32
	<.main+3290 @05c80e> : 1c 05 00 00 00             load.c32 5
	<.main+3295 @05c813> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+3299 @05c817> : 24 18 a9 05                store.m32 <@05a918> ;testZeroExtend_u32
	test/std/number.ci:63: (18 bytes: <@05c81b> - <@05c82d>): static testSignExtend_u32: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+3303 @05c81b> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3307 @05c81f> : 19                         load.z32
	<.main+3308 @05c820> : 1c 05 00 00 00             load.c32 5
	<.main+3313 @05c825> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+3317 @05c829> : 24 20 a9 05                store.m32 <@05a920> ;testSignExtend_u32
	test/std/number.ci:65: (20 bytes: <@05c82d> - <@05c841>): static testZeroExtend_u64: int32 := uint64.zxt(r5g6b5, 0, 5)
	<.main+3321 @05c82d> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3325 @05c831> : 5b                         i32.2i64
	<.main+3326 @05c832> : 19                         load.z32
	<.main+3327 @05c833> : 1c 05 00 00 00             load.c32 5
	<.main+3332 @05c838> : 01 1d 00 00                nfc(29) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3336 @05c83c> : 6a                         i64.2i32
	<.main+3337 @05c83d> : 24 28 a9 05                store.m32 <@05a928> ;testZeroExtend_u64
	test/std/number.ci:66: (20 bytes: <@05c841> - <@05c855>): static testSignExtend_u64: int32 := uint64.sxt(r5g6b5, 0, 5)
	<.main+3341 @05c841> : 20 f8 a7 05                load.m32 <@05a7f8> ;r5g6b5
	<.main+3345 @05c845> : 5b                         i32.2i64
	<.main+3346 @05c846> : 19                         load.z32
	<.main+3347 @05c847> : 1c 05 00 00 00             load.c32 5
	<.main+3352 @05c84c> : 01 1e 00 00                nfc(30) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3356 @05c850> : 6a                         i64.2i32
	<.main+3357 @05c851> : 24 30 a9 05                store.m32 <@05a930> ;testSignExtend_u64
	test/std/memory.ci:7: (18 bytes: <@05c855> - <@05c867>): static p1: pointer := malloc(1024)
	<.main+3361 @05c855> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3366 @05c85a> : 1c 00 04 00 00             load.c32 1024
	<.main+3371 @05c85f> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3375 @05c863> : 24 38 a9 05                store.m32 <@05a938> ;p1
	test/std/memory.ci:8: (18 bytes: <@05c867> - <@05c879>): static p2: pointer := malloc(80)
	<.main+3379 @05c867> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3384 @05c86c> : 1c 50 00 00 00             load.c32 80
	<.main+3389 @05c871> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3393 @05c875> : 24 40 a9 05                store.m32 <@05a940> ;p2
	test/std/memory.ci:9: (18 bytes: <@05c879> - <@05c88b>): static p3: pointer := malloc(160)
	<.main+3397 @05c879> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3402 @05c87e> : 1c a0 00 00 00             load.c32 160
	<.main+3407 @05c883> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3411 @05c887> : 24 48 a9 05                store.m32 <@05a948> ;p3
	test/std/memory.ci:10: (18 bytes: <@05c88b> - <@05c89d>): static p4: pointer := malloc(820)
	<.main+3415 @05c88b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3420 @05c890> : 1c 34 03 00 00             load.c32 820
	<.main+3425 @05c895> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3429 @05c899> : 24 50 a9 05                store.m32 <@05a950> ;p4
	test/std/memory.ci:23: (13 bytes: <@05c89d> - <@05c8aa>): static val1: int64 := 42
	<.main+3433 @05c89d> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3442 @05c8a6> : 23 58 a9 05                store.m64 <@05a958> ;val1
	test/std/memory.ci:24: (13 bytes: <@05c8aa> - <@05c8b7>): static val2: int64 := 96
	<.main+3446 @05c8aa> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+3455 @05c8b3> : 23 60 a9 05                store.m64 <@05a960> ;val2
	test/std/tryExec.ci:47: (18 bytes: <@05c8b7> - <@05c8c9>): static tryExecErr0: int32 := tryExec(null, noError)
	<.main+3459 @05c8b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3464 @05c8bc> : 1f 68 a9 05 00             load.ref <@05a968> ;noError(ptr: pointer): void
	<.main+3469 @05c8c1> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3473 @05c8c5> : 24 f8 a9 05                store.m32 <@05a9f8> ;tryExecErr0
	test/std/tryExec.ci:48: (18 bytes: <@05c8c9> - <@05c8db>): static tryExecErr1: int32 := tryExec(null, null)
	<.main+3477 @05c8c9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3482 @05c8ce> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3487 @05c8d3> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3491 @05c8d7> : 24 00 aa 05                store.m32 <@05aa00> ;tryExecErr1
	test/std/tryExec.ci:49: (18 bytes: <@05c8db> - <@05c8ed>): static tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+3495 @05c8db> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3500 @05c8e0> : 1f 70 a9 05 00             load.ref <@05a970> ;stackOverflow(ptr: pointer): void
	<.main+3505 @05c8e5> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3509 @05c8e9> : 24 08 aa 05                store.m32 <@05aa08> ;tryExecErr2
	test/std/tryExec.ci:50: (18 bytes: <@05c8ed> - <@05c8ff>): static tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+3513 @05c8ed> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3518 @05c8f2> : 1f 88 a9 05 00             load.ref <@05a988> ;divisionByZero(args: pointer): void
	<.main+3523 @05c8f7> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3527 @05c8fb> : 24 10 aa 05                store.m32 <@05aa10> ;tryExecErr3
	test/std/tryExec.ci:51: (18 bytes: <@05c8ff> - <@05c911>): static tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+3531 @05c8ff> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3536 @05c904> : 1f f0 a9 05 00             load.ref <@05a9f0> ;invalidInstruction(args: pointer): void
	<.main+3541 @05c909> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3545 @05c90d> : 24 18 aa 05                store.m32 <@05aa18> ;tryExecErr4
	test/std/tryExec.ci:52: (18 bytes: <@05c911> - <@05c923>): static tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+3549 @05c911> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3554 @05c916> : 1f e0 a9 05 00             load.ref <@05a9e0> ;invalidMemoryAccess(args: pointer): void
	<.main+3559 @05c91b> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3563 @05c91f> : 24 20 aa 05                store.m32 <@05aa20> ;tryExecErr5
	test/std/tryExec.ci:53: (18 bytes: <@05c923> - <@05c935>): static tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+3567 @05c923> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3572 @05c928> : 1f 98 a9 05 00             load.ref <@05a998> ;abortExecution(args: pointer): void
	<.main+3577 @05c92d> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3581 @05c931> : 24 28 aa 05                store.m32 <@05aa28> ;tryExecErr6
	test/lang/init.reference.ci:7: (13 bytes: <@05c935> - <@05c942>): static value: int64 := 42
	<.main+3585 @05c935> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3594 @05c93e> : 23 30 aa 05                store.m64 <@05aa30> ;value
	test/lang/init.reference.ci:8: (9 bytes: <@05c942> - <@05c94b>): static valueRef: int64 := value
	<.main+3598 @05c942> : 1f 30 aa 05 00             load.ref <@05aa30> ;value
	<.main+3603 @05c947> : 24 38 aa 05                store.m32 <@05aa38> ;valueRef
	test/lang/init.reference.ci:9: (9 bytes: <@05c94b> - <@05c954>): static valuePtr: pointer := value
	<.main+3607 @05c94b> : 1f 30 aa 05 00             load.ref <@05aa30> ;value
	<.main+3612 @05c950> : 24 40 aa 05                store.m32 <@05aa40> ;valuePtr
	test/lang/init.reference.ci:10: (14 bytes: <@05c954> - <@05c962>): static valueVar: variant := value
	<.main+3616 @05c954> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3621 @05c959> : 1f 30 aa 05 00             load.ref <@05aa30> ;value
	<.main+3626 @05c95e> : 23 48 aa 05                store.m64 <@05aa48> ;valueVar
	test/lang/init.reference.ci:12: (9 bytes: <@05c962> - <@05c96b>): static fromRef: int64 := valueRef
	<.main+3630 @05c962> : 20 38 aa 05                load.m32 <@05aa38> ;valueRef
	<.main+3634 @05c966> : 29                         load.i64
	<.main+3635 @05c967> : 23 50 aa 05                store.m64 <@05aa50> ;fromRef
	test/lang/init.reference.ci:13: (8 bytes: <@05c96b> - <@05c973>): static fromPtr: int64 := valuePtr
	<.main+3639 @05c96b> : 20 40 aa 05                load.m32 <@05aa40> ;valuePtr
	<.main+3643 @05c96f> : 24 58 aa 05                store.m32 <@05aa58> ;fromPtr
	test/lang/init.reference.ci:14: (8 bytes: <@05c973> - <@05c97b>): static fromVar: int64 := valueVar
	<.main+3647 @05c973> : 20 48 aa 05                load.m32 <@05aa48> ;valueVar
	<.main+3651 @05c977> : 24 60 aa 05                store.m32 <@05aa60> ;fromVar
	test/lang/init.reference.ci:16: (9 bytes: <@05c97b> - <@05c984>): static nullRef: int64 := null
	<.main+3655 @05c97b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3660 @05c980> : 24 68 aa 05                store.m32 <@05aa68> ;nullRef
	test/lang/init.reference.ci:17: (9 bytes: <@05c984> - <@05c98d>): static nullPtr: pointer := null
	<.main+3664 @05c984> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3669 @05c989> : 24 70 aa 05                store.m32 <@05aa70> ;nullPtr
	test/lang/init.reference.ci:18: (14 bytes: <@05c98d> - <@05c99b>): static nullVar: variant := null
	<.main+3673 @05c98d> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3678 @05c992> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3683 @05c997> : 23 78 aa 05                store.m64 <@05aa78> ;nullVar
	test/lang/init.reference.ci:19: (9 bytes: <@05c99b> - <@05c9a4>): static nullTyp: typename := null
	<.main+3687 @05c99b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3692 @05c9a0> : 24 80 aa 05                store.m32 <@05aa80> ;nullTyp
	test/lang/init.reference.ci:20: (9 bytes: <@05c9a4> - <@05c9ad>): static nullFun: function := null
	<.main+3696 @05c9a4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3701 @05c9a9> : 24 88 aa 05                store.m32 <@05aa88> ;nullFun
	test/lang/init.reference.ci:21: (9 bytes: <@05c9ad> - <@05c9b6>): static nullObj: object := null
	<.main+3705 @05c9ad> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3710 @05c9b2> : 24 90 aa 05                store.m32 <@05aa90> ;nullObj
	test/lang/init.reference.ci:23: (9 bytes: <@05c9b6> - <@05c9bf>): static typePtr: pointer := int64
	<.main+3714 @05c9b6> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3719 @05c9bb> : 24 98 aa 05                store.m32 <@05aa98> ;typePtr
	test/lang/init.reference.ci:24: (14 bytes: <@05c9bf> - <@05c9cd>): static typeVar: variant := int64
	<.main+3723 @05c9bf> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3728 @05c9c4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3733 @05c9c9> : 23 a0 aa 05                store.m64 <@05aaa0> ;typeVar
	test/lang/init.reference.ci:25: (9 bytes: <@05c9cd> - <@05c9d6>): static typeTyp: typename := int64
	<.main+3737 @05c9cd> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3742 @05c9d2> : 24 a8 aa 05                store.m32 <@05aaa8> ;typeTyp
	test/lang/init.reference.ci:27: (8 bytes: <@05c9d6> - <@05c9de>): static local: int64 := value
	<.main+3746 @05c9d6> : 21 30 aa 05                load.m64 <@05aa30> ;value
	<.main+3750 @05c9da> : 23 b0 aa 05                store.m64 <@05aab0> ;local
	test/lang/init.reference.ci:28: (8 bytes: <@05c9de> - <@05c9e6>): static copyVal: int64 := local
	<.main+3754 @05c9de> : 21 b0 aa 05                load.m64 <@05aab0> ;local
	<.main+3758 @05c9e2> : 23 b8 aa 05                store.m64 <@05aab8> ;copyVal
	test/lang/init.reference.ci:29: (8 bytes: <@05c9e6> - <@05c9ee>): static copyRef: int64 := valueRef
	<.main+3762 @05c9e6> : 20 38 aa 05                load.m32 <@05aa38> ;valueRef
	<.main+3766 @05c9ea> : 24 c0 aa 05                store.m32 <@05aac0> ;copyRef
	test/lang/init.reference.ci:30: (8 bytes: <@05c9ee> - <@05c9f6>): static copyPtr: pointer := valuePtr
	<.main+3770 @05c9ee> : 20 40 aa 05                load.m32 <@05aa40> ;valuePtr
	<.main+3774 @05c9f2> : 24 c8 aa 05                store.m32 <@05aac8> ;copyPtr
	test/lang/init.reference.ci:31: (8 bytes: <@05c9f6> - <@05c9fe>): static copyVar: variant := valueVar
	<.main+3778 @05c9f6> : 21 48 aa 05                load.m64 <@05aa48> ;valueVar
	<.main+3782 @05c9fa> : 23 d0 aa 05                store.m64 <@05aad0> ;copyVar
	test/lang/init.reference.ci:32: (8 bytes: <@05c9fe> - <@05ca06>): static copyTyp: typename := typeTyp
	<.main+3786 @05c9fe> : 20 a8 aa 05                load.m32 <@05aaa8> ;typeTyp
	<.main+3790 @05ca02> : 24 d8 aa 05                store.m32 <@05aad8> ;copyTyp
	test/lang/init.reference.ci:35: (9 bytes: <@05ca06> - <@05ca0f>): static ptrVoid: pointer := void
	<.main+3794 @05ca06> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3799 @05ca0b> : 24 e0 aa 05                store.m32 <@05aae0> ;ptrVoid
	test/lang/init.reference.ci:36: (9 bytes: <@05ca0f> - <@05ca18>): static ptrBool: pointer := bool
	<.main+3803 @05ca0f> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3808 @05ca14> : 24 e8 aa 05                store.m32 <@05aae8> ;ptrBool
	test/lang/init.reference.ci:37: (9 bytes: <@05ca18> - <@05ca21>): static ptrChar: pointer := char
	<.main+3812 @05ca18> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3817 @05ca1d> : 24 f0 aa 05                store.m32 <@05aaf0> ;ptrChar
	test/lang/init.reference.ci:38: (9 bytes: <@05ca21> - <@05ca2a>): static ptrInt8: pointer := int8
	<.main+3821 @05ca21> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3826 @05ca26> : 24 f8 aa 05                store.m32 <@05aaf8> ;ptrInt8
	test/lang/init.reference.ci:39: (9 bytes: <@05ca2a> - <@05ca33>): static ptrInt16: pointer := int16
	<.main+3830 @05ca2a> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3835 @05ca2f> : 24 00 ab 05                store.m32 <@05ab00> ;ptrInt16
	test/lang/init.reference.ci:40: (9 bytes: <@05ca33> - <@05ca3c>): static ptrInt32: pointer := int32
	<.main+3839 @05ca33> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3844 @05ca38> : 24 08 ab 05                store.m32 <@05ab08> ;ptrInt32
	test/lang/init.reference.ci:41: (9 bytes: <@05ca3c> - <@05ca45>): static ptrInt64: pointer := int64
	<.main+3848 @05ca3c> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3853 @05ca41> : 24 10 ab 05                store.m32 <@05ab10> ;ptrInt64
	test/lang/init.reference.ci:42: (9 bytes: <@05ca45> - <@05ca4e>): static ptrUint8: pointer := uint8
	<.main+3857 @05ca45> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3862 @05ca4a> : 24 18 ab 05                store.m32 <@05ab18> ;ptrUint8
	test/lang/init.reference.ci:43: (9 bytes: <@05ca4e> - <@05ca57>): static ptrUint16: pointer := uint16
	<.main+3866 @05ca4e> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3871 @05ca53> : 24 20 ab 05                store.m32 <@05ab20> ;ptrUint16
	test/lang/init.reference.ci:44: (9 bytes: <@05ca57> - <@05ca60>): static ptrUint32: pointer := uint32
	<.main+3875 @05ca57> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3880 @05ca5c> : 24 28 ab 05                store.m32 <@05ab28> ;ptrUint32
	test/lang/init.reference.ci:45: (9 bytes: <@05ca60> - <@05ca69>): static ptrUint64: pointer := uint64
	<.main+3884 @05ca60> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3889 @05ca65> : 24 30 ab 05                store.m32 <@05ab30> ;ptrUint64
	test/lang/init.reference.ci:46: (9 bytes: <@05ca69> - <@05ca72>): static ptrFloat32: pointer := float32
	<.main+3893 @05ca69> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3898 @05ca6e> : 24 38 ab 05                store.m32 <@05ab38> ;ptrFloat32
	test/lang/init.reference.ci:47: (9 bytes: <@05ca72> - <@05ca7b>): static ptrFloat64: pointer := float64
	<.main+3902 @05ca72> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3907 @05ca77> : 24 40 ab 05                store.m32 <@05ab40> ;ptrFloat64
	test/lang/init.reference.ci:48: (9 bytes: <@05ca7b> - <@05ca84>): static ptrTypename: pointer := typename
	<.main+3911 @05ca7b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3916 @05ca80> : 24 48 ab 05                store.m32 <@05ab48> ;ptrTypename
	test/lang/init.reference.ci:49: (9 bytes: <@05ca84> - <@05ca8d>): static ptrFunction: pointer := function
	<.main+3920 @05ca84> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3925 @05ca89> : 24 50 ab 05                store.m32 <@05ab50> ;ptrFunction
	test/lang/init.reference.ci:50: (9 bytes: <@05ca8d> - <@05ca96>): static ptrPointer: pointer := pointer
	<.main+3929 @05ca8d> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3934 @05ca92> : 24 58 ab 05                store.m32 <@05ab58> ;ptrPointer
	test/lang/init.reference.ci:51: (9 bytes: <@05ca96> - <@05ca9f>): static ptrVariant: pointer := variant
	<.main+3938 @05ca96> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3943 @05ca9b> : 24 60 ab 05                store.m32 <@05ab60> ;ptrVariant
	test/lang/init.reference.ci:52: (9 bytes: <@05ca9f> - <@05caa8>): static ptrObject: pointer := object
	<.main+3947 @05ca9f> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3952 @05caa4> : 24 68 ab 05                store.m32 <@05ab68> ;ptrObject
	test/lang/init.reference.ci:55: (14 bytes: <@05caa8> - <@05cab6>): static varVoid: variant := void
	<.main+3956 @05caa8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3961 @05caad> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3966 @05cab2> : 23 70 ab 05                store.m64 <@05ab70> ;varVoid
	test/lang/init.reference.ci:56: (14 bytes: <@05cab6> - <@05cac4>): static varBool: variant := bool
	<.main+3970 @05cab6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3975 @05cabb> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3980 @05cac0> : 23 78 ab 05                store.m64 <@05ab78> ;varBool
	test/lang/init.reference.ci:57: (14 bytes: <@05cac4> - <@05cad2>): static varChar: variant := char
	<.main+3984 @05cac4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3989 @05cac9> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3994 @05cace> : 23 80 ab 05                store.m64 <@05ab80> ;varChar
	test/lang/init.reference.ci:58: (14 bytes: <@05cad2> - <@05cae0>): static varInt8: variant := int8
	<.main+3998 @05cad2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4003 @05cad7> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+4008 @05cadc> : 23 88 ab 05                store.m64 <@05ab88> ;varInt8
	test/lang/init.reference.ci:59: (14 bytes: <@05cae0> - <@05caee>): static varInt16: variant := int16
	<.main+4012 @05cae0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4017 @05cae5> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+4022 @05caea> : 23 90 ab 05                store.m64 <@05ab90> ;varInt16
	test/lang/init.reference.ci:60: (14 bytes: <@05caee> - <@05cafc>): static varInt32: variant := int32
	<.main+4026 @05caee> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4031 @05caf3> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+4036 @05caf8> : 23 98 ab 05                store.m64 <@05ab98> ;varInt32
	test/lang/init.reference.ci:61: (14 bytes: <@05cafc> - <@05cb0a>): static varInt64: variant := int64
	<.main+4040 @05cafc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4045 @05cb01> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+4050 @05cb06> : 23 a0 ab 05                store.m64 <@05aba0> ;varInt64
	test/lang/init.reference.ci:62: (14 bytes: <@05cb0a> - <@05cb18>): static varUint8: variant := uint8
	<.main+4054 @05cb0a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4059 @05cb0f> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+4064 @05cb14> : 23 a8 ab 05                store.m64 <@05aba8> ;varUint8
	test/lang/init.reference.ci:63: (14 bytes: <@05cb18> - <@05cb26>): static varUint16: variant := uint16
	<.main+4068 @05cb18> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4073 @05cb1d> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+4078 @05cb22> : 23 b0 ab 05                store.m64 <@05abb0> ;varUint16
	test/lang/init.reference.ci:64: (14 bytes: <@05cb26> - <@05cb34>): static varUint32: variant := uint32
	<.main+4082 @05cb26> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4087 @05cb2b> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+4092 @05cb30> : 23 b8 ab 05                store.m64 <@05abb8> ;varUint32
	test/lang/init.reference.ci:65: (14 bytes: <@05cb34> - <@05cb42>): static varUint64: variant := uint64
	<.main+4096 @05cb34> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4101 @05cb39> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+4106 @05cb3e> : 23 c0 ab 05                store.m64 <@05abc0> ;varUint64
	test/lang/init.reference.ci:66: (14 bytes: <@05cb42> - <@05cb50>): static varFloat32: variant := float32
	<.main+4110 @05cb42> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4115 @05cb47> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+4120 @05cb4c> : 23 c8 ab 05                store.m64 <@05abc8> ;varFloat32
	test/lang/init.reference.ci:67: (14 bytes: <@05cb50> - <@05cb5e>): static varFloat64: variant := float64
	<.main+4124 @05cb50> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4129 @05cb55> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+4134 @05cb5a> : 23 d0 ab 05                store.m64 <@05abd0> ;varFloat64
	test/lang/init.reference.ci:68: (14 bytes: <@05cb5e> - <@05cb6c>): static varTypename: variant := typename
	<.main+4138 @05cb5e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4143 @05cb63> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4148 @05cb68> : 23 d8 ab 05                store.m64 <@05abd8> ;varTypename
	test/lang/init.reference.ci:69: (14 bytes: <@05cb6c> - <@05cb7a>): static varFunction: variant := function
	<.main+4152 @05cb6c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4157 @05cb71> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+4162 @05cb76> : 23 e0 ab 05                store.m64 <@05abe0> ;varFunction
	test/lang/init.reference.ci:70: (14 bytes: <@05cb7a> - <@05cb88>): static varPointer: variant := pointer
	<.main+4166 @05cb7a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4171 @05cb7f> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4176 @05cb84> : 23 e8 ab 05                store.m64 <@05abe8> ;varPointer
	test/lang/init.reference.ci:71: (14 bytes: <@05cb88> - <@05cb96>): static varVariant: variant := variant
	<.main+4180 @05cb88> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4185 @05cb8d> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+4190 @05cb92> : 23 f0 ab 05                store.m64 <@05abf0> ;varVariant
	test/lang/init.reference.ci:72: (14 bytes: <@05cb96> - <@05cba4>): static varObject: variant := object
	<.main+4194 @05cb96> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4199 @05cb9b> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+4204 @05cba0> : 23 f8 ab 05                store.m64 <@05abf8> ;varObject
	test/lang/init.reference.ci:75: (9 bytes: <@05cba4> - <@05cbad>): static typVoid: typename := void
	<.main+4208 @05cba4> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+4213 @05cba9> : 24 00 ac 05                store.m32 <@05ac00> ;typVoid
	test/lang/init.reference.ci:76: (9 bytes: <@05cbad> - <@05cbb6>): static typBool: typename := bool
	<.main+4217 @05cbad> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+4222 @05cbb2> : 24 08 ac 05                store.m32 <@05ac08> ;typBool
	test/lang/init.reference.ci:77: (9 bytes: <@05cbb6> - <@05cbbf>): static typChar: typename := char
	<.main+4226 @05cbb6> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+4231 @05cbbb> : 24 10 ac 05                store.m32 <@05ac10> ;typChar
	test/lang/init.reference.ci:78: (9 bytes: <@05cbbf> - <@05cbc8>): static typInt8: typename := int8
	<.main+4235 @05cbbf> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+4240 @05cbc4> : 24 18 ac 05                store.m32 <@05ac18> ;typInt8
	test/lang/init.reference.ci:79: (9 bytes: <@05cbc8> - <@05cbd1>): static typInt16: typename := int16
	<.main+4244 @05cbc8> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+4249 @05cbcd> : 24 20 ac 05                store.m32 <@05ac20> ;typInt16
	test/lang/init.reference.ci:80: (9 bytes: <@05cbd1> - <@05cbda>): static typInt32: typename := int32
	<.main+4253 @05cbd1> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+4258 @05cbd6> : 24 28 ac 05                store.m32 <@05ac28> ;typInt32
	test/lang/init.reference.ci:81: (9 bytes: <@05cbda> - <@05cbe3>): static typInt64: typename := int64
	<.main+4262 @05cbda> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+4267 @05cbdf> : 24 30 ac 05                store.m32 <@05ac30> ;typInt64
	test/lang/init.reference.ci:82: (9 bytes: <@05cbe3> - <@05cbec>): static typUint8: typename := uint8
	<.main+4271 @05cbe3> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+4276 @05cbe8> : 24 38 ac 05                store.m32 <@05ac38> ;typUint8
	test/lang/init.reference.ci:83: (9 bytes: <@05cbec> - <@05cbf5>): static typUint16: typename := uint16
	<.main+4280 @05cbec> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+4285 @05cbf1> : 24 40 ac 05                store.m32 <@05ac40> ;typUint16
	test/lang/init.reference.ci:84: (9 bytes: <@05cbf5> - <@05cbfe>): static typUint32: typename := uint32
	<.main+4289 @05cbf5> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+4294 @05cbfa> : 24 48 ac 05                store.m32 <@05ac48> ;typUint32
	test/lang/init.reference.ci:85: (9 bytes: <@05cbfe> - <@05cc07>): static typUint64: typename := uint64
	<.main+4298 @05cbfe> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+4303 @05cc03> : 24 50 ac 05                store.m32 <@05ac50> ;typUint64
	test/lang/init.reference.ci:86: (9 bytes: <@05cc07> - <@05cc10>): static typFloat32: typename := float32
	<.main+4307 @05cc07> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+4312 @05cc0c> : 24 58 ac 05                store.m32 <@05ac58> ;typFloat32
	test/lang/init.reference.ci:87: (9 bytes: <@05cc10> - <@05cc19>): static typFloat64: typename := float64
	<.main+4316 @05cc10> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+4321 @05cc15> : 24 60 ac 05                store.m32 <@05ac60> ;typFloat64
	test/lang/init.reference.ci:88: (9 bytes: <@05cc19> - <@05cc22>): static typTypename: typename := typename
	<.main+4325 @05cc19> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4330 @05cc1e> : 24 68 ac 05                store.m32 <@05ac68> ;typTypename
	test/lang/init.reference.ci:89: (9 bytes: <@05cc22> - <@05cc2b>): static typFunction: typename := function
	<.main+4334 @05cc22> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+4339 @05cc27> : 24 70 ac 05                store.m32 <@05ac70> ;typFunction
	test/lang/init.reference.ci:90: (9 bytes: <@05cc2b> - <@05cc34>): static typPointer: typename := pointer
	<.main+4343 @05cc2b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4348 @05cc30> : 24 78 ac 05                store.m32 <@05ac78> ;typPointer
	test/lang/init.reference.ci:91: (9 bytes: <@05cc34> - <@05cc3d>): static typVariant: typename := variant
	<.main+4352 @05cc34> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+4357 @05cc39> : 24 80 ac 05                store.m32 <@05ac80> ;typVariant
	test/lang/init.reference.ci:92: (9 bytes: <@05cc3d> - <@05cc46>): static typObject: typename := object
	<.main+4361 @05cc3d> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+4366 @05cc42> : 24 88 ac 05                store.m32 <@05ac88> ;typObject
	test/lang/init.reference.ci:95: (9 bytes: <@05cc46> - <@05cc4f>): static valueOfPtr: pointer := pointer(value)
	<.main+4370 @05cc46> : 1f 30 aa 05 00             load.ref <@05aa30> ;value
	<.main+4375 @05cc4b> : 24 90 ac 05                store.m32 <@05ac90> ;valueOfPtr
	test/lang/init.reference.ci:96: (14 bytes: <@05cc4f> - <@05cc5d>): static valueOfVar: variant := variant(value)
	<.main+4379 @05cc4f> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+4384 @05cc54> : 1f 30 aa 05 00             load.ref <@05aa30> ;value
	<.main+4389 @05cc59> : 23 98 ac 05                store.m64 <@05ac98> ;valueOfVar
	test/lang/init.reference.ci:97: (9 bytes: <@05cc5d> - <@05cc66>): static valueOfTyp: typename := typename(value)
	<.main+4393 @05cc5d> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+4398 @05cc62> : 24 a0 ac 05                store.m32 <@05aca0> ;valueOfTyp
	test/lang/init.reference.ci:99: (9 bytes: <@05cc66> - <@05cc6f>): static typeOfValue: typename := typename(value)
	<.main+4402 @05cc66> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+4407 @05cc6b> : 24 a8 ac 05                store.m32 <@05aca8> ;typeOfValue
	test/lang/init.reference.ci:105: (13 bytes: <@05cc6f> - <@05cc7c>): static copyPtrFloat64: variant := ptrFloat64
	<.main+4411 @05cc6f> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4416 @05cc74> : 20 40 ab 05                load.m32 <@05ab40> ;ptrFloat64
	<.main+4420 @05cc78> : 23 b0 ac 05                store.m64 <@05acb0> ;copyPtrFloat64
	test/lang/init.reference.ci:108: (8 bytes: <@05cc7c> - <@05cc84>): static copyVarFloat64: pointer := varFloat64
	<.main+4424 @05cc7c> : 20 d0 ab 05                load.m32 <@05abd0> ;varFloat64
	<.main+4428 @05cc80> : 24 b8 ac 05                store.m32 <@05acb8> ;copyVarFloat64
	test/lang/init.variable.ci:3: (5 bytes: <@05cc84> - <@05cc89>): static variable: int32
	<.main+4432 @05cc84> : 19                         load.z32
	<.main+4433 @05cc85> : 24 c0 ac 05                store.m32 <@05acc0> ;variable
	test/lang/init.variable.ci:7: (9 bytes: <@05cc89> - <@05cc92>): static const constant: int32 := 42
	<.main+4437 @05cc89> : 1c 2a 00 00 00             load.c32 42
	<.main+4442 @05cc8e> : 24 c8 ac 05                store.m32 <@05acc8> ;constant
	test/lang/init.variable.ci:24: (18 bytes: <@05cc92> - <@05cca4>): static valInitImplicit: ComplexVal := {...}
	<.main+4446 @05cc92> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4455 @05cc9b> : 23 d0 ac 05                store.m64 <@05acd0> ;valInitImplicit
	:: (5 bytes: <@05cc9f> - <@05cca4>): valInitImplicit.im := (0)
	<.main+4459 @05cc9f> : 1a                         load.z64
	<.main+4460 @05cca0> : 23 d8 ac 05                store.m64 <@05acd8> ;valInitImplicit+8
	test/lang/init.variable.ci:33: (41 bytes: <@05cca4> - <@05cccd>): static objInitImplicit: ComplexObj := {...}
	<.main+4464 @05cca4> : 1f f0 22 04 00             load.ref <@0422f0> ;ComplexObj
	<.main+4469 @05cca9> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4473 @05ccad> : 24 e0 ac 05                store.m32 <@05ace0> ;objInitImplicit
	test/lang/init.variable.ci:33: (18 bytes: <@05ccb1> - <@05ccc3>): objInitImplicit.re := (8);
	<.main+4477 @05ccb1> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4486 @05ccba> : 20 e0 ac 05                load.m32 <@05ace0> ;objInitImplicit
	<.main+4490 @05ccbe> : 0c 04 00 00                inc.i32(+4)
	<.main+4494 @05ccc2> : 2e                         store.i64
	:: (10 bytes: <@05ccc3> - <@05cccd>): objInitImplicit.im := (0)
	<.main+4495 @05ccc3> : 1a                         load.z64
	<.main+4496 @05ccc4> : 20 e0 ac 05                load.m32 <@05ace0> ;objInitImplicit
	<.main+4500 @05ccc8> : 0c 0c 00 00                inc.i32(+12)
	<.main+4504 @05cccc> : 2e                         store.i64
	test/lang/init.variable.ci:41: (31 bytes: <@05cccd> - <@05ccec>): static objInitExplicit: object := {...}
	<.main+4505 @05cccd> : 1f f0 22 04 00             load.ref <@0422f0> ;ComplexObj
	<.main+4510 @05ccd2> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4514 @05ccd6> : 24 e8 ac 05                store.m32 <@05ace8> ;objInitExplicit
	test/lang/init.variable.ci:41: (18 bytes: <@05ccda> - <@05ccec>): objInitExplicit.re := (8);
	<.main+4518 @05ccda> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4527 @05cce3> : 20 e8 ac 05                load.m32 <@05ace8> ;objInitExplicit
	<.main+4531 @05cce7> : 0c 04 00 00                inc.i32(+4)
	<.main+4535 @05cceb> : 2e                         store.i64
	test/lang/function.ci:12: (25 bytes: <@05ccec> - <@05cd05>): static funAddResult: int32 := funAdd(2, 7)
	<.main+4536 @05ccec> : 19                         load.z32
	<.main+4537 @05cced> : 1c 02 00 00 00             load.c32 2
	<.main+4542 @05ccf2> : 1c 07 00 00 00             load.c32 7
	<.main+4547 @05ccf7> : 1f f8 ac 05 00             load.ref <@05acf8> ;funAdd(x: int32, y: int32): int32
	<.main+4552 @05ccfc> : 02                         call
	<.main+4553 @05ccfd> : 09 f8 ff ff                inc.sp(-8)
	<.main+4557 @05cd01> : 24 00 ad 05                store.m32 <@05ad00> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@05cd05> - <@05cd0e>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+4561 @05cd05> : 1f f8 ac 05 00             load.ref <@05acf8> ;funAdd(x: int32, y: int32): int32
	<.main+4566 @05cd0a> : 24 08 ad 05                store.m32 <@05ad08> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@05cd0e> - <@05cd26>): static funAddRefResult: int32 := funAddRef(2, 8)
	<.main+4570 @05cd0e> : 19                         load.z32
	<.main+4571 @05cd0f> : 1c 02 00 00 00             load.c32 2
	<.main+4576 @05cd14> : 1c 08 00 00 00             load.c32 8
	<.main+4581 @05cd19> : 20 08 ad 05                load.m32 <@05ad08> ;funAddRef(x: int32, y: int32): int32
	<.main+4585 @05cd1d> : 02                         call
	<.main+4586 @05cd1e> : 09 f8 ff ff                inc.sp(-8)
	<.main+4590 @05cd22> : 24 10 ad 05                store.m32 <@05ad10> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@05cd26> - <@05cd2f>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+4594 @05cd26> : 1f 38 ad 05 00             load.ref <@05ad38> ;funMul(x: int32, y: int32): int32
	<.main+4599 @05cd2b> : 24 18 ad 05                store.m32 <@05ad18> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@05cd2f> - <@05cd47>): static funMulResult: int32 := funMul(2, 6)
	<.main+4603 @05cd2f> : 19                         load.z32
	<.main+4604 @05cd30> : 1c 02 00 00 00             load.c32 2
	<.main+4609 @05cd35> : 1c 06 00 00 00             load.c32 6
	<.main+4614 @05cd3a> : 20 18 ad 05                load.m32 <@05ad18> ;funMul(x: int32, y: int32): int32
	<.main+4618 @05cd3e> : 02                         call
	<.main+4619 @05cd3f> : 09 f8 ff ff                inc.sp(-8)
	<.main+4623 @05cd43> : 24 20 ad 05                store.m32 <@05ad20> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@05cd47> - <@05cd4f>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+4627 @05cd47> : 20 18 ad 05                load.m32 <@05ad18> ;funMul(x: int32, y: int32): int32
	<.main+4631 @05cd4b> : 24 28 ad 05                store.m32 <@05ad28> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@05cd4f> - <@05cd67>): static funMulRefResult: int32 := funMulRef(2, 7)
	<.main+4635 @05cd4f> : 19                         load.z32
	<.main+4636 @05cd50> : 1c 02 00 00 00             load.c32 2
	<.main+4641 @05cd55> : 1c 07 00 00 00             load.c32 7
	<.main+4646 @05cd5a> : 20 28 ad 05                load.m32 <@05ad28> ;funMulRef(x: int32, y: int32): int32
	<.main+4650 @05cd5e> : 02                         call
	<.main+4651 @05cd5f> : 09 f8 ff ff                inc.sp(-8)
	<.main+4655 @05cd63> : 24 30 ad 05                store.m32 <@05ad30> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@05cd67> - <@05cd7b>): static fibonacci_13: uint32 := fib(13)
	<.main+4659 @05cd67> : 19                         load.z32
	<.main+4660 @05cd68> : 1c 0d 00 00 00             load.c32 13
	<.main+4665 @05cd6d> : 1f 40 ad 05 00             load.ref <@05ad40> ;fib(n: uint32): uint32
	<.main+4670 @05cd72> : 02                         call
	<.main+4671 @05cd73> : 09 fc ff ff                inc.sp(-4)
	<.main+4675 @05cd77> : 24 78 ad 05                store.m32 <@05ad78> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@05cd7b> - <@05cd83>): static sizeofVoid: int32 := sizeof(void)
	<.main+4679 @05cd7b> : 20 d0 00 00                load.m32 <@0000d0> ;void+32
	<.main+4683 @05cd7f> : 24 80 ad 05                store.m32 <@05ad80> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@05cd83> - <@05cd8b>): static sizeofBool: int32 := sizeof(bool)
	<.main+4687 @05cd83> : 20 70 01 00                load.m32 <@000170> ;bool+32
	<.main+4691 @05cd87> : 24 88 ad 05                store.m32 <@05ad88> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@05cd8b> - <@05cd93>): static sizeofChar: int32 := sizeof(char)
	<.main+4695 @05cd8b> : 20 10 02 00                load.m32 <@000210> ;char+32
	<.main+4699 @05cd8f> : 24 90 ad 05                store.m32 <@05ad90> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@05cd93> - <@05cd9b>): static sizeofInt8: int32 := sizeof(int8)
	<.main+4703 @05cd93> : 20 b0 02 00                load.m32 <@0002b0> ;int8+32
	<.main+4707 @05cd97> : 24 98 ad 05                store.m32 <@05ad98> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@05cd9b> - <@05cda3>): static sizeofInt16: int32 := sizeof(int16)
	<.main+4711 @05cd9b> : 20 50 03 00                load.m32 <@000350> ;int16+32
	<.main+4715 @05cd9f> : 24 a0 ad 05                store.m32 <@05ada0> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@05cda3> - <@05cdab>): static sizeofInt32: int32 := sizeof(int32)
	<.main+4719 @05cda3> : 20 f0 03 00                load.m32 <@0003f0> ;int32+32
	<.main+4723 @05cda7> : 24 a8 ad 05                store.m32 <@05ada8> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@05cdab> - <@05cdb3>): static sizeofInt64: int32 := sizeof(int64)
	<.main+4727 @05cdab> : 20 90 04 00                load.m32 <@000490> ;int64+32
	<.main+4731 @05cdaf> : 24 b0 ad 05                store.m32 <@05adb0> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@05cdb3> - <@05cdbb>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+4735 @05cdb3> : 20 30 05 00                load.m32 <@000530> ;uint8+32
	<.main+4739 @05cdb7> : 24 b8 ad 05                store.m32 <@05adb8> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@05cdbb> - <@05cdc3>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+4743 @05cdbb> : 20 d0 05 00                load.m32 <@0005d0> ;uint16+32
	<.main+4747 @05cdbf> : 24 c0 ad 05                store.m32 <@05adc0> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@05cdc3> - <@05cdcb>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+4751 @05cdc3> : 20 70 06 00                load.m32 <@000670> ;uint32+32
	<.main+4755 @05cdc7> : 24 c8 ad 05                store.m32 <@05adc8> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@05cdcb> - <@05cdd3>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+4759 @05cdcb> : 20 10 07 00                load.m32 <@000710> ;uint64+32
	<.main+4763 @05cdcf> : 24 d0 ad 05                store.m32 <@05add0> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@05cdd3> - <@05cddb>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+4767 @05cdd3> : 20 b0 07 00                load.m32 <@0007b0> ;float32+32
	<.main+4771 @05cdd7> : 24 d8 ad 05                store.m32 <@05add8> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@05cddb> - <@05cde3>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+4775 @05cddb> : 20 50 08 00                load.m32 <@000850> ;float64+32
	<.main+4779 @05cddf> : 24 e0 ad 05                store.m32 <@05ade0> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@05cde3> - <@05cdeb>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+4783 @05cde3> : 20 f0 08 00                load.m32 <@0008f0> ;pointer+32
	<.main+4787 @05cde7> : 24 e8 ad 05                store.m32 <@05ade8> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@05cdeb> - <@05cdf3>): static sizeofVariant: int32 := sizeof(variant)
	<.main+4791 @05cdeb> : 20 90 09 00                load.m32 <@000990> ;variant+32
	<.main+4795 @05cdef> : 24 f0 ad 05                store.m32 <@05adf0> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@05cdf3> - <@05cdfb>): static sizeofTypename: int32 := sizeof(typename)
	<.main+4799 @05cdf3> : 20 28 00 00                load.m32 <@000028> ;typename+32
	<.main+4803 @05cdf7> : 24 f8 ad 05                store.m32 <@05adf8> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@05cdfb> - <@05ce03>): static sizeofFunction: int32 := sizeof(function)
	<.main+4807 @05cdfb> : 20 30 0a 00                load.m32 <@000a30> ;function+32
	<.main+4811 @05cdff> : 24 00 ae 05                store.m32 <@05ae00> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@05ce03> - <@05ce0b>): static sizeofObject: int32 := sizeof(object)
	<.main+4815 @05ce03> : 20 d8 0a 00                load.m32 <@000ad8> ;object+32
	<.main+4819 @05ce07> : 24 08 ae 05                store.m32 <@05ae08> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@05ce0b> - <@05ce14>): static typeofRecord: typename := RecordSizeofExt
	<.main+4823 @05ce0b> : 1f 30 48 04 00             load.ref <@044830> ;RecordSizeofExt
	<.main+4828 @05ce10> : 24 10 ae 05                store.m32 <@05ae10> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@05ce14> - <@05ce20>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+4832 @05ce14> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4836 @05ce18> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4840 @05ce1c> : 24 18 ae 05                store.m32 <@05ae18> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@05ce20> - <@05ce2d>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+4844 @05ce20> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4848 @05ce24> : 0c 28 00 00                inc.i32(+40)
	<.main+4852 @05ce28> : 28                         load.i32
	<.main+4853 @05ce29> : 24 20 ae 05                store.m32 <@05ae20> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@05ce2d> - <@05ce3a>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+4857 @05ce2d> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4861 @05ce31> : 0c 20 00 00                inc.i32(+32)
	<.main+4865 @05ce35> : 28                         load.i32
	<.main+4866 @05ce36> : 24 28 ae 05                store.m32 <@05ae28> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@05ce3a> - <@05ce46>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+4870 @05ce3a> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4874 @05ce3e> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4878 @05ce42> : 24 30 ae 05                store.m32 <@05ae30> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@05ce46> - <@05ce52>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+4882 @05ce46> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4886 @05ce4a> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4890 @05ce4e> : 24 38 ae 05                store.m32 <@05ae38> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@05ce52> - <@05ce5e>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+4894 @05ce52> : 20 10 ae 05                load.m32 <@05ae10> ;typeofRecord
	<.main+4898 @05ce56> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4902 @05ce5a> : 24 40 ae 05                store.m32 <@05ae40> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@05ce5e> - <@05ce6a>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+4906 @05ce5e> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4910 @05ce62> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4914 @05ce66> : 24 48 ae 05                store.m32 <@05ae48> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@05ce6a> - <@05ce77>): static offsetOfBase: int32 := typeofBase.offset
	<.main+4918 @05ce6a> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4922 @05ce6e> : 0c 28 00 00                inc.i32(+40)
	<.main+4926 @05ce72> : 28                         load.i32
	<.main+4927 @05ce73> : 24 50 ae 05                store.m32 <@05ae50> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@05ce77> - <@05ce84>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+4931 @05ce77> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4935 @05ce7b> : 0c 20 00 00                inc.i32(+32)
	<.main+4939 @05ce7f> : 28                         load.i32
	<.main+4940 @05ce80> : 24 58 ae 05                store.m32 <@05ae58> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@05ce84> - <@05ce90>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+4944 @05ce84> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4948 @05ce88> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4952 @05ce8c> : 24 60 ae 05                store.m32 <@05ae60> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@05ce90> - <@05ce9c>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+4956 @05ce90> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4960 @05ce94> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4964 @05ce98> : 24 68 ae 05                store.m32 <@05ae68> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@05ce9c> - <@05cea8>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+4968 @05ce9c> : 20 40 ae 05                load.m32 <@05ae40> ;typeofBase
	<.main+4972 @05cea0> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4976 @05cea4> : 24 70 ae 05                store.m32 <@05ae70> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@05cea8> - <@05ceb5>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+4980 @05cea8> : 20 70 ae 05                load.m32 <@05ae70> ;typeofBase1
	<.main+4984 @05ceac> : 0c 28 00 00                inc.i32(+40)
	<.main+4988 @05ceb0> : 28                         load.i32
	<.main+4989 @05ceb1> : 24 78 ae 05                store.m32 <@05ae78> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@05ceb5> - <@05cec2>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+4993 @05ceb5> : 20 70 ae 05                load.m32 <@05ae70> ;typeofBase1
	<.main+4997 @05ceb9> : 0c 20 00 00                inc.i32(+32)
	<.main+5001 @05cebd> : 28                         load.i32
	<.main+5002 @05cebe> : 24 80 ae 05                store.m32 <@05ae80> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@05cec2> - <@05cece>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+5006 @05cec2> : 20 70 ae 05                load.m32 <@05ae70> ;typeofBase1
	<.main+5010 @05cec6> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5014 @05ceca> : 24 88 ae 05                store.m32 <@05ae88> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@05cece> - <@05cedb>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+5018 @05cece> : 20 88 ae 05                load.m32 <@05ae88> ;typeofBase2
	<.main+5022 @05ced2> : 0c 28 00 00                inc.i32(+40)
	<.main+5026 @05ced6> : 28                         load.i32
	<.main+5027 @05ced7> : 24 90 ae 05                store.m32 <@05ae90> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@05cedb> - <@05cee8>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+5031 @05cedb> : 20 88 ae 05                load.m32 <@05ae88> ;typeofBase2
	<.main+5035 @05cedf> : 0c 20 00 00                inc.i32(+32)
	<.main+5039 @05cee3> : 28                         load.i32
	<.main+5040 @05cee4> : 24 98 ae 05                store.m32 <@05ae98> ;sizeOfBase2
	test/lang/init.member.ci:34: (5 bytes: <@05cee8> - <@05ceed>): static global: int32
	<.main+5044 @05cee8> : 19                         load.z32
	<.main+5045 @05cee9> : 24 a0 ae 05                store.m32 <@05aea0> ;RecordMemberTest.global
	test/lang/init.member.ci:37: (9 bytes: <@05ceed> - <@05cef6>): static globalInit: int32 := 1
	<.main+5049 @05ceed> : 1c 01 00 00 00             load.c32 1
	<.main+5054 @05cef2> : 24 a8 ae 05                store.m32 <@05aea8> ;RecordMemberTest.globalInit
	test/lang/init.member.ci:40: (9 bytes: <@05cef6> - <@05ceff>): static const globalConstant: int32 := 2
	<.main+5058 @05cef6> : 1c 02 00 00 00             load.c32 2
	<.main+5063 @05cefb> : 24 b0 ae 05                store.m32 <@05aeb0> ;RecordMemberTest.globalConstant
	test/lang/init.member.ci:43: (14 bytes: <@05ceff> - <@05cf0d>): static globalRec: Inner := {...}
	<.main+5067 @05ceff> : 1c 04 00 00 00             load.c32 4
	<.main+5072 @05cf04> : 24 bc ae 05                store.m32 <@05aebc> ;RecordMemberTest.globalRec+4
	:: (5 bytes: <@05cf08> - <@05cf0d>): globalRec.member := (0)
	<.main+5076 @05cf08> : 19                         load.z32
	<.main+5077 @05cf09> : 24 b8 ae 05                store.m32 <@05aeb8> ;RecordMemberTest.globalRec
	test/lang/init.member.ci:46: (18 bytes: <@05cf0d> - <@05cf1f>): static globalRecInit: Inner := {...}
	<.main+5081 @05cf0d> : 1c 04 00 00 00             load.c32 4
	<.main+5086 @05cf12> : 24 c0 ae 05                store.m32 <@05aec0> ;RecordMemberTest.globalRecInit
	test/lang/init.member.ci:46: (9 bytes: <@05cf16> - <@05cf1f>): globalRecInit.constant := 5;
	<.main+5090 @05cf16> : 1c 05 00 00 00             load.c32 5
	<.main+5095 @05cf1b> : 24 c4 ae 05                store.m32 <@05aec4> ;RecordMemberTest.globalRecInit+4
	test/lang/init.member.ci:49: (18 bytes: <@05cf1f> - <@05cf31>): static const globalConstantRec: Inner := {...}
	<.main+5099 @05cf1f> : 1c 06 00 00 00             load.c32 6
	<.main+5104 @05cf24> : 24 c8 ae 05                store.m32 <@05aec8> ;RecordMemberTest.globalConstantRec
	test/lang/init.member.ci:49: (9 bytes: <@05cf28> - <@05cf31>): globalConstantRec.constant := 7;
	<.main+5108 @05cf28> : 1c 07 00 00 00             load.c32 7
	<.main+5113 @05cf2d> : 24 cc ae 05                store.m32 <@05aecc> ;RecordMemberTest.globalConstantRec+4
	test/lang/init.member.ci:52: (72 bytes: <@05cf31> - <@05cf79>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5117 @05cf31> : 1c 0a 00 00 00             load.c32 10
	<.main+5122 @05cf36> : 24 d0 ae 05                store.m32 <@05aed0> ;recordMemberTest
	test/lang/init.member.ci:54: (9 bytes: <@05cf3a> - <@05cf43>): recordMemberTest.constant := 11;
	<.main+5126 @05cf3a> : 1c 0b 00 00 00             load.c32 11
	<.main+5131 @05cf3f> : 24 d4 ae 05                store.m32 <@05aed4> ;recordMemberTest+4
	test/lang/init.member.ci:55: (9 bytes: <@05cf43> - <@05cf4c>): recordMemberTest.memberInit := 12;
	<.main+5135 @05cf43> : 1c 0c 00 00 00             load.c32 12
	<.main+5140 @05cf48> : 24 d8 ae 05                store.m32 <@05aed8> ;recordMemberTest+8
	test/lang/init.member.ci:56: (9 bytes: <@05cf4c> - <@05cf55>): recordMemberTest.constantInit := 13;
	<.main+5144 @05cf4c> : 1c 0d 00 00 00             load.c32 13
	<.main+5149 @05cf51> : 24 dc ae 05                store.m32 <@05aedc> ;recordMemberTest+12
	test/lang/init.member.ci:59: (9 bytes: <@05cf55> - <@05cf5e>): recordMemberTest.memberRec.member := 14;
	<.main+5153 @05cf55> : 1c 0e 00 00 00             load.c32 14
	<.main+5158 @05cf5a> : 24 e0 ae 05                store.m32 <@05aee0> ;recordMemberTest+16
	test/lang/init.member.ci:60: (9 bytes: <@05cf5e> - <@05cf67>): recordMemberTest.memberRec.constant := 15;
	<.main+5162 @05cf5e> : 1c 0f 00 00 00             load.c32 15
	<.main+5167 @05cf63> : 24 e4 ae 05                store.m32 <@05aee4> ;recordMemberTest+20
	test/lang/init.member.ci:64: (9 bytes: <@05cf67> - <@05cf70>): recordMemberTest.constantRec.member := 16;
	<.main+5171 @05cf67> : 1c 10 00 00 00             load.c32 16
	<.main+5176 @05cf6c> : 24 e8 ae 05                store.m32 <@05aee8> ;recordMemberTest+24
	test/lang/init.member.ci:65: (9 bytes: <@05cf70> - <@05cf79>): recordMemberTest.constantRec.constant := 17;
	<.main+5180 @05cf70> : 1c 11 00 00 00             load.c32 17
	<.main+5185 @05cf75> : 24 ec ae 05                store.m32 <@05aeec> ;recordMemberTest+28
	test/lang/init.method.ci:18: (9 bytes: <@05cf79> - <@05cf82>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5189 @05cf79> : 1f 48 af 05 00             load.ref <@05af48> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5194 @05cf7e> : 24 18 af 05                store.m32 <@05af18> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/init.method.ci:62: (26 bytes: <@05cf82> - <@05cf9c>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5198 @05cf82> : 1f 70 af 05 00             load.ref <@05af70> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5203 @05cf87> : 24 98 af 05                store.m32 <@05af98> ;recordMethodTest
	:: (8 bytes: <@05cf8b> - <@05cf93>): recordMethodTest.delegateMethod := forwardMethod
	<.main+5207 @05cf8b> : 20 18 af 05                load.m32 <@05af18> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5211 @05cf8f> : 24 9c af 05                store.m32 <@05af9c> ;recordMethodTest+4
	:: (9 bytes: <@05cf93> - <@05cf9c>): recordMethodTest.virtualMethod := virtualMethod
	<.main+5215 @05cf93> : 1f 20 af 05 00             load.ref <@05af20> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5220 @05cf98> : 24 a0 af 05                store.m32 <@05afa0> ;recordMethodTest+8
	test/lang/init.array.ci:11: (91 bytes: <@05cf9c> - <@05cff7>): static arrFixedInit: int64[7] := {...}
	<.main+5224 @05cf9c> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+5233 @05cfa5> : 23 30 b0 05                store.m64 <@05b030> ;arrFixedInit
	test/lang/init.array.ci:11: (13 bytes: <@05cfa9> - <@05cfb6>): arrFixedInit[1] := (43);
	<.main+5237 @05cfa9> : 1d 2b 00 00 00 00 00 00 00 load.c64 43
	<.main+5246 @05cfb2> : 23 38 b0 05                store.m64 <@05b038> ;arrFixedInit+8
	test/lang/init.array.ci:11: (13 bytes: <@05cfb6> - <@05cfc3>): arrFixedInit[2] := (44);
	<.main+5250 @05cfb6> : 1d 2c 00 00 00 00 00 00 00 load.c64 44
	<.main+5259 @05cfbf> : 23 40 b0 05                store.m64 <@05b040> ;arrFixedInit+16
	test/lang/init.array.ci:11: (13 bytes: <@05cfc3> - <@05cfd0>): arrFixedInit[3] := (45);
	<.main+5263 @05cfc3> : 1d 2d 00 00 00 00 00 00 00 load.c64 45
	<.main+5272 @05cfcc> : 23 48 b0 05                store.m64 <@05b048> ;arrFixedInit+24
	test/lang/init.array.ci:11: (13 bytes: <@05cfd0> - <@05cfdd>): arrFixedInit[4] := (46);
	<.main+5276 @05cfd0> : 1d 2e 00 00 00 00 00 00 00 load.c64 46
	<.main+5285 @05cfd9> : 23 50 b0 05                store.m64 <@05b050> ;arrFixedInit+32
	test/lang/init.array.ci:11: (13 bytes: <@05cfdd> - <@05cfea>): arrFixedInit[5] := (47);
	<.main+5289 @05cfdd> : 1d 2f 00 00 00 00 00 00 00 load.c64 47
	<.main+5298 @05cfe6> : 23 58 b0 05                store.m64 <@05b058> ;arrFixedInit+40
	test/lang/init.array.ci:11: (13 bytes: <@05cfea> - <@05cff7>): arrFixedInit[6] := (48);
	<.main+5302 @05cfea> : 1d 30 00 00 00 00 00 00 00 load.c64 48
	<.main+5311 @05cff3> : 23 60 b0 05                store.m64 <@05b060> ;arrFixedInit+48
	test/lang/init.array.ci:18: (9 bytes: <@05cff7> - <@05d000>): static arrArrayInitNull: int64[*] := null
	<.main+5315 @05cff7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5320 @05cffc> : 24 68 b0 05                store.m32 <@05b068> ;arrArrayInitNull
	test/lang/init.array.ci:19: (10 bytes: <@05d000> - <@05d00a>): static arrSliceInitNull: int64[] := null
	<.main+5324 @05d000> : 19                         load.z32
	<.main+5325 @05d001> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5330 @05d006> : 23 70 b0 05                store.m64 <@05b070> ;arrSliceInitNull
	test/lang/init.array.ci:22: (9 bytes: <@05d00a> - <@05d013>): static arrArrayInitFixed: int64[*] := arrFixedInit
	<.main+5334 @05d00a> : 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+5339 @05d00f> : 24 78 b0 05                store.m32 <@05b078> ;arrArrayInitFixed
	test/lang/init.array.ci:23: (14 bytes: <@05d013> - <@05d021>): static arrSliceInitFixed: int64[] := arrFixedInit
	<.main+5343 @05d013> : 1c 07 00 00 00             load.c32 7
	<.main+5348 @05d018> : 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+5353 @05d01d> : 23 80 b0 05                store.m64 <@05b080> ;arrSliceInitFixed
	test/lang/init.array.ci:26: (8 bytes: <@05d021> - <@05d029>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+5357 @05d021> : 20 80 b0 05                load.m32 <@05b080> ;arrSliceInitFixed
	<.main+5361 @05d025> : 24 88 b0 05                store.m32 <@05b088> ;arrArrayInitSlice
	test/lang/init.array.ci:27: (8 bytes: <@05d029> - <@05d031>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+5365 @05d029> : 21 80 b0 05                load.m64 <@05b080> ;arrSliceInitFixed
	<.main+5369 @05d02d> : 23 90 b0 05                store.m64 <@05b090> ;arrSliceInitSlice
	test/lang/init.array.ci:30: (8 bytes: <@05d031> - <@05d039>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+5373 @05d031> : 20 78 b0 05                load.m32 <@05b078> ;arrArrayInitFixed
	<.main+5377 @05d035> : 24 98 b0 05                store.m32 <@05b098> ;arrArrayInitPtr
	test/lang/init.array.ci:34: (73 bytes: <@05d039> - <@05d082>): static strFixed: char[7] := {...}
	<.main+5381 @05d039> : 1c 73 00 00 00             load.c32 115
	<.main+5386 @05d03e> : 1f a0 b0 05 00             load.ref <@05b0a0> ;strFixed
	<.main+5391 @05d043> : 2b                         store.i8
	test/lang/init.array.ci:34: (11 bytes: <@05d044> - <@05d04f>): strFixed[1] := 't';
	<.main+5392 @05d044> : 1c 74 00 00 00             load.c32 116
	<.main+5397 @05d049> : 1f a1 b0 05 00             load.ref <@05b0a1> ;strFixed+1
	<.main+5402 @05d04e> : 2b                         store.i8
	test/lang/init.array.ci:34: (11 bytes: <@05d04f> - <@05d05a>): strFixed[2] := 'r';
	<.main+5403 @05d04f> : 1c 72 00 00 00             load.c32 114
	<.main+5408 @05d054> : 1f a2 b0 05 00             load.ref <@05b0a2> ;strFixed+2
	<.main+5413 @05d059> : 2b                         store.i8
	test/lang/init.array.ci:34: (11 bytes: <@05d05a> - <@05d065>): strFixed[3] := 'i';
	<.main+5414 @05d05a> : 1c 69 00 00 00             load.c32 105
	<.main+5419 @05d05f> : 1f a3 b0 05 00             load.ref <@05b0a3> ;strFixed+3
	<.main+5424 @05d064> : 2b                         store.i8
	test/lang/init.array.ci:34: (11 bytes: <@05d065> - <@05d070>): strFixed[4] := 'n';
	<.main+5425 @05d065> : 1c 6e 00 00 00             load.c32 110
	<.main+5430 @05d06a> : 1f a4 b0 05 00             load.ref <@05b0a4> ;strFixed+4
	<.main+5435 @05d06f> : 2b                         store.i8
	test/lang/init.array.ci:34: (11 bytes: <@05d070> - <@05d07b>): strFixed[5] := 'g';
	<.main+5436 @05d070> : 1c 67 00 00 00             load.c32 103
	<.main+5441 @05d075> : 1f a5 b0 05 00             load.ref <@05b0a5> ;strFixed+5
	<.main+5446 @05d07a> : 2b                         store.i8
	test/lang/init.array.ci:34: (7 bytes: <@05d07b> - <@05d082>): strFixed[6] := (0);
	<.main+5447 @05d07b> : 19                         load.z32
	<.main+5448 @05d07c> : 1f a6 b0 05 00             load.ref <@05b0a6> ;strFixed+6
	<.main+5453 @05d081> : 2b                         store.i8
	test/lang/init.array.ci:37: (9 bytes: <@05d082> - <@05d08b>): static strArray: char[*] := "string"
	<.main+5454 @05d082> : 1f 4d 3a 03 00             load.ref <@033a4d> ;"string"
	<.main+5459 @05d087> : 24 a8 b0 05                store.m32 <@05b0a8> ;strArray
	test/lang/init.array.ci:40: (14 bytes: <@05d08b> - <@05d099>): static strSlice: char[] := "string"
	<.main+5463 @05d08b> : 1c 06 00 00 00             load.c32 6
	<.main+5468 @05d090> : 1f 4d 3a 03 00             load.ref <@033a4d> ;"string"
	<.main+5473 @05d095> : 23 b0 b0 05                store.m64 <@05b0b0> ;strSlice
	test/lang/recUnion.ci:26: (21 bytes: <@05d099> - <@05d0ae>): static black: rgbU8 := {...}
	<.main+5477 @05d099> : 19                         load.z32
	<.main+5478 @05d09a> : 1f f2 b0 05 00             load.ref <@05b0f2> ;black+2
	<.main+5483 @05d09f> : 2b                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@05d0a0> - <@05d0a7>): black.g := (0);
	<.main+5484 @05d0a0> : 19                         load.z32
	<.main+5485 @05d0a1> : 1f f1 b0 05 00             load.ref <@05b0f1> ;black+1
	<.main+5490 @05d0a6> : 2b                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@05d0a7> - <@05d0ae>): black.b := (0);
	<.main+5491 @05d0a7> : 19                         load.z32
	<.main+5492 @05d0a8> : 1f f0 b0 05 00             load.ref <@05b0f0> ;black
	<.main+5497 @05d0ad> : 2b                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@05d0ae> - <@05d0c7>): static green: rgbU8 := {...}
	<.main+5498 @05d0ae> : 19                         load.z32
	<.main+5499 @05d0af> : 1f fa b0 05 00             load.ref <@05b0fa> ;green+2
	<.main+5504 @05d0b4> : 2b                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@05d0b5> - <@05d0c0>): green.g := (255);
	<.main+5505 @05d0b5> : 1c ff 00 00 00             load.c32 255
	<.main+5510 @05d0ba> : 1f f9 b0 05 00             load.ref <@05b0f9> ;green+1
	<.main+5515 @05d0bf> : 2b                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@05d0c0> - <@05d0c7>): green.b := (0);
	<.main+5516 @05d0c0> : 19                         load.z32
	<.main+5517 @05d0c1> : 1f f8 b0 05 00             load.ref <@05b0f8> ;green
	<.main+5522 @05d0c6> : 2b                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@05d0c7> - <@05d0e8>): static white: rgbU8 := {...}
	<.main+5523 @05d0c7> : 1c ff 00 00 00             load.c32 255
	<.main+5528 @05d0cc> : 1f 02 b1 05 00             load.ref <@05b102> ;white+2
	<.main+5533 @05d0d1> : 2b                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@05d0d2> - <@05d0dd>): white.g := (255);
	<.main+5534 @05d0d2> : 1c ff 00 00 00             load.c32 255
	<.main+5539 @05d0d7> : 1f 01 b1 05 00             load.ref <@05b101> ;white+1
	<.main+5544 @05d0dc> : 2b                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@05d0dd> - <@05d0e8>): white.b := (255);
	<.main+5545 @05d0dd> : 1c ff 00 00 00             load.c32 255
	<.main+5550 @05d0e2> : 1f 00 b1 05 00             load.ref <@05b100> ;white
	<.main+5555 @05d0e7> : 2b                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@05d0e8> - <@05d0f1>): static cyan: color := {...}
	<.main+5556 @05d0e8> : 1c ff ff 00 00             load.c32 65535
	<.main+5561 @05d0ed> : 24 08 b1 05                store.m32 <@05b108> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@05d0f1> - <@05d10a>): static blue: color := {...}
	<.main+5565 @05d0f1> : 19                         load.z32
	<.main+5566 @05d0f2> : 1f 12 b1 05 00             load.ref <@05b112> ;blue+2
	<.main+5571 @05d0f7> : 2b                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@05d0f8> - <@05d0ff>): blue.rgb.g := (0);
	<.main+5572 @05d0f8> : 19                         load.z32
	<.main+5573 @05d0f9> : 1f 11 b1 05 00             load.ref <@05b111> ;blue+1
	<.main+5578 @05d0fe> : 2b                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@05d0ff> - <@05d10a>): blue.rgb.b := (255);
	<.main+5579 @05d0ff> : 1c ff 00 00 00             load.c32 255
	<.main+5584 @05d104> : 1f 10 b1 05 00             load.ref <@05b110> ;blue
	<.main+5589 @05d109> : 2b                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@05d10a> - <@05d113>): static shift: int32 := 2
	<.main+5590 @05d10a> : 1c 02 00 00 00             load.c32 2
	<.main+5595 @05d10f> : 24 18 b1 05                store.m32 <@05b118> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@05d113> - <@05d11e>): static boolA: bool := true
	<.main+5599 @05d113> : 1c 01 00 00 00             load.c32 1
	<.main+5604 @05d118> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5609 @05d11d> : 2b                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@05d11e> - <@05d129>): static boolB: bool := !false
	<.main+5610 @05d11e> : 1c 01 00 00 00             load.c32 1
	<.main+5615 @05d123> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5620 @05d128> : 2b                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@05d129> - <@05d13c>): static boolAnd: bool := boolA & boolB
	<.main+5621 @05d129> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5626 @05d12e> : 26                         load.i8
	<.main+5627 @05d12f> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5632 @05d134> : 26                         load.i8
	<.main+5633 @05d135> : 31                         and.b32
	<.main+5634 @05d136> : 1f 30 b1 05 00             load.ref <@05b130> ;boolAnd
	<.main+5639 @05d13b> : 2b                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@05d13c> - <@05d14f>): static boolIor: bool := boolA | boolB
	<.main+5640 @05d13c> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5645 @05d141> : 26                         load.i8
	<.main+5646 @05d142> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5651 @05d147> : 26                         load.i8
	<.main+5652 @05d148> : 32                         or.b32
	<.main+5653 @05d149> : 1f 38 b1 05 00             load.ref <@05b138> ;boolIor
	<.main+5658 @05d14e> : 2b                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@05d14f> - <@05d162>): static boolXor: bool := boolA ^ boolB
	<.main+5659 @05d14f> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5664 @05d154> : 26                         load.i8
	<.main+5665 @05d155> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5670 @05d15a> : 26                         load.i8
	<.main+5671 @05d15b> : 36                         xor.b32
	<.main+5672 @05d15c> : 1f 40 b1 05 00             load.ref <@05b140> ;boolXor
	<.main+5677 @05d161> : 2b                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@05d162> - <@05d16f>): static boolNot: bool := !boolB
	<.main+5678 @05d162> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5683 @05d167> : 26                         load.i8
	<.main+5684 @05d168> : 0b                         not.b32
	<.main+5685 @05d169> : 1f 48 b1 05 00             load.ref <@05b148> ;boolNot
	<.main+5690 @05d16e> : 2b                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@05d16f> - <@05d182>): static boolCeq: bool := boolA == boolB
	<.main+5691 @05d16f> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5696 @05d174> : 26                         load.i8
	<.main+5697 @05d175> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5702 @05d17a> : 26                         load.i8
	<.main+5703 @05d17b> : 57                         ceq.i32
	<.main+5704 @05d17c> : 1f 50 b1 05 00             load.ref <@05b150> ;boolCeq
	<.main+5709 @05d181> : 2b                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@05d182> - <@05d196>): static boolCne: bool := boolA != boolB
	<.main+5710 @05d182> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5715 @05d187> : 26                         load.i8
	<.main+5716 @05d188> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5721 @05d18d> : 26                         load.i8
	<.main+5722 @05d18e> : 57                         ceq.i32
	<.main+5723 @05d18f> : 0b                         not.b32
	<.main+5724 @05d190> : 1f 58 b1 05 00             load.ref <@05b158> ;boolCne
	<.main+5729 @05d195> : 2b                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@05d196> - <@05d1a9>): static boolClt: bool := boolA < boolB
	<.main+5730 @05d196> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5735 @05d19b> : 26                         load.i8
	<.main+5736 @05d19c> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5741 @05d1a1> : 26                         load.i8
	<.main+5742 @05d1a2> : 58                         clt.i32
	<.main+5743 @05d1a3> : 1f 60 b1 05 00             load.ref <@05b160> ;boolClt
	<.main+5748 @05d1a8> : 2b                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@05d1a9> - <@05d1bd>): static boolCle: bool := boolA <= boolB
	<.main+5749 @05d1a9> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5754 @05d1ae> : 26                         load.i8
	<.main+5755 @05d1af> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5760 @05d1b4> : 26                         load.i8
	<.main+5761 @05d1b5> : 59                         cgt.i32
	<.main+5762 @05d1b6> : 0b                         not.b32
	<.main+5763 @05d1b7> : 1f 68 b1 05 00             load.ref <@05b168> ;boolCle
	<.main+5768 @05d1bc> : 2b                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@05d1bd> - <@05d1d0>): static boolCgt: bool := boolA > boolB
	<.main+5769 @05d1bd> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5774 @05d1c2> : 26                         load.i8
	<.main+5775 @05d1c3> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5780 @05d1c8> : 26                         load.i8
	<.main+5781 @05d1c9> : 59                         cgt.i32
	<.main+5782 @05d1ca> : 1f 70 b1 05 00             load.ref <@05b170> ;boolCgt
	<.main+5787 @05d1cf> : 2b                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@05d1d0> - <@05d1e4>): static boolCge: bool := boolA >= boolB
	<.main+5788 @05d1d0> : 1f 20 b1 05 00             load.ref <@05b120> ;boolA
	<.main+5793 @05d1d5> : 26                         load.i8
	<.main+5794 @05d1d6> : 1f 28 b1 05 00             load.ref <@05b128> ;boolB
	<.main+5799 @05d1db> : 26                         load.i8
	<.main+5800 @05d1dc> : 58                         clt.i32
	<.main+5801 @05d1dd> : 0b                         not.b32
	<.main+5802 @05d1de> : 1f 78 b1 05 00             load.ref <@05b178> ;boolCge
	<.main+5807 @05d1e3> : 2b                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@05d1e4> - <@05d1ef>): static chrA: char := 'a'
	<.main+5808 @05d1e4> : 1c 61 00 00 00             load.c32 97
	<.main+5813 @05d1e9> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5818 @05d1ee> : 2b                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@05d1ef> - <@05d1fa>): static chrB: char := 'b'
	<.main+5819 @05d1ef> : 1c 62 00 00 00             load.c32 98
	<.main+5824 @05d1f4> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5829 @05d1f9> : 2b                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@05d1fa> - <@05d206>): static chrPls: char := +chrB
	<.main+5830 @05d1fa> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5835 @05d1ff> : 26                         load.i8
	<.main+5836 @05d200> : 1f 90 b1 05 00             load.ref <@05b190> ;chrPls
	<.main+5841 @05d205> : 2b                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@05d206> - <@05d213>): static chrNeg: char := -chrB
	<.main+5842 @05d206> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5847 @05d20b> : 26                         load.i8
	<.main+5848 @05d20c> : 50                         neg.i32
	<.main+5849 @05d20d> : 1f 98 b1 05 00             load.ref <@05b198> ;chrNeg
	<.main+5854 @05d212> : 2b                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@05d213> - <@05d220>): static chrCmt: char := ~chrB
	<.main+5855 @05d213> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5860 @05d218> : 26                         load.i8
	<.main+5861 @05d219> : 30                         cmt.b32
	<.main+5862 @05d21a> : 1f a0 b1 05 00             load.ref <@05b1a0> ;chrCmt
	<.main+5867 @05d21f> : 2b                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@05d220> - <@05d233>): static chrAdd: char := chrA + chrB
	<.main+5868 @05d220> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5873 @05d225> : 26                         load.i8
	<.main+5874 @05d226> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5879 @05d22b> : 26                         load.i8
	<.main+5880 @05d22c> : 51                         add.i32
	<.main+5881 @05d22d> : 1f a8 b1 05 00             load.ref <@05b1a8> ;chrAdd
	<.main+5886 @05d232> : 2b                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@05d233> - <@05d246>): static chrSub: char := chrA - chrB
	<.main+5887 @05d233> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5892 @05d238> : 26                         load.i8
	<.main+5893 @05d239> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5898 @05d23e> : 26                         load.i8
	<.main+5899 @05d23f> : 52                         sub.i32
	<.main+5900 @05d240> : 1f b0 b1 05 00             load.ref <@05b1b0> ;chrSub
	<.main+5905 @05d245> : 2b                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@05d246> - <@05d259>): static chrMul: char := chrA * chrB
	<.main+5906 @05d246> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5911 @05d24b> : 26                         load.i8
	<.main+5912 @05d24c> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5917 @05d251> : 26                         load.i8
	<.main+5918 @05d252> : 53                         mul.i32
	<.main+5919 @05d253> : 1f b8 b1 05 00             load.ref <@05b1b8> ;chrMul
	<.main+5924 @05d258> : 2b                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@05d259> - <@05d26c>): static chrDiv: char := chrA / chrB
	<.main+5925 @05d259> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5930 @05d25e> : 26                         load.i8
	<.main+5931 @05d25f> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5936 @05d264> : 26                         load.i8
	<.main+5937 @05d265> : 54                         div.i32
	<.main+5938 @05d266> : 1f c0 b1 05 00             load.ref <@05b1c0> ;chrDiv
	<.main+5943 @05d26b> : 2b                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@05d26c> - <@05d27f>): static chrMod: char := chrA % chrB
	<.main+5944 @05d26c> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5949 @05d271> : 26                         load.i8
	<.main+5950 @05d272> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5955 @05d277> : 26                         load.i8
	<.main+5956 @05d278> : 55                         mod.i32
	<.main+5957 @05d279> : 1f c8 b1 05 00             load.ref <@05b1c8> ;chrMod
	<.main+5962 @05d27e> : 2b                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@05d27f> - <@05d292>): static chrAnd: char := chrA & chrB
	<.main+5963 @05d27f> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5968 @05d284> : 26                         load.i8
	<.main+5969 @05d285> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5974 @05d28a> : 26                         load.i8
	<.main+5975 @05d28b> : 31                         and.b32
	<.main+5976 @05d28c> : 1f d0 b1 05 00             load.ref <@05b1d0> ;chrAnd
	<.main+5981 @05d291> : 2b                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@05d292> - <@05d2a5>): static chrIor: char := chrA | chrB
	<.main+5982 @05d292> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+5987 @05d297> : 26                         load.i8
	<.main+5988 @05d298> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+5993 @05d29d> : 26                         load.i8
	<.main+5994 @05d29e> : 32                         or.b32
	<.main+5995 @05d29f> : 1f d8 b1 05 00             load.ref <@05b1d8> ;chrIor
	<.main+6000 @05d2a4> : 2b                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@05d2a5> - <@05d2b8>): static chrXor: char := chrA ^ chrB
	<.main+6001 @05d2a5> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6006 @05d2aa> : 26                         load.i8
	<.main+6007 @05d2ab> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6012 @05d2b0> : 26                         load.i8
	<.main+6013 @05d2b1> : 36                         xor.b32
	<.main+6014 @05d2b2> : 1f e0 b1 05 00             load.ref <@05b1e0> ;chrXor
	<.main+6019 @05d2b7> : 2b                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@05d2b8> - <@05d2c9>): static chrShl: char := (chrA) << shift
	<.main+6020 @05d2b8> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6025 @05d2bd> : 26                         load.i8
	<.main+6026 @05d2be> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6030 @05d2c2> : 3a                         shl.b32
	<.main+6031 @05d2c3> : 1f e8 b1 05 00             load.ref <@05b1e8> ;chrShl
	<.main+6036 @05d2c8> : 2b                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@05d2c9> - <@05d2da>): static chrShr: char := (chrA) >> shift
	<.main+6037 @05d2c9> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6042 @05d2ce> : 26                         load.i8
	<.main+6043 @05d2cf> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6047 @05d2d3> : 3c                         sar.b32
	<.main+6048 @05d2d4> : 1f f0 b1 05 00             load.ref <@05b1f0> ;chrShr
	<.main+6053 @05d2d9> : 2b                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@05d2da> - <@05d2e8>): static chrNot: bool := !(chrB)
	<.main+6054 @05d2da> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6059 @05d2df> : 26                         load.i8
	<.main+6060 @05d2e0> : 5a                         i32.2bool
	<.main+6061 @05d2e1> : 0b                         not.b32
	<.main+6062 @05d2e2> : 1f f8 b1 05 00             load.ref <@05b1f8> ;chrNot
	<.main+6067 @05d2e7> : 2b                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@05d2e8> - <@05d2fb>): static chrCeq: bool := chrA == chrB
	<.main+6068 @05d2e8> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6073 @05d2ed> : 26                         load.i8
	<.main+6074 @05d2ee> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6079 @05d2f3> : 26                         load.i8
	<.main+6080 @05d2f4> : 57                         ceq.i32
	<.main+6081 @05d2f5> : 1f 00 b2 05 00             load.ref <@05b200> ;chrCeq
	<.main+6086 @05d2fa> : 2b                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@05d2fb> - <@05d30f>): static chrCne: bool := chrA != chrB
	<.main+6087 @05d2fb> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6092 @05d300> : 26                         load.i8
	<.main+6093 @05d301> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6098 @05d306> : 26                         load.i8
	<.main+6099 @05d307> : 57                         ceq.i32
	<.main+6100 @05d308> : 0b                         not.b32
	<.main+6101 @05d309> : 1f 08 b2 05 00             load.ref <@05b208> ;chrCne
	<.main+6106 @05d30e> : 2b                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@05d30f> - <@05d322>): static chrClt: bool := chrA < chrB
	<.main+6107 @05d30f> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6112 @05d314> : 26                         load.i8
	<.main+6113 @05d315> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6118 @05d31a> : 26                         load.i8
	<.main+6119 @05d31b> : 58                         clt.i32
	<.main+6120 @05d31c> : 1f 10 b2 05 00             load.ref <@05b210> ;chrClt
	<.main+6125 @05d321> : 2b                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@05d322> - <@05d336>): static chrCle: bool := chrA <= chrB
	<.main+6126 @05d322> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6131 @05d327> : 26                         load.i8
	<.main+6132 @05d328> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6137 @05d32d> : 26                         load.i8
	<.main+6138 @05d32e> : 59                         cgt.i32
	<.main+6139 @05d32f> : 0b                         not.b32
	<.main+6140 @05d330> : 1f 18 b2 05 00             load.ref <@05b218> ;chrCle
	<.main+6145 @05d335> : 2b                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@05d336> - <@05d349>): static chrCgt: bool := chrA > chrB
	<.main+6146 @05d336> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6151 @05d33b> : 26                         load.i8
	<.main+6152 @05d33c> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6157 @05d341> : 26                         load.i8
	<.main+6158 @05d342> : 59                         cgt.i32
	<.main+6159 @05d343> : 1f 20 b2 05 00             load.ref <@05b220> ;chrCgt
	<.main+6164 @05d348> : 2b                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@05d349> - <@05d35d>): static chrCge: bool := chrA >= chrB
	<.main+6165 @05d349> : 1f 80 b1 05 00             load.ref <@05b180> ;chrA
	<.main+6170 @05d34e> : 26                         load.i8
	<.main+6171 @05d34f> : 1f 88 b1 05 00             load.ref <@05b188> ;chrB
	<.main+6176 @05d354> : 26                         load.i8
	<.main+6177 @05d355> : 58                         clt.i32
	<.main+6178 @05d356> : 0b                         not.b32
	<.main+6179 @05d357> : 1f 28 b2 05 00             load.ref <@05b228> ;chrCge
	<.main+6184 @05d35c> : 2b                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@05d35d> - <@05d368>): static i8A: int8 := a
	<.main+6185 @05d35d> : 1c 60 00 00 00             load.c32 96
	<.main+6190 @05d362> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6195 @05d367> : 2b                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@05d368> - <@05d373>): static i8B: int8 := b
	<.main+6196 @05d368> : 1c 2a 00 00 00             load.c32 42
	<.main+6201 @05d36d> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6206 @05d372> : 2b                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@05d373> - <@05d37f>): static i8Pls: int8 := +i8B
	<.main+6207 @05d373> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6212 @05d378> : 26                         load.i8
	<.main+6213 @05d379> : 1f 40 b2 05 00             load.ref <@05b240> ;i8Pls
	<.main+6218 @05d37e> : 2b                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@05d37f> - <@05d38c>): static i8Neg: int8 := -i8B
	<.main+6219 @05d37f> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6224 @05d384> : 26                         load.i8
	<.main+6225 @05d385> : 50                         neg.i32
	<.main+6226 @05d386> : 1f 48 b2 05 00             load.ref <@05b248> ;i8Neg
	<.main+6231 @05d38b> : 2b                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@05d38c> - <@05d399>): static i8Cmt: int8 := ~i8B
	<.main+6232 @05d38c> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6237 @05d391> : 26                         load.i8
	<.main+6238 @05d392> : 30                         cmt.b32
	<.main+6239 @05d393> : 1f 50 b2 05 00             load.ref <@05b250> ;i8Cmt
	<.main+6244 @05d398> : 2b                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@05d399> - <@05d3ac>): static i8Add: int8 := i8A + i8B
	<.main+6245 @05d399> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6250 @05d39e> : 26                         load.i8
	<.main+6251 @05d39f> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6256 @05d3a4> : 26                         load.i8
	<.main+6257 @05d3a5> : 51                         add.i32
	<.main+6258 @05d3a6> : 1f 58 b2 05 00             load.ref <@05b258> ;i8Add
	<.main+6263 @05d3ab> : 2b                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@05d3ac> - <@05d3bf>): static i8Sub: int8 := i8A - i8B
	<.main+6264 @05d3ac> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6269 @05d3b1> : 26                         load.i8
	<.main+6270 @05d3b2> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6275 @05d3b7> : 26                         load.i8
	<.main+6276 @05d3b8> : 52                         sub.i32
	<.main+6277 @05d3b9> : 1f 60 b2 05 00             load.ref <@05b260> ;i8Sub
	<.main+6282 @05d3be> : 2b                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@05d3bf> - <@05d3d2>): static i8Mul: int8 := i8A * i8B
	<.main+6283 @05d3bf> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6288 @05d3c4> : 26                         load.i8
	<.main+6289 @05d3c5> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6294 @05d3ca> : 26                         load.i8
	<.main+6295 @05d3cb> : 53                         mul.i32
	<.main+6296 @05d3cc> : 1f 68 b2 05 00             load.ref <@05b268> ;i8Mul
	<.main+6301 @05d3d1> : 2b                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@05d3d2> - <@05d3e5>): static i8Div: int8 := i8A / i8B
	<.main+6302 @05d3d2> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6307 @05d3d7> : 26                         load.i8
	<.main+6308 @05d3d8> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6313 @05d3dd> : 26                         load.i8
	<.main+6314 @05d3de> : 54                         div.i32
	<.main+6315 @05d3df> : 1f 70 b2 05 00             load.ref <@05b270> ;i8Div
	<.main+6320 @05d3e4> : 2b                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@05d3e5> - <@05d3f8>): static i8Mod: int8 := i8A % i8B
	<.main+6321 @05d3e5> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6326 @05d3ea> : 26                         load.i8
	<.main+6327 @05d3eb> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6332 @05d3f0> : 26                         load.i8
	<.main+6333 @05d3f1> : 55                         mod.i32
	<.main+6334 @05d3f2> : 1f 78 b2 05 00             load.ref <@05b278> ;i8Mod
	<.main+6339 @05d3f7> : 2b                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@05d3f8> - <@05d40b>): static i8And: int8 := i8A & i8B
	<.main+6340 @05d3f8> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6345 @05d3fd> : 26                         load.i8
	<.main+6346 @05d3fe> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6351 @05d403> : 26                         load.i8
	<.main+6352 @05d404> : 31                         and.b32
	<.main+6353 @05d405> : 1f 80 b2 05 00             load.ref <@05b280> ;i8And
	<.main+6358 @05d40a> : 2b                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@05d40b> - <@05d41e>): static i8Ior: int8 := i8A | i8B
	<.main+6359 @05d40b> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6364 @05d410> : 26                         load.i8
	<.main+6365 @05d411> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6370 @05d416> : 26                         load.i8
	<.main+6371 @05d417> : 32                         or.b32
	<.main+6372 @05d418> : 1f 88 b2 05 00             load.ref <@05b288> ;i8Ior
	<.main+6377 @05d41d> : 2b                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@05d41e> - <@05d431>): static i8Xor: int8 := i8A ^ i8B
	<.main+6378 @05d41e> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6383 @05d423> : 26                         load.i8
	<.main+6384 @05d424> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6389 @05d429> : 26                         load.i8
	<.main+6390 @05d42a> : 36                         xor.b32
	<.main+6391 @05d42b> : 1f 90 b2 05 00             load.ref <@05b290> ;i8Xor
	<.main+6396 @05d430> : 2b                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@05d431> - <@05d442>): static i8Shl: int8 := (i8A) << shift
	<.main+6397 @05d431> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6402 @05d436> : 26                         load.i8
	<.main+6403 @05d437> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6407 @05d43b> : 3a                         shl.b32
	<.main+6408 @05d43c> : 1f 98 b2 05 00             load.ref <@05b298> ;i8Shl
	<.main+6413 @05d441> : 2b                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@05d442> - <@05d453>): static i8Shr: int8 := (i8A) >> shift
	<.main+6414 @05d442> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6419 @05d447> : 26                         load.i8
	<.main+6420 @05d448> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6424 @05d44c> : 3c                         sar.b32
	<.main+6425 @05d44d> : 1f a0 b2 05 00             load.ref <@05b2a0> ;i8Shr
	<.main+6430 @05d452> : 2b                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@05d453> - <@05d461>): static i8Not: bool := !(i8B)
	<.main+6431 @05d453> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6436 @05d458> : 26                         load.i8
	<.main+6437 @05d459> : 5a                         i32.2bool
	<.main+6438 @05d45a> : 0b                         not.b32
	<.main+6439 @05d45b> : 1f a8 b2 05 00             load.ref <@05b2a8> ;i8Not
	<.main+6444 @05d460> : 2b                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@05d461> - <@05d474>): static i8Ceq: bool := i8A == i8B
	<.main+6445 @05d461> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6450 @05d466> : 26                         load.i8
	<.main+6451 @05d467> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6456 @05d46c> : 26                         load.i8
	<.main+6457 @05d46d> : 57                         ceq.i32
	<.main+6458 @05d46e> : 1f b0 b2 05 00             load.ref <@05b2b0> ;i8Ceq
	<.main+6463 @05d473> : 2b                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@05d474> - <@05d488>): static i8Cne: bool := i8A != i8B
	<.main+6464 @05d474> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6469 @05d479> : 26                         load.i8
	<.main+6470 @05d47a> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6475 @05d47f> : 26                         load.i8
	<.main+6476 @05d480> : 57                         ceq.i32
	<.main+6477 @05d481> : 0b                         not.b32
	<.main+6478 @05d482> : 1f b8 b2 05 00             load.ref <@05b2b8> ;i8Cne
	<.main+6483 @05d487> : 2b                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@05d488> - <@05d49b>): static i8Clt: bool := i8A < i8B
	<.main+6484 @05d488> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6489 @05d48d> : 26                         load.i8
	<.main+6490 @05d48e> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6495 @05d493> : 26                         load.i8
	<.main+6496 @05d494> : 58                         clt.i32
	<.main+6497 @05d495> : 1f c0 b2 05 00             load.ref <@05b2c0> ;i8Clt
	<.main+6502 @05d49a> : 2b                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@05d49b> - <@05d4af>): static i8Cle: bool := i8A <= i8B
	<.main+6503 @05d49b> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6508 @05d4a0> : 26                         load.i8
	<.main+6509 @05d4a1> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6514 @05d4a6> : 26                         load.i8
	<.main+6515 @05d4a7> : 59                         cgt.i32
	<.main+6516 @05d4a8> : 0b                         not.b32
	<.main+6517 @05d4a9> : 1f c8 b2 05 00             load.ref <@05b2c8> ;i8Cle
	<.main+6522 @05d4ae> : 2b                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@05d4af> - <@05d4c2>): static i8Cgt: bool := i8A > i8B
	<.main+6523 @05d4af> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6528 @05d4b4> : 26                         load.i8
	<.main+6529 @05d4b5> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6534 @05d4ba> : 26                         load.i8
	<.main+6535 @05d4bb> : 59                         cgt.i32
	<.main+6536 @05d4bc> : 1f d0 b2 05 00             load.ref <@05b2d0> ;i8Cgt
	<.main+6541 @05d4c1> : 2b                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@05d4c2> - <@05d4d6>): static i8Cge: bool := i8A >= i8B
	<.main+6542 @05d4c2> : 1f 30 b2 05 00             load.ref <@05b230> ;i8A
	<.main+6547 @05d4c7> : 26                         load.i8
	<.main+6548 @05d4c8> : 1f 38 b2 05 00             load.ref <@05b238> ;i8B
	<.main+6553 @05d4cd> : 26                         load.i8
	<.main+6554 @05d4ce> : 58                         clt.i32
	<.main+6555 @05d4cf> : 0b                         not.b32
	<.main+6556 @05d4d0> : 1f d8 b2 05 00             load.ref <@05b2d8> ;i8Cge
	<.main+6561 @05d4d5> : 2b                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@05d4d6> - <@05d4e1>): static u8A: uint8 := a
	<.main+6562 @05d4d6> : 1c 60 00 00 00             load.c32 96
	<.main+6567 @05d4db> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6572 @05d4e0> : 2b                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@05d4e1> - <@05d4ec>): static u8B: uint8 := b
	<.main+6573 @05d4e1> : 1c 2a 00 00 00             load.c32 42
	<.main+6578 @05d4e6> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6583 @05d4eb> : 2b                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@05d4ec> - <@05d4f8>): static u8Pls: uint8 := +u8B
	<.main+6584 @05d4ec> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6589 @05d4f1> : 26                         load.i8
	<.main+6590 @05d4f2> : 1f f0 b2 05 00             load.ref <@05b2f0> ;u8Pls
	<.main+6595 @05d4f7> : 2b                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@05d4f8> - <@05d505>): static u8Neg: uint8 := -u8B
	<.main+6596 @05d4f8> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6601 @05d4fd> : 26                         load.i8
	<.main+6602 @05d4fe> : 50                         neg.i32
	<.main+6603 @05d4ff> : 1f f8 b2 05 00             load.ref <@05b2f8> ;u8Neg
	<.main+6608 @05d504> : 2b                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@05d505> - <@05d512>): static u8Cmt: uint8 := ~u8B
	<.main+6609 @05d505> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6614 @05d50a> : 26                         load.i8
	<.main+6615 @05d50b> : 30                         cmt.b32
	<.main+6616 @05d50c> : 1f 00 b3 05 00             load.ref <@05b300> ;u8Cmt
	<.main+6621 @05d511> : 2b                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@05d512> - <@05d525>): static u8Add: uint8 := u8A + u8B
	<.main+6622 @05d512> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6627 @05d517> : 26                         load.i8
	<.main+6628 @05d518> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6633 @05d51d> : 26                         load.i8
	<.main+6634 @05d51e> : 51                         add.i32
	<.main+6635 @05d51f> : 1f 08 b3 05 00             load.ref <@05b308> ;u8Add
	<.main+6640 @05d524> : 2b                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@05d525> - <@05d538>): static u8Sub: uint8 := u8A - u8B
	<.main+6641 @05d525> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6646 @05d52a> : 26                         load.i8
	<.main+6647 @05d52b> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6652 @05d530> : 26                         load.i8
	<.main+6653 @05d531> : 52                         sub.i32
	<.main+6654 @05d532> : 1f 10 b3 05 00             load.ref <@05b310> ;u8Sub
	<.main+6659 @05d537> : 2b                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@05d538> - <@05d54b>): static u8Mul: uint8 := u8A * u8B
	<.main+6660 @05d538> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6665 @05d53d> : 26                         load.i8
	<.main+6666 @05d53e> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6671 @05d543> : 26                         load.i8
	<.main+6672 @05d544> : 33                         mul.u32
	<.main+6673 @05d545> : 1f 18 b3 05 00             load.ref <@05b318> ;u8Mul
	<.main+6678 @05d54a> : 2b                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@05d54b> - <@05d55e>): static u8Div: uint8 := u8A / u8B
	<.main+6679 @05d54b> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6684 @05d550> : 26                         load.i8
	<.main+6685 @05d551> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6690 @05d556> : 26                         load.i8
	<.main+6691 @05d557> : 34                         div.u32
	<.main+6692 @05d558> : 1f 20 b3 05 00             load.ref <@05b320> ;u8Div
	<.main+6697 @05d55d> : 2b                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@05d55e> - <@05d571>): static u8Mod: uint8 := u8A % u8B
	<.main+6698 @05d55e> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6703 @05d563> : 26                         load.i8
	<.main+6704 @05d564> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6709 @05d569> : 26                         load.i8
	<.main+6710 @05d56a> : 35                         mod.u32
	<.main+6711 @05d56b> : 1f 28 b3 05 00             load.ref <@05b328> ;u8Mod
	<.main+6716 @05d570> : 2b                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@05d571> - <@05d584>): static u8And: uint8 := u8A & u8B
	<.main+6717 @05d571> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6722 @05d576> : 26                         load.i8
	<.main+6723 @05d577> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6728 @05d57c> : 26                         load.i8
	<.main+6729 @05d57d> : 31                         and.b32
	<.main+6730 @05d57e> : 1f 30 b3 05 00             load.ref <@05b330> ;u8And
	<.main+6735 @05d583> : 2b                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@05d584> - <@05d597>): static u8Ior: uint8 := u8A | u8B
	<.main+6736 @05d584> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6741 @05d589> : 26                         load.i8
	<.main+6742 @05d58a> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6747 @05d58f> : 26                         load.i8
	<.main+6748 @05d590> : 32                         or.b32
	<.main+6749 @05d591> : 1f 38 b3 05 00             load.ref <@05b338> ;u8Ior
	<.main+6754 @05d596> : 2b                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@05d597> - <@05d5aa>): static u8Xor: uint8 := u8A ^ u8B
	<.main+6755 @05d597> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6760 @05d59c> : 26                         load.i8
	<.main+6761 @05d59d> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6766 @05d5a2> : 26                         load.i8
	<.main+6767 @05d5a3> : 36                         xor.b32
	<.main+6768 @05d5a4> : 1f 40 b3 05 00             load.ref <@05b340> ;u8Xor
	<.main+6773 @05d5a9> : 2b                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@05d5aa> - <@05d5bb>): static u8Shl: uint8 := (u8A) << shift
	<.main+6774 @05d5aa> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6779 @05d5af> : 26                         load.i8
	<.main+6780 @05d5b0> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6784 @05d5b4> : 3a                         shl.b32
	<.main+6785 @05d5b5> : 1f 48 b3 05 00             load.ref <@05b348> ;u8Shl
	<.main+6790 @05d5ba> : 2b                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@05d5bb> - <@05d5cc>): static u8Shr: uint8 := (u8A) >> shift
	<.main+6791 @05d5bb> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6796 @05d5c0> : 26                         load.i8
	<.main+6797 @05d5c1> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+6801 @05d5c5> : 3c                         sar.b32
	<.main+6802 @05d5c6> : 1f 50 b3 05 00             load.ref <@05b350> ;u8Shr
	<.main+6807 @05d5cb> : 2b                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@05d5cc> - <@05d5da>): static u8Not: bool := !(u8B)
	<.main+6808 @05d5cc> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6813 @05d5d1> : 26                         load.i8
	<.main+6814 @05d5d2> : 5a                         i32.2bool
	<.main+6815 @05d5d3> : 0b                         not.b32
	<.main+6816 @05d5d4> : 1f 58 b3 05 00             load.ref <@05b358> ;u8Not
	<.main+6821 @05d5d9> : 2b                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@05d5da> - <@05d5ed>): static u8Ceq: bool := u8A == u8B
	<.main+6822 @05d5da> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6827 @05d5df> : 26                         load.i8
	<.main+6828 @05d5e0> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6833 @05d5e5> : 26                         load.i8
	<.main+6834 @05d5e6> : 57                         ceq.i32
	<.main+6835 @05d5e7> : 1f 60 b3 05 00             load.ref <@05b360> ;u8Ceq
	<.main+6840 @05d5ec> : 2b                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@05d5ed> - <@05d601>): static u8Cne: bool := u8A != u8B
	<.main+6841 @05d5ed> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6846 @05d5f2> : 26                         load.i8
	<.main+6847 @05d5f3> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6852 @05d5f8> : 26                         load.i8
	<.main+6853 @05d5f9> : 57                         ceq.i32
	<.main+6854 @05d5fa> : 0b                         not.b32
	<.main+6855 @05d5fb> : 1f 68 b3 05 00             load.ref <@05b368> ;u8Cne
	<.main+6860 @05d600> : 2b                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@05d601> - <@05d614>): static u8Clt: bool := u8A < u8B
	<.main+6861 @05d601> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6866 @05d606> : 26                         load.i8
	<.main+6867 @05d607> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6872 @05d60c> : 26                         load.i8
	<.main+6873 @05d60d> : 38                         clt.u32
	<.main+6874 @05d60e> : 1f 70 b3 05 00             load.ref <@05b370> ;u8Clt
	<.main+6879 @05d613> : 2b                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@05d614> - <@05d628>): static u8Cle: bool := u8A <= u8B
	<.main+6880 @05d614> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6885 @05d619> : 26                         load.i8
	<.main+6886 @05d61a> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6891 @05d61f> : 26                         load.i8
	<.main+6892 @05d620> : 39                         cgt.u32
	<.main+6893 @05d621> : 0b                         not.b32
	<.main+6894 @05d622> : 1f 78 b3 05 00             load.ref <@05b378> ;u8Cle
	<.main+6899 @05d627> : 2b                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@05d628> - <@05d63b>): static u8Cgt: bool := u8A > u8B
	<.main+6900 @05d628> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6905 @05d62d> : 26                         load.i8
	<.main+6906 @05d62e> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6911 @05d633> : 26                         load.i8
	<.main+6912 @05d634> : 39                         cgt.u32
	<.main+6913 @05d635> : 1f 80 b3 05 00             load.ref <@05b380> ;u8Cgt
	<.main+6918 @05d63a> : 2b                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@05d63b> - <@05d64f>): static u8Cge: bool := u8A >= u8B
	<.main+6919 @05d63b> : 1f e0 b2 05 00             load.ref <@05b2e0> ;u8A
	<.main+6924 @05d640> : 26                         load.i8
	<.main+6925 @05d641> : 1f e8 b2 05 00             load.ref <@05b2e8> ;u8B
	<.main+6930 @05d646> : 26                         load.i8
	<.main+6931 @05d647> : 38                         clt.u32
	<.main+6932 @05d648> : 0b                         not.b32
	<.main+6933 @05d649> : 1f 88 b3 05 00             load.ref <@05b388> ;u8Cge
	<.main+6938 @05d64e> : 2b                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@05d64f> - <@05d65a>): static i16A: int16 := a
	<.main+6939 @05d64f> : 1c 60 00 00 00             load.c32 96
	<.main+6944 @05d654> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+6949 @05d659> : 2c                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@05d65a> - <@05d665>): static i16B: int16 := b
	<.main+6950 @05d65a> : 1c 2a 00 00 00             load.c32 42
	<.main+6955 @05d65f> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+6960 @05d664> : 2c                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@05d665> - <@05d671>): static i16Pls: int16 := +i16B
	<.main+6961 @05d665> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+6966 @05d66a> : 27                         load.i16
	<.main+6967 @05d66b> : 1f a0 b3 05 00             load.ref <@05b3a0> ;i16Pls
	<.main+6972 @05d670> : 2c                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@05d671> - <@05d67e>): static i16Neg: int16 := -i16B
	<.main+6973 @05d671> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+6978 @05d676> : 27                         load.i16
	<.main+6979 @05d677> : 50                         neg.i32
	<.main+6980 @05d678> : 1f a8 b3 05 00             load.ref <@05b3a8> ;i16Neg
	<.main+6985 @05d67d> : 2c                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@05d67e> - <@05d68b>): static i16Cmt: int16 := ~i16B
	<.main+6986 @05d67e> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+6991 @05d683> : 27                         load.i16
	<.main+6992 @05d684> : 30                         cmt.b32
	<.main+6993 @05d685> : 1f b0 b3 05 00             load.ref <@05b3b0> ;i16Cmt
	<.main+6998 @05d68a> : 2c                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@05d68b> - <@05d69e>): static i16Add: int16 := i16A + i16B
	<.main+6999 @05d68b> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7004 @05d690> : 27                         load.i16
	<.main+7005 @05d691> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7010 @05d696> : 27                         load.i16
	<.main+7011 @05d697> : 51                         add.i32
	<.main+7012 @05d698> : 1f b8 b3 05 00             load.ref <@05b3b8> ;i16Add
	<.main+7017 @05d69d> : 2c                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@05d69e> - <@05d6b1>): static i16Sub: int16 := i16A - i16B
	<.main+7018 @05d69e> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7023 @05d6a3> : 27                         load.i16
	<.main+7024 @05d6a4> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7029 @05d6a9> : 27                         load.i16
	<.main+7030 @05d6aa> : 52                         sub.i32
	<.main+7031 @05d6ab> : 1f c0 b3 05 00             load.ref <@05b3c0> ;i16Sub
	<.main+7036 @05d6b0> : 2c                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@05d6b1> - <@05d6c4>): static i16Mul: int16 := i16A * i16B
	<.main+7037 @05d6b1> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7042 @05d6b6> : 27                         load.i16
	<.main+7043 @05d6b7> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7048 @05d6bc> : 27                         load.i16
	<.main+7049 @05d6bd> : 53                         mul.i32
	<.main+7050 @05d6be> : 1f c8 b3 05 00             load.ref <@05b3c8> ;i16Mul
	<.main+7055 @05d6c3> : 2c                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@05d6c4> - <@05d6d7>): static i16Div: int16 := i16A / i16B
	<.main+7056 @05d6c4> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7061 @05d6c9> : 27                         load.i16
	<.main+7062 @05d6ca> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7067 @05d6cf> : 27                         load.i16
	<.main+7068 @05d6d0> : 54                         div.i32
	<.main+7069 @05d6d1> : 1f d0 b3 05 00             load.ref <@05b3d0> ;i16Div
	<.main+7074 @05d6d6> : 2c                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@05d6d7> - <@05d6ea>): static i16Mod: int16 := i16A % i16B
	<.main+7075 @05d6d7> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7080 @05d6dc> : 27                         load.i16
	<.main+7081 @05d6dd> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7086 @05d6e2> : 27                         load.i16
	<.main+7087 @05d6e3> : 55                         mod.i32
	<.main+7088 @05d6e4> : 1f d8 b3 05 00             load.ref <@05b3d8> ;i16Mod
	<.main+7093 @05d6e9> : 2c                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@05d6ea> - <@05d6fd>): static i16And: int16 := i16A & i16B
	<.main+7094 @05d6ea> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7099 @05d6ef> : 27                         load.i16
	<.main+7100 @05d6f0> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7105 @05d6f5> : 27                         load.i16
	<.main+7106 @05d6f6> : 31                         and.b32
	<.main+7107 @05d6f7> : 1f e0 b3 05 00             load.ref <@05b3e0> ;i16And
	<.main+7112 @05d6fc> : 2c                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@05d6fd> - <@05d710>): static i16Ior: int16 := i16A | i16B
	<.main+7113 @05d6fd> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7118 @05d702> : 27                         load.i16
	<.main+7119 @05d703> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7124 @05d708> : 27                         load.i16
	<.main+7125 @05d709> : 32                         or.b32
	<.main+7126 @05d70a> : 1f e8 b3 05 00             load.ref <@05b3e8> ;i16Ior
	<.main+7131 @05d70f> : 2c                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@05d710> - <@05d723>): static i16Xor: int16 := i16A ^ i16B
	<.main+7132 @05d710> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7137 @05d715> : 27                         load.i16
	<.main+7138 @05d716> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7143 @05d71b> : 27                         load.i16
	<.main+7144 @05d71c> : 36                         xor.b32
	<.main+7145 @05d71d> : 1f f0 b3 05 00             load.ref <@05b3f0> ;i16Xor
	<.main+7150 @05d722> : 2c                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@05d723> - <@05d734>): static i16Shl: int16 := (i16A) << shift
	<.main+7151 @05d723> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7156 @05d728> : 27                         load.i16
	<.main+7157 @05d729> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7161 @05d72d> : 3a                         shl.b32
	<.main+7162 @05d72e> : 1f f8 b3 05 00             load.ref <@05b3f8> ;i16Shl
	<.main+7167 @05d733> : 2c                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@05d734> - <@05d745>): static i16Shr: int16 := (i16A) >> shift
	<.main+7168 @05d734> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7173 @05d739> : 27                         load.i16
	<.main+7174 @05d73a> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7178 @05d73e> : 3c                         sar.b32
	<.main+7179 @05d73f> : 1f 00 b4 05 00             load.ref <@05b400> ;i16Shr
	<.main+7184 @05d744> : 2c                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@05d745> - <@05d753>): static i16Not: bool := !(i16B)
	<.main+7185 @05d745> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7190 @05d74a> : 27                         load.i16
	<.main+7191 @05d74b> : 5a                         i32.2bool
	<.main+7192 @05d74c> : 0b                         not.b32
	<.main+7193 @05d74d> : 1f 08 b4 05 00             load.ref <@05b408> ;i16Not
	<.main+7198 @05d752> : 2b                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@05d753> - <@05d766>): static i16Ceq: bool := i16A == i16B
	<.main+7199 @05d753> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7204 @05d758> : 27                         load.i16
	<.main+7205 @05d759> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7210 @05d75e> : 27                         load.i16
	<.main+7211 @05d75f> : 57                         ceq.i32
	<.main+7212 @05d760> : 1f 10 b4 05 00             load.ref <@05b410> ;i16Ceq
	<.main+7217 @05d765> : 2b                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@05d766> - <@05d77a>): static i16Cne: bool := i16A != i16B
	<.main+7218 @05d766> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7223 @05d76b> : 27                         load.i16
	<.main+7224 @05d76c> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7229 @05d771> : 27                         load.i16
	<.main+7230 @05d772> : 57                         ceq.i32
	<.main+7231 @05d773> : 0b                         not.b32
	<.main+7232 @05d774> : 1f 18 b4 05 00             load.ref <@05b418> ;i16Cne
	<.main+7237 @05d779> : 2b                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@05d77a> - <@05d78d>): static i16Clt: bool := i16A < i16B
	<.main+7238 @05d77a> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7243 @05d77f> : 27                         load.i16
	<.main+7244 @05d780> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7249 @05d785> : 27                         load.i16
	<.main+7250 @05d786> : 58                         clt.i32
	<.main+7251 @05d787> : 1f 20 b4 05 00             load.ref <@05b420> ;i16Clt
	<.main+7256 @05d78c> : 2b                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@05d78d> - <@05d7a1>): static i16Cle: bool := i16A <= i16B
	<.main+7257 @05d78d> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7262 @05d792> : 27                         load.i16
	<.main+7263 @05d793> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7268 @05d798> : 27                         load.i16
	<.main+7269 @05d799> : 59                         cgt.i32
	<.main+7270 @05d79a> : 0b                         not.b32
	<.main+7271 @05d79b> : 1f 28 b4 05 00             load.ref <@05b428> ;i16Cle
	<.main+7276 @05d7a0> : 2b                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@05d7a1> - <@05d7b4>): static i16Cgt: bool := i16A > i16B
	<.main+7277 @05d7a1> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7282 @05d7a6> : 27                         load.i16
	<.main+7283 @05d7a7> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7288 @05d7ac> : 27                         load.i16
	<.main+7289 @05d7ad> : 59                         cgt.i32
	<.main+7290 @05d7ae> : 1f 30 b4 05 00             load.ref <@05b430> ;i16Cgt
	<.main+7295 @05d7b3> : 2b                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@05d7b4> - <@05d7c8>): static i16Cge: bool := i16A >= i16B
	<.main+7296 @05d7b4> : 1f 90 b3 05 00             load.ref <@05b390> ;i16A
	<.main+7301 @05d7b9> : 27                         load.i16
	<.main+7302 @05d7ba> : 1f 98 b3 05 00             load.ref <@05b398> ;i16B
	<.main+7307 @05d7bf> : 27                         load.i16
	<.main+7308 @05d7c0> : 58                         clt.i32
	<.main+7309 @05d7c1> : 0b                         not.b32
	<.main+7310 @05d7c2> : 1f 38 b4 05 00             load.ref <@05b438> ;i16Cge
	<.main+7315 @05d7c7> : 2b                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@05d7c8> - <@05d7d3>): static u16A: uint16 := a
	<.main+7316 @05d7c8> : 1c 60 00 00 00             load.c32 96
	<.main+7321 @05d7cd> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7326 @05d7d2> : 2c                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@05d7d3> - <@05d7de>): static u16B: uint16 := b
	<.main+7327 @05d7d3> : 1c 2a 00 00 00             load.c32 42
	<.main+7332 @05d7d8> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7337 @05d7dd> : 2c                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@05d7de> - <@05d7ea>): static u16Pls: uint16 := +u16B
	<.main+7338 @05d7de> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7343 @05d7e3> : 27                         load.i16
	<.main+7344 @05d7e4> : 1f 50 b4 05 00             load.ref <@05b450> ;u16Pls
	<.main+7349 @05d7e9> : 2c                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@05d7ea> - <@05d7f7>): static u16Neg: uint16 := -u16B
	<.main+7350 @05d7ea> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7355 @05d7ef> : 27                         load.i16
	<.main+7356 @05d7f0> : 50                         neg.i32
	<.main+7357 @05d7f1> : 1f 58 b4 05 00             load.ref <@05b458> ;u16Neg
	<.main+7362 @05d7f6> : 2c                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@05d7f7> - <@05d804>): static u16Cmt: uint16 := ~u16B
	<.main+7363 @05d7f7> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7368 @05d7fc> : 27                         load.i16
	<.main+7369 @05d7fd> : 30                         cmt.b32
	<.main+7370 @05d7fe> : 1f 60 b4 05 00             load.ref <@05b460> ;u16Cmt
	<.main+7375 @05d803> : 2c                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@05d804> - <@05d817>): static u16Add: uint16 := u16A + u16B
	<.main+7376 @05d804> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7381 @05d809> : 27                         load.i16
	<.main+7382 @05d80a> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7387 @05d80f> : 27                         load.i16
	<.main+7388 @05d810> : 51                         add.i32
	<.main+7389 @05d811> : 1f 68 b4 05 00             load.ref <@05b468> ;u16Add
	<.main+7394 @05d816> : 2c                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@05d817> - <@05d82a>): static u16Sub: uint16 := u16A - u16B
	<.main+7395 @05d817> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7400 @05d81c> : 27                         load.i16
	<.main+7401 @05d81d> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7406 @05d822> : 27                         load.i16
	<.main+7407 @05d823> : 52                         sub.i32
	<.main+7408 @05d824> : 1f 70 b4 05 00             load.ref <@05b470> ;u16Sub
	<.main+7413 @05d829> : 2c                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@05d82a> - <@05d83d>): static u16Mul: uint16 := u16A * u16B
	<.main+7414 @05d82a> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7419 @05d82f> : 27                         load.i16
	<.main+7420 @05d830> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7425 @05d835> : 27                         load.i16
	<.main+7426 @05d836> : 33                         mul.u32
	<.main+7427 @05d837> : 1f 78 b4 05 00             load.ref <@05b478> ;u16Mul
	<.main+7432 @05d83c> : 2c                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@05d83d> - <@05d850>): static u16Div: uint16 := u16A / u16B
	<.main+7433 @05d83d> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7438 @05d842> : 27                         load.i16
	<.main+7439 @05d843> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7444 @05d848> : 27                         load.i16
	<.main+7445 @05d849> : 34                         div.u32
	<.main+7446 @05d84a> : 1f 80 b4 05 00             load.ref <@05b480> ;u16Div
	<.main+7451 @05d84f> : 2c                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@05d850> - <@05d863>): static u16Mod: uint16 := u16A % u16B
	<.main+7452 @05d850> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7457 @05d855> : 27                         load.i16
	<.main+7458 @05d856> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7463 @05d85b> : 27                         load.i16
	<.main+7464 @05d85c> : 35                         mod.u32
	<.main+7465 @05d85d> : 1f 88 b4 05 00             load.ref <@05b488> ;u16Mod
	<.main+7470 @05d862> : 2c                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@05d863> - <@05d876>): static u16And: uint16 := u16A & u16B
	<.main+7471 @05d863> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7476 @05d868> : 27                         load.i16
	<.main+7477 @05d869> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7482 @05d86e> : 27                         load.i16
	<.main+7483 @05d86f> : 31                         and.b32
	<.main+7484 @05d870> : 1f 90 b4 05 00             load.ref <@05b490> ;u16And
	<.main+7489 @05d875> : 2c                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@05d876> - <@05d889>): static u16Ior: uint16 := u16A | u16B
	<.main+7490 @05d876> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7495 @05d87b> : 27                         load.i16
	<.main+7496 @05d87c> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7501 @05d881> : 27                         load.i16
	<.main+7502 @05d882> : 32                         or.b32
	<.main+7503 @05d883> : 1f 98 b4 05 00             load.ref <@05b498> ;u16Ior
	<.main+7508 @05d888> : 2c                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@05d889> - <@05d89c>): static u16Xor: uint16 := u16A ^ u16B
	<.main+7509 @05d889> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7514 @05d88e> : 27                         load.i16
	<.main+7515 @05d88f> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7520 @05d894> : 27                         load.i16
	<.main+7521 @05d895> : 36                         xor.b32
	<.main+7522 @05d896> : 1f a0 b4 05 00             load.ref <@05b4a0> ;u16Xor
	<.main+7527 @05d89b> : 2c                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@05d89c> - <@05d8ad>): static u16Shl: uint16 := (u16A) << shift
	<.main+7528 @05d89c> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7533 @05d8a1> : 27                         load.i16
	<.main+7534 @05d8a2> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7538 @05d8a6> : 3a                         shl.b32
	<.main+7539 @05d8a7> : 1f a8 b4 05 00             load.ref <@05b4a8> ;u16Shl
	<.main+7544 @05d8ac> : 2c                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@05d8ad> - <@05d8be>): static u16Shr: uint16 := (u16A) >> shift
	<.main+7545 @05d8ad> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7550 @05d8b2> : 27                         load.i16
	<.main+7551 @05d8b3> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7555 @05d8b7> : 3c                         sar.b32
	<.main+7556 @05d8b8> : 1f b0 b4 05 00             load.ref <@05b4b0> ;u16Shr
	<.main+7561 @05d8bd> : 2c                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@05d8be> - <@05d8cc>): static u16Not: bool := !(u16B)
	<.main+7562 @05d8be> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7567 @05d8c3> : 27                         load.i16
	<.main+7568 @05d8c4> : 5a                         i32.2bool
	<.main+7569 @05d8c5> : 0b                         not.b32
	<.main+7570 @05d8c6> : 1f b8 b4 05 00             load.ref <@05b4b8> ;u16Not
	<.main+7575 @05d8cb> : 2b                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@05d8cc> - <@05d8df>): static u16Ceq: bool := u16A == u16B
	<.main+7576 @05d8cc> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7581 @05d8d1> : 27                         load.i16
	<.main+7582 @05d8d2> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7587 @05d8d7> : 27                         load.i16
	<.main+7588 @05d8d8> : 57                         ceq.i32
	<.main+7589 @05d8d9> : 1f c0 b4 05 00             load.ref <@05b4c0> ;u16Ceq
	<.main+7594 @05d8de> : 2b                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@05d8df> - <@05d8f3>): static u16Cne: bool := u16A != u16B
	<.main+7595 @05d8df> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7600 @05d8e4> : 27                         load.i16
	<.main+7601 @05d8e5> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7606 @05d8ea> : 27                         load.i16
	<.main+7607 @05d8eb> : 57                         ceq.i32
	<.main+7608 @05d8ec> : 0b                         not.b32
	<.main+7609 @05d8ed> : 1f c8 b4 05 00             load.ref <@05b4c8> ;u16Cne
	<.main+7614 @05d8f2> : 2b                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@05d8f3> - <@05d906>): static u16Clt: bool := u16A < u16B
	<.main+7615 @05d8f3> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7620 @05d8f8> : 27                         load.i16
	<.main+7621 @05d8f9> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7626 @05d8fe> : 27                         load.i16
	<.main+7627 @05d8ff> : 38                         clt.u32
	<.main+7628 @05d900> : 1f d0 b4 05 00             load.ref <@05b4d0> ;u16Clt
	<.main+7633 @05d905> : 2b                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@05d906> - <@05d91a>): static u16Cle: bool := u16A <= u16B
	<.main+7634 @05d906> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7639 @05d90b> : 27                         load.i16
	<.main+7640 @05d90c> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7645 @05d911> : 27                         load.i16
	<.main+7646 @05d912> : 39                         cgt.u32
	<.main+7647 @05d913> : 0b                         not.b32
	<.main+7648 @05d914> : 1f d8 b4 05 00             load.ref <@05b4d8> ;u16Cle
	<.main+7653 @05d919> : 2b                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@05d91a> - <@05d92d>): static u16Cgt: bool := u16A > u16B
	<.main+7654 @05d91a> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7659 @05d91f> : 27                         load.i16
	<.main+7660 @05d920> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7665 @05d925> : 27                         load.i16
	<.main+7666 @05d926> : 39                         cgt.u32
	<.main+7667 @05d927> : 1f e0 b4 05 00             load.ref <@05b4e0> ;u16Cgt
	<.main+7672 @05d92c> : 2b                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@05d92d> - <@05d941>): static u16Cge: bool := u16A >= u16B
	<.main+7673 @05d92d> : 1f 40 b4 05 00             load.ref <@05b440> ;u16A
	<.main+7678 @05d932> : 27                         load.i16
	<.main+7679 @05d933> : 1f 48 b4 05 00             load.ref <@05b448> ;u16B
	<.main+7684 @05d938> : 27                         load.i16
	<.main+7685 @05d939> : 38                         clt.u32
	<.main+7686 @05d93a> : 0b                         not.b32
	<.main+7687 @05d93b> : 1f e8 b4 05 00             load.ref <@05b4e8> ;u16Cge
	<.main+7692 @05d940> : 2b                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@05d941> - <@05d94a>): static i32A: int32 := a
	<.main+7693 @05d941> : 1c 60 00 00 00             load.c32 96
	<.main+7698 @05d946> : 24 f0 b4 05                store.m32 <@05b4f0> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@05d94a> - <@05d953>): static i32B: int32 := b
	<.main+7702 @05d94a> : 1c 2a 00 00 00             load.c32 42
	<.main+7707 @05d94f> : 24 f8 b4 05                store.m32 <@05b4f8> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@05d953> - <@05d95b>): static i32Pls: int32 := +i32B
	<.main+7711 @05d953> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7715 @05d957> : 24 00 b5 05                store.m32 <@05b500> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@05d95b> - <@05d964>): static i32Neg: int32 := -i32B
	<.main+7719 @05d95b> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7723 @05d95f> : 50                         neg.i32
	<.main+7724 @05d960> : 24 08 b5 05                store.m32 <@05b508> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@05d964> - <@05d96d>): static i32Cmt: int32 := ~i32B
	<.main+7728 @05d964> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7732 @05d968> : 30                         cmt.b32
	<.main+7733 @05d969> : 24 10 b5 05                store.m32 <@05b510> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@05d96d> - <@05d97a>): static i32Add: int32 := i32A + i32B
	<.main+7737 @05d96d> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7741 @05d971> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7745 @05d975> : 51                         add.i32
	<.main+7746 @05d976> : 24 18 b5 05                store.m32 <@05b518> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@05d97a> - <@05d987>): static i32Sub: int32 := i32A - i32B
	<.main+7750 @05d97a> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7754 @05d97e> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7758 @05d982> : 52                         sub.i32
	<.main+7759 @05d983> : 24 20 b5 05                store.m32 <@05b520> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@05d987> - <@05d994>): static i32Mul: int32 := i32A * i32B
	<.main+7763 @05d987> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7767 @05d98b> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7771 @05d98f> : 53                         mul.i32
	<.main+7772 @05d990> : 24 28 b5 05                store.m32 <@05b528> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@05d994> - <@05d9a1>): static i32Div: int32 := i32A / i32B
	<.main+7776 @05d994> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7780 @05d998> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7784 @05d99c> : 54                         div.i32
	<.main+7785 @05d99d> : 24 30 b5 05                store.m32 <@05b530> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@05d9a1> - <@05d9ae>): static i32Mod: int32 := i32A % i32B
	<.main+7789 @05d9a1> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7793 @05d9a5> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7797 @05d9a9> : 55                         mod.i32
	<.main+7798 @05d9aa> : 24 38 b5 05                store.m32 <@05b538> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@05d9ae> - <@05d9bb>): static i32And: int32 := i32A & i32B
	<.main+7802 @05d9ae> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7806 @05d9b2> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7810 @05d9b6> : 31                         and.b32
	<.main+7811 @05d9b7> : 24 40 b5 05                store.m32 <@05b540> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@05d9bb> - <@05d9c8>): static i32Ior: int32 := i32A | i32B
	<.main+7815 @05d9bb> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7819 @05d9bf> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7823 @05d9c3> : 32                         or.b32
	<.main+7824 @05d9c4> : 24 48 b5 05                store.m32 <@05b548> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@05d9c8> - <@05d9d5>): static i32Xor: int32 := i32A ^ i32B
	<.main+7828 @05d9c8> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7832 @05d9cc> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7836 @05d9d0> : 36                         xor.b32
	<.main+7837 @05d9d1> : 24 50 b5 05                store.m32 <@05b550> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@05d9d5> - <@05d9e2>): static i32Shl: int32 := i32A << shift
	<.main+7841 @05d9d5> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7845 @05d9d9> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7849 @05d9dd> : 3a                         shl.b32
	<.main+7850 @05d9de> : 24 58 b5 05                store.m32 <@05b558> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@05d9e2> - <@05d9ef>): static i32Shr: int32 := i32A >> shift
	<.main+7854 @05d9e2> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7858 @05d9e6> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+7862 @05d9ea> : 3c                         sar.b32
	<.main+7863 @05d9eb> : 24 60 b5 05                store.m32 <@05b560> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@05d9ef> - <@05d9fb>): static i32Not: bool := !(i32B)
	<.main+7867 @05d9ef> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7871 @05d9f3> : 5a                         i32.2bool
	<.main+7872 @05d9f4> : 0b                         not.b32
	<.main+7873 @05d9f5> : 1f 68 b5 05 00             load.ref <@05b568> ;i32Not
	<.main+7878 @05d9fa> : 2b                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@05d9fb> - <@05da0a>): static i32Ceq: bool := i32A == i32B
	<.main+7879 @05d9fb> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7883 @05d9ff> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7887 @05da03> : 57                         ceq.i32
	<.main+7888 @05da04> : 1f 70 b5 05 00             load.ref <@05b570> ;i32Ceq
	<.main+7893 @05da09> : 2b                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@05da0a> - <@05da1a>): static i32Cne: bool := i32A != i32B
	<.main+7894 @05da0a> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7898 @05da0e> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7902 @05da12> : 57                         ceq.i32
	<.main+7903 @05da13> : 0b                         not.b32
	<.main+7904 @05da14> : 1f 78 b5 05 00             load.ref <@05b578> ;i32Cne
	<.main+7909 @05da19> : 2b                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@05da1a> - <@05da29>): static i32Clt: bool := i32A < i32B
	<.main+7910 @05da1a> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7914 @05da1e> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7918 @05da22> : 58                         clt.i32
	<.main+7919 @05da23> : 1f 80 b5 05 00             load.ref <@05b580> ;i32Clt
	<.main+7924 @05da28> : 2b                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@05da29> - <@05da39>): static i32Cle: bool := i32A <= i32B
	<.main+7925 @05da29> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7929 @05da2d> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7933 @05da31> : 59                         cgt.i32
	<.main+7934 @05da32> : 0b                         not.b32
	<.main+7935 @05da33> : 1f 88 b5 05 00             load.ref <@05b588> ;i32Cle
	<.main+7940 @05da38> : 2b                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@05da39> - <@05da48>): static i32Cgt: bool := i32A > i32B
	<.main+7941 @05da39> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7945 @05da3d> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7949 @05da41> : 59                         cgt.i32
	<.main+7950 @05da42> : 1f 90 b5 05 00             load.ref <@05b590> ;i32Cgt
	<.main+7955 @05da47> : 2b                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@05da48> - <@05da58>): static i32Cge: bool := i32A >= i32B
	<.main+7956 @05da48> : 20 f0 b4 05                load.m32 <@05b4f0> ;i32A
	<.main+7960 @05da4c> : 20 f8 b4 05                load.m32 <@05b4f8> ;i32B
	<.main+7964 @05da50> : 58                         clt.i32
	<.main+7965 @05da51> : 0b                         not.b32
	<.main+7966 @05da52> : 1f 98 b5 05 00             load.ref <@05b598> ;i32Cge
	<.main+7971 @05da57> : 2b                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@05da58> - <@05da61>): static u32A: uint32 := a
	<.main+7972 @05da58> : 1c 60 00 00 00             load.c32 96
	<.main+7977 @05da5d> : 24 a0 b5 05                store.m32 <@05b5a0> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@05da61> - <@05da6a>): static u32B: uint32 := b
	<.main+7981 @05da61> : 1c 2a 00 00 00             load.c32 42
	<.main+7986 @05da66> : 24 a8 b5 05                store.m32 <@05b5a8> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@05da6a> - <@05da72>): static u32Pls: uint32 := +u32B
	<.main+7990 @05da6a> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+7994 @05da6e> : 24 b0 b5 05                store.m32 <@05b5b0> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@05da72> - <@05da7b>): static u32Neg: uint32 := -u32B
	<.main+7998 @05da72> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8002 @05da76> : 50                         neg.i32
	<.main+8003 @05da77> : 24 b8 b5 05                store.m32 <@05b5b8> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@05da7b> - <@05da84>): static u32Cmt: uint32 := ~u32B
	<.main+8007 @05da7b> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8011 @05da7f> : 30                         cmt.b32
	<.main+8012 @05da80> : 24 c0 b5 05                store.m32 <@05b5c0> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@05da84> - <@05da91>): static u32Add: uint32 := u32A + u32B
	<.main+8016 @05da84> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8020 @05da88> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8024 @05da8c> : 51                         add.i32
	<.main+8025 @05da8d> : 24 c8 b5 05                store.m32 <@05b5c8> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@05da91> - <@05da9e>): static u32Sub: uint32 := u32A - u32B
	<.main+8029 @05da91> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8033 @05da95> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8037 @05da99> : 52                         sub.i32
	<.main+8038 @05da9a> : 24 d0 b5 05                store.m32 <@05b5d0> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@05da9e> - <@05daab>): static u32Mul: uint32 := u32A * u32B
	<.main+8042 @05da9e> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8046 @05daa2> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8050 @05daa6> : 33                         mul.u32
	<.main+8051 @05daa7> : 24 d8 b5 05                store.m32 <@05b5d8> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@05daab> - <@05dab8>): static u32Div: uint32 := u32A / u32B
	<.main+8055 @05daab> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8059 @05daaf> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8063 @05dab3> : 34                         div.u32
	<.main+8064 @05dab4> : 24 e0 b5 05                store.m32 <@05b5e0> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@05dab8> - <@05dac5>): static u32Mod: uint32 := u32A % u32B
	<.main+8068 @05dab8> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8072 @05dabc> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8076 @05dac0> : 35                         mod.u32
	<.main+8077 @05dac1> : 24 e8 b5 05                store.m32 <@05b5e8> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@05dac5> - <@05dad2>): static u32And: uint32 := u32A & u32B
	<.main+8081 @05dac5> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8085 @05dac9> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8089 @05dacd> : 31                         and.b32
	<.main+8090 @05dace> : 24 f0 b5 05                store.m32 <@05b5f0> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@05dad2> - <@05dadf>): static u32Ior: uint32 := u32A | u32B
	<.main+8094 @05dad2> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8098 @05dad6> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8102 @05dada> : 32                         or.b32
	<.main+8103 @05dadb> : 24 f8 b5 05                store.m32 <@05b5f8> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@05dadf> - <@05daec>): static u32Xor: uint32 := u32A ^ u32B
	<.main+8107 @05dadf> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8111 @05dae3> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8115 @05dae7> : 36                         xor.b32
	<.main+8116 @05dae8> : 24 00 b6 05                store.m32 <@05b600> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@05daec> - <@05daf9>): static u32Shl: uint32 := u32A << shift
	<.main+8120 @05daec> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8124 @05daf0> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8128 @05daf4> : 3a                         shl.b32
	<.main+8129 @05daf5> : 24 08 b6 05                store.m32 <@05b608> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@05daf9> - <@05db06>): static u32Shr: uint32 := u32A >> shift
	<.main+8133 @05daf9> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8137 @05dafd> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8141 @05db01> : 3b                         shr.b32
	<.main+8142 @05db02> : 24 10 b6 05                store.m32 <@05b610> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@05db06> - <@05db12>): static u32Not: bool := !(u32B)
	<.main+8146 @05db06> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8150 @05db0a> : 5a                         i32.2bool
	<.main+8151 @05db0b> : 0b                         not.b32
	<.main+8152 @05db0c> : 1f 18 b6 05 00             load.ref <@05b618> ;u32Not
	<.main+8157 @05db11> : 2b                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@05db12> - <@05db21>): static u32Ceq: bool := u32A == u32B
	<.main+8158 @05db12> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8162 @05db16> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8166 @05db1a> : 57                         ceq.i32
	<.main+8167 @05db1b> : 1f 20 b6 05 00             load.ref <@05b620> ;u32Ceq
	<.main+8172 @05db20> : 2b                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@05db21> - <@05db31>): static u32Cne: bool := u32A != u32B
	<.main+8173 @05db21> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8177 @05db25> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8181 @05db29> : 57                         ceq.i32
	<.main+8182 @05db2a> : 0b                         not.b32
	<.main+8183 @05db2b> : 1f 28 b6 05 00             load.ref <@05b628> ;u32Cne
	<.main+8188 @05db30> : 2b                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@05db31> - <@05db40>): static u32Clt: bool := u32A < u32B
	<.main+8189 @05db31> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8193 @05db35> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8197 @05db39> : 38                         clt.u32
	<.main+8198 @05db3a> : 1f 30 b6 05 00             load.ref <@05b630> ;u32Clt
	<.main+8203 @05db3f> : 2b                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@05db40> - <@05db50>): static u32Cle: bool := u32A <= u32B
	<.main+8204 @05db40> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8208 @05db44> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8212 @05db48> : 39                         cgt.u32
	<.main+8213 @05db49> : 0b                         not.b32
	<.main+8214 @05db4a> : 1f 38 b6 05 00             load.ref <@05b638> ;u32Cle
	<.main+8219 @05db4f> : 2b                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@05db50> - <@05db5f>): static u32Cgt: bool := u32A > u32B
	<.main+8220 @05db50> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8224 @05db54> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8228 @05db58> : 39                         cgt.u32
	<.main+8229 @05db59> : 1f 40 b6 05 00             load.ref <@05b640> ;u32Cgt
	<.main+8234 @05db5e> : 2b                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@05db5f> - <@05db6f>): static u32Cge: bool := u32A >= u32B
	<.main+8235 @05db5f> : 20 a0 b5 05                load.m32 <@05b5a0> ;u32A
	<.main+8239 @05db63> : 20 a8 b5 05                load.m32 <@05b5a8> ;u32B
	<.main+8243 @05db67> : 38                         clt.u32
	<.main+8244 @05db68> : 0b                         not.b32
	<.main+8245 @05db69> : 1f 48 b6 05 00             load.ref <@05b648> ;u32Cge
	<.main+8250 @05db6e> : 2b                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@05db6f> - <@05db7c>): static i64A: int64 := a
	<.main+8251 @05db6f> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8260 @05db78> : 23 50 b6 05                store.m64 <@05b650> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@05db7c> - <@05db89>): static i64B: int64 := b
	<.main+8264 @05db7c> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8273 @05db85> : 23 58 b6 05                store.m64 <@05b658> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@05db89> - <@05db91>): static i64Pls: int64 := +i64B
	<.main+8277 @05db89> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8281 @05db8d> : 23 60 b6 05                store.m64 <@05b660> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@05db91> - <@05db9a>): static i64Neg: int64 := -i64B
	<.main+8285 @05db91> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8289 @05db95> : 60                         neg.i64
	<.main+8290 @05db96> : 23 68 b6 05                store.m64 <@05b668> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@05db9a> - <@05dba3>): static i64Cmt: int64 := ~i64B
	<.main+8294 @05db9a> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8298 @05db9e> : 40                         cmt.b64
	<.main+8299 @05db9f> : 23 70 b6 05                store.m64 <@05b670> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@05dba3> - <@05dbb0>): static i64Add: int64 := i64A + i64B
	<.main+8303 @05dba3> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8307 @05dba7> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8311 @05dbab> : 61                         add.i64
	<.main+8312 @05dbac> : 23 78 b6 05                store.m64 <@05b678> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@05dbb0> - <@05dbbd>): static i64Sub: int64 := i64A - i64B
	<.main+8316 @05dbb0> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8320 @05dbb4> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8324 @05dbb8> : 62                         sub.i64
	<.main+8325 @05dbb9> : 23 80 b6 05                store.m64 <@05b680> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@05dbbd> - <@05dbca>): static i64Mul: int64 := i64A * i64B
	<.main+8329 @05dbbd> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8333 @05dbc1> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8337 @05dbc5> : 63                         mul.i64
	<.main+8338 @05dbc6> : 23 88 b6 05                store.m64 <@05b688> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@05dbca> - <@05dbd7>): static i64Div: int64 := i64A / i64B
	<.main+8342 @05dbca> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8346 @05dbce> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8350 @05dbd2> : 64                         div.i64
	<.main+8351 @05dbd3> : 23 90 b6 05                store.m64 <@05b690> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@05dbd7> - <@05dbe4>): static i64Mod: int64 := i64A % i64B
	<.main+8355 @05dbd7> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8359 @05dbdb> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8363 @05dbdf> : 65                         mod.i64
	<.main+8364 @05dbe0> : 23 98 b6 05                store.m64 <@05b698> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@05dbe4> - <@05dbf1>): static i64And: int64 := i64A & i64B
	<.main+8368 @05dbe4> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8372 @05dbe8> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8376 @05dbec> : 41                         and.b64
	<.main+8377 @05dbed> : 23 a0 b6 05                store.m64 <@05b6a0> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@05dbf1> - <@05dbfe>): static i64Ior: int64 := i64A | i64B
	<.main+8381 @05dbf1> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8385 @05dbf5> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8389 @05dbf9> : 42                         or.b64
	<.main+8390 @05dbfa> : 23 a8 b6 05                store.m64 <@05b6a8> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@05dbfe> - <@05dc0b>): static i64Xor: int64 := i64A ^ i64B
	<.main+8394 @05dbfe> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8398 @05dc02> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8402 @05dc06> : 46                         xor.b64
	<.main+8403 @05dc07> : 23 b0 b6 05                store.m64 <@05b6b0> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@05dc0b> - <@05dc18>): static i64Shl: int64 := i64A << shift
	<.main+8407 @05dc0b> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8411 @05dc0f> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8415 @05dc13> : 4a                         shl.b64
	<.main+8416 @05dc14> : 23 b8 b6 05                store.m64 <@05b6b8> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@05dc18> - <@05dc25>): static i64Shr: int64 := i64A >> shift
	<.main+8420 @05dc18> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8424 @05dc1c> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8428 @05dc20> : 4c                         sar.b64
	<.main+8429 @05dc21> : 23 c0 b6 05                store.m64 <@05b6c0> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@05dc25> - <@05dc31>): static i64Not: bool := !(i64B)
	<.main+8433 @05dc25> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8437 @05dc29> : 6b                         i64.2bool
	<.main+8438 @05dc2a> : 0b                         not.b32
	<.main+8439 @05dc2b> : 1f c8 b6 05 00             load.ref <@05b6c8> ;i64Not
	<.main+8444 @05dc30> : 2b                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@05dc31> - <@05dc40>): static i64Ceq: bool := i64A == i64B
	<.main+8445 @05dc31> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8449 @05dc35> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8453 @05dc39> : 67                         ceq.i64
	<.main+8454 @05dc3a> : 1f d0 b6 05 00             load.ref <@05b6d0> ;i64Ceq
	<.main+8459 @05dc3f> : 2b                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@05dc40> - <@05dc50>): static i64Cne: bool := i64A != i64B
	<.main+8460 @05dc40> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8464 @05dc44> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8468 @05dc48> : 67                         ceq.i64
	<.main+8469 @05dc49> : 0b                         not.b32
	<.main+8470 @05dc4a> : 1f d8 b6 05 00             load.ref <@05b6d8> ;i64Cne
	<.main+8475 @05dc4f> : 2b                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@05dc50> - <@05dc5f>): static i64Clt: bool := i64A < i64B
	<.main+8476 @05dc50> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8480 @05dc54> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8484 @05dc58> : 68                         clt.i64
	<.main+8485 @05dc59> : 1f e0 b6 05 00             load.ref <@05b6e0> ;i64Clt
	<.main+8490 @05dc5e> : 2b                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@05dc5f> - <@05dc6f>): static i64Cle: bool := i64A <= i64B
	<.main+8491 @05dc5f> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8495 @05dc63> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8499 @05dc67> : 69                         cgt.i64
	<.main+8500 @05dc68> : 0b                         not.b32
	<.main+8501 @05dc69> : 1f e8 b6 05 00             load.ref <@05b6e8> ;i64Cle
	<.main+8506 @05dc6e> : 2b                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@05dc6f> - <@05dc7e>): static i64Cgt: bool := i64A > i64B
	<.main+8507 @05dc6f> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8511 @05dc73> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8515 @05dc77> : 69                         cgt.i64
	<.main+8516 @05dc78> : 1f f0 b6 05 00             load.ref <@05b6f0> ;i64Cgt
	<.main+8521 @05dc7d> : 2b                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@05dc7e> - <@05dc8e>): static i64Cge: bool := i64A >= i64B
	<.main+8522 @05dc7e> : 21 50 b6 05                load.m64 <@05b650> ;i64A
	<.main+8526 @05dc82> : 21 58 b6 05                load.m64 <@05b658> ;i64B
	<.main+8530 @05dc86> : 68                         clt.i64
	<.main+8531 @05dc87> : 0b                         not.b32
	<.main+8532 @05dc88> : 1f f8 b6 05 00             load.ref <@05b6f8> ;i64Cge
	<.main+8537 @05dc8d> : 2b                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@05dc8e> - <@05dc9b>): static u64A: uint64 := a
	<.main+8538 @05dc8e> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8547 @05dc97> : 23 00 b7 05                store.m64 <@05b700> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@05dc9b> - <@05dca8>): static u64B: uint64 := b
	<.main+8551 @05dc9b> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8560 @05dca4> : 23 08 b7 05                store.m64 <@05b708> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@05dca8> - <@05dcb0>): static u64Pls: uint64 := +u64B
	<.main+8564 @05dca8> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8568 @05dcac> : 23 10 b7 05                store.m64 <@05b710> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@05dcb0> - <@05dcb9>): static u64Neg: uint64 := -u64B
	<.main+8572 @05dcb0> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8576 @05dcb4> : 60                         neg.i64
	<.main+8577 @05dcb5> : 23 18 b7 05                store.m64 <@05b718> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@05dcb9> - <@05dcc2>): static u64Cmt: uint64 := ~u64B
	<.main+8581 @05dcb9> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8585 @05dcbd> : 40                         cmt.b64
	<.main+8586 @05dcbe> : 23 20 b7 05                store.m64 <@05b720> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@05dcc2> - <@05dccf>): static u64Add: uint64 := u64A + u64B
	<.main+8590 @05dcc2> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8594 @05dcc6> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8598 @05dcca> : 61                         add.i64
	<.main+8599 @05dccb> : 23 28 b7 05                store.m64 <@05b728> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@05dccf> - <@05dcdc>): static u64Sub: uint64 := u64A - u64B
	<.main+8603 @05dccf> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8607 @05dcd3> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8611 @05dcd7> : 62                         sub.i64
	<.main+8612 @05dcd8> : 23 30 b7 05                store.m64 <@05b730> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@05dcdc> - <@05dce9>): static u64Mul: uint64 := u64A * u64B
	<.main+8616 @05dcdc> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8620 @05dce0> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8624 @05dce4> : 43                         mul.u64
	<.main+8625 @05dce5> : 23 38 b7 05                store.m64 <@05b738> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@05dce9> - <@05dcf6>): static u64Div: uint64 := u64A / u64B
	<.main+8629 @05dce9> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8633 @05dced> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8637 @05dcf1> : 44                         div.u64
	<.main+8638 @05dcf2> : 23 40 b7 05                store.m64 <@05b740> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@05dcf6> - <@05dd03>): static u64Mod: uint64 := u64A % u64B
	<.main+8642 @05dcf6> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8646 @05dcfa> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8650 @05dcfe> : 45                         mod.u64
	<.main+8651 @05dcff> : 23 48 b7 05                store.m64 <@05b748> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@05dd03> - <@05dd10>): static u64And: uint64 := u64A & u64B
	<.main+8655 @05dd03> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8659 @05dd07> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8663 @05dd0b> : 41                         and.b64
	<.main+8664 @05dd0c> : 23 50 b7 05                store.m64 <@05b750> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@05dd10> - <@05dd1d>): static u64Ior: uint64 := u64A | u64B
	<.main+8668 @05dd10> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8672 @05dd14> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8676 @05dd18> : 42                         or.b64
	<.main+8677 @05dd19> : 23 58 b7 05                store.m64 <@05b758> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@05dd1d> - <@05dd2a>): static u64Xor: uint64 := u64A ^ u64B
	<.main+8681 @05dd1d> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8685 @05dd21> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8689 @05dd25> : 46                         xor.b64
	<.main+8690 @05dd26> : 23 60 b7 05                store.m64 <@05b760> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@05dd2a> - <@05dd37>): static u64Shl: uint64 := u64A << shift
	<.main+8694 @05dd2a> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8698 @05dd2e> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8702 @05dd32> : 4a                         shl.b64
	<.main+8703 @05dd33> : 23 68 b7 05                store.m64 <@05b768> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@05dd37> - <@05dd44>): static u64Shr: uint64 := u64A >> shift
	<.main+8707 @05dd37> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8711 @05dd3b> : 20 18 b1 05                load.m32 <@05b118> ;shift
	<.main+8715 @05dd3f> : 4b                         shr.b64
	<.main+8716 @05dd40> : 23 70 b7 05                store.m64 <@05b770> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@05dd44> - <@05dd50>): static u64Not: bool := !(u64B)
	<.main+8720 @05dd44> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8724 @05dd48> : 6b                         i64.2bool
	<.main+8725 @05dd49> : 0b                         not.b32
	<.main+8726 @05dd4a> : 1f 78 b7 05 00             load.ref <@05b778> ;u64Not
	<.main+8731 @05dd4f> : 2b                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@05dd50> - <@05dd5f>): static u64Ceq: bool := u64A == u64B
	<.main+8732 @05dd50> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8736 @05dd54> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8740 @05dd58> : 67                         ceq.i64
	<.main+8741 @05dd59> : 1f 80 b7 05 00             load.ref <@05b780> ;u64Ceq
	<.main+8746 @05dd5e> : 2b                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@05dd5f> - <@05dd6f>): static u64Cne: bool := u64A != u64B
	<.main+8747 @05dd5f> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8751 @05dd63> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8755 @05dd67> : 67                         ceq.i64
	<.main+8756 @05dd68> : 0b                         not.b32
	<.main+8757 @05dd69> : 1f 88 b7 05 00             load.ref <@05b788> ;u64Cne
	<.main+8762 @05dd6e> : 2b                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@05dd6f> - <@05dd7e>): static u64Clt: bool := u64A < u64B
	<.main+8763 @05dd6f> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8767 @05dd73> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8771 @05dd77> : 48                         clt.u64
	<.main+8772 @05dd78> : 1f 90 b7 05 00             load.ref <@05b790> ;u64Clt
	<.main+8777 @05dd7d> : 2b                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@05dd7e> - <@05dd8e>): static u64Cle: bool := u64A <= u64B
	<.main+8778 @05dd7e> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8782 @05dd82> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8786 @05dd86> : 49                         cgt.u64
	<.main+8787 @05dd87> : 0b                         not.b32
	<.main+8788 @05dd88> : 1f 98 b7 05 00             load.ref <@05b798> ;u64Cle
	<.main+8793 @05dd8d> : 2b                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@05dd8e> - <@05dd9d>): static u64Cgt: bool := u64A > u64B
	<.main+8794 @05dd8e> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8798 @05dd92> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8802 @05dd96> : 49                         cgt.u64
	<.main+8803 @05dd97> : 1f a0 b7 05 00             load.ref <@05b7a0> ;u64Cgt
	<.main+8808 @05dd9c> : 2b                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@05dd9d> - <@05ddad>): static u64Cge: bool := u64A >= u64B
	<.main+8809 @05dd9d> : 21 00 b7 05                load.m64 <@05b700> ;u64A
	<.main+8813 @05dda1> : 21 08 b7 05                load.m64 <@05b708> ;u64B
	<.main+8817 @05dda5> : 48                         clt.u64
	<.main+8818 @05dda6> : 0b                         not.b32
	<.main+8819 @05dda7> : 1f a8 b7 05 00             load.ref <@05b7a8> ;u64Cge
	<.main+8824 @05ddac> : 2b                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@05ddad> - <@05ddb6>): static f32A: float32 := a
	<.main+8825 @05ddad> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8830 @05ddb2> : 24 b0 b7 05                store.m32 <@05b7b0> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@05ddb6> - <@05ddbf>): static f32B: float32 := b
	<.main+8834 @05ddb6> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8839 @05ddbb> : 24 b8 b7 05                store.m32 <@05b7b8> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@05ddbf> - <@05ddc7>): static f32Pls: float32 := +f32B
	<.main+8843 @05ddbf> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8847 @05ddc3> : 24 c0 b7 05                store.m32 <@05b7c0> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@05ddc7> - <@05ddd0>): static f32Neg: float32 := -f32B
	<.main+8851 @05ddc7> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8855 @05ddcb> : 70                         neg.f32
	<.main+8856 @05ddcc> : 24 c8 b7 05                store.m32 <@05b7c8> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@05ddd0> - <@05dddd>): static f32Add: float32 := f32A + f32B
	<.main+8860 @05ddd0> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8864 @05ddd4> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8868 @05ddd8> : 71                         add.f32
	<.main+8869 @05ddd9> : 24 d0 b7 05                store.m32 <@05b7d0> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@05dddd> - <@05ddea>): static f32Sub: float32 := f32A - f32B
	<.main+8873 @05dddd> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8877 @05dde1> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8881 @05dde5> : 72                         sub.f32
	<.main+8882 @05dde6> : 24 d8 b7 05                store.m32 <@05b7d8> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@05ddea> - <@05ddf7>): static f32Mul: float32 := f32A * f32B
	<.main+8886 @05ddea> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8890 @05ddee> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8894 @05ddf2> : 73                         mul.f32
	<.main+8895 @05ddf3> : 24 e0 b7 05                store.m32 <@05b7e0> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@05ddf7> - <@05de04>): static f32Div: float32 := f32A / f32B
	<.main+8899 @05ddf7> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8903 @05ddfb> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8907 @05ddff> : 74                         div.f32
	<.main+8908 @05de00> : 24 e8 b7 05                store.m32 <@05b7e8> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@05de04> - <@05de11>): static f32Mod: float32 := f32A % f32B
	<.main+8912 @05de04> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8916 @05de08> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8920 @05de0c> : 75                         mod.f32
	<.main+8921 @05de0d> : 24 f0 b7 05                store.m32 <@05b7f0> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@05de11> - <@05de1d>): static f32Not: bool := !(f32B)
	<.main+8925 @05de11> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8929 @05de15> : 7c                         f32.2bool
	<.main+8930 @05de16> : 0b                         not.b32
	<.main+8931 @05de17> : 1f f8 b7 05 00             load.ref <@05b7f8> ;f32Not
	<.main+8936 @05de1c> : 2b                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@05de1d> - <@05de2c>): static f32Ceq: bool := f32A == f32B
	<.main+8937 @05de1d> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8941 @05de21> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8945 @05de25> : 77                         ceq.f32
	<.main+8946 @05de26> : 1f 00 b8 05 00             load.ref <@05b800> ;f32Ceq
	<.main+8951 @05de2b> : 2b                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@05de2c> - <@05de3c>): static f32Cne: bool := f32A != f32B
	<.main+8952 @05de2c> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8956 @05de30> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8960 @05de34> : 77                         ceq.f32
	<.main+8961 @05de35> : 0b                         not.b32
	<.main+8962 @05de36> : 1f 08 b8 05 00             load.ref <@05b808> ;f32Cne
	<.main+8967 @05de3b> : 2b                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@05de3c> - <@05de4b>): static f32Clt: bool := f32A < f32B
	<.main+8968 @05de3c> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8972 @05de40> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8976 @05de44> : 78                         clt.f32
	<.main+8977 @05de45> : 1f 10 b8 05 00             load.ref <@05b810> ;f32Clt
	<.main+8982 @05de4a> : 2b                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@05de4b> - <@05de5b>): static f32Cle: bool := f32A <= f32B
	<.main+8983 @05de4b> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+8987 @05de4f> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+8991 @05de53> : 79                         cgt.f32
	<.main+8992 @05de54> : 0b                         not.b32
	<.main+8993 @05de55> : 1f 18 b8 05 00             load.ref <@05b818> ;f32Cle
	<.main+8998 @05de5a> : 2b                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@05de5b> - <@05de6a>): static f32Cgt: bool := f32A > f32B
	<.main+8999 @05de5b> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+9003 @05de5f> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+9007 @05de63> : 79                         cgt.f32
	<.main+9008 @05de64> : 1f 20 b8 05 00             load.ref <@05b820> ;f32Cgt
	<.main+9013 @05de69> : 2b                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@05de6a> - <@05de7a>): static f32Cge: bool := f32A >= f32B
	<.main+9014 @05de6a> : 20 b0 b7 05                load.m32 <@05b7b0> ;f32A
	<.main+9018 @05de6e> : 20 b8 b7 05                load.m32 <@05b7b8> ;f32B
	<.main+9022 @05de72> : 78                         clt.f32
	<.main+9023 @05de73> : 0b                         not.b32
	<.main+9024 @05de74> : 1f 28 b8 05 00             load.ref <@05b828> ;f32Cge
	<.main+9029 @05de79> : 2b                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@05de7a> - <@05de87>): static f64A: float64 := a
	<.main+9030 @05de7a> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+9039 @05de83> : 23 30 b8 05                store.m64 <@05b830> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@05de87> - <@05de94>): static f64B: float64 := b
	<.main+9043 @05de87> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+9052 @05de90> : 23 38 b8 05                store.m64 <@05b838> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@05de94> - <@05de9c>): static f64Pls: float64 := +f64B
	<.main+9056 @05de94> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9060 @05de98> : 23 40 b8 05                store.m64 <@05b840> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@05de9c> - <@05dea5>): static f64Neg: float64 := -f64B
	<.main+9064 @05de9c> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9068 @05dea0> : 80                         neg.f64
	<.main+9069 @05dea1> : 23 48 b8 05                store.m64 <@05b848> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@05dea5> - <@05deb2>): static f64Add: float64 := f64A + f64B
	<.main+9073 @05dea5> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9077 @05dea9> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9081 @05dead> : 81                         add.f64
	<.main+9082 @05deae> : 23 50 b8 05                store.m64 <@05b850> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@05deb2> - <@05debf>): static f64Sub: float64 := f64A - f64B
	<.main+9086 @05deb2> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9090 @05deb6> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9094 @05deba> : 82                         sub.f64
	<.main+9095 @05debb> : 23 58 b8 05                store.m64 <@05b858> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@05debf> - <@05decc>): static f64Mul: float64 := f64A * f64B
	<.main+9099 @05debf> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9103 @05dec3> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9107 @05dec7> : 83                         mul.f64
	<.main+9108 @05dec8> : 23 60 b8 05                store.m64 <@05b860> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@05decc> - <@05ded9>): static f64Div: float64 := f64A / f64B
	<.main+9112 @05decc> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9116 @05ded0> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9120 @05ded4> : 84                         div.f64
	<.main+9121 @05ded5> : 23 68 b8 05                store.m64 <@05b868> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@05ded9> - <@05dee6>): static f64Mod: float64 := f64A % f64B
	<.main+9125 @05ded9> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9129 @05dedd> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9133 @05dee1> : 85                         mod.f64
	<.main+9134 @05dee2> : 23 70 b8 05                store.m64 <@05b870> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@05dee6> - <@05def2>): static f64Not: bool := !(f64B)
	<.main+9138 @05dee6> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9142 @05deea> : 8d                         f64.2bool
	<.main+9143 @05deeb> : 0b                         not.b32
	<.main+9144 @05deec> : 1f 78 b8 05 00             load.ref <@05b878> ;f64Not
	<.main+9149 @05def1> : 2b                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@05def2> - <@05df01>): static f64Ceq: bool := f64A == f64B
	<.main+9150 @05def2> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9154 @05def6> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9158 @05defa> : 87                         ceq.f64
	<.main+9159 @05defb> : 1f 80 b8 05 00             load.ref <@05b880> ;f64Ceq
	<.main+9164 @05df00> : 2b                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@05df01> - <@05df11>): static f64Cne: bool := f64A != f64B
	<.main+9165 @05df01> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9169 @05df05> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9173 @05df09> : 87                         ceq.f64
	<.main+9174 @05df0a> : 0b                         not.b32
	<.main+9175 @05df0b> : 1f 88 b8 05 00             load.ref <@05b888> ;f64Cne
	<.main+9180 @05df10> : 2b                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@05df11> - <@05df20>): static f64Clt: bool := f64A < f64B
	<.main+9181 @05df11> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9185 @05df15> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9189 @05df19> : 88                         clt.f64
	<.main+9190 @05df1a> : 1f 90 b8 05 00             load.ref <@05b890> ;f64Clt
	<.main+9195 @05df1f> : 2b                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@05df20> - <@05df30>): static f64Cle: bool := f64A <= f64B
	<.main+9196 @05df20> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9200 @05df24> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9204 @05df28> : 89                         cgt.f64
	<.main+9205 @05df29> : 0b                         not.b32
	<.main+9206 @05df2a> : 1f 98 b8 05 00             load.ref <@05b898> ;f64Cle
	<.main+9211 @05df2f> : 2b                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@05df30> - <@05df3f>): static f64Cgt: bool := f64A > f64B
	<.main+9212 @05df30> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9216 @05df34> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9220 @05df38> : 89                         cgt.f64
	<.main+9221 @05df39> : 1f a0 b8 05 00             load.ref <@05b8a0> ;f64Cgt
	<.main+9226 @05df3e> : 2b                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@05df3f> - <@05df4f>): static f64Cge: bool := f64A >= f64B
	<.main+9227 @05df3f> : 21 30 b8 05                load.m64 <@05b830> ;f64A
	<.main+9231 @05df43> : 21 38 b8 05                load.m64 <@05b838> ;f64B
	<.main+9235 @05df47> : 88                         clt.f64
	<.main+9236 @05df48> : 0b                         not.b32
	<.main+9237 @05df49> : 1f a8 b8 05 00             load.ref <@05b8a8> ;f64Cge
	<.main+9242 @05df4e> : 2b                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@05df4f> - <@05df58>): static ptrA: pointer := null
	<.main+9243 @05df4f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+9248 @05df54> : 24 b0 b8 05                store.m32 <@05b8b0> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@05df58> - <@05df61>): static ptrB: pointer := pointer(shift)
	<.main+9252 @05df58> : 1f 18 b1 05 00             load.ref <@05b118> ;shift
	<.main+9257 @05df5d> : 24 b8 b8 05                store.m32 <@05b8b8> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@05df61> - <@05df70>): static ptrCeq: bool := ptrA == ptrB
	<.main+9261 @05df61> : 20 b0 b8 05                load.m32 <@05b8b0> ;ptrA
	<.main+9265 @05df65> : 20 b8 b8 05                load.m32 <@05b8b8> ;ptrB
	<.main+9269 @05df69> : 57                         ceq.i32
	<.main+9270 @05df6a> : 1f c0 b8 05 00             load.ref <@05b8c0> ;ptrCeq
	<.main+9275 @05df6f> : 2b                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@05df70> - <@05df80>): static ptrCne: bool := ptrA != ptrB
	<.main+9276 @05df70> : 20 b0 b8 05                load.m32 <@05b8b0> ;ptrA
	<.main+9280 @05df74> : 20 b8 b8 05                load.m32 <@05b8b8> ;ptrB
	<.main+9284 @05df78> : 57                         ceq.i32
	<.main+9285 @05df79> : 0b                         not.b32
	<.main+9286 @05df7a> : 1f c8 b8 05 00             load.ref <@05b8c8> ;ptrCne
	<.main+9291 @05df7f> : 2b                         store.i8
	test/lang/stmt.if.ci:26: (5 bytes: <@05df80> - <@05df85>): static t: int32 := 0
	<.main+9292 @05df80> : 19                         load.z32
	<.main+9293 @05df81> : 24 d0 b8 05                store.m32 <@05b8d0> ;t
	test/lang/stmt.for.ci:12: (5 bytes: <@05df85> - <@05df8a>): static forIdx: int32
	<.main+9297 @05df85> : 19                         load.z32
	<.main+9298 @05df86> : 24 d8 b8 05                store.m32 <@05b8d8> ;forIdx
	test/std/test.math.ci:3: (24 bytes: <@05df8a> - <@05dfa2>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9302 @05df8a> : 1a                         load.z64
	<.main+9303 @05df8b> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9312 @05df94> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9317 @05df99> : 02                         call
	<.main+9318 @05df9a> : 09 f8 ff ff                inc.sp(-8)
	<.main+9322 @05df9e> : 23 e0 b8 05                store.m64 <@05b8e0> ;testMathFloor_1
	test/std/test.math.ci:4: (24 bytes: <@05dfa2> - <@05dfba>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9326 @05dfa2> : 1a                         load.z64
	<.main+9327 @05dfa3> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9336 @05dfac> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9341 @05dfb1> : 02                         call
	<.main+9342 @05dfb2> : 09 f8 ff ff                inc.sp(-8)
	<.main+9346 @05dfb6> : 23 e8 b8 05                store.m64 <@05b8e8> ;testMathFloor_2
	test/std/test.math.ci:5: (24 bytes: <@05dfba> - <@05dfd2>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9350 @05dfba> : 1a                         load.z64
	<.main+9351 @05dfbb> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9360 @05dfc4> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9365 @05dfc9> : 02                         call
	<.main+9366 @05dfca> : 09 f8 ff ff                inc.sp(-8)
	<.main+9370 @05dfce> : 23 f0 b8 05                store.m64 <@05b8f0> ;testMathFloor_3
	test/std/test.math.ci:6: (24 bytes: <@05dfd2> - <@05dfea>): static testMathFloor_4: float64 := Math.floor(-3.200000)
	<.main+9374 @05dfd2> : 1a                         load.z64
	<.main+9375 @05dfd3> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9384 @05dfdc> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9389 @05dfe1> : 02                         call
	<.main+9390 @05dfe2> : 09 f8 ff ff                inc.sp(-8)
	<.main+9394 @05dfe6> : 23 f8 b8 05                store.m64 <@05b8f8> ;testMathFloor_4
	test/std/test.math.ci:7: (24 bytes: <@05dfea> - <@05e002>): static testMathFloor_5: float64 := Math.floor(-3.500000)
	<.main+9398 @05dfea> : 1a                         load.z64
	<.main+9399 @05dfeb> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9408 @05dff4> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9413 @05dff9> : 02                         call
	<.main+9414 @05dffa> : 09 f8 ff ff                inc.sp(-8)
	<.main+9418 @05dffe> : 23 00 b9 05                store.m64 <@05b900> ;testMathFloor_5
	test/std/test.math.ci:8: (24 bytes: <@05e002> - <@05e01a>): static testMathFloor_6: float64 := Math.floor(-3.600000)
	<.main+9422 @05e002> : 1a                         load.z64
	<.main+9423 @05e003> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9432 @05e00c> : 1f 08 92 05 00             load.ref <@059208> ;Math.floor(x: float64): float64
	<.main+9437 @05e011> : 02                         call
	<.main+9438 @05e012> : 09 f8 ff ff                inc.sp(-8)
	<.main+9442 @05e016> : 23 08 b9 05                store.m64 <@05b908> ;testMathFloor_6
	test/std/test.math.ci:10: (29 bytes: <@05e01a> - <@05e037>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9446 @05e01a> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9455 @05e023> : 11 00                      dup.x64 sp(0)
	<.main+9457 @05e025> : 1a                         load.z64
	<.main+9458 @05e026> : 89                         cgt.f64
	<.main+9459 @05e027> : 11 01                      dup.x64 sp(1)
	<.main+9461 @05e029> : 1a                         load.z64
	<.main+9462 @05e02a> : 88                         clt.f64
	<.main+9463 @05e02b> : 52                         sub.i32
	<.main+9464 @05e02c> : 13 02                      set.x32 sp(2)
	<.main+9466 @05e02e> : 09 fc ff ff                inc.sp(-4)
	<.main+9470 @05e032> : 5d                         i32.2f64
	<.main+9471 @05e033> : 23 10 b9 05                store.m64 <@05b910> ;testMathSign_1F
	test/std/test.math.ci:11: (21 bytes: <@05e037> - <@05e04c>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9475 @05e037> : 1a                         load.z64
	<.main+9476 @05e038> : 11 00                      dup.x64 sp(0)
	<.main+9478 @05e03a> : 1a                         load.z64
	<.main+9479 @05e03b> : 89                         cgt.f64
	<.main+9480 @05e03c> : 11 01                      dup.x64 sp(1)
	<.main+9482 @05e03e> : 1a                         load.z64
	<.main+9483 @05e03f> : 88                         clt.f64
	<.main+9484 @05e040> : 52                         sub.i32
	<.main+9485 @05e041> : 13 02                      set.x32 sp(2)
	<.main+9487 @05e043> : 09 fc ff ff                inc.sp(-4)
	<.main+9491 @05e047> : 5d                         i32.2f64
	<.main+9492 @05e048> : 23 18 b9 05                store.m64 <@05b918> ;testMathSign_2F
	test/std/test.math.ci:12: (29 bytes: <@05e04c> - <@05e069>): static testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+9496 @05e04c> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9505 @05e055> : 11 00                      dup.x64 sp(0)
	<.main+9507 @05e057> : 1a                         load.z64
	<.main+9508 @05e058> : 89                         cgt.f64
	<.main+9509 @05e059> : 11 01                      dup.x64 sp(1)
	<.main+9511 @05e05b> : 1a                         load.z64
	<.main+9512 @05e05c> : 88                         clt.f64
	<.main+9513 @05e05d> : 52                         sub.i32
	<.main+9514 @05e05e> : 13 02                      set.x32 sp(2)
	<.main+9516 @05e060> : 09 fc ff ff                inc.sp(-4)
	<.main+9520 @05e064> : 5d                         i32.2f64
	<.main+9521 @05e065> : 23 20 b9 05                store.m64 <@05b920> ;testMathSign_3F
	test/std/test.math.ci:13: (21 bytes: <@05e069> - <@05e07e>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9525 @05e069> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9530 @05e06e> : 10 00                      dup.x32 sp(0)
	<.main+9532 @05e070> : 19                         load.z32
	<.main+9533 @05e071> : 79                         cgt.f32
	<.main+9534 @05e072> : 10 01                      dup.x32 sp(1)
	<.main+9536 @05e074> : 19                         load.z32
	<.main+9537 @05e075> : 78                         clt.f32
	<.main+9538 @05e076> : 52                         sub.i32
	<.main+9539 @05e077> : 13 01                      set.x32 sp(1)
	<.main+9541 @05e079> : 5d                         i32.2f64
	<.main+9542 @05e07a> : 23 28 b9 05                store.m64 <@05b928> ;testMathSign_1f
	test/std/test.math.ci:14: (17 bytes: <@05e07e> - <@05e08f>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9546 @05e07e> : 19                         load.z32
	<.main+9547 @05e07f> : 10 00                      dup.x32 sp(0)
	<.main+9549 @05e081> : 19                         load.z32
	<.main+9550 @05e082> : 79                         cgt.f32
	<.main+9551 @05e083> : 10 01                      dup.x32 sp(1)
	<.main+9553 @05e085> : 19                         load.z32
	<.main+9554 @05e086> : 78                         clt.f32
	<.main+9555 @05e087> : 52                         sub.i32
	<.main+9556 @05e088> : 13 01                      set.x32 sp(1)
	<.main+9558 @05e08a> : 5d                         i32.2f64
	<.main+9559 @05e08b> : 23 30 b9 05                store.m64 <@05b930> ;testMathSign_2f
	test/std/test.math.ci:15: (21 bytes: <@05e08f> - <@05e0a4>): static testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+9563 @05e08f> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9568 @05e094> : 10 00                      dup.x32 sp(0)
	<.main+9570 @05e096> : 19                         load.z32
	<.main+9571 @05e097> : 79                         cgt.f32
	<.main+9572 @05e098> : 10 01                      dup.x32 sp(1)
	<.main+9574 @05e09a> : 19                         load.z32
	<.main+9575 @05e09b> : 78                         clt.f32
	<.main+9576 @05e09c> : 52                         sub.i32
	<.main+9577 @05e09d> : 13 01                      set.x32 sp(1)
	<.main+9579 @05e09f> : 5d                         i32.2f64
	<.main+9580 @05e0a0> : 23 38 b9 05                store.m64 <@05b938> ;testMathSign_3f
	test/std/test.math.ci:17: (24 bytes: <@05e0a4> - <@05e0bc>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9584 @05e0a4> : 1a                         load.z64
	<.main+9585 @05e0a5> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9594 @05e0ae> : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<.main+9599 @05e0b3> : 02                         call
	<.main+9600 @05e0b4> : 09 f8 ff ff                inc.sp(-8)
	<.main+9604 @05e0b8> : 23 40 b9 05                store.m64 <@05b940> ;testMathAbs_1F
	test/std/test.math.ci:18: (15 bytes: <@05e0bc> - <@05e0cb>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9608 @05e0bc> : 1b                         load.z128
	<.main+9609 @05e0bd> : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<.main+9614 @05e0c2> : 02                         call
	<.main+9615 @05e0c3> : 09 f8 ff ff                inc.sp(-8)
	<.main+9619 @05e0c7> : 23 48 b9 05                store.m64 <@05b948> ;testMathAbs_2F
	test/std/test.math.ci:19: (24 bytes: <@05e0cb> - <@05e0e3>): static testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+9623 @05e0cb> : 1a                         load.z64
	<.main+9624 @05e0cc> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9633 @05e0d5> : 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<.main+9638 @05e0da> : 02                         call
	<.main+9639 @05e0db> : 09 f8 ff ff                inc.sp(-8)
	<.main+9643 @05e0df> : 23 50 b9 05                store.m64 <@05b950> ;testMathAbs_3F
	test/std/test.math.ci:20: (21 bytes: <@05e0e3> - <@05e0f8>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9647 @05e0e3> : 19                         load.z32
	<.main+9648 @05e0e4> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9653 @05e0e9> : 1f 20 92 05 00             load.ref <@059220> ;Math.abs(x: float32): float32
	<.main+9658 @05e0ee> : 02                         call
	<.main+9659 @05e0ef> : 09 fc ff ff                inc.sp(-4)
	<.main+9663 @05e0f3> : 7d                         f32.2f64
	<.main+9664 @05e0f4> : 23 58 b9 05                store.m64 <@05b958> ;testMathAbs_1f
	test/std/test.math.ci:21: (17 bytes: <@05e0f8> - <@05e109>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9668 @05e0f8> : 19                         load.z32
	<.main+9669 @05e0f9> : 19                         load.z32
	<.main+9670 @05e0fa> : 1f 20 92 05 00             load.ref <@059220> ;Math.abs(x: float32): float32
	<.main+9675 @05e0ff> : 02                         call
	<.main+9676 @05e100> : 09 fc ff ff                inc.sp(-4)
	<.main+9680 @05e104> : 7d                         f32.2f64
	<.main+9681 @05e105> : 23 60 b9 05                store.m64 <@05b960> ;testMathAbs_2f
	test/std/test.math.ci:22: (21 bytes: <@05e109> - <@05e11e>): static testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+9685 @05e109> : 19                         load.z32
	<.main+9686 @05e10a> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9691 @05e10f> : 1f 20 92 05 00             load.ref <@059220> ;Math.abs(x: float32): float32
	<.main+9696 @05e114> : 02                         call
	<.main+9697 @05e115> : 09 fc ff ff                inc.sp(-4)
	<.main+9701 @05e119> : 7d                         f32.2f64
	<.main+9702 @05e11a> : 23 68 b9 05                store.m64 <@05b968> ;testMathAbs_3f
	test/std/test.math.ci:24: (26 bytes: <@05e11e> - <@05e138>): static testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+9706 @05e11e> : 19                         load.z32
	<.main+9707 @05e11f> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9712 @05e124> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9717 @05e129> : 1f 90 92 05 00             load.ref <@059290> ;Math.min(a: float32, b: float32): float32
	<.main+9722 @05e12e> : 02                         call
	<.main+9723 @05e12f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9727 @05e133> : 7d                         f32.2f64
	<.main+9728 @05e134> : 23 70 b9 05                store.m64 <@05b970> ;testMathMin_1f
	test/std/test.math.ci:25: (26 bytes: <@05e138> - <@05e152>): static testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+9732 @05e138> : 19                         load.z32
	<.main+9733 @05e139> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9738 @05e13e> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9743 @05e143> : 1f c0 92 05 00             load.ref <@0592c0> ;Math.max(a: float32, b: float32): float32
	<.main+9748 @05e148> : 02                         call
	<.main+9749 @05e149> : 09 f8 ff ff                inc.sp(-8)
	<.main+9753 @05e14d> : 7d                         f32.2f64
	<.main+9754 @05e14e> : 23 78 b9 05                store.m64 <@05b978> ;testMathMax_2f
	test/std/test.math.ci:26: (33 bytes: <@05e152> - <@05e173>): static testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+9758 @05e152> : 1a                         load.z64
	<.main+9759 @05e153> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9768 @05e15c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9777 @05e165> : 1f a8 92 05 00             load.ref <@0592a8> ;Math.min(a: float64, b: float64): float64
	<.main+9782 @05e16a> : 02                         call
	<.main+9783 @05e16b> : 09 f0 ff ff                inc.sp(-16)
	<.main+9787 @05e16f> : 23 80 b9 05                store.m64 <@05b980> ;testMathMin_1F
	test/std/test.math.ci:27: (33 bytes: <@05e173> - <@05e194>): static testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+9791 @05e173> : 1a                         load.z64
	<.main+9792 @05e174> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9801 @05e17d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9810 @05e186> : 1f d8 92 05 00             load.ref <@0592d8> ;Math.max(a: float64, b: float64): float64
	<.main+9815 @05e18b> : 02                         call
	<.main+9816 @05e18c> : 09 f0 ff ff                inc.sp(-16)
	<.main+9820 @05e190> : 23 88 b9 05                store.m64 <@05b988> ;testMathMax_2F
	test/std/test.math.ci:29: (27 bytes: <@05e194> - <@05e1af>): static testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9824 @05e194> : 19                         load.z32
	<.main+9825 @05e195> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9830 @05e19a> : 19                         load.z32
	<.main+9831 @05e19b> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9836 @05e1a0> : 1f f0 92 05 00             load.ref <@0592f0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9841 @05e1a5> : 02                         call
	<.main+9842 @05e1a6> : 09 f4 ff ff                inc.sp(-12)
	<.main+9846 @05e1aa> : 7d                         f32.2f64
	<.main+9847 @05e1ab> : 23 90 b9 05                store.m64 <@05b990> ;testMathClamp_1f
	test/std/test.math.ci:30: (34 bytes: <@05e1af> - <@05e1d1>): static testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9851 @05e1af> : 1a                         load.z64
	<.main+9852 @05e1b0> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9861 @05e1b9> : 1a                         load.z64
	<.main+9862 @05e1ba> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9871 @05e1c3> : 1f 10 93 05 00             load.ref <@059310> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9876 @05e1c8> : 02                         call
	<.main+9877 @05e1c9> : 09 e8 ff ff                inc.sp(-24)
	<.main+9881 @05e1cd> : 23 98 b9 05                store.m64 <@05b998> ;testMathClamp_1F
	test/std/test.math.ci:32: (25 bytes: <@05e1d1> - <@05e1ea>): static testMathLerp_1f: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9885 @05e1d1> : 19                         load.z32
	<.main+9886 @05e1d2> : 10 00                      dup.x32 sp(0)
	<.main+9888 @05e1d4> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9893 @05e1d9> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9898 @05e1de> : 10 03                      dup.x32 sp(3)
	<.main+9900 @05e1e0> : 72                         sub.f32
	<.main+9901 @05e1e1> : 73                         mul.f32
	<.main+9902 @05e1e2> : 71                         add.f32
	<.main+9903 @05e1e3> : 13 01                      set.x32 sp(1)
	<.main+9905 @05e1e5> : 7d                         f32.2f64
	<.main+9906 @05e1e6> : 23 a0 b9 05                store.m64 <@05b9a0> ;testMathLerp_1f
	test/std/test.math.ci:33: (32 bytes: <@05e1ea> - <@05e20a>): static testMathLerp_1F: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9910 @05e1ea> : 1a                         load.z64
	<.main+9911 @05e1eb> : 11 00                      dup.x64 sp(0)
	<.main+9913 @05e1ed> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9922 @05e1f6> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9931 @05e1ff> : 11 06                      dup.x64 sp(6)
	<.main+9933 @05e201> : 82                         sub.f64
	<.main+9934 @05e202> : 83                         mul.f64
	<.main+9935 @05e203> : 81                         add.f64
	<.main+9936 @05e204> : 14 02                      set.x64 sp(2)
	<.main+9938 @05e206> : 23 a8 b9 05                store.m64 <@05b9a8> ;testMathLerp_1F
	test/std/test.math.ci:35: (64 bytes: <@05e20a> - <@05e24a>): static testMathSmooth_1f: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9942 @05e20a> : 19                         load.z32
	<.main+9943 @05e20b> : 19                         load.z32
	<.main+9944 @05e20c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9949 @05e211> : 10 02                      dup.x32 sp(2)
	<.main+9951 @05e213> : 72                         sub.f32
	<.main+9952 @05e214> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9957 @05e219> : 10 03                      dup.x32 sp(3)
	<.main+9959 @05e21b> : 72                         sub.f32
	<.main+9960 @05e21c> : 74                         div.f32
	<.main+9961 @05e21d> : 19                         load.z32
	<.main+9962 @05e21e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9967 @05e223> : 1f f0 92 05 00             load.ref <@0592f0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9972 @05e228> : 02                         call
	<.main+9973 @05e229> : 09 f4 ff ff                inc.sp(-12)
	<.main+9977 @05e22d> : 10 00                      dup.x32 sp(0)
	<.main+9979 @05e22f> : 10 01                      dup.x32 sp(1)
	<.main+9981 @05e231> : 73                         mul.f32
	<.main+9982 @05e232> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9987 @05e237> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9992 @05e23c> : 10 03                      dup.x32 sp(3)
	<.main+9994 @05e23e> : 73                         mul.f32
	<.main+9995 @05e23f> : 72                         sub.f32
	<.main+9996 @05e240> : 73                         mul.f32
	<.main+9997 @05e241> : 13 01                      set.x32 sp(1)
	<.main+9999 @05e243> : 13 01                      set.x32 sp(1)
	<.main+10001 @05e245>: 7d                         f32.2f64
	<.main+10002 @05e246>: 23 b0 b9 05                store.m64 <@05b9b0> ;testMathSmooth_1f
	test/std/test.math.ci:36: (82 bytes: <@05e24a> - <@05e29c>): static testMathSmooth_1F: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+10006 @05e24a>: 1b                         load.z128
	<.main+10007 @05e24b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10016 @05e254>: 11 04                      dup.x64 sp(4)
	<.main+10018 @05e256>: 82                         sub.f64
	<.main+10019 @05e257>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10028 @05e260>: 11 06                      dup.x64 sp(6)
	<.main+10030 @05e262>: 82                         sub.f64
	<.main+10031 @05e263>: 84                         div.f64
	<.main+10032 @05e264>: 1a                         load.z64
	<.main+10033 @05e265>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10042 @05e26e>: 1f 10 93 05 00             load.ref <@059310> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+10047 @05e273>: 02                         call
	<.main+10048 @05e274>: 09 e8 ff ff                inc.sp(-24)
	<.main+10052 @05e278>: 11 00                      dup.x64 sp(0)
	<.main+10054 @05e27a>: 11 02                      dup.x64 sp(2)
	<.main+10056 @05e27c>: 83                         mul.f64
	<.main+10057 @05e27d>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10066 @05e286>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10075 @05e28f>: 11 06                      dup.x64 sp(6)
	<.main+10077 @05e291>: 83                         mul.f64
	<.main+10078 @05e292>: 82                         sub.f64
	<.main+10079 @05e293>: 83                         mul.f64
	<.main+10080 @05e294>: 14 02                      set.x64 sp(2)
	<.main+10082 @05e296>: 14 02                      set.x64 sp(2)
	<.main+10084 @05e298>: 23 b8 b9 05                store.m64 <@05b9b8> ;testMathSmooth_1F
	test/std/test.math.ci:38: (25 bytes: <@05e29c> - <@05e2b5>): static testMathMin_nan: float64 := Math.min()
	<.main+10088 @05e29c>: 19                         load.z32
	<.main+10089 @05e29d>: 0a 04 00 00                load.sp(+4)
	<.main+10093 @05e2a1>: 1a                         load.z64
	<.main+10094 @05e2a2>: 11 02                      dup.x64 sp(2)
	<.main+10096 @05e2a4>: 1f 30 93 05 00             load.ref <@059330> ;Math.min(data: float64[]): float64
	<.main+10101 @05e2a9>: 02                         call
	<.main+10102 @05e2aa>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10105 @05e2ad>: 09 f0 ff ff                inc.sp(-16)
	<.main+10109 @05e2b1>: 23 c0 b9 05                store.m64 <@05b9c0> ;testMathMin_nan
	test/std/test.math.ci:39: (110 bytes: <@05e2b5> - <@05e323>): static testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10113 @05e2b5>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10122 @05e2be>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10131 @05e2c7>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10140 @05e2d0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10149 @05e2d9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10158 @05e2e2>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10167 @05e2eb>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10176 @05e2f4>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10185 @05e2fd>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10194 @05e306>: 1c 09 00 00 00             load.c32 9
	<.main+10199 @05e30b>: 0a 04 00 00                load.sp(+4)
	<.main+10203 @05e30f>: 1a                         load.z64
	<.main+10204 @05e310>: 11 02                      dup.x64 sp(2)
	<.main+10206 @05e312>: 1f 30 93 05 00             load.ref <@059330> ;Math.min(data: float64[]): float64
	<.main+10211 @05e317>: 02                         call
	<.main+10212 @05e318>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10215 @05e31b>: 09 a8 ff ff                inc.sp(-88)
	<.main+10219 @05e31f>: 23 c8 b9 05                store.m64 <@05b9c8> ;testMathMin_1
	test/std/test.math.ci:40: (25 bytes: <@05e323> - <@05e33c>): static testMathMax_nan: float64 := Math.max()
	<.main+10223 @05e323>: 19                         load.z32
	<.main+10224 @05e324>: 0a 04 00 00                load.sp(+4)
	<.main+10228 @05e328>: 1a                         load.z64
	<.main+10229 @05e329>: 11 02                      dup.x64 sp(2)
	<.main+10231 @05e32b>: 1f 80 93 05 00             load.ref <@059380> ;Math.max(data: float64[]): float64
	<.main+10236 @05e330>: 02                         call
	<.main+10237 @05e331>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10240 @05e334>: 09 f0 ff ff                inc.sp(-16)
	<.main+10244 @05e338>: 23 d0 b9 05                store.m64 <@05b9d0> ;testMathMax_nan
	test/std/test.math.ci:41: (110 bytes: <@05e33c> - <@05e3aa>): static testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10248 @05e33c>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10257 @05e345>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10266 @05e34e>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10275 @05e357>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10284 @05e360>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10293 @05e369>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10302 @05e372>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10311 @05e37b>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10320 @05e384>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10329 @05e38d>: 1c 09 00 00 00             load.c32 9
	<.main+10334 @05e392>: 0a 04 00 00                load.sp(+4)
	<.main+10338 @05e396>: 1a                         load.z64
	<.main+10339 @05e397>: 11 02                      dup.x64 sp(2)
	<.main+10341 @05e399>: 1f 80 93 05 00             load.ref <@059380> ;Math.max(data: float64[]): float64
	<.main+10346 @05e39e>: 02                         call
	<.main+10347 @05e39f>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10350 @05e3a2>: 09 a8 ff ff                inc.sp(-88)
	<.main+10354 @05e3a6>: 23 d8 b9 05                store.m64 <@05b9d8> ;testMathMax_9
	test/std/test.math.ci:43: (25 bytes: <@05e3aa> - <@05e3c3>): static testMathSum_0: float64 := Math.sum()
	<.main+10358 @05e3aa>: 19                         load.z32
	<.main+10359 @05e3ab>: 0a 04 00 00                load.sp(+4)
	<.main+10363 @05e3af>: 1a                         load.z64
	<.main+10364 @05e3b0>: 11 02                      dup.x64 sp(2)
	<.main+10366 @05e3b2>: 1f d0 93 05 00             load.ref <@0593d0> ;Math.sum(data: float64[]): float64
	<.main+10371 @05e3b7>: 02                         call
	<.main+10372 @05e3b8>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10375 @05e3bb>: 09 f0 ff ff                inc.sp(-16)
	<.main+10379 @05e3bf>: 23 e0 b9 05                store.m64 <@05b9e0> ;testMathSum_0
	test/std/test.math.ci:44: (38 bytes: <@05e3c3> - <@05e3e9>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10383 @05e3c3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10392 @05e3cc>: 1c 01 00 00 00             load.c32 1
	<.main+10397 @05e3d1>: 0a 04 00 00                load.sp(+4)
	<.main+10401 @05e3d5>: 1a                         load.z64
	<.main+10402 @05e3d6>: 11 02                      dup.x64 sp(2)
	<.main+10404 @05e3d8>: 1f d0 93 05 00             load.ref <@0593d0> ;Math.sum(data: float64[]): float64
	<.main+10409 @05e3dd>: 02                         call
	<.main+10410 @05e3de>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10413 @05e3e1>: 09 e8 ff ff                inc.sp(-24)
	<.main+10417 @05e3e5>: 23 e8 b9 05                store.m64 <@05b9e8> ;testMathSum_1
	test/std/test.math.ci:45: (47 bytes: <@05e3e9> - <@05e418>): static testMathSum_3: float64 := Math.sum(1, 2)
	<.main+10421 @05e3e9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10430 @05e3f2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10439 @05e3fb>: 1c 02 00 00 00             load.c32 2
	<.main+10444 @05e400>: 0a 04 00 00                load.sp(+4)
	<.main+10448 @05e404>: 1a                         load.z64
	<.main+10449 @05e405>: 11 02                      dup.x64 sp(2)
	<.main+10451 @05e407>: 1f d0 93 05 00             load.ref <@0593d0> ;Math.sum(data: float64[]): float64
	<.main+10456 @05e40c>: 02                         call
	<.main+10457 @05e40d>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10460 @05e410>: 09 e0 ff ff                inc.sp(-32)
	<.main+10464 @05e414>: 23 f0 b9 05                store.m64 <@05b9f0> ;testMathSum_3
	test/std/test.math.ci:46: (119 bytes: <@05e418> - <@05e48f>): static testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+10468 @05e418>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10477 @05e421>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10486 @05e42a>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10495 @05e433>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10504 @05e43c>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10513 @05e445>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10522 @05e44e>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10531 @05e457>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10540 @05e460>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10549 @05e469>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10558 @05e472>: 1c 0a 00 00 00             load.c32 10
	<.main+10563 @05e477>: 0a 04 00 00                load.sp(+4)
	<.main+10567 @05e47b>: 1a                         load.z64
	<.main+10568 @05e47c>: 11 02                      dup.x64 sp(2)
	<.main+10570 @05e47e>: 1f d0 93 05 00             load.ref <@0593d0> ;Math.sum(data: float64[]): float64
	<.main+10575 @05e483>: 02                         call
	<.main+10576 @05e484>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10579 @05e487>: 09 a0 ff ff                inc.sp(-96)
	<.main+10583 @05e48b>: 23 f8 b9 05                store.m64 <@05b9f8> ;testMathSum_55
	test/std/test.math.ci:48: (13 bytes: <@05e48f> - <@05e49c>): static testMathEval_x: float64 := 10
	<.main+10587 @05e48f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10596 @05e498>: 23 00 ba 05                store.m64 <@05ba00> ;testMathEval_x
	test/std/test.math.ci:49: (29 bytes: <@05e49c> - <@05e4b9>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10600 @05e49c>: 19                         load.z32
	<.main+10601 @05e49d>: 0a 04 00 00                load.sp(+4)
	<.main+10605 @05e4a1>: 1a                         load.z64
	<.main+10606 @05e4a2>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10610 @05e4a6>: 11 04                      dup.x64 sp(4)
	<.main+10612 @05e4a8>: 1f 10 94 05 00             load.ref <@059410> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10617 @05e4ad>: 02                         call
	<.main+10618 @05e4ae>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10621 @05e4b1>: 09 e8 ff ff                inc.sp(-24)
	<.main+10625 @05e4b5>: 23 08 ba 05                store.m64 <@05ba08> ;testMathEval_0
	test/std/test.math.ci:50: (13 bytes: <@05e4b9> - <@05e4c6>): static testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+10629 @05e4b9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10638 @05e4c2>: 23 10 ba 05                store.m64 <@05ba10> ;testMathEval_1
	test/std/test.math.ci:51: (28 bytes: <@05e4c6> - <@05e4e2>): static testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+10642 @05e4c6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10651 @05e4cf>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10655 @05e4d3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10664 @05e4dc>: 83                         mul.f64
	<.main+10665 @05e4dd>: 81                         add.f64
	<.main+10666 @05e4de>: 23 18 ba 05                store.m64 <@05ba18> ;testMathEval_2
	test/std/test.math.ci:52: (45 bytes: <@05e4e2> - <@05e50f>): static testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+10670 @05e4e2>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10674 @05e4e6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10683 @05e4ef>: 11 02                      dup.x64 sp(2)
	<.main+10685 @05e4f1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10694 @05e4fa>: 11 06                      dup.x64 sp(6)
	<.main+10696 @05e4fc>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10705 @05e505>: 83                         mul.f64
	<.main+10706 @05e506>: 81                         add.f64
	<.main+10707 @05e507>: 83                         mul.f64
	<.main+10708 @05e508>: 81                         add.f64
	<.main+10709 @05e509>: 14 02                      set.x64 sp(2)
	<.main+10711 @05e50b>: 23 20 ba 05                store.m64 <@05ba20> ;testMathEval_3
	test/std/test.math.ci:53: (62 bytes: <@05e50f> - <@05e54d>): static testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10715 @05e50f>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10719 @05e513>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10728 @05e51c>: 11 02                      dup.x64 sp(2)
	<.main+10730 @05e51e>: 11 04                      dup.x64 sp(4)
	<.main+10732 @05e520>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10741 @05e529>: 11 02                      dup.x64 sp(2)
	<.main+10743 @05e52b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10752 @05e534>: 11 06                      dup.x64 sp(6)
	<.main+10754 @05e536>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10763 @05e53f>: 83                         mul.f64
	<.main+10764 @05e540>: 81                         add.f64
	<.main+10765 @05e541>: 83                         mul.f64
	<.main+10766 @05e542>: 81                         add.f64
	<.main+10767 @05e543>: 14 02                      set.x64 sp(2)
	<.main+10769 @05e545>: 83                         mul.f64
	<.main+10770 @05e546>: 81                         add.f64
	<.main+10771 @05e547>: 14 02                      set.x64 sp(2)
	<.main+10773 @05e549>: 23 28 ba 05                store.m64 <@05ba28> ;testMathEval_4
	test/std/test.math.ci:54: (78 bytes: <@05e54d> - <@05e59b>): static testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10777 @05e54d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10786 @05e556>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10795 @05e55f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10804 @05e568>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10813 @05e571>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10822 @05e57a>: 1c 05 00 00 00             load.c32 5
	<.main+10827 @05e57f>: 0a 04 00 00                load.sp(+4)
	<.main+10831 @05e583>: 1a                         load.z64
	<.main+10832 @05e584>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10836 @05e588>: 11 04                      dup.x64 sp(4)
	<.main+10838 @05e58a>: 1f 10 94 05 00             load.ref <@059410> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10843 @05e58f>: 02                         call
	<.main+10844 @05e590>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10847 @05e593>: 09 c0 ff ff                inc.sp(-64)
	<.main+10851 @05e597>: 23 30 ba 05                store.m64 <@05ba30> ;testMathEval_5
	test/std/test.math.ci:55: (87 bytes: <@05e59b> - <@05e5f2>): static testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10855 @05e59b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10864 @05e5a4>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10873 @05e5ad>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10882 @05e5b6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10891 @05e5bf>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10900 @05e5c8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10909 @05e5d1>: 1c 06 00 00 00             load.c32 6
	<.main+10914 @05e5d6>: 0a 04 00 00                load.sp(+4)
	<.main+10918 @05e5da>: 1a                         load.z64
	<.main+10919 @05e5db>: 21 00 ba 05                load.m64 <@05ba00> ;testMathEval_x
	<.main+10923 @05e5df>: 11 04                      dup.x64 sp(4)
	<.main+10925 @05e5e1>: 1f 10 94 05 00             load.ref <@059410> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10930 @05e5e6>: 02                         call
	<.main+10931 @05e5e7>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10934 @05e5ea>: 09 b8 ff ff                inc.sp(-72)
	<.main+10938 @05e5ee>: 23 38 ba 05                store.m64 <@05ba38> ;testMathEval_6
	test/std/test.math.ci:57: (35 bytes: <@05e5f2> - <@05e615>): static testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+10942 @05e5f2>: 1a                         load.z64
	<.main+10943 @05e5f3>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10952 @05e5fc>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10961 @05e605>: 84                         div.f64
	<.main+10962 @05e606>: 19                         load.z32
	<.main+10963 @05e607>: 1f c0 94 05 00             load.ref <@0594c0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10968 @05e60c>: 02                         call
	<.main+10969 @05e60d>: 09 f4 ff ff                inc.sp(-12)
	<.main+10973 @05e611>: 23 40 ba 05                store.m64 <@05ba40> ;testMathSin_f64
	test/std/test.math.ci:58: (49 bytes: <@05e615> - <@05e646>): static testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+10977 @05e615>: 1b                         load.z128
	<.main+10978 @05e616>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10987 @05e61f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10996 @05e628>: 84                         div.f64
	<.main+10997 @05e629>: 1f 38 92 05 00             load.ref <@059238> ;Math.abs(x: float64): float64
	<.main+11002 @05e62e>: 02                         call
	<.main+11003 @05e62f>: 09 f8 ff ff                inc.sp(-8)
	<.main+11007 @05e633>: 1c 01 00 00 00             load.c32 1
	<.main+11012 @05e638>: 1f c0 94 05 00             load.ref <@0594c0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+11017 @05e63d>: 02                         call
	<.main+11018 @05e63e>: 09 f4 ff ff                inc.sp(-12)
	<.main+11022 @05e642>: 23 48 ba 05                store.m64 <@05ba48> ;testMathCos_f64
	test/std/test.math.ci:59: (34 bytes: <@05e646> - <@05e668>): static testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+11026 @05e646>: 1a                         load.z64
	<.main+11027 @05e647>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11036 @05e650>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+11045 @05e659>: 84                         div.f64
	<.main+11046 @05e65a>: 1f 10 96 05 00             load.ref <@059610> ;Math.tan(arg: float64): float64
	<.main+11051 @05e65f>: 02                         call
	<.main+11052 @05e660>: 09 f8 ff ff                inc.sp(-8)
	<.main+11056 @05e664>: 23 50 ba 05                store.m64 <@05ba50> ;testMathTan_f64
	test/std/test.math.ci:60: (34 bytes: <@05e668> - <@05e68a>): static testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+11060 @05e668>: 1a                         load.z64
	<.main+11061 @05e669>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11070 @05e672>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11079 @05e67b>: 84                         div.f64
	<.main+11080 @05e67c>: 1f 90 97 05 00             load.ref <@059790> ;Math.sinh(x: float64): float64
	<.main+11085 @05e681>: 02                         call
	<.main+11086 @05e682>: 09 f8 ff ff                inc.sp(-8)
	<.main+11090 @05e686>: 23 58 ba 05                store.m64 <@05ba58> ;testMathSinh_f64
	test/std/test.math.ci:61: (34 bytes: <@05e68a> - <@05e6ac>): static testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+11094 @05e68a>: 1a                         load.z64
	<.main+11095 @05e68b>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11104 @05e694>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11113 @05e69d>: 84                         div.f64
	<.main+11114 @05e69e>: 1f 88 98 05 00             load.ref <@059888> ;Math.cosh(x: float64): float64
	<.main+11119 @05e6a3>: 02                         call
	<.main+11120 @05e6a4>: 09 f8 ff ff                inc.sp(-8)
	<.main+11124 @05e6a8>: 23 60 ba 05                store.m64 <@05ba60> ;testMathCosh_f64
	test/std/test.math.ci:63: (24 bytes: <@05e6ac> - <@05e6c4>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+11128 @05e6ac>: 1a                         load.z64
	<.main+11129 @05e6ad>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11138 @05e6b6>: 1f d8 98 05 00             load.ref <@0598d8> ;Math.asin(x: float64): float64
	<.main+11143 @05e6bb>: 02                         call
	<.main+11144 @05e6bc>: 09 f8 ff ff                inc.sp(-8)
	<.main+11148 @05e6c0>: 23 68 ba 05                store.m64 <@05ba68> ;testMathAsin_f64
	test/std/test.math.ci:64: (44 bytes: <@05e6c4> - <@05e6f0>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+11152 @05e6c4>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11161 @05e6cd>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11170 @05e6d6>: 84                         div.f64
	<.main+11171 @05e6d7>: 1a                         load.z64
	<.main+11172 @05e6d8>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11181 @05e6e1>: 1f d8 98 05 00             load.ref <@0598d8> ;Math.asin(x: float64): float64
	<.main+11186 @05e6e6>: 02                         call
	<.main+11187 @05e6e7>: 09 f8 ff ff                inc.sp(-8)
	<.main+11191 @05e6eb>: 82                         sub.f64
	<.main+11192 @05e6ec>: 23 70 ba 05                store.m64 <@05ba70> ;testMathAcos_f64
	test/std/test.math.ci:67: (34 bytes: <@05e6f0> - <@05e712>): static testMathCmp_f32: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11196 @05e6f0>: 19                         load.z32
	<.main+11197 @05e6f1>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11202 @05e6f6>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+11207 @05e6fb>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11212 @05e700>: 1f 40 94 05 00             load.ref <@059440> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+11217 @05e705>: 02                         call
	<.main+11218 @05e706>: 09 f4 ff ff                inc.sp(-12)
	<.main+11222 @05e70a>: 19                         load.z32
	<.main+11223 @05e70b>: 57                         ceq.i32
	<.main+11224 @05e70c>: 1f 78 ba 05 00             load.ref <@05ba78> ;testMathCmp_f32
	<.main+11229 @05e711>: 2b                         store.i8
	test/std/test.math.ci:68: (46 bytes: <@05e712> - <@05e740>): static testMathCmp_f64: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11230 @05e712>: 19                         load.z32
	<.main+11231 @05e713>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11240 @05e71c>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+11249 @05e725>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11258 @05e72e>: 1f 80 94 05 00             load.ref <@059480> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+11263 @05e733>: 02                         call
	<.main+11264 @05e734>: 09 e8 ff ff                inc.sp(-24)
	<.main+11268 @05e738>: 19                         load.z32
	<.main+11269 @05e739>: 57                         ceq.i32
	<.main+11270 @05e73a>: 1f 80 ba 05 00             load.ref <@05ba80> ;testMathCmp_f64
	<.main+11275 @05e73f>: 2b                         store.i8
	test/std/test.math.ci:70: (33 bytes: <@05e740> - <@05e761>): static testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+11276 @05e740>: 1a                         load.z64
	<.main+11277 @05e741>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11286 @05e74a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11295 @05e753>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11300 @05e758>: 02                         call
	<.main+11301 @05e759>: 09 f0 ff ff                inc.sp(-16)
	<.main+11305 @05e75d>: 23 88 ba 05                store.m64 <@05ba88> ;testMathAbsMod_f64_0a
	test/std/test.math.ci:71: (24 bytes: <@05e761> - <@05e779>): static testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+11309 @05e761>: 1b                         load.z128
	<.main+11310 @05e762>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11319 @05e76b>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11324 @05e770>: 02                         call
	<.main+11325 @05e771>: 09 f0 ff ff                inc.sp(-16)
	<.main+11329 @05e775>: 23 90 ba 05                store.m64 <@05ba90> ;testMathAbsMod_f64_0b
	test/std/test.math.ci:72: (33 bytes: <@05e779> - <@05e79a>): static testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+11333 @05e779>: 1a                         load.z64
	<.main+11334 @05e77a>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11343 @05e783>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11352 @05e78c>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11357 @05e791>: 02                         call
	<.main+11358 @05e792>: 09 f0 ff ff                inc.sp(-16)
	<.main+11362 @05e796>: 23 98 ba 05                store.m64 <@05ba98> ;testMathAbsMod_f64_0c
	test/std/test.math.ci:74: (33 bytes: <@05e79a> - <@05e7bb>): static testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+11366 @05e79a>: 1a                         load.z64
	<.main+11367 @05e79b>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11376 @05e7a4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11385 @05e7ad>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11390 @05e7b2>: 02                         call
	<.main+11391 @05e7b3>: 09 f0 ff ff                inc.sp(-16)
	<.main+11395 @05e7b7>: 23 a0 ba 05                store.m64 <@05baa0> ;testMathAbsMod_f64_9a
	test/std/test.math.ci:75: (33 bytes: <@05e7bb> - <@05e7dc>): static testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+11399 @05e7bb>: 1a                         load.z64
	<.main+11400 @05e7bc>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11409 @05e7c5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11418 @05e7ce>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11423 @05e7d3>: 02                         call
	<.main+11424 @05e7d4>: 09 f0 ff ff                inc.sp(-16)
	<.main+11428 @05e7d8>: 23 a8 ba 05                store.m64 <@05baa8> ;testMathAbsMod_f64_9b
	test/std/test.math.ci:76: (33 bytes: <@05e7dc> - <@05e7fd>): static testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+11432 @05e7dc>: 1a                         load.z64
	<.main+11433 @05e7dd>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11442 @05e7e6>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11451 @05e7ef>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11456 @05e7f4>: 02                         call
	<.main+11457 @05e7f5>: 09 f0 ff ff                inc.sp(-16)
	<.main+11461 @05e7f9>: 23 b0 ba 05                store.m64 <@05bab0> ;testMathAbsMod_f64_9c
	test/std/test.math.ci:77: (33 bytes: <@05e7fd> - <@05e81e>): static testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+11465 @05e7fd>: 1a                         load.z64
	<.main+11466 @05e7fe>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11475 @05e807>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11484 @05e810>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11489 @05e815>: 02                         call
	<.main+11490 @05e816>: 09 f0 ff ff                inc.sp(-16)
	<.main+11494 @05e81a>: 23 b8 ba 05                store.m64 <@05bab8> ;testMathAbsMod_f64_9d
	test/std/test.math.ci:79: (33 bytes: <@05e81e> - <@05e83f>): static testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+11498 @05e81e>: 1a                         load.z64
	<.main+11499 @05e81f>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11508 @05e828>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11517 @05e831>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11522 @05e836>: 02                         call
	<.main+11523 @05e837>: 09 f0 ff ff                inc.sp(-16)
	<.main+11527 @05e83b>: 23 c0 ba 05                store.m64 <@05bac0> ;testMathAbsMod_f64_8a
	test/std/test.math.ci:80: (33 bytes: <@05e83f> - <@05e860>): static testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+11531 @05e83f>: 1a                         load.z64
	<.main+11532 @05e840>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11541 @05e849>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11550 @05e852>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11555 @05e857>: 02                         call
	<.main+11556 @05e858>: 09 f0 ff ff                inc.sp(-16)
	<.main+11560 @05e85c>: 23 c8 ba 05                store.m64 <@05bac8> ;testMathAbsMod_f64_8b
	test/std/test.math.ci:81: (33 bytes: <@05e860> - <@05e881>): static testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+11564 @05e860>: 1a                         load.z64
	<.main+11565 @05e861>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11574 @05e86a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11583 @05e873>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11588 @05e878>: 02                         call
	<.main+11589 @05e879>: 09 f0 ff ff                inc.sp(-16)
	<.main+11593 @05e87d>: 23 d0 ba 05                store.m64 <@05bad0> ;testMathAbsMod_f64_8c
	test/std/test.math.ci:82: (33 bytes: <@05e881> - <@05e8a2>): static testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+11597 @05e881>: 1a                         load.z64
	<.main+11598 @05e882>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11607 @05e88b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11616 @05e894>: 1f 70 92 05 00             load.ref <@059270> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11621 @05e899>: 02                         call
	<.main+11622 @05e89a>: 09 f0 ff ff                inc.sp(-16)
	<.main+11626 @05e89e>: 23 d8 ba 05                store.m64 <@05bad8> ;testMathAbsMod_f64_8d
	test/std/test.math.ci:84: (25 bytes: <@05e8a2> - <@05e8bb>): static testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+11630 @05e8a2>: 19                         load.z32
	<.main+11631 @05e8a3>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11636 @05e8a8>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11641 @05e8ad>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11646 @05e8b2>: 02                         call
	<.main+11647 @05e8b3>: 09 f8 ff ff                inc.sp(-8)
	<.main+11651 @05e8b7>: 24 e0 ba 05                store.m32 <@05bae0> ;testMathAbsMod_f32_0a
	test/std/test.math.ci:85: (21 bytes: <@05e8bb> - <@05e8d0>): static testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+11655 @05e8bb>: 19                         load.z32
	<.main+11656 @05e8bc>: 19                         load.z32
	<.main+11657 @05e8bd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11662 @05e8c2>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11667 @05e8c7>: 02                         call
	<.main+11668 @05e8c8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11672 @05e8cc>: 24 e8 ba 05                store.m32 <@05bae8> ;testMathAbsMod_f32_0b
	test/std/test.math.ci:86: (25 bytes: <@05e8d0> - <@05e8e9>): static testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+11676 @05e8d0>: 19                         load.z32
	<.main+11677 @05e8d1>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11682 @05e8d6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11687 @05e8db>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11692 @05e8e0>: 02                         call
	<.main+11693 @05e8e1>: 09 f8 ff ff                inc.sp(-8)
	<.main+11697 @05e8e5>: 24 f0 ba 05                store.m32 <@05baf0> ;testMathAbsMod_f32_0c
	test/std/test.math.ci:88: (25 bytes: <@05e8e9> - <@05e902>): static testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+11701 @05e8e9>: 19                         load.z32
	<.main+11702 @05e8ea>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11707 @05e8ef>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11712 @05e8f4>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11717 @05e8f9>: 02                         call
	<.main+11718 @05e8fa>: 09 f8 ff ff                inc.sp(-8)
	<.main+11722 @05e8fe>: 24 f8 ba 05                store.m32 <@05baf8> ;testMathAbsMod_f32_9a
	test/std/test.math.ci:89: (25 bytes: <@05e902> - <@05e91b>): static testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+11726 @05e902>: 19                         load.z32
	<.main+11727 @05e903>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11732 @05e908>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11737 @05e90d>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11742 @05e912>: 02                         call
	<.main+11743 @05e913>: 09 f8 ff ff                inc.sp(-8)
	<.main+11747 @05e917>: 24 00 bb 05                store.m32 <@05bb00> ;testMathAbsMod_f32_9b
	test/std/test.math.ci:90: (25 bytes: <@05e91b> - <@05e934>): static testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+11751 @05e91b>: 19                         load.z32
	<.main+11752 @05e91c>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11757 @05e921>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11762 @05e926>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11767 @05e92b>: 02                         call
	<.main+11768 @05e92c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11772 @05e930>: 24 08 bb 05                store.m32 <@05bb08> ;testMathAbsMod_f32_9c
	test/std/test.math.ci:91: (25 bytes: <@05e934> - <@05e94d>): static testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+11776 @05e934>: 19                         load.z32
	<.main+11777 @05e935>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11782 @05e93a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11787 @05e93f>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11792 @05e944>: 02                         call
	<.main+11793 @05e945>: 09 f8 ff ff                inc.sp(-8)
	<.main+11797 @05e949>: 24 10 bb 05                store.m32 <@05bb10> ;testMathAbsMod_f32_9d
	test/std/test.math.ci:93: (25 bytes: <@05e94d> - <@05e966>): static testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+11801 @05e94d>: 19                         load.z32
	<.main+11802 @05e94e>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11807 @05e953>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11812 @05e958>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11817 @05e95d>: 02                         call
	<.main+11818 @05e95e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11822 @05e962>: 24 18 bb 05                store.m32 <@05bb18> ;testMathAbsMod_f32_8a
	test/std/test.math.ci:94: (25 bytes: <@05e966> - <@05e97f>): static testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+11826 @05e966>: 19                         load.z32
	<.main+11827 @05e967>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11832 @05e96c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11837 @05e971>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11842 @05e976>: 02                         call
	<.main+11843 @05e977>: 09 f8 ff ff                inc.sp(-8)
	<.main+11847 @05e97b>: 24 20 bb 05                store.m32 <@05bb20> ;testMathAbsMod_f32_8b
	test/std/test.math.ci:95: (25 bytes: <@05e97f> - <@05e998>): static testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+11851 @05e97f>: 19                         load.z32
	<.main+11852 @05e980>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11857 @05e985>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11862 @05e98a>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11867 @05e98f>: 02                         call
	<.main+11868 @05e990>: 09 f8 ff ff                inc.sp(-8)
	<.main+11872 @05e994>: 24 28 bb 05                store.m32 <@05bb28> ;testMathAbsMod_f32_8c
	test/std/test.math.ci:96: (25 bytes: <@05e998> - <@05e9b1>): static testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+11876 @05e998>: 19                         load.z32
	<.main+11877 @05e999>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11882 @05e99e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11887 @05e9a3>: 1f 50 92 05 00             load.ref <@059250> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11892 @05e9a8>: 02                         call
	<.main+11893 @05e9a9>: 09 f8 ff ff                inc.sp(-8)
	<.main+11897 @05e9ad>: 24 30 bb 05                store.m32 <@05bb30> ;testMathAbsMod_f32_8d
	test/std/memory.ci:13: (18 bytes: <@05e9b1> - <@05e9c3>): pointer.fill(p1, 0, 1024);
	<.main+11901 @05e9b1>: 20 38 a9 05                load.m32 <@05a938> ;p1
	<.main+11905 @05e9b5>: 19                         load.z32
	<.main+11906 @05e9b6>: 1c 00 04 00 00             load.c32 1024
	<.main+11911 @05e9bb>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+11915 @05e9bf>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:14: (21 bytes: <@05e9c3> - <@05e9d8>): pointer.copy(p1, p3, 160);
	<.main+11919 @05e9c3>: 20 38 a9 05                load.m32 <@05a938> ;p1
	<.main+11923 @05e9c7>: 20 48 a9 05                load.m32 <@05a948> ;p3
	<.main+11927 @05e9cb>: 1c a0 00 00 00             load.c32 160
	<.main+11932 @05e9d0>: 01 0c 00 00                nfc(12) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11936 @05e9d4>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:17: (13 bytes: <@05e9d8> - <@05e9e5>): free(p1);
	<.main+11940 @05e9d8>: 20 38 a9 05                load.m32 <@05a938> ;p1
	<.main+11944 @05e9dc>: 19                         load.z32
	<.main+11945 @05e9dd>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11949 @05e9e1>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:18: (13 bytes: <@05e9e5> - <@05e9f2>): free(p2);
	<.main+11953 @05e9e5>: 20 40 a9 05                load.m32 <@05a940> ;p2
	<.main+11957 @05e9e9>: 19                         load.z32
	<.main+11958 @05e9ea>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11962 @05e9ee>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:19: (13 bytes: <@05e9f2> - <@05e9ff>): free(p3);
	<.main+11966 @05e9f2>: 20 48 a9 05                load.m32 <@05a948> ;p3
	<.main+11970 @05e9f6>: 19                         load.z32
	<.main+11971 @05e9f7>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11975 @05e9fb>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:20: (13 bytes: <@05e9ff> - <@05ea0c>): free(p4);
	<.main+11979 @05e9ff>: 20 50 a9 05                load.m32 <@05a950> ;p4
	<.main+11983 @05ea03>: 19                         load.z32
	<.main+11984 @05ea04>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11988 @05ea08>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:26: (35 bytes: <@05ea0c> - <@05ea2f>): debug("val1", val1);
	<.main+11992 @05ea0c>: 1f d0 c7 03 00             load.ref <@03c7d0> ;"test/std/memory.ci"
	<.main+11997 @05ea11>: 1c 1a 00 00 00             load.c32 26
	<.main+12002 @05ea16>: 1c 0e 00 00 00             load.c32 14
	<.main+12007 @05ea1b>: 19                         load.z32
	<.main+12008 @05ea1c>: 1f f7 c7 03 00             load.ref <@03c7f7> ;"val1"
	<.main+12013 @05ea21>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+12018 @05ea26>: 1f 58 a9 05 00             load.ref <@05a958> ;val1
	<.main+12023 @05ea2b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:27: (35 bytes: <@05ea2f> - <@05ea52>): debug("val2", val2);
	<.main+12027 @05ea2f>: 1f d0 c7 03 00             load.ref <@03c7d0> ;"test/std/memory.ci"
	<.main+12032 @05ea34>: 1c 1b 00 00 00             load.c32 27
	<.main+12037 @05ea39>: 1c 0e 00 00 00             load.c32 14
	<.main+12042 @05ea3e>: 19                         load.z32
	<.main+12043 @05ea3f>: 1f fc c7 03 00             load.ref <@03c7fc> ;"val2"
	<.main+12048 @05ea44>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+12053 @05ea49>: 1f 60 a9 05 00             load.ref <@05a960> ;val2
	<.main+12058 @05ea4e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:29: (22 bytes: <@05ea52> - <@05ea68>): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+12062 @05ea52>: 1f 60 a9 05 00             load.ref <@05a960> ;val2
	<.main+12067 @05ea57>: 1f 58 a9 05 00             load.ref <@05a958> ;val1
	<.main+12072 @05ea5c>: 20 90 04 00                load.m32 <@000490> ;int64+32
	<.main+12076 @05ea60>: 01 0d 00 00                nfc(13) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+12080 @05ea64>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:30: (18 bytes: <@05ea68> - <@05ea7a>): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+12084 @05ea68>: 1f 58 a9 05 00             load.ref <@05a958> ;val1
	<.main+12089 @05ea6d>: 19                         load.z32
	<.main+12090 @05ea6e>: 20 90 04 00                load.m32 <@000490> ;int64+32
	<.main+12094 @05ea72>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12098 @05ea76>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:32: (35 bytes: <@05ea7a> - <@05ea9d>): debug("val1", val1);
	<.main+12102 @05ea7a>: 1f d0 c7 03 00             load.ref <@03c7d0> ;"test/std/memory.ci"
	<.main+12107 @05ea7f>: 1c 20 00 00 00             load.c32 32
	<.main+12112 @05ea84>: 1c 0e 00 00 00             load.c32 14
	<.main+12117 @05ea89>: 19                         load.z32
	<.main+12118 @05ea8a>: 1f f7 c7 03 00             load.ref <@03c7f7> ;"val1"
	<.main+12123 @05ea8f>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+12128 @05ea94>: 1f 58 a9 05 00             load.ref <@05a958> ;val1
	<.main+12133 @05ea99>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:33: (35 bytes: <@05ea9d> - <@05eac0>): debug("val2", val2);
	<.main+12137 @05ea9d>: 1f d0 c7 03 00             load.ref <@03c7d0> ;"test/std/memory.ci"
	<.main+12142 @05eaa2>: 1c 21 00 00 00             load.c32 33
	<.main+12147 @05eaa7>: 1c 0e 00 00 00             load.c32 14
	<.main+12152 @05eaac>: 19                         load.z32
	<.main+12153 @05eaad>: 1f fc c7 03 00             load.ref <@03c7fc> ;"val2"
	<.main+12158 @05eab2>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+12163 @05eab7>: 1f 60 a9 05 00             load.ref <@05a960> ;val2
	<.main+12168 @05eabc>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.method.ci:78: (21 bytes: <@05eac0> - <@05ead5>): recordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+12172 @05eac0>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12176 @05eac4>: 1c 01 00 00 00             load.c32 1
	<.main+12181 @05eac9>: 13 04                      set.x32 sp(4)
	<.main+12183 @05eacb>: 1f f0 ae 05 00             load.ref <@05aef0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12188 @05ead0>: 02                         call
	<.main+12189 @05ead1>: 09 f0 ff ff                inc.sp(-16)
	test/lang/init.method.ci:79: (20 bytes: <@05ead5> - <@05eae9>): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+12193 @05ead5>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12197 @05ead9>: 1c 01 00 00 00             load.c32 1
	<.main+12202 @05eade>: 13 04                      set.x32 sp(4)
	<.main+12204 @05eae0>: 20 a0 af 05                load.m32 <@05afa0> ;recordMethodTest+8
	<.main+12208 @05eae4>: 02                         call
	<.main+12209 @05eae5>: 09 f0 ff ff                inc.sp(-16)
	test/lang/init.method.ci:97: (19 bytes: <@05eae9> - <@05eafc>): staticMethod(recordMethodTest, 2);
	<.main+12213 @05eae9>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12217 @05eaed>: 1c 02 00 00 00             load.c32 2
	<.main+12222 @05eaf2>: 1f a8 af 05 00             load.ref <@05afa8> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12227 @05eaf7>: 02                         call
	<.main+12228 @05eaf8>: 09 ec ff ff                inc.sp(-20)
	test/lang/init.method.ci:98: (19 bytes: <@05eafc> - <@05eb0f>): virtualMethod(recordMethodTest, 2);
	<.main+12232 @05eafc>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12236 @05eb00>: 1c 02 00 00 00             load.c32 2
	<.main+12241 @05eb05>: 1f f0 af 05 00             load.ref <@05aff0> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12246 @05eb0a>: 02                         call
	<.main+12247 @05eb0b>: 09 ec ff ff                inc.sp(-20)
	test/lang/init.method.ci:101: (21 bytes: <@05eb0f> - <@05eb24>): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+12251 @05eb0f>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12255 @05eb13>: 1c 03 00 00 00             load.c32 3
	<.main+12260 @05eb18>: 13 04                      set.x32 sp(4)
	<.main+12262 @05eb1a>: 1f f0 ae 05 00             load.ref <@05aef0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12267 @05eb1f>: 02                         call
	<.main+12268 @05eb20>: 09 f0 ff ff                inc.sp(-16)
	test/lang/init.method.ci:102: (21 bytes: <@05eb24> - <@05eb39>): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12272 @05eb24>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12276 @05eb28>: 1c 03 00 00 00             load.c32 3
	<.main+12281 @05eb2d>: 13 04                      set.x32 sp(4)
	<.main+12283 @05eb2f>: 1f 20 af 05 00             load.ref <@05af20> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12288 @05eb34>: 02                         call
	<.main+12289 @05eb35>: 09 f0 ff ff                inc.sp(-16)
	test/lang/init.method.ci:103: (20 bytes: <@05eb39> - <@05eb4d>): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12293 @05eb39>: 22 98 af 05                load.m128 <@05af98> ;recordMethodTest
	<.main+12297 @05eb3d>: 1c 03 00 00 00             load.c32 3
	<.main+12302 @05eb42>: 13 04                      set.x32 sp(4)
	<.main+12304 @05eb44>: 20 a0 af 05                load.m32 <@05afa0> ;recordMethodTest+8
	<.main+12308 @05eb48>: 02                         call
	<.main+12309 @05eb49>: 09 f0 ff ff                inc.sp(-16)
	test/lang/init.array.ci:35: (35 bytes: <@05eb4d> - <@05eb70>): debug("string as variant", strFixed);
	<.main+12313 @05eb4d>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12318 @05eb52>: 1c 23 00 00 00             load.c32 35
	<.main+12323 @05eb57>: 1c 0e 00 00 00             load.c32 14
	<.main+12328 @05eb5c>: 19                         load.z32
	<.main+12329 @05eb5d>: 1f c0 7d 04 00             load.ref <@047dc0> ;"string as variant"
	<.main+12334 @05eb62>: 1f c8 88 04 00             load.ref <@0488c8>
	<.main+12339 @05eb67>: 1f a0 b0 05 00             load.ref <@05b0a0> ;strFixed
	<.main+12344 @05eb6c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:38: (34 bytes: <@05eb70> - <@05eb92>): debug("string as variant", strArray);
	<.main+12348 @05eb70>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12353 @05eb75>: 1c 26 00 00 00             load.c32 38
	<.main+12358 @05eb7a>: 1c 0e 00 00 00             load.c32 14
	<.main+12363 @05eb7f>: 19                         load.z32
	<.main+12364 @05eb80>: 1f c0 7d 04 00             load.ref <@047dc0> ;"string as variant"
	<.main+12369 @05eb85>: 1f 90 8a 04 00             load.ref <@048a90>
	<.main+12374 @05eb8a>: 20 a8 b0 05                load.m32 <@05b0a8> ;strArray
	<.main+12378 @05eb8e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:41: (34 bytes: <@05eb92> - <@05ebb4>): debug("string as variant", strSlice);
	<.main+12382 @05eb92>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12387 @05eb97>: 1c 29 00 00 00             load.c32 41
	<.main+12392 @05eb9c>: 1c 0e 00 00 00             load.c32 14
	<.main+12397 @05eba1>: 19                         load.z32
	<.main+12398 @05eba2>: 1f c0 7d 04 00             load.ref <@047dc0> ;"string as variant"
	<.main+12403 @05eba7>: 1f c0 8b 04 00             load.ref <@048bc0>
	<.main+12408 @05ebac>: 20 b0 b0 05                load.m32 <@05b0b0> ;strSlice
	<.main+12412 @05ebb0>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:48: (53 bytes: <@05ebb4> - <@05ebe9>): assert(arrSliceInitNull.length == (0));
	<.main+12416 @05ebb4>: 20 74 b0 05                load.m32 <@05b074> ;arrSliceInitNull+4
	<.main+12420 @05ebb8>: 19                         load.z32
	<.main+12421 @05ebb9>: 57                         ceq.i32
	<.main+12422 @05ebba>: 06 08 00 00                jz <.main+12430 @05ebc2>
	<.main+12426 @05ebbe>: 04 2b 00 00                jmp <.main+12469 @05ebe9>
	<.main+12430 @05ebc2>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12435 @05ebc7>: 1c 30 00 00 00             load.c32 48
	<.main+12440 @05ebcc>: 1c fe ff ff ff             load.c32 -2
	<.main+12445 @05ebd1>: 1c 80 00 00 00             load.c32 128
	<.main+12450 @05ebd6>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+12455 @05ebdb>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12460 @05ebe0>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12465 @05ebe5>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:49: (61 bytes: <@05ebe9> - <@05ec26>): assert(arrFixedInit[0] == (42));
	<.main+12469 @05ebe9>: 21 30 b0 05                load.m64 <@05b030> ;arrFixedInit
	<.main+12473 @05ebed>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12482 @05ebf6>: 67                         ceq.i64
	<.main+12483 @05ebf7>: 06 08 00 00                jz <.main+12491 @05ebff>
	<.main+12487 @05ebfb>: 04 2b 00 00                jmp <.main+12530 @05ec26>
	<.main+12491 @05ebff>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12496 @05ec04>: 1c 31 00 00 00             load.c32 49
	<.main+12501 @05ec09>: 1c fe ff ff ff             load.c32 -2
	<.main+12506 @05ec0e>: 1c 80 00 00 00             load.c32 128
	<.main+12511 @05ec13>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+12516 @05ec18>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12521 @05ec1d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12526 @05ec22>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:56: (25 bytes: <@05ec26> - <@05ec3f>): assertEq(7, arrFixedInit.length);
	<.main+12530 @05ec26>: 1c 07 00 00 00             load.c32 7
	<.main+12535 @05ec2b>: 1c 07 00 00 00             load.c32 7
	<.main+12540 @05ec30>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12545 @05ec35>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12550 @05ec3a>: 02                         call
	<.main+12551 @05ec3b>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:57: (24 bytes: <@05ec3f> - <@05ec57>): assertEq(arrFixedInit.length, arrSliceInitFixed.length);
	<.main+12555 @05ec3f>: 1c 07 00 00 00             load.c32 7
	<.main+12560 @05ec44>: 20 84 b0 05                load.m32 <@05b084> ;arrSliceInitFixed+4
	<.main+12564 @05ec48>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12569 @05ec4d>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12574 @05ec52>: 02                         call
	<.main+12575 @05ec53>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:58: (24 bytes: <@05ec57> - <@05ec6f>): assertEq(arrFixedInit.length, arrSliceInitSlice.length);
	<.main+12579 @05ec57>: 1c 07 00 00 00             load.c32 7
	<.main+12584 @05ec5c>: 20 94 b0 05                load.m32 <@05b094> ;arrSliceInitSlice+4
	<.main+12588 @05ec60>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12593 @05ec65>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12598 @05ec6a>: 02                         call
	<.main+12599 @05ec6b>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:60: (32 bytes: <@05ec6f> - <@05ec8f>): assertEq(0, lenSlice(null));
	<.main+12603 @05ec6f>: 19                         load.z32
	<.main+12604 @05ec70>: 1a                         load.z64
	<.main+12605 @05ec71>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12610 @05ec76>: 1f b8 b0 05 00             load.ref <@05b0b8> ;lenSlice(values: int64[]): int32
	<.main+12615 @05ec7b>: 02                         call
	<.main+12616 @05ec7c>: 09 f8 ff ff                inc.sp(-8)
	<.main+12620 @05ec80>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12625 @05ec85>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12630 @05ec8a>: 02                         call
	<.main+12631 @05ec8b>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:61: (31 bytes: <@05ec8f> - <@05ecae>): assertEq(0, lenSlice(arrSliceInitNull));
	<.main+12635 @05ec8f>: 19                         load.z32
	<.main+12636 @05ec90>: 19                         load.z32
	<.main+12637 @05ec91>: 21 70 b0 05                load.m64 <@05b070> ;arrSliceInitNull
	<.main+12641 @05ec95>: 1f b8 b0 05 00             load.ref <@05b0b8> ;lenSlice(values: int64[]): int32
	<.main+12646 @05ec9a>: 02                         call
	<.main+12647 @05ec9b>: 09 f8 ff ff                inc.sp(-8)
	<.main+12651 @05ec9f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12656 @05eca4>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12661 @05eca9>: 02                         call
	<.main+12662 @05ecaa>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:62: (41 bytes: <@05ecae> - <@05ecd7>): assertEq(arrFixedInit.length, lenSlice(arrFixedInit));
	<.main+12666 @05ecae>: 1c 07 00 00 00             load.c32 7
	<.main+12671 @05ecb3>: 19                         load.z32
	<.main+12672 @05ecb4>: 1c 07 00 00 00             load.c32 7
	<.main+12677 @05ecb9>: 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+12682 @05ecbe>: 1f b8 b0 05 00             load.ref <@05b0b8> ;lenSlice(values: int64[]): int32
	<.main+12687 @05ecc3>: 02                         call
	<.main+12688 @05ecc4>: 09 f8 ff ff                inc.sp(-8)
	<.main+12692 @05ecc8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12697 @05eccd>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12702 @05ecd2>: 02                         call
	<.main+12703 @05ecd3>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:63: (35 bytes: <@05ecd7> - <@05ecfa>): assertEq(arrFixedInit.length, lenSlice(arrSliceInitFixed));
	<.main+12707 @05ecd7>: 1c 07 00 00 00             load.c32 7
	<.main+12712 @05ecdc>: 19                         load.z32
	<.main+12713 @05ecdd>: 21 80 b0 05                load.m64 <@05b080> ;arrSliceInitFixed
	<.main+12717 @05ece1>: 1f b8 b0 05 00             load.ref <@05b0b8> ;lenSlice(values: int64[]): int32
	<.main+12722 @05ece6>: 02                         call
	<.main+12723 @05ece7>: 09 f8 ff ff                inc.sp(-8)
	<.main+12727 @05eceb>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12732 @05ecf0>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12737 @05ecf5>: 02                         call
	<.main+12738 @05ecf6>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:64: (35 bytes: <@05ecfa> - <@05ed1d>): assertEq(arrFixedInit.length, lenSlice(arrSliceInitSlice));
	<.main+12742 @05ecfa>: 1c 07 00 00 00             load.c32 7
	<.main+12747 @05ecff>: 19                         load.z32
	<.main+12748 @05ed00>: 21 90 b0 05                load.m64 <@05b090> ;arrSliceInitSlice
	<.main+12752 @05ed04>: 1f b8 b0 05 00             load.ref <@05b0b8> ;lenSlice(values: int64[]): int32
	<.main+12757 @05ed09>: 02                         call
	<.main+12758 @05ed0a>: 09 f8 ff ff                inc.sp(-8)
	<.main+12762 @05ed0e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12767 @05ed13>: 1f 48 91 05 00             load.ref <@059148> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12772 @05ed18>: 02                         call
	<.main+12773 @05ed19>: 09 f4 ff ff                inc.sp(-12)
	test/lang/init.array.ci:66: (827 bytes: <@05ed1d> - <@05f058>): for (i: int32 := 0; i < arrFixedInit.length; i := i + 1)
	<.main+12777 @05ed1d>: 19                         load.z32
	<.main+12778 @05ed1e>: 04 2a 03 00                jmp <.main+13588 @05f048>
	test/lang/init.array.ci:67: (9 bytes: <@05ed22> - <@05ed2b>): expected: int64 := 42 + i
	<.main+12782 @05ed22>: 1c 2a 00 00 00             load.c32 42
	<.main+12787 @05ed27>: 10 01                      dup.x32 sp(1)
	<.main+12789 @05ed29>: 51                         add.i32
	<.main+12790 @05ed2a>: 5b                         i32.2i64
	test/lang/init.array.ci:68: (62 bytes: <@05ed2b> - <@05ed69>): assert(expected == arrFixedInit[i]);
	<.main+12791 @05ed2b>: 11 00                      dup.x64 sp(0)
	<.main+12793 @05ed2d>: 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+12798 @05ed32>: 10 05                      dup.x32 sp(5)
	<.main+12800 @05ed34>: 0d 08 00 00                mad.u32 8
	<.main+12804 @05ed38>: 29                         load.i64
	<.main+12805 @05ed39>: 67                         ceq.i64
	<.main+12806 @05ed3a>: 06 08 00 00                jz <.main+12814 @05ed42>
	<.main+12810 @05ed3e>: 04 2b 00 00                jmp <.main+12853 @05ed69>
	<.main+12814 @05ed42>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12819 @05ed47>: 1c 44 00 00 00             load.c32 68
	<.main+12824 @05ed4c>: 1c fe ff ff ff             load.c32 -2
	<.main+12829 @05ed51>: 1c 80 00 00 00             load.c32 128
	<.main+12834 @05ed56>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+12839 @05ed5b>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12844 @05ed60>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12849 @05ed65>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:69: (61 bytes: <@05ed69> - <@05eda6>): assert(expected == arrArrayInitFixed[i]);
	<.main+12853 @05ed69>: 11 00                      dup.x64 sp(0)
	<.main+12855 @05ed6b>: 20 78 b0 05                load.m32 <@05b078> ;arrArrayInitFixed
	<.main+12859 @05ed6f>: 10 05                      dup.x32 sp(5)
	<.main+12861 @05ed71>: 0d 08 00 00                mad.u32 8
	<.main+12865 @05ed75>: 29                         load.i64
	<.main+12866 @05ed76>: 67                         ceq.i64
	<.main+12867 @05ed77>: 06 08 00 00                jz <.main+12875 @05ed7f>
	<.main+12871 @05ed7b>: 04 2b 00 00                jmp <.main+12914 @05eda6>
	<.main+12875 @05ed7f>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12880 @05ed84>: 1c 45 00 00 00             load.c32 69
	<.main+12885 @05ed89>: 1c fe ff ff ff             load.c32 -2
	<.main+12890 @05ed8e>: 1c 80 00 00 00             load.c32 128
	<.main+12895 @05ed93>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+12900 @05ed98>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12905 @05ed9d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12910 @05eda2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:70: (61 bytes: <@05eda6> - <@05ede3>): assert(expected == arrSliceInitFixed[i]);
	<.main+12914 @05eda6>: 11 00                      dup.x64 sp(0)
	<.main+12916 @05eda8>: 20 80 b0 05                load.m32 <@05b080> ;arrSliceInitFixed
	<.main+12920 @05edac>: 10 05                      dup.x32 sp(5)
	<.main+12922 @05edae>: 0d 08 00 00                mad.u32 8
	<.main+12926 @05edb2>: 29                         load.i64
	<.main+12927 @05edb3>: 67                         ceq.i64
	<.main+12928 @05edb4>: 06 08 00 00                jz <.main+12936 @05edbc>
	<.main+12932 @05edb8>: 04 2b 00 00                jmp <.main+12975 @05ede3>
	<.main+12936 @05edbc>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+12941 @05edc1>: 1c 46 00 00 00             load.c32 70
	<.main+12946 @05edc6>: 1c fe ff ff ff             load.c32 -2
	<.main+12951 @05edcb>: 1c 80 00 00 00             load.c32 128
	<.main+12956 @05edd0>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+12961 @05edd5>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12966 @05edda>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12971 @05eddf>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:72: (68 bytes: <@05ede3> - <@05ee27>): assert(expected == nthFixed(i, arrFixedInit));
	<.main+12975 @05ede3>: 11 00                      dup.x64 sp(0)
	<.main+12977 @05ede5>: 1a                         load.z64
	<.main+12978 @05ede6>: 10 06                      dup.x32 sp(6)
	<.main+12980 @05ede8>: 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+12985 @05eded>: 1f c0 b0 05 00             load.ref <@05b0c0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12990 @05edf2>: 02                         call
	<.main+12991 @05edf3>: 09 f8 ff ff                inc.sp(-8)
	<.main+12995 @05edf7>: 67                         ceq.i64
	<.main+12996 @05edf8>: 06 08 00 00                jz <.main+13004 @05ee00>
	<.main+13000 @05edfc>: 04 2b 00 00                jmp <.main+13043 @05ee27>
	<.main+13004 @05ee00>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13009 @05ee05>: 1c 48 00 00 00             load.c32 72
	<.main+13014 @05ee0a>: 1c fe ff ff ff             load.c32 -2
	<.main+13019 @05ee0f>: 1c 80 00 00 00             load.c32 128
	<.main+13024 @05ee14>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13029 @05ee19>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13034 @05ee1e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13039 @05ee23>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:73: (67 bytes: <@05ee27> - <@05ee6a>): assert(expected == nthFixed(i, arrArrayInitFixed));
	<.main+13043 @05ee27>: 11 00                      dup.x64 sp(0)
	<.main+13045 @05ee29>: 1a                         load.z64
	<.main+13046 @05ee2a>: 10 06                      dup.x32 sp(6)
	<.main+13048 @05ee2c>: 20 78 b0 05                load.m32 <@05b078> ;arrArrayInitFixed
	<.main+13052 @05ee30>: 1f c0 b0 05 00             load.ref <@05b0c0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13057 @05ee35>: 02                         call
	<.main+13058 @05ee36>: 09 f8 ff ff                inc.sp(-8)
	<.main+13062 @05ee3a>: 67                         ceq.i64
	<.main+13063 @05ee3b>: 06 08 00 00                jz <.main+13071 @05ee43>
	<.main+13067 @05ee3f>: 04 2b 00 00                jmp <.main+13110 @05ee6a>
	<.main+13071 @05ee43>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13076 @05ee48>: 1c 49 00 00 00             load.c32 73
	<.main+13081 @05ee4d>: 1c fe ff ff ff             load.c32 -2
	<.main+13086 @05ee52>: 1c 80 00 00 00             load.c32 128
	<.main+13091 @05ee57>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13096 @05ee5c>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13101 @05ee61>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13106 @05ee66>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:74: (67 bytes: <@05ee6a> - <@05eead>): assert(expected == nthFixed(i, arrSliceInitFixed));
	<.main+13110 @05ee6a>: 11 00                      dup.x64 sp(0)
	<.main+13112 @05ee6c>: 1a                         load.z64
	<.main+13113 @05ee6d>: 10 06                      dup.x32 sp(6)
	<.main+13115 @05ee6f>: 20 80 b0 05                load.m32 <@05b080> ;arrSliceInitFixed
	<.main+13119 @05ee73>: 1f c0 b0 05 00             load.ref <@05b0c0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13124 @05ee78>: 02                         call
	<.main+13125 @05ee79>: 09 f8 ff ff                inc.sp(-8)
	<.main+13129 @05ee7d>: 67                         ceq.i64
	<.main+13130 @05ee7e>: 06 08 00 00                jz <.main+13138 @05ee86>
	<.main+13134 @05ee82>: 04 2b 00 00                jmp <.main+13177 @05eead>
	<.main+13138 @05ee86>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13143 @05ee8b>: 1c 4a 00 00 00             load.c32 74
	<.main+13148 @05ee90>: 1c fe ff ff ff             load.c32 -2
	<.main+13153 @05ee95>: 1c 80 00 00 00             load.c32 128
	<.main+13158 @05ee9a>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13163 @05ee9f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13168 @05eea4>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13173 @05eea9>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:76: (68 bytes: <@05eead> - <@05eef1>): assert(expected == nthArray(i, arrFixedInit));
	<.main+13177 @05eead>: 11 00                      dup.x64 sp(0)
	<.main+13179 @05eeaf>: 1a                         load.z64
	<.main+13180 @05eeb0>: 10 06                      dup.x32 sp(6)
	<.main+13182 @05eeb2>: 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+13187 @05eeb7>: 1f d0 b0 05 00             load.ref <@05b0d0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13192 @05eebc>: 02                         call
	<.main+13193 @05eebd>: 09 f8 ff ff                inc.sp(-8)
	<.main+13197 @05eec1>: 67                         ceq.i64
	<.main+13198 @05eec2>: 06 08 00 00                jz <.main+13206 @05eeca>
	<.main+13202 @05eec6>: 04 2b 00 00                jmp <.main+13245 @05eef1>
	<.main+13206 @05eeca>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13211 @05eecf>: 1c 4c 00 00 00             load.c32 76
	<.main+13216 @05eed4>: 1c fe ff ff ff             load.c32 -2
	<.main+13221 @05eed9>: 1c 80 00 00 00             load.c32 128
	<.main+13226 @05eede>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13231 @05eee3>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13236 @05eee8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13241 @05eeed>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:77: (67 bytes: <@05eef1> - <@05ef34>): assert(expected == nthArray(i, arrArrayInitFixed));
	<.main+13245 @05eef1>: 11 00                      dup.x64 sp(0)
	<.main+13247 @05eef3>: 1a                         load.z64
	<.main+13248 @05eef4>: 10 06                      dup.x32 sp(6)
	<.main+13250 @05eef6>: 20 78 b0 05                load.m32 <@05b078> ;arrArrayInitFixed
	<.main+13254 @05eefa>: 1f d0 b0 05 00             load.ref <@05b0d0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13259 @05eeff>: 02                         call
	<.main+13260 @05ef00>: 09 f8 ff ff                inc.sp(-8)
	<.main+13264 @05ef04>: 67                         ceq.i64
	<.main+13265 @05ef05>: 06 08 00 00                jz <.main+13273 @05ef0d>
	<.main+13269 @05ef09>: 04 2b 00 00                jmp <.main+13312 @05ef34>
	<.main+13273 @05ef0d>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13278 @05ef12>: 1c 4d 00 00 00             load.c32 77
	<.main+13283 @05ef17>: 1c fe ff ff ff             load.c32 -2
	<.main+13288 @05ef1c>: 1c 80 00 00 00             load.c32 128
	<.main+13293 @05ef21>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13298 @05ef26>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13303 @05ef2b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13308 @05ef30>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:78: (67 bytes: <@05ef34> - <@05ef77>): assert(expected == nthArray(i, arrSliceInitFixed));
	<.main+13312 @05ef34>: 11 00                      dup.x64 sp(0)
	<.main+13314 @05ef36>: 1a                         load.z64
	<.main+13315 @05ef37>: 10 06                      dup.x32 sp(6)
	<.main+13317 @05ef39>: 20 80 b0 05                load.m32 <@05b080> ;arrSliceInitFixed
	<.main+13321 @05ef3d>: 1f d0 b0 05 00             load.ref <@05b0d0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13326 @05ef42>: 02                         call
	<.main+13327 @05ef43>: 09 f8 ff ff                inc.sp(-8)
	<.main+13331 @05ef47>: 67                         ceq.i64
	<.main+13332 @05ef48>: 06 08 00 00                jz <.main+13340 @05ef50>
	<.main+13336 @05ef4c>: 04 2b 00 00                jmp <.main+13379 @05ef77>
	<.main+13340 @05ef50>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13345 @05ef55>: 1c 4e 00 00 00             load.c32 78
	<.main+13350 @05ef5a>: 1c fe ff ff ff             load.c32 -2
	<.main+13355 @05ef5f>: 1c 80 00 00 00             load.c32 128
	<.main+13360 @05ef64>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13365 @05ef69>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13370 @05ef6e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13375 @05ef73>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:80: (73 bytes: <@05ef77> - <@05efc0>): assert(expected == nthSlice(i, arrFixedInit));
	<.main+13379 @05ef77>: 11 00                      dup.x64 sp(0)
	<.main+13381 @05ef79>: 1a                         load.z64
	<.main+13382 @05ef7a>: 10 06                      dup.x32 sp(6)
	<.main+13384 @05ef7c>: 1c 07 00 00 00             load.c32 7
	<.main+13389 @05ef81>: 1f 30 b0 05 00             load.ref <@05b030> ;arrFixedInit
	<.main+13394 @05ef86>: 1f e0 b0 05 00             load.ref <@05b0e0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13399 @05ef8b>: 02                         call
	<.main+13400 @05ef8c>: 09 f4 ff ff                inc.sp(-12)
	<.main+13404 @05ef90>: 67                         ceq.i64
	<.main+13405 @05ef91>: 06 08 00 00                jz <.main+13413 @05ef99>
	<.main+13409 @05ef95>: 04 2b 00 00                jmp <.main+13452 @05efc0>
	<.main+13413 @05ef99>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13418 @05ef9e>: 1c 50 00 00 00             load.c32 80
	<.main+13423 @05efa3>: 1c fe ff ff ff             load.c32 -2
	<.main+13428 @05efa8>: 1c 80 00 00 00             load.c32 128
	<.main+13433 @05efad>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13438 @05efb2>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13443 @05efb7>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13448 @05efbc>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:82: (67 bytes: <@05efc0> - <@05f003>): assert(expected == nthSlice(i, arrSliceInitFixed));
	<.main+13452 @05efc0>: 11 00                      dup.x64 sp(0)
	<.main+13454 @05efc2>: 1a                         load.z64
	<.main+13455 @05efc3>: 10 06                      dup.x32 sp(6)
	<.main+13457 @05efc5>: 21 80 b0 05                load.m64 <@05b080> ;arrSliceInitFixed
	<.main+13461 @05efc9>: 1f e0 b0 05 00             load.ref <@05b0e0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13466 @05efce>: 02                         call
	<.main+13467 @05efcf>: 09 f4 ff ff                inc.sp(-12)
	<.main+13471 @05efd3>: 67                         ceq.i64
	<.main+13472 @05efd4>: 06 08 00 00                jz <.main+13480 @05efdc>
	<.main+13476 @05efd8>: 04 2b 00 00                jmp <.main+13519 @05f003>
	<.main+13480 @05efdc>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13485 @05efe1>: 1c 52 00 00 00             load.c32 82
	<.main+13490 @05efe6>: 1c fe ff ff ff             load.c32 -2
	<.main+13495 @05efeb>: 1c 80 00 00 00             load.c32 128
	<.main+13500 @05eff0>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13505 @05eff5>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13510 @05effa>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13515 @05efff>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/init.array.ci:84: (61 bytes: <@05f003> - <@05f040>): assert(expected == arrSliceInitSlice[i]);
	<.main+13519 @05f003>: 11 00                      dup.x64 sp(0)
	<.main+13521 @05f005>: 20 90 b0 05                load.m32 <@05b090> ;arrSliceInitSlice
	<.main+13525 @05f009>: 10 05                      dup.x32 sp(5)
	<.main+13527 @05f00b>: 0d 08 00 00                mad.u32 8
	<.main+13531 @05f00f>: 29                         load.i64
	<.main+13532 @05f010>: 67                         ceq.i64
	<.main+13533 @05f011>: 06 08 00 00                jz <.main+13541 @05f019>
	<.main+13537 @05f015>: 04 2b 00 00                jmp <.main+13580 @05f040>
	<.main+13541 @05f019>: 1f 18 7d 04 00             load.ref <@047d18> ;"test/lang/init.array.ci"
	<.main+13546 @05f01e>: 1c 54 00 00 00             load.c32 84
	<.main+13551 @05f023>: 1c fe ff ff ff             load.c32 -2
	<.main+13556 @05f028>: 1c 80 00 00 00             load.c32 128
	<.main+13561 @05f02d>: 1f 94 e5 00 00             load.ref <@00e594> ;"assertion failed!"
	<.main+13566 @05f032>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13571 @05f037>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13576 @05f03c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13580 @05f040>: 09 f8 ff ff                inc.sp(-8)
	test/lang/init.array.ci:66: (4 bytes: <@05f044> - <@05f048>): i := i + 1
	<.main+13584 @05f044>: 0c 01 00 00                inc.i32(+1)
	test/lang/init.array.ci:66: (12 bytes: <@05f048> - <@05f054>): i < arrFixedInit.length
	<.main+13588 @05f048>: 10 00                      dup.x32 sp(0)
	<.main+13590 @05f04a>: 1c 07 00 00 00             load.c32 7
	<.main+13595 @05f04f>: 58                         clt.i32
	<.main+13596 @05f050>: 05 d2 fc ff                jnz <.main+12782 @05ed22>
	<.main+13600 @05f054>: 09 fc ff ff                inc.sp(-4)
	test/lang/stmt.if.ci:4: (39 bytes: <@05f058> - <@05f07f>): raise(raise.debug, 1, "0 == 0", null);
	<.main+13604 @05f058>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13609 @05f05d>: 1c 04 00 00 00             load.c32 4
	<.main+13614 @05f062>: 1c 0e 00 00 00             load.c32 14
	<.main+13619 @05f067>: 1c 01 00 00 00             load.c32 1
	<.main+13624 @05f06c>: 1f e5 58 05 00             load.ref <@0558e5> ;"0 == 0"
	<.main+13629 @05f071>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13634 @05f076>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13639 @05f07b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:12: (39 bytes: <@05f07f> - <@05f0a6>): raise(raise.debug, 3, "0 == 0", null);
	<.main+13643 @05f07f>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13648 @05f084>: 1c 0c 00 00 00             load.c32 12
	<.main+13653 @05f089>: 1c 0e 00 00 00             load.c32 14
	<.main+13658 @05f08e>: 1c 03 00 00 00             load.c32 3
	<.main+13663 @05f093>: 1f e5 58 05 00             load.ref <@0558e5> ;"0 == 0"
	<.main+13668 @05f098>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13673 @05f09d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13678 @05f0a2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:22: (39 bytes: <@05f0a6> - <@05f0cd>): raise(raise.debug, 6, "0 == 0", null);
	<.main+13682 @05f0a6>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13687 @05f0ab>: 1c 16 00 00 00             load.c32 22
	<.main+13692 @05f0b0>: 1c 0e 00 00 00             load.c32 14
	<.main+13697 @05f0b5>: 1c 06 00 00 00             load.c32 6
	<.main+13702 @05f0ba>: 1f e5 58 05 00             load.ref <@0558e5> ;"0 == 0"
	<.main+13707 @05f0bf>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13712 @05f0c4>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13717 @05f0c9>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:28: (49 bytes: <@05f0cd> - <@05f0fe>): if (t == 0)
	<.main+13721 @05f0cd>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+13725 @05f0d1>: 19                         load.z32
	<.main+13726 @05f0d2>: 57                         ceq.i32
	<.main+13727 @05f0d3>: 06 2b 00 00                jz <.main+13770 @05f0fe>
	test/lang/stmt.if.ci:29: (39 bytes: <@05f0d7> - <@05f0fe>): raise(raise.debug, 7, "t == 0", t);
	<.main+13731 @05f0d7>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13736 @05f0dc>: 1c 1d 00 00 00             load.c32 29
	<.main+13741 @05f0e1>: 1c 0e 00 00 00             load.c32 14
	<.main+13746 @05f0e6>: 1c 07 00 00 00             load.c32 7
	<.main+13751 @05f0eb>: 1f f3 58 05 00             load.ref <@0558f3> ;"t == 0"
	<.main+13756 @05f0f0>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13761 @05f0f5>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13766 @05f0fa>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:32: (49 bytes: <@05f0fe> - <@05f12f>): if (t != 0)
	<.main+13770 @05f0fe>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+13774 @05f102>: 19                         load.z32
	<.main+13775 @05f103>: 57                         ceq.i32
	<.main+13776 @05f104>: 05 2b 00 00                jnz <.main+13819 @05f12f>
	test/lang/stmt.if.ci:33: (39 bytes: <@05f108> - <@05f12f>): raise(raise.debug, 8, "t != 0", t);
	<.main+13780 @05f108>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13785 @05f10d>: 1c 21 00 00 00             load.c32 33
	<.main+13790 @05f112>: 1c 0e 00 00 00             load.c32 14
	<.main+13795 @05f117>: 1c 08 00 00 00             load.c32 8
	<.main+13800 @05f11c>: 1f fa 58 05 00             load.ref <@0558fa> ;"t != 0"
	<.main+13805 @05f121>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13810 @05f126>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13815 @05f12b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:36: (92 bytes: <@05f12f> - <@05f18b>): if (t == 0)
	<.main+13819 @05f12f>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+13823 @05f133>: 19                         load.z32
	<.main+13824 @05f134>: 57                         ceq.i32
	<.main+13825 @05f135>: 06 2f 00 00                jz <.main+13872 @05f164>
	test/lang/stmt.if.ci:37: (39 bytes: <@05f139> - <@05f160>): raise(raise.debug, 9, "t == 0", t);
	<.main+13829 @05f139>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13834 @05f13e>: 1c 25 00 00 00             load.c32 37
	<.main+13839 @05f143>: 1c 0e 00 00 00             load.c32 14
	<.main+13844 @05f148>: 1c 09 00 00 00             load.c32 9
	<.main+13849 @05f14d>: 1f f3 58 05 00             load.ref <@0558f3> ;"t == 0"
	<.main+13854 @05f152>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13859 @05f157>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13864 @05f15c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13868 @05f160>: 04 2b 00 00                jmp <.main+13911 @05f18b>
	test/lang/stmt.if.ci:40: (39 bytes: <@05f164> - <@05f18b>): raise(raise.debug, 10, "t != 0", t);
	<.main+13872 @05f164>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13877 @05f169>: 1c 28 00 00 00             load.c32 40
	<.main+13882 @05f16e>: 1c 0e 00 00 00             load.c32 14
	<.main+13887 @05f173>: 1c 0a 00 00 00             load.c32 10
	<.main+13892 @05f178>: 1f fa 58 05 00             load.ref <@0558fa> ;"t != 0"
	<.main+13897 @05f17d>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13902 @05f182>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13907 @05f187>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:43: (92 bytes: <@05f18b> - <@05f1e7>): if (t != 0)
	<.main+13911 @05f18b>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+13915 @05f18f>: 19                         load.z32
	<.main+13916 @05f190>: 57                         ceq.i32
	<.main+13917 @05f191>: 05 2f 00 00                jnz <.main+13964 @05f1c0>
	test/lang/stmt.if.ci:44: (39 bytes: <@05f195> - <@05f1bc>): raise(raise.debug, 11, "t != 0", t);
	<.main+13921 @05f195>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13926 @05f19a>: 1c 2c 00 00 00             load.c32 44
	<.main+13931 @05f19f>: 1c 0e 00 00 00             load.c32 14
	<.main+13936 @05f1a4>: 1c 0b 00 00 00             load.c32 11
	<.main+13941 @05f1a9>: 1f fa 58 05 00             load.ref <@0558fa> ;"t != 0"
	<.main+13946 @05f1ae>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13951 @05f1b3>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13956 @05f1b8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13960 @05f1bc>: 04 2b 00 00                jmp <.main+14003 @05f1e7>
	test/lang/stmt.if.ci:47: (39 bytes: <@05f1c0> - <@05f1e7>): raise(raise.debug, 12, "t == 0", t);
	<.main+13964 @05f1c0>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+13969 @05f1c5>: 1c 2f 00 00 00             load.c32 47
	<.main+13974 @05f1ca>: 1c 0e 00 00 00             load.c32 14
	<.main+13979 @05f1cf>: 1c 0c 00 00 00             load.c32 12
	<.main+13984 @05f1d4>: 1f f3 58 05 00             load.ref <@0558f3> ;"t == 0"
	<.main+13989 @05f1d9>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13994 @05f1de>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+13999 @05f1e3>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.if.ci:50: (377 bytes: <@05f1e7> - <@05f360>): if (t == 0)
	<.main+14003 @05f1e7>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14007 @05f1eb>: 19                         load.z32
	<.main+14008 @05f1ec>: 57                         ceq.i32
	<.main+14009 @05f1ed>: 06 2f 00 00                jz <.main+14056 @05f21c>
	test/lang/stmt.if.ci:51: (39 bytes: <@05f1f1> - <@05f218>): raise(raise.debug, 9, "t == 0", t);
	<.main+14013 @05f1f1>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14018 @05f1f6>: 1c 33 00 00 00             load.c32 51
	<.main+14023 @05f1fb>: 1c 0e 00 00 00             load.c32 14
	<.main+14028 @05f200>: 1c 09 00 00 00             load.c32 9
	<.main+14033 @05f205>: 1f f3 58 05 00             load.ref <@0558f3> ;"t == 0"
	<.main+14038 @05f20a>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14043 @05f20f>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14048 @05f214>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14052 @05f218>: 04 48 01 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:53: (324 bytes: <@05f21c> - <@05f360>): if (t == 1)
	<.main+14056 @05f21c>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14060 @05f220>: 1c 01 00 00 00             load.c32 1
	<.main+14065 @05f225>: 57                         ceq.i32
	<.main+14066 @05f226>: 06 2f 00 00                jz <.main+14113 @05f255>
	test/lang/stmt.if.ci:54: (39 bytes: <@05f22a> - <@05f251>): raise(raise.debug, 10, "t == 1", t);
	<.main+14070 @05f22a>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14075 @05f22f>: 1c 36 00 00 00             load.c32 54
	<.main+14080 @05f234>: 1c 0e 00 00 00             load.c32 14
	<.main+14085 @05f239>: 1c 0a 00 00 00             load.c32 10
	<.main+14090 @05f23e>: 1f 01 59 05 00             load.ref <@055901> ;"t == 1"
	<.main+14095 @05f243>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14100 @05f248>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14105 @05f24d>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14109 @05f251>: 04 0f 01 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:56: (267 bytes: <@05f255> - <@05f360>): if (t == 2)
	<.main+14113 @05f255>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14117 @05f259>: 1c 02 00 00 00             load.c32 2
	<.main+14122 @05f25e>: 57                         ceq.i32
	<.main+14123 @05f25f>: 06 2f 00 00                jz <.main+14170 @05f28e>
	test/lang/stmt.if.ci:57: (39 bytes: <@05f263> - <@05f28a>): raise(raise.debug, 10, "t == 2", t);
	<.main+14127 @05f263>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14132 @05f268>: 1c 39 00 00 00             load.c32 57
	<.main+14137 @05f26d>: 1c 0e 00 00 00             load.c32 14
	<.main+14142 @05f272>: 1c 0a 00 00 00             load.c32 10
	<.main+14147 @05f277>: 1f 08 59 05 00             load.ref <@055908> ;"t == 2"
	<.main+14152 @05f27c>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14157 @05f281>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14162 @05f286>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14166 @05f28a>: 04 d6 00 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:59: (210 bytes: <@05f28e> - <@05f360>): if (t == 3)
	<.main+14170 @05f28e>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14174 @05f292>: 1c 03 00 00 00             load.c32 3
	<.main+14179 @05f297>: 57                         ceq.i32
	<.main+14180 @05f298>: 06 2f 00 00                jz <.main+14227 @05f2c7>
	test/lang/stmt.if.ci:60: (39 bytes: <@05f29c> - <@05f2c3>): raise(raise.debug, 10, "t == 3", t);
	<.main+14184 @05f29c>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14189 @05f2a1>: 1c 3c 00 00 00             load.c32 60
	<.main+14194 @05f2a6>: 1c 0e 00 00 00             load.c32 14
	<.main+14199 @05f2ab>: 1c 0a 00 00 00             load.c32 10
	<.main+14204 @05f2b0>: 1f 0f 59 05 00             load.ref <@05590f> ;"t == 3"
	<.main+14209 @05f2b5>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14214 @05f2ba>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14219 @05f2bf>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14223 @05f2c3>: 04 9d 00 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:62: (153 bytes: <@05f2c7> - <@05f360>): if (t == 4)
	<.main+14227 @05f2c7>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14231 @05f2cb>: 1c 04 00 00 00             load.c32 4
	<.main+14236 @05f2d0>: 57                         ceq.i32
	<.main+14237 @05f2d1>: 06 2f 00 00                jz <.main+14284 @05f300>
	test/lang/stmt.if.ci:63: (39 bytes: <@05f2d5> - <@05f2fc>): raise(raise.debug, 10, "t == 4", t);
	<.main+14241 @05f2d5>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14246 @05f2da>: 1c 3f 00 00 00             load.c32 63
	<.main+14251 @05f2df>: 1c 0e 00 00 00             load.c32 14
	<.main+14256 @05f2e4>: 1c 0a 00 00 00             load.c32 10
	<.main+14261 @05f2e9>: 1f 16 59 05 00             load.ref <@055916> ;"t == 4"
	<.main+14266 @05f2ee>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14271 @05f2f3>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14276 @05f2f8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14280 @05f2fc>: 04 64 00 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:65: (96 bytes: <@05f300> - <@05f360>): if (t == 5)
	<.main+14284 @05f300>: 20 d0 b8 05                load.m32 <@05b8d0> ;t
	<.main+14288 @05f304>: 1c 05 00 00 00             load.c32 5
	<.main+14293 @05f309>: 57                         ceq.i32
	<.main+14294 @05f30a>: 06 2f 00 00                jz <.main+14341 @05f339>
	test/lang/stmt.if.ci:66: (39 bytes: <@05f30e> - <@05f335>): raise(raise.debug, 10, "t == 5", t);
	<.main+14298 @05f30e>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14303 @05f313>: 1c 42 00 00 00             load.c32 66
	<.main+14308 @05f318>: 1c 0e 00 00 00             load.c32 14
	<.main+14313 @05f31d>: 1c 0a 00 00 00             load.c32 10
	<.main+14318 @05f322>: 1f 1d 59 05 00             load.ref <@05591d> ;"t == 5"
	<.main+14323 @05f327>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14328 @05f32c>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14333 @05f331>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14337 @05f335>: 04 2b 00 00                jmp <.main+14380 @05f360>
	test/lang/stmt.if.ci:69: (39 bytes: <@05f339> - <@05f360>): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+14341 @05f339>: 1f d0 58 05 00             load.ref <@0558d0> ;"test/lang/stmt.if.ci"
	<.main+14346 @05f33e>: 1c 45 00 00 00             load.c32 69
	<.main+14351 @05f343>: 1c 0e 00 00 00             load.c32 14
	<.main+14356 @05f348>: 1c 0a 00 00 00             load.c32 10
	<.main+14361 @05f34d>: 1f 24 59 05 00             load.ref <@055924> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14366 @05f352>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14371 @05f357>: 1f d0 b8 05 00             load.ref <@05b8d0> ;t
	<.main+14376 @05f35c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:3: (47 bytes: <@05f360> - <@05f38f>): for ( ; ; )
	<.main+14380 @05f360>: 04 2b 00 00                jmp <.main+14423 @05f38b>
	test/lang/stmt.for.ci:4: (35 bytes: <@05f364> - <@05f387>): debug("for ( ; ; )");
	<.main+14384 @05f364>: 1f 08 5a 05 00             load.ref <@055a08> ;"test/lang/stmt.for.ci"
	<.main+14389 @05f369>: 1c 04 00 00 00             load.c32 4
	<.main+14394 @05f36e>: 1c 0e 00 00 00             load.c32 14
	<.main+14399 @05f373>: 19                         load.z32
	<.main+14400 @05f374>: 1f 1e 5a 05 00             load.ref <@055a1e> ;"for ( ; ; )"
	<.main+14405 @05f379>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14410 @05f37e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14415 @05f383>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:5: (4 bytes: <@05f387> - <@05f38b>): break;
	<.main+14419 @05f387>: 04 08 00 00                jmp <.main+14427 @05f38f>
	:: (4 bytes: <@05f38b> - <@05f38f>)
	<.main+14423 @05f38b>: 04 d9 ff ff                jmp <.main+14384 @05f364>
	test/lang/stmt.for.ci:8: (59 bytes: <@05f38f> - <@05f3ca>): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+14427 @05f38f>: 19                         load.z32
	<.main+14428 @05f390>: 04 2a 00 00                jmp <.main+14470 @05f3ba>
	test/lang/stmt.for.ci:9: (34 bytes: <@05f394> - <@05f3b6>): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+14432 @05f394>: 1f 08 5a 05 00             load.ref <@055a08> ;"test/lang/stmt.for.ci"
	<.main+14437 @05f399>: 1c 09 00 00 00             load.c32 9
	<.main+14442 @05f39e>: 1c 0e 00 00 00             load.c32 14
	<.main+14447 @05f3a3>: 19                         load.z32
	<.main+14448 @05f3a4>: 1f 2a 5a 05 00             load.ref <@055a2a> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14453 @05f3a9>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14458 @05f3ae>: 0a 18 00 00                load.sp(+24)
	<.main+14462 @05f3b2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:8: (4 bytes: <@05f3b6> - <@05f3ba>): i := i + 1
	<.main+14466 @05f3b6>: 0c 01 00 00                inc.i32(+1)
	test/lang/stmt.for.ci:8: (12 bytes: <@05f3ba> - <@05f3c6>): i < 2
	<.main+14470 @05f3ba>: 10 00                      dup.x32 sp(0)
	<.main+14472 @05f3bc>: 1c 02 00 00 00             load.c32 2
	<.main+14477 @05f3c1>: 58                         clt.i32
	<.main+14478 @05f3c2>: 05 d2 ff ff                jnz <.main+14432 @05f394>
	<.main+14482 @05f3c6>: 09 fc ff ff                inc.sp(-4)
	test/lang/stmt.for.ci:13: (70 bytes: <@05f3ca> - <@05f410>): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+14486 @05f3ca>: 19                         load.z32
	<.main+14487 @05f3cb>: 24 d8 b8 05                store.m32 <@05b8d8> ;forIdx
	<.main+14491 @05f3cf>: 04 33 00 00                jmp <.main+14542 @05f402>
	test/lang/stmt.for.ci:14: (35 bytes: <@05f3d3> - <@05f3f6>): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+14495 @05f3d3>: 1f 08 5a 05 00             load.ref <@055a08> ;"test/lang/stmt.for.ci"
	<.main+14500 @05f3d8>: 1c 0e 00 00 00             load.c32 14
	<.main+14505 @05f3dd>: 1c 0e 00 00 00             load.c32 14
	<.main+14510 @05f3e2>: 19                         load.z32
	<.main+14511 @05f3e3>: 1f 50 5a 05 00             load.ref <@055a50> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14516 @05f3e8>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14521 @05f3ed>: 1f d8 b8 05 00             load.ref <@05b8d8> ;forIdx
	<.main+14526 @05f3f2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:13: (12 bytes: <@05f3f6> - <@05f402>): forIdx := forIdx + 1
	<.main+14530 @05f3f6>: 20 d8 b8 05                load.m32 <@05b8d8> ;forIdx
	<.main+14534 @05f3fa>: 0c 01 00 00                inc.i32(+1)
	<.main+14538 @05f3fe>: 24 d8 b8 05                store.m32 <@05b8d8> ;forIdx
	test/lang/stmt.for.ci:13: (14 bytes: <@05f402> - <@05f410>): forIdx < 2
	<.main+14542 @05f402>: 20 d8 b8 05                load.m32 <@05b8d8> ;forIdx
	<.main+14546 @05f406>: 1c 02 00 00 00             load.c32 2
	<.main+14551 @05f40b>: 58                         clt.i32
	<.main+14552 @05f40c>: 05 c7 ff ff                jnz <.main+14495 @05f3d3>
	test/lang/stmt.for.ci:17: (75 bytes: <@05f410> - <@05f45b>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14556 @05f410>: 19                         load.z32
	<.main+14557 @05f411>: 04 3a 00 00                jmp <.main+14615 @05f44b>
	test/lang/stmt.for.ci:18: (16 bytes: <@05f415> - <@05f425>): if (i < 2)
	<.main+14561 @05f415>: 10 00                      dup.x32 sp(0)
	<.main+14563 @05f417>: 1c 02 00 00 00             load.c32 2
	<.main+14568 @05f41c>: 58                         clt.i32
	<.main+14569 @05f41d>: 06 08 00 00                jz <.main+14577 @05f425>
	test/lang/stmt.for.ci:19: (4 bytes: <@05f421> - <@05f425>): continue;
	<.main+14573 @05f421>: 04 26 00 00                jmp <.main+14611 @05f447>
	test/lang/stmt.for.ci:21: (34 bytes: <@05f425> - <@05f447>): debug("for with continue", i);
	<.main+14577 @05f425>: 1f 08 5a 05 00             load.ref <@055a08> ;"test/lang/stmt.for.ci"
	<.main+14582 @05f42a>: 1c 15 00 00 00             load.c32 21
	<.main+14587 @05f42f>: 1c 0e 00 00 00             load.c32 14
	<.main+14592 @05f434>: 19                         load.z32
	<.main+14593 @05f435>: 1f 7a 5a 05 00             load.ref <@055a7a> ;"for with continue"
	<.main+14598 @05f43a>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14603 @05f43f>: 0a 18 00 00                load.sp(+24)
	<.main+14607 @05f443>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:17: (4 bytes: <@05f447> - <@05f44b>): i := i + 1
	<.main+14611 @05f447>: 0c 01 00 00                inc.i32(+1)
	test/lang/stmt.for.ci:17: (12 bytes: <@05f44b> - <@05f457>): i < 7
	<.main+14615 @05f44b>: 10 00                      dup.x32 sp(0)
	<.main+14617 @05f44d>: 1c 07 00 00 00             load.c32 7
	<.main+14622 @05f452>: 58                         clt.i32
	<.main+14623 @05f453>: 05 c2 ff ff                jnz <.main+14561 @05f415>
	<.main+14627 @05f457>: 09 fc ff ff                inc.sp(-4)
	test/lang/stmt.for.ci:24: (75 bytes: <@05f45b> - <@05f4a6>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14631 @05f45b>: 19                         load.z32
	<.main+14632 @05f45c>: 04 3a 00 00                jmp <.main+14690 @05f496>
	test/lang/stmt.for.ci:25: (16 bytes: <@05f460> - <@05f470>): if (i > 2)
	<.main+14636 @05f460>: 10 00                      dup.x32 sp(0)
	<.main+14638 @05f462>: 1c 02 00 00 00             load.c32 2
	<.main+14643 @05f467>: 59                         cgt.i32
	<.main+14644 @05f468>: 06 08 00 00                jz <.main+14652 @05f470>
	test/lang/stmt.for.ci:26: (4 bytes: <@05f46c> - <@05f470>): break;
	<.main+14648 @05f46c>: 04 36 00 00                jmp <.main+14702 @05f4a2>
	test/lang/stmt.for.ci:28: (34 bytes: <@05f470> - <@05f492>): debug("for with break", i);
	<.main+14652 @05f470>: 1f 08 5a 05 00             load.ref <@055a08> ;"test/lang/stmt.for.ci"
	<.main+14657 @05f475>: 1c 1c 00 00 00             load.c32 28
	<.main+14662 @05f47a>: 1c 0e 00 00 00             load.c32 14
	<.main+14667 @05f47f>: 19                         load.z32
	<.main+14668 @05f480>: 1f 8c 5a 05 00             load.ref <@055a8c> ;"for with break"
	<.main+14673 @05f485>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14678 @05f48a>: 0a 18 00 00                load.sp(+24)
	<.main+14682 @05f48e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/stmt.for.ci:24: (4 bytes: <@05f492> - <@05f496>): i := i + 1
	<.main+14686 @05f492>: 0c 01 00 00                inc.i32(+1)
	test/lang/stmt.for.ci:24: (12 bytes: <@05f496> - <@05f4a2>): i < 7
	<.main+14690 @05f496>: 10 00                      dup.x32 sp(0)
	<.main+14692 @05f498>: 1c 07 00 00 00             load.c32 7
	<.main+14697 @05f49d>: 58                         clt.i32
	<.main+14698 @05f49e>: 05 c2 ff ff                jnz <.main+14636 @05f460>
	<.main+14702 @05f4a2>: 09 fc ff ff                inc.sp(-4)
	<.main+14706 @05f4a6>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 317.32] > .main
[ 317.38]  > float32.sin(x: float32): float32
[ 317.45]  < return
[ 317.92]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 317.96]  < return
[ 317.97]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 318.00]  < return
[ 318.01]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 318.02]  < return
[ 318.03]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.06]  < return
[ 318.07]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.09]  < return
[ 318.10]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.13]  < return
[ 318.16]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 318.17]  < return
[ 318.20]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 318.21]  < return
[ 318.24]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 318.27]  < return
[ 318.28]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.30]  < return
[ 318.31]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.33]  < return
[ 318.34]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 318.39]  < return
[ 318.40]  > float64.sin(x: float64): float64
[ 318.43]  < return
[ 318.44]  > float64.cos(x: float64): float64
[ 318.46]  < return
[ 318.47]  > float64.tan(x: float64): float64
[ 318.50]  < return
[ 318.51]  > float64.log(x: float64): float64
[ 318.53]  < return
[ 318.54]  > float64.exp(x: float64): float64
[ 318.56]  < return
[ 318.57]  > float64.pow(x: float64, y: float64): float64
[ 318.58]  < return
[ 318.59]  > float64.sqrt(x: float64): float64
[ 318.61]  < return
[ 318.62]  > float64.atan2(x: float64, y: float64): float64
[ 318.63]  < return
[ 318.64]  > float32.sin(x: float32): float32
[ 318.66]  < return
[ 318.67]  > float32.cos(x: float32): float32
[ 318.69]  < return
[ 318.69]  > float32.tan(x: float32): float32
[ 318.71]  < return
[ 318.72]  > float32.log(x: float32): float32
[ 318.74]  < return
[ 318.75]  > float32.exp(x: float32): float32
[ 318.78]  < return
[ 318.79]  > float32.pow(x: float32, y: float32): float32
[ 318.84]  < return
[ 318.85]  > float32.sqrt(x: float32): float32
[ 318.87]  < return
[ 318.89]  > float32.atan2(x: float32, y: float32): float32
[ 318.91]  < return
[ 318.92]  > uint32.pop(value: int32): int32
[ 318.93]  < return
[ 318.94]  > uint32.swap(value: int32): int32
[ 318.95]  < return
[ 318.96]  > uint32.bsr(value: int32): int32
[ 318.98]  < return
[ 318.99]  > uint32.bsf(value: int32): int32
[ 319.00]  < return
[ 319.01]  > uint32.hib(value: int32): int32
[ 319.03]  < return
[ 319.04]  > uint32.lob(value: int32): int32
[ 319.05]  < return
[ 319.06]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 319.07]  < return
[ 319.08]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 319.11]  < return
[ 319.12]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 319.13]  < return
[ 319.14]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 319.16]  < return
[ 319.17]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 319.18]  < return
[ 319.19]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 319.21]  < return
[ 319.22]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 319.23]  < return
[ 319.24]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 319.28]  < return
[ 319.29]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 319.31]   > noError(ptr: pointer): void
[ 319.32]   < return
[ 319.34]   > halt(): void
[ 319.35]   < return
[ 319.36]  < return
[ 319.36]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 319.38]  < return
[ 319.39]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 319.40]   > stackOverflow(ptr: pointer): void
[ 319.42]    > stackOverflow(ptr: pointer): void
[ 319.43]     > stackOverflow(ptr: pointer): void
[ 319.45]      > stackOverflow(ptr: pointer): void
[ 319.46]       > stackOverflow(ptr: pointer): void
[ 319.48]        > stackOverflow(ptr: pointer): void
[ 319.49]         > stackOverflow(ptr: pointer): void
[ 319.50]          > stackOverflow(ptr: pointer): void
[ 319.52]           > stackOverflow(ptr: pointer): void
[ 319.53]            > stackOverflow(ptr: pointer): void
[ 319.54]             > stackOverflow(ptr: pointer): void
[ 319.56]              > stackOverflow(ptr: pointer): void
[ 319.57]               > stackOverflow(ptr: pointer): void
[ 319.58]                > stackOverflow(ptr: pointer): void
[ 319.60]                 > stackOverflow(ptr: pointer): void
[ 319.61]                  > stackOverflow(ptr: pointer): void
[ 319.62]                   > stackOverflow(ptr: pointer): void
[ 319.64]                    > stackOverflow(ptr: pointer): void
[ 319.65]                     > stackOverflow(ptr: pointer): void
[ 319.67]                      > stackOverflow(ptr: pointer): void
[ 319.68]                       > stackOverflow(ptr: pointer): void
[ 319.69]                        > stackOverflow(ptr: pointer): void
[ 319.71]                         > stackOverflow(ptr: pointer): void
[ 319.72]                          > stackOverflow(ptr: pointer): void
[ 319.73]                           > stackOverflow(ptr: pointer): void
[ 319.75]                            > stackOverflow(ptr: pointer): void
[ 319.76]                             > stackOverflow(ptr: pointer): void
[ 319.77]                              > stackOverflow(ptr: pointer): void
[ 319.80]                               > stackOverflow(ptr: pointer): void
[ 319.81]                                > stackOverflow(ptr: pointer): void
[ 319.85]                                 > stackOverflow(ptr: pointer): void
[ 319.87]                                  > stackOverflow(ptr: pointer): void
[ 319.89]                                   > stackOverflow(ptr: pointer): void
[ 319.90]                                    > stackOverflow(ptr: pointer): void
[ 319.91]                                     > stackOverflow(ptr: pointer): void
[ 319.93]                                      > stackOverflow(ptr: pointer): void
[ 319.94]                                       > stackOverflow(ptr: pointer): void
[ 319.95]                                        > stackOverflow(ptr: pointer): void
[ 319.97]                                         > stackOverflow(ptr: pointer): void
[ 319.98]                                          > stackOverflow(ptr: pointer): void
[ 320.00]                                           > stackOverflow(ptr: pointer): void
[ 320.01]                                            > stackOverflow(ptr: pointer): void
[ 320.02]                                             > stackOverflow(ptr: pointer): void
[ 320.04]                                              > stackOverflow(ptr: pointer): void
[ 320.05]                                               > stackOverflow(ptr: pointer): void
[ 320.06]                                                > stackOverflow(ptr: pointer): void
[ 320.08]                                                 > stackOverflow(ptr: pointer): void
[ 320.09]                                                  > stackOverflow(ptr: pointer): void
[ 320.11]                                                   > stackOverflow(ptr: pointer): void
[ 320.14]                                                    > stackOverflow(ptr: pointer): void
[ 320.15]                                                     > stackOverflow(ptr: pointer): void
[ 320.17]                                                      > stackOverflow(ptr: pointer): void
[ 320.18]                                                       > stackOverflow(ptr: pointer): void
[ 320.19]                                                        > stackOverflow(ptr: pointer): void
[ 320.21]                                                         > stackOverflow(ptr: pointer): void
[ 320.22]                                                          > stackOverflow(ptr: pointer): void
[ 320.24]                                                           > stackOverflow(ptr: pointer): void
[ 320.25]                                                            > stackOverflow(ptr: pointer): void
[ 320.26]                                                             > stackOverflow(ptr: pointer): void
[ 320.28]                                                              > stackOverflow(ptr: pointer): void
[ 320.29]                                                               > stackOverflow(ptr: pointer): void
[ 320.31]                                                                > stackOverflow(ptr: pointer): void
[ 320.35]                                                                 > stackOverflow(ptr: pointer): void
[ 320.39]                                                                  > stackOverflow(ptr: pointer): void
[ 320.41]                                                                   > stackOverflow(ptr: pointer): void
[ 320.42]                                                                    > stackOverflow(ptr: pointer): void
[ 320.44]                                                                     > stackOverflow(ptr: pointer): void
[ 320.54]                                                                      > stackOverflow(ptr: pointer): void
[ 320.56]                                                                       > stackOverflow(ptr: pointer): void
[ 320.58]                                                                        > stackOverflow(ptr: pointer): void
[ 320.60]                                                                         > stackOverflow(ptr: pointer): void
[ 320.61]                                                                          > stackOverflow(ptr: pointer): void
[ 320.63]                                                                           > stackOverflow(ptr: pointer): void
[ 320.64]                                                                            > stackOverflow(ptr: pointer): void
[ 320.65]                                                                             > stackOverflow(ptr: pointer): void
[ 320.67]                                                                              > stackOverflow(ptr: pointer): void
[ 320.68]                                                                               > stackOverflow(ptr: pointer): void
[ 320.69]                                                                                > stackOverflow(ptr: pointer): void
[ 320.71]                                                                                 > stackOverflow(ptr: pointer): void
[ 320.72]                                                                                  > stackOverflow(ptr: pointer): void
[ 320.74]                                                                                   > stackOverflow(ptr: pointer): void
[ 320.75]                                                                                    > stackOverflow(ptr: pointer): void
[ 320.77]                                                                                     > stackOverflow(ptr: pointer): void
[ 320.78]                                                                                      > stackOverflow(ptr: pointer): void
[ 320.80]                                                                                       > stackOverflow(ptr: pointer): void
[ 320.81]                                                                                        > stackOverflow(ptr: pointer): void
[ 320.82]                                                                                         > stackOverflow(ptr: pointer): void
[ 320.84]                                                                                          > stackOverflow(ptr: pointer): void
[ 320.85]                                                                                           > stackOverflow(ptr: pointer): void
[ 320.86]                                                                                            > stackOverflow(ptr: pointer): void
[ 320.90]                                                                                             > stackOverflow(ptr: pointer): void
[ 320.91]                                                                                              > stackOverflow(ptr: pointer): void
[ 320.92]                                                                                               > stackOverflow(ptr: pointer): void
[ 320.94]                                                                                                > stackOverflow(ptr: pointer): void
[ 320.97]                                                                                                 > stackOverflow(ptr: pointer): void
[ 320.98]                                                                                                  > stackOverflow(ptr: pointer): void
[ 320.99]                                                                                                   > stackOverflow(ptr: pointer): void
[ 321.01]                                                                                                    > stackOverflow(ptr: pointer): void
[ 321.04]                                                                                                     > stackOverflow(ptr: pointer): void
[ 321.05]                                                                                                      > stackOverflow(ptr: pointer): void
[ 321.07]                                                                                                       > stackOverflow(ptr: pointer): void
[ 321.09]                                                                                                        > stackOverflow(ptr: pointer): void
[ 321.11]                                                                                                         > stackOverflow(ptr: pointer): void
[ 321.15]                                                                                                          > stackOverflow(ptr: pointer): void
[ 321.17]                                                                                                           > stackOverflow(ptr: pointer): void
[ 321.18]                                                                                                            > stackOverflow(ptr: pointer): void
[ 321.20]                                                                                                             > stackOverflow(ptr: pointer): void
[ 321.25]                                                                                                              > stackOverflow(ptr: pointer): void
[ 321.27]                                                                                                               > stackOverflow(ptr: pointer): void
[ 321.28]                                                                                                                > stackOverflow(ptr: pointer): void
[ 321.30]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 321.31]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 321.33]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 321.34]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 321.36]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 321.37]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 321.38]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 321.40]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 321.41]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 321.43]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 321.44]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 321.45]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 321.47]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 321.48]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 321.50]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 321.53]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 321.54]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 321.56]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 321.57]                                                                                                                                  < return
[ 321.58]                                                                                                                                 < return
[ 321.60]                                                                                                                                < return
[ 321.62]                                                                                                                               < return
[ 321.62]                                                                                                                              < return
[ 321.63]                                                                                                                             < return
[ 321.64]                                                                                                                            < return
[ 321.65]                                                                                                                           < return
[ 321.65]                                                                                                                          < return
[ 321.66]                                                                                                                         < return
[ 321.67]                                                                                                                        < return
[ 321.68]                                                                                                                       < return
[ 321.68]                                                                                                                      < return
[ 321.69]                                                                                                                     < return
[ 321.70]                                                                                                                    < return
[ 321.70]                                                                                                                   < return
[ 321.71]                                                                                                                  < return
[ 321.72]                                                                                                                 < return
[ 321.72]                                                                                                                < return
[ 321.73]                                                                                                               < return
[ 321.74]                                                                                                              < return
[ 321.74]                                                                                                             < return
[ 321.75]                                                                                                            < return
[ 321.76]                                                                                                           < return
[ 321.76]                                                                                                          < return
[ 321.77]                                                                                                         < return
[ 321.78]                                                                                                        < return
[ 321.79]                                                                                                       < return
[ 321.81]                                                                                                      < return
[ 321.82]                                                                                                     < return
[ 321.82]                                                                                                    < return
[ 321.83]                                                                                                   < return
[ 321.84]                                                                                                  < return
[ 321.85]                                                                                                 < return
[ 321.85]                                                                                                < return
[ 321.86]                                                                                               < return
[ 321.87]                                                                                              < return
[ 321.87]                                                                                             < return
[ 321.88]                                                                                            < return
[ 321.89]                                                                                           < return
[ 321.89]                                                                                          < return
[ 321.92]                                                                                         < return
[ 321.94]                                                                                        < return
[ 321.95]                                                                                       < return
[ 321.96]                                                                                      < return
[ 321.99]                                                                                     < return
[ 321.99]                                                                                    < return
[ 322.01]                                                                                   < return
[ 322.04]                                                                                  < return
[ 322.04]                                                                                 < return
[ 322.05]                                                                                < return
[ 322.06]                                                                               < return
[ 322.06]                                                                              < return
[ 322.07]                                                                             < return
[ 322.08]                                                                            < return
[ 322.10]                                                                           < return
[ 322.11]                                                                          < return
[ 322.13]                                                                         < return
[ 322.13]                                                                        < return
[ 322.14]                                                                       < return
[ 322.15]                                                                      < return
[ 322.15]                                                                     < return
[ 322.16]                                                                    < return
[ 322.17]                                                                   < return
[ 322.17]                                                                  < return
[ 322.18]                                                                 < return
[ 322.19]                                                                < return
[ 322.19]                                                               < return
[ 322.20]                                                              < return
[ 322.21]                                                             < return
[ 322.21]                                                            < return
[ 322.22]                                                           < return
[ 322.23]                                                          < return
[ 322.23]                                                         < return
[ 322.24]                                                        < return
[ 322.25]                                                       < return
[ 322.25]                                                      < return
[ 322.26]                                                     < return
[ 322.27]                                                    < return
[ 322.27]                                                   < return
[ 322.28]                                                  < return
[ 322.29]                                                 < return
[ 322.29]                                                < return
[ 322.30]                                               < return
[ 322.31]                                              < return
[ 322.31]                                             < return
[ 322.32]                                            < return
[ 322.33]                                           < return
[ 322.33]                                          < return
[ 322.34]                                         < return
[ 322.35]                                        < return
[ 322.36]                                       < return
[ 322.36]                                      < return
[ 322.37]                                     < return
[ 322.38]                                    < return
[ 322.38]                                   < return
[ 322.39]                                  < return
[ 322.40]                                 < return
[ 322.40]                                < return
[ 322.41]                               < return
[ 322.42]                              < return
[ 322.42]                             < return
[ 322.43]                            < return
[ 322.44]                           < return
[ 322.44]                          < return
[ 322.45]                         < return
[ 322.46]                        < return
[ 322.46]                       < return
[ 322.47]                      < return
[ 322.48]                     < return
[ 322.48]                    < return
[ 322.49]                   < return
[ 322.50]                  < return
[ 322.50]                 < return
[ 322.51]                < return
[ 322.52]               < return
[ 322.52]              < return
[ 322.53]             < return
[ 322.54]            < return
[ 322.54]           < return
[ 322.55]          < return
[ 322.56]         < return
[ 322.56]        < return
[ 322.57]       < return
[ 322.57]      < return
[ 322.58]     < return
[ 322.59]    < return
[ 322.60]   < return
[ 322.60]  < return
[ 322.61]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 322.62]   > divisionByZero(args: pointer): void
[ 322.64]   < return
[ 322.64]  < return
[ 322.65]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 322.66]   > invalidInstruction(args: pointer): void
[ 322.68]   < return
[ 322.68]  < return
[ 322.69]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 322.70]   > invalidMemoryAccess(args: pointer): void
[ 322.72]   < return
[ 322.72]  < return
[ 322.73]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 322.74]   > abortExecution(args: pointer): void
[ 322.77]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/tryExec.ci:35: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	test/std/tryExec.ci:53: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 322.89]    < return
[ 322.90]   < return
[ 322.90]  < return
[ 323.17]  > object.create(type: typename): pointer
[ 323.19]  < return
[ 323.21]  > object.create(type: typename): pointer
[ 323.23]  < return
[ 323.25]  > funAdd(x: int32, y: int32): int32
[ 323.28]  < return
[ 323.30]  > funAdd(x: int32, y: int32): int32
[ 323.31]  < return
[ 323.33]  > funMul(x: int32, y: int32): int32
[ 323.34]  < return
[ 323.36]  > funMul(x: int32, y: int32): int32
[ 323.38]  < return
[ 323.40]  > fib(n: uint32): uint32
[ 323.44]   > fib(n: uint32): uint32
[ 323.49]    > fib(n: uint32): uint32
[ 323.51]     > fib(n: uint32): uint32
[ 323.53]      > fib(n: uint32): uint32
[ 323.55]       > fib(n: uint32): uint32
[ 323.56]        > fib(n: uint32): uint32
[ 323.58]         > fib(n: uint32): uint32
[ 323.60]          > fib(n: uint32): uint32
[ 323.63]           > fib(n: uint32): uint32
[ 323.64]            > fib(n: uint32): uint32
[ 323.66]             > fib(n: uint32): uint32
[ 323.68]              > fib(n: uint32): uint32
[ 323.69]              < return
[ 323.70]              > fib(n: uint32): uint32
[ 323.71]              < return
[ 323.72]             < return
[ 323.73]             > fib(n: uint32): uint32
[ 323.75]             < return
[ 323.75]            < return
[ 323.76]            > fib(n: uint32): uint32
[ 323.78]             > fib(n: uint32): uint32
[ 323.79]             < return
[ 323.80]             > fib(n: uint32): uint32
[ 323.82]             < return
[ 323.83]            < return
[ 323.83]           < return
[ 323.84]           > fib(n: uint32): uint32
[ 323.86]            > fib(n: uint32): uint32
[ 323.88]             > fib(n: uint32): uint32
[ 323.89]             < return
[ 323.90]             > fib(n: uint32): uint32
[ 323.92]             < return
[ 323.93]            < return
[ 323.93]            > fib(n: uint32): uint32
[ 323.95]            < return
[ 323.96]           < return
[ 323.96]          < return
[ 323.97]          > fib(n: uint32): uint32
[ 323.99]           > fib(n: uint32): uint32
[ 324.00]            > fib(n: uint32): uint32
[ 324.02]             > fib(n: uint32): uint32
[ 324.04]             < return
[ 324.04]             > fib(n: uint32): uint32
[ 324.06]             < return
[ 324.07]            < return
[ 324.08]            > fib(n: uint32): uint32
[ 324.09]            < return
[ 324.10]           < return
[ 324.11]           > fib(n: uint32): uint32
[ 324.12]            > fib(n: uint32): uint32
[ 324.14]            < return
[ 324.15]            > fib(n: uint32): uint32
[ 324.16]            < return
[ 324.17]           < return
[ 324.18]          < return
[ 324.18]         < return
[ 324.19]         > fib(n: uint32): uint32
[ 324.21]          > fib(n: uint32): uint32
[ 324.23]           > fib(n: uint32): uint32
[ 324.24]            > fib(n: uint32): uint32
[ 324.26]             > fib(n: uint32): uint32
[ 324.29]             < return
[ 324.30]             > fib(n: uint32): uint32
[ 324.35]             < return
[ 324.37]            < return
[ 324.37]            > fib(n: uint32): uint32
[ 324.40]            < return
[ 324.43]           < return
[ 324.43]           > fib(n: uint32): uint32
[ 324.45]            > fib(n: uint32): uint32
[ 324.46]            < return
[ 324.47]            > fib(n: uint32): uint32
[ 324.49]            < return
[ 324.50]           < return
[ 324.50]          < return
[ 324.51]          > fib(n: uint32): uint32
[ 324.53]           > fib(n: uint32): uint32
[ 324.55]            > fib(n: uint32): uint32
[ 324.56]            < return
[ 324.57]            > fib(n: uint32): uint32
[ 324.58]            < return
[ 324.59]           < return
[ 324.60]           > fib(n: uint32): uint32
[ 324.61]           < return
[ 324.62]          < return
[ 324.63]         < return
[ 324.64]        < return
[ 324.65]        > fib(n: uint32): uint32
[ 324.66]         > fib(n: uint32): uint32
[ 324.68]          > fib(n: uint32): uint32
[ 324.69]           > fib(n: uint32): uint32
[ 324.71]            > fib(n: uint32): uint32
[ 324.73]             > fib(n: uint32): uint32
[ 324.74]             < return
[ 324.75]             > fib(n: uint32): uint32
[ 324.76]             < return
[ 324.77]            < return
[ 324.78]            > fib(n: uint32): uint32
[ 324.80]            < return
[ 324.80]           < return
[ 324.81]           > fib(n: uint32): uint32
[ 324.83]            > fib(n: uint32): uint32
[ 324.84]            < return
[ 324.85]            > fib(n: uint32): uint32
[ 324.87]            < return
[ 324.88]           < return
[ 324.88]          < return
[ 324.89]          > fib(n: uint32): uint32
[ 324.91]           > fib(n: uint32): uint32
[ 324.92]            > fib(n: uint32): uint32
[ 324.94]            < return
[ 324.95]            > fib(n: uint32): uint32
[ 324.98]            < return
[ 324.99]           < return
[ 325.00]           > fib(n: uint32): uint32
[ 325.01]           < return
[ 325.02]          < return
[ 325.03]         < return
[ 325.06]         > fib(n: uint32): uint32
[ 325.09]          > fib(n: uint32): uint32
[ 325.12]           > fib(n: uint32): uint32
[ 325.14]            > fib(n: uint32): uint32
[ 325.17]            < return
[ 325.19]            > fib(n: uint32): uint32
[ 325.23]            < return
[ 325.24]           < return
[ 325.25]           > fib(n: uint32): uint32
[ 325.29]           < return
[ 325.32]          < return
[ 325.34]          > fib(n: uint32): uint32
[ 325.37]           > fib(n: uint32): uint32
[ 325.39]           < return
[ 325.40]           > fib(n: uint32): uint32
[ 325.43]           < return
[ 325.44]          < return
[ 325.45]         < return
[ 325.46]        < return
[ 325.48]       < return
[ 325.49]       > fib(n: uint32): uint32
[ 325.51]        > fib(n: uint32): uint32
[ 325.53]         > fib(n: uint32): uint32
[ 325.55]          > fib(n: uint32): uint32
[ 325.56]           > fib(n: uint32): uint32
[ 325.58]            > fib(n: uint32): uint32
[ 325.60]             > fib(n: uint32): uint32
[ 325.61]             < return
[ 325.62]             > fib(n: uint32): uint32
[ 325.63]             < return
[ 325.64]            < return
[ 325.65]            > fib(n: uint32): uint32
[ 325.67]            < return
[ 325.67]           < return
[ 325.68]           > fib(n: uint32): uint32
[ 325.70]            > fib(n: uint32): uint32
[ 325.71]            < return
[ 325.72]            > fib(n: uint32): uint32
[ 325.74]            < return
[ 325.75]           < return
[ 325.75]          < return
[ 325.76]          > fib(n: uint32): uint32
[ 325.78]           > fib(n: uint32): uint32
[ 325.80]            > fib(n: uint32): uint32
[ 325.81]            < return
[ 325.82]            > fib(n: uint32): uint32
[ 325.83]            < return
[ 325.84]           < return
[ 325.85]           > fib(n: uint32): uint32
[ 325.86]           < return
[ 325.87]          < return
[ 325.88]         < return
[ 325.89]         > fib(n: uint32): uint32
[ 325.90]          > fib(n: uint32): uint32
[ 325.92]           > fib(n: uint32): uint32
[ 325.94]            > fib(n: uint32): uint32
[ 325.95]            < return
[ 325.96]            > fib(n: uint32): uint32
[ 325.98]            < return
[ 325.99]           < return
[ 325.99]           > fib(n: uint32): uint32
[ 326.01]           < return
[ 326.02]          < return
[ 326.02]          > fib(n: uint32): uint32
[ 326.04]           > fib(n: uint32): uint32
[ 326.06]           < return
[ 326.06]           > fib(n: uint32): uint32
[ 326.08]           < return
[ 326.09]          < return
[ 326.10]         < return
[ 326.10]        < return
[ 326.11]        > fib(n: uint32): uint32
[ 326.15]         > fib(n: uint32): uint32
[ 326.18]          > fib(n: uint32): uint32
[ 326.19]           > fib(n: uint32): uint32
[ 326.21]            > fib(n: uint32): uint32
[ 326.23]            < return
[ 326.23]            > fib(n: uint32): uint32
[ 326.26]            < return
[ 326.27]           < return
[ 326.28]           > fib(n: uint32): uint32
[ 326.29]           < return
[ 326.30]          < return
[ 326.31]          > fib(n: uint32): uint32
[ 326.33]           > fib(n: uint32): uint32
[ 326.34]           < return
[ 326.35]           > fib(n: uint32): uint32
[ 326.36]           < return
[ 326.37]          < return
[ 326.38]         < return
[ 326.39]         > fib(n: uint32): uint32
[ 326.40]          > fib(n: uint32): uint32
[ 326.42]           > fib(n: uint32): uint32
[ 326.44]           < return
[ 326.44]           > fib(n: uint32): uint32
[ 326.46]           < return
[ 326.47]          < return
[ 326.48]          > fib(n: uint32): uint32
[ 326.49]          < return
[ 326.50]         < return
[ 326.51]        < return
[ 326.51]       < return
[ 326.52]      < return
[ 326.53]      > fib(n: uint32): uint32
[ 326.55]       > fib(n: uint32): uint32
[ 326.56]        > fib(n: uint32): uint32
[ 326.58]         > fib(n: uint32): uint32
[ 326.60]          > fib(n: uint32): uint32
[ 326.61]           > fib(n: uint32): uint32
[ 326.63]            > fib(n: uint32): uint32
[ 326.64]             > fib(n: uint32): uint32
[ 326.66]             < return
[ 326.67]             > fib(n: uint32): uint32
[ 326.68]             < return
[ 326.69]            < return
[ 326.70]            > fib(n: uint32): uint32
[ 326.71]            < return
[ 326.72]           < return
[ 326.73]           > fib(n: uint32): uint32
[ 326.75]            > fib(n: uint32): uint32
[ 326.76]            < return
[ 326.77]            > fib(n: uint32): uint32
[ 326.79]            < return
[ 326.79]           < return
[ 326.80]          < return
[ 326.81]          > fib(n: uint32): uint32
[ 326.83]           > fib(n: uint32): uint32
[ 326.84]            > fib(n: uint32): uint32
[ 326.86]            < return
[ 326.87]            > fib(n: uint32): uint32
[ 326.88]            < return
[ 326.89]           < return
[ 326.90]           > fib(n: uint32): uint32
[ 326.92]           < return
[ 326.92]          < return
[ 326.93]         < return
[ 326.94]         > fib(n: uint32): uint32
[ 326.96]          > fib(n: uint32): uint32
[ 326.97]           > fib(n: uint32): uint32
[ 326.99]            > fib(n: uint32): uint32
[ 327.00]            < return
[ 327.01]            > fib(n: uint32): uint32
[ 327.03]            < return
[ 327.04]           < return
[ 327.04]           > fib(n: uint32): uint32
[ 327.06]           < return
[ 327.07]          < return
[ 327.07]          > fib(n: uint32): uint32
[ 327.09]           > fib(n: uint32): uint32
[ 327.11]           < return
[ 327.12]           > fib(n: uint32): uint32
[ 327.13]           < return
[ 327.14]          < return
[ 327.15]         < return
[ 327.15]        < return
[ 327.16]        > fib(n: uint32): uint32
[ 327.18]         > fib(n: uint32): uint32
[ 327.21]          > fib(n: uint32): uint32
[ 327.24]           > fib(n: uint32): uint32
[ 327.26]            > fib(n: uint32): uint32
[ 327.28]            < return
[ 327.29]            > fib(n: uint32): uint32
[ 327.31]            < return
[ 327.33]           < return
[ 327.34]           > fib(n: uint32): uint32
[ 327.36]           < return
[ 327.37]          < return
[ 327.38]          > fib(n: uint32): uint32
[ 327.39]           > fib(n: uint32): uint32
[ 327.41]           < return
[ 327.42]           > fib(n: uint32): uint32
[ 327.43]           < return
[ 327.44]          < return
[ 327.44]         < return
[ 327.45]         > fib(n: uint32): uint32
[ 327.47]          > fib(n: uint32): uint32
[ 327.49]           > fib(n: uint32): uint32
[ 327.50]           < return
[ 327.51]           > fib(n: uint32): uint32
[ 327.52]           < return
[ 327.53]          < return
[ 327.54]          > fib(n: uint32): uint32
[ 327.56]          < return
[ 327.56]         < return
[ 327.57]        < return
[ 327.58]       < return
[ 327.59]       > fib(n: uint32): uint32
[ 327.60]        > fib(n: uint32): uint32
[ 327.62]         > fib(n: uint32): uint32
[ 327.64]          > fib(n: uint32): uint32
[ 327.65]           > fib(n: uint32): uint32
[ 327.67]            > fib(n: uint32): uint32
[ 327.68]            < return
[ 327.69]            > fib(n: uint32): uint32
[ 327.71]            < return
[ 327.72]           < return
[ 327.73]           > fib(n: uint32): uint32
[ 327.74]           < return
[ 327.75]          < return
[ 327.76]          > fib(n: uint32): uint32
[ 327.77]           > fib(n: uint32): uint32
[ 327.79]           < return
[ 327.80]           > fib(n: uint32): uint32
[ 327.81]           < return
[ 327.82]          < return
[ 327.83]         < return
[ 327.83]         > fib(n: uint32): uint32
[ 327.85]          > fib(n: uint32): uint32
[ 327.87]           > fib(n: uint32): uint32
[ 327.88]           < return
[ 327.89]           > fib(n: uint32): uint32
[ 327.90]           < return
[ 327.91]          < return
[ 327.92]          > fib(n: uint32): uint32
[ 327.94]          < return
[ 327.94]         < return
[ 327.95]        < return
[ 327.96]        > fib(n: uint32): uint32
[ 327.98]         > fib(n: uint32): uint32
[ 327.99]          > fib(n: uint32): uint32
[ 328.01]           > fib(n: uint32): uint32
[ 328.02]           < return
[ 328.03]           > fib(n: uint32): uint32
[ 328.05]           < return
[ 328.09]          < return
[ 328.10]          > fib(n: uint32): uint32
[ 328.13]          < return
[ 328.15]         < return
[ 328.16]         > fib(n: uint32): uint32
[ 328.20]          > fib(n: uint32): uint32
[ 328.24]          < return
[ 328.25]          > fib(n: uint32): uint32
[ 328.27]          < return
[ 328.28]         < return
[ 328.29]        < return
[ 328.31]       < return
[ 328.34]      < return
[ 328.35]     < return
[ 328.36]     > fib(n: uint32): uint32
[ 328.38]      > fib(n: uint32): uint32
[ 328.41]       > fib(n: uint32): uint32
[ 328.48]        > fib(n: uint32): uint32
[ 328.50]         > fib(n: uint32): uint32
[ 328.52]          > fib(n: uint32): uint32
[ 328.54]           > fib(n: uint32): uint32
[ 328.56]            > fib(n: uint32): uint32
[ 328.58]             > fib(n: uint32): uint32
[ 328.60]             < return
[ 328.61]             > fib(n: uint32): uint32
[ 328.63]             < return
[ 328.64]            < return
[ 328.65]            > fib(n: uint32): uint32
[ 328.68]            < return
[ 328.69]           < return
[ 328.70]           > fib(n: uint32): uint32
[ 328.72]            > fib(n: uint32): uint32
[ 328.73]            < return
[ 328.74]            > fib(n: uint32): uint32
[ 328.76]            < return
[ 328.77]           < return
[ 328.77]          < return
[ 328.78]          > fib(n: uint32): uint32
[ 328.80]           > fib(n: uint32): uint32
[ 328.82]            > fib(n: uint32): uint32
[ 328.83]            < return
[ 328.84]            > fib(n: uint32): uint32
[ 328.86]            < return
[ 328.87]           < return
[ 328.88]           > fib(n: uint32): uint32
[ 328.91]           < return
[ 328.94]          < return
[ 328.94]         < return
[ 328.95]         > fib(n: uint32): uint32
[ 328.97]          > fib(n: uint32): uint32
[ 328.99]           > fib(n: uint32): uint32
[ 329.01]            > fib(n: uint32): uint32
[ 329.03]            < return
[ 329.04]            > fib(n: uint32): uint32
[ 329.06]            < return
[ 329.07]           < return
[ 329.08]           > fib(n: uint32): uint32
[ 329.10]           < return
[ 329.11]          < return
[ 329.12]          > fib(n: uint32): uint32
[ 329.14]           > fib(n: uint32): uint32
[ 329.15]           < return
[ 329.16]           > fib(n: uint32): uint32
[ 329.18]           < return
[ 329.19]          < return
[ 329.19]         < return
[ 329.20]        < return
[ 329.21]        > fib(n: uint32): uint32
[ 329.23]         > fib(n: uint32): uint32
[ 329.28]          > fib(n: uint32): uint32
[ 329.29]           > fib(n: uint32): uint32
[ 329.34]            > fib(n: uint32): uint32
[ 329.36]            < return
[ 329.37]            > fib(n: uint32): uint32
[ 329.39]            < return
[ 329.39]           < return
[ 329.40]           > fib(n: uint32): uint32
[ 329.46]           < return
[ 329.47]          < return
[ 329.48]          > fib(n: uint32): uint32
[ 329.49]           > fib(n: uint32): uint32
[ 329.51]           < return
[ 329.52]           > fib(n: uint32): uint32
[ 329.54]           < return
[ 329.55]          < return
[ 329.55]         < return
[ 329.56]         > fib(n: uint32): uint32
[ 329.58]          > fib(n: uint32): uint32
[ 329.60]           > fib(n: uint32): uint32
[ 329.61]           < return
[ 329.62]           > fib(n: uint32): uint32
[ 329.64]           < return
[ 329.65]          < return
[ 329.66]          > fib(n: uint32): uint32
[ 329.67]          < return
[ 329.68]         < return
[ 329.69]        < return
[ 329.70]       < return
[ 329.71]       > fib(n: uint32): uint32
[ 329.72]        > fib(n: uint32): uint32
[ 329.74]         > fib(n: uint32): uint32
[ 329.76]          > fib(n: uint32): uint32
[ 329.78]           > fib(n: uint32): uint32
[ 329.79]            > fib(n: uint32): uint32
[ 329.81]            < return
[ 329.82]            > fib(n: uint32): uint32
[ 329.83]            < return
[ 329.84]           < return
[ 329.85]           > fib(n: uint32): uint32
[ 329.89]           < return
[ 329.90]          < return
[ 329.92]          > fib(n: uint32): uint32
[ 329.95]           > fib(n: uint32): uint32
[ 329.96]           < return
[ 329.98]           > fib(n: uint32): uint32
[ 330.07]           < return
[ 330.08]          < return
[ 330.09]         < return
[ 330.10]         > fib(n: uint32): uint32
[ 330.12]          > fib(n: uint32): uint32
[ 330.13]           > fib(n: uint32): uint32
[ 330.15]           < return
[ 330.16]           > fib(n: uint32): uint32
[ 330.18]           < return
[ 330.19]          < return
[ 330.19]          > fib(n: uint32): uint32
[ 330.21]          < return
[ 330.22]         < return
[ 330.23]        < return
[ 330.24]        > fib(n: uint32): uint32
[ 330.26]         > fib(n: uint32): uint32
[ 330.28]          > fib(n: uint32): uint32
[ 330.29]           > fib(n: uint32): uint32
[ 330.34]           < return
[ 330.36]           > fib(n: uint32): uint32
[ 330.50]           < return
[ 330.51]          < return
[ 330.52]          > fib(n: uint32): uint32
[ 330.54]          < return
[ 330.55]         < return
[ 330.56]         > fib(n: uint32): uint32
[ 330.57]          > fib(n: uint32): uint32
[ 330.59]          < return
[ 330.60]          > fib(n: uint32): uint32
[ 330.63]          < return
[ 330.65]         < return
[ 330.68]        < return
[ 330.70]       < return
[ 330.71]      < return
[ 330.72]      > fib(n: uint32): uint32
[ 330.74]       > fib(n: uint32): uint32
[ 330.76]        > fib(n: uint32): uint32
[ 330.81]         > fib(n: uint32): uint32
[ 330.85]          > fib(n: uint32): uint32
[ 330.88]           > fib(n: uint32): uint32
[ 330.90]            > fib(n: uint32): uint32
[ 330.94]            < return
[ 330.96]            > fib(n: uint32): uint32
[ 330.97]            < return
[ 330.98]           < return
[ 331.01]           > fib(n: uint32): uint32
[ 331.02]           < return
[ 331.03]          < return
[ 331.04]          > fib(n: uint32): uint32
[ 331.06]           > fib(n: uint32): uint32
[ 331.08]           < return
[ 331.09]           > fib(n: uint32): uint32
[ 331.11]           < return
[ 331.11]          < return
[ 331.12]         < return
[ 331.13]         > fib(n: uint32): uint32
[ 331.15]          > fib(n: uint32): uint32
[ 331.17]           > fib(n: uint32): uint32
[ 331.18]           < return
[ 331.19]           > fib(n: uint32): uint32
[ 331.21]           < return
[ 331.22]          < return
[ 331.23]          > fib(n: uint32): uint32
[ 331.24]          < return
[ 331.25]         < return
[ 331.26]        < return
[ 331.29]        > fib(n: uint32): uint32
[ 331.32]         > fib(n: uint32): uint32
[ 331.36]          > fib(n: uint32): uint32
[ 331.37]           > fib(n: uint32): uint32
[ 331.39]           < return
[ 331.40]           > fib(n: uint32): uint32
[ 331.43]           < return
[ 331.46]          < return
[ 331.47]          > fib(n: uint32): uint32
[ 331.48]          < return
[ 331.49]         < return
[ 331.50]         > fib(n: uint32): uint32
[ 331.52]          > fib(n: uint32): uint32
[ 331.54]          < return
[ 331.55]          > fib(n: uint32): uint32
[ 331.56]          < return
[ 331.57]         < return
[ 331.58]        < return
[ 331.62]       < return
[ 331.62]       > fib(n: uint32): uint32
[ 331.66]        > fib(n: uint32): uint32
[ 331.68]         > fib(n: uint32): uint32
[ 331.70]          > fib(n: uint32): uint32
[ 331.72]           > fib(n: uint32): uint32
[ 331.75]           < return
[ 331.76]           > fib(n: uint32): uint32
[ 331.78]           < return
[ 331.79]          < return
[ 331.80]          > fib(n: uint32): uint32
[ 331.81]          < return
[ 331.82]         < return
[ 331.83]         > fib(n: uint32): uint32
[ 331.85]          > fib(n: uint32): uint32
[ 331.87]          < return
[ 331.88]          > fib(n: uint32): uint32
[ 331.89]          < return
[ 331.90]         < return
[ 331.91]        < return
[ 331.92]        > fib(n: uint32): uint32
[ 331.94]         > fib(n: uint32): uint32
[ 331.95]          > fib(n: uint32): uint32
[ 331.97]          < return
[ 331.98]          > fib(n: uint32): uint32
[ 332.00]          < return
[ 332.00]         < return
[ 332.01]         > fib(n: uint32): uint32
[ 332.03]         < return
[ 332.04]        < return
[ 332.05]       < return
[ 332.06]      < return
[ 332.06]     < return
[ 332.09]    < return
[ 332.10]    > fib(n: uint32): uint32
[ 332.14]     > fib(n: uint32): uint32
[ 332.16]      > fib(n: uint32): uint32
[ 332.18]       > fib(n: uint32): uint32
[ 332.21]        > fib(n: uint32): uint32
[ 332.23]         > fib(n: uint32): uint32
[ 332.25]          > fib(n: uint32): uint32
[ 332.27]           > fib(n: uint32): uint32
[ 332.29]            > fib(n: uint32): uint32
[ 332.30]             > fib(n: uint32): uint32
[ 332.35]             < return
[ 332.36]             > fib(n: uint32): uint32
[ 332.37]             < return
[ 332.39]            < return
[ 332.40]            > fib(n: uint32): uint32
[ 332.47]            < return
[ 332.48]           < return
[ 332.49]           > fib(n: uint32): uint32
[ 332.51]            > fib(n: uint32): uint32
[ 332.52]            < return
[ 332.54]            > fib(n: uint32): uint32
[ 332.55]            < return
[ 332.56]           < return
[ 332.58]          < return
[ 332.59]          > fib(n: uint32): uint32
[ 332.61]           > fib(n: uint32): uint32
[ 332.63]            > fib(n: uint32): uint32
[ 332.64]            < return
[ 332.65]            > fib(n: uint32): uint32
[ 332.67]            < return
[ 332.68]           < return
[ 332.69]           > fib(n: uint32): uint32
[ 332.70]           < return
[ 332.71]          < return
[ 332.72]         < return
[ 332.73]         > fib(n: uint32): uint32
[ 332.75]          > fib(n: uint32): uint32
[ 332.76]           > fib(n: uint32): uint32
[ 332.79]            > fib(n: uint32): uint32
[ 332.80]            < return
[ 332.81]            > fib(n: uint32): uint32
[ 332.83]            < return
[ 332.84]           < return
[ 332.85]           > fib(n: uint32): uint32
[ 332.86]           < return
[ 332.87]          < return
[ 332.88]          > fib(n: uint32): uint32
[ 332.90]           > fib(n: uint32): uint32
[ 332.91]           < return
[ 332.92]           > fib(n: uint32): uint32
[ 332.94]           < return
[ 332.95]          < return
[ 332.96]         < return
[ 332.96]        < return
[ 332.97]        > fib(n: uint32): uint32
[ 332.99]         > fib(n: uint32): uint32
[ 333.01]          > fib(n: uint32): uint32
[ 333.02]           > fib(n: uint32): uint32
[ 333.04]            > fib(n: uint32): uint32
[ 333.06]            < return
[ 333.07]            > fib(n: uint32): uint32
[ 333.08]            < return
[ 333.09]           < return
[ 333.10]           > fib(n: uint32): uint32
[ 333.13]           < return
[ 333.14]          < return
[ 333.15]          > fib(n: uint32): uint32
[ 333.16]           > fib(n: uint32): uint32
[ 333.18]           < return
[ 333.19]           > fib(n: uint32): uint32
[ 333.20]           < return
[ 333.21]          < return
[ 333.22]         < return
[ 333.23]         > fib(n: uint32): uint32
[ 333.26]          > fib(n: uint32): uint32
[ 333.28]           > fib(n: uint32): uint32
[ 333.30]           < return
[ 333.32]           > fib(n: uint32): uint32
[ 333.34]           < return
[ 333.35]          < return
[ 333.36]          > fib(n: uint32): uint32
[ 333.38]          < return
[ 333.39]         < return
[ 333.40]        < return
[ 333.42]       < return
[ 333.43]       > fib(n: uint32): uint32
[ 333.45]        > fib(n: uint32): uint32
[ 333.47]         > fib(n: uint32): uint32
[ 333.49]          > fib(n: uint32): uint32
[ 333.51]           > fib(n: uint32): uint32
[ 333.56]            > fib(n: uint32): uint32
[ 333.58]            < return
[ 333.60]            > fib(n: uint32): uint32
[ 333.62]            < return
[ 333.63]           < return
[ 333.65]           > fib(n: uint32): uint32
[ 333.70]           < return
[ 333.71]          < return
[ 333.72]          > fib(n: uint32): uint32
[ 333.78]           > fib(n: uint32): uint32
[ 333.80]           < return
[ 333.81]           > fib(n: uint32): uint32
[ 333.86]           < return
[ 333.88]          < return
[ 333.89]         < return
[ 333.90]         > fib(n: uint32): uint32
[ 333.94]          > fib(n: uint32): uint32
[ 333.98]           > fib(n: uint32): uint32
[ 334.02]           < return
[ 334.04]           > fib(n: uint32): uint32
[ 334.05]           < return
[ 334.06]          < return
[ 334.09]          > fib(n: uint32): uint32
[ 334.10]          < return
[ 334.13]         < return
[ 334.16]        < return
[ 334.18]        > fib(n: uint32): uint32
[ 334.20]         > fib(n: uint32): uint32
[ 334.25]          > fib(n: uint32): uint32
[ 334.28]           > fib(n: uint32): uint32
[ 334.30]           < return
[ 334.31]           > fib(n: uint32): uint32
[ 334.33]           < return
[ 334.35]          < return
[ 334.36]          > fib(n: uint32): uint32
[ 334.40]          < return
[ 334.42]         < return
[ 334.44]         > fib(n: uint32): uint32
[ 334.47]          > fib(n: uint32): uint32
[ 334.49]          < return
[ 334.50]          > fib(n: uint32): uint32
[ 334.51]          < return
[ 334.52]         < return
[ 334.53]        < return
[ 334.54]       < return
[ 334.55]      < return
[ 334.56]      > fib(n: uint32): uint32
[ 334.57]       > fib(n: uint32): uint32
[ 334.59]        > fib(n: uint32): uint32
[ 334.61]         > fib(n: uint32): uint32
[ 334.64]          > fib(n: uint32): uint32
[ 334.66]           > fib(n: uint32): uint32
[ 334.67]            > fib(n: uint32): uint32
[ 334.69]            < return
[ 334.69]            > fib(n: uint32): uint32
[ 334.71]            < return
[ 334.72]           < return
[ 334.73]           > fib(n: uint32): uint32
[ 334.74]           < return
[ 334.75]          < return
[ 334.78]          > fib(n: uint32): uint32
[ 334.81]           > fib(n: uint32): uint32
[ 334.84]           < return
[ 334.85]           > fib(n: uint32): uint32
[ 334.89]           < return
[ 334.90]          < return
[ 334.91]         < return
[ 334.92]         > fib(n: uint32): uint32
[ 334.94]          > fib(n: uint32): uint32
[ 334.96]           > fib(n: uint32): uint32
[ 334.97]           < return
[ 334.98]           > fib(n: uint32): uint32
[ 335.00]           < return
[ 335.01]          < return
[ 335.02]          > fib(n: uint32): uint32
[ 335.03]          < return
[ 335.06]         < return
[ 335.08]        < return
[ 335.09]        > fib(n: uint32): uint32
[ 335.11]         > fib(n: uint32): uint32
[ 335.14]          > fib(n: uint32): uint32
[ 335.16]           > fib(n: uint32): uint32
[ 335.18]           < return
[ 335.19]           > fib(n: uint32): uint32
[ 335.20]           < return
[ 335.22]          < return
[ 335.23]          > fib(n: uint32): uint32
[ 335.25]          < return
[ 335.26]         < return
[ 335.26]         > fib(n: uint32): uint32
[ 335.28]          > fib(n: uint32): uint32
[ 335.30]          < return
[ 335.31]          > fib(n: uint32): uint32
[ 335.32]          < return
[ 335.33]         < return
[ 335.34]        < return
[ 335.35]       < return
[ 335.35]       > fib(n: uint32): uint32
[ 335.37]        > fib(n: uint32): uint32
[ 335.38]         > fib(n: uint32): uint32
[ 335.40]          > fib(n: uint32): uint32
[ 335.42]           > fib(n: uint32): uint32
[ 335.43]           < return
[ 335.44]           > fib(n: uint32): uint32
[ 335.46]           < return
[ 335.46]          < return
[ 335.47]          > fib(n: uint32): uint32
[ 335.49]          < return
[ 335.50]         < return
[ 335.50]         > fib(n: uint32): uint32
[ 335.52]          > fib(n: uint32): uint32
[ 335.54]          < return
[ 335.55]          > fib(n: uint32): uint32
[ 335.56]          < return
[ 335.57]         < return
[ 335.57]        < return
[ 335.58]        > fib(n: uint32): uint32
[ 335.60]         > fib(n: uint32): uint32
[ 335.62]          > fib(n: uint32): uint32
[ 335.63]          < return
[ 335.64]          > fib(n: uint32): uint32
[ 335.65]          < return
[ 335.66]         < return
[ 335.67]         > fib(n: uint32): uint32
[ 335.69]         < return
[ 335.70]        < return
[ 335.71]       < return
[ 335.72]      < return
[ 335.73]     < return
[ 335.74]     > fib(n: uint32): uint32
[ 335.75]      > fib(n: uint32): uint32
[ 335.77]       > fib(n: uint32): uint32
[ 335.79]        > fib(n: uint32): uint32
[ 335.80]         > fib(n: uint32): uint32
[ 335.82]          > fib(n: uint32): uint32
[ 335.83]           > fib(n: uint32): uint32
[ 335.85]            > fib(n: uint32): uint32
[ 335.87]            < return
[ 335.88]            > fib(n: uint32): uint32
[ 335.89]            < return
[ 335.90]           < return
[ 335.91]           > fib(n: uint32): uint32
[ 335.92]           < return
[ 335.93]          < return
[ 335.94]          > fib(n: uint32): uint32
[ 335.96]           > fib(n: uint32): uint32
[ 335.97]           < return
[ 335.98]           > fib(n: uint32): uint32
[ 336.00]           < return
[ 336.00]          < return
[ 336.01]         < return
[ 336.02]         > fib(n: uint32): uint32
[ 336.04]          > fib(n: uint32): uint32
[ 336.06]           > fib(n: uint32): uint32
[ 336.07]           < return
[ 336.08]           > fib(n: uint32): uint32
[ 336.10]           < return
[ 336.10]          < return
[ 336.11]          > fib(n: uint32): uint32
[ 336.13]          < return
[ 336.13]         < return
[ 336.14]        < return
[ 336.15]        > fib(n: uint32): uint32
[ 336.17]         > fib(n: uint32): uint32
[ 336.18]          > fib(n: uint32): uint32
[ 336.20]           > fib(n: uint32): uint32
[ 336.21]           < return
[ 336.23]           > fib(n: uint32): uint32
[ 336.25]           < return
[ 336.26]          < return
[ 336.26]          > fib(n: uint32): uint32
[ 336.28]          < return
[ 336.29]         < return
[ 336.30]         > fib(n: uint32): uint32
[ 336.32]          > fib(n: uint32): uint32
[ 336.36]          < return
[ 336.49]          > fib(n: uint32): uint32
[ 336.52]          < return
[ 336.53]         < return
[ 336.53]        < return
[ 336.54]       < return
[ 336.55]       > fib(n: uint32): uint32
[ 336.57]        > fib(n: uint32): uint32
[ 336.58]         > fib(n: uint32): uint32
[ 336.61]          > fib(n: uint32): uint32
[ 336.62]           > fib(n: uint32): uint32
[ 336.64]           < return
[ 336.66]           > fib(n: uint32): uint32
[ 336.68]           < return
[ 336.69]          < return
[ 336.70]          > fib(n: uint32): uint32
[ 336.71]          < return
[ 336.72]         < return
[ 336.73]         > fib(n: uint32): uint32
[ 336.75]          > fib(n: uint32): uint32
[ 336.76]          < return
[ 336.77]          > fib(n: uint32): uint32
[ 336.79]          < return
[ 336.79]         < return
[ 336.80]        < return
[ 336.81]        > fib(n: uint32): uint32
[ 336.83]         > fib(n: uint32): uint32
[ 336.84]          > fib(n: uint32): uint32
[ 336.86]          < return
[ 336.87]          > fib(n: uint32): uint32
[ 336.88]          < return
[ 336.89]         < return
[ 336.90]         > fib(n: uint32): uint32
[ 336.91]         < return
[ 336.92]        < return
[ 336.93]       < return
[ 336.94]      < return
[ 336.94]      > fib(n: uint32): uint32
[ 336.96]       > fib(n: uint32): uint32
[ 336.98]        > fib(n: uint32): uint32
[ 336.99]         > fib(n: uint32): uint32
[ 337.01]          > fib(n: uint32): uint32
[ 337.03]           > fib(n: uint32): uint32
[ 337.04]           < return
[ 337.05]           > fib(n: uint32): uint32
[ 337.06]           < return
[ 337.07]          < return
[ 337.08]          > fib(n: uint32): uint32
[ 337.10]          < return
[ 337.10]         < return
[ 337.11]         > fib(n: uint32): uint32
[ 337.13]          > fib(n: uint32): uint32
[ 337.15]          < return
[ 337.16]          > fib(n: uint32): uint32
[ 337.17]          < return
[ 337.18]         < return
[ 337.19]        < return
[ 337.19]        > fib(n: uint32): uint32
[ 337.27]         > fib(n: uint32): uint32
[ 337.29]          > fib(n: uint32): uint32
[ 337.32]          < return
[ 337.33]          > fib(n: uint32): uint32
[ 337.34]          < return
[ 337.35]         < return
[ 337.36]         > fib(n: uint32): uint32
[ 337.38]         < return
[ 337.39]        < return
[ 337.41]       < return
[ 337.42]       > fib(n: uint32): uint32
[ 337.43]        > fib(n: uint32): uint32
[ 337.45]         > fib(n: uint32): uint32
[ 337.47]          > fib(n: uint32): uint32
[ 337.48]          < return
[ 337.49]          > fib(n: uint32): uint32
[ 337.50]          < return
[ 337.51]         < return
[ 337.52]         > fib(n: uint32): uint32
[ 337.54]         < return
[ 337.55]        < return
[ 337.56]        > fib(n: uint32): uint32
[ 337.60]         > fib(n: uint32): uint32
[ 337.63]         < return
[ 337.64]         > fib(n: uint32): uint32
[ 337.65]         < return
[ 337.66]        < return
[ 337.67]       < return
[ 337.68]      < return
[ 337.70]     < return
[ 337.71]    < return
[ 337.72]   < return
[ 337.73]   > fib(n: uint32): uint32
[ 337.74]    > fib(n: uint32): uint32
[ 337.76]     > fib(n: uint32): uint32
[ 337.79]      > fib(n: uint32): uint32
[ 337.81]       > fib(n: uint32): uint32
[ 337.83]        > fib(n: uint32): uint32
[ 337.84]         > fib(n: uint32): uint32
[ 337.86]          > fib(n: uint32): uint32
[ 337.88]           > fib(n: uint32): uint32
[ 337.89]            > fib(n: uint32): uint32
[ 337.91]             > fib(n: uint32): uint32
[ 337.92]             < return
[ 337.93]             > fib(n: uint32): uint32
[ 337.95]             < return
[ 337.95]            < return
[ 337.96]            > fib(n: uint32): uint32
[ 337.98]            < return
[ 337.99]           < return
[ 338.00]           > fib(n: uint32): uint32
[ 338.01]            > fib(n: uint32): uint32
[ 338.03]            < return
[ 338.04]            > fib(n: uint32): uint32
[ 338.05]            < return
[ 338.06]           < return
[ 338.06]          < return
[ 338.07]          > fib(n: uint32): uint32
[ 338.09]           > fib(n: uint32): uint32
[ 338.11]            > fib(n: uint32): uint32
[ 338.12]            < return
[ 338.13]            > fib(n: uint32): uint32
[ 338.14]            < return
[ 338.15]           < return
[ 338.16]           > fib(n: uint32): uint32
[ 338.18]           < return
[ 338.18]          < return
[ 338.19]         < return
[ 338.20]         > fib(n: uint32): uint32
[ 338.21]          > fib(n: uint32): uint32
[ 338.23]           > fib(n: uint32): uint32
[ 338.25]            > fib(n: uint32): uint32
[ 338.26]            < return
[ 338.27]            > fib(n: uint32): uint32
[ 338.29]            < return
[ 338.29]           < return
[ 338.30]           > fib(n: uint32): uint32
[ 338.32]           < return
[ 338.32]          < return
[ 338.33]          > fib(n: uint32): uint32
[ 338.35]           > fib(n: uint32): uint32
[ 338.36]           < return
[ 338.37]           > fib(n: uint32): uint32
[ 338.39]           < return
[ 338.40]          < return
[ 338.40]         < return
[ 338.41]        < return
[ 338.42]        > fib(n: uint32): uint32
[ 338.44]         > fib(n: uint32): uint32
[ 338.45]          > fib(n: uint32): uint32
[ 338.47]           > fib(n: uint32): uint32
[ 338.50]            > fib(n: uint32): uint32
[ 338.52]            < return
[ 338.53]            > fib(n: uint32): uint32
[ 338.54]            < return
[ 338.55]           < return
[ 338.56]           > fib(n: uint32): uint32
[ 338.59]           < return
[ 338.60]          < return
[ 338.60]          > fib(n: uint32): uint32
[ 338.62]           > fib(n: uint32): uint32
[ 338.63]           < return
[ 338.64]           > fib(n: uint32): uint32
[ 338.66]           < return
[ 338.67]          < return
[ 338.67]         < return
[ 338.68]         > fib(n: uint32): uint32
[ 338.70]          > fib(n: uint32): uint32
[ 338.71]           > fib(n: uint32): uint32
[ 338.73]           < return
[ 338.74]           > fib(n: uint32): uint32
[ 338.75]           < return
[ 338.76]          < return
[ 338.77]          > fib(n: uint32): uint32
[ 338.78]          < return
[ 338.79]         < return
[ 338.80]        < return
[ 338.81]       < return
[ 338.82]       > fib(n: uint32): uint32
[ 338.83]        > fib(n: uint32): uint32
[ 338.85]         > fib(n: uint32): uint32
[ 338.87]          > fib(n: uint32): uint32
[ 338.88]           > fib(n: uint32): uint32
[ 338.90]            > fib(n: uint32): uint32
[ 338.91]            < return
[ 338.92]            > fib(n: uint32): uint32
[ 338.94]            < return
[ 338.94]           < return
[ 338.95]           > fib(n: uint32): uint32
[ 338.97]           < return
[ 338.98]          < return
[ 338.98]          > fib(n: uint32): uint32
[ 339.00]           > fib(n: uint32): uint32
[ 339.01]           < return
[ 339.02]           > fib(n: uint32): uint32
[ 339.04]           < return
[ 339.05]          < return
[ 339.05]         < return
[ 339.06]         > fib(n: uint32): uint32
[ 339.08]          > fib(n: uint32): uint32
[ 339.09]           > fib(n: uint32): uint32
[ 339.11]           < return
[ 339.12]           > fib(n: uint32): uint32
[ 339.13]           < return
[ 339.14]          < return
[ 339.15]          > fib(n: uint32): uint32
[ 339.18]          < return
[ 339.19]         < return
[ 339.20]        < return
[ 339.21]        > fib(n: uint32): uint32
[ 339.23]         > fib(n: uint32): uint32
[ 339.26]          > fib(n: uint32): uint32
[ 339.28]           > fib(n: uint32): uint32
[ 339.31]           < return
[ 339.32]           > fib(n: uint32): uint32
[ 339.33]           < return
[ 339.34]          < return
[ 339.37]          > fib(n: uint32): uint32
[ 339.40]          < return
[ 339.42]         < return
[ 339.43]         > fib(n: uint32): uint32
[ 339.45]          > fib(n: uint32): uint32
[ 339.50]          < return
[ 339.50]          > fib(n: uint32): uint32
[ 339.52]          < return
[ 339.54]         < return
[ 339.55]        < return
[ 339.56]       < return
[ 339.56]      < return
[ 339.57]      > fib(n: uint32): uint32
[ 339.59]       > fib(n: uint32): uint32
[ 339.61]        > fib(n: uint32): uint32
[ 339.62]         > fib(n: uint32): uint32
[ 339.64]          > fib(n: uint32): uint32
[ 339.65]           > fib(n: uint32): uint32
[ 339.67]            > fib(n: uint32): uint32
[ 339.69]            < return
[ 339.69]            > fib(n: uint32): uint32
[ 339.71]            < return
[ 339.72]           < return
[ 339.73]           > fib(n: uint32): uint32
[ 339.74]           < return
[ 339.75]          < return
[ 339.76]          > fib(n: uint32): uint32
[ 339.77]           > fib(n: uint32): uint32
[ 339.79]           < return
[ 339.80]           > fib(n: uint32): uint32
[ 339.81]           < return
[ 339.82]          < return
[ 339.83]         < return
[ 339.83]         > fib(n: uint32): uint32
[ 339.85]          > fib(n: uint32): uint32
[ 339.87]           > fib(n: uint32): uint32
[ 339.88]           < return
[ 339.89]           > fib(n: uint32): uint32
[ 339.91]           < return
[ 339.91]          < return
[ 339.92]          > fib(n: uint32): uint32
[ 339.94]          < return
[ 339.94]         < return
[ 339.95]        < return
[ 339.96]        > fib(n: uint32): uint32
[ 339.98]         > fib(n: uint32): uint32
[ 340.01]          > fib(n: uint32): uint32
[ 340.03]           > fib(n: uint32): uint32
[ 340.04]           < return
[ 340.05]           > fib(n: uint32): uint32
[ 340.07]           < return
[ 340.08]          < return
[ 340.09]          > fib(n: uint32): uint32
[ 340.10]          < return
[ 340.12]         < return
[ 340.13]         > fib(n: uint32): uint32
[ 340.15]          > fib(n: uint32): uint32
[ 340.16]          < return
[ 340.17]          > fib(n: uint32): uint32
[ 340.19]          < return
[ 340.19]         < return
[ 340.20]        < return
[ 340.21]       < return
[ 340.22]       > fib(n: uint32): uint32
[ 340.23]        > fib(n: uint32): uint32
[ 340.25]         > fib(n: uint32): uint32
[ 340.26]          > fib(n: uint32): uint32
[ 340.28]           > fib(n: uint32): uint32
[ 340.30]           < return
[ 340.31]           > fib(n: uint32): uint32
[ 340.36]           < return
[ 340.36]          < return
[ 340.37]          > fib(n: uint32): uint32
[ 340.39]          < return
[ 340.40]         < return
[ 340.40]         > fib(n: uint32): uint32
[ 340.44]          > fib(n: uint32): uint32
[ 340.45]          < return
[ 340.46]          > fib(n: uint32): uint32
[ 340.47]          < return
[ 340.48]         < return
[ 340.49]        < return
[ 340.50]        > fib(n: uint32): uint32
[ 340.51]         > fib(n: uint32): uint32
[ 340.53]          > fib(n: uint32): uint32
[ 340.54]          < return
[ 340.55]          > fib(n: uint32): uint32
[ 340.57]          < return
[ 340.58]         < return
[ 340.58]         > fib(n: uint32): uint32
[ 340.60]         < return
[ 340.61]        < return
[ 340.62]       < return
[ 340.62]      < return
[ 340.63]     < return
[ 340.64]     > fib(n: uint32): uint32
[ 340.65]      > fib(n: uint32): uint32
[ 340.67]       > fib(n: uint32): uint32
[ 340.69]        > fib(n: uint32): uint32
[ 340.70]         > fib(n: uint32): uint32
[ 340.72]          > fib(n: uint32): uint32
[ 340.74]           > fib(n: uint32): uint32
[ 340.75]            > fib(n: uint32): uint32
[ 340.76]            < return
[ 340.77]            > fib(n: uint32): uint32
[ 340.79]            < return
[ 340.80]           < return
[ 340.81]           > fib(n: uint32): uint32
[ 340.82]           < return
[ 340.83]          < return
[ 340.84]          > fib(n: uint32): uint32
[ 340.86]           > fib(n: uint32): uint32
[ 340.87]           < return
[ 340.88]           > fib(n: uint32): uint32
[ 340.89]           < return
[ 340.90]          < return
[ 340.91]         < return
[ 340.92]         > fib(n: uint32): uint32
[ 340.94]          > fib(n: uint32): uint32
[ 340.95]           > fib(n: uint32): uint32
[ 340.97]           < return
[ 340.98]           > fib(n: uint32): uint32
[ 340.99]           < return
[ 341.00]          < return
[ 341.01]          > fib(n: uint32): uint32
[ 341.02]          < return
[ 341.03]         < return
[ 341.04]        < return
[ 341.05]        > fib(n: uint32): uint32
[ 341.06]         > fib(n: uint32): uint32
[ 341.08]          > fib(n: uint32): uint32
[ 341.09]           > fib(n: uint32): uint32
[ 341.11]           < return
[ 341.12]           > fib(n: uint32): uint32
[ 341.13]           < return
[ 341.14]          < return
[ 341.15]          > fib(n: uint32): uint32
[ 341.16]          < return
[ 341.17]         < return
[ 341.18]         > fib(n: uint32): uint32
[ 341.19]          > fib(n: uint32): uint32
[ 341.21]          < return
[ 341.22]          > fib(n: uint32): uint32
[ 341.23]          < return
[ 341.24]         < return
[ 341.25]        < return
[ 341.26]       < return
[ 341.26]       > fib(n: uint32): uint32
[ 341.28]        > fib(n: uint32): uint32
[ 341.30]         > fib(n: uint32): uint32
[ 341.31]          > fib(n: uint32): uint32
[ 341.33]           > fib(n: uint32): uint32
[ 341.34]           < return
[ 341.35]           > fib(n: uint32): uint32
[ 341.37]           < return
[ 341.38]          < return
[ 341.38]          > fib(n: uint32): uint32
[ 341.40]          < return
[ 341.41]         < return
[ 341.42]         > fib(n: uint32): uint32
[ 341.43]          > fib(n: uint32): uint32
[ 341.44]          < return
[ 341.45]          > fib(n: uint32): uint32
[ 341.47]          < return
[ 341.48]         < return
[ 341.48]        < return
[ 341.49]        > fib(n: uint32): uint32
[ 341.51]         > fib(n: uint32): uint32
[ 341.53]          > fib(n: uint32): uint32
[ 341.54]          < return
[ 341.55]          > fib(n: uint32): uint32
[ 341.56]          < return
[ 341.57]         < return
[ 341.58]         > fib(n: uint32): uint32
[ 341.60]         < return
[ 341.60]        < return
[ 341.61]       < return
[ 341.62]      < return
[ 341.63]      > fib(n: uint32): uint32
[ 341.64]       > fib(n: uint32): uint32
[ 341.66]        > fib(n: uint32): uint32
[ 341.68]         > fib(n: uint32): uint32
[ 341.69]          > fib(n: uint32): uint32
[ 341.71]           > fib(n: uint32): uint32
[ 341.72]           < return
[ 341.73]           > fib(n: uint32): uint32
[ 341.75]           < return
[ 341.75]          < return
[ 341.76]          > fib(n: uint32): uint32
[ 341.78]          < return
[ 341.79]         < return
[ 341.79]         > fib(n: uint32): uint32
[ 341.81]          > fib(n: uint32): uint32
[ 341.82]          < return
[ 341.83]          > fib(n: uint32): uint32
[ 341.85]          < return
[ 341.86]         < return
[ 341.87]        < return
[ 341.87]        > fib(n: uint32): uint32
[ 341.89]         > fib(n: uint32): uint32
[ 341.91]          > fib(n: uint32): uint32
[ 341.92]          < return
[ 341.93]          > fib(n: uint32): uint32
[ 341.94]          < return
[ 341.95]         < return
[ 341.96]         > fib(n: uint32): uint32
[ 341.98]         < return
[ 341.98]        < return
[ 341.99]       < return
[ 342.00]       > fib(n: uint32): uint32
[ 342.01]        > fib(n: uint32): uint32
[ 342.03]         > fib(n: uint32): uint32
[ 342.05]          > fib(n: uint32): uint32
[ 342.06]          < return
[ 342.07]          > fib(n: uint32): uint32
[ 342.08]          < return
[ 342.09]         < return
[ 342.10]         > fib(n: uint32): uint32
[ 342.12]         < return
[ 342.12]        < return
[ 342.13]        > fib(n: uint32): uint32
[ 342.15]         > fib(n: uint32): uint32
[ 342.17]         < return
[ 342.18]         > fib(n: uint32): uint32
[ 342.19]         < return
[ 342.20]        < return
[ 342.20]       < return
[ 342.21]      < return
[ 342.22]     < return
[ 342.23]    < return
[ 342.24]    > fib(n: uint32): uint32
[ 342.25]     > fib(n: uint32): uint32
[ 342.27]      > fib(n: uint32): uint32
[ 342.29]       > fib(n: uint32): uint32
[ 342.30]        > fib(n: uint32): uint32
[ 342.32]         > fib(n: uint32): uint32
[ 342.33]          > fib(n: uint32): uint32
[ 342.35]           > fib(n: uint32): uint32
[ 342.37]            > fib(n: uint32): uint32
[ 342.38]            < return
[ 342.39]            > fib(n: uint32): uint32
[ 342.40]            < return
[ 342.41]           < return
[ 342.42]           > fib(n: uint32): uint32
[ 342.44]           < return
[ 342.44]          < return
[ 342.45]          > fib(n: uint32): uint32
[ 342.47]           > fib(n: uint32): uint32
[ 342.48]           < return
[ 342.49]           > fib(n: uint32): uint32
[ 342.51]           < return
[ 342.51]          < return
[ 342.52]         < return
[ 342.53]         > fib(n: uint32): uint32
[ 342.55]          > fib(n: uint32): uint32
[ 342.56]           > fib(n: uint32): uint32
[ 342.58]           < return
[ 342.59]           > fib(n: uint32): uint32
[ 342.60]           < return
[ 342.61]          < return
[ 342.62]          > fib(n: uint32): uint32
[ 342.63]          < return
[ 342.64]         < return
[ 342.65]        < return
[ 342.66]        > fib(n: uint32): uint32
[ 342.67]         > fib(n: uint32): uint32
[ 342.69]          > fib(n: uint32): uint32
[ 342.70]           > fib(n: uint32): uint32
[ 342.72]           < return
[ 342.73]           > fib(n: uint32): uint32
[ 342.74]           < return
[ 342.75]          < return
[ 342.76]          > fib(n: uint32): uint32
[ 342.77]          < return
[ 342.78]         < return
[ 342.79]         > fib(n: uint32): uint32
[ 342.81]          > fib(n: uint32): uint32
[ 342.82]          < return
[ 342.83]          > fib(n: uint32): uint32
[ 342.84]          < return
[ 342.85]         < return
[ 342.86]        < return
[ 342.87]       < return
[ 342.88]       > fib(n: uint32): uint32
[ 342.89]        > fib(n: uint32): uint32
[ 342.91]         > fib(n: uint32): uint32
[ 342.93]          > fib(n: uint32): uint32
[ 342.94]           > fib(n: uint32): uint32
[ 342.95]           < return
[ 342.96]           > fib(n: uint32): uint32
[ 342.98]           < return
[ 342.99]          < return
[ 343.00]          > fib(n: uint32): uint32
[ 343.01]          < return
[ 343.02]         < return
[ 343.03]         > fib(n: uint32): uint32
[ 343.04]          > fib(n: uint32): uint32
[ 343.06]          < return
[ 343.07]          > fib(n: uint32): uint32
[ 343.08]          < return
[ 343.09]         < return
[ 343.10]        < return
[ 343.11]        > fib(n: uint32): uint32
[ 343.12]         > fib(n: uint32): uint32
[ 343.14]          > fib(n: uint32): uint32
[ 343.15]          < return
[ 343.16]          > fib(n: uint32): uint32
[ 343.18]          < return
[ 343.18]         < return
[ 343.19]         > fib(n: uint32): uint32
[ 343.21]         < return
[ 343.21]        < return
[ 343.22]       < return
[ 343.23]      < return
[ 343.24]      > fib(n: uint32): uint32
[ 343.25]       > fib(n: uint32): uint32
[ 343.27]        > fib(n: uint32): uint32
[ 343.29]         > fib(n: uint32): uint32
[ 343.30]          > fib(n: uint32): uint32
[ 343.32]           > fib(n: uint32): uint32
[ 343.33]           < return
[ 343.34]           > fib(n: uint32): uint32
[ 343.36]           < return
[ 343.37]          < return
[ 343.38]          > fib(n: uint32): uint32
[ 343.39]          < return
[ 343.40]         < return
[ 343.41]         > fib(n: uint32): uint32
[ 343.42]          > fib(n: uint32): uint32
[ 343.44]          < return
[ 343.44]          > fib(n: uint32): uint32
[ 343.46]          < return
[ 343.47]         < return
[ 343.48]        < return
[ 343.48]        > fib(n: uint32): uint32
[ 343.50]         > fib(n: uint32): uint32
[ 343.52]          > fib(n: uint32): uint32
[ 343.53]          < return
[ 343.54]          > fib(n: uint32): uint32
[ 343.56]          < return
[ 343.56]         < return
[ 343.57]         > fib(n: uint32): uint32
[ 343.59]         < return
[ 343.60]        < return
[ 343.60]       < return
[ 343.61]       > fib(n: uint32): uint32
[ 343.63]        > fib(n: uint32): uint32
[ 343.64]         > fib(n: uint32): uint32
[ 343.66]          > fib(n: uint32): uint32
[ 343.68]          < return
[ 343.68]          > fib(n: uint32): uint32
[ 343.70]          < return
[ 343.71]         < return
[ 343.71]         > fib(n: uint32): uint32
[ 343.73]         < return
[ 343.74]        < return
[ 343.75]        > fib(n: uint32): uint32
[ 343.76]         > fib(n: uint32): uint32
[ 343.78]         < return
[ 343.79]         > fib(n: uint32): uint32
[ 343.80]         < return
[ 343.81]        < return
[ 343.82]       < return
[ 343.82]      < return
[ 343.83]     < return
[ 343.84]     > fib(n: uint32): uint32
[ 343.86]      > fib(n: uint32): uint32
[ 343.87]       > fib(n: uint32): uint32
[ 343.89]        > fib(n: uint32): uint32
[ 343.90]         > fib(n: uint32): uint32
[ 343.92]          > fib(n: uint32): uint32
[ 343.94]           > fib(n: uint32): uint32
[ 343.95]           < return
[ 343.96]           > fib(n: uint32): uint32
[ 343.98]           < return
[ 343.98]          < return
[ 343.99]          > fib(n: uint32): uint32
[ 344.01]          < return
[ 344.01]         < return
[ 344.02]         > fib(n: uint32): uint32
[ 344.04]          > fib(n: uint32): uint32
[ 344.05]          < return
[ 344.06]          > fib(n: uint32): uint32
[ 344.08]          < return
[ 344.09]         < return
[ 344.09]        < return
[ 344.10]        > fib(n: uint32): uint32
[ 344.12]         > fib(n: uint32): uint32
[ 344.13]          > fib(n: uint32): uint32
[ 344.15]          < return
[ 344.16]          > fib(n: uint32): uint32
[ 344.17]          < return
[ 344.18]         < return
[ 344.19]         > fib(n: uint32): uint32
[ 344.20]         < return
[ 344.21]        < return
[ 344.22]       < return
[ 344.23]       > fib(n: uint32): uint32
[ 344.24]        > fib(n: uint32): uint32
[ 344.26]         > fib(n: uint32): uint32
[ 344.28]          > fib(n: uint32): uint32
[ 344.29]          < return
[ 344.30]          > fib(n: uint32): uint32
[ 344.32]          < return
[ 344.35]         < return
[ 344.36]         > fib(n: uint32): uint32
[ 344.39]         < return
[ 344.41]        < return
[ 344.42]        > fib(n: uint32): uint32
[ 344.44]         > fib(n: uint32): uint32
[ 344.45]         < return
[ 344.46]         > fib(n: uint32): uint32
[ 344.47]         < return
[ 344.48]        < return
[ 344.49]       < return
[ 344.50]      < return
[ 344.51]      > fib(n: uint32): uint32
[ 344.52]       > fib(n: uint32): uint32
[ 344.54]        > fib(n: uint32): uint32
[ 344.55]         > fib(n: uint32): uint32
[ 344.57]          > fib(n: uint32): uint32
[ 344.58]          < return
[ 344.59]          > fib(n: uint32): uint32
[ 344.61]          < return
[ 344.62]         < return
[ 344.62]         > fib(n: uint32): uint32
[ 344.64]         < return
[ 344.65]        < return
[ 344.66]        > fib(n: uint32): uint32
[ 344.67]         > fib(n: uint32): uint32
[ 344.69]         < return
[ 344.70]         > fib(n: uint32): uint32
[ 344.73]         < return
[ 344.74]        < return
[ 344.75]       < return
[ 344.76]       > fib(n: uint32): uint32
[ 344.81]        > fib(n: uint32): uint32
[ 344.83]         > fib(n: uint32): uint32
[ 344.88]         < return
[ 344.90]         > fib(n: uint32): uint32
[ 344.93]         < return
[ 344.97]        < return
[ 344.98]        > fib(n: uint32): uint32
[ 345.00]        < return
[ 345.03]       < return
[ 345.04]      < return
[ 345.05]     < return
[ 345.06]    < return
[ 345.07]   < return
[ 345.07]  < return
[ 345.19]  > typename.name(type: typename): .cstr
[ 345.24]  < return
[ 345.28]  > typename.file(type: typename): .cstr
[ 345.30]  < return
[ 345.31]  > typename.line(type: typename): int32
[ 345.35]  < return
[ 345.36]  > typename.base(type: typename): typename
[ 345.39]  < return
[ 345.42]  > typename.name(type: typename): .cstr
[ 345.44]  < return
[ 345.46]  > typename.file(type: typename): .cstr
[ 345.50]  < return
[ 345.51]  > typename.line(type: typename): int32
[ 345.53]  < return
[ 345.56]  > typename.base(type: typename): typename
[ 345.60]  < return
[ 345.62]  > typename.base(type: typename): typename
[ 345.64]  < return
[ 347.37]  > Math.floor(x: float64): float64
[ 347.38]   > Math.modf(x: float64, intPart: float64): float64
[ 347.39]   < return
[ 347.40]  < return
[ 347.42]  > Math.floor(x: float64): float64
[ 347.43]   > Math.modf(x: float64, intPart: float64): float64
[ 347.44]   < return
[ 347.44]  < return
[ 347.46]  > Math.floor(x: float64): float64
[ 347.47]   > Math.modf(x: float64, intPart: float64): float64
[ 347.48]   < return
[ 347.49]  < return
[ 347.50]  > Math.floor(x: float64): float64
[ 347.51]   > Math.modf(x: float64, intPart: float64): float64
[ 347.52]    > Math.modf(x: float64, intPart: float64): float64
[ 347.53]    < return
[ 347.54]   < return
[ 347.55]  < return
[ 347.56]  > Math.floor(x: float64): float64
[ 347.57]   > Math.modf(x: float64, intPart: float64): float64
[ 347.58]    > Math.modf(x: float64, intPart: float64): float64
[ 347.59]    < return
[ 347.60]   < return
[ 347.61]  < return
[ 347.62]  > Math.floor(x: float64): float64
[ 347.63]   > Math.modf(x: float64, intPart: float64): float64
[ 347.64]    > Math.modf(x: float64, intPart: float64): float64
[ 347.65]    < return
[ 347.66]   < return
[ 347.67]  < return
[ 347.77]  > Math.abs(x: float64): float64
[ 347.78]  < return
[ 347.79]  > Math.abs(x: float64): float64
[ 347.80]  < return
[ 347.82]  > Math.abs(x: float64): float64
[ 347.82]  < return
[ 347.84]  > Math.abs(x: float32): float32
[ 347.85]  < return
[ 347.87]  > Math.abs(x: float32): float32
[ 347.87]  < return
[ 347.89]  > Math.abs(x: float32): float32
[ 347.90]  < return
[ 347.92]  > Math.min(a: float32, b: float32): float32
[ 347.93]  < return
[ 347.94]  > Math.max(a: float32, b: float32): float32
[ 347.95]  < return
[ 347.97]  > Math.min(a: float64, b: float64): float64
[ 347.98]  < return
[ 348.00]  > Math.max(a: float64, b: float64): float64
[ 348.00]  < return
[ 348.02]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 348.03]  < return
[ 348.05]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 348.06]  < return
[ 348.11]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 348.12]  < return
[ 348.16]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 348.17]  < return
[ 348.21]  > Math.min(data: float64[]): float64
[ 348.22]  < return
[ 348.25]  > Math.min(data: float64[]): float64
[ 348.30]  < return
[ 348.35]  > Math.max(data: float64[]): float64
[ 348.38]  < return
[ 348.41]  > Math.max(data: float64[]): float64
[ 348.48]  < return
[ 348.50]  > Math.sum(data: float64[]): float64
[ 348.51]  < return
[ 348.53]  > Math.sum(data: float64[]): float64
[ 348.55]  < return
[ 348.57]  > Math.sum(data: float64[]): float64
[ 348.60]  < return
[ 348.62]  > Math.sum(data: float64[]): float64
[ 348.68]  < return
[ 348.71]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 348.73]  < return
[ 348.83]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 348.88]  < return
[ 348.92]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 348.97]  < return
[ 348.99]  > Math.sinCos(arg: float64, quad: int32): float64
[ 349.04]  < return
[ 349.06]  > Math.abs(x: float64): float64
[ 349.08]  < return
[ 349.09]  > Math.sinCos(arg: float64, quad: int32): float64
[ 349.14]  < return
[ 349.16]  > Math.tan(arg: float64): float64
[ 349.20]   > Math.modf(x: float64, intPart: float64): float64
[ 349.22]   < return
[ 349.27]  < return
[ 349.32]  > Math.sinh(x: float64): float64
[ 349.34]   > float64.exp(x: float64): float64
[ 349.42]   < return
[ 349.42]   > float64.exp(x: float64): float64
[ 349.47]   < return
[ 349.49]  < return
[ 349.51]  > Math.cosh(x: float64): float64
[ 349.53]   > float64.exp(x: float64): float64
[ 349.55]   < return
[ 349.57]   > float64.exp(x: float64): float64
[ 349.60]   < return
[ 349.62]  < return
[ 349.65]  > Math.asin(x: float64): float64
[ 349.67]   > float64.sqrt(x: float64): float64
[ 350.01]   < return
[ 350.04]   > float64.atan2(x: float64, y: float64): float64
[ 350.05]   < return
[ 350.06]  < return
[ 350.08]  > Math.asin(x: float64): float64
[ 350.10]   > float64.sqrt(x: float64): float64
[ 350.14]   < return
[ 350.15]   > float64.atan2(x: float64, y: float64): float64
[ 350.17]   < return
[ 350.18]  < return
[ 350.20]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 350.21]  < return
[ 350.23]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 350.25]  < return
[ 350.29]  > Math.absMod(val: float64, mod: float64): float64
[ 350.31]  < return
[ 350.33]  > Math.absMod(val: float64, mod: float64): float64
[ 350.35]  < return
[ 350.39]  > Math.absMod(val: float64, mod: float64): float64
[ 350.41]  < return
[ 350.43]  > Math.absMod(val: float64, mod: float64): float64
[ 350.46]  < return
[ 350.50]  > Math.absMod(val: float64, mod: float64): float64
[ 350.51]  < return
[ 350.54]  > Math.absMod(val: float64, mod: float64): float64
[ 350.55]  < return
[ 350.58]  > Math.absMod(val: float64, mod: float64): float64
[ 350.60]  < return
[ 350.62]  > Math.absMod(val: float64, mod: float64): float64
[ 350.63]  < return
[ 350.66]  > Math.absMod(val: float64, mod: float64): float64
[ 350.67]  < return
[ 350.69]  > Math.absMod(val: float64, mod: float64): float64
[ 350.70]  < return
[ 350.73]  > Math.absMod(val: float64, mod: float64): float64
[ 350.74]  < return
[ 350.78]  > Math.absMod(val: float32, mod: float32): float32
[ 350.80]  < return
[ 350.84]  > Math.absMod(val: float32, mod: float32): float32
[ 350.88]  < return
[ 350.91]  > Math.absMod(val: float32, mod: float32): float32
[ 350.94]  < return
[ 350.96]  > Math.absMod(val: float32, mod: float32): float32
[ 350.98]  < return
[ 351.00]  > Math.absMod(val: float32, mod: float32): float32
[ 351.01]  < return
[ 351.04]  > Math.absMod(val: float32, mod: float32): float32
[ 351.05]  < return
[ 351.07]  > Math.absMod(val: float32, mod: float32): float32
[ 351.09]  < return
[ 351.16]  > Math.absMod(val: float32, mod: float32): float32
[ 351.18]  < return
[ 351.20]  > Math.absMod(val: float32, mod: float32): float32
[ 351.21]  < return
[ 351.23]  > Math.absMod(val: float32, mod: float32): float32
[ 351.24]  < return
[ 351.29]  > Math.absMod(val: float32, mod: float32): float32
[ 351.30]  < return
[ 351.32]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 351.38]  < return
[ 351.39]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 351.41]  < return
[ 351.42]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 351.44]  < return
[ 351.45]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 351.48]  < return
[ 351.50]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 351.51]  < return
[ 351.53]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 351.54]  < return
[ 351.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:26: debug: val1: int64(42)
[ 351.59]  < return
[ 351.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:27: debug: val2: int64(96)
[ 351.62]  < return
[ 351.64]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 351.65]  < return
[ 351.67]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 351.69]  < return
[ 351.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:32: debug: val1: int64(0)
[ 351.73]  < return
[ 351.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:33: debug: val2: int64(42)
[ 351.78]  < return
[ 351.80]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 351.82]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	test/lang/init.method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 351.93]   < return
[ 351.94]  < return
[ 351.96]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 351.98]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	test/lang/init.method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 352.07]   < return
[ 352.07]  < return
[ 352.09]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 352.10]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:85: debug: extension.staticMethod
[ 352.12]   < return
[ 352.13]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 352.15]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	test/lang/init.method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 352.25]    < return
[ 352.26]   < return
[ 352.27]  < return
[ 352.28]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 352.30]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:91: debug: extension.virtualMethod
[ 352.35]   < return
[ 352.40]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 352.43]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	test/lang/init.method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 352.55]    < return
[ 352.56]   < return
[ 352.56]  < return
[ 352.58]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 352.60]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	test/lang/init.method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 352.71]   < return
[ 352.72]  < return
[ 352.73]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 352.79]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	test/lang/init.method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 352.93]   < return
[ 352.94]  < return
[ 352.96]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 352.98]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	test/lang/init.method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 353.07]   < return
[ 353.08]  < return
[ 353.10]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.array.ci:35: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 353.16]  < return
[ 353.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.array.ci:38: debug: string as variant: char[*]("string")
[ 353.21]  < return
[ 353.23]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/init.array.ci:41: debug: string as variant: char[]([0] {})
[ 353.26]  < return
[ 353.29]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.30]  < return
[ 353.31]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.32]  < return
[ 353.34]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.35]  < return
[ 353.36]  > lenSlice(values: int64[]): int32
[ 353.38]  < return
[ 353.39]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.40]  < return
[ 353.42]  > lenSlice(values: int64[]): int32
[ 353.43]  < return
[ 353.45]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.45]  < return
[ 353.47]  > lenSlice(values: int64[]): int32
[ 353.49]  < return
[ 353.50]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.51]  < return
[ 353.52]  > lenSlice(values: int64[]): int32
[ 353.54]  < return
[ 353.55]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.56]  < return
[ 353.58]  > lenSlice(values: int64[]): int32
[ 353.59]  < return
[ 353.60]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 353.61]  < return
[ 353.67]  > nthFixed(idx: int32, values: int64[7]): int64
[ 353.69]  < return
[ 353.72]  > nthFixed(idx: int32, values: int64[7]): int64
[ 353.74]  < return
[ 353.76]  > nthFixed(idx: int32, values: int64[7]): int64
[ 353.78]  < return
[ 353.80]  > nthArray(idx: int32, values: int64[*]): int64
[ 353.81]  < return
[ 353.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 353.85]  < return
[ 353.87]  > nthArray(idx: int32, values: int64[*]): int64
[ 353.89]  < return
[ 353.91]  > nthSlice(idx: int32, values: int64[]): int64
[ 353.93]  < return
[ 353.95]  > nthSlice(idx: int32, values: int64[]): int64
[ 353.97]  < return
[ 354.05]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.07]  < return
[ 354.09]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.11]  < return
[ 354.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.18]  < return
[ 354.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.22]  < return
[ 354.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.32]  < return
[ 354.34]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.36]  < return
[ 354.41]  > nthSlice(idx: int32, values: int64[]): int64
[ 354.44]  < return
[ 354.46]  > nthSlice(idx: int32, values: int64[]): int64
[ 354.50]  < return
[ 354.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.63]  < return
[ 354.65]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.67]  < return
[ 354.72]  > nthFixed(idx: int32, values: int64[7]): int64
[ 354.74]  < return
[ 354.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.80]  < return
[ 354.82]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.85]  < return
[ 354.88]  > nthArray(idx: int32, values: int64[*]): int64
[ 354.90]  < return
[ 354.93]  > nthSlice(idx: int32, values: int64[]): int64
[ 354.94]  < return
[ 354.96]  > nthSlice(idx: int32, values: int64[]): int64
[ 354.98]  < return
[ 355.06]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.08]  < return
[ 355.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.12]  < return
[ 355.14]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.16]  < return
[ 355.18]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.20]  < return
[ 355.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.27]  < return
[ 355.31]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.33]  < return
[ 355.37]  > nthSlice(idx: int32, values: int64[]): int64
[ 355.41]  < return
[ 355.44]  > nthSlice(idx: int32, values: int64[]): int64
[ 355.45]  < return
[ 355.53]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.55]  < return
[ 355.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.59]  < return
[ 355.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.62]  < return
[ 355.64]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.66]  < return
[ 355.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.70]  < return
[ 355.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 355.74]  < return
[ 355.76]  > nthSlice(idx: int32, values: int64[]): int64
[ 355.78]  < return
[ 355.80]  > nthSlice(idx: int32, values: int64[]): int64
[ 355.81]  < return
[ 355.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.92]  < return
[ 355.94]  > nthFixed(idx: int32, values: int64[7]): int64
[ 355.96]  < return
[ 355.98]  > nthFixed(idx: int32, values: int64[7]): int64
[ 356.00]  < return
[ 356.02]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.03]  < return
[ 356.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.07]  < return
[ 356.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.11]  < return
[ 356.13]  > nthSlice(idx: int32, values: int64[]): int64
[ 356.15]  < return
[ 356.17]  > nthSlice(idx: int32, values: int64[]): int64
[ 356.19]  < return
[ 356.27]  > nthFixed(idx: int32, values: int64[7]): int64
[ 356.30]  < return
[ 356.35]  > nthFixed(idx: int32, values: int64[7]): int64
[ 356.39]  < return
[ 356.42]  > nthFixed(idx: int32, values: int64[7]): int64
[ 356.43]  < return
[ 356.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.49]  < return
[ 356.52]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.57]  < return
[ 356.60]  > nthArray(idx: int32, values: int64[*]): int64
[ 356.62]  < return
[ 356.64]  > nthSlice(idx: int32, values: int64[]): int64
[ 356.69]  < return
[ 356.74]  > nthSlice(idx: int32, values: int64[]): int64
[ 356.77]  < return
[ 356.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
[ 356.84]  < return
[ 356.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
[ 356.90]  < return
[ 356.91]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
[ 356.96]  < return
[ 357.03]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 357.06]  < return
[ 357.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 357.15]  < return
[ 357.19]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 357.22]  < return
[ 357.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 357.31]  < return
[ 357.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:4: debug: for ( ; ; )
[ 357.35]  < return
[ 357.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 357.42]  < return
[ 357.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 357.47]  < return
[ 357.51]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 357.53]  < return
[ 357.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 357.58]  < return
[ 357.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
[ 357.71]  < return
[ 357.76]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
[ 357.79]  < return
[ 357.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
[ 357.84]  < return
[ 357.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
[ 357.92]  < return
[ 357.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
[ 357.98]  < return
[ 358.02]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:28: debug: for with break: int32(0)
[ 358.04]  < return
[ 358.07]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:28: debug: for with break: int32(1)
[ 358.10]  < return
[ 358.13]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/stmt.for.ci:28: debug: for with break: int32(2)
[ 358.15]  < return
[ 358.18]  > halt(): void
[ 358.19]  < return
[ 358.19] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
lib/std/debug.ci:48: NotEquals: typename(<NotEquals>)
lib/std/debug.ci:61: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:238: Math.mean: function(<Math.mean>)
lib/std/math.ci:255: Math.eval: function(<Math.eval>)
lib/std/math.ci:264: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:279: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:294: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:351: Math.tan: function(<Math.tan>)
lib/std/math.ci:408: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:447: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:462: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math/Complex.ci:2: Complex: typename(<Complex>)
lib/std/math/Complex.ci:24: Complex: function(<Complex>)
lib/std/math/Complex.ci:31: Complex: function(<Complex>)
lib/std/math/Complex.ci:86: div: function(<div>)
lib/std/math/Complex.ci:117: inv: function(<inv>)
lib/std/math/Complex.ci:135: pow: function(<pow>)
lib/std/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
lib/std/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
lib/std/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:87: transpose: function(<transpose>)
lib/std/math/Matrix4f.ci:97: mul: function(<mul>)
lib/std/math/Matrix4f.ci:111: rotation: function(<rotation>)
lib/std/math/Matrix4f.ci:163: translation: function(<translation>)
lib/std/math/Matrix4f.ci:173: scale: function(<scale>)
lib/std/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
lib/std/math/Vector2d.ci:14: vec2d: function(<vec2d>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:112: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:127: append: function(<append>)
lib/std/string.ci:144: append: function(<append>)
lib/std/string.ci:234: append: function(<append>)
lib/std/string.ci:262: append: function(<append>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:10: emitAddI32: int32(138)
test/lang/emit.ci:13: emitDivI32: int32(2)
test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:29: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
test/std/number.ci:3: pi64: float64(3.141593)
test/std/number.ci:4: e64: float64(2.718282)
test/std/number.ci:6: pi32: float32(3.141593)
test/std/number.ci:7: e32: float32(2.718282)
test/std/number.ci:14: r_comp: int32(112)
test/std/number.ci:15: g_comp: int32(252)
test/std/number.ci:16: b_comp: int32(248)
test/std/number.ci:18: r5g6b5: int32(30719)
test/std/number.ci:19: r8g8b8: int32(7404792)
test/std/number.ci:21: zxtR5: int32(14)
test/std/number.ci:22: zxtG6: int32(63)
test/std/number.ci:23: zxtB5: int32(31)
test/std/number.ci:25: sxtR5: int32(14)
test/std/number.ci:26: sxtG6: int32(-1)
test/std/number.ci:27: sxtB5: int32(-1)
test/std/number.ci:29: zxtR8: int32(112)
test/std/number.ci:30: zxtG8: int32(252)
test/std/number.ci:31: zxtB8: int32(248)
test/std/number.ci:33: sxtR8: int32(112)
test/std/number.ci:34: sxtG8: int32(-4)
test/std/number.ci:35: sxtB8: int32(-8)
test/std/number.ci:37: testSin_f64: float64(1.000000)
test/std/number.ci:38: testCos_f64: float64(0.000000)
test/std/number.ci:39: testTan_f64: float64(1.000000)
test/std/number.ci:40: testLog_f64: float64(3.000000)
test/std/number.ci:41: testExp_f64: float64(2.718282)
test/std/number.ci:42: testPow_f64: float64(3.141593)
test/std/number.ci:43: testSqrt_f64: float64(3.141593)
test/std/number.ci:44: testAtan_f64: float64(1.262627)
test/std/number.ci:46: testSin_f32: float32(1.000000)
test/std/number.ci:47: testCos_f32: float32(-0.000000)
test/std/number.ci:48: testTan_f32: float32(1.000000)
test/std/number.ci:49: testLog_f32: float32(3.000000)
test/std/number.ci:50: testExp_f32: float32(2.718282)
test/std/number.ci:51: testPow_f32: float32(3.141593)
test/std/number.ci:52: testSqrt_f32: float32(3.141593)
test/std/number.ci:53: testAtan_f32: float32(1.262627)
test/std/number.ci:55: testPopulation_u32: int32(14)
test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/std/number.ci:57: testBitScanReverse_u32: int32(14)
test/std/number.ci:58: testBitScanForward_u32: int32(0)
test/std/number.ci:59: testHighBit_u32: int32(16384)
test/std/number.ci:60: testLowBit_u32: int32(1)
test/std/number.ci:62: testZeroExtend_u32: int32(31)
test/std/number.ci:63: testSignExtend_u32: int32(-1)
test/std/number.ci:65: testZeroExtend_u64: int32(31)
test/std/number.ci:66: testSignExtend_u64: int32(-1)
test/std/memory.ci:7: p1: pointer(<?>)
test/std/memory.ci:8: p2: pointer(<?>)
test/std/memory.ci:9: p3: pointer(<?>)
test/std/memory.ci:10: p4: pointer(<?>)
test/std/memory.ci:23: val1: int64(0)
test/std/memory.ci:24: val2: int64(42)
test/std/tryExec.ci:11: noError: function(<noError>)
test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/std/tryExec.ci:20: divisionByZero: function(<divisionByZero>)
test/std/tryExec.ci:24: abortExecution: function(<abortExecution>)
test/std/tryExec.ci:38: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/std/tryExec.ci:43: invalidInstruction: function(<invalidInstruction>)
test/std/tryExec.ci:47: tryExecErr0: int32(0)
test/std/tryExec.ci:48: tryExecErr1: int32(1)
test/std/tryExec.ci:49: tryExecErr2: int32(2)
test/std/tryExec.ci:50: tryExecErr3: int32(3)
test/std/tryExec.ci:51: tryExecErr4: int32(4)
test/std/tryExec.ci:52: tryExecErr5: int32(5)
test/std/tryExec.ci:53: tryExecErr6: int32(6)
test/lang/init.reference.ci:7: value: int64(42)
test/lang/init.reference.ci:8: valueRef: int64(42)
test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
test/lang/init.reference.ci:12: fromRef: int64(42)
test/lang/init.reference.ci:13: fromPtr: int64(42)
test/lang/init.reference.ci:14: fromVar: int64(42)
test/lang/init.reference.ci:16: nullRef: int64(null)
test/lang/init.reference.ci:17: nullPtr: pointer(null)
test/lang/init.reference.ci:18: nullVar: variant(null)
test/lang/init.reference.ci:19: nullTyp: typename(null)
test/lang/init.reference.ci:20: nullFun: function(null)
test/lang/init.reference.ci:21: nullObj: object(null)
test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
test/lang/init.reference.ci:27: local: int64(42)
test/lang/init.reference.ci:28: copyVal: int64(42)
test/lang/init.reference.ci:29: copyRef: int64(42)
test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
test/lang/init.reference.ci:75: typVoid: typename(<void>)
test/lang/init.reference.ci:76: typBool: typename(<bool>)
test/lang/init.reference.ci:77: typChar: typename(<char>)
test/lang/init.reference.ci:78: typInt8: typename(<int8>)
test/lang/init.reference.ci:79: typInt16: typename(<int16>)
test/lang/init.reference.ci:80: typInt32: typename(<int32>)
test/lang/init.reference.ci:81: typInt64: typename(<int64>)
test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
test/lang/init.reference.ci:88: typTypename: typename(<typename>)
test/lang/init.reference.ci:89: typFunction: typename(<function>)
test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
test/lang/init.reference.ci:91: typVariant: typename(<variant>)
test/lang/init.reference.ci:92: typObject: typename(<object>)
test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/init.variable.ci:3: variable: int32(0)
test/lang/init.variable.ci:7: constant: int32(42)
test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(280624)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(280320)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/init.array.ci:11: arrFixedInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/init.array.ci:18: arrArrayInitNull: int64[*](null)
test/lang/init.array.ci:19: arrSliceInitNull: int64[](null)
test/lang/init.array.ci:22: arrArrayInitFixed: int64[*]([0] {})
test/lang/init.array.ci:23: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/init.array.ci:26: arrArrayInitSlice: int64[*]([0] {})
test/lang/init.array.ci:27: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/init.array.ci:30: arrArrayInitPtr: int64[*]([0] {})
test/lang/init.array.ci:34: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/init.array.ci:37: strArray: char[*]("string")
test/lang/init.array.ci:40: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/init.array.ci:51: lenSlice: function(<lenSlice>)
test/lang/init.array.ci:52: nthFixed: function(<nthFixed>)
test/lang/init.array.ci:53: nthArray: function(<nthArray>)
test/lang/init.array.ci:54: nthSlice: function(<nthSlice>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(255),
		r: uint8(0)
	})
})
test/lang/recUnion.ci:31: blue: color({
	col: uint32(255),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(0),
		r: uint8(0)
	})
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/stmt.if.ci:26: t: int32(0)
test/lang/stmt.for.ci:12: forIdx: int32(2)
test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/std/test.math.ci:67: testMathCmp_f32: bool(1)
test/std/test.math.ci:68: testMathCmp_f64: bool(1)
test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 390314(381.2 Kb)
memory[heap] @05f4aa; size: 2755150(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 364872(356.3 Kb)
memory[code] @000000; size: 20238(19.8 Kb)
memory[data] @000000; size: 2698(2.6 Kb)

---------- heap memory:
memory[free] @05f4c0; size: 2144(2.1 Kb)
memory[used] @05fd30; size: 32(32.0 bytes)
memory[used] @05fd60; size: 32(32.0 bytes)
memory[free] @05fd90; size: 2752848(2.6 Mb)

---------- Profile functions: 80/119, coverage: 67.23%
::[.005a38, .005a38): exec(2), time(0.015 ms): halt(): void
::[.005cd8, .005cd8): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006018, .006018): exec(3), time(0.082 ms): typename.base(type: typename): typename
::[.006218, .006218): exec(2), time(0.059 ms): typename.file(type: typename): .cstr
::[.006418, .006418): exec(2), time(0.056 ms): typename.line(type: typename): int32
::[.006618, .006618): exec(2), time(0.070 ms): typename.name(type: typename): .cstr
::[.0068b8, .0068b8): exec(2), time(0.049 ms): object.create(type: typename): pointer
::[.006b50, .006b50): exec(0), time(0.000 ms): object.as(this: object, type: typename): pointer
::[.007310, .007310): exec(37), time(1.719 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.007bf0, .007bf0): exec(7), time(3.551 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007e90, .007e90): exec(8), time(0.148 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.0081c8, .0081c8): exec(2), time(0.057 ms): pointer.fill(dst: pointer, value: uint8, size: int32): pointer
::[.008500, .008500): exec(1), time(0.018 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008830, .008830): exec(1), time(0.016 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.008ad8, .008ad8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.008ce0, .008ce0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008e48, .008e48): exec(0), time(0.000 ms): System.rand(): int32
::[.008fb0, .008fb0): exec(0), time(0.000 ms): System.time(): int32
::[.009118, .009118): exec(0), time(0.000 ms): System.clock(): int32
::[.009280, .009280): exec(0), time(0.000 ms): System.millis(): int64
::[.009480, .009480): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0097b8, .0097b8): exec(7), time(0.152 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.009ae8, .009ae8): exec(7), time(0.157 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.009ce8, .009ce8): exec(1), time(0.014 ms): uint32.pop(value: int32): int32
::[.009ee8, .009ee8): exec(1), time(0.014 ms): uint32.swap(value: int32): int32
::[.00a0e8, .00a0e8): exec(1), time(0.014 ms): uint32.bsr(value: int32): int32
::[.00a2e8, .00a2e8): exec(1), time(0.014 ms): uint32.bsf(value: int32): int32
::[.00a4e8, .00a4e8): exec(1), time(0.014 ms): uint32.hib(value: int32): int32
::[.00a6e8, .00a6e8): exec(1), time(0.013 ms): uint32.lob(value: int32): int32
::[.00aa10, .00aa10): exec(1), time(0.014 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00ad38, .00ad38): exec(1), time(0.014 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00af38, .00af38): exec(2), time(0.078 ms): float32.sin(x: float32): float32
::[.00b138, .00b138): exec(1), time(0.014 ms): float32.cos(x: float32): float32
::[.00b338, .00b338): exec(1), time(0.014 ms): float32.tan(x: float32): float32
::[.00b538, .00b538): exec(1), time(0.016 ms): float32.log(x: float32): float32
::[.00b738, .00b738): exec(1), time(0.033 ms): float32.exp(x: float32): float32
::[.00b9d0, .00b9d0): exec(1), time(0.027 ms): float32.pow(x: float32, y: float32): float32
::[.00bbd0, .00bbd0): exec(1), time(0.014 ms): float32.sqrt(x: float32): float32
::[.00be68, .00be68): exec(1), time(0.017 ms): float32.atan2(x: float32, y: float32): float32
::[.00c060, .00c060): exec(1), time(0.036 ms): float64.sin(x: float64): float64
::[.00c258, .00c258): exec(1), time(0.017 ms): float64.cos(x: float64): float64
::[.00c450, .00c450): exec(1), time(0.027 ms): float64.tan(x: float64): float64
::[.00c648, .00c648): exec(1), time(0.017 ms): float64.log(x: float64): float64
::[.00c840, .00c840): exec(5), time(0.189 ms): float64.exp(x: float64): float64
::[.00cad0, .00cad0): exec(1), time(0.017 ms): float64.pow(x: float64, y: float64): float64
::[.00ccc8, .00ccc8): exec(3), time(0.405 ms): float64.sqrt(x: float64): float64
::[.00cf58, .00cf58): exec(3), time(0.045 ms): float64.atan2(x: float64, y: float64): float64
lib/std/debug.ci:61:[.059148, .0591af): exec(8), time(0.088 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.0591b0, .059206): exec(10), time(0.133 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.059208, .059220): exec(6), time(0.227-0.117 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.059220, .059232): exec(3), time(0.029 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.059238, .05924a): exec(4), time(0.045 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.059250, .05926b): exec(11), time(0.211 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.059270, .05928b): exec(11), time(0.189 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.059290, .0592a1): exec(1), time(0.010 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.0592a8, .0592b9): exec(1), time(0.009 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.0592c0, .0592d1): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.0592d8, .0592e9): exec(1), time(0.011 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.0592f0, .05930e): exec(2), time(0.025 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.059310, .05932e): exec(2), time(0.023 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.059330, .05937f): exec(2), time(0.065 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.059380, .0593cf): exec(2), time(0.122 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.0593d0, .0593f8): exec(4), time(0.122 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:238:[.0593f8, .05940c): exec(0), time(0.000 ms): Math.mean(data: float64[]): float64
lib/std/math.ci:255:[.059410, .05943f): exec(3), time(0.122 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:264:[.059440, .059479): exec(1), time(0.015 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:279:[.059480, .0594b9): exec(1), time(0.014 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:294:[.0594c0, .05960f): exec(2), time(0.092 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:351:[.059610, .05978a): exec(1), time(0.111-0.016 ms): Math.tan(arg: float64): float64
lib/std/math.ci:408:[.059790, .059881): exec(1), time(0.167-0.126 ms): Math.sinh(x: float64): float64
lib/std/math.ci:447:[.059888, .0598d3): exec(1), time(0.101-0.048 ms): Math.cosh(x: float64): float64
lib/std/math.ci:462:[.0598d8, .059985): exec(2), time(0.510-0.422 ms): Math.asin(x: float64): float64
lib/std/math/Complex.ci:24:[.059988, .05998f): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math/Complex.ci:31:[.059990, .059997): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math/Complex.ci:86:[.059998, .059a13): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math/Complex.ci:117:[.059a18, .059a37): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math/Complex.ci:135:[.059a38, .059a9c): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/math/Matrix4f.ci:62:[.059aa0, .059ad1): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/std/math/Matrix4f.ci:75:[.059ad8, .059aed): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/std/math/Matrix4f.ci:87:[.059af0, .059b21): exec(0), time(0.000 ms): transpose(mat: mat4f): mat4f
lib/std/math/Matrix4f.ci:97:[.059b28, .059c1d): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
lib/std/math/Matrix4f.ci:111:[.059c20, .059de6): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
lib/std/math/Matrix4f.ci:163:[.059de8, .059e40): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
lib/std/math/Matrix4f.ci:173:[.059e40, .059f19): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
lib/std/math/Vector2d.ci:14:[.059f20, .059f27): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/std/string.ci:4:[.059f28, .059f4e): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.059f50, .059f82): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.059f88, .059fba): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.059fc0, .05a009): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.05a010, .05a08e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.05a090, .05a0cf): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.05a0d0, .05a117): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.05a118, .05a13c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.05a140, .05a14e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:127:[.05a150, .05a1a4): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:144:[.05a1b8, .05a47b): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
lib/std/string.ci:234:[.05a480, .05a563): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
lib/std/string.ci:262:[.05a578, .05a5b7): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
test/std/tryExec.ci:11:[.05a968, .05a969): exec(1), time(0.014 ms): noError(ptr: pointer): void
test/std/tryExec.ci:14:[.05a970, .05a988): exec(128-128), time(3.192 ms): stackOverflow(ptr: pointer): void
test/std/tryExec.ci:20:[.05a988, .05a994): exec(1-1), time(0.013 ms): divisionByZero(args: pointer): void
test/std/tryExec.ci:24:[.05a998, .05a9dc): exec(1-1), time(0.154-0.125 ms): abortExecution(args: pointer): void
test/std/tryExec.ci:38:[.05a9e0, .05a9ed): exec(1-1), time(0.014 ms): invalidMemoryAccess(args: pointer): void
test/std/tryExec.ci:43:[.05a9f0, .05a9f2): exec(1-1), time(0.013 ms): invalidInstruction(args: pointer): void
test/lang/function.ci:4:[.05acf0, .05acf1): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.05acf8, .05ad00): exec(2), time(0.043 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.05ad38, .05ad40): exec(2), time(0.039 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.05ad40, .05ad76): exec(753), time(21.674 ms): fib(n: uint32): uint32
test/lang/init.method.ci:10:[.05aef0, .05af17): exec(3), time(0.412-0.311 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/init.method.ci:40:[.05af20, .05af47): exec(4), time(0.600-0.433 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/init.method.ci:47:[.05af48, .05af6f): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/init.method.ci:57:[.05af70, .05af97): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/init.method.ci:84:[.05afa8, .05afea): exec(1), time(0.180-0.143 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/init.method.ci:90:[.05aff0, .05b02f): exec(1), time(0.282-0.205 ms): virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/init.array.ci:51:[.05b0b8, .05b0bc): exec(5), time(0.078 ms): lenSlice(values: int64[]): int32
test/lang/init.array.ci:52:[.05b0c0, .05b0cc): exec(21), time(0.443 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/init.array.ci:53:[.05b0d0, .05b0dc): exec(21), time(0.537 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/init.array.ci:54:[.05b0e0, .05b0ec): exec(14), time(0.356 ms): nthSlice(idx: int32, values: int64[]): int64
::[.05bb34, .05f4aa): exec(1), time(40.869-32.375 ms): .main

---------- Profile statements: 892/1223, coverage: 72.94%
lib/std/debug.ci:63:[.059151, .059152) exec(8), time(0.048-0.048 ms): <assertEq+9>
lib/std/debug.ci:62:[.059148, .059152) exec(8-8), time(0.000 ms): <assertEq+0>
lib/std/debug.ci:65:[.059156, .05915f) exec(0), time(0.000 ms): <assertEq+14>
lib/std/debug.ci:65:[.059152, .05915f) exec(0), time(0.000 ms): <assertEq+10>
lib/std/debug.ci:67:[.059163, .05916e) exec(0), time(0.000 ms): <assertEq+27>
lib/std/debug.ci:68:[.05916e, .059179) exec(0), time(0.000 ms): <assertEq+38>
lib/std/debug.ci:69:[.059179, .059184) exec(0), time(0.000 ms): <assertEq+49>
lib/std/debug.ci:66:[.05915f, .059184) exec(0), time(0.000 ms): <assertEq+23>
lib/std/debug.ci:71:[.059184, .0591aa) exec(0), time(0.000 ms): <assertEq+60>
lib/std/math.ci:25:[.0591c8, .0591d9) exec(3), time(0.052-0.052 ms): <modf+24>
lib/std/math.ci:26:[.0591d9, .0591e0) exec(3), time(0.003-0.003 ms): <modf+41>
lib/std/math.ci:27:[.0591e0, .0591e3) exec(3), time(0.017-0.017 ms): <modf+48>
lib/std/math.ci:24:[.0591c0, .0591e7) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.0591e7, .0591eb) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.0591eb, .0591ef) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.0591b0, .0591ef) exec(10-3), time(0.007-0.007 ms): <modf+0>
lib/std/math.ci:32:[.0591ef, .0591fb) exec(7), time(0.007-0.007 ms): <modf+63>
lib/std/math.ci:33:[.0591fb, .059203) exec(7), time(0.005-0.005 ms): <modf+75>
lib/std/math.ci:34:[.059203, .059206) exec(7), time(0.044-0.044 ms): <modf+83>
lib/std/math.ci:48:[.059208, .059209) exec(6), time(0.005-0.005 ms): <floor+0>
lib/std/math.ci:49:[.059209, .05921d) exec(6), time(0.155-0.155 ms): <floor+1>
lib/std/math.ci:50:[.05921d, .059220) exec(6), time(0.036-0.036 ms): <floor+21>
lib/std/math.ci:79:[.059228, .05922e) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:78:[.059220, .05922e) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.05922e, .059232) exec(2), time(0.013-0.013 ms): <abs+14>
lib/std/math.ci:87:[.059240, .059246) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:86:[.059238, .059246) exec(4-1), time(0.003-0.003 ms): <abs+0>
lib/std/math.ci:89:[.059246, .05924a) exec(3), time(0.021-0.021 ms): <abs+14>
lib/std/math.ci:95:[.05925f, .059267) exec(4), time(0.031-0.031 ms): <absMod+15>
lib/std/math.ci:94:[.059250, .059267) exec(11-4), time(0.010-0.010 ms): <absMod+0>
lib/std/math.ci:97:[.059267, .05926b) exec(7), time(0.072-0.072 ms): <absMod+23>
lib/std/math.ci:103:[.05927f, .059287) exec(4), time(0.035-0.035 ms): <absMod+15>
lib/std/math.ci:102:[.059270, .059287) exec(11-4), time(0.012-0.012 ms): <absMod+0>
lib/std/math.ci:105:[.059287, .05928b) exec(7), time(0.083-0.083 ms): <absMod+23>
lib/std/math.ci:117:[.059299, .05929d) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:116:[.059290, .05929d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.05929d, .0592a1) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.0592b1, .0592b5) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:124:[.0592a8, .0592b5) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.0592b5, .0592b9) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.0592c9, .0592cd) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.0592c0, .0592cd) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.0592cd, .0592d1) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:147:[.0592e1, .0592e5) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.0592d8, .0592e5) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.0592e5, .0592e9) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:161:[.0592f9, .0592fd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.0592f0, .0592fd) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.059306, .05930a) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:163:[.0592fd, .05930a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.05930a, .05930e) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:172:[.059319, .05931d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.059310, .05931d) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:175:[.059326, .05932a) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:174:[.05931d, .05932a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:177:[.05932a, .05932e) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:203:[.059338, .059344) exec(1), time(0.007-0.007 ms): <min+8>
lib/std/math.ci:202:[.059330, .059344) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.059344, .059347) exec(1), time(0.001-0.001 ms): <min+20>
lib/std/math.ci:208:[.059360, .05936b) exec(2), time(0.002-0.002 ms): <min+48>
lib/std/math.ci:207:[.059350, .05936b) exec(8-2), time(0.005-0.005 ms): <min+32>
lib/std/math.ci:206:[.05936b, .05936f) exec(8), time(0.003-0.003 ms): <min+59>
lib/std/math.ci:206:[.05936f, .059378) exec(9), time(0.008-0.008 ms): <min+63>
lib/std/math.ci:206:[.059347, .05937c) exec(1), time(0.002-0.002 ms): <min+23>
lib/std/math.ci:211:[.05937c, .05937f) exec(1), time(0.007-0.007 ms): <min+76>
lib/std/math.ci:217:[.059388, .059394) exec(1), time(0.007-0.007 ms): <max+8>
lib/std/math.ci:216:[.059380, .059394) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.059394, .059397) exec(1), time(0.001-0.001 ms): <max+20>
lib/std/math.ci:222:[.0593b0, .0593bb) exec(2), time(0.002-0.002 ms): <max+48>
lib/std/math.ci:221:[.0593a0, .0593bb) exec(8-2), time(0.007-0.007 ms): <max+32>
lib/std/math.ci:220:[.0593bb, .0593bf) exec(8), time(0.007-0.007 ms): <max+59>
lib/std/math.ci:220:[.0593bf, .0593c8) exec(9), time(0.021-0.021 ms): <max+63>
lib/std/math.ci:220:[.059397, .0593cc) exec(1), time(0.015-0.015 ms): <max+23>
lib/std/math.ci:225:[.0593cc, .0593cf) exec(1), time(0.007-0.007 ms): <max+76>
lib/std/math.ci:230:[.0593d0, .0593d1) exec(4), time(0.002-0.002 ms): <sum+0>
lib/std/math.ci:232:[.0593d6, .0593e4) exec(13), time(0.013-0.013 ms): <sum+6>
lib/std/math.ci:231:[.0593e4, .0593e8) exec(13), time(0.007-0.007 ms): <sum+20>
lib/std/math.ci:231:[.0593e8, .0593f1) exec(17), time(0.016-0.016 ms): <sum+24>
lib/std/math.ci:231:[.0593d1, .0593f5) exec(4), time(0.004-0.004 ms): <sum+1>
lib/std/math.ci:234:[.0593f5, .0593f8) exec(4), time(0.024-0.024 ms): <sum+37>
lib/std/math.ci:239:[.0593f8, .05940c) exec(0), time(0.000 ms): <mean+0>
lib/std/math.ci:256:[.059410, .059411) exec(3), time(0.003-0.003 ms): <eval+0>
lib/std/math.ci:258:[.05941b, .05942c) exec(11), time(0.015-0.015 ms): <eval+11>
lib/std/math.ci:257:[.05942c, .059430) exec(11), time(0.009-0.009 ms): <eval+28>
lib/std/math.ci:257:[.059430, .059438) exec(14), time(0.014-0.014 ms): <eval+32>
lib/std/math.ci:257:[.059411, .05943c) exec(3), time(0.006-0.006 ms): <eval+1>
lib/std/math.ci:260:[.05943c, .05943f) exec(3), time(0.025-0.025 ms): <eval+44>
lib/std/math.ci:267:[.059455, .05945d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:266:[.059449, .05945d) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:272:[.05946d, .059475) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:271:[.059461, .059475) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:265:[.059440, .059475) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:275:[.059475, .059479) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:282:[.059495, .05949d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:281:[.059489, .05949d) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:287:[.0594ad, .0594b5) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:286:[.0594a1, .0594b5) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:280:[.059480, .0594b5) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:290:[.0594b5, .0594b9) exec(1), time(0.026-0.026 ms): <cmp+53>
lib/std/math.ci:308:[.0594c0, .0594c2) exec(2), time(0.002-0.002 ms): <sinCos+0>
lib/std/math.ci:310:[.0594ca, .0594cb) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:311:[.0594cb, .0594d3) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:309:[.0594c2, .0594d3) exec(2), time(0.004-0.004 ms): <sinCos+2>
lib/std/math.ci:314:[.0594d3, .0594d4) exec(2), time(0.001-0.001 ms): <sinCos+19>
lib/std/math.ci:315:[.0594d4, .0594ec) exec(2), time(0.003-0.003 ms): <sinCos+20>
lib/std/math.ci:317:[.0594fc, .0594fd) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:318:[.0594fd, .05950f) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:319:[.05950f, .059513) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:321:[.059513, .059514) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:322:[.059514, .059532) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:323:[.059532, .059544) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:326:[.05954c, .05954f) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:327:[.05954f, .059557) exec(2), time(0.003-0.003 ms): <sinCos+143>
lib/std/math.ci:328:[.059557, .05955e) exec(2), time(0.002-0.002 ms): <sinCos+151>
lib/std/math.ci:329:[.05955e, .059564) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:316:[.0594ec, .059568) exec(2), time(0.003-0.003 ms): <sinCos+44>
lib/std/math.ci:332:[.059570, .05957e) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:331:[.059568, .05957e) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:335:[.05958a, .05958b) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:334:[.05957e, .05958b) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:338:[.05958b, .059590) exec(2), time(0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:339:[.059590, .0595d0) exec(2), time(0.007-0.007 ms): <sinCos+208>
lib/std/math.ci:340:[.0595d0, .059603) exec(2), time(0.006-0.006 ms): <sinCos+272>
lib/std/math.ci:341:[.059603, .05960f) exec(2), time(0.020-0.020 ms): <sinCos+323>
lib/std/math.ci:364:[.059610, .059611) exec(1), time(0.000 ms): <tan+0>
lib/std/math.ci:365:[.059611, .059612) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:368:[.05961a, .05961f) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:369:[.05961f, .059629) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:367:[.059612, .059629) exec(1), time(0.020-0.020 ms): <tan+2>
lib/std/math.ci:371:[.059629, .059641) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:373:[.059641, .059642) exec(1), time(0.001-0.001 ms): <tan+49>
lib/std/math.ci:374:[.059642, .059652) exec(1), time(0.027-0.027 ms): <tan+50>
lib/std/math.ci:375:[.059652, .05965b) exec(1), time(0.002-0.002 ms): <tan+66>
lib/std/math.ci:379:[.05966f, .05967d) exec(1), time(0.002-0.002 ms): <tan+95>
lib/std/math.ci:380:[.05967d, .059687) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:383:[.059697, .0596a2) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:384:[.0596a2, .0596ac) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:387:[.0596bc, .0596ca) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:388:[.0596ca, .0596d5) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:386:[.0596b0, .0596d5) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:382:[.05968b, .0596d5) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:378:[.059663, .0596d5) exec(1), time(0.002-0.002 ms): <tan+83>
lib/std/math.ci:377:[.05965b, .0596d5) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:391:[.0596d5, .0596da) exec(1), time(0.002-0.002 ms): <tan+197>
lib/std/math.ci:392:[.0596da, .05971a) exec(1), time(0.004-0.004 ms): <tan+202>
lib/std/math.ci:393:[.05971a, .059741) exec(1), time(0.003-0.003 ms): <tan+266>
lib/std/math.ci:397:[.059752, .059762) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:396:[.05974a, .059762) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:399:[.059762, .059770) exec(1), time(0.001-0.001 ms): <tan+338>
lib/std/math.ci:395:[.059741, .059770) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:402:[.059779, .059783) exec(0), time(0.000 ms): <tan+361>
lib/std/math.ci:401:[.059770, .059783) exec(1), time(0.001-0.001 ms): <tan+352>
lib/std/math.ci:404:[.059783, .05978a) exec(1), time(0.028-0.028 ms): <tan+371>
lib/std/math.ci:420:[.059790, .059791) exec(1), time(0.001-0.001 ms): <sinh+0>
lib/std/math.ci:422:[.059799, .05979e) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:423:[.05979e, .0597a8) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:421:[.059791, .0597a8) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:427:[.0597b8, .0597cf) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:426:[.0597a8, .0597cf) exec(1), time(0.002-0.002 ms): <sinh+24>
lib/std/math.ci:430:[.0597cf, .0597d0) exec(1), time(0.001-0.001 ms): <sinh+63>
lib/std/math.ci:432:[.0597e0, .0597fa) exec(1), time(0.141-0.141 ms): <sinh+80>
lib/std/math.ci:435:[.0597fe, .059803) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:436:[.059803, .059838) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:437:[.059838, .059863) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:431:[.0597d0, .059867) exec(1), time(0.141-0.141 ms): <sinh+64>
lib/std/math.ci:441:[.059870, .05987a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:440:[.059867, .05987a) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:443:[.05987a, .059881) exec(1), time(0.015-0.015 ms): <sinh+234>
lib/std/math.ci:449:[.059890, .059895) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:448:[.059888, .059895) exec(1), time(0.002-0.002 ms): <cosh+0>
lib/std/math.ci:452:[.0598a5, .0598b8) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:451:[.059895, .0598b8) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:454:[.0598b8, .0598d3) exec(1), time(0.089-0.089 ms): <cosh+48>
lib/std/math.ci:465:[.0598e0, .0598e4) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:463:[.0598d8, .0598e4) exec(2), time(0.003-0.003 ms): <asin+0>
lib/std/math.ci:468:[.0598e4, .0598e5) exec(2), time(0.002-0.002 ms): <asin+12>
lib/std/math.ci:470:[.0598ed, .0598f7) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:471:[.0598f7, .0598fc) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:469:[.0598e5, .0598fc) exec(2), time(0.002-0.002 ms): <asin+13>
lib/std/math.ci:476:[.05990c, .05991c) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:474:[.0598fc, .05991c) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:479:[.05991c, .05992f) exec(2), time(0.406-0.406 ms): <asin+68>
lib/std/math.ci:481:[.05993f, .05995d) exec(0), time(0.000 ms): <asin+103>
lib/std/math.ci:484:[.059961, .05996b) exec(2), time(0.044-0.044 ms): <asin+137>
lib/std/math.ci:480:[.05992f, .05996b) exec(2-2), time(0.000 ms): <asin+87>
lib/std/math.ci:488:[.059974, .05997e) exec(0), time(0.000 ms): <asin+156>
lib/std/math.ci:487:[.05996b, .05997e) exec(2), time(0.002-0.002 ms): <asin+147>
lib/std/math.ci:490:[.05997e, .059985) exec(2), time(0.013-0.013 ms): <asin+166>
::[.05998b, .05998e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:25:[.059988, .05998f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:34:[.059993, .059996) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:32:[.059990, .059997) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:91:[.0599b7, .0599bc) exec(0), time(0.000 ms): <div+31>
lib/std/math/Complex.ci:92:[.0599bc, .0599c4) exec(0), time(0.000 ms): <div+36>
lib/std/math/Complex.ci:95:[.0599d1, .0599de) exec(0), time(0.000 ms): <div+57>
lib/std/math/Complex.ci:93:[.0599c4, .0599e3) exec(0), time(0.000 ms): <div+44>
lib/std/math/Complex.ci:90:[.059998, .0599e7) exec(0), time(0.000 ms): <div+0>
lib/std/math/Complex.ci:98:[.0599e7, .0599ec) exec(0), time(0.000 ms): <div+79>
lib/std/math/Complex.ci:99:[.0599ec, .0599f4) exec(0), time(0.000 ms): <div+84>
lib/std/math/Complex.ci:102:[.059a01, .059a0e) exec(0), time(0.000 ms): <div+105>
lib/std/math/Complex.ci:100:[.0599f4, .059a13) exec(0), time(0.000 ms): <div+92>
lib/std/math/Complex.ci:118:[.059a18, .059a23) exec(0), time(0.000 ms): <inv+0>
lib/std/math/Complex.ci:121:[.059a2a, .059a32) exec(0), time(0.000 ms): <inv+18>
lib/std/math/Complex.ci:119:[.059a23, .059a37) exec(0), time(0.000 ms): <inv+11>
lib/std/math/Complex.ci:136:[.059a38, .059a4f) exec(0), time(0.000 ms): <pow+0>
lib/std/math/Complex.ci:137:[.059a4f, .059a5f) exec(0), time(0.000 ms): <pow+23>
lib/std/math/Complex.ci:138:[.059a5f, .059a6e) exec(0), time(0.000 ms): <pow+39>
lib/std/math/Complex.ci:139:[.059a6e, .059a81) exec(0), time(0.000 ms): <pow+54>
lib/std/math/Complex.ci:142:[.059a8c, .059a97) exec(0), time(0.000 ms): <pow+84>
lib/std/math/Complex.ci:140:[.059a81, .059a9c) exec(0), time(0.000 ms): <pow+73>
lib/std/math/Matrix4f.ci:67:[.059aa3, .059aa6) exec(0), time(0.000 ms): <mat4f+3>
lib/std/math/Matrix4f.ci:67:[.059aa6, .059aa9) exec(0), time(0.000 ms): <mat4f+6>
lib/std/math/Matrix4f.ci:67:[.059aa9, .059aac) exec(0), time(0.000 ms): <mat4f+9>
lib/std/math/Matrix4f.ci:68:[.059aac, .059aaf) exec(0), time(0.000 ms): <mat4f+12>
lib/std/math/Matrix4f.ci:68:[.059aaf, .059ab2) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:68:[.059ab2, .059ab5) exec(0), time(0.000 ms): <mat4f+18>
lib/std/math/Matrix4f.ci:68:[.059ab5, .059ab8) exec(0), time(0.000 ms): <mat4f+21>
lib/std/math/Matrix4f.ci:69:[.059ab8, .059abb) exec(0), time(0.000 ms): <mat4f+24>
lib/std/math/Matrix4f.ci:69:[.059abb, .059abe) exec(0), time(0.000 ms): <mat4f+27>
lib/std/math/Matrix4f.ci:69:[.059abe, .059ac1) exec(0), time(0.000 ms): <mat4f+30>
lib/std/math/Matrix4f.ci:69:[.059ac1, .059ac4) exec(0), time(0.000 ms): <mat4f+33>
lib/std/math/Matrix4f.ci:70:[.059ac4, .059ac7) exec(0), time(0.000 ms): <mat4f+36>
lib/std/math/Matrix4f.ci:70:[.059ac7, .059aca) exec(0), time(0.000 ms): <mat4f+39>
lib/std/math/Matrix4f.ci:70:[.059aca, .059acd) exec(0), time(0.000 ms): <mat4f+42>
lib/std/math/Matrix4f.ci:70:[.059acd, .059ad0) exec(0), time(0.000 ms): <mat4f+45>
lib/std/math/Matrix4f.ci:66:[.059aa0, .059ad1) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:76:[.059add, .059ae2) exec(0), time(0.000 ms): <mat4f+5>
lib/std/math/Matrix4f.ci:76:[.059ae2, .059ae7) exec(0), time(0.000 ms): <mat4f+10>
lib/std/math/Matrix4f.ci:76:[.059ae7, .059aec) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:76:[.059ad8, .059aed) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:89:[.059af3, .059af6) exec(0), time(0.000 ms): <transpose+3>
lib/std/math/Matrix4f.ci:89:[.059af6, .059af9) exec(0), time(0.000 ms): <transpose+6>
lib/std/math/Matrix4f.ci:89:[.059af9, .059afc) exec(0), time(0.000 ms): <transpose+9>
lib/std/math/Matrix4f.ci:90:[.059afc, .059aff) exec(0), time(0.000 ms): <transpose+12>
lib/std/math/Matrix4f.ci:90:[.059aff, .059b02) exec(0), time(0.000 ms): <transpose+15>
lib/std/math/Matrix4f.ci:90:[.059b02, .059b05) exec(0), time(0.000 ms): <transpose+18>
lib/std/math/Matrix4f.ci:90:[.059b05, .059b08) exec(0), time(0.000 ms): <transpose+21>
lib/std/math/Matrix4f.ci:91:[.059b08, .059b0b) exec(0), time(0.000 ms): <transpose+24>
lib/std/math/Matrix4f.ci:91:[.059b0b, .059b0e) exec(0), time(0.000 ms): <transpose+27>
lib/std/math/Matrix4f.ci:91:[.059b0e, .059b11) exec(0), time(0.000 ms): <transpose+30>
lib/std/math/Matrix4f.ci:91:[.059b11, .059b14) exec(0), time(0.000 ms): <transpose+33>
lib/std/math/Matrix4f.ci:92:[.059b14, .059b17) exec(0), time(0.000 ms): <transpose+36>
lib/std/math/Matrix4f.ci:92:[.059b17, .059b1a) exec(0), time(0.000 ms): <transpose+39>
lib/std/math/Matrix4f.ci:92:[.059b1a, .059b1d) exec(0), time(0.000 ms): <transpose+42>
lib/std/math/Matrix4f.ci:92:[.059b1d, .059b20) exec(0), time(0.000 ms): <transpose+45>
lib/std/math/Matrix4f.ci:88:[.059af0, .059b21) exec(0), time(0.000 ms): <transpose+0>
lib/std/math/Matrix4f.ci:98:[.059b28, .059b44) exec(0), time(0.000 ms): <mul+0>
lib/std/math/Matrix4f.ci:101:[.059b76, .059bac) exec(0), time(0.000 ms): <mul+78>
lib/std/math/Matrix4f.ci:102:[.059bac, .059be2) exec(0), time(0.000 ms): <mul+132>
lib/std/math/Matrix4f.ci:103:[.059be2, .059c18) exec(0), time(0.000 ms): <mul+186>
lib/std/math/Matrix4f.ci:99:[.059b44, .059c1d) exec(0), time(0.000 ms): <mul+28>
lib/std/math/Matrix4f.ci:112:[.059c20, .059c32) exec(0), time(0.000 ms): <rotation+0>
lib/std/math/Matrix4f.ci:114:[.059c43, .059c67) exec(0), time(0.000 ms): <rotation+35>
lib/std/math/Matrix4f.ci:117:[.059c6d, .059c73) exec(0), time(0.000 ms): <rotation+77>
lib/std/math/Matrix4f.ci:118:[.059c73, .059c79) exec(0), time(0.000 ms): <rotation+83>
lib/std/math/Matrix4f.ci:119:[.059c79, .059c7f) exec(0), time(0.000 ms): <rotation+89>
lib/std/math/Matrix4f.ci:115:[.059c67, .059c84) exec(0), time(0.000 ms): <rotation+71>
lib/std/math/Matrix4f.ci:113:[.059c32, .059c84) exec(0), time(0.000 ms): <rotation+18>
lib/std/math/Matrix4f.ci:122:[.059c84, .059c8a) exec(0), time(0.000 ms): <rotation+100>
lib/std/math/Matrix4f.ci:123:[.059c8a, .059c94) exec(0), time(0.000 ms): <rotation+106>
lib/std/math/Matrix4f.ci:124:[.059c94, .059c9e) exec(0), time(0.000 ms): <rotation+116>
lib/std/math/Matrix4f.ci:125:[.059c9e, .059ca1) exec(0), time(0.000 ms): <rotation+126>
lib/std/math/Matrix4f.ci:126:[.059ca1, .059ca8) exec(0), time(0.000 ms): <rotation+129>
lib/std/math/Matrix4f.ci:127:[.059ca8, .059caf) exec(0), time(0.000 ms): <rotation+136>
lib/std/math/Matrix4f.ci:128:[.059caf, .059cb4) exec(0), time(0.000 ms): <rotation+143>
lib/std/math/Matrix4f.ci:129:[.059cb4, .059cb9) exec(0), time(0.000 ms): <rotation+148>
lib/std/math/Matrix4f.ci:130:[.059cb9, .059cbe) exec(0), time(0.000 ms): <rotation+153>
lib/std/math/Matrix4f.ci:131:[.059cbe, .059cc3) exec(0), time(0.000 ms): <rotation+158>
lib/std/math/Matrix4f.ci:132:[.059cc3, .059cc8) exec(0), time(0.000 ms): <rotation+163>
lib/std/math/Matrix4f.ci:133:[.059cc8, .059ccd) exec(0), time(0.000 ms): <rotation+168>
lib/std/math/Matrix4f.ci:135:[.059ccd, .059cd3) exec(0), time(0.000 ms): <rotation+173>
lib/std/math/Matrix4f.ci:136:[.059cd3, .059cd9) exec(0), time(0.000 ms): <rotation+179>
lib/std/math/Matrix4f.ci:137:[.059cd9, .059ce1) exec(0), time(0.000 ms): <rotation+185>
lib/std/math/Matrix4f.ci:141:[.059cee, .059cfb) exec(0), time(0.000 ms): <rotation+206>
lib/std/math/Matrix4f.ci:142:[.059cfb, .059d08) exec(0), time(0.000 ms): <rotation+219>
lib/std/math/Matrix4f.ci:143:[.059d08, .059d33) exec(0), time(0.000 ms): <rotation+232>
lib/std/math/Matrix4f.ci:145:[.059d33, .059d40) exec(0), time(0.000 ms): <rotation+275>
lib/std/math/Matrix4f.ci:146:[.059d40, .059d4d) exec(0), time(0.000 ms): <rotation+288>
lib/std/math/Matrix4f.ci:147:[.059d4d, .059d5a) exec(0), time(0.000 ms): <rotation+301>
lib/std/math/Matrix4f.ci:148:[.059d5a, .059d85) exec(0), time(0.000 ms): <rotation+314>
lib/std/math/Matrix4f.ci:150:[.059d85, .059d92) exec(0), time(0.000 ms): <rotation+357>
lib/std/math/Matrix4f.ci:151:[.059d92, .059d9f) exec(0), time(0.000 ms): <rotation+370>
lib/std/math/Matrix4f.ci:152:[.059d9f, .059dac) exec(0), time(0.000 ms): <rotation+383>
lib/std/math/Matrix4f.ci:153:[.059dac, .059dd7) exec(0), time(0.000 ms): <rotation+396>
lib/std/math/Matrix4f.ci:155:[.059dd7, .059de1) exec(0), time(0.000 ms): <rotation+439>
lib/std/math/Matrix4f.ci:139:[.059ce1, .059de6) exec(0), time(0.000 ms): <rotation+193>
lib/std/math/Matrix4f.ci:165:[.059def, .059df2) exec(0), time(0.000 ms): <translation+7>
lib/std/math/Matrix4f.ci:165:[.059df2, .059df5) exec(0), time(0.000 ms): <translation+10>
lib/std/math/Matrix4f.ci:165:[.059df5, .059dfd) exec(0), time(0.000 ms): <translation+13>
lib/std/math/Matrix4f.ci:166:[.059dfd, .059e00) exec(0), time(0.000 ms): <translation+21>
lib/std/math/Matrix4f.ci:166:[.059e00, .059e07) exec(0), time(0.000 ms): <translation+24>
lib/std/math/Matrix4f.ci:166:[.059e07, .059e0a) exec(0), time(0.000 ms): <translation+31>
lib/std/math/Matrix4f.ci:166:[.059e0a, .059e16) exec(0), time(0.000 ms): <translation+34>
lib/std/math/Matrix4f.ci:167:[.059e16, .059e19) exec(0), time(0.000 ms): <translation+46>
lib/std/math/Matrix4f.ci:167:[.059e19, .059e1c) exec(0), time(0.000 ms): <translation+49>
lib/std/math/Matrix4f.ci:167:[.059e1c, .059e23) exec(0), time(0.000 ms): <translation+52>
lib/std/math/Matrix4f.ci:167:[.059e23, .059e2f) exec(0), time(0.000 ms): <translation+59>
lib/std/math/Matrix4f.ci:168:[.059e2f, .059e32) exec(0), time(0.000 ms): <translation+71>
lib/std/math/Matrix4f.ci:168:[.059e32, .059e35) exec(0), time(0.000 ms): <translation+74>
lib/std/math/Matrix4f.ci:168:[.059e35, .059e38) exec(0), time(0.000 ms): <translation+77>
lib/std/math/Matrix4f.ci:168:[.059e38, .059e3f) exec(0), time(0.000 ms): <translation+80>
lib/std/math/Matrix4f.ci:164:[.059de8, .059e40) exec(0), time(0.000 ms): <translation+0>
lib/std/math/Matrix4f.ci:176:[.059e77, .059e7a) exec(0), time(0.000 ms): <scale+55>
lib/std/math/Matrix4f.ci:176:[.059e7a, .059e7d) exec(0), time(0.000 ms): <scale+58>
lib/std/math/Matrix4f.ci:176:[.059e7d, .059e80) exec(0), time(0.000 ms): <scale+61>
lib/std/math/Matrix4f.ci:177:[.059e80, .059e83) exec(0), time(0.000 ms): <scale+64>
lib/std/math/Matrix4f.ci:177:[.059e83, .059ebe) exec(0), time(0.000 ms): <scale+67>
lib/std/math/Matrix4f.ci:177:[.059ebe, .059ec1) exec(0), time(0.000 ms): <scale+126>
lib/std/math/Matrix4f.ci:177:[.059ec1, .059ec4) exec(0), time(0.000 ms): <scale+129>
lib/std/math/Matrix4f.ci:178:[.059ec4, .059ec7) exec(0), time(0.000 ms): <scale+132>
lib/std/math/Matrix4f.ci:178:[.059ec7, .059eca) exec(0), time(0.000 ms): <scale+135>
lib/std/math/Matrix4f.ci:178:[.059eca, .059f05) exec(0), time(0.000 ms): <scale+138>
lib/std/math/Matrix4f.ci:178:[.059f05, .059f08) exec(0), time(0.000 ms): <scale+197>
lib/std/math/Matrix4f.ci:179:[.059f08, .059f0b) exec(0), time(0.000 ms): <scale+200>
lib/std/math/Matrix4f.ci:179:[.059f0b, .059f0e) exec(0), time(0.000 ms): <scale+203>
lib/std/math/Matrix4f.ci:179:[.059f0e, .059f11) exec(0), time(0.000 ms): <scale+206>
lib/std/math/Matrix4f.ci:179:[.059f11, .059f18) exec(0), time(0.000 ms): <scale+209>
lib/std/math/Matrix4f.ci:175:[.059e40, .059f19) exec(0), time(0.000 ms): <scale+0>
lib/std/math/Vector2d.ci:17:[.059f23, .059f26) exec(0), time(0.000 ms): <vec2d+3>
lib/std/math/Vector2d.ci:15:[.059f20, .059f27) exec(0), time(0.000 ms): <vec2d+0>
lib/std/string.ci:6:[.059f34, .059f38) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.059f28, .059f38) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.059f38, .059f39) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.059f3d, .059f41) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.059f41, .059f4b) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.059f39, .059f4b) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.059f4b, .059f4e) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.059f65, .059f68) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.059f55, .059f68) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.059f68, .059f6c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.059f6c, .059f76) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.059f50, .059f7a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.059f7a, .059f82) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.059f88, .059f8d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.059fa2, .059fa5) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.059f92, .059fa5) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.059fa5, .059fa9) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.059fa9, .059fb3) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.059f8d, .059fb7) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.059fb7, .059fba) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.059fdf, .059fea) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.059fc5, .059fea) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.059fea, .059fee) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.059fee, .059ffa) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.059fc0, .059ffe) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.059ffe, .05a009) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.05a010, .05a01d) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.05a01d, .05a02a) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.05a033, .05a03e) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.05a02a, .05a03e) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.05a063, .05a06e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.05a043, .05a06e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.05a06e, .05a072) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.05a072, .05a07b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.05a03e, .05a07f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.05a07f, .05a08e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.05a090, .05a091) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.05a096, .05a0ac) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.05a0b8, .05a0bc) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.05a0ac, .05a0bc) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.05a0bc, .05a0c0) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.05a0c0, .05a0c8) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.05a091, .05a0cc) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.05a0cc, .05a0cf) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.05a0df, .05a0ea) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.05a0d0, .05a0ea) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.05a0f9, .05a104) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.05a0ea, .05a104) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.05a104, .05a117) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.05a118, .05a13c) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.05a140, .05a14e) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:130:[.05a15e, .05a162) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:129:[.05a155, .05a162) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:132:[.05a162, .05a16e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:133:[.05a16e, .05a176) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:128:[.05a176, .05a17a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:128:[.05a17a, .05a184) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:128:[.05a150, .05a188) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:137:[.05a191, .05a199) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:136:[.05a188, .05a199) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:139:[.05a199, .05a1a0) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:140:[.05a1a0, .05a1a4) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:148:[.05a1b8, .05a1b9) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:149:[.05a1b9, .05a1bd) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:153:[.05a1cf, .05a1d9) exec(0), time(0.000 ms): <append+23>
lib/std/string.ci:152:[.05a1c4, .05a1d9) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:151:[.05a1bd, .05a1d9) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:157:[.05a1d9, .05a1e0) exec(0), time(0.000 ms): <append+33>
lib/std/string.ci:159:[.05a1e8, .05a1ef) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:158:[.05a1e0, .05a1ef) exec(0), time(0.000 ms): <append+40>
lib/std/string.ci:161:[.05a1ef, .05a225) exec(0), time(0.000 ms): <append+55>
lib/std/string.ci:162:[.05a225, .05a25a) exec(0), time(0.000 ms): <append+109>
lib/std/string.ci:166:[.05a25e, .05a27b) exec(0), time(0.000 ms): <append+166>
lib/std/string.ci:165:[.05a27b, .05a283) exec(0), time(0.000 ms): <append+195>
lib/std/string.ci:165:[.05a283, .05a28b) exec(0), time(0.000 ms): <append+203>
lib/std/string.ci:165:[.05a25a, .05a28b) exec(0), time(0.000 ms): <append+162>
lib/std/string.ci:169:[.05a293, .05a2a8) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:168:[.05a28b, .05a2a8) exec(0), time(0.000 ms): <append+211>
lib/std/string.ci:172:[.05a2a8, .05a2b2) exec(0), time(0.000 ms): <append+240>
lib/std/string.ci:174:[.05a2b2, .05a2b9) exec(0), time(0.000 ms): <append+250>
lib/std/string.ci:176:[.05a2c4, .05a2ce) exec(0), time(0.000 ms): <append+268>
lib/std/string.ci:175:[.05a2b9, .05a2ce) exec(0), time(0.000 ms): <append+257>
lib/std/string.ci:181:[.05a2d9, .05a2e1) exec(0), time(0.000 ms): <append+289>
lib/std/string.ci:185:[.05a2ff, .05a333) exec(0), time(0.000 ms): <append+327>
lib/std/string.ci:186:[.05a333, .05a33e) exec(0), time(0.000 ms): <append+379>
lib/std/string.ci:187:[.05a33e, .05a346) exec(0), time(0.000 ms): <append+390>
lib/std/string.ci:184:[.05a346, .05a34e) exec(0), time(0.000 ms): <append+398>
lib/std/string.ci:184:[.05a34e, .05a356) exec(0), time(0.000 ms): <append+406>
lib/std/string.ci:184:[.05a2fb, .05a356) exec(0), time(0.000 ms): <append+323>
lib/std/string.ci:182:[.05a2e1, .05a356) exec(0), time(0.000 ms): <append+297>
lib/std/string.ci:190:[.05a356, .05a38a) exec(0), time(0.000 ms): <append+414>
lib/std/string.ci:191:[.05a38a, .05a395) exec(0), time(0.000 ms): <append+466>
lib/std/string.ci:192:[.05a395, .05a39d) exec(0), time(0.000 ms): <append+477>
lib/std/string.ci:180:[.05a2ce, .05a39d) exec(0), time(0.000 ms): <append+278>
lib/std/string.ci:197:[.05a3a1, .05a3d5) exec(0), time(0.000 ms): <append+489>
lib/std/string.ci:198:[.05a3d5, .05a3e0) exec(0), time(0.000 ms): <append+541>
lib/std/string.ci:199:[.05a3e0, .05a3e8) exec(0), time(0.000 ms): <append+552>
lib/std/string.ci:196:[.05a3e8, .05a3f0) exec(0), time(0.000 ms): <append+560>
lib/std/string.ci:196:[.05a3f0, .05a3f8) exec(0), time(0.000 ms): <append+568>
lib/std/string.ci:196:[.05a39d, .05a3f8) exec(0), time(0.000 ms): <append+485>
lib/std/string.ci:204:[.05a3fd, .05a431) exec(0), time(0.000 ms): <append+581>
lib/std/string.ci:205:[.05a431, .05a442) exec(0), time(0.000 ms): <append+633>
lib/std/string.ci:206:[.05a442, .05a44a) exec(0), time(0.000 ms): <append+650>
lib/std/string.ci:203:[.05a44a, .05a44e) exec(0), time(0.000 ms): <append+658>
lib/std/string.ci:203:[.05a44e, .05a457) exec(0), time(0.000 ms): <append+662>
lib/std/string.ci:203:[.05a3f8, .05a45b) exec(0), time(0.000 ms): <append+576>
lib/std/string.ci:210:[.05a464, .05a46c) exec(0), time(0.000 ms): <append+684>
lib/std/string.ci:209:[.05a45b, .05a46c) exec(0), time(0.000 ms): <append+675>
lib/std/string.ci:212:[.05a46c, .05a473) exec(0), time(0.000 ms): <append+692>
lib/std/string.ci:213:[.05a473, .05a47b) exec(0), time(0.000 ms): <append+699>
lib/std/string.ci:236:[.05a484, .05a48c) exec(0), time(0.000 ms): <append+4>
lib/std/string.ci:237:[.05a48c, .05a48f) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:238:[.05a48f, .05a49b) exec(0), time(0.000 ms): <append+15>
lib/std/string.ci:239:[.05a49b, .05a4ac) exec(0), time(0.000 ms): <append+27>
lib/std/string.ci:235:[.05a480, .05a4ac) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:242:[.05a4b0, .05a4b6) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:243:[.05a4b6, .05a4b9) exec(0), time(0.000 ms): <append+54>
lib/std/string.ci:244:[.05a4b9, .05a4c3) exec(0), time(0.000 ms): <append+57>
lib/std/string.ci:245:[.05a4c3, .05a4cc) exec(0), time(0.000 ms): <append+67>
lib/std/string.ci:241:[.05a4ac, .05a4cc) exec(0), time(0.000 ms): <append+44>
lib/std/string.ci:248:[.05a4cc, .05a4de) exec(0), time(0.000 ms): <append+76>
lib/std/string.ci:249:[.05a4de, .05a4f9) exec(0), time(0.000 ms): <append+94>
lib/std/string.ci:250:[.05a4f9, .05a516) exec(0), time(0.000 ms): <append+121>
lib/std/string.ci:252:[.05a516, .05a52c) exec(0), time(0.000 ms): <append+150>
lib/std/string.ci:253:[.05a52c, .05a542) exec(0), time(0.000 ms): <append+172>
lib/std/string.ci:254:[.05a542, .05a55b) exec(0), time(0.000 ms): <append+194>
lib/std/string.ci:255:[.05a55b, .05a563) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:264:[.05a578, .05a5b7) exec(0), time(0.000 ms): <append+0>
test/std/tryExec.ci:16:[.05a970, .05a974) exec(128-1), time(0.081-0.081 ms): <stackOverflow+0>
test/std/tryExec.ci:17:[.05a974, .05a983) exec(127-127), time(0.000 ms): <stackOverflow+4>
test/std/tryExec.ci:21:[.05a988, .05a98f) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/std/tryExec.ci:31:[.05a99c, .05a9a3) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/std/tryExec.ci:32:[.05a9a3, .05a9aa) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/std/tryExec.ci:33:[.05a9aa, .05a9b1) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/std/tryExec.ci:30:[.05a998, .05a9b1) exec(1-1), time(0.000 ms): <abortExecution+0>
test/std/tryExec.ci:35:[.05a9b1, .05a9d7) exec(1-1), time(0.000 ms): <abortExecution+25>
test/std/tryExec.ci:39:[.05a9e0, .05a9e5) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/std/tryExec.ci:40:[.05a9e5, .05a9e8) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/std/tryExec.ci:44:[.05a9f0, .05a9f2) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/function.ci:8:[.05acf8, .05ad00) exec(2), time(0.034-0.034 ms): <funAdd+0>
test/lang/function.ci:34:[.05ad38, .05ad40) exec(2), time(0.022-0.022 ms): <funMul+0>
test/lang/function.ci:40:[.05ad4c, .05ad50) exec(377), time(3.297-3.297 ms): <fib+12>
test/lang/function.ci:39:[.05ad40, .05ad50) exec(753-377), time(0.896-0.896 ms): <fib+0>
test/lang/function.ci:42:[.05ad50, .05ad76) exec(376-375), time(21.660-21.660 ms): <fib+16>
test/lang/init.method.ci:11:[.05aef0, .05af16) exec(3), time(0.362-0.362 ms): <staticMethod+0>
test/lang/init.method.ci:41:[.05af20, .05af46) exec(4), time(0.486-0.486 ms): <virtualMethod+0>
test/lang/init.method.ci:48:[.05af48, .05af6e) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/init.method.ci:58:[.05af70, .05af96) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/init.method.ci:85:[.05afa8, .05afcb) exec(1), time(0.025-0.025 ms): <staticMethod+0>
test/lang/init.method.ci:87:[.05afd9, .05afe9) exec(1), time(0.137-0.137 ms): <staticMethod+49>
test/lang/init.method.ci:86:[.05afcb, .05afe9) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/init.method.ci:91:[.05aff0, .05b013) exec(1), time(0.076-0.076 ms): <virtualMethod+0>
test/lang/init.method.ci:93:[.05b021, .05b02e) exec(1), time(0.187-0.187 ms): <virtualMethod+49>
test/lang/init.method.ci:92:[.05b013, .05b02e) exec(1-1), time(0.000 ms): <virtualMethod+35>
test/lang/init.array.ci:51:[.05b0b8, .05b0bc) exec(5), time(0.036-0.036 ms): <lenSlice+0>
test/lang/init.array.ci:52:[.05b0c0, .05b0cc) exec(21), time(0.207-0.207 ms): <nthFixed+0>
test/lang/init.array.ci:53:[.05b0d0, .05b0dc) exec(21), time(0.271-0.271 ms): <nthArray+0>
test/lang/init.array.ci:54:[.05b0e0, .05b0ec) exec(14), time(0.172-0.172 ms): <nthSlice+0>
lib/std/string.ci:145:[.05bb34, .05bb42) exec(1), time(0.003-0.003 ms): <.main+0>
lib/std/string.ci:146:[.05bb42, .05bb50) exec(1), time(0.002-0.002 ms): <.main+14>
::[.05bb57, .05bb5c) exec(1), time(0.001-0.001 ms): <.main+35>
::[.05bb5c, .05bb63) exec(1), time(0.002-0.002 ms): <.main+40>
::[.05bb63, .05bb68) exec(1), time(0.002-0.002 ms): <.main+47>
lib/std/string.ci:263:[.05bb50, .05bb68) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.05bb68, .05bb6d) exec(1), time(0.001-0.001 ms): <.main+52>
test/lang/emit.ci:4:[.05bb6d, .05bb72) exec(1), time(0.002-0.002 ms): <.main+57>
test/lang/emit.ci:6:[.05bb72, .05bb7b) exec(1), time(0.002-0.002 ms): <.main+62>
test/lang/emit.ci:7:[.05bb7b, .05bb84) exec(1), time(0.001-0.001 ms): <.main+71>
test/lang/emit.ci:10:[.05bb84, .05bb91) exec(1), time(0.002-0.002 ms): <.main+80>
test/lang/emit.ci:13:[.05bb91, .05bba0) exec(1), time(0.002-0.002 ms): <.main+93>
test/lang/emit.ci:16:[.05bba0, .05bbb3) exec(1), time(0.090-0.090 ms): <.main+108>
test/lang/emit.ci:23:[.05bbb3, .05bbbc) exec(1), time(0.001-0.001 ms): <.main+127>
test/lang/emit.ci:24:[.05bbbc, .05bbc6) exec(1), time(0.003-0.003 ms): <.main+136>
test/lang/emit.ci:25:[.05bbc6, .05bbd4) exec(1), time(0.002-0.002 ms): <.main+146>
test/lang/emit.ci:26:[.05bbd4, .05bbe1) exec(1), time(0.001-0.001 ms): <.main+160>
test/lang/emit.ci:29:[.05bbe1, .05bbef) exec(1), time(0.001-0.001 ms): <.main+173>
test/lang/inlineMacros.ci:10:[.05bbef, .05bbf8) exec(1), time(0.001-0.001 ms): <.main+187>
test/lang/inlineMacros.ci:11:[.05bbf8, .05bc01) exec(1), time(0.001-0.001 ms): <.main+196>
test/lang/inlineMacros.ci:12:[.05bc01, .05bc0a) exec(1), time(0.001-0.001 ms): <.main+205>
test/lang/inlineMacros.ci:13:[.05bc0a, .05bc13) exec(1), time(0.001-0.001 ms): <.main+214>
test/lang/inlineMacros.ci:15:[.05bc13, .05bc18) exec(1), time(0.002-0.002 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.05bc18, .05bc1d) exec(1), time(0.001-0.001 ms): <.main+228>
test/lang/inlineMacros.ci:17:[.05bc1d, .05bc22) exec(1), time(0.002-0.002 ms): <.main+233>
test/lang/inlineMacros.ci:19:[.05bc22, .05bc2b) exec(1), time(0.001-0.001 ms): <.main+238>
test/lang/inlineMacros.ci:20:[.05bc2b, .05bc33) exec(1), time(0.002-0.002 ms): <.main+247>
test/lang/inlineMacros.ci:21:[.05bc33, .05bc43) exec(1), time(0.018-0.018 ms): <.main+255>
test/lang/inlineMacros.ci:23:[.05bc43, .05bc50) exec(1), time(0.002-0.002 ms): <.main+271>
test/lang/inlineMacros.ci:24:[.05bc50, .05bc5d) exec(1), time(0.002-0.002 ms): <.main+284>
test/lang/inlineMacros.ci:25:[.05bc5d, .05bc76) exec(1), time(0.004-0.004 ms): <.main+297>
test/lang/inlineMacros.ci:27:[.05bc76, .05bc92) exec(1), time(0.005-0.005 ms): <.main+322>
test/lang/inlineMacros.ci:28:[.05bc92, .05bcac) exec(1), time(0.003-0.003 ms): <.main+350>
test/lang/inlineMacros.ci:29:[.05bcac, .05bcd2) exec(1), time(0.004-0.004 ms): <.main+376>
test/lang/inlineMacros.ci:31:[.05bcd2, .05bcf7) exec(1), time(0.005-0.005 ms): <.main+414>
test/lang/inlineMacros.ci:32:[.05bcf7, .05bd1a) exec(1), time(0.005-0.005 ms): <.main+451>
test/lang/inlineMacros.ci:33:[.05bd1a, .05bd49) exec(1), time(0.006-0.006 ms): <.main+486>
test/lang/inlineMacros.ci:35:[.05bd49, .05bd6e) exec(1), time(0.017-0.017 ms): <.main+533>
test/lang/inlineMacros.ci:36:[.05bd6e, .05bd91) exec(1), time(0.005-0.005 ms): <.main+570>
test/lang/inlineMacros.ci:37:[.05bd91, .05bdc0) exec(1), time(0.006-0.006 ms): <.main+605>
test/lang/inlineMacros.ci:41:[.05bdc0, .05bdd9) exec(1), time(0.003-0.003 ms): <.main+652>
test/lang/inlineMacros.ci:42:[.05bdd9, .05bdee) exec(1), time(0.002-0.002 ms): <.main+677>
test/lang/inlineMacros.ci:43:[.05bdee, .05be05) exec(1), time(0.003-0.003 ms): <.main+698>
test/lang/inlineMacros.ci:44:[.05be05, .05be1c) exec(1), time(0.004-0.004 ms): <.main+721>
test/lang/inlineMacros.ci:45:[.05be1c, .05be47) exec(1), time(0.006-0.006 ms): <.main+744>
test/lang/inlineMacros.ci:46:[.05be47, .05be72) exec(1), time(0.006-0.006 ms): <.main+787>
test/lang/inlineMacros.ci:50:[.05be72, .05beb4) exec(1), time(0.003-0.003 ms): <.main+830>
test/lang/inlineMacros.ci:51:[.05beb4, .05bef6) exec(1), time(0.007-0.007 ms): <.main+896>
test/lang/inlineMacros.ci:52:[.05bef6, .05bf34) exec(1), time(0.004-0.004 ms): <.main+962>
test/lang/inlineMacros.ci:53:[.05bf34, .05bf72) exec(1), time(0.007-0.007 ms): <.main+1024>
test/lang/inlineMacros.ci:54:[.05bf72, .05bfc4) exec(1), time(0.004-0.004 ms): <.main+1086>
test/lang/inlineMacros.ci:55:[.05bfc4, .05c016) exec(1), time(0.008-0.008 ms): <.main+1168>
test/lang/inlineMacros.ci:59:[.05c016, .05c073) exec(1), time(0.012-0.012 ms): <.main+1250>
test/lang/inlineMacros.ci:60:[.05c073, .05c0d0) exec(1), time(0.012-0.012 ms): <.main+1343>
test/lang/inlineMacros.ci:61:[.05c0d0, .05c129) exec(1), time(0.012-0.012 ms): <.main+1436>
test/lang/inlineMacros.ci:62:[.05c129, .05c182) exec(1), time(0.012-0.012 ms): <.main+1525>
test/lang/inlineMacros.ci:63:[.05c182, .05c1ef) exec(1), time(0.014-0.014 ms): <.main+1614>
test/lang/inlineMacros.ci:64:[.05c1ef, .05c25c) exec(1), time(0.015-0.015 ms): <.main+1723>
test/lang/inlineMacros.ci:68:[.05c25c, .05c2b9) exec(1), time(0.012-0.012 ms): <.main+1832>
test/lang/inlineMacros.ci:69:[.05c2b9, .05c316) exec(1), time(0.012-0.012 ms): <.main+1925>
test/lang/inlineMacros.ci:70:[.05c316, .05c36f) exec(1), time(0.012-0.012 ms): <.main+2018>
test/lang/inlineMacros.ci:71:[.05c36f, .05c3c8) exec(1), time(0.012-0.012 ms): <.main+2107>
test/lang/inlineMacros.ci:72:[.05c3c8, .05c435) exec(1), time(0.014-0.014 ms): <.main+2196>
test/lang/inlineMacros.ci:73:[.05c435, .05c4a2) exec(1), time(0.015-0.015 ms): <.main+2305>
test/lang/overload.inline.ci:9:[.05c4a2, .05c4ab) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/overload.inline.ci:10:[.05c4ab, .05c4b4) exec(1), time(0.001-0.001 ms): <.main+2423>
test/lang/overload.inline.ci:11:[.05c4b4, .05c4bd) exec(1), time(0.001-0.001 ms): <.main+2432>
test/lang/overload.inline.ci:12:[.05c4bd, .05c4c6) exec(1), time(0.001-0.001 ms): <.main+2441>
test/lang/overload.inline.ci:13:[.05c4c6, .05c4cf) exec(1), time(0.001-0.001 ms): <.main+2450>
test/lang/overload.inline.ci:28:[.05c4cf, .05c4dc) exec(1), time(0.001-0.001 ms): <.main+2459>
test/lang/overload.inline.ci:29:[.05c4dc, .05c4f8) exec(1), time(0.003-0.003 ms): <.main+2472>
test/std/number.ci:3:[.05c4f8, .05c505) exec(1), time(0.001-0.001 ms): <.main+2500>
test/std/number.ci:4:[.05c505, .05c512) exec(1), time(0.001-0.001 ms): <.main+2513>
test/std/number.ci:6:[.05c512, .05c51b) exec(1), time(0.001-0.001 ms): <.main+2526>
test/std/number.ci:7:[.05c51b, .05c524) exec(1), time(0.002-0.002 ms): <.main+2535>
test/std/number.ci:14:[.05c524, .05c52f) exec(1), time(0.002-0.002 ms): <.main+2544>
test/std/number.ci:15:[.05c52f, .05c53a) exec(1), time(0.001-0.001 ms): <.main+2555>
test/std/number.ci:16:[.05c53a, .05c545) exec(1), time(0.002-0.002 ms): <.main+2566>
test/std/number.ci:18:[.05c545, .05c56b) exec(1), time(0.007-0.007 ms): <.main+2577>
test/std/number.ci:19:[.05c56b, .05c58f) exec(1), time(0.006-0.006 ms): <.main+2615>
test/std/number.ci:21:[.05c58f, .05c5a5) exec(1), time(0.048-0.048 ms): <.main+2651>
test/std/number.ci:22:[.05c5a5, .05c5bb) exec(1), time(0.039-0.039 ms): <.main+2673>
test/std/number.ci:23:[.05c5bb, .05c5cd) exec(1), time(0.025-0.025 ms): <.main+2695>
test/std/number.ci:25:[.05c5cd, .05c5e3) exec(1), time(0.039-0.039 ms): <.main+2713>
test/std/number.ci:26:[.05c5e3, .05c5f9) exec(1), time(0.025-0.025 ms): <.main+2735>
test/std/number.ci:27:[.05c5f9, .05c60b) exec(1), time(0.043-0.043 ms): <.main+2757>
test/std/number.ci:29:[.05c60b, .05c621) exec(1), time(0.054-0.054 ms): <.main+2775>
test/std/number.ci:30:[.05c621, .05c637) exec(1), time(0.024-0.024 ms): <.main+2797>
test/std/number.ci:31:[.05c637, .05c649) exec(1), time(0.057-0.057 ms): <.main+2819>
test/std/number.ci:33:[.05c649, .05c65f) exec(1), time(0.025-0.025 ms): <.main+2837>
test/std/number.ci:34:[.05c65f, .05c675) exec(1), time(0.026-0.026 ms): <.main+2859>
test/std/number.ci:35:[.05c675, .05c687) exec(1), time(0.059-0.059 ms): <.main+2881>
test/std/number.ci:37:[.05c687, .05c69d) exec(1), time(0.046-0.046 ms): <.main+2899>
test/std/number.ci:38:[.05c69d, .05c6b3) exec(1), time(0.028-0.028 ms): <.main+2921>
test/std/number.ci:39:[.05c6b3, .05c6c9) exec(1), time(0.038-0.038 ms): <.main+2943>
test/std/number.ci:40:[.05c6c9, .05c6df) exec(1), time(0.027-0.027 ms): <.main+2965>
test/std/number.ci:41:[.05c6df, .05c6f0) exec(1), time(0.023-0.023 ms): <.main+2987>
test/std/number.ci:42:[.05c6f0, .05c70a) exec(1), time(0.027-0.027 ms): <.main+3004>
test/std/number.ci:43:[.05c70a, .05c71b) exec(1), time(0.024-0.024 ms): <.main+3030>
test/std/number.ci:44:[.05c71b, .05c730) exec(1), time(0.024-0.024 ms): <.main+3047>
test/std/number.ci:46:[.05c730, .05c742) exec(1), time(0.024-0.024 ms): <.main+3068>
test/std/number.ci:47:[.05c742, .05c754) exec(1), time(0.023-0.023 ms): <.main+3086>
test/std/number.ci:48:[.05c754, .05c766) exec(1), time(0.024-0.024 ms): <.main+3104>
test/std/number.ci:49:[.05c766, .05c77c) exec(1), time(0.027-0.027 ms): <.main+3122>
test/std/number.ci:50:[.05c77c, .05c789) exec(1), time(0.042-0.042 ms): <.main+3144>
test/std/number.ci:51:[.05c789, .05c79f) exec(1), time(0.057-0.057 ms): <.main+3157>
test/std/number.ci:52:[.05c79f, .05c7b0) exec(1), time(0.038-0.038 ms): <.main+3179>
test/std/number.ci:53:[.05c7b0, .05c7c1) exec(1), time(0.026-0.026 ms): <.main+3196>
test/std/number.ci:55:[.05c7c1, .05c7cd) exec(1), time(0.023-0.023 ms): <.main+3213>
test/std/number.ci:56:[.05c7cd, .05c7d9) exec(1), time(0.022-0.022 ms): <.main+3225>
test/std/number.ci:57:[.05c7d9, .05c7e5) exec(1), time(0.023-0.023 ms): <.main+3237>
test/std/number.ci:58:[.05c7e5, .05c7f1) exec(1), time(0.023-0.023 ms): <.main+3249>
test/std/number.ci:59:[.05c7f1, .05c7fd) exec(1), time(0.022-0.022 ms): <.main+3261>
test/std/number.ci:60:[.05c7fd, .05c809) exec(1), time(0.023-0.023 ms): <.main+3273>
test/std/number.ci:62:[.05c809, .05c81b) exec(1), time(0.023-0.023 ms): <.main+3285>
test/std/number.ci:63:[.05c81b, .05c82d) exec(1), time(0.029-0.029 ms): <.main+3303>
test/std/number.ci:65:[.05c82d, .05c841) exec(1), time(0.025-0.025 ms): <.main+3321>
test/std/number.ci:66:[.05c841, .05c855) exec(1), time(0.024-0.024 ms): <.main+3341>
test/std/memory.ci:7:[.05c855, .05c867) exec(1), time(0.024-0.024 ms): <.main+3361>
test/std/memory.ci:8:[.05c867, .05c879) exec(1), time(0.024-0.024 ms): <.main+3379>
test/std/memory.ci:9:[.05c879, .05c88b) exec(1), time(0.023-0.023 ms): <.main+3397>
test/std/memory.ci:10:[.05c88b, .05c89d) exec(1), time(0.042-0.042 ms): <.main+3415>
test/std/memory.ci:23:[.05c89d, .05c8aa) exec(1), time(0.002-0.002 ms): <.main+3433>
test/std/memory.ci:24:[.05c8aa, .05c8b7) exec(1), time(0.001-0.001 ms): <.main+3446>
test/std/tryExec.ci:47:[.05c8b7, .05c8c9) exec(1), time(0.071-0.071 ms): <.main+3459>
test/std/tryExec.ci:48:[.05c8c9, .05c8db) exec(1), time(0.027-0.027 ms): <.main+3477>
test/std/tryExec.ci:49:[.05c8db, .05c8ed) exec(1), time(3.218-3.218 ms): <.main+3495>
test/std/tryExec.ci:50:[.05c8ed, .05c8ff) exec(1), time(0.040-0.040 ms): <.main+3513>
test/std/tryExec.ci:51:[.05c8ff, .05c911) exec(1), time(0.039-0.039 ms): <.main+3531>
test/std/tryExec.ci:52:[.05c911, .05c923) exec(1), time(0.040-0.040 ms): <.main+3549>
test/std/tryExec.ci:53:[.05c923, .05c935) exec(1), time(0.181-0.181 ms): <.main+3567>
test/lang/init.reference.ci:7:[.05c935, .05c942) exec(1), time(0.001-0.001 ms): <.main+3585>
test/lang/init.reference.ci:8:[.05c942, .05c94b) exec(1), time(0.001-0.001 ms): <.main+3598>
test/lang/init.reference.ci:9:[.05c94b, .05c954) exec(1), time(0.001-0.001 ms): <.main+3607>
test/lang/init.reference.ci:10:[.05c954, .05c962) exec(1), time(0.002-0.002 ms): <.main+3616>
test/lang/init.reference.ci:12:[.05c962, .05c96b) exec(1), time(0.002-0.002 ms): <.main+3630>
test/lang/init.reference.ci:13:[.05c96b, .05c973) exec(1), time(0.002-0.002 ms): <.main+3639>
test/lang/init.reference.ci:14:[.05c973, .05c97b) exec(1), time(0.001-0.001 ms): <.main+3647>
test/lang/init.reference.ci:16:[.05c97b, .05c984) exec(1), time(0.001-0.001 ms): <.main+3655>
test/lang/init.reference.ci:17:[.05c984, .05c98d) exec(1), time(0.002-0.002 ms): <.main+3664>
test/lang/init.reference.ci:18:[.05c98d, .05c99b) exec(1), time(0.002-0.002 ms): <.main+3673>
test/lang/init.reference.ci:19:[.05c99b, .05c9a4) exec(1), time(0.001-0.001 ms): <.main+3687>
test/lang/init.reference.ci:20:[.05c9a4, .05c9ad) exec(1), time(0.001-0.001 ms): <.main+3696>
test/lang/init.reference.ci:21:[.05c9ad, .05c9b6) exec(1), time(0.002-0.002 ms): <.main+3705>
test/lang/init.reference.ci:23:[.05c9b6, .05c9bf) exec(1), time(0.001-0.001 ms): <.main+3714>
test/lang/init.reference.ci:24:[.05c9bf, .05c9cd) exec(1), time(0.002-0.002 ms): <.main+3723>
test/lang/init.reference.ci:25:[.05c9cd, .05c9d6) exec(1), time(0.001-0.001 ms): <.main+3737>
test/lang/init.reference.ci:27:[.05c9d6, .05c9de) exec(1), time(0.002-0.002 ms): <.main+3746>
test/lang/init.reference.ci:28:[.05c9de, .05c9e6) exec(1), time(0.001-0.001 ms): <.main+3754>
test/lang/init.reference.ci:29:[.05c9e6, .05c9ee) exec(1), time(0.001-0.001 ms): <.main+3762>
test/lang/init.reference.ci:30:[.05c9ee, .05c9f6) exec(1), time(0.001-0.001 ms): <.main+3770>
test/lang/init.reference.ci:31:[.05c9f6, .05c9fe) exec(1), time(0.001-0.001 ms): <.main+3778>
test/lang/init.reference.ci:32:[.05c9fe, .05ca06) exec(1), time(0.002-0.002 ms): <.main+3786>
test/lang/init.reference.ci:35:[.05ca06, .05ca0f) exec(1), time(0.001-0.001 ms): <.main+3794>
test/lang/init.reference.ci:36:[.05ca0f, .05ca18) exec(1), time(0.002-0.002 ms): <.main+3803>
test/lang/init.reference.ci:37:[.05ca18, .05ca21) exec(1), time(0.002-0.002 ms): <.main+3812>
test/lang/init.reference.ci:38:[.05ca21, .05ca2a) exec(1), time(0.001-0.001 ms): <.main+3821>
test/lang/init.reference.ci:39:[.05ca2a, .05ca33) exec(1), time(0.002-0.002 ms): <.main+3830>
test/lang/init.reference.ci:40:[.05ca33, .05ca3c) exec(1), time(0.001-0.001 ms): <.main+3839>
test/lang/init.reference.ci:41:[.05ca3c, .05ca45) exec(1), time(0.001-0.001 ms): <.main+3848>
test/lang/init.reference.ci:42:[.05ca45, .05ca4e) exec(1), time(0.002-0.002 ms): <.main+3857>
test/lang/init.reference.ci:43:[.05ca4e, .05ca57) exec(1), time(0.001-0.001 ms): <.main+3866>
test/lang/init.reference.ci:44:[.05ca57, .05ca60) exec(1), time(0.001-0.001 ms): <.main+3875>
test/lang/init.reference.ci:45:[.05ca60, .05ca69) exec(1), time(0.002-0.002 ms): <.main+3884>
test/lang/init.reference.ci:46:[.05ca69, .05ca72) exec(1), time(0.001-0.001 ms): <.main+3893>
test/lang/init.reference.ci:47:[.05ca72, .05ca7b) exec(1), time(0.001-0.001 ms): <.main+3902>
test/lang/init.reference.ci:48:[.05ca7b, .05ca84) exec(1), time(0.002-0.002 ms): <.main+3911>
test/lang/init.reference.ci:49:[.05ca84, .05ca8d) exec(1), time(0.001-0.001 ms): <.main+3920>
test/lang/init.reference.ci:50:[.05ca8d, .05ca96) exec(1), time(0.001-0.001 ms): <.main+3929>
test/lang/init.reference.ci:51:[.05ca96, .05ca9f) exec(1), time(0.002-0.002 ms): <.main+3938>
test/lang/init.reference.ci:52:[.05ca9f, .05caa8) exec(1), time(0.001-0.001 ms): <.main+3947>
test/lang/init.reference.ci:55:[.05caa8, .05cab6) exec(1), time(0.002-0.002 ms): <.main+3956>
test/lang/init.reference.ci:56:[.05cab6, .05cac4) exec(1), time(0.002-0.002 ms): <.main+3970>
test/lang/init.reference.ci:57:[.05cac4, .05cad2) exec(1), time(0.002-0.002 ms): <.main+3984>
test/lang/init.reference.ci:58:[.05cad2, .05cae0) exec(1), time(0.002-0.002 ms): <.main+3998>
test/lang/init.reference.ci:59:[.05cae0, .05caee) exec(1), time(0.003-0.003 ms): <.main+4012>
test/lang/init.reference.ci:60:[.05caee, .05cafc) exec(1), time(0.002-0.002 ms): <.main+4026>
test/lang/init.reference.ci:61:[.05cafc, .05cb0a) exec(1), time(0.002-0.002 ms): <.main+4040>
test/lang/init.reference.ci:62:[.05cb0a, .05cb18) exec(1), time(0.002-0.002 ms): <.main+4054>
test/lang/init.reference.ci:63:[.05cb18, .05cb26) exec(1), time(0.002-0.002 ms): <.main+4068>
test/lang/init.reference.ci:64:[.05cb26, .05cb34) exec(1), time(0.002-0.002 ms): <.main+4082>
test/lang/init.reference.ci:65:[.05cb34, .05cb42) exec(1), time(0.002-0.002 ms): <.main+4096>
test/lang/init.reference.ci:66:[.05cb42, .05cb50) exec(1), time(0.002-0.002 ms): <.main+4110>
test/lang/init.reference.ci:67:[.05cb50, .05cb5e) exec(1), time(0.002-0.002 ms): <.main+4124>
test/lang/init.reference.ci:68:[.05cb5e, .05cb6c) exec(1), time(0.003-0.003 ms): <.main+4138>
test/lang/init.reference.ci:69:[.05cb6c, .05cb7a) exec(1), time(0.002-0.002 ms): <.main+4152>
test/lang/init.reference.ci:70:[.05cb7a, .05cb88) exec(1), time(0.002-0.002 ms): <.main+4166>
test/lang/init.reference.ci:71:[.05cb88, .05cb96) exec(1), time(0.002-0.002 ms): <.main+4180>
test/lang/init.reference.ci:72:[.05cb96, .05cba4) exec(1), time(0.002-0.002 ms): <.main+4194>
test/lang/init.reference.ci:75:[.05cba4, .05cbad) exec(1), time(0.001-0.001 ms): <.main+4208>
test/lang/init.reference.ci:76:[.05cbad, .05cbb6) exec(1), time(0.002-0.002 ms): <.main+4217>
test/lang/init.reference.ci:77:[.05cbb6, .05cbbf) exec(1), time(0.002-0.002 ms): <.main+4226>
test/lang/init.reference.ci:78:[.05cbbf, .05cbc8) exec(1), time(0.002-0.002 ms): <.main+4235>
test/lang/init.reference.ci:79:[.05cbc8, .05cbd1) exec(1), time(0.001-0.001 ms): <.main+4244>
test/lang/init.reference.ci:80:[.05cbd1, .05cbda) exec(1), time(0.001-0.001 ms): <.main+4253>
test/lang/init.reference.ci:81:[.05cbda, .05cbe3) exec(1), time(0.002-0.002 ms): <.main+4262>
test/lang/init.reference.ci:82:[.05cbe3, .05cbec) exec(1), time(0.002-0.002 ms): <.main+4271>
test/lang/init.reference.ci:83:[.05cbec, .05cbf5) exec(1), time(0.001-0.001 ms): <.main+4280>
test/lang/init.reference.ci:84:[.05cbf5, .05cbfe) exec(1), time(0.001-0.001 ms): <.main+4289>
test/lang/init.reference.ci:85:[.05cbfe, .05cc07) exec(1), time(0.002-0.002 ms): <.main+4298>
test/lang/init.reference.ci:86:[.05cc07, .05cc10) exec(1), time(0.001-0.001 ms): <.main+4307>
test/lang/init.reference.ci:87:[.05cc10, .05cc19) exec(1), time(0.002-0.002 ms): <.main+4316>
test/lang/init.reference.ci:88:[.05cc19, .05cc22) exec(1), time(0.002-0.002 ms): <.main+4325>
test/lang/init.reference.ci:89:[.05cc22, .05cc2b) exec(1), time(0.001-0.001 ms): <.main+4334>
test/lang/init.reference.ci:90:[.05cc2b, .05cc34) exec(1), time(0.001-0.001 ms): <.main+4343>
test/lang/init.reference.ci:91:[.05cc34, .05cc3d) exec(1), time(0.001-0.001 ms): <.main+4352>
test/lang/init.reference.ci:92:[.05cc3d, .05cc46) exec(1), time(0.002-0.002 ms): <.main+4361>
test/lang/init.reference.ci:95:[.05cc46, .05cc4f) exec(1), time(0.001-0.001 ms): <.main+4370>
test/lang/init.reference.ci:96:[.05cc4f, .05cc5d) exec(1), time(0.002-0.002 ms): <.main+4379>
test/lang/init.reference.ci:97:[.05cc5d, .05cc66) exec(1), time(0.002-0.002 ms): <.main+4393>
test/lang/init.reference.ci:99:[.05cc66, .05cc6f) exec(1), time(0.002-0.002 ms): <.main+4402>
test/lang/init.reference.ci:105:[.05cc6f, .05cc7c) exec(1), time(0.002-0.002 ms): <.main+4411>
test/lang/init.reference.ci:108:[.05cc7c, .05cc84) exec(1), time(0.001-0.001 ms): <.main+4424>
test/lang/init.variable.ci:3:[.05cc84, .05cc89) exec(1), time(0.002-0.002 ms): <.main+4432>
test/lang/init.variable.ci:7:[.05cc89, .05cc92) exec(1), time(0.002-0.002 ms): <.main+4437>
::[.05cc9f, .05cca4) exec(1), time(0.002-0.002 ms): <.main+4459>
test/lang/init.variable.ci:24:[.05cc92, .05cca4) exec(1-1), time(0.000 ms): <.main+4446>
test/lang/init.variable.ci:33:[.05ccb1, .05ccc3) exec(1), time(0.003-0.003 ms): <.main+4477>
::[.05ccc3, .05cccd) exec(1), time(0.003-0.003 ms): <.main+4495>
test/lang/init.variable.ci:33:[.05cca4, .05cccd) exec(1-1), time(0.000 ms): <.main+4464>
test/lang/init.variable.ci:41:[.05ccda, .05ccec) exec(1), time(0.003-0.003 ms): <.main+4518>
test/lang/init.variable.ci:41:[.05cccd, .05ccec) exec(1-1), time(0.000 ms): <.main+4505>
test/lang/function.ci:12:[.05ccec, .05cd05) exec(1), time(0.042-0.042 ms): <.main+4536>
test/lang/function.ci:15:[.05cd05, .05cd0e) exec(1), time(0.002-0.002 ms): <.main+4561>
test/lang/function.ci:18:[.05cd0e, .05cd26) exec(1), time(0.027-0.027 ms): <.main+4570>
test/lang/function.ci:21:[.05cd26, .05cd2f) exec(1), time(0.002-0.002 ms): <.main+4594>
test/lang/function.ci:24:[.05cd2f, .05cd47) exec(1), time(0.027-0.027 ms): <.main+4603>
test/lang/function.ci:27:[.05cd47, .05cd4f) exec(1), time(0.001-0.001 ms): <.main+4627>
test/lang/function.ci:30:[.05cd4f, .05cd67) exec(1), time(0.040-0.040 ms): <.main+4635>
test/lang/function.ci:46:[.05cd67, .05cd7b) exec(1), time(21.687-21.687 ms): <.main+4659>
test/lang/reflect.ci:3:[.05cd7b, .05cd83) exec(1), time(0.001-0.001 ms): <.main+4679>
test/lang/reflect.ci:4:[.05cd83, .05cd8b) exec(1), time(0.002-0.002 ms): <.main+4687>
test/lang/reflect.ci:5:[.05cd8b, .05cd93) exec(1), time(0.002-0.002 ms): <.main+4695>
test/lang/reflect.ci:6:[.05cd93, .05cd9b) exec(1), time(0.001-0.001 ms): <.main+4703>
test/lang/reflect.ci:7:[.05cd9b, .05cda3) exec(1), time(0.001-0.001 ms): <.main+4711>
test/lang/reflect.ci:8:[.05cda3, .05cdab) exec(1), time(0.001-0.001 ms): <.main+4719>
test/lang/reflect.ci:9:[.05cdab, .05cdb3) exec(1), time(0.001-0.001 ms): <.main+4727>
test/lang/reflect.ci:10:[.05cdb3, .05cdbb) exec(1), time(0.001-0.001 ms): <.main+4735>
test/lang/reflect.ci:11:[.05cdbb, .05cdc3) exec(1), time(0.020-0.020 ms): <.main+4743>
test/lang/reflect.ci:12:[.05cdc3, .05cdcb) exec(1), time(0.001-0.001 ms): <.main+4751>
test/lang/reflect.ci:13:[.05cdcb, .05cdd3) exec(1), time(0.001-0.001 ms): <.main+4759>
test/lang/reflect.ci:14:[.05cdd3, .05cddb) exec(1), time(0.001-0.001 ms): <.main+4767>
test/lang/reflect.ci:15:[.05cddb, .05cde3) exec(1), time(0.001-0.001 ms): <.main+4775>
test/lang/reflect.ci:16:[.05cde3, .05cdeb) exec(1), time(0.001-0.001 ms): <.main+4783>
test/lang/reflect.ci:17:[.05cdeb, .05cdf3) exec(1), time(0.001-0.001 ms): <.main+4791>
test/lang/reflect.ci:18:[.05cdf3, .05cdfb) exec(1), time(0.001-0.001 ms): <.main+4799>
test/lang/reflect.ci:19:[.05cdfb, .05ce03) exec(1), time(0.001-0.001 ms): <.main+4807>
test/lang/reflect.ci:20:[.05ce03, .05ce0b) exec(1), time(0.014-0.014 ms): <.main+4815>
test/lang/reflect.ci:30:[.05ce0b, .05ce14) exec(1), time(0.001-0.001 ms): <.main+4823>
test/lang/reflect.ci:31:[.05ce14, .05ce20) exec(1), time(0.062-0.062 ms): <.main+4832>
test/lang/reflect.ci:32:[.05ce20, .05ce2d) exec(1), time(0.003-0.003 ms): <.main+4844>
test/lang/reflect.ci:33:[.05ce2d, .05ce3a) exec(1), time(0.003-0.003 ms): <.main+4857>
test/lang/reflect.ci:34:[.05ce3a, .05ce46) exec(1), time(0.032-0.032 ms): <.main+4870>
test/lang/reflect.ci:35:[.05ce46, .05ce52) exec(1), time(0.048-0.048 ms): <.main+4882>
test/lang/reflect.ci:37:[.05ce52, .05ce5e) exec(1), time(0.060-0.060 ms): <.main+4894>
test/lang/reflect.ci:38:[.05ce5e, .05ce6a) exec(1), time(0.028-0.028 ms): <.main+4906>
test/lang/reflect.ci:39:[.05ce6a, .05ce77) exec(1), time(0.003-0.003 ms): <.main+4918>
test/lang/reflect.ci:40:[.05ce77, .05ce84) exec(1), time(0.003-0.003 ms): <.main+4931>
test/lang/reflect.ci:41:[.05ce84, .05ce90) exec(1), time(0.047-0.047 ms): <.main+4944>
test/lang/reflect.ci:42:[.05ce90, .05ce9c) exec(1), time(0.046-0.046 ms): <.main+4956>
test/lang/reflect.ci:44:[.05ce9c, .05cea8) exec(1), time(0.057-0.057 ms): <.main+4968>
test/lang/reflect.ci:45:[.05cea8, .05ceb5) exec(1), time(0.003-0.003 ms): <.main+4980>
test/lang/reflect.ci:46:[.05ceb5, .05cec2) exec(1), time(0.003-0.003 ms): <.main+4993>
test/lang/reflect.ci:48:[.05cec2, .05cece) exec(1), time(0.024-0.024 ms): <.main+5006>
test/lang/reflect.ci:49:[.05cece, .05cedb) exec(1), time(0.003-0.003 ms): <.main+5018>
test/lang/reflect.ci:50:[.05cedb, .05cee8) exec(1), time(0.003-0.003 ms): <.main+5031>
test/lang/init.member.ci:34:[.05cee8, .05ceed) exec(1), time(0.002-0.002 ms): <.main+5044>
test/lang/init.member.ci:37:[.05ceed, .05cef6) exec(1), time(0.002-0.002 ms): <.main+5049>
test/lang/init.member.ci:40:[.05cef6, .05ceff) exec(1), time(0.001-0.001 ms): <.main+5058>
::[.05cf08, .05cf0d) exec(1), time(0.001-0.001 ms): <.main+5076>
test/lang/init.member.ci:43:[.05ceff, .05cf0d) exec(1-1), time(0.000 ms): <.main+5067>
test/lang/init.member.ci:46:[.05cf16, .05cf1f) exec(1), time(0.001-0.001 ms): <.main+5090>
test/lang/init.member.ci:46:[.05cf0d, .05cf1f) exec(1-1), time(0.000 ms): <.main+5081>
test/lang/init.member.ci:49:[.05cf28, .05cf31) exec(1), time(0.001-0.001 ms): <.main+5108>
test/lang/init.member.ci:49:[.05cf1f, .05cf31) exec(1-1), time(0.000 ms): <.main+5099>
test/lang/init.member.ci:54:[.05cf3a, .05cf43) exec(1), time(0.002-0.002 ms): <.main+5126>
test/lang/init.member.ci:55:[.05cf43, .05cf4c) exec(1), time(0.001-0.001 ms): <.main+5135>
test/lang/init.member.ci:56:[.05cf4c, .05cf55) exec(1), time(0.001-0.001 ms): <.main+5144>
test/lang/init.member.ci:59:[.05cf55, .05cf5e) exec(1), time(0.001-0.001 ms): <.main+5153>
test/lang/init.member.ci:60:[.05cf5e, .05cf67) exec(1), time(0.002-0.002 ms): <.main+5162>
test/lang/init.member.ci:64:[.05cf67, .05cf70) exec(1), time(0.002-0.002 ms): <.main+5171>
test/lang/init.member.ci:65:[.05cf70, .05cf79) exec(1), time(0.001-0.001 ms): <.main+5180>
test/lang/init.member.ci:52:[.05cf31, .05cf79) exec(1-1), time(0.000 ms): <.main+5117>
test/lang/init.method.ci:18:[.05cf79, .05cf82) exec(1), time(0.001-0.001 ms): <.main+5189>
::[.05cf8b, .05cf93) exec(1), time(0.001-0.001 ms): <.main+5207>
::[.05cf93, .05cf9c) exec(1), time(0.002-0.002 ms): <.main+5215>
test/lang/init.method.ci:62:[.05cf82, .05cf9c) exec(1-1), time(0.000 ms): <.main+5198>
test/lang/init.array.ci:11:[.05cfa9, .05cfb6) exec(1), time(0.001-0.001 ms): <.main+5237>
test/lang/init.array.ci:11:[.05cfb6, .05cfc3) exec(1), time(0.002-0.002 ms): <.main+5250>
test/lang/init.array.ci:11:[.05cfc3, .05cfd0) exec(1), time(0.002-0.002 ms): <.main+5263>
test/lang/init.array.ci:11:[.05cfd0, .05cfdd) exec(1), time(0.001-0.001 ms): <.main+5276>
test/lang/init.array.ci:11:[.05cfdd, .05cfea) exec(1), time(0.001-0.001 ms): <.main+5289>
test/lang/init.array.ci:11:[.05cfea, .05cff7) exec(1), time(0.002-0.002 ms): <.main+5302>
test/lang/init.array.ci:11:[.05cf9c, .05cff7) exec(1-1), time(0.000 ms): <.main+5224>
test/lang/init.array.ci:18:[.05cff7, .05d000) exec(1), time(0.002-0.002 ms): <.main+5315>
test/lang/init.array.ci:19:[.05d000, .05d00a) exec(1), time(0.002-0.002 ms): <.main+5324>
test/lang/init.array.ci:22:[.05d00a, .05d013) exec(1), time(0.002-0.002 ms): <.main+5334>
test/lang/init.array.ci:23:[.05d013, .05d021) exec(1), time(0.003-0.003 ms): <.main+5343>
test/lang/init.array.ci:26:[.05d021, .05d029) exec(1), time(0.001-0.001 ms): <.main+5357>
test/lang/init.array.ci:27:[.05d029, .05d031) exec(1), time(0.001-0.001 ms): <.main+5365>
test/lang/init.array.ci:30:[.05d031, .05d039) exec(1), time(0.001-0.001 ms): <.main+5373>
test/lang/init.array.ci:34:[.05d044, .05d04f) exec(1), time(0.002-0.002 ms): <.main+5392>
test/lang/init.array.ci:34:[.05d04f, .05d05a) exec(1), time(0.002-0.002 ms): <.main+5403>
test/lang/init.array.ci:34:[.05d05a, .05d065) exec(1), time(0.002-0.002 ms): <.main+5414>
test/lang/init.array.ci:34:[.05d065, .05d070) exec(1), time(0.002-0.002 ms): <.main+5425>
test/lang/init.array.ci:34:[.05d070, .05d07b) exec(1), time(0.002-0.002 ms): <.main+5436>
test/lang/init.array.ci:34:[.05d07b, .05d082) exec(1), time(0.002-0.002 ms): <.main+5447>
test/lang/init.array.ci:34:[.05d039, .05d082) exec(1-1), time(0.000 ms): <.main+5381>
test/lang/init.array.ci:37:[.05d082, .05d08b) exec(1), time(0.002-0.002 ms): <.main+5454>
test/lang/init.array.ci:40:[.05d08b, .05d099) exec(1), time(0.002-0.002 ms): <.main+5463>
test/lang/recUnion.ci:26:[.05d0a0, .05d0a7) exec(1), time(0.003-0.003 ms): <.main+5484>
test/lang/recUnion.ci:26:[.05d0a7, .05d0ae) exec(1), time(0.002-0.002 ms): <.main+5491>
test/lang/recUnion.ci:26:[.05d099, .05d0ae) exec(1-1), time(0.000 ms): <.main+5477>
test/lang/recUnion.ci:27:[.05d0b5, .05d0c0) exec(1), time(0.003-0.003 ms): <.main+5505>
test/lang/recUnion.ci:27:[.05d0c0, .05d0c7) exec(1), time(0.002-0.002 ms): <.main+5516>
test/lang/recUnion.ci:27:[.05d0ae, .05d0c7) exec(1-1), time(0.000 ms): <.main+5498>
test/lang/recUnion.ci:28:[.05d0d2, .05d0dd) exec(1), time(0.003-0.003 ms): <.main+5534>
test/lang/recUnion.ci:28:[.05d0dd, .05d0e8) exec(1), time(0.002-0.002 ms): <.main+5545>
test/lang/recUnion.ci:28:[.05d0c7, .05d0e8) exec(1-1), time(0.000 ms): <.main+5523>
test/lang/recUnion.ci:30:[.05d0e8, .05d0f1) exec(1), time(0.001-0.001 ms): <.main+5556>
test/lang/recUnion.ci:31:[.05d0f8, .05d0ff) exec(1), time(0.002-0.002 ms): <.main+5572>
test/lang/recUnion.ci:31:[.05d0ff, .05d10a) exec(1), time(0.002-0.002 ms): <.main+5579>
test/lang/recUnion.ci:31:[.05d0f1, .05d10a) exec(1-1), time(0.000 ms): <.main+5565>
test/lang/useOperator.ci:5:[.05d10a, .05d113) exec(1), time(0.002-0.002 ms): <.main+5590>
test/lang/useOperator.ci:7:[.05d113, .05d11e) exec(1), time(0.002-0.002 ms): <.main+5599>
test/lang/useOperator.ci:8:[.05d11e, .05d129) exec(1), time(0.002-0.002 ms): <.main+5610>
test/lang/useOperator.ci:17:[.05d129, .05d13c) exec(1), time(0.005-0.005 ms): <.main+5621>
test/lang/useOperator.ci:18:[.05d13c, .05d14f) exec(1), time(0.005-0.005 ms): <.main+5640>
test/lang/useOperator.ci:19:[.05d14f, .05d162) exec(1), time(0.006-0.006 ms): <.main+5659>
test/lang/useOperator.ci:22:[.05d162, .05d16f) exec(1), time(0.004-0.004 ms): <.main+5678>
test/lang/useOperator.ci:23:[.05d16f, .05d182) exec(1), time(0.006-0.006 ms): <.main+5691>
test/lang/useOperator.ci:24:[.05d182, .05d196) exec(1), time(0.006-0.006 ms): <.main+5710>
test/lang/useOperator.ci:25:[.05d196, .05d1a9) exec(1), time(0.005-0.005 ms): <.main+5730>
test/lang/useOperator.ci:26:[.05d1a9, .05d1bd) exec(1), time(0.006-0.006 ms): <.main+5749>
test/lang/useOperator.ci:27:[.05d1bd, .05d1d0) exec(1), time(0.005-0.005 ms): <.main+5769>
test/lang/useOperator.ci:28:[.05d1d0, .05d1e4) exec(1), time(0.006-0.006 ms): <.main+5788>
test/lang/useOperator.ci:30:[.05d1e4, .05d1ef) exec(1), time(0.003-0.003 ms): <.main+5808>
test/lang/useOperator.ci:31:[.05d1ef, .05d1fa) exec(1), time(0.002-0.002 ms): <.main+5819>
test/lang/useOperator.ci:32:[.05d1fa, .05d206) exec(1), time(0.003-0.003 ms): <.main+5830>
test/lang/useOperator.ci:33:[.05d206, .05d213) exec(1), time(0.004-0.004 ms): <.main+5842>
test/lang/useOperator.ci:34:[.05d213, .05d220) exec(1), time(0.003-0.003 ms): <.main+5855>
test/lang/useOperator.ci:35:[.05d220, .05d233) exec(1), time(0.005-0.005 ms): <.main+5868>
test/lang/useOperator.ci:36:[.05d233, .05d246) exec(1), time(0.005-0.005 ms): <.main+5887>
test/lang/useOperator.ci:37:[.05d246, .05d259) exec(1), time(0.005-0.005 ms): <.main+5906>
test/lang/useOperator.ci:38:[.05d259, .05d26c) exec(1), time(0.005-0.005 ms): <.main+5925>
test/lang/useOperator.ci:39:[.05d26c, .05d27f) exec(1), time(0.005-0.005 ms): <.main+5944>
test/lang/useOperator.ci:40:[.05d27f, .05d292) exec(1), time(0.005-0.005 ms): <.main+5963>
test/lang/useOperator.ci:41:[.05d292, .05d2a5) exec(1), time(0.005-0.005 ms): <.main+5982>
test/lang/useOperator.ci:42:[.05d2a5, .05d2b8) exec(1), time(0.005-0.005 ms): <.main+6001>
test/lang/useOperator.ci:43:[.05d2b8, .05d2c9) exec(1), time(0.004-0.004 ms): <.main+6020>
test/lang/useOperator.ci:44:[.05d2c9, .05d2da) exec(1), time(0.005-0.005 ms): <.main+6037>
test/lang/useOperator.ci:45:[.05d2da, .05d2e8) exec(1), time(0.005-0.005 ms): <.main+6054>
test/lang/useOperator.ci:46:[.05d2e8, .05d2fb) exec(1), time(0.006-0.006 ms): <.main+6068>
test/lang/useOperator.ci:47:[.05d2fb, .05d30f) exec(1), time(0.007-0.007 ms): <.main+6087>
test/lang/useOperator.ci:48:[.05d30f, .05d322) exec(1), time(0.006-0.006 ms): <.main+6107>
test/lang/useOperator.ci:49:[.05d322, .05d336) exec(1), time(0.007-0.007 ms): <.main+6126>
test/lang/useOperator.ci:50:[.05d336, .05d349) exec(1), time(0.006-0.006 ms): <.main+6146>
test/lang/useOperator.ci:51:[.05d349, .05d35d) exec(1), time(0.006-0.006 ms): <.main+6165>
test/lang/useOperator.ci:53:[.05d35d, .05d368) exec(1), time(0.002-0.002 ms): <.main+6185>
test/lang/useOperator.ci:54:[.05d368, .05d373) exec(1), time(0.002-0.002 ms): <.main+6196>
test/lang/useOperator.ci:55:[.05d373, .05d37f) exec(1), time(0.003-0.003 ms): <.main+6207>
test/lang/useOperator.ci:56:[.05d37f, .05d38c) exec(1), time(0.004-0.004 ms): <.main+6219>
test/lang/useOperator.ci:57:[.05d38c, .05d399) exec(1), time(0.004-0.004 ms): <.main+6232>
test/lang/useOperator.ci:58:[.05d399, .05d3ac) exec(1), time(0.006-0.006 ms): <.main+6245>
test/lang/useOperator.ci:59:[.05d3ac, .05d3bf) exec(1), time(0.006-0.006 ms): <.main+6264>
test/lang/useOperator.ci:60:[.05d3bf, .05d3d2) exec(1), time(0.006-0.006 ms): <.main+6283>
test/lang/useOperator.ci:61:[.05d3d2, .05d3e5) exec(1), time(0.006-0.006 ms): <.main+6302>
test/lang/useOperator.ci:62:[.05d3e5, .05d3f8) exec(1), time(0.006-0.006 ms): <.main+6321>
test/lang/useOperator.ci:63:[.05d3f8, .05d40b) exec(1), time(0.006-0.006 ms): <.main+6340>
test/lang/useOperator.ci:64:[.05d40b, .05d41e) exec(1), time(0.005-0.005 ms): <.main+6359>
test/lang/useOperator.ci:65:[.05d41e, .05d431) exec(1), time(0.005-0.005 ms): <.main+6378>
test/lang/useOperator.ci:66:[.05d431, .05d442) exec(1), time(0.005-0.005 ms): <.main+6397>
test/lang/useOperator.ci:67:[.05d442, .05d453) exec(1), time(0.005-0.005 ms): <.main+6414>
test/lang/useOperator.ci:68:[.05d453, .05d461) exec(1), time(0.005-0.005 ms): <.main+6431>
test/lang/useOperator.ci:69:[.05d461, .05d474) exec(1), time(0.006-0.006 ms): <.main+6445>
test/lang/useOperator.ci:70:[.05d474, .05d488) exec(1), time(0.007-0.007 ms): <.main+6464>
test/lang/useOperator.ci:71:[.05d488, .05d49b) exec(1), time(0.005-0.005 ms): <.main+6484>
test/lang/useOperator.ci:72:[.05d49b, .05d4af) exec(1), time(0.007-0.007 ms): <.main+6503>
test/lang/useOperator.ci:73:[.05d4af, .05d4c2) exec(1), time(0.006-0.006 ms): <.main+6523>
test/lang/useOperator.ci:74:[.05d4c2, .05d4d6) exec(1), time(0.007-0.007 ms): <.main+6542>
test/lang/useOperator.ci:76:[.05d4d6, .05d4e1) exec(1), time(0.002-0.002 ms): <.main+6562>
test/lang/useOperator.ci:77:[.05d4e1, .05d4ec) exec(1), time(0.002-0.002 ms): <.main+6573>
test/lang/useOperator.ci:78:[.05d4ec, .05d4f8) exec(1), time(0.003-0.003 ms): <.main+6584>
test/lang/useOperator.ci:79:[.05d4f8, .05d505) exec(1), time(0.005-0.005 ms): <.main+6596>
test/lang/useOperator.ci:80:[.05d505, .05d512) exec(1), time(0.004-0.004 ms): <.main+6609>
test/lang/useOperator.ci:81:[.05d512, .05d525) exec(1), time(0.006-0.006 ms): <.main+6622>
test/lang/useOperator.ci:82:[.05d525, .05d538) exec(1), time(0.005-0.005 ms): <.main+6641>
test/lang/useOperator.ci:83:[.05d538, .05d54b) exec(1), time(0.006-0.006 ms): <.main+6660>
test/lang/useOperator.ci:84:[.05d54b, .05d55e) exec(1), time(0.005-0.005 ms): <.main+6679>
test/lang/useOperator.ci:85:[.05d55e, .05d571) exec(1), time(0.006-0.006 ms): <.main+6698>
test/lang/useOperator.ci:86:[.05d571, .05d584) exec(1), time(0.006-0.006 ms): <.main+6717>
test/lang/useOperator.ci:87:[.05d584, .05d597) exec(1), time(0.007-0.007 ms): <.main+6736>
test/lang/useOperator.ci:88:[.05d597, .05d5aa) exec(1), time(0.007-0.007 ms): <.main+6755>
test/lang/useOperator.ci:89:[.05d5aa, .05d5bb) exec(1), time(0.005-0.005 ms): <.main+6774>
test/lang/useOperator.ci:90:[.05d5bb, .05d5cc) exec(1), time(0.005-0.005 ms): <.main+6791>
test/lang/useOperator.ci:91:[.05d5cc, .05d5da) exec(1), time(0.005-0.005 ms): <.main+6808>
test/lang/useOperator.ci:92:[.05d5da, .05d5ed) exec(1), time(0.006-0.006 ms): <.main+6822>
test/lang/useOperator.ci:93:[.05d5ed, .05d601) exec(1), time(0.007-0.007 ms): <.main+6841>
test/lang/useOperator.ci:94:[.05d601, .05d614) exec(1), time(0.005-0.005 ms): <.main+6861>
test/lang/useOperator.ci:95:[.05d614, .05d628) exec(1), time(0.007-0.007 ms): <.main+6880>
test/lang/useOperator.ci:96:[.05d628, .05d63b) exec(1), time(0.006-0.006 ms): <.main+6900>
test/lang/useOperator.ci:97:[.05d63b, .05d64f) exec(1), time(0.007-0.007 ms): <.main+6919>
test/lang/useOperator.ci:99:[.05d64f, .05d65a) exec(1), time(0.003-0.003 ms): <.main+6939>
test/lang/useOperator.ci:100:[.05d65a, .05d665) exec(1), time(0.003-0.003 ms): <.main+6950>
test/lang/useOperator.ci:101:[.05d665, .05d671) exec(1), time(0.004-0.004 ms): <.main+6961>
test/lang/useOperator.ci:102:[.05d671, .05d67e) exec(1), time(0.004-0.004 ms): <.main+6973>
test/lang/useOperator.ci:103:[.05d67e, .05d68b) exec(1), time(0.004-0.004 ms): <.main+6986>
test/lang/useOperator.ci:104:[.05d68b, .05d69e) exec(1), time(0.006-0.006 ms): <.main+6999>
test/lang/useOperator.ci:105:[.05d69e, .05d6b1) exec(1), time(0.005-0.005 ms): <.main+7018>
test/lang/useOperator.ci:106:[.05d6b1, .05d6c4) exec(1), time(0.007-0.007 ms): <.main+7037>
test/lang/useOperator.ci:107:[.05d6c4, .05d6d7) exec(1), time(0.007-0.007 ms): <.main+7056>
test/lang/useOperator.ci:108:[.05d6d7, .05d6ea) exec(1), time(0.007-0.007 ms): <.main+7075>
test/lang/useOperator.ci:109:[.05d6ea, .05d6fd) exec(1), time(0.005-0.005 ms): <.main+7094>
test/lang/useOperator.ci:110:[.05d6fd, .05d710) exec(1), time(0.005-0.005 ms): <.main+7113>
test/lang/useOperator.ci:111:[.05d710, .05d723) exec(1), time(0.006-0.006 ms): <.main+7132>
test/lang/useOperator.ci:112:[.05d723, .05d734) exec(1), time(0.005-0.005 ms): <.main+7151>
test/lang/useOperator.ci:113:[.05d734, .05d745) exec(1), time(0.005-0.005 ms): <.main+7168>
test/lang/useOperator.ci:114:[.05d745, .05d753) exec(1), time(0.005-0.005 ms): <.main+7185>
test/lang/useOperator.ci:115:[.05d753, .05d766) exec(1), time(0.006-0.006 ms): <.main+7199>
test/lang/useOperator.ci:116:[.05d766, .05d77a) exec(1), time(0.007-0.007 ms): <.main+7218>
test/lang/useOperator.ci:117:[.05d77a, .05d78d) exec(1), time(0.005-0.005 ms): <.main+7238>
test/lang/useOperator.ci:118:[.05d78d, .05d7a1) exec(1), time(0.006-0.006 ms): <.main+7257>
test/lang/useOperator.ci:119:[.05d7a1, .05d7b4) exec(1), time(0.006-0.006 ms): <.main+7277>
test/lang/useOperator.ci:120:[.05d7b4, .05d7c8) exec(1), time(0.007-0.007 ms): <.main+7296>
test/lang/useOperator.ci:122:[.05d7c8, .05d7d3) exec(1), time(0.003-0.003 ms): <.main+7316>
test/lang/useOperator.ci:123:[.05d7d3, .05d7de) exec(1), time(0.003-0.003 ms): <.main+7327>
test/lang/useOperator.ci:124:[.05d7de, .05d7ea) exec(1), time(0.003-0.003 ms): <.main+7338>
test/lang/useOperator.ci:125:[.05d7ea, .05d7f7) exec(1), time(0.004-0.004 ms): <.main+7350>
test/lang/useOperator.ci:126:[.05d7f7, .05d804) exec(1), time(0.004-0.004 ms): <.main+7363>
test/lang/useOperator.ci:127:[.05d804, .05d817) exec(1), time(0.006-0.006 ms): <.main+7376>
test/lang/useOperator.ci:128:[.05d817, .05d82a) exec(1), time(0.006-0.006 ms): <.main+7395>
test/lang/useOperator.ci:129:[.05d82a, .05d83d) exec(1), time(0.006-0.006 ms): <.main+7414>
test/lang/useOperator.ci:130:[.05d83d, .05d850) exec(1), time(0.006-0.006 ms): <.main+7433>
test/lang/useOperator.ci:131:[.05d850, .05d863) exec(1), time(0.006-0.006 ms): <.main+7452>
test/lang/useOperator.ci:132:[.05d863, .05d876) exec(1), time(0.006-0.006 ms): <.main+7471>
test/lang/useOperator.ci:133:[.05d876, .05d889) exec(1), time(0.006-0.006 ms): <.main+7490>
test/lang/useOperator.ci:134:[.05d889, .05d89c) exec(1), time(0.006-0.006 ms): <.main+7509>
test/lang/useOperator.ci:135:[.05d89c, .05d8ad) exec(1), time(0.005-0.005 ms): <.main+7528>
test/lang/useOperator.ci:136:[.05d8ad, .05d8be) exec(1), time(0.005-0.005 ms): <.main+7545>
test/lang/useOperator.ci:137:[.05d8be, .05d8cc) exec(1), time(0.005-0.005 ms): <.main+7562>
test/lang/useOperator.ci:138:[.05d8cc, .05d8df) exec(1), time(0.006-0.006 ms): <.main+7576>
test/lang/useOperator.ci:139:[.05d8df, .05d8f3) exec(1), time(0.007-0.007 ms): <.main+7595>
test/lang/useOperator.ci:140:[.05d8f3, .05d906) exec(1), time(0.006-0.006 ms): <.main+7615>
test/lang/useOperator.ci:141:[.05d906, .05d91a) exec(1), time(0.007-0.007 ms): <.main+7634>
test/lang/useOperator.ci:142:[.05d91a, .05d92d) exec(1), time(0.006-0.006 ms): <.main+7654>
test/lang/useOperator.ci:143:[.05d92d, .05d941) exec(1), time(0.007-0.007 ms): <.main+7673>
test/lang/useOperator.ci:145:[.05d941, .05d94a) exec(1), time(0.002-0.002 ms): <.main+7693>
test/lang/useOperator.ci:146:[.05d94a, .05d953) exec(1), time(0.001-0.001 ms): <.main+7702>
test/lang/useOperator.ci:147:[.05d953, .05d95b) exec(1), time(0.001-0.001 ms): <.main+7711>
test/lang/useOperator.ci:148:[.05d95b, .05d964) exec(1), time(0.002-0.002 ms): <.main+7719>
test/lang/useOperator.ci:149:[.05d964, .05d96d) exec(1), time(0.002-0.002 ms): <.main+7728>
test/lang/useOperator.ci:150:[.05d96d, .05d97a) exec(1), time(0.003-0.003 ms): <.main+7737>
test/lang/useOperator.ci:151:[.05d97a, .05d987) exec(1), time(0.003-0.003 ms): <.main+7750>
test/lang/useOperator.ci:152:[.05d987, .05d994) exec(1), time(0.003-0.003 ms): <.main+7763>
test/lang/useOperator.ci:153:[.05d994, .05d9a1) exec(1), time(0.003-0.003 ms): <.main+7776>
test/lang/useOperator.ci:154:[.05d9a1, .05d9ae) exec(1), time(0.003-0.003 ms): <.main+7789>
test/lang/useOperator.ci:155:[.05d9ae, .05d9bb) exec(1), time(0.003-0.003 ms): <.main+7802>
test/lang/useOperator.ci:156:[.05d9bb, .05d9c8) exec(1), time(0.003-0.003 ms): <.main+7815>
test/lang/useOperator.ci:157:[.05d9c8, .05d9d5) exec(1), time(0.004-0.004 ms): <.main+7828>
test/lang/useOperator.ci:158:[.05d9d5, .05d9e2) exec(1), time(0.004-0.004 ms): <.main+7841>
test/lang/useOperator.ci:159:[.05d9e2, .05d9ef) exec(1), time(0.004-0.004 ms): <.main+7854>
test/lang/useOperator.ci:160:[.05d9ef, .05d9fb) exec(1), time(0.005-0.005 ms): <.main+7867>
test/lang/useOperator.ci:161:[.05d9fb, .05da0a) exec(1), time(0.005-0.005 ms): <.main+7879>
test/lang/useOperator.ci:162:[.05da0a, .05da1a) exec(1), time(0.005-0.005 ms): <.main+7894>
test/lang/useOperator.ci:163:[.05da1a, .05da29) exec(1), time(0.004-0.004 ms): <.main+7910>
test/lang/useOperator.ci:164:[.05da29, .05da39) exec(1), time(0.005-0.005 ms): <.main+7925>
test/lang/useOperator.ci:165:[.05da39, .05da48) exec(1), time(0.005-0.005 ms): <.main+7941>
test/lang/useOperator.ci:166:[.05da48, .05da58) exec(1), time(0.005-0.005 ms): <.main+7956>
test/lang/useOperator.ci:168:[.05da58, .05da61) exec(1), time(0.002-0.002 ms): <.main+7972>
test/lang/useOperator.ci:169:[.05da61, .05da6a) exec(1), time(0.001-0.001 ms): <.main+7981>
test/lang/useOperator.ci:170:[.05da6a, .05da72) exec(1), time(0.001-0.001 ms): <.main+7990>
test/lang/useOperator.ci:171:[.05da72, .05da7b) exec(1), time(0.002-0.002 ms): <.main+7998>
test/lang/useOperator.ci:172:[.05da7b, .05da84) exec(1), time(0.003-0.003 ms): <.main+8007>
test/lang/useOperator.ci:173:[.05da84, .05da91) exec(1), time(0.004-0.004 ms): <.main+8016>
test/lang/useOperator.ci:174:[.05da91, .05da9e) exec(1), time(0.004-0.004 ms): <.main+8029>
test/lang/useOperator.ci:175:[.05da9e, .05daab) exec(1), time(0.004-0.004 ms): <.main+8042>
test/lang/useOperator.ci:176:[.05daab, .05dab8) exec(1), time(0.004-0.004 ms): <.main+8055>
test/lang/useOperator.ci:177:[.05dab8, .05dac5) exec(1), time(0.004-0.004 ms): <.main+8068>
test/lang/useOperator.ci:178:[.05dac5, .05dad2) exec(1), time(0.004-0.004 ms): <.main+8081>
test/lang/useOperator.ci:179:[.05dad2, .05dadf) exec(1), time(0.004-0.004 ms): <.main+8094>
test/lang/useOperator.ci:180:[.05dadf, .05daec) exec(1), time(0.004-0.004 ms): <.main+8107>
test/lang/useOperator.ci:181:[.05daec, .05daf9) exec(1), time(0.004-0.004 ms): <.main+8120>
test/lang/useOperator.ci:182:[.05daf9, .05db06) exec(1), time(0.004-0.004 ms): <.main+8133>
test/lang/useOperator.ci:183:[.05db06, .05db12) exec(1), time(0.004-0.004 ms): <.main+8146>
test/lang/useOperator.ci:184:[.05db12, .05db21) exec(1), time(0.004-0.004 ms): <.main+8158>
test/lang/useOperator.ci:185:[.05db21, .05db31) exec(1), time(0.005-0.005 ms): <.main+8173>
test/lang/useOperator.ci:186:[.05db31, .05db40) exec(1), time(0.004-0.004 ms): <.main+8189>
test/lang/useOperator.ci:187:[.05db40, .05db50) exec(1), time(0.005-0.005 ms): <.main+8204>
test/lang/useOperator.ci:188:[.05db50, .05db5f) exec(1), time(0.004-0.004 ms): <.main+8220>
test/lang/useOperator.ci:189:[.05db5f, .05db6f) exec(1), time(0.005-0.005 ms): <.main+8235>
test/lang/useOperator.ci:191:[.05db6f, .05db7c) exec(1), time(0.002-0.002 ms): <.main+8251>
test/lang/useOperator.ci:192:[.05db7c, .05db89) exec(1), time(0.002-0.002 ms): <.main+8264>
test/lang/useOperator.ci:193:[.05db89, .05db91) exec(1), time(0.002-0.002 ms): <.main+8277>
test/lang/useOperator.ci:194:[.05db91, .05db9a) exec(1), time(0.003-0.003 ms): <.main+8285>
test/lang/useOperator.ci:195:[.05db9a, .05dba3) exec(1), time(0.003-0.003 ms): <.main+8294>
test/lang/useOperator.ci:196:[.05dba3, .05dbb0) exec(1), time(0.003-0.003 ms): <.main+8303>
test/lang/useOperator.ci:197:[.05dbb0, .05dbbd) exec(1), time(0.003-0.003 ms): <.main+8316>
test/lang/useOperator.ci:198:[.05dbbd, .05dbca) exec(1), time(0.003-0.003 ms): <.main+8329>
test/lang/useOperator.ci:199:[.05dbca, .05dbd7) exec(1), time(0.003-0.003 ms): <.main+8342>
test/lang/useOperator.ci:200:[.05dbd7, .05dbe4) exec(1), time(0.004-0.004 ms): <.main+8355>
test/lang/useOperator.ci:201:[.05dbe4, .05dbf1) exec(1), time(0.004-0.004 ms): <.main+8368>
test/lang/useOperator.ci:202:[.05dbf1, .05dbfe) exec(1), time(0.004-0.004 ms): <.main+8381>
test/lang/useOperator.ci:203:[.05dbfe, .05dc0b) exec(1), time(0.004-0.004 ms): <.main+8394>
test/lang/useOperator.ci:204:[.05dc0b, .05dc18) exec(1), time(0.004-0.004 ms): <.main+8407>
test/lang/useOperator.ci:205:[.05dc18, .05dc25) exec(1), time(0.004-0.004 ms): <.main+8420>
test/lang/useOperator.ci:206:[.05dc25, .05dc31) exec(1), time(0.005-0.005 ms): <.main+8433>
test/lang/useOperator.ci:207:[.05dc31, .05dc40) exec(1), time(0.004-0.004 ms): <.main+8445>
test/lang/useOperator.ci:208:[.05dc40, .05dc50) exec(1), time(0.006-0.006 ms): <.main+8460>
test/lang/useOperator.ci:209:[.05dc50, .05dc5f) exec(1), time(0.005-0.005 ms): <.main+8476>
test/lang/useOperator.ci:210:[.05dc5f, .05dc6f) exec(1), time(0.006-0.006 ms): <.main+8491>
test/lang/useOperator.ci:211:[.05dc6f, .05dc7e) exec(1), time(0.004-0.004 ms): <.main+8507>
test/lang/useOperator.ci:212:[.05dc7e, .05dc8e) exec(1), time(0.005-0.005 ms): <.main+8522>
test/lang/useOperator.ci:214:[.05dc8e, .05dc9b) exec(1), time(0.002-0.002 ms): <.main+8538>
test/lang/useOperator.ci:215:[.05dc9b, .05dca8) exec(1), time(0.001-0.001 ms): <.main+8551>
test/lang/useOperator.ci:216:[.05dca8, .05dcb0) exec(1), time(0.002-0.002 ms): <.main+8564>
test/lang/useOperator.ci:217:[.05dcb0, .05dcb9) exec(1), time(0.003-0.003 ms): <.main+8572>
test/lang/useOperator.ci:218:[.05dcb9, .05dcc2) exec(1), time(0.003-0.003 ms): <.main+8581>
test/lang/useOperator.ci:219:[.05dcc2, .05dccf) exec(1), time(0.004-0.004 ms): <.main+8590>
test/lang/useOperator.ci:220:[.05dccf, .05dcdc) exec(1), time(0.004-0.004 ms): <.main+8603>
test/lang/useOperator.ci:221:[.05dcdc, .05dce9) exec(1), time(0.004-0.004 ms): <.main+8616>
test/lang/useOperator.ci:222:[.05dce9, .05dcf6) exec(1), time(0.004-0.004 ms): <.main+8629>
test/lang/useOperator.ci:223:[.05dcf6, .05dd03) exec(1), time(0.004-0.004 ms): <.main+8642>
test/lang/useOperator.ci:224:[.05dd03, .05dd10) exec(1), time(0.003-0.003 ms): <.main+8655>
test/lang/useOperator.ci:225:[.05dd10, .05dd1d) exec(1), time(0.003-0.003 ms): <.main+8668>
test/lang/useOperator.ci:226:[.05dd1d, .05dd2a) exec(1), time(0.004-0.004 ms): <.main+8681>
test/lang/useOperator.ci:227:[.05dd2a, .05dd37) exec(1), time(0.003-0.003 ms): <.main+8694>
test/lang/useOperator.ci:228:[.05dd37, .05dd44) exec(1), time(0.004-0.004 ms): <.main+8707>
test/lang/useOperator.ci:229:[.05dd44, .05dd50) exec(1), time(0.005-0.005 ms): <.main+8720>
test/lang/useOperator.ci:230:[.05dd50, .05dd5f) exec(1), time(0.005-0.005 ms): <.main+8732>
test/lang/useOperator.ci:231:[.05dd5f, .05dd6f) exec(1), time(0.006-0.006 ms): <.main+8747>
test/lang/useOperator.ci:232:[.05dd6f, .05dd7e) exec(1), time(0.005-0.005 ms): <.main+8763>
test/lang/useOperator.ci:233:[.05dd7e, .05dd8e) exec(1), time(0.006-0.006 ms): <.main+8778>
test/lang/useOperator.ci:234:[.05dd8e, .05dd9d) exec(1), time(0.005-0.005 ms): <.main+8794>
test/lang/useOperator.ci:235:[.05dd9d, .05ddad) exec(1), time(0.005-0.005 ms): <.main+8809>
test/lang/useOperator.ci:237:[.05ddad, .05ddb6) exec(1), time(0.002-0.002 ms): <.main+8825>
test/lang/useOperator.ci:238:[.05ddb6, .05ddbf) exec(1), time(0.002-0.002 ms): <.main+8834>
test/lang/useOperator.ci:239:[.05ddbf, .05ddc7) exec(1), time(0.001-0.001 ms): <.main+8843>
test/lang/useOperator.ci:240:[.05ddc7, .05ddd0) exec(1), time(0.003-0.003 ms): <.main+8851>
test/lang/useOperator.ci:242:[.05ddd0, .05dddd) exec(1), time(0.004-0.004 ms): <.main+8860>
test/lang/useOperator.ci:243:[.05dddd, .05ddea) exec(1), time(0.004-0.004 ms): <.main+8873>
test/lang/useOperator.ci:244:[.05ddea, .05ddf7) exec(1), time(0.004-0.004 ms): <.main+8886>
test/lang/useOperator.ci:245:[.05ddf7, .05de04) exec(1), time(0.004-0.004 ms): <.main+8899>
test/lang/useOperator.ci:246:[.05de04, .05de11) exec(1), time(0.005-0.005 ms): <.main+8912>
test/lang/useOperator.ci:252:[.05de11, .05de1d) exec(1), time(0.005-0.005 ms): <.main+8925>
test/lang/useOperator.ci:253:[.05de1d, .05de2c) exec(1), time(0.005-0.005 ms): <.main+8937>
test/lang/useOperator.ci:254:[.05de2c, .05de3c) exec(1), time(0.006-0.006 ms): <.main+8952>
test/lang/useOperator.ci:255:[.05de3c, .05de4b) exec(1), time(0.005-0.005 ms): <.main+8968>
test/lang/useOperator.ci:256:[.05de4b, .05de5b) exec(1), time(0.006-0.006 ms): <.main+8983>
test/lang/useOperator.ci:257:[.05de5b, .05de6a) exec(1), time(0.005-0.005 ms): <.main+8999>
test/lang/useOperator.ci:258:[.05de6a, .05de7a) exec(1), time(0.006-0.006 ms): <.main+9014>
test/lang/useOperator.ci:260:[.05de7a, .05de87) exec(1), time(0.002-0.002 ms): <.main+9030>
test/lang/useOperator.ci:261:[.05de87, .05de94) exec(1), time(0.002-0.002 ms): <.main+9043>
test/lang/useOperator.ci:262:[.05de94, .05de9c) exec(1), time(0.001-0.001 ms): <.main+9056>
test/lang/useOperator.ci:263:[.05de9c, .05dea5) exec(1), time(0.003-0.003 ms): <.main+9064>
test/lang/useOperator.ci:265:[.05dea5, .05deb2) exec(1), time(0.003-0.003 ms): <.main+9073>
test/lang/useOperator.ci:266:[.05deb2, .05debf) exec(1), time(0.004-0.004 ms): <.main+9086>
test/lang/useOperator.ci:267:[.05debf, .05decc) exec(1), time(0.004-0.004 ms): <.main+9099>
test/lang/useOperator.ci:268:[.05decc, .05ded9) exec(1), time(0.005-0.005 ms): <.main+9112>
test/lang/useOperator.ci:269:[.05ded9, .05dee6) exec(1), time(0.004-0.004 ms): <.main+9125>
test/lang/useOperator.ci:275:[.05dee6, .05def2) exec(1), time(0.005-0.005 ms): <.main+9138>
test/lang/useOperator.ci:276:[.05def2, .05df01) exec(1), time(0.005-0.005 ms): <.main+9150>
test/lang/useOperator.ci:277:[.05df01, .05df11) exec(1), time(0.005-0.005 ms): <.main+9165>
test/lang/useOperator.ci:278:[.05df11, .05df20) exec(1), time(0.005-0.005 ms): <.main+9181>
test/lang/useOperator.ci:279:[.05df20, .05df30) exec(1), time(0.006-0.006 ms): <.main+9196>
test/lang/useOperator.ci:280:[.05df30, .05df3f) exec(1), time(0.005-0.005 ms): <.main+9212>
test/lang/useOperator.ci:281:[.05df3f, .05df4f) exec(1), time(0.007-0.007 ms): <.main+9227>
test/lang/useOperator.ci:283:[.05df4f, .05df58) exec(1), time(0.003-0.003 ms): <.main+9243>
test/lang/useOperator.ci:284:[.05df58, .05df61) exec(1), time(0.002-0.002 ms): <.main+9252>
test/lang/useOperator.ci:299:[.05df61, .05df70) exec(1), time(0.006-0.006 ms): <.main+9261>
test/lang/useOperator.ci:300:[.05df70, .05df80) exec(1), time(0.006-0.006 ms): <.main+9276>
test/lang/stmt.if.ci:26:[.05df80, .05df85) exec(1), time(0.002-0.002 ms): <.main+9292>
test/lang/stmt.for.ci:12:[.05df85, .05df8a) exec(1), time(0.002-0.002 ms): <.main+9297>
test/std/test.math.ci:3:[.05df8a, .05dfa2) exec(1), time(0.051-0.051 ms): <.main+9302>
test/std/test.math.ci:4:[.05dfa2, .05dfba) exec(1), time(0.040-0.040 ms): <.main+9326>
test/std/test.math.ci:5:[.05dfba, .05dfd2) exec(1), time(0.041-0.041 ms): <.main+9350>
test/std/test.math.ci:6:[.05dfd2, .05dfea) exec(1), time(0.058-0.058 ms): <.main+9374>
test/std/test.math.ci:7:[.05dfea, .05e002) exec(1), time(0.058-0.058 ms): <.main+9398>
test/std/test.math.ci:8:[.05e002, .05e01a) exec(1), time(0.057-0.057 ms): <.main+9422>
test/std/test.math.ci:10:[.05e01a, .05e037) exec(1), time(0.011-0.011 ms): <.main+9446>
test/std/test.math.ci:11:[.05e037, .05e04c) exec(1), time(0.012-0.012 ms): <.main+9475>
test/std/test.math.ci:12:[.05e04c, .05e069) exec(1), time(0.015-0.015 ms): <.main+9496>
test/std/test.math.ci:13:[.05e069, .05e07e) exec(1), time(0.011-0.011 ms): <.main+9525>
test/std/test.math.ci:14:[.05e07e, .05e08f) exec(1), time(0.012-0.012 ms): <.main+9546>
test/std/test.math.ci:15:[.05e08f, .05e0a4) exec(1), time(0.012-0.012 ms): <.main+9563>
test/std/test.math.ci:17:[.05e0a4, .05e0bc) exec(1), time(0.023-0.023 ms): <.main+9584>
test/std/test.math.ci:18:[.05e0bc, .05e0cb) exec(1), time(0.021-0.021 ms): <.main+9608>
test/std/test.math.ci:19:[.05e0cb, .05e0e3) exec(1), time(0.022-0.022 ms): <.main+9623>
test/std/test.math.ci:20:[.05e0e3, .05e0f8) exec(1), time(0.024-0.024 ms): <.main+9647>
test/std/test.math.ci:21:[.05e0f8, .05e109) exec(1), time(0.024-0.024 ms): <.main+9668>
test/std/test.math.ci:22:[.05e109, .05e11e) exec(1), time(0.023-0.023 ms): <.main+9685>
test/std/test.math.ci:24:[.05e11e, .05e138) exec(1), time(0.025-0.025 ms): <.main+9706>
test/std/test.math.ci:25:[.05e138, .05e152) exec(1), time(0.025-0.025 ms): <.main+9732>
test/std/test.math.ci:26:[.05e152, .05e173) exec(1), time(0.023-0.023 ms): <.main+9758>
test/std/test.math.ci:27:[.05e173, .05e194) exec(1), time(0.024-0.024 ms): <.main+9791>
test/std/test.math.ci:29:[.05e194, .05e1af) exec(1), time(0.028-0.028 ms): <.main+9824>
test/std/test.math.ci:30:[.05e1af, .05e1d1) exec(1), time(0.026-0.026 ms): <.main+9851>
test/std/test.math.ci:32:[.05e1d1, .05e1ea) exec(1), time(0.011-0.011 ms): <.main+9885>
test/std/test.math.ci:33:[.05e1ea, .05e20a) exec(1), time(0.010-0.010 ms): <.main+9910>
test/std/test.math.ci:35:[.05e20a, .05e24a) exec(1), time(0.050-0.050 ms): <.main+9942>
test/std/test.math.ci:36:[.05e24a, .05e29c) exec(1), time(0.047-0.047 ms): <.main+10006>
test/std/test.math.ci:38:[.05e29c, .05e2b5) exec(1), time(0.028-0.028 ms): <.main+10088>
test/std/test.math.ci:39:[.05e2b5, .05e323) exec(1), time(0.079-0.079 ms): <.main+10113>
test/std/test.math.ci:40:[.05e323, .05e33c) exec(1), time(0.080-0.080 ms): <.main+10223>
test/std/test.math.ci:41:[.05e33c, .05e3aa) exec(1), time(0.096-0.096 ms): <.main+10248>
test/std/test.math.ci:43:[.05e3aa, .05e3c3) exec(1), time(0.031-0.031 ms): <.main+10358>
test/std/test.math.ci:44:[.05e3c3, .05e3e9) exec(1), time(0.037-0.037 ms): <.main+10383>
test/std/test.math.ci:45:[.05e3e9, .05e418) exec(1), time(0.046-0.046 ms): <.main+10421>
test/std/test.math.ci:46:[.05e418, .05e48f) exec(1), time(0.088-0.088 ms): <.main+10468>
test/std/test.math.ci:48:[.05e48f, .05e49c) exec(1), time(0.002-0.002 ms): <.main+10587>
test/std/test.math.ci:49:[.05e49c, .05e4b9) exec(1), time(0.046-0.046 ms): <.main+10600>
test/std/test.math.ci:50:[.05e4b9, .05e4c6) exec(1), time(0.002-0.002 ms): <.main+10629>
test/std/test.math.ci:51:[.05e4c6, .05e4e2) exec(1), time(0.008-0.008 ms): <.main+10642>
test/std/test.math.ci:52:[.05e4e2, .05e50f) exec(1), time(0.017-0.017 ms): <.main+10670>
test/std/test.math.ci:53:[.05e50f, .05e54d) exec(1), time(0.025-0.025 ms): <.main+10715>
test/std/test.math.ci:54:[.05e54d, .05e59b) exec(1), time(0.083-0.083 ms): <.main+10777>
test/std/test.math.ci:55:[.05e59b, .05e5f2) exec(1), time(0.080-0.080 ms): <.main+10855>
test/std/test.math.ci:57:[.05e5f2, .05e615) exec(1), time(0.069-0.069 ms): <.main+10942>
test/std/test.math.ci:58:[.05e615, .05e646) exec(1), time(0.098-0.098 ms): <.main+10977>
test/std/test.math.ci:59:[.05e646, .05e668) exec(1), time(0.151-0.151 ms): <.main+11026>
test/std/test.math.ci:60:[.05e668, .05e68a) exec(1), time(0.196-0.196 ms): <.main+11060>
test/std/test.math.ci:61:[.05e68a, .05e6ac) exec(1), time(0.139-0.139 ms): <.main+11094>
test/std/test.math.ci:63:[.05e6ac, .05e6c4) exec(1), time(0.427-0.427 ms): <.main+11128>
test/std/test.math.ci:64:[.05e6c4, .05e6f0) exec(1), time(0.114-0.114 ms): <.main+11152>
test/std/test.math.ci:67:[.05e6f0, .05e712) exec(1), time(0.033-0.033 ms): <.main+11196>
test/std/test.math.ci:68:[.05e712, .05e740) exec(1), time(0.052-0.052 ms): <.main+11230>
test/std/test.math.ci:70:[.05e740, .05e761) exec(1), time(0.049-0.049 ms): <.main+11276>
test/std/test.math.ci:71:[.05e761, .05e779) exec(1), time(0.037-0.037 ms): <.main+11309>
test/std/test.math.ci:72:[.05e779, .05e79a) exec(1), time(0.050-0.050 ms): <.main+11333>
test/std/test.math.ci:74:[.05e79a, .05e7bb) exec(1), time(0.053-0.053 ms): <.main+11366>
test/std/test.math.ci:75:[.05e7bb, .05e7dc) exec(1), time(0.048-0.048 ms): <.main+11399>
test/std/test.math.ci:76:[.05e7dc, .05e7fd) exec(1), time(0.033-0.033 ms): <.main+11432>
test/std/test.math.ci:77:[.05e7fd, .05e81e) exec(1), time(0.046-0.046 ms): <.main+11465>
test/std/test.math.ci:79:[.05e81e, .05e83f) exec(1), time(0.034-0.034 ms): <.main+11498>
test/std/test.math.ci:80:[.05e83f, .05e860) exec(1), time(0.033-0.033 ms): <.main+11531>
test/std/test.math.ci:81:[.05e860, .05e881) exec(1), time(0.033-0.033 ms): <.main+11564>
test/std/test.math.ci:82:[.05e881, .05e8a2) exec(1), time(0.052-0.052 ms): <.main+11597>
test/std/test.math.ci:84:[.05e8a2, .05e8bb) exec(1), time(0.035-0.035 ms): <.main+11630>
test/std/test.math.ci:85:[.05e8bb, .05e8d0) exec(1), time(0.079-0.079 ms): <.main+11655>
test/std/test.math.ci:86:[.05e8d0, .05e8e9) exec(1), time(0.060-0.060 ms): <.main+11676>
test/std/test.math.ci:88:[.05e8e9, .05e902) exec(1), time(0.034-0.034 ms): <.main+11701>
test/std/test.math.ci:89:[.05e902, .05e91b) exec(1), time(0.035-0.035 ms): <.main+11726>
test/std/test.math.ci:90:[.05e91b, .05e934) exec(1), time(0.034-0.034 ms): <.main+11751>
test/std/test.math.ci:91:[.05e934, .05e94d) exec(1), time(0.061-0.061 ms): <.main+11776>
test/std/test.math.ci:93:[.05e94d, .05e966) exec(1), time(0.064-0.064 ms): <.main+11801>
test/std/test.math.ci:94:[.05e966, .05e97f) exec(1), time(0.026-0.026 ms): <.main+11826>
test/std/test.math.ci:95:[.05e97f, .05e998) exec(1), time(0.047-0.047 ms): <.main+11851>
test/std/test.math.ci:96:[.05e998, .05e9b1) exec(1), time(0.040-0.040 ms): <.main+11876>
test/std/memory.ci:13:[.05e9b1, .05e9c3) exec(1), time(0.067-0.067 ms): <.main+11901>
test/std/memory.ci:14:[.05e9c3, .05e9d8) exec(1), time(0.031-0.031 ms): <.main+11919>
test/std/memory.ci:17:[.05e9d8, .05e9e5) exec(1), time(0.028-0.028 ms): <.main+11940>
test/std/memory.ci:18:[.05e9e5, .05e9f2) exec(1), time(0.043-0.043 ms): <.main+11953>
test/std/memory.ci:19:[.05e9f2, .05e9ff) exec(1), time(0.028-0.028 ms): <.main+11966>
test/std/memory.ci:20:[.05e9ff, .05ea0c) exec(1), time(0.027-0.027 ms): <.main+11979>
test/std/memory.ci:26:[.05ea0c, .05ea2f) exec(1), time(0.040-0.040 ms): <.main+11992>
test/std/memory.ci:27:[.05ea2f, .05ea52) exec(1), time(0.037-0.037 ms): <.main+12027>
test/std/memory.ci:29:[.05ea52, .05ea68) exec(1), time(0.029-0.029 ms): <.main+12062>
test/std/memory.ci:30:[.05ea68, .05ea7a) exec(1), time(0.029-0.029 ms): <.main+12084>
test/std/memory.ci:32:[.05ea7a, .05ea9d) exec(1), time(0.037-0.037 ms): <.main+12102>
test/std/memory.ci:33:[.05ea9d, .05eac0) exec(1), time(0.055-0.055 ms): <.main+12137>
test/lang/init.method.ci:78:[.05eac0, .05ead5) exec(1), time(0.160-0.160 ms): <.main+12172>
test/lang/init.method.ci:79:[.05ead5, .05eae9) exec(1), time(0.130-0.130 ms): <.main+12193>
test/lang/init.method.ci:97:[.05eae9, .05eafc) exec(1), time(0.192-0.192 ms): <.main+12213>
test/lang/init.method.ci:98:[.05eafc, .05eb0f) exec(1), time(0.294-0.294 ms): <.main+12232>
test/lang/init.method.ci:101:[.05eb0f, .05eb24) exec(1), time(0.151-0.151 ms): <.main+12251>
test/lang/init.method.ci:102:[.05eb24, .05eb39) exec(1), time(0.225-0.225 ms): <.main+12272>
test/lang/init.method.ci:103:[.05eb39, .05eb4d) exec(1), time(0.132-0.132 ms): <.main+12293>
test/lang/init.array.ci:35:[.05eb4d, .05eb70) exec(1), time(0.082-0.082 ms): <.main+12313>
test/lang/init.array.ci:38:[.05eb70, .05eb92) exec(1), time(0.042-0.042 ms): <.main+12348>
test/lang/init.array.ci:41:[.05eb92, .05ebb4) exec(1), time(0.050-0.050 ms): <.main+12382>
test/lang/init.array.ci:48:[.05ebb4, .05ebe9) exec(1), time(0.006-0.006 ms): <.main+12416>
test/lang/init.array.ci:49:[.05ebe9, .05ec26) exec(1), time(0.005-0.005 ms): <.main+12469>
test/lang/init.array.ci:56:[.05ec26, .05ec3f) exec(1), time(0.024-0.024 ms): <.main+12530>
test/lang/init.array.ci:57:[.05ec3f, .05ec57) exec(1), time(0.024-0.024 ms): <.main+12555>
test/lang/init.array.ci:58:[.05ec57, .05ec6f) exec(1), time(0.023-0.023 ms): <.main+12579>
test/lang/init.array.ci:60:[.05ec6f, .05ec8f) exec(1), time(0.052-0.052 ms): <.main+12603>
test/lang/init.array.ci:61:[.05ec8f, .05ecae) exec(1), time(0.051-0.051 ms): <.main+12635>
test/lang/init.array.ci:62:[.05ecae, .05ecd7) exec(1), time(0.051-0.051 ms): <.main+12666>
test/lang/init.array.ci:63:[.05ecd7, .05ecfa) exec(1), time(0.050-0.050 ms): <.main+12707>
test/lang/init.array.ci:64:[.05ecfa, .05ed1d) exec(1), time(0.050-0.050 ms): <.main+12742>
test/lang/init.array.ci:67:[.05ed22, .05ed2b) exec(7), time(0.046-0.046 ms): <.main+12782>
test/lang/init.array.ci:68:[.05ed2b, .05ed69) exec(7), time(0.070-0.070 ms): <.main+12791>
test/lang/init.array.ci:69:[.05ed69, .05eda6) exec(7), time(0.064-0.064 ms): <.main+12853>
test/lang/init.array.ci:70:[.05eda6, .05ede3) exec(7), time(0.060-0.060 ms): <.main+12914>
test/lang/init.array.ci:72:[.05ede3, .05ee27) exec(7), time(0.276-0.276 ms): <.main+12975>
test/lang/init.array.ci:73:[.05ee27, .05ee6a) exec(7), time(0.317-0.317 ms): <.main+13043>
test/lang/init.array.ci:74:[.05ee6a, .05eead) exec(7), time(0.313-0.313 ms): <.main+13110>
test/lang/init.array.ci:76:[.05eead, .05eef1) exec(7), time(0.315-0.315 ms): <.main+13177>
test/lang/init.array.ci:77:[.05eef1, .05ef34) exec(7), time(0.431-0.431 ms): <.main+13245>
test/lang/init.array.ci:78:[.05ef34, .05ef77) exec(7), time(0.260-0.260 ms): <.main+13312>
test/lang/init.array.ci:80:[.05ef77, .05efc0) exec(7), time(0.389-0.389 ms): <.main+13379>
test/lang/init.array.ci:82:[.05efc0, .05f003) exec(7), time(0.308-0.308 ms): <.main+13452>
test/lang/init.array.ci:84:[.05f003, .05f040) exec(7), time(0.065-0.065 ms): <.main+13519>
test/lang/init.array.ci:66:[.05f044, .05f048) exec(7), time(0.005-0.005 ms): <.main+13584>
test/lang/init.array.ci:66:[.05f048, .05f054) exec(8), time(0.037-0.037 ms): <.main+13588>
test/lang/init.array.ci:66:[.05ed1d, .05f058) exec(1), time(0.006-0.006 ms): <.main+12777>
test/lang/stmt.if.ci:4:[.05f058, .05f07f) exec(1), time(0.039-0.039 ms): <.main+13604>
test/lang/stmt.if.ci:12:[.05f07f, .05f0a6) exec(1), time(0.051-0.051 ms): <.main+13643>
test/lang/stmt.if.ci:22:[.05f0a6, .05f0cd) exec(1), time(0.086-0.086 ms): <.main+13682>
test/lang/stmt.if.ci:29:[.05f0d7, .05f0fe) exec(1), time(0.049-0.049 ms): <.main+13731>
test/lang/stmt.if.ci:28:[.05f0cd, .05f0fe) exec(1-1), time(0.000 ms): <.main+13721>
test/lang/stmt.if.ci:33:[.05f108, .05f12f) exec(0), time(0.000 ms): <.main+13780>
test/lang/stmt.if.ci:32:[.05f0fe, .05f12f) exec(1), time(0.005-0.005 ms): <.main+13770>
test/lang/stmt.if.ci:37:[.05f139, .05f160) exec(1), time(0.088-0.088 ms): <.main+13829>
test/lang/stmt.if.ci:40:[.05f164, .05f18b) exec(0), time(0.000 ms): <.main+13872>
test/lang/stmt.if.ci:36:[.05f12f, .05f18b) exec(1), time(0.091-0.091 ms): <.main+13819>
test/lang/stmt.if.ci:44:[.05f195, .05f1bc) exec(0), time(0.000 ms): <.main+13921>
test/lang/stmt.if.ci:47:[.05f1c0, .05f1e7) exec(1), time(0.049-0.049 ms): <.main+13964>
test/lang/stmt.if.ci:43:[.05f18b, .05f1e7) exec(1-1), time(0.000 ms): <.main+13911>
test/lang/stmt.if.ci:51:[.05f1f1, .05f218) exec(1), time(0.056-0.056 ms): <.main+14013>
test/lang/stmt.if.ci:54:[.05f22a, .05f251) exec(0), time(0.000 ms): <.main+14070>
test/lang/stmt.if.ci:57:[.05f263, .05f28a) exec(0), time(0.000 ms): <.main+14127>
test/lang/stmt.if.ci:60:[.05f29c, .05f2c3) exec(0), time(0.000 ms): <.main+14184>
test/lang/stmt.if.ci:63:[.05f2d5, .05f2fc) exec(0), time(0.000 ms): <.main+14241>
test/lang/stmt.if.ci:66:[.05f30e, .05f335) exec(0), time(0.000 ms): <.main+14298>
test/lang/stmt.if.ci:69:[.05f339, .05f360) exec(0), time(0.000 ms): <.main+14341>
test/lang/stmt.if.ci:65:[.05f300, .05f360) exec(0), time(0.000 ms): <.main+14284>
test/lang/stmt.if.ci:62:[.05f2c7, .05f360) exec(0), time(0.000 ms): <.main+14227>
test/lang/stmt.if.ci:59:[.05f28e, .05f360) exec(0), time(0.000 ms): <.main+14170>
test/lang/stmt.if.ci:56:[.05f255, .05f360) exec(0), time(0.000 ms): <.main+14113>
test/lang/stmt.if.ci:53:[.05f21c, .05f360) exec(0), time(0.000 ms): <.main+14056>
test/lang/stmt.if.ci:50:[.05f1e7, .05f360) exec(1), time(0.059-0.059 ms): <.main+14003>
test/lang/stmt.for.ci:4:[.05f364, .05f387) exec(1), time(0.047-0.047 ms): <.main+14384>
test/lang/stmt.for.ci:5:[.05f387, .05f38b) exec(1), time(0.001-0.001 ms): <.main+14419>
::[.05f38b, .05f38f) exec(1), time(0.000 ms): <.main+14423>
test/lang/stmt.for.ci:3:[.05f360, .05f38f) exec(1-1), time(0.000 ms): <.main+14380>
test/lang/stmt.for.ci:9:[.05f394, .05f3b6) exec(2), time(0.080-0.080 ms): <.main+14432>
test/lang/stmt.for.ci:8:[.05f3b6, .05f3ba) exec(2), time(0.002-0.002 ms): <.main+14466>
test/lang/stmt.for.ci:8:[.05f3ba, .05f3c6) exec(3), time(0.013-0.013 ms): <.main+14470>
test/lang/stmt.for.ci:8:[.05f38f, .05f3ca) exec(1), time(0.006-0.006 ms): <.main+14427>
test/lang/stmt.for.ci:14:[.05f3d3, .05f3f6) exec(2), time(0.074-0.074 ms): <.main+14495>
test/lang/stmt.for.ci:13:[.05f3f6, .05f402) exec(2), time(0.008-0.008 ms): <.main+14530>
test/lang/stmt.for.ci:13:[.05f402, .05f410) exec(3), time(0.014-0.014 ms): <.main+14542>
test/lang/stmt.for.ci:13:[.05f3ca, .05f410) exec(1-1), time(0.000 ms): <.main+14486>
test/lang/stmt.for.ci:19:[.05f421, .05f425) exec(2), time(0.001-0.001 ms): <.main+14573>
test/lang/stmt.for.ci:18:[.05f415, .05f425) exec(7-2), time(0.035-0.035 ms): <.main+14561>
test/lang/stmt.for.ci:21:[.05f425, .05f447) exec(5), time(0.251-0.251 ms): <.main+14577>
test/lang/stmt.for.ci:17:[.05f447, .05f44b) exec(7), time(0.004-0.004 ms): <.main+14611>
test/lang/stmt.for.ci:17:[.05f44b, .05f457) exec(8), time(0.037-0.037 ms): <.main+14615>
test/lang/stmt.for.ci:17:[.05f410, .05f45b) exec(1), time(0.006-0.006 ms): <.main+14556>
test/lang/stmt.for.ci:26:[.05f46c, .05f470) exec(1), time(0.001-0.001 ms): <.main+14648>
test/lang/stmt.for.ci:25:[.05f460, .05f470) exec(4-1), time(0.012-0.012 ms): <.main+14636>
test/lang/stmt.for.ci:28:[.05f470, .05f492) exec(3), time(0.110-0.110 ms): <.main+14652>
test/lang/stmt.for.ci:24:[.05f492, .05f496) exec(3), time(0.002-0.002 ms): <.main+14686>
test/lang/stmt.for.ci:24:[.05f496, .05f4a2) exec(4), time(0.018-0.018 ms): <.main+14690>
test/lang/stmt.for.ci:24:[.05f45b, .05f4a6) exec(1), time(0.003-0.003 ms): <.main+14631>

---------- Exitcode: 0, time: 40.878 ms
