
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:59: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:80: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:81: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:82: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:79: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:67: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:94: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:95: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:97: debug: inline file: `lib/vec/vec2d.ci`
lib/stdlib.ci:98: debug: inline file: `lib/vec/vec4f.ci`
lib/stdlib.ci:99: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:110: warn: adding implicit cast float64(len: float32)
lib/vec/mat4f.ci:134: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:162: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:162: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:162: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:163: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:163: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:163: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:164: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:164: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:164: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:165: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:171: warn: adding implicit cast float32(1: int32)
lib/vec/mat4f.ci:171: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:171: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
lib/vec/mat4f.ci:171: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:175: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:175: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:175: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/vec/mat4f.ci:176: warn: adding implicit cast float32(1: int32)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:78: warn: comment does not belong to a declaration
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:86: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:86: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:86: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:86: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:113: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:114: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:115: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:116: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:152: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006178>, cast: static const inline)
.field file: function (size: 0, offs: <@006378>, cast: static const inline)
.field line: function (size: 0, offs: <@006578>, cast: static const inline)
.field name: function (size: 0, offs: <@006778>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:92: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 9
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:92: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006178>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006378>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006578>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006778>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:75: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:56: referenced as `bool`
	lib/stdlib.ci:54: referenced as `bool`
	lib/stdlib.ci:52: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
	internal usages: 1
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:75: referenced as `char`
	lib/stdlib.ci:70: referenced as `char`
	lib/stdlib.ci:54: referenced as `char`
	lib/stdlib.ci:52: referenced as `char`
	lib/stdlib.ci:47: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:42: referenced as `char`
	lib/stdlib.ci:40: referenced as `char`
	lib/stdlib.ci:37: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:32: referenced as `char`
	lib/stdlib.ci:30: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:25: referenced as `char`
	lib/stdlib.ci:22: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:92: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0093b8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0096e8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0098e8>, cast: static const inline)
.field swap: function (size: 0, offs: <@009ae8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ce8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009ee8>, cast: static const inline)
.field hib: function (size: 0, offs: <@00a0e8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a2e8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093b8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096e8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098e8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ae8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ce8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ee8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0e8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a610>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a938>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a610>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a938>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00ab38>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ad38>, cast: static const inline)
.field tan: function (size: 0, offs: <@00af38>, cast: static const inline)
.field log: function (size: 0, offs: <@00b138>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b338>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b5d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b7d0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00ba68>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:171: referenced as `float32`
	lib/vec/mat4f.ci:170: referenced as `float32`
	lib/vec/mat4f.ci:160: referenced as `float32`
	lib/vec/mat4f.ci:157: referenced as `float32`
	lib/vec/mat4f.ci:134: referenced as `float32`
	lib/vec/mat4f.ci:133: referenced as `float32`
	lib/vec/mat4f.ci:133: referenced as `float32`
	lib/vec/mat4f.ci:132: referenced as `float32`
	lib/vec/mat4f.ci:132: referenced as `float32`
	lib/vec/mat4f.ci:130: referenced as `float32`
	lib/vec/mat4f.ci:129: referenced as `float32`
	lib/vec/mat4f.ci:128: referenced as `float32`
	lib/vec/mat4f.ci:127: referenced as `float32`
	lib/vec/mat4f.ci:126: referenced as `float32`
	lib/vec/mat4f.ci:125: referenced as `float32`
	lib/vec/mat4f.ci:124: referenced as `float32`
	lib/vec/mat4f.ci:123: referenced as `float32`
	lib/vec/mat4f.ci:122: referenced as `float32`
	lib/vec/mat4f.ci:121: referenced as `float32`
	lib/vec/mat4f.ci:120: referenced as `float32`
	lib/vec/mat4f.ci:119: referenced as `float32`
	lib/vec/mat4f.ci:109: referenced as `float32`
	lib/vec/mat4f.ci:108: referenced as `float32`
	lib/vec/mat4f.ci:67: referenced as `float32`
	lib/vec/mat4f.ci:67: referenced as `float32`
	lib/vec/mat4f.ci:67: referenced as `float32`
	lib/vec/mat4f.ci:67: referenced as `float32`
	lib/vec/mat4f.ci:66: referenced as `float32`
	lib/vec/mat4f.ci:66: referenced as `float32`
	lib/vec/mat4f.ci:66: referenced as `float32`
	lib/vec/mat4f.ci:66: referenced as `float32`
	lib/vec/mat4f.ci:65: referenced as `float32`
	lib/vec/mat4f.ci:65: referenced as `float32`
	lib/vec/mat4f.ci:65: referenced as `float32`
	lib/vec/mat4f.ci:65: referenced as `float32`
	lib/vec/mat4f.ci:64: referenced as `float32`
	lib/vec/mat4f.ci:64: referenced as `float32`
	lib/vec/mat4f.ci:64: referenced as `float32`
	lib/vec/mat4f.ci:64: referenced as `float32`
	lib/vec/mat4f.ci:59: referenced as `float32`
	lib/vec/mat4f.ci:57: referenced as `float32`
	lib/vec/mat4f.ci:55: referenced as `float32`
	lib/vec/mat4f.ci:53: referenced as `float32`
	lib/vec/mat4f.ci:50: referenced as `float32`
	lib/vec/mat4f.ci:48: referenced as `float32`
	lib/vec/mat4f.ci:46: referenced as `float32`
	lib/vec/mat4f.ci:44: referenced as `float32`
	lib/vec/mat4f.ci:41: referenced as `float32`
	lib/vec/mat4f.ci:39: referenced as `float32`
	lib/vec/mat4f.ci:37: referenced as `float32`
	lib/vec/mat4f.ci:35: referenced as `float32`
	lib/vec/mat4f.ci:32: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:26: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:109: referenced as `float32`
	lib/vec/vec4f.ci:109: referenced as `float32`
	lib/vec/vec4f.ci:104: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:94: referenced as `float32`
	lib/vec/vec4f.ci:90: referenced as `float32`
	lib/vec/vec4f.ci:86: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:42: referenced as `float32`
	lib/vec/vec4f.ci:39: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:33: referenced as `float32`
	lib/vec/vec4f.ci:33: referenced as `float32`
	lib/vec/vec4f.ci:33: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab38>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	lib/vec/mat4f.ci:132: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad38>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	lib/vec/mat4f.ci:133: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af38>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b138>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5d0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b7d0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:104: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba68>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(37)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00bc60>, cast: static const inline)
.field cos: function (size: 0, offs: <@00be58>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c050>, cast: static const inline)
.field log: function (size: 0, offs: <@00c248>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c440>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c6d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c8c8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00cb58>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc60>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be58>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c050>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c248>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c440>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6d0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c8c8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cb58>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(45)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007a90>, cast: static const inline)
.field fill: function (size: 0, offs: <@007dc8>, cast: static const inline)
.field copy: function (size: 0, offs: <@008100>, cast: static const inline)
.field move: function (size: 0, offs: <@008430>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 13
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007dc8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008100>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(11)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008430>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.field is: function (size: 0, offs: <@005ba0>, cast: static const inline)
.field as: function (size: 0, offs: <@005e38>, cast: static const inline)
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:67: referenced as `variant`
	lib/stdlib.ci:64: referenced as `variant`
	lib/stdlib.ci:61: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:45: referenced as `variant`
	lib/stdlib.ci:40: referenced as `variant`
	lib/stdlib.ci:35: referenced as `variant`
	lib/stdlib.ci:30: referenced as `variant`
	lib/stdlib.ci:25: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:15: referenced as `variant`
	internal usages: 3
}
variant.is(var: variant, type: typename): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ba0>
.name: 'is'
.owner: variant
.param .result: bool (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005e38>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:87: referenced as `null`
	lib/stdlib.ci:70: referenced as `null`
	lib/stdlib.ci:67: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:47: referenced as `null`
	lib/stdlib.ci:42: referenced as `null`
	lib/stdlib.ci:37: referenced as `null`
	lib/stdlib.ci:32: referenced as `null`
	lib/stdlib.ci:27: referenced as `null`
	lib/stdlib.ci:22: referenced as `null`
	lib/stdlib.ci:17: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000d38>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000dd8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001198>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001238>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0014b8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a58>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001df0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001fd0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0021a0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002370>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002540>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002710>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002a10>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002e60>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003290>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036c0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c20>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004180>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0045b0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@0049e0>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004e10>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005240>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005410>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:98: referenced as `emit`
	lib/vec/vec4f.ci:94: referenced as `emit`
	lib/vec/vec4f.ci:90: referenced as `emit`
	lib/vec/vec4f.ci:86: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:81: referenced as `emit`
	lib/vec/vec4f.ci:79: referenced as `emit`
	lib/vec/vec4f.ci:77: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001198>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:98: referenced as `p4x`
	lib/vec/vec4f.ci:94: referenced as `p4x`
	lib/vec/vec4f.ci:90: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:90: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:98: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:94: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001238>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0014b8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a58>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001df0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001fd0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0021a0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002370>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002540>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002710>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a10>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002e60>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:75: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003290>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:77: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:77: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036c0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:79: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:79: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c20>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:81: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:81: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004180>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0045b0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0049e0>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e10>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005240>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:84: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005410>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:86: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:86: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005900>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f10>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(7)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:84: referenced as `abort`
	lib/stdlib.ci:49: referenced as `abort`
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:42: referenced as `error`
	lib/stdlib.ci:40: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:37: referenced as `warn`
	lib/stdlib.ci:35: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:32: referenced as `info`
	lib/stdlib.ci:30: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:27: referenced as `debug`
	lib/stdlib.ci:25: referenced as `debug`
	lib/stdlib.ci:22: referenced as `debug`
	lib/stdlib.ci:20: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:17: referenced as `verbose`
	lib/stdlib.ci:15: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:37: referenced as `noTrace`
	lib/stdlib.ci:35: referenced as `noTrace`
	lib/stdlib.ci:32: referenced as `noTrace`
	lib/stdlib.ci:30: referenced as `noTrace`
	lib/stdlib.ci:22: referenced as `noTrace`
	lib/stdlib.ci:20: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:84: referenced as `defTrace`
	lib/stdlib.ci:49: referenced as `defTrace`
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:45: referenced as `defTrace`
	lib/stdlib.ci:42: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:27: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0077f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008460>
.name: 'System'
.field exit: function (size: 0, offs: <@0086d8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0088e0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008a48>, cast: static const inline)
.field time: function (size: 0, offs: <@008bb0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008d18>, cast: static const inline)
.field millis: function (size: 0, offs: <@008e80>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009080>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(13)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0088e0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(14)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008a48>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008bb0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d18>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e80>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(18)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009080>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(19)
.usages:
	internal usages: 1
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
	lib/stdlib.ci:4: defined as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/stdlib.ci:5: defined as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
	lib/stdlib.ci:8: defined as `byte`
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
	lib/stdlib.ci:9: defined as `float`
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
	lib/stdlib.ci:10: defined as `double`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:15: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:17: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:20: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:22'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/stdlib.ci:22: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/vec/mat4f.ci:111: referenced as `trace`
	lib/stdlib.ci:25: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:27: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:30'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:30: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:32'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:32: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:35'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:35: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:37: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:40: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:42: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:52: referenced as `abort`
	lib/stdlib.ci:45: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:56: referenced as `abort`
	lib/stdlib.ci:54: referenced as `abort`
	lib/stdlib.ci:47: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:49: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:52'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:52: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:54'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:54: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:56'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:56: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@010108>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:59'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:79: referenced as `NotEquals`
	lib/stdlib.ci:59: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:80: referenced as `expected`
	lib/stdlib.ci:61: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:64'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:81: referenced as `returned`
	lib/stdlib.ci:64: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:67'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:67: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:70'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:82: referenced as `message`
	lib/stdlib.ci:70: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@0533e0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@0533e0> - <@05343e>)
	lib/stdlib.ci:76: (10 bytes: <@0533e0> - <@0533ea>): if (bool(returned == expected))
	<assertEq @0533e0>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @0533e2>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @0533e4>    : 57                         ceq.i32
	<assertEq+5 @0533e5>    : 06 05 00 00                jz <assertEq+10 @0533ea>
	lib/stdlib.ci:77: (1 byte: <@0533e9> - <@0533ea>): return;
	<assertEq+9 @0533e9>    : 03                         ret
	lib/stdlib.ci:79: (41 bytes: <@0533ea> - <@053413>): details: NotEquals := {...}
	<assertEq+10 @0533ea>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:80: (11 bytes: <@0533ee> - <@0533f9>): void(details.expected := (expected));
	<assertEq+14 @0533ee>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @0533f3>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @0533f7>   : 14 02                      set.x64 sp(2)
	lib/stdlib.ci:81: (11 bytes: <@0533f9> - <@053404>): void(details.returned := (returned));
	<assertEq+25 @0533f9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @0533fe>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @053402>   : 14 04                      set.x64 sp(4)
	lib/stdlib.ci:82: (3 bytes: <@053404> - <@053407>): void(details.message := (message));
	<assertEq+36 @053404>   : 16 06 09                   mov.x32 sp(6, 9)
	:: (12 bytes: <@053407> - <@053413>): void(details.argument := (null))
	<assertEq+39 @053407>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @05340c>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @053411>   : 14 06                      set.x64 sp(6)
	lib/stdlib.ci:84: (38 bytes: <@053413> - <@053439>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @053413>   : 1f 88 cb 00 00             load.ref <@00cb88> ;"lib/stdlib.ci"
	<assertEq+56 @053418>   : 1c 54 00 00 00             load.c32 84
	<assertEq+61 @05341d>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @053422>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @053427>   : 1f a8 ce 00 00             load.ref <@00cea8> ;"assertion failed"
	<assertEq+76 @05342c>   : 1f 08 01 01 00             load.ref <@010108> ;NotEquals
	<assertEq+81 @053431>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @053435>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @053439>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @05343d>   : 03                         ret
.usages:
	lib/stdlib.ci:87: referenced as `assertEq`
	lib/stdlib.ci:75: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/stdlib.ci:87'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:87: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:92'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:92: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@011380>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@053440>, cast: static const function)
.field floor: function (size: 24, offs: <@053498>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@0534b0>, cast: static const function)
.field abs: function (size: 18, offs: <@0534c8>, cast: static const function)
.field absMod: function (size: 27, offs: <@0534e0>, cast: static const function)
.field absMod: function (size: 27, offs: <@053500>, cast: static const function)
.field min: function (size: 17, offs: <@053520>, cast: static const function)
.field min: function (size: 17, offs: <@053538>, cast: static const function)
.field max: function (size: 17, offs: <@053550>, cast: static const function)
.field max: function (size: 17, offs: <@053568>, cast: static const function)
.field clamp: function (size: 30, offs: <@053580>, cast: static const function)
.field clamp: function (size: 30, offs: <@0535a0>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@0535c0>, cast: static const function)
.field max: function (size: 79, offs: <@053610>, cast: static const function)
.field sum: function (size: 40, offs: <@053660>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@053688>, cast: static const function)
.field cmp: function (size: 57, offs: <@0536b8>, cast: static const function)
.field cmp: function (size: 57, offs: <@0536f8>, cast: static const function)
.field sinCos: function (size: 335, offs: <@053738>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@053888>, cast: static const function)
.field sinh: function (size: 241, offs: <@053a08>, cast: static const function)
.field cosh: function (size: 75, offs: <@053b00>, cast: static const function)
.field asin: function (size: 173, offs: <@053b50>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@053440>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@053440> - <@053496>)
	lib/std/math.ci:23: (63 bytes: <@053440> - <@05347f>): if (bool(x < (1)))
	<modf @053440>      : 11 02                      dup.x64 sp(2)
	<modf+2 @053442>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @05344b>   : 88                         clt.f64
	<modf+12 @05344c>   : 06 33 00 00                jz <modf+63 @05347f>
	lib/std/math.ci:24: (39 bytes: <@053450> - <@053477>): if (bool(x < (0)))
	<modf+16 @053450>   : 11 02                      dup.x64 sp(2)
	<modf+18 @053452>   : 1a                         load.z64
	<modf+19 @053453>   : 88                         clt.f64
	<modf+20 @053454>   : 06 23 00 00                jz <modf+55 @053477>
	lib/std/math.ci:25: (17 bytes: <@053458> - <@053469>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @053458>   : 1a                         load.z64
	<modf+25 @053459>   : 11 04                      dup.x64 sp(4)
	<modf+27 @05345b>   : 80                         neg.f64
	<modf+28 @05345c>   : 10 05                      dup.x32 sp(5)
	<modf+30 @05345e>   : 1f 40 34 05 00             load.ref <@053440> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @053463>   : 02                         call
	<modf+36 @053464>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @053468>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@053469> - <@053470>): float64(intPart := float64(-intPart));
	<modf+41 @053469>   : 10 03                      dup.x32 sp(3)
	<modf+43 @05346b>   : 23                         load.i64
	<modf+44 @05346c>   : 80                         neg.f64
	<modf+45 @05346d>   : 10 05                      dup.x32 sp(5)
	<modf+47 @05346f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@053470> - <@053473>): return float64(.result := result);
	<modf+48 @053470>   : 14 06                      set.x64 sp(6)
	<modf+50 @053472>   : 03                         ret
	<modf+51 @053473>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@053477> - <@05347b>): float64(intPart := (0));
	<modf+55 @053477>   : 1a                         load.z64
	<modf+56 @053478>   : 10 03                      dup.x32 sp(3)
	<modf+58 @05347a>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@05347b> - <@05347f>): return float64(.result := x);
	<modf+59 @05347b>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @05347e>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@05347f> - <@05348b>): result: float64 := float64(x % (1))
	<modf+63 @05347f>   : 11 02                      dup.x64 sp(2)
	<modf+65 @053481>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @05348a>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@05348b> - <@053493>): float64(intPart := float64(x - result));
	<modf+75 @05348b>   : 11 04                      dup.x64 sp(4)
	<modf+77 @05348d>   : 11 02                      dup.x64 sp(2)
	<modf+79 @05348f>   : 82                         sub.f64
	<modf+80 @053490>   : 10 05                      dup.x32 sp(5)
	<modf+82 @053492>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@053493> - <@053496>): return float64(.result := result);
	<modf+83 @053493>   : 14 06                      set.x64 sp(6)
	<modf+85 @053495>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@053498>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@053498> - <@0534b0>)
	lib/std/math.ci:48: (1 byte: <@053498> - <@053499>): result: float64
	<floor @053498>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@053499> - <@0534ad>): modf(void(x, result));
	<floor+1 @053499>    : 11 05                      dup.x64 sp(5)
	<floor+3 @05349b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @05349f>    : 1f 40 34 05 00             load.ref <@053440> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @0534a4>   : 02                         call
	<floor+13 @0534a5>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @0534a9>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@0534ad> - <@0534b0>): return float64(.result := result);
	<floor+21 @0534ad>   : 14 05                      set.x64 sp(5)
	<floor+23 @0534af>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0534b0>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@0534b0> - <@0534c2>)
	lib/std/math.ci:78: (14 bytes: <@0534b0> - <@0534be>): if (bool(x < (0)))
	<abs @0534b0>      : 10 01                      dup.x32 sp(1)
	<abs+2 @0534b2>    : 19                         load.z32
	<abs+3 @0534b3>    : 78                         clt.f32
	<abs+4 @0534b4>    : 06 0a 00 00                jz <abs+14 @0534be>
	lib/std/math.ci:79: (6 bytes: <@0534b8> - <@0534be>): return float32(.result := float32(-x));
	<abs+8 @0534b8>    : 10 01                      dup.x32 sp(1)
	<abs+10 @0534ba>   : 70                         neg.f32
	<abs+11 @0534bb>   : 13 03                      set.x32 sp(3)
	<abs+13 @0534bd>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@0534be> - <@0534c2>): return float32(.result := x);
	<abs+14 @0534be>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @0534c1>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0534c8>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@0534c8> - <@0534da>)
	lib/std/math.ci:86: (14 bytes: <@0534c8> - <@0534d6>): if (bool(x < (0)))
	<abs @0534c8>      : 11 01                      dup.x64 sp(1)
	<abs+2 @0534ca>    : 1a                         load.z64
	<abs+3 @0534cb>    : 88                         clt.f64
	<abs+4 @0534cc>    : 06 0a 00 00                jz <abs+14 @0534d6>
	lib/std/math.ci:87: (6 bytes: <@0534d0> - <@0534d6>): return float64(.result := float64(-x));
	<abs+8 @0534d0>    : 11 01                      dup.x64 sp(1)
	<abs+10 @0534d2>   : 80                         neg.f64
	<abs+11 @0534d3>   : 14 05                      set.x64 sp(5)
	<abs+13 @0534d5>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@0534d6> - <@0534da>): return float64(.result := x);
	<abs+14 @0534d6>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @0534d9>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@0534e0>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@0534e0> - <@0534fb>)
	lib/std/math.ci:94: (23 bytes: <@0534e0> - <@0534f7>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @0534e0>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @0534e2>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @0534e4>    : 75                         mod.f32
	<absMod+5 @0534e5>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @0534e7>    : 13 04                      set.x32 sp(4)
	<absMod+9 @0534e9>    : 19                         load.z32
	<absMod+10 @0534ea>   : 78                         clt.f32
	<absMod+11 @0534eb>   : 06 0c 00 00                jz <absMod+23 @0534f7>
	lib/std/math.ci:95: (8 bytes: <@0534ef> - <@0534f7>): return float32(.result := float32(val + mod));
	<absMod+15 @0534ef>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @0534f1>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @0534f3>   : 71                         add.f32
	<absMod+20 @0534f4>   : 13 04                      set.x32 sp(4)
	<absMod+22 @0534f6>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@0534f7> - <@0534fb>): return float32(.result := val);
	<absMod+23 @0534f7>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @0534fa>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@053500>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@053500> - <@05351b>)
	lib/std/math.ci:102: (23 bytes: <@053500> - <@053517>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @053500>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @053502>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @053504>    : 85                         mod.f64
	<absMod+5 @053505>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @053507>    : 14 07                      set.x64 sp(7)
	<absMod+9 @053509>    : 1a                         load.z64
	<absMod+10 @05350a>   : 88                         clt.f64
	<absMod+11 @05350b>   : 06 0c 00 00                jz <absMod+23 @053517>
	lib/std/math.ci:103: (8 bytes: <@05350f> - <@053517>): return float64(.result := float64(val + mod));
	<absMod+15 @05350f>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @053511>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @053513>   : 81                         add.f64
	<absMod+20 @053514>   : 14 07                      set.x64 sp(7)
	<absMod+22 @053516>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@053517> - <@05351b>): return float64(.result := val);
	<absMod+23 @053517>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @05351a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@053520>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@053520> - <@053531>)
	lib/std/math.ci:116: (13 bytes: <@053520> - <@05352d>): if (bool(a < b))
	<min @053520>      : 10 02                      dup.x32 sp(2)
	<min+2 @053522>    : 10 02                      dup.x32 sp(2)
	<min+4 @053524>    : 78                         clt.f32
	<min+5 @053525>    : 06 08 00 00                jz <min+13 @05352d>
	lib/std/math.ci:117: (4 bytes: <@053529> - <@05352d>): return float32(.result := a);
	<min+9 @053529>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @05352c>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@05352d> - <@053531>): return float32(.result := b);
	<min+13 @05352d>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @053530>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@053538>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@053538> - <@053549>)
	lib/std/math.ci:124: (13 bytes: <@053538> - <@053545>): if (bool(a < b))
	<min @053538>      : 11 03                      dup.x64 sp(3)
	<min+2 @05353a>    : 11 03                      dup.x64 sp(3)
	<min+4 @05353c>    : 88                         clt.f64
	<min+5 @05353d>    : 06 08 00 00                jz <min+13 @053545>
	lib/std/math.ci:125: (4 bytes: <@053541> - <@053545>): return float64(.result := a);
	<min+9 @053541>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @053544>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@053545> - <@053549>): return float64(.result := b);
	<min+13 @053545>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @053548>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@053550>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@053550> - <@053561>)
	lib/std/math.ci:138: (13 bytes: <@053550> - <@05355d>): if (bool(a > b))
	<max @053550>      : 10 02                      dup.x32 sp(2)
	<max+2 @053552>    : 10 02                      dup.x32 sp(2)
	<max+4 @053554>    : 79                         cgt.f32
	<max+5 @053555>    : 06 08 00 00                jz <max+13 @05355d>
	lib/std/math.ci:139: (4 bytes: <@053559> - <@05355d>): return float32(.result := a);
	<max+9 @053559>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @05355c>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@05355d> - <@053561>): return float32(.result := b);
	<max+13 @05355d>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @053560>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@053568>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@053568> - <@053579>)
	lib/std/math.ci:146: (13 bytes: <@053568> - <@053575>): if (bool(a > b))
	<max @053568>      : 11 03                      dup.x64 sp(3)
	<max+2 @05356a>    : 11 03                      dup.x64 sp(3)
	<max+4 @05356c>    : 89                         cgt.f64
	<max+5 @05356d>    : 06 08 00 00                jz <max+13 @053575>
	lib/std/math.ci:147: (4 bytes: <@053571> - <@053575>): return float64(.result := a);
	<max+9 @053571>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @053574>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@053575> - <@053579>): return float64(.result := b);
	<max+13 @053575>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @053578>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@053580>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@053580> - <@05359e>)
	lib/std/math.ci:160: (13 bytes: <@053580> - <@05358d>): if (bool(t < a))
	<clamp @053580>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @053582>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @053584>    : 78                         clt.f32
	<clamp+5 @053585>    : 06 08 00 00                jz <clamp+13 @05358d>
	lib/std/math.ci:161: (4 bytes: <@053589> - <@05358d>): return float32(.result := a);
	<clamp+9 @053589>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @05358c>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@05358d> - <@05359a>): if (bool(t > b))
	<clamp+13 @05358d>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @05358f>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @053591>   : 79                         cgt.f32
	<clamp+18 @053592>   : 06 08 00 00                jz <clamp+26 @05359a>
	lib/std/math.ci:164: (4 bytes: <@053596> - <@05359a>): return float32(.result := b);
	<clamp+22 @053596>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @053599>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@05359a> - <@05359e>): return float32(.result := t);
	<clamp+26 @05359a>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @05359d>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0535a0>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@0535a0> - <@0535be>)
	lib/std/math.ci:171: (13 bytes: <@0535a0> - <@0535ad>): if (bool(t < a))
	<clamp @0535a0>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @0535a2>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @0535a4>    : 88                         clt.f64
	<clamp+5 @0535a5>    : 06 08 00 00                jz <clamp+13 @0535ad>
	lib/std/math.ci:172: (4 bytes: <@0535a9> - <@0535ad>): return float64(.result := a);
	<clamp+9 @0535a9>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @0535ac>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@0535ad> - <@0535ba>): if (bool(t > b))
	<clamp+13 @0535ad>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @0535af>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @0535b1>   : 89                         cgt.f64
	<clamp+18 @0535b2>   : 06 08 00 00                jz <clamp+26 @0535ba>
	lib/std/math.ci:175: (4 bytes: <@0535b6> - <@0535ba>): return float64(.result := b);
	<clamp+22 @0535b6>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @0535b9>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@0535ba> - <@0535be>): return float64(.result := t);
	<clamp+26 @0535ba>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @0535bd>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@0535c0>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@0535c0> - <@05360f>)
	lib/std/math.ci:202: (20 bytes: <@0535c0> - <@0535d4>): if (bool(data.length == (0)))
	<min @0535c0>      : 10 02                      dup.x32 sp(2)
	<min+2 @0535c2>    : 19                         load.z32
	<min+3 @0535c3>    : 57                         ceq.i32
	<min+4 @0535c4>    : 06 10 00 00                jz <min+20 @0535d4>
	lib/std/math.ci:203: (12 bytes: <@0535c8> - <@0535d4>): return float64(.result := nan);
	<min+8 @0535c8>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @0535d1>   : 14 05                      set.x64 sp(5)
	<min+19 @0535d3>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@0535d4> - <@0535d7>): result: float64 := data[0]
	<min+20 @0535d4>   : 10 01                      dup.x32 sp(1)
	<min+22 @0535d6>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@0535d7> - <@05360c>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+23 @0535d7>   : 1c 01 00 00 00             load.c32 1
	<min+28 @0535dc>   : 04 23 00 00                jmp <min+63 @0535ff>
	lib/std/math.ci:207: (27 bytes: <@0535e0> - <@0535fb>): if (bool(result > data[i]))
	<min+32 @0535e0>   : 11 01                      dup.x64 sp(1)
	<min+34 @0535e2>   : 10 06                      dup.x32 sp(6)
	<min+36 @0535e4>   : 10 03                      dup.x32 sp(3)
	<min+38 @0535e6>   : 0d 08 00 00                mad.u32 8
	<min+42 @0535ea>   : 23                         load.i64
	<min+43 @0535eb>   : 89                         cgt.f64
	<min+44 @0535ec>   : 06 0f 00 00                jz <min+59 @0535fb>
	lib/std/math.ci:208: (11 bytes: <@0535f0> - <@0535fb>): float64(result := data[i]);
	<min+48 @0535f0>   : 10 04                      dup.x32 sp(4)
	<min+50 @0535f2>   : 10 01                      dup.x32 sp(1)
	<min+52 @0535f4>   : 0d 08 00 00                mad.u32 8
	<min+56 @0535f8>   : 23                         load.i64
	<min+57 @0535f9>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@0535fb> - <@0535ff>): int32(i := int32(i + 1))
	<min+59 @0535fb>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@0535ff> - <@053608>): bool(i < (data.length))
	<min+63 @0535ff>   : 10 00                      dup.x32 sp(0)
	<min+65 @053601>   : 10 06                      dup.x32 sp(6)
	<min+67 @053603>   : 58                         clt.i32
	<min+68 @053604>   : 05 dc ff ff                jnz <min+32 @0535e0>
	<min+72 @053608>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@05360c> - <@05360f>): return float64(.result := result);
	<min+76 @05360c>   : 14 05                      set.x64 sp(5)
	<min+78 @05360e>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@053610>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@053610> - <@05365f>)
	lib/std/math.ci:216: (20 bytes: <@053610> - <@053624>): if (bool(data.length == (0)))
	<max @053610>      : 10 02                      dup.x32 sp(2)
	<max+2 @053612>    : 19                         load.z32
	<max+3 @053613>    : 57                         ceq.i32
	<max+4 @053614>    : 06 10 00 00                jz <max+20 @053624>
	lib/std/math.ci:217: (12 bytes: <@053618> - <@053624>): return float64(.result := nan);
	<max+8 @053618>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @053621>   : 14 05                      set.x64 sp(5)
	<max+19 @053623>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@053624> - <@053627>): result: float64 := data[0]
	<max+20 @053624>   : 10 01                      dup.x32 sp(1)
	<max+22 @053626>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@053627> - <@05365c>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+23 @053627>   : 1c 01 00 00 00             load.c32 1
	<max+28 @05362c>   : 04 23 00 00                jmp <max+63 @05364f>
	lib/std/math.ci:221: (27 bytes: <@053630> - <@05364b>): if (bool(result < data[i]))
	<max+32 @053630>   : 11 01                      dup.x64 sp(1)
	<max+34 @053632>   : 10 06                      dup.x32 sp(6)
	<max+36 @053634>   : 10 03                      dup.x32 sp(3)
	<max+38 @053636>   : 0d 08 00 00                mad.u32 8
	<max+42 @05363a>   : 23                         load.i64
	<max+43 @05363b>   : 88                         clt.f64
	<max+44 @05363c>   : 06 0f 00 00                jz <max+59 @05364b>
	lib/std/math.ci:222: (11 bytes: <@053640> - <@05364b>): float64(result := data[i]);
	<max+48 @053640>   : 10 04                      dup.x32 sp(4)
	<max+50 @053642>   : 10 01                      dup.x32 sp(1)
	<max+52 @053644>   : 0d 08 00 00                mad.u32 8
	<max+56 @053648>   : 23                         load.i64
	<max+57 @053649>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@05364b> - <@05364f>): int32(i := int32(i + 1))
	<max+59 @05364b>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@05364f> - <@053658>): bool(i < (data.length))
	<max+63 @05364f>   : 10 00                      dup.x32 sp(0)
	<max+65 @053651>   : 10 06                      dup.x32 sp(6)
	<max+67 @053653>   : 58                         clt.i32
	<max+68 @053654>   : 05 dc ff ff                jnz <max+32 @053630>
	<max+72 @053658>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@05365c> - <@05365f>): return float64(.result := result);
	<max+76 @05365c>   : 14 05                      set.x64 sp(5)
	<max+78 @05365e>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@053660>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@053660> - <@053688>)
	lib/std/math.ci:230: (1 byte: <@053660> - <@053661>): result: float64 := 0
	<sum @053660>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@053661> - <@053685>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @053661>    : 6a                         i64.2i32
	<sum+2 @053662>    : 04 16 00 00                jmp <sum+24 @053678>
	lib/std/math.ci:232: (14 bytes: <@053666> - <@053674>): float64(result := float64(result + data[i]));
	<sum+6 @053666>    : 11 01                      dup.x64 sp(1)
	<sum+8 @053668>    : 10 06                      dup.x32 sp(6)
	<sum+10 @05366a>   : 10 03                      dup.x32 sp(3)
	<sum+12 @05366c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @053670>   : 23                         load.i64
	<sum+17 @053671>   : 81                         add.f64
	<sum+18 @053672>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@053674> - <@053678>): int32(i := int32(i + 1))
	<sum+20 @053674>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@053678> - <@053681>): bool(i < (data.length))
	<sum+24 @053678>   : 10 00                      dup.x32 sp(0)
	<sum+26 @05367a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @05367c>   : 58                         clt.i32
	<sum+29 @05367d>   : 05 e9 ff ff                jnz <sum+6 @053666>
	<sum+33 @053681>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@053685> - <@053688>): return float64(.result := result);
	<sum+37 @053685>   : 14 05                      set.x64 sp(5)
	<sum+39 @053687>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@053688>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@053688> - <@0536b7>)
	lib/std/math.ci:257: (1 byte: <@053688> - <@053689>): result: float64 := 0
	<eval @053688>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@053689> - <@0536b4>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @053689>    : 10 04                      dup.x32 sp(4)
	<eval+3 @05368b>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @05368f>    : 04 19 00 00                jmp <eval+32 @0536a8>
	lib/std/math.ci:259: (17 bytes: <@053693> - <@0536a4>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @053693>   : 11 01                      dup.x64 sp(1)
	<eval+13 @053695>   : 11 08                      dup.x64 sp(8)
	<eval+15 @053697>   : 83                         mul.f64
	<eval+16 @053698>   : 10 06                      dup.x32 sp(6)
	<eval+18 @05369a>   : 10 03                      dup.x32 sp(3)
	<eval+20 @05369c>   : 0d 08 00 00                mad.u32 8
	<eval+24 @0536a0>   : 23                         load.i64
	<eval+25 @0536a1>   : 81                         add.f64
	<eval+26 @0536a2>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:258: (4 bytes: <@0536a4> - <@0536a8>): int32(i := int32(i - 1))
	<eval+28 @0536a4>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@0536a8> - <@0536b0>): bool(i >= 0)
	<eval+32 @0536a8>   : 10 00                      dup.x32 sp(0)
	<eval+34 @0536aa>   : 19                         load.z32
	<eval+35 @0536ab>   : 58                         clt.i32
	<eval+36 @0536ac>   : 06 e7 ff ff                jz <eval+11 @053693>
	<eval+40 @0536b0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@0536b4> - <@0536b7>): return float64(.result := result);
	<eval+44 @0536b4>   : 14 07                      set.x64 sp(7)
	<eval+46 @0536b6>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@0536b8>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@0536b8> - <@0536f1>)
	lib/std/math.ci:266: (53 bytes: <@0536b8> - <@0536ed>): if (bool(a < b))
	<cmp @0536b8>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @0536ba>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @0536bc>    : 78                         clt.f32
	<cmp+5 @0536bd>    : 06 1c 00 00                jz <cmp+33 @0536d9>
	lib/std/math.ci:267: (20 bytes: <@0536c1> - <@0536d5>): if (bool(eps < (float32(b - a))))
	<cmp+9 @0536c1>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @0536c3>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @0536c5>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @0536c7>   : 72                         sub.f32
	<cmp+16 @0536c8>   : 78                         clt.f32
	<cmp+17 @0536c9>   : 06 0c 00 00                jz <cmp+29 @0536d5>
	lib/std/math.ci:268: (8 bytes: <@0536cd> - <@0536d5>): return int32(.result := int32(-1));
	<cmp+21 @0536cd>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0536d2>   : 13 05                      set.x32 sp(5)
	<cmp+28 @0536d4>   : 03                         ret
	<cmp+29 @0536d5>   : 04 18 00 00                jmp <cmp+53 @0536ed>
	lib/std/math.ci:272: (20 bytes: <@0536d9> - <@0536ed>): if (bool(eps < (float32(a - b))))
	<cmp+33 @0536d9>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @0536db>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @0536dd>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @0536df>   : 72                         sub.f32
	<cmp+40 @0536e0>   : 78                         clt.f32
	<cmp+41 @0536e1>   : 06 0c 00 00                jz <cmp+53 @0536ed>
	lib/std/math.ci:273: (8 bytes: <@0536e5> - <@0536ed>): return int32(.result := int32(+1));
	<cmp+45 @0536e5>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @0536ea>   : 13 05                      set.x32 sp(5)
	<cmp+52 @0536ec>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@0536ed> - <@0536f1>): return int32(.result := 0);
	<cmp+53 @0536ed>   : 19                         load.z32
	<cmp+54 @0536ee>   : 13 05                      set.x32 sp(5)
	<cmp+56 @0536f0>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@0536f8>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@0536f8> - <@053731>)
	lib/std/math.ci:281: (53 bytes: <@0536f8> - <@05372d>): if (bool(a < b))
	<cmp @0536f8>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @0536fa>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @0536fc>    : 88                         clt.f64
	<cmp+5 @0536fd>    : 06 1c 00 00                jz <cmp+33 @053719>
	lib/std/math.ci:282: (20 bytes: <@053701> - <@053715>): if (bool(eps < (float64(b - a))))
	<cmp+9 @053701>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @053703>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @053705>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @053707>   : 82                         sub.f64
	<cmp+16 @053708>   : 88                         clt.f64
	<cmp+17 @053709>   : 06 0c 00 00                jz <cmp+29 @053715>
	lib/std/math.ci:283: (8 bytes: <@05370d> - <@053715>): return int32(.result := int32(-1));
	<cmp+21 @05370d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @053712>   : 13 08                      set.x32 sp(8)
	<cmp+28 @053714>   : 03                         ret
	<cmp+29 @053715>   : 04 18 00 00                jmp <cmp+53 @05372d>
	lib/std/math.ci:287: (20 bytes: <@053719> - <@05372d>): if (bool(eps < (float64(a - b))))
	<cmp+33 @053719>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @05371b>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @05371d>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @05371f>   : 82                         sub.f64
	<cmp+40 @053720>   : 88                         clt.f64
	<cmp+41 @053721>   : 06 0c 00 00                jz <cmp+53 @05372d>
	lib/std/math.ci:288: (8 bytes: <@053725> - <@05372d>): return int32(.result := int32(+1));
	<cmp+45 @053725>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05372a>   : 13 08                      set.x32 sp(8)
	<cmp+52 @05372c>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@05372d> - <@053731>): return int32(.result := 0);
	<cmp+53 @05372d>   : 19                         load.z32
	<cmp+54 @05372e>   : 13 08                      set.x32 sp(8)
	<cmp+56 @053730>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@053738>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@053738> - <@053887>)
	lib/std/math.ci:309: (2 bytes: <@053738> - <@05373a>): x: float64 := arg
	<sinCos @053738>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:310: (17 bytes: <@05373a> - <@05374b>): if (bool(x < (0)))
	<sinCos+2 @05373a>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @05373c>    : 1a                         load.z64
	<sinCos+5 @05373d>    : 88                         clt.f64
	<sinCos+6 @05373e>    : 06 0d 00 00                jz <sinCos+19 @05374b>
	lib/std/math.ci:311: (1 byte: <@053742> - <@053743>): float64(x := float64(-x));
	<sinCos+10 @053742>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@053743> - <@05374b>): int32(quad := int32(quad + 2));
	<sinCos+11 @053743>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @053745>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @053749>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:315: (1 byte: <@05374b> - <@05374c>): y: float64
	<sinCos+19 @05374b>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@05374c> - <@053764>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @05374c>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @05374e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @053757>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @053760>   : 84                         div.f64
	<sinCos+41 @053761>   : 83                         mul.f64
	<sinCos+42 @053762>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:317: (124 bytes: <@053764> - <@0537e0>): if (bool(x > (32764)))
	<sinCos+44 @053764>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @053766>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05376f>   : 89                         cgt.f64
	<sinCos+56 @053770>   : 06 54 00 00                jz <sinCos+140 @0537c4>
	lib/std/math.ci:318: (1 byte: <@053774> - <@053775>): e: float64
	<sinCos+60 @053774>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@053775> - <@053787>): float64(y := modf(void(x, e)));
	<sinCos+61 @053775>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @053777>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05377b>   : 1f 40 34 05 00             load.ref <@053440> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @053780>   : 02                         call
	<sinCos+73 @053781>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @053785>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:320: (4 bytes: <@053787> - <@05378b>): float64(e := float64(e + (quad)));
	<sinCos+79 @053787>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @053789>   : 5d                         i32.2f64
	<sinCos+82 @05378a>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@05378b> - <@05378c>): f: float64
	<sinCos+83 @05378b>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@05378c> - <@0537aa>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @05378c>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @053795>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @053797>   : 83                         mul.f64
	<sinCos+96 @053798>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @05379c>  : 1f 40 34 05 00             load.ref <@053440> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @0537a1>  : 02                         call
	<sinCos+106 @0537a2>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @0537a6>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@0537aa> - <@0537bc>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @0537aa>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @0537ac>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @0537b5>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @0537b7>  : 83                         mul.f64
	<sinCos+128 @0537b8>  : 82                         sub.f64
	<sinCos+129 @0537b9>  : 8a                         f64.2i32
	<sinCos+130 @0537ba>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @0537bc>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @0537c0>  : 04 20 00 00                jmp <sinCos+168 @0537e0>
	lib/std/math.ci:327: (3 bytes: <@0537c4> - <@0537c7>): k: int32 := x
	<sinCos+140 @0537c4>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @0537c6>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@0537c7> - <@0537cf>): float64(y := float64(x - (k)));
	<sinCos+143 @0537c7>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @0537c9>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @0537cb>  : 5d                         i32.2f64
	<sinCos+148 @0537cc>  : 82                         sub.f64
	<sinCos+149 @0537cd>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:329: (7 bytes: <@0537cf> - <@0537d6>): int32(quad := int32(quad + k));
	<sinCos+151 @0537cf>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @0537d1>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @0537d3>  : 51                         add.i32
	<sinCos+156 @0537d4>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:330: (6 bytes: <@0537d6> - <@0537dc>): int32(quad := int32(quad & 3));
	<sinCos+158 @0537d6>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @0537d8>  : 3f 02                      b32.and 0x003
	<sinCos+162 @0537da>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @0537dc>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@0537e0> - <@0537f6>): if (int32(quad & 1))
	<sinCos+168 @0537e0>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @0537e2>  : 3f 01                      b32.and 0x001
	<sinCos+172 @0537e4>  : 06 12 00 00                jz <sinCos+190 @0537f6>
	lib/std/math.ci:333: (14 bytes: <@0537e8> - <@0537f6>): float64(y := float64((1) - y));
	<sinCos+176 @0537e8>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @0537f1>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @0537f3>  : 82                         sub.f64
	<sinCos+188 @0537f4>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:335: (13 bytes: <@0537f6> - <@053803>): if (bool(quad > 1))
	<sinCos+190 @0537f6>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @0537f8>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @0537fd>  : 59                         cgt.i32
	<sinCos+198 @0537fe>  : 06 05 00 00                jz <sinCos+203 @053803>
	lib/std/math.ci:336: (1 byte: <@053802> - <@053803>): float64(y := float64(-y));
	<sinCos+202 @053802>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@053803> - <@053808>): ysq: float64 := float64(y * y)
	<sinCos+203 @053803>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @053805>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @053807>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@053808> - <@053848>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @053808>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @053811>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @053813>  : 83                         mul.f64
	<sinCos+220 @053814>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05381d>  : 81                         add.f64
	<sinCos+230 @05381e>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @053820>  : 83                         mul.f64
	<sinCos+233 @053821>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05382a>  : 81                         add.f64
	<sinCos+243 @05382b>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @05382d>  : 83                         mul.f64
	<sinCos+246 @05382e>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @053837>  : 81                         add.f64
	<sinCos+256 @053838>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @05383a>  : 83                         mul.f64
	<sinCos+259 @05383b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @053844>  : 81                         add.f64
	<sinCos+269 @053845>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @053847>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@053848> - <@05387b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @053848>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @05384a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @053853>  : 81                         add.f64
	<sinCos+284 @053854>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @053856>  : 83                         mul.f64
	<sinCos+287 @053857>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @053860>  : 81                         add.f64
	<sinCos+297 @053861>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @053863>  : 83                         mul.f64
	<sinCos+300 @053864>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05386d>  : 81                         add.f64
	<sinCos+310 @05386e>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @053870>  : 83                         mul.f64
	<sinCos+313 @053871>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05387a>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@05387b> - <@053887>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @05387b>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @05387d>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @05387f>  : 84                         div.f64
	<sinCos+328 @053880>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @053882>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @053886>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@053888>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@053888> - <@053a02>)
	lib/std/math.ci:365: (1 byte: <@053888> - <@053889>): complement: bool := false
	<tan @053888>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@053889> - <@05388a>): negate: bool := false
	<tan+1 @053889>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@05388a> - <@0538a1>): if (bool(arg < (0)))
	<tan+2 @05388a>    : 11 03                      dup.x64 sp(3)
	<tan+4 @05388c>    : 1a                         load.z64
	<tan+5 @05388d>    : 88                         clt.f64
	<tan+6 @05388e>    : 06 13 00 00                jz <tan+25 @0538a1>
	lib/std/math.ci:369: (5 bytes: <@053892> - <@053897>): float64(arg := float64(-arg));
	<tan+10 @053892>   : 11 03                      dup.x64 sp(3)
	<tan+12 @053894>   : 80                         neg.f64
	<tan+13 @053895>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:370: (10 bytes: <@053897> - <@0538a1>): bool(negate := true);
	<tan+15 @053897>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @05389c>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @0538a0>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@0538a1> - <@0538b9>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @0538a1>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @0538aa>   : 11 05                      dup.x64 sp(5)
	<tan+36 @0538ac>   : 83                         mul.f64
	<tan+37 @0538ad>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @0538b6>   : 84                         div.f64
	<tan+47 @0538b7>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:374: (1 byte: <@0538b9> - <@0538ba>): e: float64
	<tan+49 @0538b9>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@0538ba> - <@0538ca>): x: float64 := modf(void(arg, e))
	<tan+50 @0538ba>   : 11 07                      dup.x64 sp(7)
	<tan+52 @0538bc>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @0538c0>   : 1f 40 34 05 00             load.ref <@053440> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @0538c5>   : 02                         call
	<tan+62 @0538c6>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@0538ca> - <@0538d3>): i: int32 := int32(int32(e) % 4)
	<tan+66 @0538ca>   : 11 02                      dup.x64 sp(2)
	<tan+68 @0538cc>   : 8a                         f64.2i32
	<tan+69 @0538cd>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @0538d2>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@0538d3> - <@05394d>): if (bool(i == 0))
	<tan+75 @0538d3>   : 10 00                      dup.x32 sp(0)
	<tan+77 @0538d5>   : 19                         load.z32
	<tan+78 @0538d6>   : 57                         ceq.i32
	<tan+79 @0538d7>   : 05 76 00 00                jnz <tan+197 @05394d>
	lib/std/math.ci:379: (114 bytes: <@0538db> - <@05394d>): if (bool(i == 1))
	<tan+83 @0538db>   : 10 00                      dup.x32 sp(0)
	<tan+85 @0538dd>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @0538e2>   : 57                         ceq.i32
	<tan+91 @0538e3>   : 06 20 00 00                jz <tan+123 @053903>
	lib/std/math.ci:380: (14 bytes: <@0538e7> - <@0538f5>): float64(x := float64((1) - x));
	<tan+95 @0538e7>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @0538f0>  : 11 03                      dup.x64 sp(3)
	<tan+106 @0538f2>  : 82                         sub.f64
	<tan+107 @0538f3>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:381: (10 bytes: <@0538f5> - <@0538ff>): bool(complement := true);
	<tan+109 @0538f5>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @0538fa>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @0538fe>  : 25                         store.i8
	<tan+119 @0538ff>  : 04 4e 00 00                jmp <tan+197 @05394d>
	lib/std/math.ci:383: (74 bytes: <@053903> - <@05394d>): if (bool(i == 2))
	<tan+123 @053903>  : 10 00                      dup.x32 sp(0)
	<tan+125 @053905>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05390a>  : 57                         ceq.i32
	<tan+131 @05390b>  : 06 1d 00 00                jz <tan+160 @053928>
	lib/std/math.ci:384: (11 bytes: <@05390f> - <@05391a>): bool(negate := bool(!negate));
	<tan+135 @05390f>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @053913>  : 20                         load.i8
	<tan+140 @053914>  : 0b                         not.b32
	<tan+141 @053915>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @053919>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@05391a> - <@053924>): bool(complement := true);
	<tan+146 @05391a>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05391f>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @053923>  : 25                         store.i8
	<tan+156 @053924>  : 04 29 00 00                jmp <tan+197 @05394d>
	lib/std/math.ci:387: (37 bytes: <@053928> - <@05394d>): if (bool(i == 3))
	<tan+160 @053928>  : 10 00                      dup.x32 sp(0)
	<tan+162 @05392a>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05392f>  : 57                         ceq.i32
	<tan+168 @053930>  : 06 1d 00 00                jz <tan+197 @05394d>
	lib/std/math.ci:388: (14 bytes: <@053934> - <@053942>): float64(x := float64((1) - x));
	<tan+172 @053934>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05393d>  : 11 03                      dup.x64 sp(3)
	<tan+183 @05393f>  : 82                         sub.f64
	<tan+184 @053940>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:389: (11 bytes: <@053942> - <@05394d>): bool(negate := bool(!negate));
	<tan+186 @053942>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @053946>  : 20                         load.i8
	<tan+191 @053947>  : 0b                         not.b32
	<tan+192 @053948>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05394c>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@05394d> - <@053952>): xsq: float64 := float64(x * x)
	<tan+197 @05394d>  : 11 01                      dup.x64 sp(1)
	<tan+199 @05394f>  : 11 03                      dup.x64 sp(3)
	<tan+201 @053951>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@053952> - <@053992>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @053952>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05395b>  : 11 02                      dup.x64 sp(2)
	<tan+213 @05395d>  : 83                         mul.f64
	<tan+214 @05395e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @053967>  : 81                         add.f64
	<tan+224 @053968>  : 11 02                      dup.x64 sp(2)
	<tan+226 @05396a>  : 83                         mul.f64
	<tan+227 @05396b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @053974>  : 81                         add.f64
	<tan+237 @053975>  : 11 02                      dup.x64 sp(2)
	<tan+239 @053977>  : 83                         mul.f64
	<tan+240 @053978>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @053981>  : 81                         add.f64
	<tan+250 @053982>  : 11 02                      dup.x64 sp(2)
	<tan+252 @053984>  : 83                         mul.f64
	<tan+253 @053985>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @05398e>  : 81                         add.f64
	<tan+263 @05398f>  : 11 05                      dup.x64 sp(5)
	<tan+265 @053991>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@053992> - <@0539b9>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @053992>  : 11 02                      dup.x64 sp(2)
	<tan+268 @053994>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @05399d>  : 81                         add.f64
	<tan+278 @05399e>  : 11 04                      dup.x64 sp(4)
	<tan+280 @0539a0>  : 83                         mul.f64
	<tan+281 @0539a1>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @0539aa>  : 81                         add.f64
	<tan+291 @0539ab>  : 11 04                      dup.x64 sp(4)
	<tan+293 @0539ad>  : 83                         mul.f64
	<tan+294 @0539ae>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @0539b7>  : 81                         add.f64
	<tan+304 @0539b8>  : 84                         div.f64
	lib/std/math.ci:396: (47 bytes: <@0539b9> - <@0539e8>): if (complement)
	<tan+305 @0539b9>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @0539bd>  : 20                         load.i8
	<tan+310 @0539be>  : 06 2a 00 00                jz <tan+352 @0539e8>
	lib/std/math.ci:397: (24 bytes: <@0539c2> - <@0539da>): if (bool(result == (0)))
	<tan+314 @0539c2>  : 11 00                      dup.x64 sp(0)
	<tan+316 @0539c4>  : 1a                         load.z64
	<tan+317 @0539c5>  : 87                         ceq.f64
	<tan+318 @0539c6>  : 06 14 00 00                jz <tan+338 @0539da>
	lib/std/math.ci:398: (16 bytes: <@0539ca> - <@0539da>): return float64(.result := nan);
	<tan+322 @0539ca>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @0539d3>  : 14 10                      set.x64 sp(16)
	<tan+333 @0539d5>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @0539d9>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@0539da> - <@0539e8>): float64(result := float64((1) / result));
	<tan+338 @0539da>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @0539e3>  : 11 02                      dup.x64 sp(2)
	<tan+349 @0539e5>  : 84                         div.f64
	<tan+350 @0539e6>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:402: (19 bytes: <@0539e8> - <@0539fb>): if (negate)
	<tan+352 @0539e8>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @0539ec>  : 20                         load.i8
	<tan+357 @0539ed>  : 06 0e 00 00                jz <tan+371 @0539fb>
	lib/std/math.ci:403: (10 bytes: <@0539f1> - <@0539fb>): return float64(.result := float64(-result));
	<tan+361 @0539f1>  : 11 00                      dup.x64 sp(0)
	<tan+363 @0539f3>  : 80                         neg.f64
	<tan+364 @0539f4>  : 14 10                      set.x64 sp(16)
	<tan+366 @0539f6>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @0539fa>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@0539fb> - <@053a02>): return float64(.result := result);
	<tan+371 @0539fb>  : 14 0e                      set.x64 sp(14)
	<tan+373 @0539fd>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @053a01>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@053a08>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@053a08> - <@053af9>)
	lib/std/math.ci:421: (1 byte: <@053a08> - <@053a09>): negate: bool := false
	<sinh @053a08>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@053a09> - <@053a20>): if (bool(x < (0)))
	<sinh+1 @053a09>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @053a0b>    : 1a                         load.z64
	<sinh+4 @053a0c>    : 88                         clt.f64
	<sinh+5 @053a0d>    : 06 13 00 00                jz <sinh+24 @053a20>
	lib/std/math.ci:423: (5 bytes: <@053a11> - <@053a16>): float64(x := float64(-x));
	<sinh+9 @053a11>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @053a13>   : 80                         neg.f64
	<sinh+12 @053a14>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:424: (10 bytes: <@053a16> - <@053a20>): bool(negate := true);
	<sinh+14 @053a16>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @053a1b>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @053a1f>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@053a20> - <@053a47>): if (bool(x > (21)))
	<sinh+24 @053a20>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @053a22>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @053a2b>   : 89                         cgt.f64
	<sinh+36 @053a2c>   : 06 1b 00 00                jz <sinh+63 @053a47>
	lib/std/math.ci:428: (23 bytes: <@053a30> - <@053a47>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @053a30>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @053a32>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+46 @053a36>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @053a3f>   : 84                         div.f64
	<sinh+56 @053a40>   : 14 06                      set.x64 sp(6)
	<sinh+58 @053a42>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @053a46>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@053a47> - <@053a48>): result: float64
	<sinh+63 @053a47>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@053a48> - <@053adf>): if (bool(x > 0.500000))
	<sinh+64 @053a48>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @053a4a>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @053a53>   : 89                         cgt.f64
	<sinh+76 @053a54>   : 06 22 00 00                jz <sinh+110 @053a76>
	lib/std/math.ci:433: (26 bytes: <@053a58> - <@053a72>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @053a58>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @053a5a>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+86 @053a5e>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @053a60>   : 80                         neg.f64
	<sinh+89 @053a61>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+93 @053a65>   : 82                         sub.f64
	<sinh+94 @053a66>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @053a6f>  : 84                         div.f64
	<sinh+104 @053a70>  : 14 02                      set.x64 sp(2)
	<sinh+106 @053a72>  : 04 6d 00 00                jmp <sinh+215 @053adf>
	lib/std/math.ci:436: (5 bytes: <@053a76> - <@053a7b>): sq: float64 := float64(x * x)
	<sinh+110 @053a76>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @053a78>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @053a7a>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@053a7b> - <@053ab0>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @053a7b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @053a84>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @053a86>  : 83                         mul.f64
	<sinh+127 @053a87>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @053a90>  : 81                         add.f64
	<sinh+137 @053a91>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @053a93>  : 83                         mul.f64
	<sinh+140 @053a94>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @053a9d>  : 81                         add.f64
	<sinh+150 @053a9e>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @053aa0>  : 83                         mul.f64
	<sinh+153 @053aa1>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @053aaa>  : 81                         add.f64
	<sinh+163 @053aab>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @053aad>  : 83                         mul.f64
	<sinh+166 @053aae>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:438: (43 bytes: <@053ab0> - <@053adb>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @053ab0>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @053ab2>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @053ab4>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @053abd>  : 81                         add.f64
	<sinh+182 @053abe>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @053ac0>  : 83                         mul.f64
	<sinh+185 @053ac1>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @053aca>  : 81                         add.f64
	<sinh+195 @053acb>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @053acd>  : 83                         mul.f64
	<sinh+198 @053ace>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @053ad7>  : 81                         add.f64
	<sinh+208 @053ad8>  : 84                         div.f64
	<sinh+209 @053ad9>  : 14 04                      set.x64 sp(4)
	<sinh+211 @053adb>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@053adf> - <@053af2>): if (negate)
	<sinh+215 @053adf>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @053ae3>  : 20                         load.i8
	<sinh+220 @053ae4>  : 06 0e 00 00                jz <sinh+234 @053af2>
	lib/std/math.ci:442: (10 bytes: <@053ae8> - <@053af2>): return float64(.result := float64(-result));
	<sinh+224 @053ae8>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @053aea>  : 80                         neg.f64
	<sinh+227 @053aeb>  : 14 08                      set.x64 sp(8)
	<sinh+229 @053aed>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @053af1>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@053af2> - <@053af9>): return float64(.result := result);
	<sinh+234 @053af2>  : 14 06                      set.x64 sp(6)
	<sinh+236 @053af4>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @053af8>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@053b00>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@053b00> - <@053b4b>)
	lib/std/math.ci:449: (13 bytes: <@053b00> - <@053b0d>): if (bool(x < (0)))
	<cosh @053b00>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @053b02>    : 1a                         load.z64
	<cosh+3 @053b03>    : 88                         clt.f64
	<cosh+4 @053b04>    : 06 09 00 00                jz <cosh+13 @053b0d>
	lib/std/math.ci:450: (5 bytes: <@053b08> - <@053b0d>): float64(x := float64(-x));
	<cosh+8 @053b08>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @053b0a>   : 80                         neg.f64
	<cosh+11 @053b0b>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:452: (35 bytes: <@053b0d> - <@053b30>): if (bool(x > (21)))
	<cosh+13 @053b0d>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @053b0f>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @053b18>   : 89                         cgt.f64
	<cosh+25 @053b19>   : 06 17 00 00                jz <cosh+48 @053b30>
	lib/std/math.ci:453: (19 bytes: <@053b1d> - <@053b30>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @053b1d>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @053b1f>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+35 @053b23>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @053b2c>   : 84                         div.f64
	<cosh+45 @053b2d>   : 14 05                      set.x64 sp(5)
	<cosh+47 @053b2f>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@053b30> - <@053b4b>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @053b30>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @053b32>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+54 @053b36>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @053b38>   : 80                         neg.f64
	<cosh+57 @053b39>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+61 @053b3d>   : 81                         add.f64
	<cosh+62 @053b3e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @053b47>   : 84                         div.f64
	<cosh+72 @053b48>   : 14 05                      set.x64 sp(5)
	<cosh+74 @053b4a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.offset: <@053b50>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <@053b50> - <@053bfd>)
	lib/std/math.ci:464: (12 bytes: <@053b50> - <@053b5c>): if (bool(x == (0)))
	<asin @053b50>      : 11 01                      dup.x64 sp(1)
	<asin+2 @053b52>    : 1a                         load.z64
	<asin+3 @053b53>    : 87                         ceq.f64
	<asin+4 @053b54>    : 06 08 00 00                jz <asin+12 @053b5c>
	lib/std/math.ci:466: (4 bytes: <@053b58> - <@053b5c>): return float64(.result := x);
	<asin+8 @053b58>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @053b5b>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@053b5c> - <@053b5d>): negate: bool := false
	<asin+12 @053b5c>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@053b5d> - <@053b74>): if (bool(x < (0)))
	<asin+13 @053b5d>   : 11 02                      dup.x64 sp(2)
	<asin+15 @053b5f>   : 1a                         load.z64
	<asin+16 @053b60>   : 88                         clt.f64
	<asin+17 @053b61>   : 06 13 00 00                jz <asin+36 @053b74>
	lib/std/math.ci:471: (10 bytes: <@053b65> - <@053b6f>): bool(negate := true);
	<asin+21 @053b65>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @053b6a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @053b6e>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@053b6f> - <@053b74>): float64(x := float64(-x));
	<asin+31 @053b6f>   : 11 02                      dup.x64 sp(2)
	<asin+33 @053b71>   : 80                         neg.f64
	<asin+34 @053b72>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:475: (32 bytes: <@053b74> - <@053b94>): if (bool(x > (1)))
	<asin+36 @053b74>   : 11 02                      dup.x64 sp(2)
	<asin+38 @053b76>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @053b7f>   : 89                         cgt.f64
	<asin+48 @053b80>   : 06 14 00 00                jz <asin+68 @053b94>
	lib/std/math.ci:477: (16 bytes: <@053b84> - <@053b94>): return float64(.result := nan);
	<asin+52 @053b84>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @053b8d>   : 14 06                      set.x64 sp(6)
	<asin+63 @053b8f>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @053b93>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@053b94> - <@053ba7>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+68 @053b94>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @053b9d>   : 11 04                      dup.x64 sp(4)
	<asin+79 @053b9f>   : 11 06                      dup.x64 sp(6)
	<asin+81 @053ba1>   : 83                         mul.f64
	<asin+82 @053ba2>   : 82                         sub.f64
	<asin+83 @053ba3>   : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@053ba7> - <@053be3>): if (bool(x > 0.700000))
	<asin+87 @053ba7>   : 11 04                      dup.x64 sp(4)
	<asin+89 @053ba9>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @053bb2>   : 89                         cgt.f64
	<asin+99 @053bb3>   : 06 26 00 00                jz <asin+137 @053bd9>
	lib/std/math.ci:482: (30 bytes: <@053bb7> - <@053bd5>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+103 @053bb7>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @053bc0>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @053bc9>  : 84                         div.f64
	<asin+122 @053bca>  : 11 02                      dup.x64 sp(2)
	<asin+124 @053bcc>  : 11 08                      dup.x64 sp(8)
	<asin+126 @053bce>  : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @053bd2>  : 82                         sub.f64
	<asin+131 @053bd3>  : 14 02                      set.x64 sp(2)
	<asin+133 @053bd5>  : 04 0e 00 00                jmp <asin+147 @053be3>
	lib/std/math.ci:485: (10 bytes: <@053bd9> - <@053be3>): float64(result := float64.atan2(void(x, result)));
	<asin+137 @053bd9>  : 11 04                      dup.x64 sp(4)
	<asin+139 @053bdb>  : 11 02                      dup.x64 sp(2)
	<asin+141 @053bdd>  : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @053be1>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:488: (19 bytes: <@053be3> - <@053bf6>): if (negate)
	<asin+147 @053be3>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @053be7>  : 20                         load.i8
	<asin+152 @053be8>  : 06 0e 00 00                jz <asin+166 @053bf6>
	lib/std/math.ci:489: (10 bytes: <@053bec> - <@053bf6>): return float64(.result := float64(-result));
	<asin+156 @053bec>  : 11 00                      dup.x64 sp(0)
	<asin+158 @053bee>  : 80                         neg.f64
	<asin+159 @053bef>  : 14 08                      set.x64 sp(8)
	<asin+161 @053bf1>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @053bf5>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@053bf6> - <@053bfd>): return float64(.result := result);
	<asin+166 @053bf6>  : 14 06                      set.x64 sp(6)
	<asin+168 @053bf8>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @053bfc>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01a0a0>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@053c00>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@053c00> - <@053c07>)
	lib/std/math.Complex.ci:25: (7 bytes: <@053c00> - <@053c07>): return void(.result := {...});
	<Complex @053c00>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@053c03> - <@053c06>): void(.result.im := (0))
	<Complex+3 @053c03>    : 1a                         load.z64
	<Complex+4 @053c04>    : 14 07                      set.x64 sp(7)
	<Complex+6 @053c06>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@053c08>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@053c08> - <@053c0f>)
	lib/std/math.Complex.ci:32: (7 bytes: <@053c08> - <@053c0f>): return void(.result := {...});
	<Complex @053c08>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@053c0b> - <@053c0e>): void(.result.im := im);
	<Complex+3 @053c0b>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @053c0e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:73: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@053c10>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@053c10> - <@053c8b>)
	lib/std/math.Complex.ci:87: (79 bytes: <@053c10> - <@053c5f>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @053c10>      : 1a                         load.z64
	<div+1 @053c11>    : 11 03                      dup.x64 sp(3)
	<div+3 @053c13>    : 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<div+8 @053c18>    : 02                         call
	<div+9 @053c19>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @053c1d>   : 1a                         load.z64
	<div+14 @053c1e>   : 11 07                      dup.x64 sp(7)
	<div+16 @053c20>   : 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<div+21 @053c25>   : 02                         call
	<div+22 @053c26>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @053c2a>   : 88                         clt.f64
	<div+27 @053c2b>   : 05 34 00 00                jnz <div+79 @053c5f>
	lib/std/math.Complex.ci:88: (5 bytes: <@053c2f> - <@053c34>): r: float64 := float64(b.im / b.re)
	<div+31 @053c2f>   : 11 03                      dup.x64 sp(3)
	<div+33 @053c31>   : 11 03                      dup.x64 sp(3)
	<div+35 @053c33>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@053c34> - <@053c3c>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @053c34>   : 11 03                      dup.x64 sp(3)
	<div+38 @053c36>   : 11 02                      dup.x64 sp(2)
	<div+40 @053c38>   : 11 09                      dup.x64 sp(9)
	<div+42 @053c3a>   : 83                         mul.f64
	<div+43 @053c3b>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@053c3c> - <@053c5b>): return void(.result := {...});
	<div+44 @053c3c>   : 11 09                      dup.x64 sp(9)
	<div+46 @053c3e>   : 11 04                      dup.x64 sp(4)
	<div+48 @053c40>   : 11 0f                      dup.x64 sp(15)
	<div+50 @053c42>   : 83                         mul.f64
	<div+51 @053c43>   : 81                         add.f64
	<div+52 @053c44>   : 11 02                      dup.x64 sp(2)
	<div+54 @053c46>   : 84                         div.f64
	<div+55 @053c47>   : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@053c49> - <@053c56>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @053c49>   : 11 0b                      dup.x64 sp(11)
	<div+59 @053c4b>   : 11 04                      dup.x64 sp(4)
	<div+61 @053c4d>   : 11 0d                      dup.x64 sp(13)
	<div+63 @053c4f>   : 83                         mul.f64
	<div+64 @053c50>   : 82                         sub.f64
	<div+65 @053c51>   : 11 02                      dup.x64 sp(2)
	<div+67 @053c53>   : 84                         div.f64
	<div+68 @053c54>   : 14 11                      set.x64 sp(17)
	<div+70 @053c56>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @053c5a>   : 03                         ret
	<div+75 @053c5b>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@053c5f> - <@053c64>): r: float64 := float64(b.re / b.im)
	<div+79 @053c5f>   : 11 01                      dup.x64 sp(1)
	<div+81 @053c61>   : 11 05                      dup.x64 sp(5)
	<div+83 @053c63>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@053c64> - <@053c6c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @053c64>   : 11 05                      dup.x64 sp(5)
	<div+86 @053c66>   : 11 02                      dup.x64 sp(2)
	<div+88 @053c68>   : 11 07                      dup.x64 sp(7)
	<div+90 @053c6a>   : 83                         mul.f64
	<div+91 @053c6b>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@053c6c> - <@053c8b>): return void(.result := {...});
	<div+92 @053c6c>   : 11 09                      dup.x64 sp(9)
	<div+94 @053c6e>   : 11 04                      dup.x64 sp(4)
	<div+96 @053c70>   : 83                         mul.f64
	<div+97 @053c71>   : 11 0d                      dup.x64 sp(13)
	<div+99 @053c73>   : 81                         add.f64
	<div+100 @053c74>  : 11 02                      dup.x64 sp(2)
	<div+102 @053c76>  : 84                         div.f64
	<div+103 @053c77>  : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@053c79> - <@053c86>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @053c79>  : 11 0b                      dup.x64 sp(11)
	<div+107 @053c7b>  : 11 04                      dup.x64 sp(4)
	<div+109 @053c7d>  : 83                         mul.f64
	<div+110 @053c7e>  : 11 0b                      dup.x64 sp(11)
	<div+112 @053c80>  : 82                         sub.f64
	<div+113 @053c81>  : 11 02                      dup.x64 sp(2)
	<div+115 @053c83>  : 84                         div.f64
	<div+116 @053c84>  : 14 11                      set.x64 sp(17)
	<div+118 @053c86>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @053c8a>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@053c90>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@053c90> - <@053caf>)
	lib/std/math.Complex.ci:115: (11 bytes: <@053c90> - <@053c9b>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @053c90>      : 11 01                      dup.x64 sp(1)
	<inv+2 @053c92>    : 11 03                      dup.x64 sp(3)
	<inv+4 @053c94>    : 83                         mul.f64
	<inv+5 @053c95>    : 11 05                      dup.x64 sp(5)
	<inv+7 @053c97>    : 11 07                      dup.x64 sp(7)
	<inv+9 @053c99>    : 83                         mul.f64
	<inv+10 @053c9a>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@053c9b> - <@053caf>): return void(.result := {...});
	<inv+11 @053c9b>   : 11 03                      dup.x64 sp(3)
	<inv+13 @053c9d>   : 11 02                      dup.x64 sp(2)
	<inv+15 @053c9f>   : 84                         div.f64
	<inv+16 @053ca0>   : 14 09                      set.x64 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@053ca2> - <@053caa>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @053ca2>   : 11 05                      dup.x64 sp(5)
	<inv+20 @053ca4>   : 80                         neg.f64
	<inv+21 @053ca5>   : 11 02                      dup.x64 sp(2)
	<inv+23 @053ca7>   : 84                         div.f64
	<inv+24 @053ca8>   : 14 0b                      set.x64 sp(11)
	<inv+26 @053caa>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @053cae>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@053cb0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@053cb0> - <@053d14>)
	lib/std/math.Complex.ci:133: (23 bytes: <@053cb0> - <@053cc7>): r: float64 := abs(a)
	<pow @053cb0>      : 12 05                      dup.x128 sp(5)
	<pow+2 @053cb2>    : 11 00                      dup.x64 sp(0)
	<pow+4 @053cb4>    : 11 02                      dup.x64 sp(2)
	<pow+6 @053cb6>    : 83                         mul.f64
	<pow+7 @053cb7>    : 11 04                      dup.x64 sp(4)
	<pow+9 @053cb9>    : 11 06                      dup.x64 sp(6)
	<pow+11 @053cbb>   : 83                         mul.f64
	<pow+12 @053cbc>   : 81                         add.f64
	<pow+13 @053cbd>   : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	<pow+17 @053cc1>   : 14 04                      set.x64 sp(4)
	<pow+19 @053cc3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@053cc7> - <@053cd7>): t: float64 := arg(a)
	<pow+23 @053cc7>   : 12 07                      dup.x128 sp(7)
	<pow+25 @053cc9>   : 11 00                      dup.x64 sp(0)
	<pow+27 @053ccb>   : 11 04                      dup.x64 sp(4)
	<pow+29 @053ccd>   : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @053cd1>   : 14 04                      set.x64 sp(4)
	<pow+35 @053cd3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@053cd7> - <@053ce6>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @053cd7>   : 11 05                      dup.x64 sp(5)
	<pow+41 @053cd9>   : 11 02                      dup.x64 sp(2)
	<pow+43 @053cdb>   : 83                         mul.f64
	<pow+44 @053cdc>   : 11 09                      dup.x64 sp(9)
	<pow+46 @053cde>   : 11 06                      dup.x64 sp(6)
	<pow+48 @053ce0>   : 01 29 00 00                nfc(41) ;float64.log(x: float64): float64
	<pow+52 @053ce4>   : 83                         mul.f64
	<pow+53 @053ce5>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@053ce6> - <@053cf9>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @053ce6>   : 11 04                      dup.x64 sp(4)
	<pow+56 @053ce8>   : 11 09                      dup.x64 sp(9)
	<pow+58 @053cea>   : 01 2b 00 00                nfc(43) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @053cee>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @053cf0>   : 80                         neg.f64
	<pow+65 @053cf1>   : 11 06                      dup.x64 sp(6)
	<pow+67 @053cf3>   : 83                         mul.f64
	<pow+68 @053cf4>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<pow+72 @053cf8>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@053cf9> - <@053d14>): return void(.result := {...});
	<pow+73 @053cf9>   : 11 00                      dup.x64 sp(0)
	<pow+75 @053cfb>   : 11 04                      dup.x64 sp(4)
	<pow+77 @053cfd>   : 01 27 00 00                nfc(39) ;float64.cos(x: float64): float64
	<pow+81 @053d01>   : 83                         mul.f64
	<pow+82 @053d02>   : 14 13                      set.x64 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@053d04> - <@053d0f>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @053d04>   : 11 00                      dup.x64 sp(0)
	<pow+86 @053d06>   : 11 04                      dup.x64 sp(4)
	<pow+88 @053d08>   : 01 26 00 00                nfc(38) ;float64.sin(x: float64): float64
	<pow+92 @053d0c>   : 83                         mul.f64
	<pow+93 @053d0d>   : 14 15                      set.x64 sp(21)
	<pow+95 @053d0f>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @053d13>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@053d18>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@053d18> - <@053d3e>)
	lib/std/string.ci:5: (16 bytes: <@053d18> - <@053d28>): if (bool((str) == null))
	<length @053d18>      : 10 01                      dup.x32 sp(1)
	<length+2 @053d1a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @053d1f>    : 57                         ceq.i32
	<length+8 @053d20>    : 06 08 00 00                jz <length+16 @053d28>
	lib/std/string.ci:6: (4 bytes: <@053d24> - <@053d28>): return int32(.result := 0);
	<length+12 @053d24>   : 19                         load.z32
	<length+13 @053d25>   : 13 03                      set.x32 sp(3)
	<length+15 @053d27>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@053d28> - <@053d29>): result: int32 := 0
	<length+16 @053d28>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@053d29> - <@053d3b>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @053d29>   : 04 08 00 00                jmp <length+25 @053d31>
	lib/std/string.ci:9: (4 bytes: <@053d2d> - <@053d31>): int32(result := int32(result + 1))
	<length+21 @053d2d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@053d31> - <@053d3b>): str[result]
	<length+25 @053d31>   : 10 02                      dup.x32 sp(2)
	<length+27 @053d33>   : 10 01                      dup.x32 sp(1)
	<length+29 @053d35>   : 51                         add.i32
	<length+30 @053d36>   : 20                         load.i8
	<length+31 @053d37>   : 05 f6 ff ff                jnz <length+21 @053d2d>
	lib/std/string.ci:11: (3 bytes: <@053d3b> - <@053d3e>): return int32(.result := result);
	<length+35 @053d3b>   : 13 03                      set.x32 sp(3)
	<length+37 @053d3d>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@053d40>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@053d40> - <@053d72>)
	lib/std/string.ci:16: (42 bytes: <@053d40> - <@053d6a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @053d40>      : 19                         load.z32
	<indexOf+1 @053d41>    : 04 1b 00 00                jmp <indexOf+28 @053d5c>
	lib/std/string.ci:17: (19 bytes: <@053d45> - <@053d58>): if (bool(str[i] == chr))
	<indexOf+5 @053d45>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @053d47>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @053d49>    : 51                         add.i32
	<indexOf+10 @053d4a>   : 20                         load.i8
	<indexOf+11 @053d4b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @053d4f>   : 20                         load.i8
	<indexOf+16 @053d50>   : 57                         ceq.i32
	<indexOf+17 @053d51>   : 06 07 00 00                jz <indexOf+24 @053d58>
	lib/std/string.ci:18: (3 bytes: <@053d55> - <@053d58>): return int32(.result := i);
	<indexOf+21 @053d55>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @053d57>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@053d58> - <@053d5c>): int32(i := int32(i + 1))
	<indexOf+24 @053d58>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@053d5c> - <@053d66>): str[i]
	<indexOf+28 @053d5c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @053d5e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @053d60>   : 51                         add.i32
	<indexOf+33 @053d61>   : 20                         load.i8
	<indexOf+34 @053d62>   : 05 e3 ff ff                jnz <indexOf+5 @053d45>
	<indexOf+38 @053d66>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@053d6a> - <@053d72>): return int32(.result := int32(-1));
	<indexOf+42 @053d6a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @053d6f>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @053d71>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@053d78>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@053d78> - <@053daa>)
	lib/std/string.ci:26: (5 bytes: <@053d78> - <@053d7d>): result: int32 := int32(-1)
	<lastIndexOf @053d78>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@053d7d> - <@053da7>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @053d7d>    : 19                         load.z32
	<lastIndexOf+6 @053d7e>    : 04 1b 00 00                jmp <lastIndexOf+33 @053d99>
	lib/std/string.ci:28: (19 bytes: <@053d82> - <@053d95>): if (bool(str[i] == chr))
	<lastIndexOf+10 @053d82>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @053d84>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @053d86>   : 51                         add.i32
	<lastIndexOf+15 @053d87>   : 20                         load.i8
	<lastIndexOf+16 @053d88>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @053d8c>   : 20                         load.i8
	<lastIndexOf+21 @053d8d>   : 57                         ceq.i32
	<lastIndexOf+22 @053d8e>   : 06 07 00 00                jz <lastIndexOf+29 @053d95>
	lib/std/string.ci:29: (3 bytes: <@053d92> - <@053d95>): int32(result := i);
	<lastIndexOf+26 @053d92>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@053d95> - <@053d99>): int32(i := int32(i + 1))
	<lastIndexOf+29 @053d95>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@053d99> - <@053da3>): str[i]
	<lastIndexOf+33 @053d99>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @053d9b>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @053d9d>   : 51                         add.i32
	<lastIndexOf+38 @053d9e>   : 20                         load.i8
	<lastIndexOf+39 @053d9f>   : 05 e3 ff ff                jnz <lastIndexOf+10 @053d82>
	<lastIndexOf+43 @053da3>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@053da7> - <@053daa>): return int32(.result := result);
	<lastIndexOf+47 @053da7>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @053da9>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@053db0>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@053db0> - <@053df9>)
	lib/std/string.ci:37: (62 bytes: <@053db0> - <@053dee>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @053db0>      : 19                         load.z32
	<startsWith+1 @053db1>    : 04 2d 00 00                jmp <startsWith+46 @053dde>
	lib/std/string.ci:38: (37 bytes: <@053db5> - <@053dda>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @053db5>    : 19                         load.z32
	<startsWith+6 @053db6>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @053db8>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @053dba>   : 51                         add.i32
	<startsWith+11 @053dbb>   : 20                         load.i8
	<startsWith+12 @053dbc>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @053dbe>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @053dc0>   : 51                         add.i32
	<startsWith+17 @053dc1>   : 20                         load.i8
	<startsWith+18 @053dc2>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @053dc4>   : 02                         call
	<startsWith+21 @053dc5>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @053dc9>   : 19                         load.z32
	<startsWith+26 @053dca>   : 57                         ceq.i32
	<startsWith+27 @053dcb>   : 05 0f 00 00                jnz <startsWith+42 @053dda>
	lib/std/string.ci:39: (11 bytes: <@053dcf> - <@053dda>): return bool(.result := false);
	<startsWith+31 @053dcf>   : 19                         load.z32
	<startsWith+32 @053dd0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @053dd4>   : 25                         store.i8
	<startsWith+37 @053dd5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @053dd9>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@053dda> - <@053dde>): int32(i := int32(i + 1))
	<startsWith+42 @053dda>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@053dde> - <@053dea>): bool((with[i]) != 0)
	<startsWith+46 @053dde>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @053de0>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @053de2>   : 51                         add.i32
	<startsWith+51 @053de3>   : 20                         load.i8
	<startsWith+52 @053de4>   : 19                         load.z32
	<startsWith+53 @053de5>   : 57                         ceq.i32
	<startsWith+54 @053de6>   : 06 cf ff ff                jz <startsWith+5 @053db5>
	<startsWith+58 @053dea>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@053dee> - <@053df9>): return bool(.result := true);
	<startsWith+62 @053dee>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @053df3>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @053df7>   : 25                         store.i8
	<startsWith+72 @053df8>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@053e00>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@053e00> - <@053e7e>)
	lib/std/string.ci:47: (13 bytes: <@053e00> - <@053e0d>): withLen: int32 := length(with)
	<endsWith @053e00>      : 19                         load.z32
	<endsWith+1 @053e01>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @053e03>    : 1f 18 3d 05 00             load.ref <@053d18> ;length(str: char[*]): int32
	<endsWith+8 @053e08>    : 02                         call
	<endsWith+9 @053e09>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@053e0d> - <@053e1a>): strLen: int32 := length(str)
	<endsWith+13 @053e0d>   : 19                         load.z32
	<endsWith+14 @053e0e>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @053e10>   : 1f 18 3d 05 00             load.ref <@053d18> ;length(str: char[*]): int32
	<endsWith+21 @053e15>   : 02                         call
	<endsWith+22 @053e16>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@053e1a> - <@053e2e>): if (bool(strLen < withLen))
	<endsWith+26 @053e1a>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @053e1c>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @053e1e>   : 58                         clt.i32
	<endsWith+31 @053e1f>   : 06 0f 00 00                jz <endsWith+46 @053e2e>
	lib/std/string.ci:50: (11 bytes: <@053e23> - <@053e2e>): return bool(.result := false);
	<endsWith+35 @053e23>   : 19                         load.z32
	<endsWith+36 @053e24>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @053e28>   : 25                         store.i8
	<endsWith+41 @053e29>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @053e2d>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@053e2e> - <@053e6f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @053e2e>   : 19                         load.z32
	<endsWith+47 @053e2f>   : 04 33 00 00                jmp <endsWith+98 @053e62>
	lib/std/string.ci:53: (43 bytes: <@053e33> - <@053e5e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @053e33>   : 19                         load.z32
	<endsWith+52 @053e34>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @053e36>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @053e38>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @053e3a>   : 52                         sub.i32
	<endsWith+59 @053e3b>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @053e3d>   : 51                         add.i32
	<endsWith+62 @053e3e>   : 51                         add.i32
	<endsWith+63 @053e3f>   : 20                         load.i8
	<endsWith+64 @053e40>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @053e42>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @053e44>   : 51                         add.i32
	<endsWith+69 @053e45>   : 20                         load.i8
	<endsWith+70 @053e46>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @053e48>   : 02                         call
	<endsWith+73 @053e49>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @053e4d>   : 19                         load.z32
	<endsWith+78 @053e4e>   : 57                         ceq.i32
	<endsWith+79 @053e4f>   : 05 0f 00 00                jnz <endsWith+94 @053e5e>
	lib/std/string.ci:54: (11 bytes: <@053e53> - <@053e5e>): return bool(.result := false);
	<endsWith+83 @053e53>   : 19                         load.z32
	<endsWith+84 @053e54>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @053e58>   : 25                         store.i8
	<endsWith+89 @053e59>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @053e5d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@053e5e> - <@053e62>): int32(i := int32(i + 1))
	<endsWith+94 @053e5e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@053e62> - <@053e6b>): bool(i < withLen)
	<endsWith+98 @053e62>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @053e64>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @053e66>  : 58                         clt.i32
	<endsWith+103 @053e67>  : 05 cc ff ff                jnz <endsWith+51 @053e33>
	<endsWith+107 @053e6b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@053e6f> - <@053e7e>): return bool(.result := true);
	<endsWith+111 @053e6f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @053e74>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @053e78>  : 25                         store.i8
	<endsWith+121 @053e79>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @053e7d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@053e80>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@053e80> - <@053ebf>)
	lib/std/string.ci:62: (1 byte: <@053e80> - <@053e81>): result: int32 := 0
	<compare @053e80>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@053e81> - <@053ebc>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @053e81>    : 19                         load.z32
	<compare+2 @053e82>    : 04 2e 00 00                jmp <compare+48 @053eb0>
	lib/std/string.ci:64: (22 bytes: <@053e86> - <@053e9c>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @053e86>    : 19                         load.z32
	<compare+7 @053e87>    : 10 06                      dup.x32 sp(6)
	<compare+9 @053e89>    : 10 02                      dup.x32 sp(2)
	<compare+11 @053e8b>   : 51                         add.i32
	<compare+12 @053e8c>   : 20                         load.i8
	<compare+13 @053e8d>   : 10 06                      dup.x32 sp(6)
	<compare+15 @053e8f>   : 10 03                      dup.x32 sp(3)
	<compare+17 @053e91>   : 51                         add.i32
	<compare+18 @053e92>   : 20                         load.i8
	<compare+19 @053e93>   : 10 06                      dup.x32 sp(6)
	<compare+21 @053e95>   : 02                         call
	<compare+22 @053e96>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @053e9a>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@053e9c> - <@053eac>): if (bool((str[i]) == 0))
	<compare+28 @053e9c>   : 10 05                      dup.x32 sp(5)
	<compare+30 @053e9e>   : 10 01                      dup.x32 sp(1)
	<compare+32 @053ea0>   : 51                         add.i32
	<compare+33 @053ea1>   : 20                         load.i8
	<compare+34 @053ea2>   : 19                         load.z32
	<compare+35 @053ea3>   : 57                         ceq.i32
	<compare+36 @053ea4>   : 06 08 00 00                jz <compare+44 @053eac>
	lib/std/string.ci:66: (4 bytes: <@053ea8> - <@053eac>): break;
	<compare+40 @053ea8>   : 04 10 00 00                jmp <compare+56 @053eb8>
	lib/std/string.ci:63: (4 bytes: <@053eac> - <@053eb0>): int32(i := int32(i + 1))
	<compare+44 @053eac>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@053eb0> - <@053eb8>): bool(result == 0)
	<compare+48 @053eb0>   : 10 01                      dup.x32 sp(1)
	<compare+50 @053eb2>   : 19                         load.z32
	<compare+51 @053eb3>   : 57                         ceq.i32
	<compare+52 @053eb4>   : 05 d2 ff ff                jnz <compare+6 @053e86>
	<compare+56 @053eb8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@053ebc> - <@053ebf>): return int32(.result := result);
	<compare+60 @053ebc>   : 13 05                      set.x32 sp(5)
	<compare+62 @053ebe>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@053f08>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@053f08> - <@053f2c>)
	lib/std/string.ci:84: (36 bytes: <@053f08> - <@053f2c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @053f08>      : 19                         load.z32
	<ignCaseCmp+1 @053f09>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @053f0d>    : 20                         load.i8
	<ignCaseCmp+6 @053f0e>    : 1f c0 3e 05 00             load.ref <@053ec0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @053f13>   : 02                         call
	<ignCaseCmp+12 @053f14>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @053f18>   : 19                         load.z32
	<ignCaseCmp+17 @053f19>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @053f1d>   : 20                         load.i8
	<ignCaseCmp+22 @053f1e>   : 1f c0 3e 05 00             load.ref <@053ec0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @053f23>   : 02                         call
	<ignCaseCmp+28 @053f24>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @053f28>   : 52                         sub.i32
	<ignCaseCmp+33 @053f29>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @053f2b>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@053f30>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@053f30> - <@053f3e>)
	lib/std/string.ci:89: (14 bytes: <@053f30> - <@053f3e>): return char(.result := char(chr - with));
	<caseCmp @053f30>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @053f34>    : 20                         load.i8
	<caseCmp+5 @053f35>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @053f39>    : 20                         load.i8
	<caseCmp+10 @053f3a>   : 52                         sub.i32
	<caseCmp+11 @053f3b>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @053f3d>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@022ac8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@053f40>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@053f40> - <@053f94>)
	lib/std/string.ci:127: (56 bytes: <@053f40> - <@053f78>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @053f40>      : 19                         load.z32
	<append+1 @053f41>    : 04 29 00 00                jmp <append+42 @053f6a>
	lib/std/string.ci:128: (13 bytes: <@053f45> - <@053f52>): if (bool(pos >= (output.length)))
	<append+5 @053f45>    : 10 03                      dup.x32 sp(3)
	<append+7 @053f47>    : 10 06                      dup.x32 sp(6)
	<append+9 @053f49>    : 58                         clt.i32
	<append+10 @053f4a>   : 05 08 00 00                jnz <append+18 @053f52>
	lib/std/string.ci:129: (4 bytes: <@053f4e> - <@053f52>): break;
	<append+14 @053f4e>   : 04 26 00 00                jmp <append+52 @053f74>
	lib/std/string.ci:131: (12 bytes: <@053f52> - <@053f5e>): char(output[pos] := value[i]);
	<append+18 @053f52>   : 10 02                      dup.x32 sp(2)
	<append+20 @053f54>   : 10 01                      dup.x32 sp(1)
	<append+22 @053f56>   : 51                         add.i32
	<append+23 @053f57>   : 20                         load.i8
	<append+24 @053f58>   : 10 05                      dup.x32 sp(5)
	<append+26 @053f5a>   : 10 05                      dup.x32 sp(5)
	<append+28 @053f5c>   : 51                         add.i32
	<append+29 @053f5d>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@053f5e> - <@053f66>): int32(pos := int32(pos + 1));
	<append+30 @053f5e>   : 10 03                      dup.x32 sp(3)
	<append+32 @053f60>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @053f64>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:127: (4 bytes: <@053f66> - <@053f6a>): int32(i := int32(i + 1))
	<append+38 @053f66>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@053f6a> - <@053f74>): value[i]
	<append+42 @053f6a>   : 10 02                      dup.x32 sp(2)
	<append+44 @053f6c>   : 10 01                      dup.x32 sp(1)
	<append+46 @053f6e>   : 51                         add.i32
	<append+47 @053f6f>   : 20                         load.i8
	<append+48 @053f70>   : 05 d5 ff ff                jnz <append+5 @053f45>
	<append+52 @053f74>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@053f78> - <@053f89>): if (bool(pos >= (output.length)))
	<append+56 @053f78>   : 10 02                      dup.x32 sp(2)
	<append+58 @053f7a>   : 10 05                      dup.x32 sp(5)
	<append+60 @053f7c>   : 58                         clt.i32
	<append+61 @053f7d>   : 05 0c 00 00                jnz <append+73 @053f89>
	lib/std/string.ci:136: (8 bytes: <@053f81> - <@053f89>): int32(pos := (uint32(output.length - (1))));
	<append+65 @053f81>   : 10 04                      dup.x32 sp(4)
	<append+67 @053f83>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @053f87>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:138: (7 bytes: <@053f89> - <@053f90>): char(output[pos] := (0));
	<append+73 @053f89>   : 19                         load.z32
	<append+74 @053f8a>   : 10 04                      dup.x32 sp(4)
	<append+76 @053f8c>   : 10 04                      dup.x32 sp(4)
	<append+78 @053f8e>   : 51                         add.i32
	<append+79 @053f8f>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@053f90> - <@053f94>): return int32(.result := pos);
	<append+80 @053f90>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @053f93>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@053fa8>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@053fa8> - <@054239>)
	lib/std/string.ci:147: (1 byte: <@053fa8> - <@053fa9>): len: int32 := 0
	<append @053fa8>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@053fa9> - <@053fad>): digits: char[80]
	<append+1 @053fa9>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@053fad> - <@053fb0>): radix: int32 := format.radix
	<append+5 @053fad>    : 10 16                      dup.x32 sp(22)
	<append+7 @053faf>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@053fb0> - <@053fe6>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @053fb0>    : 10 00                      dup.x32 sp(0)
	<append+10 @053fb2>   : 1c 01 00 00 00             load.c32 1
	<append+15 @053fb7>   : 59                         cgt.i32
	<append+16 @053fb8>   : 06 08 00 00                jz <append+24 @053fc0>
	<append+20 @053fbc>   : 04 2a 00 00                jmp <append+62 @053fe6>
	<append+24 @053fc0>   : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+29 @053fc5>   : 1c 97 00 00 00             load.c32 151
	<append+34 @053fca>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @053fcf>   : 1c 80 00 00 00             load.c32 128
	<append+44 @053fd4>   : 1f 22 f6 01 00             load.ref <@01f622> ;"radix is too small"
	<append+49 @053fd9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @053fde>   : 0a 18 00 00                load.sp(+24)
	<append+58 @053fe2>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@053fe6> - <@05401b>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @053fe6>   : 10 00                      dup.x32 sp(0)
	<append+64 @053fe8>   : 2a a4 3f 05                load.m32 <@053fa4> ;append.radixDigits+4
	<append+68 @053fec>   : 58                         clt.i32
	<append+69 @053fed>   : 06 08 00 00                jz <append+77 @053ff5>
	<append+73 @053ff1>   : 04 2a 00 00                jmp <append+115 @05401b>
	<append+77 @053ff5>   : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+82 @053ffa>   : 1c 98 00 00 00             load.c32 152
	<append+87 @053fff>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @054004>   : 1c 80 00 00 00             load.c32 128
	<append+97 @054009>   : 1f 35 f6 01 00             load.ref <@01f635> ;"radix is too big"
	<append+102 @05400e>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @054013>  : 0a 18 00 00                load.sp(+24)
	<append+111 @054017>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@05401b> - <@054049>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @05401b>  : 04 26 00 00                jmp <append+153 @054041>
	lib/std/string.ci:156: (27 bytes: <@05401f> - <@05403a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @05401f>  : 2a a0 3f 05                load.m32 <@053fa0> ;append.radixDigits
	<append+123 @054023>  : 10 19                      dup.x32 sp(25)
	<append+125 @054025>  : 10 02                      dup.x32 sp(2)
	<append+127 @054027>  : 35                         mod.u32
	<append+128 @054028>  : 51                         add.i32
	<append+129 @054029>  : 20                         load.i8
	<append+130 @05402a>  : 0a 08 00 00                load.sp(+8)
	<append+134 @05402e>  : 10 17                      dup.x32 sp(23)
	<append+136 @054030>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @054034>  : 10 00                      dup.x32 sp(0)
	<append+142 @054036>  : 13 19                      set.x32 sp(25)
	<append+144 @054038>  : 51                         add.i32
	<append+145 @054039>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@05403a> - <@054041>): uint32(value := uint32(value / (radix)))
	<append+146 @05403a>  : 10 18                      dup.x32 sp(24)
	<append+148 @05403c>  : 10 01                      dup.x32 sp(1)
	<append+150 @05403e>  : 34                         div.u32
	<append+151 @05403f>  : 13 19                      set.x32 sp(25)
	lib/std/string.ci:155: (8 bytes: <@054041> - <@054049>): bool(value > (0))
	<append+153 @054041>  : 10 18                      dup.x32 sp(24)
	<append+155 @054043>  : 19                         load.z32
	<append+156 @054044>  : 39                         cgt.u32
	<append+157 @054045>  : 05 da ff ff                jnz <append+119 @05401f>
	lib/std/string.ci:158: (29 bytes: <@054049> - <@054066>): if (bool(len == 0))
	<append+161 @054049>  : 10 15                      dup.x32 sp(21)
	<append+163 @05404b>  : 19                         load.z32
	<append+164 @05404c>  : 57                         ceq.i32
	<append+165 @05404d>  : 06 19 00 00                jz <append+190 @054066>
	lib/std/string.ci:159: (21 bytes: <@054051> - <@054066>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @054051>  : 1c 30 00 00 00             load.c32 48
	<append+174 @054056>  : 0a 08 00 00                load.sp(+8)
	<append+178 @05405a>  : 10 17                      dup.x32 sp(23)
	<append+180 @05405c>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @054060>  : 10 00                      dup.x32 sp(0)
	<append+186 @054062>  : 13 19                      set.x32 sp(25)
	<append+188 @054064>  : 51                         add.i32
	<append+189 @054065>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@054066> - <@054070>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @054066>  : 10 17                      dup.x32 sp(23)
	<append+192 @054068>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @05406c>  : 22                         load.i32
	<append+197 @05406d>  : 10 16                      dup.x32 sp(22)
	<append+199 @05406f>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@054070> - <@054077>): padChr: char := format.padChr
	<append+200 @054070>  : 10 18                      dup.x32 sp(24)
	<append+202 @054072>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @054076>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@054077> - <@05408c>): if (bool(padChr == ''))
	<append+207 @054077>  : 0a 00 00 00                load.sp(+0)
	<append+211 @05407b>  : 20                         load.i8
	<append+212 @05407c>  : 19                         load.z32
	<append+213 @05407d>  : 57                         ceq.i32
	<append+214 @05407e>  : 06 0e 00 00                jz <append+228 @05408c>
	lib/std/string.ci:166: (10 bytes: <@054082> - <@05408c>): char(padChr := ' ');
	<append+218 @054082>  : 1c 20 00 00 00             load.c32 32
	<append+223 @054087>  : 0a 04 00 00                load.sp(+4)
	<append+227 @05408b>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@05408c> - <@05415b>): if (bool((sign) != 0))
	<append+228 @05408c>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @054090>  : 20                         load.i8
	<append+233 @054091>  : 19                         load.z32
	<append+234 @054092>  : 57                         ceq.i32
	<append+235 @054093>  : 05 c8 00 00                jnz <append+435 @05415b>
	lib/std/string.ci:171: (8 bytes: <@054097> - <@05409f>): int32(maxLen := int32(maxLen - 1));
	<append+239 @054097>  : 10 01                      dup.x32 sp(1)
	<append+241 @054099>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @05409d>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:172: (117 bytes: <@05409f> - <@054114>): if (contains(void(whiteSpace, padChr)))
	<append+247 @05409f>  : 19                         load.z32
	<append+248 @0540a0>  : 2a 98 3f 05                load.m32 <@053f98> ;append.whiteSpace
	<append+252 @0540a4>  : 0a 08 00 00                load.sp(+8)
	<append+256 @0540a8>  : 20                         load.i8
	<append+257 @0540a9>  : 1f 40 3d 05 00             load.ref <@053d40> ;indexOf(str: char[*], chr: char): int32
	<append+262 @0540ae>  : 02                         call
	<append+263 @0540af>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @0540b3>  : 19                         load.z32
	<append+268 @0540b4>  : 58                         clt.i32
	<append+269 @0540b5>  : 05 5f 00 00                jnz <append+364 @054114>
	lib/std/string.ci:174: (91 bytes: <@0540b9> - <@054114>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @0540b9>  : 04 53 00 00                jmp <append+356 @05410c>
	lib/std/string.ci:175: (52 bytes: <@0540bd> - <@0540f1>): assert(bool(pos < (output.length)));
	<append+277 @0540bd>  : 10 1c                      dup.x32 sp(28)
	<append+279 @0540bf>  : 10 1f                      dup.x32 sp(31)
	<append+281 @0540c1>  : 58                         clt.i32
	<append+282 @0540c2>  : 06 08 00 00                jz <append+290 @0540ca>
	<append+286 @0540c6>  : 04 2b 00 00                jmp <append+329 @0540f1>
	<append+290 @0540ca>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+295 @0540cf>  : 1c af 00 00 00             load.c32 175
	<append+300 @0540d4>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @0540d9>  : 1c 80 00 00 00             load.c32 128
	<append+310 @0540de>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+315 @0540e3>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @0540e8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @0540ed>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@0540f1> - <@0540fc>): char(output[pos] := padChr);
	<append+329 @0540f1>  : 0a 00 00 00                load.sp(+0)
	<append+333 @0540f5>  : 20                         load.i8
	<append+334 @0540f6>  : 10 1e                      dup.x32 sp(30)
	<append+336 @0540f8>  : 10 1e                      dup.x32 sp(30)
	<append+338 @0540fa>  : 51                         add.i32
	<append+339 @0540fb>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@0540fc> - <@054104>): int32(pos := int32(pos + 1));
	<append+340 @0540fc>  : 10 1c                      dup.x32 sp(28)
	<append+342 @0540fe>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @054102>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:174: (8 bytes: <@054104> - <@05410c>): int32(maxLen := int32(maxLen - 1))
	<append+348 @054104>  : 10 01                      dup.x32 sp(1)
	<append+350 @054106>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @05410a>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:174: (8 bytes: <@05410c> - <@054114>): bool(maxLen > 0)
	<append+356 @05410c>  : 10 01                      dup.x32 sp(1)
	<append+358 @05410e>  : 19                         load.z32
	<append+359 @05410f>  : 59                         cgt.i32
	<append+360 @054110>  : 05 ad ff ff                jnz <append+277 @0540bd>
	lib/std/string.ci:180: (52 bytes: <@054114> - <@054148>): assert(bool(pos < (output.length)));
	<append+364 @054114>  : 10 1c                      dup.x32 sp(28)
	<append+366 @054116>  : 10 1f                      dup.x32 sp(31)
	<append+368 @054118>  : 58                         clt.i32
	<append+369 @054119>  : 06 08 00 00                jz <append+377 @054121>
	<append+373 @05411d>  : 04 2b 00 00                jmp <append+416 @054148>
	<append+377 @054121>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+382 @054126>  : 1c b4 00 00 00             load.c32 180
	<append+387 @05412b>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @054130>  : 1c 80 00 00 00             load.c32 128
	<append+397 @054135>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+402 @05413a>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @05413f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @054144>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@054148> - <@054153>): char(output[pos] := sign);
	<append+416 @054148>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @05414c>  : 20                         load.i8
	<append+421 @05414d>  : 10 1e                      dup.x32 sp(30)
	<append+423 @05414f>  : 10 1e                      dup.x32 sp(30)
	<append+425 @054151>  : 51                         add.i32
	<append+426 @054152>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@054153> - <@05415b>): int32(pos := int32(pos + 1));
	<append+427 @054153>  : 10 1c                      dup.x32 sp(28)
	<append+429 @054155>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @054159>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (91 bytes: <@05415b> - <@0541b6>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @05415b>  : 04 53 00 00                jmp <append+518 @0541ae>
	lib/std/string.ci:187: (52 bytes: <@05415f> - <@054193>): assert(bool(pos < (output.length)));
	<append+439 @05415f>  : 10 1c                      dup.x32 sp(28)
	<append+441 @054161>  : 10 1f                      dup.x32 sp(31)
	<append+443 @054163>  : 58                         clt.i32
	<append+444 @054164>  : 06 08 00 00                jz <append+452 @05416c>
	<append+448 @054168>  : 04 2b 00 00                jmp <append+491 @054193>
	<append+452 @05416c>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+457 @054171>  : 1c bb 00 00 00             load.c32 187
	<append+462 @054176>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @05417b>  : 1c 80 00 00 00             load.c32 128
	<append+472 @054180>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+477 @054185>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @05418a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @05418f>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@054193> - <@05419e>): char(output[pos] := padChr);
	<append+491 @054193>  : 0a 00 00 00                load.sp(+0)
	<append+495 @054197>  : 20                         load.i8
	<append+496 @054198>  : 10 1e                      dup.x32 sp(30)
	<append+498 @05419a>  : 10 1e                      dup.x32 sp(30)
	<append+500 @05419c>  : 51                         add.i32
	<append+501 @05419d>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@05419e> - <@0541a6>): int32(pos := int32(pos + 1));
	<append+502 @05419e>  : 10 1c                      dup.x32 sp(28)
	<append+504 @0541a0>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @0541a4>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (8 bytes: <@0541a6> - <@0541ae>): int32(maxLen := int32(maxLen - 1))
	<append+510 @0541a6>  : 10 01                      dup.x32 sp(1)
	<append+512 @0541a8>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @0541ac>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:186: (8 bytes: <@0541ae> - <@0541b6>): bool(maxLen > 0)
	<append+518 @0541ae>  : 10 01                      dup.x32 sp(1)
	<append+520 @0541b0>  : 19                         load.z32
	<append+521 @0541b1>  : 59                         cgt.i32
	<append+522 @0541b2>  : 05 ad ff ff                jnz <append+439 @05415f>
	lib/std/string.ci:193: (99 bytes: <@0541b6> - <@054219>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @0541b6>  : 19                         load.z32
	<append+527 @0541b7>  : 04 55 00 00                jmp <append+612 @05420c>
	lib/std/string.ci:194: (52 bytes: <@0541bb> - <@0541ef>): assert(bool(i < (output.length)));
	<append+531 @0541bb>  : 10 00                      dup.x32 sp(0)
	<append+533 @0541bd>  : 10 20                      dup.x32 sp(32)
	<append+535 @0541bf>  : 58                         clt.i32
	<append+536 @0541c0>  : 06 08 00 00                jz <append+544 @0541c8>
	<append+540 @0541c4>  : 04 2b 00 00                jmp <append+583 @0541ef>
	<append+544 @0541c8>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+549 @0541cd>  : 1c c2 00 00 00             load.c32 194
	<append+554 @0541d2>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @0541d7>  : 1c 80 00 00 00             load.c32 128
	<append+564 @0541dc>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+569 @0541e1>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @0541e6>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @0541eb>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@0541ef> - <@054200>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @0541ef>  : 0a 10 00 00                load.sp(+16)
	<append+587 @0541f3>  : 10 19                      dup.x32 sp(25)
	<append+589 @0541f5>  : 10 02                      dup.x32 sp(2)
	<append+591 @0541f7>  : 52                         sub.i32
	<append+592 @0541f8>  : 51                         add.i32
	<append+593 @0541f9>  : 20                         load.i8
	<append+594 @0541fa>  : 10 1f                      dup.x32 sp(31)
	<append+596 @0541fc>  : 10 1f                      dup.x32 sp(31)
	<append+598 @0541fe>  : 51                         add.i32
	<append+599 @0541ff>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@054200> - <@054208>): int32(pos := int32(pos + 1));
	<append+600 @054200>  : 10 1d                      dup.x32 sp(29)
	<append+602 @054202>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @054206>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:193: (4 bytes: <@054208> - <@05420c>): int32(i := int32(i + 1))
	<append+608 @054208>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@05420c> - <@054215>): bool(i < len)
	<append+612 @05420c>  : 10 00                      dup.x32 sp(0)
	<append+614 @05420e>  : 10 19                      dup.x32 sp(25)
	<append+616 @054210>  : 58                         clt.i32
	<append+617 @054211>  : 05 aa ff ff                jnz <append+531 @0541bb>
	<append+621 @054215>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@054219> - <@05422a>): if (bool(pos >= (output.length)))
	<append+625 @054219>  : 10 1c                      dup.x32 sp(28)
	<append+627 @05421b>  : 10 1f                      dup.x32 sp(31)
	<append+629 @05421d>  : 58                         clt.i32
	<append+630 @05421e>  : 05 0c 00 00                jnz <append+642 @05422a>
	lib/std/string.ci:200: (8 bytes: <@054222> - <@05422a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @054222>  : 10 1e                      dup.x32 sp(30)
	<append+636 @054224>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @054228>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:202: (7 bytes: <@05422a> - <@054231>): char(output[pos] := (0));
	<append+642 @05422a>  : 19                         load.z32
	<append+643 @05422b>  : 10 1e                      dup.x32 sp(30)
	<append+645 @05422d>  : 10 1e                      dup.x32 sp(30)
	<append+647 @05422f>  : 51                         add.i32
	<append+648 @054230>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@054231> - <@054239>): return int32(.result := pos);
	<append+649 @054231>  : 16 1f 1c                   mov.x32 sp(31, 28)
	<append+652 @054234>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @054238>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@054240>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@054240> - <@054257>)
	lib/std/string.ci:208: (23 bytes: <@054240> - <@054257>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @054240>      : 19                         load.z32
	<append+1 @054241>    : 11 05                      dup.x64 sp(5)
	<append+3 @054243>    : 10 06                      dup.x32 sp(6)
	<append+5 @054245>    : 19                         load.z32
	<append+6 @054246>    : 10 07                      dup.x32 sp(7)
	<append+8 @054248>    : 10 07                      dup.x32 sp(7)
	<append+10 @05424a>   : 1f a8 3f 05 00             load.ref <@053fa8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @05424f>   : 02                         call
	<append+16 @054250>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @054254>   : 13 07                      set.x32 sp(7)
	<append+22 @054256>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@054258>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@054258> - <@054289>)
	lib/std/string.ci:213: (1 byte: <@054258> - <@054259>): sign: int32 := 0
	<append @054258>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@054259> - <@05426d>): if (bool(value < 0))
	<append+1 @054259>    : 10 03                      dup.x32 sp(3)
	<append+3 @05425b>    : 19                         load.z32
	<append+4 @05425c>    : 58                         clt.i32
	<append+5 @05425d>    : 06 10 00 00                jz <append+21 @05426d>
	lib/std/string.ci:215: (7 bytes: <@054261> - <@054268>): int32(sign := ('-'));
	<append+9 @054261>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @054266>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:216: (5 bytes: <@054268> - <@05426d>): int32(value := int32(-value));
	<append+16 @054268>   : 10 03                      dup.x32 sp(3)
	<append+18 @05426a>   : 50                         neg.i32
	<append+19 @05426b>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:218: (28 bytes: <@05426d> - <@054289>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @05426d>   : 19                         load.z32
	<append+22 @05426e>   : 11 06                      dup.x64 sp(6)
	<append+24 @054270>   : 10 07                      dup.x32 sp(7)
	<append+26 @054272>   : 10 04                      dup.x32 sp(4)
	<append+28 @054274>   : 10 08                      dup.x32 sp(8)
	<append+30 @054276>   : 10 08                      dup.x32 sp(8)
	<append+32 @054278>   : 1f a8 3f 05 00             load.ref <@053fa8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @05427d>   : 02                         call
	<append+38 @05427e>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @054282>   : 13 08                      set.x32 sp(8)
	<append+44 @054284>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @054288>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@0542a0>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@0542a0> - <@0542b9>)
	lib/std/string.ci:224: (25 bytes: <@0542a0> - <@0542b9>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @0542a0>      : 19                         load.z32
	<append+1 @0542a1>    : 11 04                      dup.x64 sp(4)
	<append+3 @0542a3>    : 10 05                      dup.x32 sp(5)
	<append+5 @0542a5>    : 10 05                      dup.x32 sp(5)
	<append+7 @0542a7>    : 1f 90 42 05 00             load.ref <@054290> ;append.format
	<append+12 @0542ac>   : 1f 40 42 05 00             load.ref <@054240> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @0542b1>   : 02                         call
	<append+18 @0542b2>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @0542b6>   : 13 06                      set.x32 sp(6)
	<append+24 @0542b8>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024c58>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0542c0>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@0542c0> - <@0542c7>)
	lib/vec/vec2d.ci:17: (7 bytes: <@0542c0> - <@0542c7>): return void(.result := {...});
	<vec2d @0542c0>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@0542c3> - <@0542c6>): void(.result.y := y);
	<vec2d+3 @0542c3>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @0542c6>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@025c28>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:170: referenced as `vec4f`
	lib/vec/mat4f.ci:160: referenced as `vec4f`
	lib/vec/mat4f.ci:157: referenced as `vec4f`
	lib/vec/mat4f.ci:108: referenced as `vec4f`
	lib/vec/mat4f.ci:108: referenced as `vec4f`
	lib/vec/mat4f.ci:86: referenced as `vec4f`
	lib/vec/mat4f.ci:84: referenced as `vec4f`
	lib/vec/mat4f.ci:82: referenced as `vec4f`
	lib/vec/mat4f.ci:77: referenced as `vec4f`
	lib/vec/mat4f.ci:77: referenced as `vec4f`
	lib/vec/mat4f.ci:77: referenced as `vec4f`
	lib/vec/mat4f.ci:77: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:109: referenced as `vec4f`
	lib/vec/vec4f.ci:106: referenced as `vec4f`
	lib/vec/vec4f.ci:104: referenced as `vec4f`
	lib/vec/vec4f.ci:101: referenced as `vec4f`
	lib/vec/vec4f.ci:101: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:94: referenced as `vec4f`
	lib/vec/vec4f.ci:94: referenced as `vec4f`
	lib/vec/vec4f.ci:90: referenced as `vec4f`
	lib/vec/vec4f.ci:90: referenced as `vec4f`
	lib/vec/vec4f.ci:86: referenced as `vec4f`
	lib/vec/vec4f.ci:86: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:81: referenced as `vec4f`
	lib/vec/vec4f.ci:81: referenced as `vec4f`
	lib/vec/vec4f.ci:81: referenced as `vec4f`
	lib/vec/vec4f.ci:79: referenced as `vec4f`
	lib/vec/vec4f.ci:79: referenced as `vec4f`
	lib/vec/vec4f.ci:79: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:39: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:111'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:111: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/mat4f.ci:176: referenced as `x`
	lib/vec/mat4f.ci:175: referenced as `x`
	lib/vec/mat4f.ci:174: referenced as `x`
	lib/vec/mat4f.ci:173: referenced as `x`
	lib/vec/mat4f.ci:173: referenced as `x`
	lib/vec/mat4f.ci:165: referenced as `x`
	lib/vec/mat4f.ci:164: referenced as `x`
	lib/vec/mat4f.ci:163: referenced as `x`
	lib/vec/mat4f.ci:162: referenced as `x`
	lib/vec/mat4f.ci:162: referenced as `x`
	lib/vec/mat4f.ci:122: referenced as `x`
	lib/vec/mat4f.ci:119: referenced as `x`
	lib/vec/mat4f.ci:94: referenced as `x`
	lib/vec/mat4f.ci:93: referenced as `x`
	lib/vec/mat4f.ci:92: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:72: referenced as `x`
	lib/vec/mat4f.ci:71: referenced as `x`
	lib/vec/mat4f.ci:70: referenced as `x`
	lib/vec/mat4f.ci:69: referenced as `x`
	lib/vec/vec4f.ci:109: referenced as `x`
	lib/vec/vec4f.ci:101: referenced as `x`
	lib/vec/vec4f.ci:101: referenced as `x`
	lib/vec/vec4f.ci:101: referenced as `x`
	lib/vec/vec4f.ci:101: referenced as `x`
	lib/vec/vec4f.ci:39: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/mat4f.ci:176: referenced as `y`
	lib/vec/mat4f.ci:175: referenced as `y`
	lib/vec/mat4f.ci:174: referenced as `y`
	lib/vec/mat4f.ci:173: referenced as `y`
	lib/vec/mat4f.ci:174: referenced as `y`
	lib/vec/mat4f.ci:165: referenced as `y`
	lib/vec/mat4f.ci:164: referenced as `y`
	lib/vec/mat4f.ci:163: referenced as `y`
	lib/vec/mat4f.ci:162: referenced as `y`
	lib/vec/mat4f.ci:163: referenced as `y`
	lib/vec/mat4f.ci:123: referenced as `y`
	lib/vec/mat4f.ci:120: referenced as `y`
	lib/vec/mat4f.ci:94: referenced as `y`
	lib/vec/mat4f.ci:93: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:91: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:72: referenced as `y`
	lib/vec/mat4f.ci:71: referenced as `y`
	lib/vec/mat4f.ci:70: referenced as `y`
	lib/vec/mat4f.ci:69: referenced as `y`
	lib/vec/vec4f.ci:109: referenced as `y`
	lib/vec/vec4f.ci:101: referenced as `y`
	lib/vec/vec4f.ci:101: referenced as `y`
	lib/vec/vec4f.ci:101: referenced as `y`
	lib/vec/vec4f.ci:101: referenced as `y`
	lib/vec/vec4f.ci:39: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/vec/mat4f.ci:176: referenced as `z`
	lib/vec/mat4f.ci:175: referenced as `z`
	lib/vec/mat4f.ci:174: referenced as `z`
	lib/vec/mat4f.ci:173: referenced as `z`
	lib/vec/mat4f.ci:175: referenced as `z`
	lib/vec/mat4f.ci:165: referenced as `z`
	lib/vec/mat4f.ci:164: referenced as `z`
	lib/vec/mat4f.ci:163: referenced as `z`
	lib/vec/mat4f.ci:162: referenced as `z`
	lib/vec/mat4f.ci:164: referenced as `z`
	lib/vec/mat4f.ci:124: referenced as `z`
	lib/vec/mat4f.ci:121: referenced as `z`
	lib/vec/mat4f.ci:94: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:92: referenced as `z`
	lib/vec/mat4f.ci:91: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:72: referenced as `z`
	lib/vec/mat4f.ci:71: referenced as `z`
	lib/vec/mat4f.ci:70: referenced as `z`
	lib/vec/mat4f.ci:69: referenced as `z`
	lib/vec/vec4f.ci:109: referenced as `z`
	lib/vec/vec4f.ci:101: referenced as `z`
	lib/vec/vec4f.ci:101: referenced as `z`
	lib/vec/vec4f.ci:101: referenced as `z`
	lib/vec/vec4f.ci:101: referenced as `z`
	lib/vec/vec4f.ci:39: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/vec/mat4f.ci:176: referenced as `w`
	lib/vec/mat4f.ci:175: referenced as `w`
	lib/vec/mat4f.ci:174: referenced as `w`
	lib/vec/mat4f.ci:173: referenced as `w`
	lib/vec/mat4f.ci:165: referenced as `w`
	lib/vec/mat4f.ci:164: referenced as `w`
	lib/vec/mat4f.ci:163: referenced as `w`
	lib/vec/mat4f.ci:162: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:93: referenced as `w`
	lib/vec/mat4f.ci:92: referenced as `w`
	lib/vec/mat4f.ci:91: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:72: referenced as `w`
	lib/vec/mat4f.ci:71: referenced as `w`
	lib/vec/mat4f.ci:70: referenced as `w`
	lib/vec/mat4f.ci:69: referenced as `w`
	lib/vec/vec4f.ci:109: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0542c8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@0542c8> - <@0542d5>)
	lib/vec/vec4f.ci:29: (13 bytes: <@0542c8> - <@0542d5>): return void(.result := {...});
	<vec4f @0542c8>      : 16 05 04                   mov.x32 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@0542cb> - <@0542ce>): void(.result.y := y);
	<vec4f+3 @0542cb>    : 16 06 03                   mov.x32 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@0542ce> - <@0542d1>): void(.result.z := z);
	<vec4f+6 @0542ce>    : 16 07 02                   mov.x32 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@0542d1> - <@0542d4>): void(.result.w := w);
	<vec4f+9 @0542d1>    : 16 08 01                   mov.x32 sp(8, 1)
	<vec4f+12 @0542d4>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:152: referenced as `vec4f`
	lib/vec/mat4f.ci:116: referenced as `vec4f`
	lib/vec/mat4f.ci:115: referenced as `vec4f`
	lib/vec/mat4f.ci:114: referenced as `vec4f`
	lib/vec/mat4f.ci:113: referenced as `vec4f`
	lib/vec/mat4f.ci:86: referenced as `vec4f`
	lib/vec/mat4f.ci:84: referenced as `vec4f`
	lib/vec/mat4f.ci:82: referenced as `vec4f`
	lib/vec/vec4f.ci:42: referenced as `vec4f`
	lib/vec/vec4f.ci:39: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:33: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:33'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	lib/vec/vec4f.ci:101: referenced as `vec4f`
	lib/vec/vec4f.ci:33: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
	lib/vec/vec4f.ci:36: defined as `vec4f(x: float32, y: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:39'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:39: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:42'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/mat4f.ci:157: referenced as `vec4f`
	lib/vec/vec4f.ci:106: referenced as `vec4f`
	lib/vec/vec4f.ci:42: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:75: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:77: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:79'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:79: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/vec/vec4f.ci:81'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:106: referenced as `div`
	lib/vec/vec4f.ci:81: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:84: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/vec/vec4f.ci:86'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:86: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:90'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:82: referenced as `dp3`
	lib/vec/mat4f.ci:82: referenced as `dp3`
	lib/vec/mat4f.ci:82: referenced as `dp3`
	lib/vec/vec4f.ci:104: referenced as `dp3`
	lib/vec/vec4f.ci:90: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:94'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:84: referenced as `dph`
	lib/vec/mat4f.ci:84: referenced as `dph`
	lib/vec/mat4f.ci:84: referenced as `dph`
	lib/vec/mat4f.ci:84: referenced as `dph`
	lib/vec/vec4f.ci:94: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:86: referenced as `dp4`
	lib/vec/mat4f.ci:86: referenced as `dp4`
	lib/vec/mat4f.ci:86: referenced as `dp4`
	lib/vec/mat4f.ci:86: referenced as `dp4`
	lib/vec/vec4f.ci:98: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:101'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:101: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'lib/vec/vec4f.ci:104'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/mat4f.ci:109: referenced as `length`
	lib/vec/vec4f.ci:106: referenced as `length`
	lib/vec/vec4f.ci:104: defined as `length(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:106'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
	lib/vec/vec4f.ci:106: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:109'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:109: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@029390>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:170: referenced as `mat4f`
	lib/vec/mat4f.ci:160: referenced as `mat4f`
	lib/vec/mat4f.ci:108: referenced as `mat4f`
	lib/vec/mat4f.ci:90: referenced as `mat4f`
	lib/vec/mat4f.ci:89: referenced as `mat4f`
	lib/vec/mat4f.ci:89: referenced as `mat4f`
	lib/vec/mat4f.ci:89: referenced as `mat4f`
	lib/vec/mat4f.ci:86: referenced as `mat4f`
	lib/vec/mat4f.ci:84: referenced as `mat4f`
	lib/vec/mat4f.ci:82: referenced as `mat4f`
	lib/vec/mat4f.ci:77: referenced as `mat4f`
	lib/vec/mat4f.ci:64: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `data`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `m`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:180'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:180: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:173: referenced as `x`
	lib/vec/mat4f.ci:162: referenced as `x`
	lib/vec/mat4f.ci:113: referenced as `x`
	lib/vec/mat4f.ci:97: referenced as `x`
	lib/vec/mat4f.ci:97: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:94: referenced as `x`
	lib/vec/mat4f.ci:93: referenced as `x`
	lib/vec/mat4f.ci:92: referenced as `x`
	lib/vec/mat4f.ci:91: referenced as `x`
	lib/vec/mat4f.ci:86: referenced as `x`
	lib/vec/mat4f.ci:84: referenced as `x`
	lib/vec/mat4f.ci:82: referenced as `x`
	lib/vec/mat4f.ci:78: referenced as `x`
	lib/vec/mat4f.ci:69: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:174: referenced as `y`
	lib/vec/mat4f.ci:163: referenced as `y`
	lib/vec/mat4f.ci:114: referenced as `y`
	lib/vec/mat4f.ci:98: referenced as `y`
	lib/vec/mat4f.ci:98: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:94: referenced as `y`
	lib/vec/mat4f.ci:93: referenced as `y`
	lib/vec/mat4f.ci:92: referenced as `y`
	lib/vec/mat4f.ci:91: referenced as `y`
	lib/vec/mat4f.ci:86: referenced as `y`
	lib/vec/mat4f.ci:84: referenced as `y`
	lib/vec/mat4f.ci:82: referenced as `y`
	lib/vec/mat4f.ci:78: referenced as `y`
	lib/vec/mat4f.ci:70: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:175: referenced as `z`
	lib/vec/mat4f.ci:164: referenced as `z`
	lib/vec/mat4f.ci:115: referenced as `z`
	lib/vec/mat4f.ci:99: referenced as `z`
	lib/vec/mat4f.ci:99: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:94: referenced as `z`
	lib/vec/mat4f.ci:93: referenced as `z`
	lib/vec/mat4f.ci:92: referenced as `z`
	lib/vec/mat4f.ci:91: referenced as `z`
	lib/vec/mat4f.ci:86: referenced as `z`
	lib/vec/mat4f.ci:84: referenced as `z`
	lib/vec/mat4f.ci:82: referenced as `z`
	lib/vec/mat4f.ci:78: referenced as `z`
	lib/vec/mat4f.ci:71: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:176: referenced as `w`
	lib/vec/mat4f.ci:165: referenced as `w`
	lib/vec/mat4f.ci:152: referenced as `w`
	lib/vec/mat4f.ci:116: referenced as `w`
	lib/vec/mat4f.ci:100: referenced as `w`
	lib/vec/mat4f.ci:100: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:94: referenced as `w`
	lib/vec/mat4f.ci:93: referenced as `w`
	lib/vec/mat4f.ci:92: referenced as `w`
	lib/vec/mat4f.ci:91: referenced as `w`
	lib/vec/mat4f.ci:86: referenced as `w`
	lib/vec/mat4f.ci:84: referenced as `w`
	lib/vec/mat4f.ci:78: referenced as `w`
	lib/vec/mat4f.ci:72: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:180'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
	lib/vec/mat4f.ci:180: defined as `<?>`
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'lib/vec/mat4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:137: referenced as `xx`
	lib/vec/mat4f.ci:26: defined as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'lib/vec/mat4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:138: referenced as `xy`
	lib/vec/mat4f.ci:28: defined as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'lib/vec/mat4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:139: referenced as `xz`
	lib/vec/mat4f.ci:30: defined as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'lib/vec/mat4f.ci:32'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:140: referenced as `xw`
	lib/vec/mat4f.ci:32: defined as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'lib/vec/mat4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:142: referenced as `yx`
	lib/vec/mat4f.ci:35: defined as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'lib/vec/mat4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:143: referenced as `yy`
	lib/vec/mat4f.ci:37: defined as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'lib/vec/mat4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:144: referenced as `yz`
	lib/vec/mat4f.ci:39: defined as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'lib/vec/mat4f.ci:41'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:145: referenced as `yw`
	lib/vec/mat4f.ci:41: defined as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'lib/vec/mat4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:147: referenced as `zx`
	lib/vec/mat4f.ci:44: defined as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'lib/vec/mat4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:148: referenced as `zy`
	lib/vec/mat4f.ci:46: defined as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'lib/vec/mat4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:149: referenced as `zz`
	lib/vec/mat4f.ci:48: defined as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'lib/vec/mat4f.ci:50'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:150: referenced as `zw`
	lib/vec/mat4f.ci:50: defined as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'lib/vec/mat4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:53: defined as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'lib/vec/mat4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:55: defined as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'lib/vec/mat4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:57: defined as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:59: defined as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'lib/vec/mat4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xx: float32
.usages:
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'lib/vec/mat4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xy: float32
.usages:
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'lib/vec/mat4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xz: float32
.usages:
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'lib/vec/mat4f.ci:32'
.owner: mat4f
.doc: '@public'
.value: xw: float32
.usages:
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'lib/vec/mat4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yx: float32
.usages:
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'lib/vec/mat4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yy: float32
.usages:
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'lib/vec/mat4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yz: float32
.usages:
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'lib/vec/mat4f.ci:41'
.owner: mat4f
.doc: '@public'
.value: yw: float32
.usages:
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'lib/vec/mat4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zx: float32
.usages:
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'lib/vec/mat4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zy: float32
.usages:
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'lib/vec/mat4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zz: float32
.usages:
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'lib/vec/mat4f.ci:50'
.owner: mat4f
.doc: '@public'
.value: zw: float32
.usages:
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'lib/vec/mat4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wx: float32
.usages:
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'lib/vec/mat4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wy: float32
.usages:
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'lib/vec/mat4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: wz: float32
.usages:
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f
.doc: '@public'
.value: ww: float32
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0542d8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:64'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@0542d8> - <@054309>)
	lib/vec/mat4f.ci:68: (49 bytes: <@0542d8> - <@054309>): return void(.result := {...});
	<mat4f @0542d8>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/vec/mat4f.ci:69: (3 bytes: <@0542db> - <@0542de>): void(.result.x.y := xy);
	<mat4f+3 @0542db>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/vec/mat4f.ci:69: (3 bytes: <@0542de> - <@0542e1>): void(.result.x.z := xz);
	<mat4f+6 @0542de>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/vec/mat4f.ci:69: (3 bytes: <@0542e1> - <@0542e4>): void(.result.x.w := xw);
	<mat4f+9 @0542e1>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/vec/mat4f.ci:70: (3 bytes: <@0542e4> - <@0542e7>): void(.result.y.x := yx);
	<mat4f+12 @0542e4>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/vec/mat4f.ci:70: (3 bytes: <@0542e7> - <@0542ea>): void(.result.y.y := yy);
	<mat4f+15 @0542e7>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/vec/mat4f.ci:70: (3 bytes: <@0542ea> - <@0542ed>): void(.result.y.z := yz);
	<mat4f+18 @0542ea>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/vec/mat4f.ci:70: (3 bytes: <@0542ed> - <@0542f0>): void(.result.y.w := yw);
	<mat4f+21 @0542ed>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/vec/mat4f.ci:71: (3 bytes: <@0542f0> - <@0542f3>): void(.result.z.x := zx);
	<mat4f+24 @0542f0>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/vec/mat4f.ci:71: (3 bytes: <@0542f3> - <@0542f6>): void(.result.z.y := zy);
	<mat4f+27 @0542f3>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/vec/mat4f.ci:71: (3 bytes: <@0542f6> - <@0542f9>): void(.result.z.z := zz);
	<mat4f+30 @0542f6>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/vec/mat4f.ci:71: (3 bytes: <@0542f9> - <@0542fc>): void(.result.z.w := zw);
	<mat4f+33 @0542f9>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/vec/mat4f.ci:72: (3 bytes: <@0542fc> - <@0542ff>): void(.result.w.x := wx);
	<mat4f+36 @0542fc>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/vec/mat4f.ci:72: (3 bytes: <@0542ff> - <@054302>): void(.result.w.y := wy);
	<mat4f+39 @0542ff>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/vec/mat4f.ci:72: (3 bytes: <@054302> - <@054305>): void(.result.w.z := wz);
	<mat4f+42 @054302>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/vec/mat4f.ci:72: (3 bytes: <@054305> - <@054308>): void(.result.w.w := ww);
	<mat4f+45 @054305>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @054308>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:64: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@054310>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:77'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@054310> - <@054325>)
	lib/vec/mat4f.ci:78: (21 bytes: <@054310> - <@054325>): return void(.result := {...});
	<mat4f @054310>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @054312>    : 24                         load.i128
	<mat4f+3 @054313>    : 15 09                      set.x128 sp(9)
	lib/vec/mat4f.ci:78: (5 bytes: <@054315> - <@05431a>): void(.result.y := y);
	<mat4f+5 @054315>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @054317>    : 24                         load.i128
	<mat4f+8 @054318>    : 15 0d                      set.x128 sp(13)
	lib/vec/mat4f.ci:78: (5 bytes: <@05431a> - <@05431f>): void(.result.z := z);
	<mat4f+10 @05431a>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @05431c>   : 24                         load.i128
	<mat4f+13 @05431d>   : 15 11                      set.x128 sp(17)
	lib/vec/mat4f.ci:78: (5 bytes: <@05431f> - <@054324>): void(.result.w := w);
	<mat4f+15 @05431f>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @054321>   : 24                         load.i128
	<mat4f+18 @054322>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @054324>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:77: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:82: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:84: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:86'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:100: referenced as `dp4`
	lib/vec/mat4f.ci:99: referenced as `dp4`
	lib/vec/mat4f.ci:98: referenced as `dp4`
	lib/vec/mat4f.ci:97: referenced as `dp4`
	lib/vec/mat4f.ci:86: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@054328>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:89'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@054328> - <@0544c9>)
	lib/vec/mat4f.ci:90: (144 bytes: <@054328> - <@0543b8>): transposed: mat4f := {...}
	<mul @054328>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:91: (5 bytes: <@05432c> - <@054331>): void(transposed.x.x := rhs.x.x);
	<mul+4 @05432c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @05432e>    : 22                         load.i32
	<mul+7 @05432f>    : 13 01                      set.x32 sp(1)
	lib/vec/mat4f.ci:91: (9 bytes: <@054331> - <@05433a>): void(transposed.x.y := rhs.y.x);
	<mul+9 @054331>    : 10 11                      dup.x32 sp(17)
	<mul+11 @054333>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @054337>   : 22                         load.i32
	<mul+16 @054338>   : 13 02                      set.x32 sp(2)
	lib/vec/mat4f.ci:91: (9 bytes: <@05433a> - <@054343>): void(transposed.x.z := rhs.z.x);
	<mul+18 @05433a>   : 10 11                      dup.x32 sp(17)
	<mul+20 @05433c>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @054340>   : 22                         load.i32
	<mul+25 @054341>   : 13 03                      set.x32 sp(3)
	lib/vec/mat4f.ci:91: (9 bytes: <@054343> - <@05434c>): void(transposed.x.w := rhs.w.x);
	<mul+27 @054343>   : 10 11                      dup.x32 sp(17)
	<mul+29 @054345>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @054349>   : 22                         load.i32
	<mul+34 @05434a>   : 13 04                      set.x32 sp(4)
	lib/vec/mat4f.ci:92: (9 bytes: <@05434c> - <@054355>): void(transposed.y.x := rhs.x.y);
	<mul+36 @05434c>   : 10 11                      dup.x32 sp(17)
	<mul+38 @05434e>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @054352>   : 22                         load.i32
	<mul+43 @054353>   : 13 05                      set.x32 sp(5)
	lib/vec/mat4f.ci:92: (9 bytes: <@054355> - <@05435e>): void(transposed.y.y := rhs.y.y);
	<mul+45 @054355>   : 10 11                      dup.x32 sp(17)
	<mul+47 @054357>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @05435b>   : 22                         load.i32
	<mul+52 @05435c>   : 13 06                      set.x32 sp(6)
	lib/vec/mat4f.ci:92: (9 bytes: <@05435e> - <@054367>): void(transposed.y.z := rhs.z.y);
	<mul+54 @05435e>   : 10 11                      dup.x32 sp(17)
	<mul+56 @054360>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @054364>   : 22                         load.i32
	<mul+61 @054365>   : 13 07                      set.x32 sp(7)
	lib/vec/mat4f.ci:92: (9 bytes: <@054367> - <@054370>): void(transposed.y.w := rhs.w.y);
	<mul+63 @054367>   : 10 11                      dup.x32 sp(17)
	<mul+65 @054369>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @05436d>   : 22                         load.i32
	<mul+70 @05436e>   : 13 08                      set.x32 sp(8)
	lib/vec/mat4f.ci:93: (9 bytes: <@054370> - <@054379>): void(transposed.z.x := rhs.x.z);
	<mul+72 @054370>   : 10 11                      dup.x32 sp(17)
	<mul+74 @054372>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @054376>   : 22                         load.i32
	<mul+79 @054377>   : 13 09                      set.x32 sp(9)
	lib/vec/mat4f.ci:93: (9 bytes: <@054379> - <@054382>): void(transposed.z.y := rhs.y.z);
	<mul+81 @054379>   : 10 11                      dup.x32 sp(17)
	<mul+83 @05437b>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @05437f>   : 22                         load.i32
	<mul+88 @054380>   : 13 0a                      set.x32 sp(10)
	lib/vec/mat4f.ci:93: (9 bytes: <@054382> - <@05438b>): void(transposed.z.z := rhs.z.z);
	<mul+90 @054382>   : 10 11                      dup.x32 sp(17)
	<mul+92 @054384>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @054388>   : 22                         load.i32
	<mul+97 @054389>   : 13 0b                      set.x32 sp(11)
	lib/vec/mat4f.ci:93: (9 bytes: <@05438b> - <@054394>): void(transposed.z.w := rhs.w.z);
	<mul+99 @05438b>   : 10 11                      dup.x32 sp(17)
	<mul+101 @05438d>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @054391>  : 22                         load.i32
	<mul+106 @054392>  : 13 0c                      set.x32 sp(12)
	lib/vec/mat4f.ci:94: (9 bytes: <@054394> - <@05439d>): void(transposed.w.x := rhs.x.w);
	<mul+108 @054394>  : 10 11                      dup.x32 sp(17)
	<mul+110 @054396>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @05439a>  : 22                         load.i32
	<mul+115 @05439b>  : 13 0d                      set.x32 sp(13)
	lib/vec/mat4f.ci:94: (9 bytes: <@05439d> - <@0543a6>): void(transposed.w.y := rhs.y.w);
	<mul+117 @05439d>  : 10 11                      dup.x32 sp(17)
	<mul+119 @05439f>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @0543a3>  : 22                         load.i32
	<mul+124 @0543a4>  : 13 0e                      set.x32 sp(14)
	lib/vec/mat4f.ci:94: (9 bytes: <@0543a6> - <@0543af>): void(transposed.w.z := rhs.z.w);
	<mul+126 @0543a6>  : 10 11                      dup.x32 sp(17)
	<mul+128 @0543a8>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @0543ac>  : 22                         load.i32
	<mul+133 @0543ad>  : 13 0f                      set.x32 sp(15)
	lib/vec/mat4f.ci:94: (9 bytes: <@0543af> - <@0543b8>): void(transposed.w.w := rhs.w.w);
	<mul+135 @0543af>  : 10 11                      dup.x32 sp(17)
	<mul+137 @0543b1>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @0543b5>  : 22                         load.i32
	<mul+142 @0543b6>  : 13 10                      set.x32 sp(16)
	lib/vec/mat4f.ci:96: (273 bytes: <@0543b8> - <@0544c9>): return void(.result := {...});
	<mul+144 @0543b8>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @0543bc>  : 10 13                      dup.x32 sp(19)
	<mul+150 @0543be>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @0543c2>  : 10 05                      dup.x32 sp(5)
	<mul+156 @0543c4>  : 24                         load.i128
	<mul+157 @0543c5>  : 10 08                      dup.x32 sp(8)
	<mul+159 @0543c7>  : 24                         load.i128
	<mul+160 @0543c8>  : 9b                         dp4.v4f
	<mul+161 @0543c9>  : 10 06                      dup.x32 sp(6)
	<mul+163 @0543cb>  : 0c 10 00 00                inc.i32(+16)
	<mul+167 @0543cf>  : 24                         load.i128
	<mul+168 @0543d0>  : 10 09                      dup.x32 sp(9)
	<mul+170 @0543d2>  : 24                         load.i128
	<mul+171 @0543d3>  : 9b                         dp4.v4f
	<mul+172 @0543d4>  : 10 07                      dup.x32 sp(7)
	<mul+174 @0543d6>  : 0c 20 00 00                inc.i32(+32)
	<mul+178 @0543da>  : 24                         load.i128
	<mul+179 @0543db>  : 10 0a                      dup.x32 sp(10)
	<mul+181 @0543dd>  : 24                         load.i128
	<mul+182 @0543de>  : 9b                         dp4.v4f
	<mul+183 @0543df>  : 10 08                      dup.x32 sp(8)
	<mul+185 @0543e1>  : 0c 30 00 00                inc.i32(+48)
	<mul+189 @0543e5>  : 24                         load.i128
	<mul+190 @0543e6>  : 10 0b                      dup.x32 sp(11)
	<mul+192 @0543e8>  : 24                         load.i128
	<mul+193 @0543e9>  : 9b                         dp4.v4f
	<mul+194 @0543ea>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @0543ef>  : 02                         call
	<mul+200 @0543f0>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @0543f4>  : 15 02                      set.x128 sp(2)
	<mul+206 @0543f6>  : 15 17                      set.x128 sp(23)
	lib/vec/mat4f.ci:98: (68 bytes: <@0543f8> - <@05443c>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @0543f8>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @0543fc>  : 10 13                      dup.x32 sp(19)
	<mul+214 @0543fe>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @054402>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @054406>  : 10 05                      dup.x32 sp(5)
	<mul+224 @054408>  : 24                         load.i128
	<mul+225 @054409>  : 10 08                      dup.x32 sp(8)
	<mul+227 @05440b>  : 24                         load.i128
	<mul+228 @05440c>  : 9b                         dp4.v4f
	<mul+229 @05440d>  : 10 06                      dup.x32 sp(6)
	<mul+231 @05440f>  : 0c 10 00 00                inc.i32(+16)
	<mul+235 @054413>  : 24                         load.i128
	<mul+236 @054414>  : 10 09                      dup.x32 sp(9)
	<mul+238 @054416>  : 24                         load.i128
	<mul+239 @054417>  : 9b                         dp4.v4f
	<mul+240 @054418>  : 10 07                      dup.x32 sp(7)
	<mul+242 @05441a>  : 0c 20 00 00                inc.i32(+32)
	<mul+246 @05441e>  : 24                         load.i128
	<mul+247 @05441f>  : 10 0a                      dup.x32 sp(10)
	<mul+249 @054421>  : 24                         load.i128
	<mul+250 @054422>  : 9b                         dp4.v4f
	<mul+251 @054423>  : 10 08                      dup.x32 sp(8)
	<mul+253 @054425>  : 0c 30 00 00                inc.i32(+48)
	<mul+257 @054429>  : 24                         load.i128
	<mul+258 @05442a>  : 10 0b                      dup.x32 sp(11)
	<mul+260 @05442c>  : 24                         load.i128
	<mul+261 @05442d>  : 9b                         dp4.v4f
	<mul+262 @05442e>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @054433>  : 02                         call
	<mul+268 @054434>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @054438>  : 15 02                      set.x128 sp(2)
	<mul+274 @05443a>  : 15 1b                      set.x128 sp(27)
	lib/vec/mat4f.ci:99: (68 bytes: <@05443c> - <@054480>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @05443c>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @054440>  : 10 13                      dup.x32 sp(19)
	<mul+282 @054442>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @054446>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @05444a>  : 10 05                      dup.x32 sp(5)
	<mul+292 @05444c>  : 24                         load.i128
	<mul+293 @05444d>  : 10 08                      dup.x32 sp(8)
	<mul+295 @05444f>  : 24                         load.i128
	<mul+296 @054450>  : 9b                         dp4.v4f
	<mul+297 @054451>  : 10 06                      dup.x32 sp(6)
	<mul+299 @054453>  : 0c 10 00 00                inc.i32(+16)
	<mul+303 @054457>  : 24                         load.i128
	<mul+304 @054458>  : 10 09                      dup.x32 sp(9)
	<mul+306 @05445a>  : 24                         load.i128
	<mul+307 @05445b>  : 9b                         dp4.v4f
	<mul+308 @05445c>  : 10 07                      dup.x32 sp(7)
	<mul+310 @05445e>  : 0c 20 00 00                inc.i32(+32)
	<mul+314 @054462>  : 24                         load.i128
	<mul+315 @054463>  : 10 0a                      dup.x32 sp(10)
	<mul+317 @054465>  : 24                         load.i128
	<mul+318 @054466>  : 9b                         dp4.v4f
	<mul+319 @054467>  : 10 08                      dup.x32 sp(8)
	<mul+321 @054469>  : 0c 30 00 00                inc.i32(+48)
	<mul+325 @05446d>  : 24                         load.i128
	<mul+326 @05446e>  : 10 0b                      dup.x32 sp(11)
	<mul+328 @054470>  : 24                         load.i128
	<mul+329 @054471>  : 9b                         dp4.v4f
	<mul+330 @054472>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @054477>  : 02                         call
	<mul+336 @054478>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @05447c>  : 15 02                      set.x128 sp(2)
	<mul+342 @05447e>  : 15 1f                      set.x128 sp(31)
	lib/vec/mat4f.ci:100: (68 bytes: <@054480> - <@0544c4>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @054480>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @054484>  : 10 13                      dup.x32 sp(19)
	<mul+350 @054486>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @05448a>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @05448e>  : 10 05                      dup.x32 sp(5)
	<mul+360 @054490>  : 24                         load.i128
	<mul+361 @054491>  : 10 08                      dup.x32 sp(8)
	<mul+363 @054493>  : 24                         load.i128
	<mul+364 @054494>  : 9b                         dp4.v4f
	<mul+365 @054495>  : 10 06                      dup.x32 sp(6)
	<mul+367 @054497>  : 0c 10 00 00                inc.i32(+16)
	<mul+371 @05449b>  : 24                         load.i128
	<mul+372 @05449c>  : 10 09                      dup.x32 sp(9)
	<mul+374 @05449e>  : 24                         load.i128
	<mul+375 @05449f>  : 9b                         dp4.v4f
	<mul+376 @0544a0>  : 10 07                      dup.x32 sp(7)
	<mul+378 @0544a2>  : 0c 20 00 00                inc.i32(+32)
	<mul+382 @0544a6>  : 24                         load.i128
	<mul+383 @0544a7>  : 10 0a                      dup.x32 sp(10)
	<mul+385 @0544a9>  : 24                         load.i128
	<mul+386 @0544aa>  : 9b                         dp4.v4f
	<mul+387 @0544ab>  : 10 08                      dup.x32 sp(8)
	<mul+389 @0544ad>  : 0c 30 00 00                inc.i32(+48)
	<mul+393 @0544b1>  : 24                         load.i128
	<mul+394 @0544b2>  : 10 0b                      dup.x32 sp(11)
	<mul+396 @0544b4>  : 24                         load.i128
	<mul+397 @0544b5>  : 9b                         dp4.v4f
	<mul+398 @0544b6>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @0544bb>  : 02                         call
	<mul+404 @0544bc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @0544c0>  : 15 02                      set.x128 sp(2)
	<mul+410 @0544c2>  : 15 23                      set.x128 sp(35)
	<mul+412 @0544c4>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @0544c8>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:89: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 524
.offset: <@0544d0>
.name: 'rotation'
.file: 'lib/vec/mat4f.ci:108'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (524 bytes: <@0544d0> - <@0546dc>)
	lib/vec/mat4f.ci:109: (18 bytes: <@0544d0> - <@0544e2>): len: float32 := length(direction)
	<rotation @0544d0>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @0544d2>    : 24                         load.i128
	<rotation+3 @0544d3>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @0544d5>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @0544d7>    : 9a                         dp3.v4f
	<rotation+8 @0544d8>    : 01 24 00 00                nfc(36) ;float32.sqrt(x: float32): float32
	<rotation+12 @0544dc>   : 13 04                      set.x32 sp(4)
	<rotation+14 @0544de>   : 09 f4 ff ff                inc.sp(-12)
	lib/vec/mat4f.ci:110: (138 bytes: <@0544e2> - <@05456c>): if (bool((len) < 0.000000))
	<rotation+18 @0544e2>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @0544e4>   : 7d                         f32.2f64
	<rotation+21 @0544e5>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @0544ee>   : 88                         clt.f64
	<rotation+31 @0544ef>   : 06 7d 00 00                jz <rotation+156 @05456c>
	lib/vec/mat4f.ci:111: (36 bytes: <@0544f3> - <@054517>): trace(void("invalid direction of rotation", direction));
	<rotation+35 @0544f3>   : 1f 68 90 02 00             load.ref <@029068> ;"lib/vec/mat4f.ci"
	<rotation+40 @0544f8>   : 1c 6f 00 00 00             load.c32 111
	<rotation+45 @0544fd>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @054502>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @054507>   : 1f fa 92 02 00             load.ref <@0292fa> ;"invalid direction of rotation"
	<rotation+60 @05450c>   : 1f 28 5c 02 00             load.ref <@025c28> ;vec4f
	<rotation+65 @054511>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @054513>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/vec/mat4f.ci:112: (85 bytes: <@054517> - <@05456c>): return void(.result := {...});
	<rotation+71 @054517>   : 09 10 00 00                inc.sp(+16)
	<rotation+75 @05451b>   : 19                         load.z32
	<rotation+76 @05451c>   : 19                         load.z32
	<rotation+77 @05451d>   : 19                         load.z32
	<rotation+78 @05451e>   : 19                         load.z32
	<rotation+79 @05451f>   : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+84 @054524>   : 02                         call
	<rotation+85 @054525>   : 09 f0 ff ff                inc.sp(-16)
	<rotation+89 @054529>   : 15 09                      set.x128 sp(9)
	lib/vec/mat4f.ci:114: (20 bytes: <@05452b> - <@05453f>): void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+91 @05452b>   : 09 10 00 00                inc.sp(+16)
	<rotation+95 @05452f>   : 19                         load.z32
	<rotation+96 @054530>   : 19                         load.z32
	<rotation+97 @054531>   : 19                         load.z32
	<rotation+98 @054532>   : 19                         load.z32
	<rotation+99 @054533>   : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+104 @054538>  : 02                         call
	<rotation+105 @054539>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+109 @05453d>  : 15 0d                      set.x128 sp(13)
	lib/vec/mat4f.ci:115: (20 bytes: <@05453f> - <@054553>): void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+111 @05453f>  : 09 10 00 00                inc.sp(+16)
	<rotation+115 @054543>  : 19                         load.z32
	<rotation+116 @054544>  : 19                         load.z32
	<rotation+117 @054545>  : 19                         load.z32
	<rotation+118 @054546>  : 19                         load.z32
	<rotation+119 @054547>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+124 @05454c>  : 02                         call
	<rotation+125 @05454d>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+129 @054551>  : 15 11                      set.x128 sp(17)
	lib/vec/mat4f.ci:116: (20 bytes: <@054553> - <@054567>): void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+131 @054553>  : 09 10 00 00                inc.sp(+16)
	<rotation+135 @054557>  : 19                         load.z32
	<rotation+136 @054558>  : 19                         load.z32
	<rotation+137 @054559>  : 19                         load.z32
	<rotation+138 @05455a>  : 19                         load.z32
	<rotation+139 @05455b>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+144 @054560>  : 02                         call
	<rotation+145 @054561>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+149 @054565>  : 15 15                      set.x128 sp(21)
	<rotation+151 @054567>  : 09 fc ff ff                inc.sp(-4)
	<rotation+155 @05456b>  : 03                         ret
	lib/vec/mat4f.ci:119: (6 bytes: <@05456c> - <@054572>): x: float32 := float32(direction.x / len)
	<rotation+156 @05456c>  : 10 03                      dup.x32 sp(3)
	<rotation+158 @05456e>  : 22                         load.i32
	<rotation+159 @05456f>  : 10 01                      dup.x32 sp(1)
	<rotation+161 @054571>  : 74                         div.f32
	lib/vec/mat4f.ci:120: (10 bytes: <@054572> - <@05457c>): y: float32 := float32(direction.y / len)
	<rotation+162 @054572>  : 10 04                      dup.x32 sp(4)
	<rotation+164 @054574>  : 0c 04 00 00                inc.i32(+4)
	<rotation+168 @054578>  : 22                         load.i32
	<rotation+169 @054579>  : 10 02                      dup.x32 sp(2)
	<rotation+171 @05457b>  : 74                         div.f32
	lib/vec/mat4f.ci:121: (10 bytes: <@05457c> - <@054586>): z: float32 := float32(direction.z / len)
	<rotation+172 @05457c>  : 10 05                      dup.x32 sp(5)
	<rotation+174 @05457e>  : 0c 08 00 00                inc.i32(+8)
	<rotation+178 @054582>  : 22                         load.i32
	<rotation+179 @054583>  : 10 03                      dup.x32 sp(3)
	<rotation+181 @054585>  : 74                         div.f32
	lib/vec/mat4f.ci:122: (3 bytes: <@054586> - <@054589>): cx: float32 := center.x
	<rotation+182 @054586>  : 10 07                      dup.x32 sp(7)
	<rotation+184 @054588>  : 22                         load.i32
	lib/vec/mat4f.ci:123: (7 bytes: <@054589> - <@054590>): cy: float32 := center.y
	<rotation+185 @054589>  : 10 08                      dup.x32 sp(8)
	<rotation+187 @05458b>  : 0c 04 00 00                inc.i32(+4)
	<rotation+191 @05458f>  : 22                         load.i32
	lib/vec/mat4f.ci:124: (7 bytes: <@054590> - <@054597>): cz: float32 := center.z
	<rotation+192 @054590>  : 10 09                      dup.x32 sp(9)
	<rotation+194 @054592>  : 0c 08 00 00                inc.i32(+8)
	<rotation+198 @054596>  : 22                         load.i32
	lib/vec/mat4f.ci:125: (5 bytes: <@054597> - <@05459c>): xx: float32 := float32(x * x)
	<rotation+199 @054597>  : 10 05                      dup.x32 sp(5)
	<rotation+201 @054599>  : 10 06                      dup.x32 sp(6)
	<rotation+203 @05459b>  : 73                         mul.f32
	lib/vec/mat4f.ci:126: (5 bytes: <@05459c> - <@0545a1>): xy: float32 := float32(x * y)
	<rotation+204 @05459c>  : 10 06                      dup.x32 sp(6)
	<rotation+206 @05459e>  : 10 06                      dup.x32 sp(6)
	<rotation+208 @0545a0>  : 73                         mul.f32
	lib/vec/mat4f.ci:127: (5 bytes: <@0545a1> - <@0545a6>): xz: float32 := float32(x * z)
	<rotation+209 @0545a1>  : 10 07                      dup.x32 sp(7)
	<rotation+211 @0545a3>  : 10 06                      dup.x32 sp(6)
	<rotation+213 @0545a5>  : 73                         mul.f32
	lib/vec/mat4f.ci:128: (5 bytes: <@0545a6> - <@0545ab>): yy: float32 := float32(y * y)
	<rotation+214 @0545a6>  : 10 07                      dup.x32 sp(7)
	<rotation+216 @0545a8>  : 10 08                      dup.x32 sp(8)
	<rotation+218 @0545aa>  : 73                         mul.f32
	lib/vec/mat4f.ci:129: (5 bytes: <@0545ab> - <@0545b0>): yz: float32 := float32(y * z)
	<rotation+219 @0545ab>  : 10 08                      dup.x32 sp(8)
	<rotation+221 @0545ad>  : 10 08                      dup.x32 sp(8)
	<rotation+223 @0545af>  : 73                         mul.f32
	lib/vec/mat4f.ci:130: (5 bytes: <@0545b0> - <@0545b5>): zz: float32 := float32(z * z)
	<rotation+224 @0545b0>  : 10 08                      dup.x32 sp(8)
	<rotation+226 @0545b2>  : 10 09                      dup.x32 sp(9)
	<rotation+228 @0545b4>  : 73                         mul.f32
	lib/vec/mat4f.ci:132: (6 bytes: <@0545b5> - <@0545bb>): s: float32 := float32.sin(angle)
	<rotation+229 @0545b5>  : 10 0e                      dup.x32 sp(14)
	<rotation+231 @0545b7>  : 01 1e 00 00                nfc(30) ;float32.sin(x: float32): float32
	lib/vec/mat4f.ci:133: (6 bytes: <@0545bb> - <@0545c1>): c: float32 := float32.cos(angle)
	<rotation+235 @0545bb>  : 10 0f                      dup.x32 sp(15)
	<rotation+237 @0545bd>  : 01 1f 00 00                nfc(31) ;float32.cos(x: float32): float32
	lib/vec/mat4f.ci:134: (8 bytes: <@0545c1> - <@0545c9>): k: float32 := float32((1) - c)
	<rotation+241 @0545c1>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+246 @0545c6>  : 10 01                      dup.x32 sp(1)
	<rotation+248 @0545c8>  : 72                         sub.f32
	lib/vec/mat4f.ci:136: (275 bytes: <@0545c9> - <@0546dc>): return void(.result := {...});
	<rotation+249 @0545c9>  : 10 08                      dup.x32 sp(8)
	<rotation+251 @0545cb>  : 10 06                      dup.x32 sp(6)
	<rotation+253 @0545cd>  : 10 05                      dup.x32 sp(5)
	<rotation+255 @0545cf>  : 71                         add.f32
	<rotation+256 @0545d0>  : 10 03                      dup.x32 sp(3)
	<rotation+258 @0545d2>  : 73                         mul.f32
	<rotation+259 @0545d3>  : 71                         add.f32
	<rotation+260 @0545d4>  : 13 15                      set.x32 sp(21)
	lib/vec/mat4f.ci:138: (13 bytes: <@0545d6> - <@0545e3>): void(.result.xy := float32(float32(xy * k) - float32(z * s)));
	<rotation+262 @0545d6>  : 10 07                      dup.x32 sp(7)
	<rotation+264 @0545d8>  : 10 01                      dup.x32 sp(1)
	<rotation+266 @0545da>  : 73                         mul.f32
	<rotation+267 @0545db>  : 10 0d                      dup.x32 sp(13)
	<rotation+269 @0545dd>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @0545df>  : 73                         mul.f32
	<rotation+272 @0545e0>  : 72                         sub.f32
	<rotation+273 @0545e1>  : 13 16                      set.x32 sp(22)
	lib/vec/mat4f.ci:139: (13 bytes: <@0545e3> - <@0545f0>): void(.result.xz := float32(float32(xz * k) + float32(y * s)));
	<rotation+275 @0545e3>  : 10 06                      dup.x32 sp(6)
	<rotation+277 @0545e5>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @0545e7>  : 73                         mul.f32
	<rotation+280 @0545e8>  : 10 0e                      dup.x32 sp(14)
	<rotation+282 @0545ea>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @0545ec>  : 73                         mul.f32
	<rotation+285 @0545ed>  : 71                         add.f32
	<rotation+286 @0545ee>  : 13 17                      set.x32 sp(23)
	lib/vec/mat4f.ci:140: (43 bytes: <@0545f0> - <@05461b>): void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
	<rotation+288 @0545f0>  : 10 0b                      dup.x32 sp(11)
	<rotation+290 @0545f2>  : 10 06                      dup.x32 sp(6)
	<rotation+292 @0545f4>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @0545f6>  : 71                         add.f32
	<rotation+295 @0545f7>  : 73                         mul.f32
	<rotation+296 @0545f8>  : 10 0f                      dup.x32 sp(15)
	<rotation+298 @0545fa>  : 10 0c                      dup.x32 sp(12)
	<rotation+300 @0545fc>  : 10 10                      dup.x32 sp(16)
	<rotation+302 @0545fe>  : 73                         mul.f32
	<rotation+303 @0545ff>  : 10 0c                      dup.x32 sp(12)
	<rotation+305 @054601>  : 10 10                      dup.x32 sp(16)
	<rotation+307 @054603>  : 73                         mul.f32
	<rotation+308 @054604>  : 71                         add.f32
	<rotation+309 @054605>  : 73                         mul.f32
	<rotation+310 @054606>  : 72                         sub.f32
	<rotation+311 @054607>  : 10 01                      dup.x32 sp(1)
	<rotation+313 @054609>  : 73                         mul.f32
	<rotation+314 @05460a>  : 10 0b                      dup.x32 sp(11)
	<rotation+316 @05460c>  : 10 0e                      dup.x32 sp(14)
	<rotation+318 @05460e>  : 73                         mul.f32
	<rotation+319 @05460f>  : 10 0b                      dup.x32 sp(11)
	<rotation+321 @054611>  : 10 10                      dup.x32 sp(16)
	<rotation+323 @054613>  : 73                         mul.f32
	<rotation+324 @054614>  : 72                         sub.f32
	<rotation+325 @054615>  : 10 04                      dup.x32 sp(4)
	<rotation+327 @054617>  : 73                         mul.f32
	<rotation+328 @054618>  : 71                         add.f32
	<rotation+329 @054619>  : 13 18                      set.x32 sp(24)
	lib/vec/mat4f.ci:142: (13 bytes: <@05461b> - <@054628>): void(.result.yx := float32(float32(xy * k) + float32(z * s)));
	<rotation+331 @05461b>  : 10 07                      dup.x32 sp(7)
	<rotation+333 @05461d>  : 10 01                      dup.x32 sp(1)
	<rotation+335 @05461f>  : 73                         mul.f32
	<rotation+336 @054620>  : 10 0d                      dup.x32 sp(13)
	<rotation+338 @054622>  : 10 04                      dup.x32 sp(4)
	<rotation+340 @054624>  : 73                         mul.f32
	<rotation+341 @054625>  : 71                         add.f32
	<rotation+342 @054626>  : 13 19                      set.x32 sp(25)
	lib/vec/mat4f.ci:143: (13 bytes: <@054628> - <@054635>): void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
	<rotation+344 @054628>  : 10 05                      dup.x32 sp(5)
	<rotation+346 @05462a>  : 10 09                      dup.x32 sp(9)
	<rotation+348 @05462c>  : 10 05                      dup.x32 sp(5)
	<rotation+350 @05462e>  : 71                         add.f32
	<rotation+351 @05462f>  : 10 03                      dup.x32 sp(3)
	<rotation+353 @054631>  : 73                         mul.f32
	<rotation+354 @054632>  : 71                         add.f32
	<rotation+355 @054633>  : 13 1a                      set.x32 sp(26)
	lib/vec/mat4f.ci:144: (13 bytes: <@054635> - <@054642>): void(.result.yz := float32(float32(yz * k) - float32(x * s)));
	<rotation+357 @054635>  : 10 04                      dup.x32 sp(4)
	<rotation+359 @054637>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @054639>  : 73                         mul.f32
	<rotation+362 @05463a>  : 10 0f                      dup.x32 sp(15)
	<rotation+364 @05463c>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @05463e>  : 73                         mul.f32
	<rotation+367 @05463f>  : 72                         sub.f32
	<rotation+368 @054640>  : 13 1b                      set.x32 sp(27)
	lib/vec/mat4f.ci:145: (43 bytes: <@054642> - <@05466d>): void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
	<rotation+370 @054642>  : 10 0a                      dup.x32 sp(10)
	<rotation+372 @054644>  : 10 09                      dup.x32 sp(9)
	<rotation+374 @054646>  : 10 05                      dup.x32 sp(5)
	<rotation+376 @054648>  : 71                         add.f32
	<rotation+377 @054649>  : 73                         mul.f32
	<rotation+378 @05464a>  : 10 0e                      dup.x32 sp(14)
	<rotation+380 @05464c>  : 10 0d                      dup.x32 sp(13)
	<rotation+382 @05464e>  : 10 11                      dup.x32 sp(17)
	<rotation+384 @054650>  : 73                         mul.f32
	<rotation+385 @054651>  : 10 0c                      dup.x32 sp(12)
	<rotation+387 @054653>  : 10 10                      dup.x32 sp(16)
	<rotation+389 @054655>  : 73                         mul.f32
	<rotation+390 @054656>  : 71                         add.f32
	<rotation+391 @054657>  : 73                         mul.f32
	<rotation+392 @054658>  : 72                         sub.f32
	<rotation+393 @054659>  : 10 01                      dup.x32 sp(1)
	<rotation+395 @05465b>  : 73                         mul.f32
	<rotation+396 @05465c>  : 10 0a                      dup.x32 sp(10)
	<rotation+398 @05465e>  : 10 10                      dup.x32 sp(16)
	<rotation+400 @054660>  : 73                         mul.f32
	<rotation+401 @054661>  : 10 0d                      dup.x32 sp(13)
	<rotation+403 @054663>  : 10 0f                      dup.x32 sp(15)
	<rotation+405 @054665>  : 73                         mul.f32
	<rotation+406 @054666>  : 72                         sub.f32
	<rotation+407 @054667>  : 10 04                      dup.x32 sp(4)
	<rotation+409 @054669>  : 73                         mul.f32
	<rotation+410 @05466a>  : 71                         add.f32
	<rotation+411 @05466b>  : 13 1c                      set.x32 sp(28)
	lib/vec/mat4f.ci:147: (13 bytes: <@05466d> - <@05467a>): void(.result.zx := float32(float32(xz * k) - float32(y * s)));
	<rotation+413 @05466d>  : 10 06                      dup.x32 sp(6)
	<rotation+415 @05466f>  : 10 01                      dup.x32 sp(1)
	<rotation+417 @054671>  : 73                         mul.f32
	<rotation+418 @054672>  : 10 0e                      dup.x32 sp(14)
	<rotation+420 @054674>  : 10 04                      dup.x32 sp(4)
	<rotation+422 @054676>  : 73                         mul.f32
	<rotation+423 @054677>  : 72                         sub.f32
	<rotation+424 @054678>  : 13 1d                      set.x32 sp(29)
	lib/vec/mat4f.ci:148: (13 bytes: <@05467a> - <@054687>): void(.result.zy := float32(float32(yz * k) + float32(x * s)));
	<rotation+426 @05467a>  : 10 04                      dup.x32 sp(4)
	<rotation+428 @05467c>  : 10 01                      dup.x32 sp(1)
	<rotation+430 @05467e>  : 73                         mul.f32
	<rotation+431 @05467f>  : 10 0f                      dup.x32 sp(15)
	<rotation+433 @054681>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @054683>  : 73                         mul.f32
	<rotation+436 @054684>  : 71                         add.f32
	<rotation+437 @054685>  : 13 1e                      set.x32 sp(30)
	lib/vec/mat4f.ci:149: (13 bytes: <@054687> - <@054694>): void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
	<rotation+439 @054687>  : 10 03                      dup.x32 sp(3)
	<rotation+441 @054689>  : 10 09                      dup.x32 sp(9)
	<rotation+443 @05468b>  : 10 07                      dup.x32 sp(7)
	<rotation+445 @05468d>  : 71                         add.f32
	<rotation+446 @05468e>  : 10 03                      dup.x32 sp(3)
	<rotation+448 @054690>  : 73                         mul.f32
	<rotation+449 @054691>  : 71                         add.f32
	<rotation+450 @054692>  : 13 1f                      set.x32 sp(31)
	lib/vec/mat4f.ci:150: (43 bytes: <@054694> - <@0546bf>): void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
	<rotation+452 @054694>  : 10 09                      dup.x32 sp(9)
	<rotation+454 @054696>  : 10 09                      dup.x32 sp(9)
	<rotation+456 @054698>  : 10 07                      dup.x32 sp(7)
	<rotation+458 @05469a>  : 71                         add.f32
	<rotation+459 @05469b>  : 73                         mul.f32
	<rotation+460 @05469c>  : 10 0d                      dup.x32 sp(13)
	<rotation+462 @05469e>  : 10 0d                      dup.x32 sp(13)
	<rotation+464 @0546a0>  : 10 11                      dup.x32 sp(17)
	<rotation+466 @0546a2>  : 73                         mul.f32
	<rotation+467 @0546a3>  : 10 0d                      dup.x32 sp(13)
	<rotation+469 @0546a5>  : 10 11                      dup.x32 sp(17)
	<rotation+471 @0546a7>  : 73                         mul.f32
	<rotation+472 @0546a8>  : 71                         add.f32
	<rotation+473 @0546a9>  : 73                         mul.f32
	<rotation+474 @0546aa>  : 72                         sub.f32
	<rotation+475 @0546ab>  : 10 01                      dup.x32 sp(1)
	<rotation+477 @0546ad>  : 73                         mul.f32
	<rotation+478 @0546ae>  : 10 0c                      dup.x32 sp(12)
	<rotation+480 @0546b0>  : 10 0f                      dup.x32 sp(15)
	<rotation+482 @0546b2>  : 73                         mul.f32
	<rotation+483 @0546b3>  : 10 0c                      dup.x32 sp(12)
	<rotation+485 @0546b5>  : 10 11                      dup.x32 sp(17)
	<rotation+487 @0546b7>  : 73                         mul.f32
	<rotation+488 @0546b8>  : 72                         sub.f32
	<rotation+489 @0546b9>  : 10 04                      dup.x32 sp(4)
	<rotation+491 @0546bb>  : 73                         mul.f32
	<rotation+492 @0546bc>  : 71                         add.f32
	<rotation+493 @0546bd>  : 13 20                      set.x32 sp(32)
	lib/vec/mat4f.ci:152: (24 bytes: <@0546bf> - <@0546d7>): void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
	<rotation+495 @0546bf>  : 09 10 00 00                inc.sp(+16)
	<rotation+499 @0546c3>  : 19                         load.z32
	<rotation+500 @0546c4>  : 19                         load.z32
	<rotation+501 @0546c5>  : 19                         load.z32
	<rotation+502 @0546c6>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+507 @0546cb>  : 1f c8 42 05 00             load.ref <@0542c8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+512 @0546d0>  : 02                         call
	<rotation+513 @0546d1>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+517 @0546d5>  : 15 24                      set.x128 sp(36)
	<rotation+519 @0546d7>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+523 @0546db>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:157: referenced as `rotation`
	lib/vec/mat4f.ci:108: defined as `rotation(center: vec4f, direction: vec4f, angle: float32): mat4f`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'lib/vec/mat4f.ci:157'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
	lib/vec/mat4f.ci:157: defined as `rotation(direction: vec4f, angle: float32): mat4f`
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 88
.offset: <@0546e0>
.name: 'translation'
.file: 'lib/vec/mat4f.ci:160'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (88 bytes: <@0546e0> - <@054738>)
	lib/vec/mat4f.ci:161: (88 bytes: <@0546e0> - <@054738>): return void(.result := {...});
	<translation @0546e0>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @0546e5>    : 13 04                      set.x32 sp(4)
	lib/vec/mat4f.ci:162: (3 bytes: <@0546e7> - <@0546ea>): void(.result.x.y := (0));
	<translation+7 @0546e7>    : 19                         load.z32
	<translation+8 @0546e8>    : 13 05                      set.x32 sp(5)
	lib/vec/mat4f.ci:162: (3 bytes: <@0546ea> - <@0546ed>): void(.result.x.z := (0));
	<translation+10 @0546ea>   : 19                         load.z32
	<translation+11 @0546eb>   : 13 06                      set.x32 sp(6)
	lib/vec/mat4f.ci:162: (8 bytes: <@0546ed> - <@0546f5>): void(.result.x.w := float32(direction.x * amount));
	<translation+13 @0546ed>   : 10 02                      dup.x32 sp(2)
	<translation+15 @0546ef>   : 22                         load.i32
	<translation+16 @0546f0>   : 10 02                      dup.x32 sp(2)
	<translation+18 @0546f2>   : 73                         mul.f32
	<translation+19 @0546f3>   : 13 07                      set.x32 sp(7)
	lib/vec/mat4f.ci:163: (3 bytes: <@0546f5> - <@0546f8>): void(.result.y.x := (0));
	<translation+21 @0546f5>   : 19                         load.z32
	<translation+22 @0546f6>   : 13 08                      set.x32 sp(8)
	lib/vec/mat4f.ci:163: (7 bytes: <@0546f8> - <@0546ff>): void(.result.y.y := (1));
	<translation+24 @0546f8>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @0546fd>   : 13 09                      set.x32 sp(9)
	lib/vec/mat4f.ci:163: (3 bytes: <@0546ff> - <@054702>): void(.result.y.z := (0));
	<translation+31 @0546ff>   : 19                         load.z32
	<translation+32 @054700>   : 13 0a                      set.x32 sp(10)
	lib/vec/mat4f.ci:163: (12 bytes: <@054702> - <@05470e>): void(.result.y.w := float32(direction.y * amount));
	<translation+34 @054702>   : 10 02                      dup.x32 sp(2)
	<translation+36 @054704>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @054708>   : 22                         load.i32
	<translation+41 @054709>   : 10 02                      dup.x32 sp(2)
	<translation+43 @05470b>   : 73                         mul.f32
	<translation+44 @05470c>   : 13 0b                      set.x32 sp(11)
	lib/vec/mat4f.ci:164: (3 bytes: <@05470e> - <@054711>): void(.result.z.x := (0));
	<translation+46 @05470e>   : 19                         load.z32
	<translation+47 @05470f>   : 13 0c                      set.x32 sp(12)
	lib/vec/mat4f.ci:164: (3 bytes: <@054711> - <@054714>): void(.result.z.y := (0));
	<translation+49 @054711>   : 19                         load.z32
	<translation+50 @054712>   : 13 0d                      set.x32 sp(13)
	lib/vec/mat4f.ci:164: (7 bytes: <@054714> - <@05471b>): void(.result.z.z := (1));
	<translation+52 @054714>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @054719>   : 13 0e                      set.x32 sp(14)
	lib/vec/mat4f.ci:164: (12 bytes: <@05471b> - <@054727>): void(.result.z.w := float32(direction.z * amount));
	<translation+59 @05471b>   : 10 02                      dup.x32 sp(2)
	<translation+61 @05471d>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @054721>   : 22                         load.i32
	<translation+66 @054722>   : 10 02                      dup.x32 sp(2)
	<translation+68 @054724>   : 73                         mul.f32
	<translation+69 @054725>   : 13 0f                      set.x32 sp(15)
	lib/vec/mat4f.ci:165: (3 bytes: <@054727> - <@05472a>): void(.result.w.x := (0));
	<translation+71 @054727>   : 19                         load.z32
	<translation+72 @054728>   : 13 10                      set.x32 sp(16)
	lib/vec/mat4f.ci:165: (3 bytes: <@05472a> - <@05472d>): void(.result.w.y := (0));
	<translation+74 @05472a>   : 19                         load.z32
	<translation+75 @05472b>   : 13 11                      set.x32 sp(17)
	lib/vec/mat4f.ci:165: (3 bytes: <@05472d> - <@054730>): void(.result.w.z := (0));
	<translation+77 @05472d>   : 19                         load.z32
	<translation+78 @05472e>   : 13 12                      set.x32 sp(18)
	lib/vec/mat4f.ci:165: (7 bytes: <@054730> - <@054737>): void(.result.w.w := (1));
	<translation+80 @054730>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @054735>   : 13 13                      set.x32 sp(19)
	<translation+87 @054737>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:160: defined as `translation(direction: vec4f, amount: float32): mat4f`
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 217
.offset: <@054738>
.name: 'scale'
.file: 'lib/vec/mat4f.ci:170'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (217 bytes: <@054738> - <@054811>)
	lib/vec/mat4f.ci:172: (217 bytes: <@054738> - <@054811>): return void(.result := {...});
	<scale @054738>      : 10 02                      dup.x32 sp(2)
	<scale+2 @05473a>    : 22                         load.i32
	<scale+3 @05473b>    : 10 02                      dup.x32 sp(2)
	<scale+5 @05473d>    : 73                         mul.f32
	<scale+6 @05473e>    : 10 00                      dup.x32 sp(0)
	<scale+8 @054740>    : 19                         load.z32
	<scale+9 @054741>    : 78                         clt.f32
	<scale+10 @054742>   : 06 0b 00 00                jz <scale+21 @05474d>
	<scale+14 @054746>   : 10 00                      dup.x32 sp(0)
	<scale+16 @054748>   : 70                         neg.f32
	<scale+17 @054749>   : 04 06 00 00                jmp <scale+23 @05474f>
	<scale+21 @05474d>   : 10 00                      dup.x32 sp(0)
	<scale+23 @05474f>   : 7d                         f32.2f64
	<scale+24 @054750>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @054759>   : 88                         clt.f64
	<scale+34 @05475a>   : 06 09 00 00                jz <scale+43 @054763>
	<scale+38 @05475e>   : 19                         load.z32
	<scale+39 @05475f>   : 04 0c 00 00                jmp <scale+51 @05476b>
	<scale+43 @054763>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @054768>   : 10 01                      dup.x32 sp(1)
	<scale+50 @05476a>   : 74                         div.f32
	<scale+51 @05476b>   : 13 01                      set.x32 sp(1)
	<scale+53 @05476d>   : 13 04                      set.x32 sp(4)
	lib/vec/mat4f.ci:173: (3 bytes: <@05476f> - <@054772>): void(.result.x.y := (0));
	<scale+55 @05476f>   : 19                         load.z32
	<scale+56 @054770>   : 13 05                      set.x32 sp(5)
	lib/vec/mat4f.ci:173: (3 bytes: <@054772> - <@054775>): void(.result.x.z := (0));
	<scale+58 @054772>   : 19                         load.z32
	<scale+59 @054773>   : 13 06                      set.x32 sp(6)
	lib/vec/mat4f.ci:173: (3 bytes: <@054775> - <@054778>): void(.result.x.w := (0));
	<scale+61 @054775>   : 19                         load.z32
	<scale+62 @054776>   : 13 07                      set.x32 sp(7)
	lib/vec/mat4f.ci:174: (3 bytes: <@054778> - <@05477b>): void(.result.y.x := (0));
	<scale+64 @054778>   : 19                         load.z32
	<scale+65 @054779>   : 13 08                      set.x32 sp(8)
	lib/vec/mat4f.ci:174: (59 bytes: <@05477b> - <@0547b6>): void(.result.y.y := rcp(float32(direction.y * amount)));
	<scale+67 @05477b>   : 10 02                      dup.x32 sp(2)
	<scale+69 @05477d>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @054781>   : 22                         load.i32
	<scale+74 @054782>   : 10 02                      dup.x32 sp(2)
	<scale+76 @054784>   : 73                         mul.f32
	<scale+77 @054785>   : 10 00                      dup.x32 sp(0)
	<scale+79 @054787>   : 19                         load.z32
	<scale+80 @054788>   : 78                         clt.f32
	<scale+81 @054789>   : 06 0b 00 00                jz <scale+92 @054794>
	<scale+85 @05478d>   : 10 00                      dup.x32 sp(0)
	<scale+87 @05478f>   : 70                         neg.f32
	<scale+88 @054790>   : 04 06 00 00                jmp <scale+94 @054796>
	<scale+92 @054794>   : 10 00                      dup.x32 sp(0)
	<scale+94 @054796>   : 7d                         f32.2f64
	<scale+95 @054797>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @0547a0>  : 88                         clt.f64
	<scale+105 @0547a1>  : 06 09 00 00                jz <scale+114 @0547aa>
	<scale+109 @0547a5>  : 19                         load.z32
	<scale+110 @0547a6>  : 04 0c 00 00                jmp <scale+122 @0547b2>
	<scale+114 @0547aa>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @0547af>  : 10 01                      dup.x32 sp(1)
	<scale+121 @0547b1>  : 74                         div.f32
	<scale+122 @0547b2>  : 13 01                      set.x32 sp(1)
	<scale+124 @0547b4>  : 13 09                      set.x32 sp(9)
	lib/vec/mat4f.ci:174: (3 bytes: <@0547b6> - <@0547b9>): void(.result.y.z := (0));
	<scale+126 @0547b6>  : 19                         load.z32
	<scale+127 @0547b7>  : 13 0a                      set.x32 sp(10)
	lib/vec/mat4f.ci:174: (3 bytes: <@0547b9> - <@0547bc>): void(.result.y.w := (0));
	<scale+129 @0547b9>  : 19                         load.z32
	<scale+130 @0547ba>  : 13 0b                      set.x32 sp(11)
	lib/vec/mat4f.ci:175: (3 bytes: <@0547bc> - <@0547bf>): void(.result.z.x := (0));
	<scale+132 @0547bc>  : 19                         load.z32
	<scale+133 @0547bd>  : 13 0c                      set.x32 sp(12)
	lib/vec/mat4f.ci:175: (3 bytes: <@0547bf> - <@0547c2>): void(.result.z.y := (0));
	<scale+135 @0547bf>  : 19                         load.z32
	<scale+136 @0547c0>  : 13 0d                      set.x32 sp(13)
	lib/vec/mat4f.ci:175: (59 bytes: <@0547c2> - <@0547fd>): void(.result.z.z := rcp(float32(direction.z * amount)));
	<scale+138 @0547c2>  : 10 02                      dup.x32 sp(2)
	<scale+140 @0547c4>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @0547c8>  : 22                         load.i32
	<scale+145 @0547c9>  : 10 02                      dup.x32 sp(2)
	<scale+147 @0547cb>  : 73                         mul.f32
	<scale+148 @0547cc>  : 10 00                      dup.x32 sp(0)
	<scale+150 @0547ce>  : 19                         load.z32
	<scale+151 @0547cf>  : 78                         clt.f32
	<scale+152 @0547d0>  : 06 0b 00 00                jz <scale+163 @0547db>
	<scale+156 @0547d4>  : 10 00                      dup.x32 sp(0)
	<scale+158 @0547d6>  : 70                         neg.f32
	<scale+159 @0547d7>  : 04 06 00 00                jmp <scale+165 @0547dd>
	<scale+163 @0547db>  : 10 00                      dup.x32 sp(0)
	<scale+165 @0547dd>  : 7d                         f32.2f64
	<scale+166 @0547de>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @0547e7>  : 88                         clt.f64
	<scale+176 @0547e8>  : 06 09 00 00                jz <scale+185 @0547f1>
	<scale+180 @0547ec>  : 19                         load.z32
	<scale+181 @0547ed>  : 04 0c 00 00                jmp <scale+193 @0547f9>
	<scale+185 @0547f1>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @0547f6>  : 10 01                      dup.x32 sp(1)
	<scale+192 @0547f8>  : 74                         div.f32
	<scale+193 @0547f9>  : 13 01                      set.x32 sp(1)
	<scale+195 @0547fb>  : 13 0e                      set.x32 sp(14)
	lib/vec/mat4f.ci:175: (3 bytes: <@0547fd> - <@054800>): void(.result.z.w := (0));
	<scale+197 @0547fd>  : 19                         load.z32
	<scale+198 @0547fe>  : 13 0f                      set.x32 sp(15)
	lib/vec/mat4f.ci:176: (3 bytes: <@054800> - <@054803>): void(.result.w.x := (0));
	<scale+200 @054800>  : 19                         load.z32
	<scale+201 @054801>  : 13 10                      set.x32 sp(16)
	lib/vec/mat4f.ci:176: (3 bytes: <@054803> - <@054806>): void(.result.w.y := (0));
	<scale+203 @054803>  : 19                         load.z32
	<scale+204 @054804>  : 13 11                      set.x32 sp(17)
	lib/vec/mat4f.ci:176: (3 bytes: <@054806> - <@054809>): void(.result.w.z := (0));
	<scale+206 @054806>  : 19                         load.z32
	<scale+207 @054807>  : 13 12                      set.x32 sp(18)
	lib/vec/mat4f.ci:176: (7 bytes: <@054809> - <@054810>): void(.result.w.w := (1));
	<scale+209 @054809>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @05480e>  : 13 13                      set.x32 sp(19)
	<scale+216 @054810>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:170: defined as `scale(direction: vec4f, amount: float32): mat4f`
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054818>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054820>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054828>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054830>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054838>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054840>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054848>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054850>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054858>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054860>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@054868>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054870>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054878>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054880>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054888>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054890>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054898>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548a0>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548a8>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548b0>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548b8>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548c0>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548c8>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548d0>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548d8>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548e0>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548e8>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548f0>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0548f8>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054900>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054908>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054910>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054918>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054920>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054928>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054930>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054938>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054940>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054948>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054950>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054958>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054960>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054968>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054970>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054978>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054980>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054988>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054990>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054998>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549a0>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549a8>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549b0>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549b8>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549c0>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549c8>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549d0>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0549d8>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0549e0>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0549e8>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0549f0>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0549f8>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054a00>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0341b0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0342e0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@054a08>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@054a10>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054a18>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@054a20>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054a28>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054a30>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054a38>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@054a40>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@054a48>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@054a50>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054a58>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054a60>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054a68>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@054a70>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@054a78>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054a80>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054a88>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054a90>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054a98>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054aa0>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@054aa8>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ab0>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054ab8>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054ac0>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ac8>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ad0>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ad8>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ae0>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ae8>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054af0>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054af8>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b00>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b08>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b10>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b18>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b20>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b28>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b30>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b38>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b40>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b48>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054b50>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b58>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b60>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b68>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b70>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b78>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b80>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b88>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b90>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054b98>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054ba0>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054ba8>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bb0>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bb8>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bc0>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bc8>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bd0>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054bd8>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054be0>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054be8>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054bf0>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054bf8>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c00>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c08>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c10>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c18>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c20>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c28>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c30>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c38>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c40>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c48>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c50>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c58>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c60>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c68>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c70>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054c78>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054c80>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c88>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054c90>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@054c98>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054ca0>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@054ca8>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@054ca8> - <@054ca9>)
	<empty @054ca8>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@054cb0>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@054cb0> - <@054cb8>)
	test/lang/function.ci:8: (8 bytes: <@054cb0> - <@054cb8>): return int32(.result := int32(x + y));
	<funAdd @054cb0>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @054cb2>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @054cb4>    : 51                         add.i32
	<funAdd+5 @054cb5>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @054cb7>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054cb8>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@054cc0>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054cc8>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@054cd0>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054cd8>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@054ce0>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ce8>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@054cf0>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@054cf0> - <@054cf8>)
	test/lang/function.ci:34: (8 bytes: <@054cf0> - <@054cf8>): return int32(.result := int32(x * y));
	<funMul @054cf0>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @054cf2>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @054cf4>    : 53                         mul.i32
	<funMul+5 @054cf5>    : 13 04                      set.x32 sp(4)
	<funMul+7 @054cf7>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@054cf8>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@054cf8> - <@054d2e>)
	test/lang/function.ci:39: (16 bytes: <@054cf8> - <@054d08>): if (bool(n <= (1)))
	<fib @054cf8>      : 10 01                      dup.x32 sp(1)
	<fib+2 @054cfa>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @054cff>    : 39                         cgt.u32
	<fib+8 @054d00>    : 05 08 00 00                jnz <fib+16 @054d08>
	test/lang/function.ci:40: (4 bytes: <@054d04> - <@054d08>): return uint32(.result := n);
	<fib+12 @054d04>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @054d07>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@054d08> - <@054d2e>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @054d08>   : 19                         load.z32
	<fib+17 @054d09>   : 10 02                      dup.x32 sp(2)
	<fib+19 @054d0b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @054d0f>   : 1f f8 4c 05 00             load.ref <@054cf8> ;fib(n: uint32): uint32
	<fib+28 @054d14>   : 02                         call
	<fib+29 @054d15>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @054d19>   : 19                         load.z32
	<fib+34 @054d1a>   : 10 03                      dup.x32 sp(3)
	<fib+36 @054d1c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @054d20>   : 1f f8 4c 05 00             load.ref <@054cf8> ;fib(n: uint32): uint32
	<fib+45 @054d25>   : 02                         call
	<fib+46 @054d26>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @054d2a>   : 51                         add.i32
	<fib+51 @054d2b>   : 13 03                      set.x32 sp(3)
	<fib+53 @054d2d>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@054d30>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d38>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d40>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d48>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d50>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d58>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d60>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d68>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d70>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d78>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d80>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d88>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d90>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054d98>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054da0>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054da8>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054db0>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054db8>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054dc0>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@03a148>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@03a278>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054dc8>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@054dd0>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054dd8>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054de0>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@054de8>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054df0>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054df8>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@054e00>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e08>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e10>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@054e18>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e20>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054e28>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e30>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e38>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@054e40>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e48>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e50>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054e58>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054e60>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054e68>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054e70>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e78>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e80>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e88>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e90>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054e98>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ea0>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ea8>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054eb0>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054eb8>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ec0>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ec8>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ed0>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ed8>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ee0>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ee8>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ef0>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054ef8>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f00>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f08>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f10>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f18>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f20>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f28>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f30>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@054f38>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f40>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f48>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f50>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f58>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f60>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f68>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f70>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@054f78>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054f80>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@054f88>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054f90>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054f98>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fa0>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fa8>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fb0>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fb8>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fc0>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@054fc8>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054fd0>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054fd8>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054fe0>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@054fe8>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054ff0>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@054ff8>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@055000>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@055000> - <@055001>)
	<noError @055000>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@055008>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@055008> - <@055020>)
	test/stdc/tryExec.ci:15: (4 bytes: <@055008> - <@05500c>): data: uint8[8192]
	<stackOverflow @055008>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@05500c> - <@05501b>): stackOverflow(ptr);
	<stackOverflow+4 @05500c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @055010>    : 22                         load.i32
	<stackOverflow+9 @055011>    : 1f 08 50 05 00             load.ref <@055008> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @055016>   : 02                         call
	<stackOverflow+15 @055017>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @05501b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @05501f>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@055020>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@055020> - <@05502c>)
	test/stdc/tryExec.ci:20: (7 bytes: <@055020> - <@055027>): value: int32 := int32(3 / 0)
	<divisionByZero @055020>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @055025>    : 19                         load.z32
	<divisionByZero+6 @055026>    : 54                         div.i32
	<divisionByZero+7 @055027>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @05502b>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@055030>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@055030> - <@055074>)
	test/stdc/tryExec.ci:29: (25 bytes: <@055030> - <@055049>): details: NotEquals := {...}
	<abortExecution @055030>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@055034> - <@05503b>): void(details.message := ("assertion failed"));
	<abortExecution+4 @055034>    : 1f a8 ce 00 00             load.ref <@00cea8> ;"assertion failed"
	<abortExecution+9 @055039>    : 13 01                      set.x32 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@05503b> - <@055042>): void(details.expected := 97);
	<abortExecution+11 @05503b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @055040>   : 13 02                      set.x32 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@055042> - <@055049>): void(details.returned := 77);
	<abortExecution+18 @055042>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @055047>   : 13 03                      set.x32 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@055049> - <@05506f>): abort(void("fatal error", details));
	<abortExecution+25 @055049>   : 1f e8 de 03 00             load.ref <@03dee8> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @05504e>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @055053>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @055058>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @05505d>   : 1f 31 df 03 00             load.ref <@03df31> ;"fatal error"
	<abortExecution+50 @055062>   : 1f 48 e9 03 00             load.ref <@03e948> ;abortExecution.NotEquals
	<abortExecution+55 @055067>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @05506b>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @05506f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @055073>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@055078>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@055078> - <@055085>)
	test/stdc/tryExec.ci:38: (5 bytes: <@055078> - <@05507d>): i32Ref: int32 := null
	<invalidMemoryAccess @055078>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@05507d> - <@055080>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @05507d>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @05507f>    : 22                         load.i32
	<invalidMemoryAccess+8 @055080>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @055084>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@055088>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@055088> - <@05508a>)
	test/stdc/tryExec.ci:43: (2 bytes: <@055088> - <@05508a>): emit(void(load.z32, ret));
	<invalidInstruction @055088>      : 19                         load.z32
	<invalidInstruction+1 @055089>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055090>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055098>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0550a0>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0550a8>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0550b0>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0550b8>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0550c0>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@0550c8>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@055100>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@055108>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@055110>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@055118>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@055120>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@055128>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@055130>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@055138>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@055140>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@055148>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@055150>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@055158>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@055160>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@055160> - <@055164>)
	test/lang/array.ci:103: (4 bytes: <@055160> - <@055164>): return uint32(.result := values.length);
	<lenSlice @055160>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @055163>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@055168>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@055168> - <@055174>)
	test/lang/array.ci:104: (12 bytes: <@055168> - <@055174>): return int64(.result := values[idx]);
	<nthFixed @055168>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @05516a>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @05516c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @055170>    : 23                         load.i64
	<nthFixed+9 @055171>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @055173>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@055178>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@055178> - <@055184>)
	test/lang/array.ci:105: (12 bytes: <@055178> - <@055184>): return int64(.result := values[idx]);
	<nthArray @055178>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @05517a>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @05517c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @055180>    : 23                         load.i64
	<nthArray+9 @055181>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @055183>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@055188>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@055188> - <@055194>)
	test/lang/array.ci:106: (12 bytes: <@055188> - <@055194>): return int64(.result := values[idx]);
	<nthSlice @055188>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @05518a>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @05518c>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @055190>    : 23                         load.i64
	<nthSlice+9 @055191>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @055193>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@041690>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@041728>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@055198>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@0551a0>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@0551a8>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@0551b0>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@0551b8>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@0551c0>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@041728>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055198>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0551a0>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@0551a8>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0551b0>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0551b8>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0551c0>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@0551c8>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@042568>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@0551e8>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@055210>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@055218>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@055240>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@0551e8>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@0551e8> - <@05520f>)
	test/lang/method.ci:11: (38 bytes: <@0551e8> - <@05520e>): trace(void("staticMethod", x));
	<staticMethod @0551e8>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<staticMethod+5 @0551ed>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @0551f2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0551f7>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @0551fc>   : 1f 45 21 04 00             load.ref <@042145> ;"staticMethod"
	<staticMethod+25 @055201>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @055206>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @05520a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @05520e>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@055210>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@055218>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@055218> - <@05523f>)
	test/lang/method.ci:41: (38 bytes: <@055218> - <@05523e>): trace(void("virtualMethod", x));
	<virtualMethod @055218>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<virtualMethod+5 @05521d>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @055222>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @055227>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @05522c>   : 1f 36 24 04 00             load.ref <@042436> ;"virtualMethod"
	<virtualMethod+25 @055231>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @055236>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @05523a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @05523e>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@055240>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@055240> - <@055267>)
	test/lang/method.ci:48: (38 bytes: <@055240> - <@055266>): trace(void("forwardMethod", x));
	<forwardMethod @055240>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<forwardMethod+5 @055245>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @05524a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @05524f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @055254>   : 1f bd 21 04 00             load.ref <@0421bd> ;"forwardMethod"
	<forwardMethod+25 @055259>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @05525e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @055262>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @055266>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@055268>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@055268> - <@05528f>)
	test/lang/method.ci:58: (38 bytes: <@055268> - <@05528e>): trace(void("globalFunction", x));
	<globalFunction @055268>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<globalFunction+5 @05526d>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @055272>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @055277>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @05527c>   : 1f 69 24 04 00             load.ref <@042469> ;"globalFunction"
	<globalFunction+25 @055281>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @055286>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @05528a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @05528e>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@055290>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@0552a0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@0552a0> - <@0552e2>)
	test/lang/method.ci:85: (35 bytes: <@0552a0> - <@0552c3>): debug("extension.staticMethod");
	<staticMethod @0552a0>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<staticMethod+5 @0552a5>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @0552aa>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0552af>   : 19                         load.z32
	<staticMethod+16 @0552b0>   : 1f 37 25 04 00             load.ref <@042537> ;"extension.staticMethod"
	<staticMethod+21 @0552b5>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @0552ba>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @0552bf>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@0552c3> - <@0552e1>): if (bool((this) != null))
	<staticMethod+35 @0552c3>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @0552c7>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @0552cc>   : 57                         ceq.i32
	<staticMethod+45 @0552cd>   : 05 14 00 00                jnz <staticMethod+65 @0552e1>
	test/lang/method.ci:87: (16 bytes: <@0552d1> - <@0552e1>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @0552d1>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @0552d3>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @0552d5>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @0552d7>   : 1f e8 51 05 00             load.ref <@0551e8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @0552dc>   : 02                         call
	<staticMethod+61 @0552dd>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @0552e1>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@0552e8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@0552e8> - <@055327>)
	test/lang/method.ci:91: (35 bytes: <@0552e8> - <@05530b>): debug("extension.virtualMethod");
	<virtualMethod @0552e8>      : 1f a8 20 04 00             load.ref <@0420a8> ;"test/lang/method.ci"
	<virtualMethod+5 @0552ed>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @0552f2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @0552f7>   : 19                         load.z32
	<virtualMethod+16 @0552f8>   : 1f 4e 25 04 00             load.ref <@04254e> ;"extension.virtualMethod"
	<virtualMethod+21 @0552fd>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @055302>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @055307>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@05530b> - <@055326>): if (bool((this) != null))
	<virtualMethod+35 @05530b>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @05530f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @055314>   : 57                         ceq.i32
	<virtualMethod+45 @055315>   : 05 11 00 00                jnz <virtualMethod+62 @055326>
	test/lang/method.ci:93: (13 bytes: <@055319> - <@055326>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @055319>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @05531b>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @05531d>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @05531f>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @055321>   : 02                         call
	<virtualMethod+58 @055322>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @055326>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@043ce8>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@043f48>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@0441a8>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@044370>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@055328>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@055330>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@055338>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@055340>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@055348>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@044810>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@044c38>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@045060>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@045488>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0458b0>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@045cd8>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055350>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055358>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055360>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055368>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055370>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055378>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055380>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055388>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055390>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055398>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0553a0>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0553a8>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0553b0>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553b8>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553c0>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553c8>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553d0>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553d8>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553e0>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553e8>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553f0>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0553f8>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055400>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055408>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055410>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055418>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055420>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@055428>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055430>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055438>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055440>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055448>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055450>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055458>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055460>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055468>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055470>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055478>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055480>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055488>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055490>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@055498>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554a0>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554a8>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554b0>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554b8>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554c0>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554c8>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554d0>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0554d8>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0554e0>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0554e8>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0554f0>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0554f8>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055500>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055508>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055510>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055518>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055520>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055528>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055530>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055538>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055540>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055548>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055550>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055558>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055560>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055568>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055570>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055578>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055580>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@055588>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055590>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055598>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0555a0>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0555a8>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0555b0>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0555b8>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0555c0>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555c8>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555d0>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555d8>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555e0>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555e8>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555f0>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0555f8>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055600>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055608>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055610>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055618>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055620>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055628>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055630>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@055638>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055640>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055648>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055650>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055658>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055660>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055668>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055670>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@055678>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@055680>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@055688>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@055690>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@055698>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556a0>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556a8>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556b0>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556b8>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556c0>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556c8>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556d0>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556d8>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556e0>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0556e8>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0556f0>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0556f8>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055700>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055708>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055710>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055718>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055720>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055728>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055730>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055738>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055740>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055748>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055750>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055758>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055760>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055768>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055770>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055778>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055780>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055788>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055790>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055798>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557a0>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557a8>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557b0>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557b8>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557c0>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557c8>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0557d0>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0557d8>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0557e0>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0557e8>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0557f0>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0557f8>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055800>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055808>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055810>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055818>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055820>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055828>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055830>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055838>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055840>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@055848>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055850>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055858>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055860>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055868>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055870>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055878>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055880>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@055888>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@055890>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@055898>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558a0>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558a8>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558b0>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558b8>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558c0>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558c8>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558d0>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558d8>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558e0>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558e8>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558f0>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0558f8>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055900>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055908>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055910>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055918>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055920>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055928>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055930>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055938>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055940>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055948>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055950>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055958>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055960>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055968>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055970>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055978>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055980>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055988>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055990>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@055998>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0559a0>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0559a8>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559b0>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559b8>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559c0>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559c8>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559d0>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559d8>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0559e0>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0559e8>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0559f0>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0559f8>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a00>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a08>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a10>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a18>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a20>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055a28>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a30>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a38>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a40>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a48>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a50>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a58>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055a60>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a68>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a70>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a78>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a80>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a88>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a90>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055a98>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055aa0>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055aa8>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ab0>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ab8>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ac0>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ac8>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ad0>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ad8>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055ae0>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@055ae8>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@055af0>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055af8>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055b00>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055b08>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@055b10>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b18>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b20>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b28>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b30>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b38>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b40>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b48>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b50>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b58>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b60>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b68>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b70>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b78>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b80>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b88>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b90>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055b98>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ba0>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ba8>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bb0>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bb8>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bc0>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bc8>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bd0>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bd8>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055be0>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055be8>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bf0>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055bf8>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c00>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c08>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c10>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c18>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c20>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c28>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c30>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c38>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c40>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c48>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c50>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c58>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c60>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c68>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c70>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c78>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c80>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c88>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c90>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055c98>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ca0>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ca8>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055cb0>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@055cb8>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cc0>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cc8>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cd0>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cd8>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ce0>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055ce8>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cf0>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055cf8>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055d00>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055d08>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@055d10>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d18>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d20>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d28>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d30>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d38>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d40>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d48>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d50>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d58>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d60>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@055d68>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 14636
.offset: <@055d6c>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000d38>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000dd8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005900>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006f10>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0077f0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008460>, cast: static const typename(void))
.field true: bool (size: 1, offs: <@000000>, cast: static const val)
.field false: bool (size: 1, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 32, offs: <@010108>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@0533e0>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@011380>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01a0a0>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@053c00>, cast: static const function)
.field Complex: function (size: 7, offs: <@053c08>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@053c10>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@053c90>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@053cb0>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@053d18>, cast: static const function)
.field indexOf: function (size: 50, offs: <@053d40>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@053d78>, cast: static const function)
.field startsWith: function (size: 73, offs: <@053db0>, cast: static const function)
.field endsWith: function (size: 126, offs: <@053e00>, cast: static const function)
.field compare: function (size: 63, offs: <@053e80>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@053f08>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@053f30>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@022ac8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@053f40>, cast: static const function)
.field append: function (size: 657, offs: <@053fa8>, cast: static const function)
.field append: function (size: 23, offs: <@054240>, cast: static const function)
.field append: function (size: 49, offs: <@054258>, cast: static const function)
.field append: function (size: 25, offs: <@0542a0>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024c58>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@0542c0>, cast: static const function)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@025c28>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@0542c8>, cast: static const function)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@029390>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@0542d8>, cast: static const function)
.field mat4f: function (size: 21, offs: <@054310>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 417, offs: <@054328>, cast: static const function)
.field rotation: function (size: 524, offs: <@0544d0>, cast: static const function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@0546e0>, cast: static const function)
.field scale: function (size: 217, offs: <@054738>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@054818>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@054820>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@054828>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@054830>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@054838>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@054840>, cast: static variable(i32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@054848>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@054850>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@054858>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@054860>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@054868>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@054870>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@054878>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@054880>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@054888>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@054890>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@054898>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@0548a0>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@0548a8>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@0548b0>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@0548b8>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@0548c0>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@0548c8>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@0548d0>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@0548d8>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@0548e0>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@0548e8>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@0548f0>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@0548f8>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@054900>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@054908>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@054910>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@054918>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@054920>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@054928>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@054930>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@054938>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@054940>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@054948>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@054950>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@054958>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@054960>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@054968>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@054970>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@054978>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@054980>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@054988>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@054990>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@054998>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@0549a0>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@0549a8>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@0549b0>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@0549b8>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@0549c0>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@0549c8>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@0549d0>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@0549d8>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@0549e0>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@0549e8>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@0549f0>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@0549f8>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@054a00>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@0341b0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@0342e0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@054a08>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@054a10>, cast: static variable(val))
.field value: int64 (size: 8, offs: <@054a18>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@054a20>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@054a28>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@054a30>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@054a38>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@054a40>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@054a48>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@054a50>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@054a58>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@054a60>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@054a68>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@054a70>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@054a78>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@054a80>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@054a88>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@054a90>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@054a98>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@054aa0>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@054aa8>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@054ab0>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@054ab8>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@054ac0>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@054ac8>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@054ad0>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@054ad8>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@054ae0>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@054ae8>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@054af0>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@054af8>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@054b00>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@054b08>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@054b10>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@054b18>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@054b20>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@054b28>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@054b30>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@054b38>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@054b40>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@054b48>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@054b50>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@054b58>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@054b60>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@054b68>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@054b70>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@054b78>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@054b80>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@054b88>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@054b90>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@054b98>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@054ba0>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@054ba8>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@054bb0>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@054bb8>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@054bc0>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@054bc8>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@054bd0>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@054bd8>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@054be0>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@054be8>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@054bf0>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@054bf8>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@054c00>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@054c08>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@054c10>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@054c18>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@054c20>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@054c28>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@054c30>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@054c38>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@054c40>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@054c48>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@054c50>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@054c58>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@054c60>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@054c68>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@054c70>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@054c78>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@054c80>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@054c88>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@054c90>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@054c98>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@054ca0>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@054ca8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@054cb0>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@054cb8>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@054cc0>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@054cc8>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@054cd0>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@054cd8>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@054ce0>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@054ce8>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@054cf0>, cast: static const function)
.field fib: function (size: 54, offs: <@054cf8>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@054d30>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@054d38>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@054d40>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@054d48>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@054d50>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@054d58>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@054d60>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@054d68>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@054d70>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@054d78>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@054d80>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@054d88>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@054d90>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@054d98>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@054da0>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@054da8>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@054db0>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@054db8>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@054dc0>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@03a148>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@03a278>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@054dc8>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@054dd0>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@054dd8>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@054de0>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@054de8>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@054df0>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@054df8>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@054e00>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@054e08>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@054e10>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@054e18>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@054e20>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@054e28>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@054e30>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@054e38>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@054e40>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@054e48>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@054e50>, cast: static variable(i32))
.field pi64: float64 (size: 8, offs: <@054e58>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@054e60>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@054e68>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@054e70>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@054e78>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@054e80>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@054e88>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@054e90>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@054e98>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@054ea0>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@054ea8>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@054eb0>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@054eb8>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@054ec0>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@054ec8>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@054ed0>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@054ed8>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@054ee0>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@054ee8>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@054ef0>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@054ef8>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@054f00>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@054f08>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@054f10>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@054f18>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@054f20>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@054f28>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@054f30>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@054f38>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@054f40>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@054f48>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@054f50>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@054f58>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@054f60>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@054f68>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@054f70>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@054f78>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@054f80>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@054f88>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@054f90>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@054f98>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@054fa0>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@054fa8>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@054fb0>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@054fb8>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@054fc0>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@054fc8>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@054fd0>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@054fd8>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@054fe0>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@054fe8>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@054ff0>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@054ff8>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@055000>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@055008>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@055020>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@055030>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@055078>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@055088>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@055090>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@055098>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@0550a0>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@0550a8>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@0550b0>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@0550b8>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@0550c0>, cast: static variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <@0550c8>, cast: static variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <@055100>, cast: static variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <@055108>, cast: static variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@055110>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@055118>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@055120>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@055128>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@055130>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@055138>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@055140>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@055148>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@055150>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@055158>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@055160>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@055168>, cast: static const function)
.field nthArray: function (size: 12, offs: <@055178>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@055188>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@041690>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@0551c8>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@042568>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@055268>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@055290>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@0552a0>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@0552e8>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@043ce8>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@043f48>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@0441a8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@044370>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@055328>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@055330>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@055338>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@055340>, cast: static variable(val))
.field blue: color (size: 4, offs: <@055348>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@044810>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@044c38>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@045060>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@045488>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@0458b0>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@045cd8>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@055350>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@055358>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@055360>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@055368>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@055370>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@055378>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@055380>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@055388>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@055390>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@055398>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@0553a0>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@0553a8>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@0553b0>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@0553b8>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@0553c0>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@0553c8>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@0553d0>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@0553d8>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@0553e0>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@0553e8>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@0553f0>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@0553f8>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@055400>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@055408>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@055410>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@055418>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@055420>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@055428>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@055430>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@055438>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@055440>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@055448>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@055450>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@055458>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@055460>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@055468>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@055470>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@055478>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@055480>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@055488>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@055490>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@055498>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@0554a0>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@0554a8>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@0554b0>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@0554b8>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@0554c0>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@0554c8>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@0554d0>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@0554d8>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@0554e0>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@0554e8>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@0554f0>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@0554f8>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@055500>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@055508>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@055510>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@055518>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@055520>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@055528>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@055530>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@055538>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@055540>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@055548>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@055550>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@055558>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@055560>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@055568>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@055570>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@055578>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@055580>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@055588>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@055590>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@055598>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@0555a0>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@0555a8>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@0555b0>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@0555b8>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@0555c0>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@0555c8>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@0555d0>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@0555d8>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@0555e0>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@0555e8>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@0555f0>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@0555f8>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@055600>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@055608>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@055610>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@055618>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@055620>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@055628>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@055630>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@055638>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@055640>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@055648>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@055650>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@055658>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@055660>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@055668>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@055670>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@055678>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@055680>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@055688>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@055690>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@055698>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@0556a0>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@0556a8>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@0556b0>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@0556b8>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@0556c0>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@0556c8>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@0556d0>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@0556d8>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@0556e0>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@0556e8>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@0556f0>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@0556f8>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@055700>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@055708>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@055710>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@055718>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@055720>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@055728>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@055730>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@055738>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@055740>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@055748>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@055750>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@055758>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@055760>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@055768>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@055770>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@055778>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@055780>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@055788>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@055790>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@055798>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@0557a0>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@0557a8>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@0557b0>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@0557b8>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@0557c0>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@0557c8>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@0557d0>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@0557d8>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@0557e0>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@0557e8>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@0557f0>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@0557f8>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@055800>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@055808>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@055810>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@055818>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@055820>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@055828>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@055830>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@055838>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@055840>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@055848>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@055850>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@055858>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@055860>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@055868>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@055870>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@055878>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@055880>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@055888>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@055890>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@055898>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@0558a0>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@0558a8>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@0558b0>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@0558b8>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@0558c0>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@0558c8>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@0558d0>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@0558d8>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@0558e0>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@0558e8>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@0558f0>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@0558f8>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@055900>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@055908>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@055910>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@055918>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@055920>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@055928>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@055930>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@055938>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@055940>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@055948>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@055950>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@055958>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@055960>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@055968>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@055970>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@055978>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@055980>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@055988>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@055990>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@055998>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@0559a0>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@0559a8>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@0559b0>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@0559b8>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@0559c0>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@0559c8>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@0559d0>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@0559d8>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@0559e0>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@0559e8>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@0559f0>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@0559f8>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@055a00>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@055a08>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@055a10>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@055a18>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@055a20>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@055a28>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@055a30>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@055a38>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@055a40>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@055a48>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@055a50>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@055a58>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@055a60>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@055a68>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@055a70>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@055a78>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@055a80>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@055a88>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@055a90>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@055a98>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@055aa0>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@055aa8>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@055ab0>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@055ab8>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@055ac0>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@055ac8>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@055ad0>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@055ad8>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@055ae0>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@055ae8>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@055af0>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@055af8>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@055b00>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@055b08>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@055b10>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@055b18>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@055b20>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@055b28>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@055b30>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@055b38>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@055b40>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@055b48>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@055b50>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@055b58>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@055b60>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@055b68>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@055b70>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@055b78>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@055b80>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@055b88>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@055b90>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@055b98>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@055ba0>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@055ba8>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@055bb0>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@055bb8>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@055bc0>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@055bc8>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@055bd0>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@055bd8>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@055be0>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@055be8>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@055bf0>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@055bf8>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@055c00>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@055c08>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@055c10>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@055c18>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@055c20>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@055c28>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@055c30>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@055c38>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@055c40>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@055c48>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@055c50>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@055c58>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@055c60>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@055c68>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@055c70>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@055c78>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@055c80>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@055c88>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@055c90>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@055c98>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@055ca0>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@055ca8>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@055cb0>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@055cb8>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@055cc0>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@055cc8>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@055cd0>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@055cd8>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@055ce0>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@055ce8>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@055cf0>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@055cf8>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@055d00>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@055d08>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@055d10>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@055d18>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@055d20>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@055d28>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@055d30>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@055d38>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@055d40>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@055d48>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@055d50>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@055d58>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@055d60>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@055d68>, cast: static variable(f32))
.field .main: function (size: 14636, offs: <@055d6c>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static if (bool(typename(raise) == function)) {
			static verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		static add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool(null == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool(null == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
			static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
			static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			static min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
			static max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
			static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
			static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
			static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
			static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
			static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool(null == null)) {
			static const mat4f: struct {
				data: float32[16];
				m: float32[4][4];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
				<?>: <?>;
				xx: float32 := xx: float32;
				xy: float32 := xy: float32;
				xz: float32 := xz: float32;
				xw: float32 := xw: float32;
				yx: float32 := yx: float32;
				yy: float32 := yy: float32;
				yz: float32 := yz: float32;
				yw: float32 := yw: float32;
				zx: float32 := zx: float32;
				zy: float32 := zy: float32;
				zz: float32 := zz: float32;
				zw: float32 := zw: float32;
				wx: float32 := wx: float32;
				wy: float32 := wy: float32;
				wz: float32 := wz: float32;
				ww: float32 := ww: float32;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
			static const rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
				len: float32 := length(direction);
				if (bool((len) < 0.000000)) {
					trace(void("invalid direction of rotation", direction));
					return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
				}
				x: float32 := float32(direction.x / len);
				y: float32 := float32(direction.y / len);
				z: float32 := float32(direction.z / len);
				cx: float32 := center.x;
				cy: float32 := center.y;
				cz: float32 := center.z;
				xx: float32 := float32(x * x);
				xy: float32 := float32(x * y);
				xz: float32 := float32(x * z);
				yy: float32 := float32(y * y);
				yz: float32 := float32(y * z);
				zz: float32 := float32(z * z);
				s: float32 := float32.sin(angle);
				c: float32 := float32.cos(angle);
				k: float32 := float32((1) - c);
				return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
			};
			static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
			static const translation(const direction: vec4f, amount: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
			};
			static const scale(const direction: vec4f, amount: float32): mat4f := {
				rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
				return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
			};
		}
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedNoInit: int64[7];
		static arrArrayNoInit: int64[*];
		static arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedNoInit;
		static arrSliceInitFixed: int64[] := arrFixedNoInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14636 bytes: <@055d6c> - <@059698>)
	lib/std/string.ci:144: (14 bytes: <@055d6c> - <@055d7a>): static const whiteSpace: char[] := " \t\n\r"
	<.main @055d6c>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @055d71>    : 1f e1 f5 01 00             load.ref <@01f5e1> ;" \t\n\r"
	<.main+10 @055d76>   : 2d 98 3f 05                store.m64 <@053f98> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@055d7a> - <@055d88>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @055d7a>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @055d7f>   : 1f f2 f5 01 00             load.ref <@01f5f2> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @055d84>   : 2d a0 3f 05                store.m64 <@053fa0> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@055d88> - <@055da2>): static const format: FormatFlags := {...}
	<.main+28 @055d88>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @055d8d>   : 2e 90 42 05                store.m32 <@054290> ;append.format
	:: (7 bytes: <@055d91> - <@055d98>): void(format.padChr := (0))
	<.main+37 @055d91>   : 19                         load.z32
	<.main+38 @055d92>   : 1f 94 42 05 00             load.ref <@054294> ;append.format+4
	<.main+43 @055d97>   : 25                         store.i8
	:: (5 bytes: <@055d98> - <@055d9d>): void(format.padLen := 0)
	<.main+44 @055d98>   : 19                         load.z32
	<.main+45 @055d99>   : 2e 98 42 05                store.m32 <@054298> ;append.format+8
	:: (5 bytes: <@055d9d> - <@055da2>): void(format.precision := 0)
	<.main+49 @055d9d>   : 19                         load.z32
	<.main+50 @055d9e>   : 2e 9c 42 05                store.m32 <@05429c> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@055da2> - <@055da7>): static emitldz32: int32 := emit(load.z32)
	<.main+54 @055da2>   : 19                         load.z32
	<.main+55 @055da3>   : 2e 18 48 05                store.m32 <@054818> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@055da7> - <@055dac>): static emitldz64: int64 := emit(load.z64)
	<.main+59 @055da7>   : 1a                         load.z64
	<.main+60 @055da8>   : 2d 20 48 05                store.m64 <@054820> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@055dac> - <@055db5>): static emitA: int32 := 42
	<.main+64 @055dac>   : 1c 2a 00 00 00             load.c32 42
	<.main+69 @055db1>   : 2e 28 48 05                store.m32 <@054828> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@055db5> - <@055dbe>): static emitB: int32 := 96
	<.main+73 @055db5>   : 1c 60 00 00 00             load.c32 96
	<.main+78 @055dba>   : 2e 30 48 05                store.m32 <@054830> ;emitB
	test/lang/emit.ci:9: (13 bytes: <@055dbe> - <@055dcb>): static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+82 @055dbe>   : 2a 28 48 05                load.m32 <@054828> ;emitA
	<.main+86 @055dc2>   : 2a 30 48 05                load.m32 <@054830> ;emitB
	<.main+90 @055dc6>   : 51                         add.i32
	<.main+91 @055dc7>   : 2e 38 48 05                store.m32 <@054838> ;emitAddI32
	test/lang/emit.ci:10: (15 bytes: <@055dcb> - <@055dda>): static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+95 @055dcb>   : 1c 0a 00 00 00             load.c32 10
	<.main+100 @055dd0>  : 1c 05 00 00 00             load.c32 5
	<.main+105 @055dd5>  : 54                         div.i32
	<.main+106 @055dd6>  : 2e 40 48 05                store.m32 <@054840> ;emitDivI32
	test/lang/emit.ci:17: (9 bytes: <@055dda> - <@055de3>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+110 @055dda>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+115 @055ddf>  : 2e 48 48 05                store.m32 <@054848> ;emitFloatAsInt1
	test/lang/emit.ci:18: (10 bytes: <@055de3> - <@055ded>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+119 @055de3>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+124 @055de8>  : 5b                         i32.2i64
	<.main+125 @055de9>  : 2d 50 48 05                store.m64 <@054850> ;emitFloatAsInt2
	test/lang/emit.ci:19: (14 bytes: <@055ded> - <@055dfb>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+129 @055ded>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+138 @055df6>  : 6a                         i64.2i32
	<.main+139 @055df7>  : 2e 58 48 05                store.m32 <@054858> ;emitFloatAsInt3
	test/lang/emit.ci:20: (13 bytes: <@055dfb> - <@055e08>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+143 @055dfb>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+152 @055e04>  : 2d 60 48 05                store.m64 <@054860> ;emitFloatAsInt4
	test/lang/emit.ci:23: (14 bytes: <@055e08> - <@055e16>): static emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+156 @055e08>  : 1c 03 00 00 00             load.c32 3
	<.main+161 @055e0d>  : 1f ec e3 02 00             load.ref <@02e3ec> ;"string"
	<.main+166 @055e12>  : 2d 68 48 05                store.m64 <@054868> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@055e16> - <@055e1f>): static i3: int32 := 3
	<.main+170 @055e16>  : 1c 03 00 00 00             load.c32 3
	<.main+175 @055e1b>  : 2e 70 48 05                store.m32 <@054870> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@055e1f> - <@055e28>): static i6: int32 := 6
	<.main+179 @055e1f>  : 1c 06 00 00 00             load.c32 6
	<.main+184 @055e24>  : 2e 78 48 05                store.m32 <@054878> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@055e28> - <@055e31>): static i2: int32 := 2
	<.main+188 @055e28>  : 1c 02 00 00 00             load.c32 2
	<.main+193 @055e2d>  : 2e 80 48 05                store.m32 <@054880> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@055e31> - <@055e3a>): static i8: int32 := 8
	<.main+197 @055e31>  : 1c 08 00 00 00             load.c32 8
	<.main+202 @055e36>  : 2e 88 48 05                store.m32 <@054888> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@055e3a> - <@055e3f>): static zeroVal: int32 := zero(void(3, 6))
	<.main+206 @055e3a>  : 19                         load.z32
	<.main+207 @055e3b>  : 2e 90 48 05                store.m32 <@054890> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@055e3f> - <@055e44>): static zeroVar: int32 := zero(void(i3, i6))
	<.main+211 @055e3f>  : 19                         load.z32
	<.main+212 @055e40>  : 2e 98 48 05                store.m32 <@054898> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@055e44> - <@055e49>): static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+216 @055e44>  : 19                         load.z32
	<.main+217 @055e45>  : 2e a0 48 05                store.m32 <@0548a0> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@055e49> - <@055e52>): static lastVal: int32 := last(void(3, 6))
	<.main+221 @055e49>  : 1c 06 00 00 00             load.c32 6
	<.main+226 @055e4e>  : 2e a8 48 05                store.m32 <@0548a8> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@055e52> - <@055e5a>): static lastVar: int32 := last(void(i3, i6))
	<.main+230 @055e52>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+234 @055e56>  : 2e b0 48 05                store.m32 <@0548b0> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@055e5a> - <@055e6a>): static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+238 @055e5a>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+242 @055e5e>  : 0c 01 00 00                inc.i32(+1)
	<.main+246 @055e62>  : 0c ff ff ff                inc.i32(-1)
	<.main+250 @055e66>  : 2e b8 48 05                store.m32 <@0548b8> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@055e6a> - <@055e77>): static sum2Val: int32 := sum(void(3, 6))
	<.main+254 @055e6a>  : 1c 03 00 00 00             load.c32 3
	<.main+259 @055e6f>  : 0c 06 00 00                inc.i32(+6)
	<.main+263 @055e73>  : 2e c0 48 05                store.m32 <@0548c0> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@055e77> - <@055e84>): static sum2Var: int32 := sum(void(i3, i6))
	<.main+267 @055e77>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+271 @055e7b>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+275 @055e7f>  : 51                         add.i32
	<.main+276 @055e80>  : 2e c8 48 05                store.m32 <@0548c8> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@055e84> - <@055e9d>): static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+280 @055e84>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+284 @055e88>  : 0c 01 00 00                inc.i32(+1)
	<.main+288 @055e8c>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+292 @055e90>  : 0c 01 00 00                inc.i32(+1)
	<.main+296 @055e94>  : 51                         add.i32
	<.main+297 @055e95>  : 0c fe ff ff                inc.i32(-2)
	<.main+301 @055e99>  : 2e d0 48 05                store.m32 <@0548d0> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@055e9d> - <@055eb9>): static any2Val: int32 := any(void(3, 6))
	<.main+305 @055e9d>  : 1c 03 00 00 00             load.c32 3
	<.main+310 @055ea2>  : 10 00                      dup.x32 sp(0)
	<.main+312 @055ea4>  : 06 0a 00 00                jz <.main+322 @055eae>
	<.main+316 @055ea8>  : 10 00                      dup.x32 sp(0)
	<.main+318 @055eaa>  : 04 09 00 00                jmp <.main+327 @055eb3>
	<.main+322 @055eae>  : 1c 06 00 00 00             load.c32 6
	<.main+327 @055eb3>  : 13 01                      set.x32 sp(1)
	<.main+329 @055eb5>  : 2e d8 48 05                store.m32 <@0548d8> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@055eb9> - <@055ed3>): static any2Var: int32 := any(void(i3, i6))
	<.main+333 @055eb9>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+337 @055ebd>  : 10 00                      dup.x32 sp(0)
	<.main+339 @055ebf>  : 06 0a 00 00                jz <.main+349 @055ec9>
	<.main+343 @055ec3>  : 10 00                      dup.x32 sp(0)
	<.main+345 @055ec5>  : 04 08 00 00                jmp <.main+353 @055ecd>
	<.main+349 @055ec9>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+353 @055ecd>  : 13 01                      set.x32 sp(1)
	<.main+355 @055ecf>  : 2e e0 48 05                store.m32 <@0548e0> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@055ed3> - <@055ef9>): static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+359 @055ed3>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+363 @055ed7>  : 0c 01 00 00                inc.i32(+1)
	<.main+367 @055edb>  : 10 00                      dup.x32 sp(0)
	<.main+369 @055edd>  : 06 0a 00 00                jz <.main+379 @055ee7>
	<.main+373 @055ee1>  : 10 00                      dup.x32 sp(0)
	<.main+375 @055ee3>  : 04 0c 00 00                jmp <.main+387 @055eef>
	<.main+379 @055ee7>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+383 @055eeb>  : 0c 01 00 00                inc.i32(+1)
	<.main+387 @055eef>  : 13 01                      set.x32 sp(1)
	<.main+389 @055ef1>  : 0c ff ff ff                inc.i32(-1)
	<.main+393 @055ef5>  : 2e e8 48 05                store.m32 <@0548e8> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@055ef9> - <@055f1e>): static min2Val: int32 := min(void(3, 6))
	<.main+397 @055ef9>  : 1c 03 00 00 00             load.c32 3
	<.main+402 @055efe>  : 1c 06 00 00 00             load.c32 6
	<.main+407 @055f03>  : 10 01                      dup.x32 sp(1)
	<.main+409 @055f05>  : 10 01                      dup.x32 sp(1)
	<.main+411 @055f07>  : 58                         clt.i32
	<.main+412 @055f08>  : 06 0a 00 00                jz <.main+422 @055f12>
	<.main+416 @055f0c>  : 10 01                      dup.x32 sp(1)
	<.main+418 @055f0e>  : 04 06 00 00                jmp <.main+424 @055f14>
	<.main+422 @055f12>  : 10 00                      dup.x32 sp(0)
	<.main+424 @055f14>  : 13 02                      set.x32 sp(2)
	<.main+426 @055f16>  : 09 fc ff ff                inc.sp(-4)
	<.main+430 @055f1a>  : 2e f0 48 05                store.m32 <@0548f0> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@055f1e> - <@055f41>): static min2Var: int32 := min(void(i3, i6))
	<.main+434 @055f1e>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+438 @055f22>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+442 @055f26>  : 10 01                      dup.x32 sp(1)
	<.main+444 @055f28>  : 10 01                      dup.x32 sp(1)
	<.main+446 @055f2a>  : 58                         clt.i32
	<.main+447 @055f2b>  : 06 0a 00 00                jz <.main+457 @055f35>
	<.main+451 @055f2f>  : 10 01                      dup.x32 sp(1)
	<.main+453 @055f31>  : 04 06 00 00                jmp <.main+459 @055f37>
	<.main+457 @055f35>  : 10 00                      dup.x32 sp(0)
	<.main+459 @055f37>  : 13 02                      set.x32 sp(2)
	<.main+461 @055f39>  : 09 fc ff ff                inc.sp(-4)
	<.main+465 @055f3d>  : 2e f8 48 05                store.m32 <@0548f8> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@055f41> - <@055f70>): static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+469 @055f41>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+473 @055f45>  : 0c 01 00 00                inc.i32(+1)
	<.main+477 @055f49>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+481 @055f4d>  : 0c 01 00 00                inc.i32(+1)
	<.main+485 @055f51>  : 10 01                      dup.x32 sp(1)
	<.main+487 @055f53>  : 10 01                      dup.x32 sp(1)
	<.main+489 @055f55>  : 58                         clt.i32
	<.main+490 @055f56>  : 06 0a 00 00                jz <.main+500 @055f60>
	<.main+494 @055f5a>  : 10 01                      dup.x32 sp(1)
	<.main+496 @055f5c>  : 04 06 00 00                jmp <.main+502 @055f62>
	<.main+500 @055f60>  : 10 00                      dup.x32 sp(0)
	<.main+502 @055f62>  : 13 02                      set.x32 sp(2)
	<.main+504 @055f64>  : 09 fc ff ff                inc.sp(-4)
	<.main+508 @055f68>  : 0c ff ff ff                inc.i32(-1)
	<.main+512 @055f6c>  : 2e 00 49 05                store.m32 <@054900> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@055f70> - <@055f95>): static max2Val: int32 := max(void(3, 6))
	<.main+516 @055f70>  : 1c 03 00 00 00             load.c32 3
	<.main+521 @055f75>  : 1c 06 00 00 00             load.c32 6
	<.main+526 @055f7a>  : 10 01                      dup.x32 sp(1)
	<.main+528 @055f7c>  : 10 01                      dup.x32 sp(1)
	<.main+530 @055f7e>  : 59                         cgt.i32
	<.main+531 @055f7f>  : 06 0a 00 00                jz <.main+541 @055f89>
	<.main+535 @055f83>  : 10 01                      dup.x32 sp(1)
	<.main+537 @055f85>  : 04 06 00 00                jmp <.main+543 @055f8b>
	<.main+541 @055f89>  : 10 00                      dup.x32 sp(0)
	<.main+543 @055f8b>  : 13 02                      set.x32 sp(2)
	<.main+545 @055f8d>  : 09 fc ff ff                inc.sp(-4)
	<.main+549 @055f91>  : 2e 08 49 05                store.m32 <@054908> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@055f95> - <@055fb8>): static max2Var: int32 := max(void(i3, i6))
	<.main+553 @055f95>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+557 @055f99>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+561 @055f9d>  : 10 01                      dup.x32 sp(1)
	<.main+563 @055f9f>  : 10 01                      dup.x32 sp(1)
	<.main+565 @055fa1>  : 59                         cgt.i32
	<.main+566 @055fa2>  : 06 0a 00 00                jz <.main+576 @055fac>
	<.main+570 @055fa6>  : 10 01                      dup.x32 sp(1)
	<.main+572 @055fa8>  : 04 06 00 00                jmp <.main+578 @055fae>
	<.main+576 @055fac>  : 10 00                      dup.x32 sp(0)
	<.main+578 @055fae>  : 13 02                      set.x32 sp(2)
	<.main+580 @055fb0>  : 09 fc ff ff                inc.sp(-4)
	<.main+584 @055fb4>  : 2e 10 49 05                store.m32 <@054910> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@055fb8> - <@055fe7>): static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+588 @055fb8>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+592 @055fbc>  : 0c 01 00 00                inc.i32(+1)
	<.main+596 @055fc0>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+600 @055fc4>  : 0c 01 00 00                inc.i32(+1)
	<.main+604 @055fc8>  : 10 01                      dup.x32 sp(1)
	<.main+606 @055fca>  : 10 01                      dup.x32 sp(1)
	<.main+608 @055fcc>  : 59                         cgt.i32
	<.main+609 @055fcd>  : 06 0a 00 00                jz <.main+619 @055fd7>
	<.main+613 @055fd1>  : 10 01                      dup.x32 sp(1)
	<.main+615 @055fd3>  : 04 06 00 00                jmp <.main+621 @055fd9>
	<.main+619 @055fd7>  : 10 00                      dup.x32 sp(0)
	<.main+621 @055fd9>  : 13 02                      set.x32 sp(2)
	<.main+623 @055fdb>  : 09 fc ff ff                inc.sp(-4)
	<.main+627 @055fdf>  : 0c ff ff ff                inc.i32(-1)
	<.main+631 @055fe3>  : 2e 18 49 05                store.m32 <@054918> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@055fe7> - <@056000>): static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+635 @055fe7>  : 1c 03 00 00 00             load.c32 3
	<.main+640 @055fec>  : 1c 06 00 00 00             load.c32 6
	<.main+645 @055ff1>  : 1c 02 00 00 00             load.c32 2
	<.main+650 @055ff6>  : 0c 08 00 00                inc.i32(+8)
	<.main+654 @055ffa>  : 51                         add.i32
	<.main+655 @055ffb>  : 51                         add.i32
	<.main+656 @055ffc>  : 2e 20 49 05                store.m32 <@054920> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@056000> - <@056015>): static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+660 @056000>  : 1c 03 00 00 00             load.c32 3
	<.main+665 @056005>  : 0c 06 00 00                inc.i32(+6)
	<.main+669 @056009>  : 0c 02 00 00                inc.i32(+2)
	<.main+673 @05600d>  : 0c 08 00 00                inc.i32(+8)
	<.main+677 @056011>  : 2e 28 49 05                store.m32 <@054928> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@056015> - <@05602c>): static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+681 @056015>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+685 @056019>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+689 @05601d>  : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+693 @056021>  : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+697 @056025>  : 51                         add.i32
	<.main+698 @056026>  : 51                         add.i32
	<.main+699 @056027>  : 51                         add.i32
	<.main+700 @056028>  : 2e 30 49 05                store.m32 <@054930> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@05602c> - <@056043>): static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+704 @05602c>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+708 @056030>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+712 @056034>  : 51                         add.i32
	<.main+713 @056035>  : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+717 @056039>  : 51                         add.i32
	<.main+718 @05603a>  : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+722 @05603e>  : 51                         add.i32
	<.main+723 @05603f>  : 2e 38 49 05                store.m32 <@054938> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@056043> - <@05606e>): static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+727 @056043>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+731 @056047>  : 0c 01 00 00                inc.i32(+1)
	<.main+735 @05604b>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+739 @05604f>  : 0c 01 00 00                inc.i32(+1)
	<.main+743 @056053>  : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+747 @056057>  : 0c 01 00 00                inc.i32(+1)
	<.main+751 @05605b>  : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+755 @05605f>  : 0c 01 00 00                inc.i32(+1)
	<.main+759 @056063>  : 51                         add.i32
	<.main+760 @056064>  : 51                         add.i32
	<.main+761 @056065>  : 51                         add.i32
	<.main+762 @056066>  : 0c fc ff ff                inc.i32(-4)
	<.main+766 @05606a>  : 2e 40 49 05                store.m32 <@054940> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@05606e> - <@056099>): static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+770 @05606e>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+774 @056072>  : 0c 01 00 00                inc.i32(+1)
	<.main+778 @056076>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+782 @05607a>  : 0c 01 00 00                inc.i32(+1)
	<.main+786 @05607e>  : 51                         add.i32
	<.main+787 @05607f>  : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+791 @056083>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @056087>  : 51                         add.i32
	<.main+796 @056088>  : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+800 @05608c>  : 0c 01 00 00                inc.i32(+1)
	<.main+804 @056090>  : 51                         add.i32
	<.main+805 @056091>  : 0c fc ff ff                inc.i32(-4)
	<.main+809 @056095>  : 2e 48 49 05                store.m32 <@054948> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@056099> - <@0560db>): static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+813 @056099>  : 1c 03 00 00 00             load.c32 3
	<.main+818 @05609e>  : 10 00                      dup.x32 sp(0)
	<.main+820 @0560a0>  : 06 0a 00 00                jz <.main+830 @0560aa>
	<.main+824 @0560a4>  : 10 00                      dup.x32 sp(0)
	<.main+826 @0560a6>  : 04 2f 00 00                jmp <.main+873 @0560d5>
	<.main+830 @0560aa>  : 1c 06 00 00 00             load.c32 6
	<.main+835 @0560af>  : 10 00                      dup.x32 sp(0)
	<.main+837 @0560b1>  : 06 0a 00 00                jz <.main+847 @0560bb>
	<.main+841 @0560b5>  : 10 00                      dup.x32 sp(0)
	<.main+843 @0560b7>  : 04 1c 00 00                jmp <.main+871 @0560d3>
	<.main+847 @0560bb>  : 1c 02 00 00 00             load.c32 2
	<.main+852 @0560c0>  : 10 00                      dup.x32 sp(0)
	<.main+854 @0560c2>  : 06 0a 00 00                jz <.main+864 @0560cc>
	<.main+858 @0560c6>  : 10 00                      dup.x32 sp(0)
	<.main+860 @0560c8>  : 04 09 00 00                jmp <.main+869 @0560d1>
	<.main+864 @0560cc>  : 1c 08 00 00 00             load.c32 8
	<.main+869 @0560d1>  : 13 01                      set.x32 sp(1)
	<.main+871 @0560d3>  : 13 01                      set.x32 sp(1)
	<.main+873 @0560d5>  : 13 01                      set.x32 sp(1)
	<.main+875 @0560d7>  : 2e 50 49 05                store.m32 <@054950> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@0560db> - <@05611d>): static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+879 @0560db>  : 1c 03 00 00 00             load.c32 3
	<.main+884 @0560e0>  : 10 00                      dup.x32 sp(0)
	<.main+886 @0560e2>  : 06 0a 00 00                jz <.main+896 @0560ec>
	<.main+890 @0560e6>  : 10 00                      dup.x32 sp(0)
	<.main+892 @0560e8>  : 04 09 00 00                jmp <.main+901 @0560f1>
	<.main+896 @0560ec>  : 1c 06 00 00 00             load.c32 6
	<.main+901 @0560f1>  : 13 01                      set.x32 sp(1)
	<.main+903 @0560f3>  : 10 00                      dup.x32 sp(0)
	<.main+905 @0560f5>  : 06 0a 00 00                jz <.main+915 @0560ff>
	<.main+909 @0560f9>  : 10 00                      dup.x32 sp(0)
	<.main+911 @0560fb>  : 04 09 00 00                jmp <.main+920 @056104>
	<.main+915 @0560ff>  : 1c 02 00 00 00             load.c32 2
	<.main+920 @056104>  : 13 01                      set.x32 sp(1)
	<.main+922 @056106>  : 10 00                      dup.x32 sp(0)
	<.main+924 @056108>  : 06 0a 00 00                jz <.main+934 @056112>
	<.main+928 @05610c>  : 10 00                      dup.x32 sp(0)
	<.main+930 @05610e>  : 04 09 00 00                jmp <.main+939 @056117>
	<.main+934 @056112>  : 1c 08 00 00 00             load.c32 8
	<.main+939 @056117>  : 13 01                      set.x32 sp(1)
	<.main+941 @056119>  : 2e 58 49 05                store.m32 <@054958> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@05611d> - <@05615b>): static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+945 @05611d>  : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+949 @056121>  : 10 00                      dup.x32 sp(0)
	<.main+951 @056123>  : 06 0a 00 00                jz <.main+961 @05612d>
	<.main+955 @056127>  : 10 00                      dup.x32 sp(0)
	<.main+957 @056129>  : 04 2c 00 00                jmp <.main+1001 @056155>
	<.main+961 @05612d>  : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+965 @056131>  : 10 00                      dup.x32 sp(0)
	<.main+967 @056133>  : 06 0a 00 00                jz <.main+977 @05613d>
	<.main+971 @056137>  : 10 00                      dup.x32 sp(0)
	<.main+973 @056139>  : 04 1a 00 00                jmp <.main+999 @056153>
	<.main+977 @05613d>  : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+981 @056141>  : 10 00                      dup.x32 sp(0)
	<.main+983 @056143>  : 06 0a 00 00                jz <.main+993 @05614d>
	<.main+987 @056147>  : 10 00                      dup.x32 sp(0)
	<.main+989 @056149>  : 04 08 00 00                jmp <.main+997 @056151>
	<.main+993 @05614d>  : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+997 @056151>  : 13 01                      set.x32 sp(1)
	<.main+999 @056153>  : 13 01                      set.x32 sp(1)
	<.main+1001 @056155> : 13 01                      set.x32 sp(1)
	<.main+1003 @056157> : 2e 60 49 05                store.m32 <@054960> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@05615b> - <@056199>): static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+1007 @05615b> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1011 @05615f> : 10 00                      dup.x32 sp(0)
	<.main+1013 @056161> : 06 0a 00 00                jz <.main+1023 @05616b>
	<.main+1017 @056165> : 10 00                      dup.x32 sp(0)
	<.main+1019 @056167> : 04 08 00 00                jmp <.main+1027 @05616f>
	<.main+1023 @05616b> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1027 @05616f> : 13 01                      set.x32 sp(1)
	<.main+1029 @056171> : 10 00                      dup.x32 sp(0)
	<.main+1031 @056173> : 06 0a 00 00                jz <.main+1041 @05617d>
	<.main+1035 @056177> : 10 00                      dup.x32 sp(0)
	<.main+1037 @056179> : 04 08 00 00                jmp <.main+1045 @056181>
	<.main+1041 @05617d> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1045 @056181> : 13 01                      set.x32 sp(1)
	<.main+1047 @056183> : 10 00                      dup.x32 sp(0)
	<.main+1049 @056185> : 06 0a 00 00                jz <.main+1059 @05618f>
	<.main+1053 @056189> : 10 00                      dup.x32 sp(0)
	<.main+1055 @05618b> : 04 08 00 00                jmp <.main+1063 @056193>
	<.main+1059 @05618f> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1063 @056193> : 13 01                      set.x32 sp(1)
	<.main+1065 @056195> : 2e 68 49 05                store.m32 <@054968> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@056199> - <@0561eb>): static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1069 @056199> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1073 @05619d> : 0c 01 00 00                inc.i32(+1)
	<.main+1077 @0561a1> : 10 00                      dup.x32 sp(0)
	<.main+1079 @0561a3> : 06 0a 00 00                jz <.main+1089 @0561ad>
	<.main+1083 @0561a7> : 10 00                      dup.x32 sp(0)
	<.main+1085 @0561a9> : 04 38 00 00                jmp <.main+1141 @0561e1>
	<.main+1089 @0561ad> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1093 @0561b1> : 0c 01 00 00                inc.i32(+1)
	<.main+1097 @0561b5> : 10 00                      dup.x32 sp(0)
	<.main+1099 @0561b7> : 06 0a 00 00                jz <.main+1109 @0561c1>
	<.main+1103 @0561bb> : 10 00                      dup.x32 sp(0)
	<.main+1105 @0561bd> : 04 22 00 00                jmp <.main+1139 @0561df>
	<.main+1109 @0561c1> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1113 @0561c5> : 0c 01 00 00                inc.i32(+1)
	<.main+1117 @0561c9> : 10 00                      dup.x32 sp(0)
	<.main+1119 @0561cb> : 06 0a 00 00                jz <.main+1129 @0561d5>
	<.main+1123 @0561cf> : 10 00                      dup.x32 sp(0)
	<.main+1125 @0561d1> : 04 0c 00 00                jmp <.main+1137 @0561dd>
	<.main+1129 @0561d5> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1133 @0561d9> : 0c 01 00 00                inc.i32(+1)
	<.main+1137 @0561dd> : 13 01                      set.x32 sp(1)
	<.main+1139 @0561df> : 13 01                      set.x32 sp(1)
	<.main+1141 @0561e1> : 13 01                      set.x32 sp(1)
	<.main+1143 @0561e3> : 0c ff ff ff                inc.i32(-1)
	<.main+1147 @0561e7> : 2e 70 49 05                store.m32 <@054970> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@0561eb> - <@05623d>): static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1151 @0561eb> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1155 @0561ef> : 0c 01 00 00                inc.i32(+1)
	<.main+1159 @0561f3> : 10 00                      dup.x32 sp(0)
	<.main+1161 @0561f5> : 06 0a 00 00                jz <.main+1171 @0561ff>
	<.main+1165 @0561f9> : 10 00                      dup.x32 sp(0)
	<.main+1167 @0561fb> : 04 0c 00 00                jmp <.main+1179 @056207>
	<.main+1171 @0561ff> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1175 @056203> : 0c 01 00 00                inc.i32(+1)
	<.main+1179 @056207> : 13 01                      set.x32 sp(1)
	<.main+1181 @056209> : 10 00                      dup.x32 sp(0)
	<.main+1183 @05620b> : 06 0a 00 00                jz <.main+1193 @056215>
	<.main+1187 @05620f> : 10 00                      dup.x32 sp(0)
	<.main+1189 @056211> : 04 0c 00 00                jmp <.main+1201 @05621d>
	<.main+1193 @056215> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1197 @056219> : 0c 01 00 00                inc.i32(+1)
	<.main+1201 @05621d> : 13 01                      set.x32 sp(1)
	<.main+1203 @05621f> : 10 00                      dup.x32 sp(0)
	<.main+1205 @056221> : 06 0a 00 00                jz <.main+1215 @05622b>
	<.main+1209 @056225> : 10 00                      dup.x32 sp(0)
	<.main+1211 @056227> : 04 0c 00 00                jmp <.main+1223 @056233>
	<.main+1215 @05622b> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1219 @05622f> : 0c 01 00 00                inc.i32(+1)
	<.main+1223 @056233> : 13 01                      set.x32 sp(1)
	<.main+1225 @056235> : 0c ff ff ff                inc.i32(-1)
	<.main+1229 @056239> : 2e 78 49 05                store.m32 <@054978> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@05623d> - <@05629a>): static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1233 @05623d> : 1c 03 00 00 00             load.c32 3
	<.main+1238 @056242> : 1c 06 00 00 00             load.c32 6
	<.main+1243 @056247> : 1c 02 00 00 00             load.c32 2
	<.main+1248 @05624c> : 1c 08 00 00 00             load.c32 8
	<.main+1253 @056251> : 10 01                      dup.x32 sp(1)
	<.main+1255 @056253> : 10 01                      dup.x32 sp(1)
	<.main+1257 @056255> : 58                         clt.i32
	<.main+1258 @056256> : 06 0a 00 00                jz <.main+1268 @056260>
	<.main+1262 @05625a> : 10 01                      dup.x32 sp(1)
	<.main+1264 @05625c> : 04 06 00 00                jmp <.main+1270 @056262>
	<.main+1268 @056260> : 10 00                      dup.x32 sp(0)
	<.main+1270 @056262> : 13 02                      set.x32 sp(2)
	<.main+1272 @056264> : 09 fc ff ff                inc.sp(-4)
	<.main+1276 @056268> : 10 01                      dup.x32 sp(1)
	<.main+1278 @05626a> : 10 01                      dup.x32 sp(1)
	<.main+1280 @05626c> : 58                         clt.i32
	<.main+1281 @05626d> : 06 0a 00 00                jz <.main+1291 @056277>
	<.main+1285 @056271> : 10 01                      dup.x32 sp(1)
	<.main+1287 @056273> : 04 06 00 00                jmp <.main+1293 @056279>
	<.main+1291 @056277> : 10 00                      dup.x32 sp(0)
	<.main+1293 @056279> : 13 02                      set.x32 sp(2)
	<.main+1295 @05627b> : 09 fc ff ff                inc.sp(-4)
	<.main+1299 @05627f> : 10 01                      dup.x32 sp(1)
	<.main+1301 @056281> : 10 01                      dup.x32 sp(1)
	<.main+1303 @056283> : 58                         clt.i32
	<.main+1304 @056284> : 06 0a 00 00                jz <.main+1314 @05628e>
	<.main+1308 @056288> : 10 01                      dup.x32 sp(1)
	<.main+1310 @05628a> : 04 06 00 00                jmp <.main+1316 @056290>
	<.main+1314 @05628e> : 10 00                      dup.x32 sp(0)
	<.main+1316 @056290> : 13 02                      set.x32 sp(2)
	<.main+1318 @056292> : 09 fc ff ff                inc.sp(-4)
	<.main+1322 @056296> : 2e 80 49 05                store.m32 <@054980> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@05629a> - <@0562f7>): static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1326 @05629a> : 1c 03 00 00 00             load.c32 3
	<.main+1331 @05629f> : 1c 06 00 00 00             load.c32 6
	<.main+1336 @0562a4> : 10 01                      dup.x32 sp(1)
	<.main+1338 @0562a6> : 10 01                      dup.x32 sp(1)
	<.main+1340 @0562a8> : 58                         clt.i32
	<.main+1341 @0562a9> : 06 0a 00 00                jz <.main+1351 @0562b3>
	<.main+1345 @0562ad> : 10 01                      dup.x32 sp(1)
	<.main+1347 @0562af> : 04 06 00 00                jmp <.main+1353 @0562b5>
	<.main+1351 @0562b3> : 10 00                      dup.x32 sp(0)
	<.main+1353 @0562b5> : 13 02                      set.x32 sp(2)
	<.main+1355 @0562b7> : 09 fc ff ff                inc.sp(-4)
	<.main+1359 @0562bb> : 1c 02 00 00 00             load.c32 2
	<.main+1364 @0562c0> : 10 01                      dup.x32 sp(1)
	<.main+1366 @0562c2> : 10 01                      dup.x32 sp(1)
	<.main+1368 @0562c4> : 58                         clt.i32
	<.main+1369 @0562c5> : 06 0a 00 00                jz <.main+1379 @0562cf>
	<.main+1373 @0562c9> : 10 01                      dup.x32 sp(1)
	<.main+1375 @0562cb> : 04 06 00 00                jmp <.main+1381 @0562d1>
	<.main+1379 @0562cf> : 10 00                      dup.x32 sp(0)
	<.main+1381 @0562d1> : 13 02                      set.x32 sp(2)
	<.main+1383 @0562d3> : 09 fc ff ff                inc.sp(-4)
	<.main+1387 @0562d7> : 1c 08 00 00 00             load.c32 8
	<.main+1392 @0562dc> : 10 01                      dup.x32 sp(1)
	<.main+1394 @0562de> : 10 01                      dup.x32 sp(1)
	<.main+1396 @0562e0> : 58                         clt.i32
	<.main+1397 @0562e1> : 06 0a 00 00                jz <.main+1407 @0562eb>
	<.main+1401 @0562e5> : 10 01                      dup.x32 sp(1)
	<.main+1403 @0562e7> : 04 06 00 00                jmp <.main+1409 @0562ed>
	<.main+1407 @0562eb> : 10 00                      dup.x32 sp(0)
	<.main+1409 @0562ed> : 13 02                      set.x32 sp(2)
	<.main+1411 @0562ef> : 09 fc ff ff                inc.sp(-4)
	<.main+1415 @0562f3> : 2e 88 49 05                store.m32 <@054988> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@0562f7> - <@056350>): static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1419 @0562f7> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1423 @0562fb> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1427 @0562ff> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1431 @056303> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1435 @056307> : 10 01                      dup.x32 sp(1)
	<.main+1437 @056309> : 10 01                      dup.x32 sp(1)
	<.main+1439 @05630b> : 58                         clt.i32
	<.main+1440 @05630c> : 06 0a 00 00                jz <.main+1450 @056316>
	<.main+1444 @056310> : 10 01                      dup.x32 sp(1)
	<.main+1446 @056312> : 04 06 00 00                jmp <.main+1452 @056318>
	<.main+1450 @056316> : 10 00                      dup.x32 sp(0)
	<.main+1452 @056318> : 13 02                      set.x32 sp(2)
	<.main+1454 @05631a> : 09 fc ff ff                inc.sp(-4)
	<.main+1458 @05631e> : 10 01                      dup.x32 sp(1)
	<.main+1460 @056320> : 10 01                      dup.x32 sp(1)
	<.main+1462 @056322> : 58                         clt.i32
	<.main+1463 @056323> : 06 0a 00 00                jz <.main+1473 @05632d>
	<.main+1467 @056327> : 10 01                      dup.x32 sp(1)
	<.main+1469 @056329> : 04 06 00 00                jmp <.main+1475 @05632f>
	<.main+1473 @05632d> : 10 00                      dup.x32 sp(0)
	<.main+1475 @05632f> : 13 02                      set.x32 sp(2)
	<.main+1477 @056331> : 09 fc ff ff                inc.sp(-4)
	<.main+1481 @056335> : 10 01                      dup.x32 sp(1)
	<.main+1483 @056337> : 10 01                      dup.x32 sp(1)
	<.main+1485 @056339> : 58                         clt.i32
	<.main+1486 @05633a> : 06 0a 00 00                jz <.main+1496 @056344>
	<.main+1490 @05633e> : 10 01                      dup.x32 sp(1)
	<.main+1492 @056340> : 04 06 00 00                jmp <.main+1498 @056346>
	<.main+1496 @056344> : 10 00                      dup.x32 sp(0)
	<.main+1498 @056346> : 13 02                      set.x32 sp(2)
	<.main+1500 @056348> : 09 fc ff ff                inc.sp(-4)
	<.main+1504 @05634c> : 2e 90 49 05                store.m32 <@054990> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@056350> - <@0563a9>): static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1508 @056350> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1512 @056354> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1516 @056358> : 10 01                      dup.x32 sp(1)
	<.main+1518 @05635a> : 10 01                      dup.x32 sp(1)
	<.main+1520 @05635c> : 58                         clt.i32
	<.main+1521 @05635d> : 06 0a 00 00                jz <.main+1531 @056367>
	<.main+1525 @056361> : 10 01                      dup.x32 sp(1)
	<.main+1527 @056363> : 04 06 00 00                jmp <.main+1533 @056369>
	<.main+1531 @056367> : 10 00                      dup.x32 sp(0)
	<.main+1533 @056369> : 13 02                      set.x32 sp(2)
	<.main+1535 @05636b> : 09 fc ff ff                inc.sp(-4)
	<.main+1539 @05636f> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1543 @056373> : 10 01                      dup.x32 sp(1)
	<.main+1545 @056375> : 10 01                      dup.x32 sp(1)
	<.main+1547 @056377> : 58                         clt.i32
	<.main+1548 @056378> : 06 0a 00 00                jz <.main+1558 @056382>
	<.main+1552 @05637c> : 10 01                      dup.x32 sp(1)
	<.main+1554 @05637e> : 04 06 00 00                jmp <.main+1560 @056384>
	<.main+1558 @056382> : 10 00                      dup.x32 sp(0)
	<.main+1560 @056384> : 13 02                      set.x32 sp(2)
	<.main+1562 @056386> : 09 fc ff ff                inc.sp(-4)
	<.main+1566 @05638a> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1570 @05638e> : 10 01                      dup.x32 sp(1)
	<.main+1572 @056390> : 10 01                      dup.x32 sp(1)
	<.main+1574 @056392> : 58                         clt.i32
	<.main+1575 @056393> : 06 0a 00 00                jz <.main+1585 @05639d>
	<.main+1579 @056397> : 10 01                      dup.x32 sp(1)
	<.main+1581 @056399> : 04 06 00 00                jmp <.main+1587 @05639f>
	<.main+1585 @05639d> : 10 00                      dup.x32 sp(0)
	<.main+1587 @05639f> : 13 02                      set.x32 sp(2)
	<.main+1589 @0563a1> : 09 fc ff ff                inc.sp(-4)
	<.main+1593 @0563a5> : 2e 98 49 05                store.m32 <@054998> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@0563a9> - <@056416>): static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1597 @0563a9> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1601 @0563ad> : 0c 01 00 00                inc.i32(+1)
	<.main+1605 @0563b1> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1609 @0563b5> : 0c 01 00 00                inc.i32(+1)
	<.main+1613 @0563b9> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1617 @0563bd> : 0c 01 00 00                inc.i32(+1)
	<.main+1621 @0563c1> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1625 @0563c5> : 0c 01 00 00                inc.i32(+1)
	<.main+1629 @0563c9> : 10 01                      dup.x32 sp(1)
	<.main+1631 @0563cb> : 10 01                      dup.x32 sp(1)
	<.main+1633 @0563cd> : 58                         clt.i32
	<.main+1634 @0563ce> : 06 0a 00 00                jz <.main+1644 @0563d8>
	<.main+1638 @0563d2> : 10 01                      dup.x32 sp(1)
	<.main+1640 @0563d4> : 04 06 00 00                jmp <.main+1646 @0563da>
	<.main+1644 @0563d8> : 10 00                      dup.x32 sp(0)
	<.main+1646 @0563da> : 13 02                      set.x32 sp(2)
	<.main+1648 @0563dc> : 09 fc ff ff                inc.sp(-4)
	<.main+1652 @0563e0> : 10 01                      dup.x32 sp(1)
	<.main+1654 @0563e2> : 10 01                      dup.x32 sp(1)
	<.main+1656 @0563e4> : 58                         clt.i32
	<.main+1657 @0563e5> : 06 0a 00 00                jz <.main+1667 @0563ef>
	<.main+1661 @0563e9> : 10 01                      dup.x32 sp(1)
	<.main+1663 @0563eb> : 04 06 00 00                jmp <.main+1669 @0563f1>
	<.main+1667 @0563ef> : 10 00                      dup.x32 sp(0)
	<.main+1669 @0563f1> : 13 02                      set.x32 sp(2)
	<.main+1671 @0563f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1675 @0563f7> : 10 01                      dup.x32 sp(1)
	<.main+1677 @0563f9> : 10 01                      dup.x32 sp(1)
	<.main+1679 @0563fb> : 58                         clt.i32
	<.main+1680 @0563fc> : 06 0a 00 00                jz <.main+1690 @056406>
	<.main+1684 @056400> : 10 01                      dup.x32 sp(1)
	<.main+1686 @056402> : 04 06 00 00                jmp <.main+1692 @056408>
	<.main+1690 @056406> : 10 00                      dup.x32 sp(0)
	<.main+1692 @056408> : 13 02                      set.x32 sp(2)
	<.main+1694 @05640a> : 09 fc ff ff                inc.sp(-4)
	<.main+1698 @05640e> : 0c ff ff ff                inc.i32(-1)
	<.main+1702 @056412> : 2e a0 49 05                store.m32 <@0549a0> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@056416> - <@056483>): static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1706 @056416> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+1710 @05641a> : 0c 01 00 00                inc.i32(+1)
	<.main+1714 @05641e> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+1718 @056422> : 0c 01 00 00                inc.i32(+1)
	<.main+1722 @056426> : 10 01                      dup.x32 sp(1)
	<.main+1724 @056428> : 10 01                      dup.x32 sp(1)
	<.main+1726 @05642a> : 58                         clt.i32
	<.main+1727 @05642b> : 06 0a 00 00                jz <.main+1737 @056435>
	<.main+1731 @05642f> : 10 01                      dup.x32 sp(1)
	<.main+1733 @056431> : 04 06 00 00                jmp <.main+1739 @056437>
	<.main+1737 @056435> : 10 00                      dup.x32 sp(0)
	<.main+1739 @056437> : 13 02                      set.x32 sp(2)
	<.main+1741 @056439> : 09 fc ff ff                inc.sp(-4)
	<.main+1745 @05643d> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+1749 @056441> : 0c 01 00 00                inc.i32(+1)
	<.main+1753 @056445> : 10 01                      dup.x32 sp(1)
	<.main+1755 @056447> : 10 01                      dup.x32 sp(1)
	<.main+1757 @056449> : 58                         clt.i32
	<.main+1758 @05644a> : 06 0a 00 00                jz <.main+1768 @056454>
	<.main+1762 @05644e> : 10 01                      dup.x32 sp(1)
	<.main+1764 @056450> : 04 06 00 00                jmp <.main+1770 @056456>
	<.main+1768 @056454> : 10 00                      dup.x32 sp(0)
	<.main+1770 @056456> : 13 02                      set.x32 sp(2)
	<.main+1772 @056458> : 09 fc ff ff                inc.sp(-4)
	<.main+1776 @05645c> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+1780 @056460> : 0c 01 00 00                inc.i32(+1)
	<.main+1784 @056464> : 10 01                      dup.x32 sp(1)
	<.main+1786 @056466> : 10 01                      dup.x32 sp(1)
	<.main+1788 @056468> : 58                         clt.i32
	<.main+1789 @056469> : 06 0a 00 00                jz <.main+1799 @056473>
	<.main+1793 @05646d> : 10 01                      dup.x32 sp(1)
	<.main+1795 @05646f> : 04 06 00 00                jmp <.main+1801 @056475>
	<.main+1799 @056473> : 10 00                      dup.x32 sp(0)
	<.main+1801 @056475> : 13 02                      set.x32 sp(2)
	<.main+1803 @056477> : 09 fc ff ff                inc.sp(-4)
	<.main+1807 @05647b> : 0c ff ff ff                inc.i32(-1)
	<.main+1811 @05647f> : 2e a8 49 05                store.m32 <@0549a8> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@056483> - <@0564e0>): static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1815 @056483> : 1c 03 00 00 00             load.c32 3
	<.main+1820 @056488> : 1c 06 00 00 00             load.c32 6
	<.main+1825 @05648d> : 1c 02 00 00 00             load.c32 2
	<.main+1830 @056492> : 1c 08 00 00 00             load.c32 8
	<.main+1835 @056497> : 10 01                      dup.x32 sp(1)
	<.main+1837 @056499> : 10 01                      dup.x32 sp(1)
	<.main+1839 @05649b> : 59                         cgt.i32
	<.main+1840 @05649c> : 06 0a 00 00                jz <.main+1850 @0564a6>
	<.main+1844 @0564a0> : 10 01                      dup.x32 sp(1)
	<.main+1846 @0564a2> : 04 06 00 00                jmp <.main+1852 @0564a8>
	<.main+1850 @0564a6> : 10 00                      dup.x32 sp(0)
	<.main+1852 @0564a8> : 13 02                      set.x32 sp(2)
	<.main+1854 @0564aa> : 09 fc ff ff                inc.sp(-4)
	<.main+1858 @0564ae> : 10 01                      dup.x32 sp(1)
	<.main+1860 @0564b0> : 10 01                      dup.x32 sp(1)
	<.main+1862 @0564b2> : 59                         cgt.i32
	<.main+1863 @0564b3> : 06 0a 00 00                jz <.main+1873 @0564bd>
	<.main+1867 @0564b7> : 10 01                      dup.x32 sp(1)
	<.main+1869 @0564b9> : 04 06 00 00                jmp <.main+1875 @0564bf>
	<.main+1873 @0564bd> : 10 00                      dup.x32 sp(0)
	<.main+1875 @0564bf> : 13 02                      set.x32 sp(2)
	<.main+1877 @0564c1> : 09 fc ff ff                inc.sp(-4)
	<.main+1881 @0564c5> : 10 01                      dup.x32 sp(1)
	<.main+1883 @0564c7> : 10 01                      dup.x32 sp(1)
	<.main+1885 @0564c9> : 59                         cgt.i32
	<.main+1886 @0564ca> : 06 0a 00 00                jz <.main+1896 @0564d4>
	<.main+1890 @0564ce> : 10 01                      dup.x32 sp(1)
	<.main+1892 @0564d0> : 04 06 00 00                jmp <.main+1898 @0564d6>
	<.main+1896 @0564d4> : 10 00                      dup.x32 sp(0)
	<.main+1898 @0564d6> : 13 02                      set.x32 sp(2)
	<.main+1900 @0564d8> : 09 fc ff ff                inc.sp(-4)
	<.main+1904 @0564dc> : 2e b0 49 05                store.m32 <@0549b0> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@0564e0> - <@05653d>): static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1908 @0564e0> : 1c 03 00 00 00             load.c32 3
	<.main+1913 @0564e5> : 1c 06 00 00 00             load.c32 6
	<.main+1918 @0564ea> : 10 01                      dup.x32 sp(1)
	<.main+1920 @0564ec> : 10 01                      dup.x32 sp(1)
	<.main+1922 @0564ee> : 59                         cgt.i32
	<.main+1923 @0564ef> : 06 0a 00 00                jz <.main+1933 @0564f9>
	<.main+1927 @0564f3> : 10 01                      dup.x32 sp(1)
	<.main+1929 @0564f5> : 04 06 00 00                jmp <.main+1935 @0564fb>
	<.main+1933 @0564f9> : 10 00                      dup.x32 sp(0)
	<.main+1935 @0564fb> : 13 02                      set.x32 sp(2)
	<.main+1937 @0564fd> : 09 fc ff ff                inc.sp(-4)
	<.main+1941 @056501> : 1c 02 00 00 00             load.c32 2
	<.main+1946 @056506> : 10 01                      dup.x32 sp(1)
	<.main+1948 @056508> : 10 01                      dup.x32 sp(1)
	<.main+1950 @05650a> : 59                         cgt.i32
	<.main+1951 @05650b> : 06 0a 00 00                jz <.main+1961 @056515>
	<.main+1955 @05650f> : 10 01                      dup.x32 sp(1)
	<.main+1957 @056511> : 04 06 00 00                jmp <.main+1963 @056517>
	<.main+1961 @056515> : 10 00                      dup.x32 sp(0)
	<.main+1963 @056517> : 13 02                      set.x32 sp(2)
	<.main+1965 @056519> : 09 fc ff ff                inc.sp(-4)
	<.main+1969 @05651d> : 1c 08 00 00 00             load.c32 8
	<.main+1974 @056522> : 10 01                      dup.x32 sp(1)
	<.main+1976 @056524> : 10 01                      dup.x32 sp(1)
	<.main+1978 @056526> : 59                         cgt.i32
	<.main+1979 @056527> : 06 0a 00 00                jz <.main+1989 @056531>
	<.main+1983 @05652b> : 10 01                      dup.x32 sp(1)
	<.main+1985 @05652d> : 04 06 00 00                jmp <.main+1991 @056533>
	<.main+1989 @056531> : 10 00                      dup.x32 sp(0)
	<.main+1991 @056533> : 13 02                      set.x32 sp(2)
	<.main+1993 @056535> : 09 fc ff ff                inc.sp(-4)
	<.main+1997 @056539> : 2e b8 49 05                store.m32 <@0549b8> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@05653d> - <@056596>): static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+2001 @05653d> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+2005 @056541> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+2009 @056545> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+2013 @056549> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+2017 @05654d> : 10 01                      dup.x32 sp(1)
	<.main+2019 @05654f> : 10 01                      dup.x32 sp(1)
	<.main+2021 @056551> : 59                         cgt.i32
	<.main+2022 @056552> : 06 0a 00 00                jz <.main+2032 @05655c>
	<.main+2026 @056556> : 10 01                      dup.x32 sp(1)
	<.main+2028 @056558> : 04 06 00 00                jmp <.main+2034 @05655e>
	<.main+2032 @05655c> : 10 00                      dup.x32 sp(0)
	<.main+2034 @05655e> : 13 02                      set.x32 sp(2)
	<.main+2036 @056560> : 09 fc ff ff                inc.sp(-4)
	<.main+2040 @056564> : 10 01                      dup.x32 sp(1)
	<.main+2042 @056566> : 10 01                      dup.x32 sp(1)
	<.main+2044 @056568> : 59                         cgt.i32
	<.main+2045 @056569> : 06 0a 00 00                jz <.main+2055 @056573>
	<.main+2049 @05656d> : 10 01                      dup.x32 sp(1)
	<.main+2051 @05656f> : 04 06 00 00                jmp <.main+2057 @056575>
	<.main+2055 @056573> : 10 00                      dup.x32 sp(0)
	<.main+2057 @056575> : 13 02                      set.x32 sp(2)
	<.main+2059 @056577> : 09 fc ff ff                inc.sp(-4)
	<.main+2063 @05657b> : 10 01                      dup.x32 sp(1)
	<.main+2065 @05657d> : 10 01                      dup.x32 sp(1)
	<.main+2067 @05657f> : 59                         cgt.i32
	<.main+2068 @056580> : 06 0a 00 00                jz <.main+2078 @05658a>
	<.main+2072 @056584> : 10 01                      dup.x32 sp(1)
	<.main+2074 @056586> : 04 06 00 00                jmp <.main+2080 @05658c>
	<.main+2078 @05658a> : 10 00                      dup.x32 sp(0)
	<.main+2080 @05658c> : 13 02                      set.x32 sp(2)
	<.main+2082 @05658e> : 09 fc ff ff                inc.sp(-4)
	<.main+2086 @056592> : 2e c0 49 05                store.m32 <@0549c0> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@056596> - <@0565ef>): static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+2090 @056596> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+2094 @05659a> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+2098 @05659e> : 10 01                      dup.x32 sp(1)
	<.main+2100 @0565a0> : 10 01                      dup.x32 sp(1)
	<.main+2102 @0565a2> : 59                         cgt.i32
	<.main+2103 @0565a3> : 06 0a 00 00                jz <.main+2113 @0565ad>
	<.main+2107 @0565a7> : 10 01                      dup.x32 sp(1)
	<.main+2109 @0565a9> : 04 06 00 00                jmp <.main+2115 @0565af>
	<.main+2113 @0565ad> : 10 00                      dup.x32 sp(0)
	<.main+2115 @0565af> : 13 02                      set.x32 sp(2)
	<.main+2117 @0565b1> : 09 fc ff ff                inc.sp(-4)
	<.main+2121 @0565b5> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+2125 @0565b9> : 10 01                      dup.x32 sp(1)
	<.main+2127 @0565bb> : 10 01                      dup.x32 sp(1)
	<.main+2129 @0565bd> : 59                         cgt.i32
	<.main+2130 @0565be> : 06 0a 00 00                jz <.main+2140 @0565c8>
	<.main+2134 @0565c2> : 10 01                      dup.x32 sp(1)
	<.main+2136 @0565c4> : 04 06 00 00                jmp <.main+2142 @0565ca>
	<.main+2140 @0565c8> : 10 00                      dup.x32 sp(0)
	<.main+2142 @0565ca> : 13 02                      set.x32 sp(2)
	<.main+2144 @0565cc> : 09 fc ff ff                inc.sp(-4)
	<.main+2148 @0565d0> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+2152 @0565d4> : 10 01                      dup.x32 sp(1)
	<.main+2154 @0565d6> : 10 01                      dup.x32 sp(1)
	<.main+2156 @0565d8> : 59                         cgt.i32
	<.main+2157 @0565d9> : 06 0a 00 00                jz <.main+2167 @0565e3>
	<.main+2161 @0565dd> : 10 01                      dup.x32 sp(1)
	<.main+2163 @0565df> : 04 06 00 00                jmp <.main+2169 @0565e5>
	<.main+2167 @0565e3> : 10 00                      dup.x32 sp(0)
	<.main+2169 @0565e5> : 13 02                      set.x32 sp(2)
	<.main+2171 @0565e7> : 09 fc ff ff                inc.sp(-4)
	<.main+2175 @0565eb> : 2e c8 49 05                store.m32 <@0549c8> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@0565ef> - <@05665c>): static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2179 @0565ef> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+2183 @0565f3> : 0c 01 00 00                inc.i32(+1)
	<.main+2187 @0565f7> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+2191 @0565fb> : 0c 01 00 00                inc.i32(+1)
	<.main+2195 @0565ff> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+2199 @056603> : 0c 01 00 00                inc.i32(+1)
	<.main+2203 @056607> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+2207 @05660b> : 0c 01 00 00                inc.i32(+1)
	<.main+2211 @05660f> : 10 01                      dup.x32 sp(1)
	<.main+2213 @056611> : 10 01                      dup.x32 sp(1)
	<.main+2215 @056613> : 59                         cgt.i32
	<.main+2216 @056614> : 06 0a 00 00                jz <.main+2226 @05661e>
	<.main+2220 @056618> : 10 01                      dup.x32 sp(1)
	<.main+2222 @05661a> : 04 06 00 00                jmp <.main+2228 @056620>
	<.main+2226 @05661e> : 10 00                      dup.x32 sp(0)
	<.main+2228 @056620> : 13 02                      set.x32 sp(2)
	<.main+2230 @056622> : 09 fc ff ff                inc.sp(-4)
	<.main+2234 @056626> : 10 01                      dup.x32 sp(1)
	<.main+2236 @056628> : 10 01                      dup.x32 sp(1)
	<.main+2238 @05662a> : 59                         cgt.i32
	<.main+2239 @05662b> : 06 0a 00 00                jz <.main+2249 @056635>
	<.main+2243 @05662f> : 10 01                      dup.x32 sp(1)
	<.main+2245 @056631> : 04 06 00 00                jmp <.main+2251 @056637>
	<.main+2249 @056635> : 10 00                      dup.x32 sp(0)
	<.main+2251 @056637> : 13 02                      set.x32 sp(2)
	<.main+2253 @056639> : 09 fc ff ff                inc.sp(-4)
	<.main+2257 @05663d> : 10 01                      dup.x32 sp(1)
	<.main+2259 @05663f> : 10 01                      dup.x32 sp(1)
	<.main+2261 @056641> : 59                         cgt.i32
	<.main+2262 @056642> : 06 0a 00 00                jz <.main+2272 @05664c>
	<.main+2266 @056646> : 10 01                      dup.x32 sp(1)
	<.main+2268 @056648> : 04 06 00 00                jmp <.main+2274 @05664e>
	<.main+2272 @05664c> : 10 00                      dup.x32 sp(0)
	<.main+2274 @05664e> : 13 02                      set.x32 sp(2)
	<.main+2276 @056650> : 09 fc ff ff                inc.sp(-4)
	<.main+2280 @056654> : 0c ff ff ff                inc.i32(-1)
	<.main+2284 @056658> : 2e d0 49 05                store.m32 <@0549d0> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@05665c> - <@0566c9>): static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2288 @05665c> : 2a 70 48 05                load.m32 <@054870> ;i3
	<.main+2292 @056660> : 0c 01 00 00                inc.i32(+1)
	<.main+2296 @056664> : 2a 78 48 05                load.m32 <@054878> ;i6
	<.main+2300 @056668> : 0c 01 00 00                inc.i32(+1)
	<.main+2304 @05666c> : 10 01                      dup.x32 sp(1)
	<.main+2306 @05666e> : 10 01                      dup.x32 sp(1)
	<.main+2308 @056670> : 59                         cgt.i32
	<.main+2309 @056671> : 06 0a 00 00                jz <.main+2319 @05667b>
	<.main+2313 @056675> : 10 01                      dup.x32 sp(1)
	<.main+2315 @056677> : 04 06 00 00                jmp <.main+2321 @05667d>
	<.main+2319 @05667b> : 10 00                      dup.x32 sp(0)
	<.main+2321 @05667d> : 13 02                      set.x32 sp(2)
	<.main+2323 @05667f> : 09 fc ff ff                inc.sp(-4)
	<.main+2327 @056683> : 2a 80 48 05                load.m32 <@054880> ;i2
	<.main+2331 @056687> : 0c 01 00 00                inc.i32(+1)
	<.main+2335 @05668b> : 10 01                      dup.x32 sp(1)
	<.main+2337 @05668d> : 10 01                      dup.x32 sp(1)
	<.main+2339 @05668f> : 59                         cgt.i32
	<.main+2340 @056690> : 06 0a 00 00                jz <.main+2350 @05669a>
	<.main+2344 @056694> : 10 01                      dup.x32 sp(1)
	<.main+2346 @056696> : 04 06 00 00                jmp <.main+2352 @05669c>
	<.main+2350 @05669a> : 10 00                      dup.x32 sp(0)
	<.main+2352 @05669c> : 13 02                      set.x32 sp(2)
	<.main+2354 @05669e> : 09 fc ff ff                inc.sp(-4)
	<.main+2358 @0566a2> : 2a 88 48 05                load.m32 <@054888> ;i8
	<.main+2362 @0566a6> : 0c 01 00 00                inc.i32(+1)
	<.main+2366 @0566aa> : 10 01                      dup.x32 sp(1)
	<.main+2368 @0566ac> : 10 01                      dup.x32 sp(1)
	<.main+2370 @0566ae> : 59                         cgt.i32
	<.main+2371 @0566af> : 06 0a 00 00                jz <.main+2381 @0566b9>
	<.main+2375 @0566b3> : 10 01                      dup.x32 sp(1)
	<.main+2377 @0566b5> : 04 06 00 00                jmp <.main+2383 @0566bb>
	<.main+2381 @0566b9> : 10 00                      dup.x32 sp(0)
	<.main+2383 @0566bb> : 13 02                      set.x32 sp(2)
	<.main+2385 @0566bd> : 09 fc ff ff                inc.sp(-4)
	<.main+2389 @0566c1> : 0c ff ff ff                inc.i32(-1)
	<.main+2393 @0566c5> : 2e d8 49 05                store.m32 <@0549d8> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@0566c9> - <@0566d2>): static overload1: float32 := overload
	<.main+2397 @0566c9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2402 @0566ce> : 2e e0 49 05                store.m32 <@0549e0> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@0566d2> - <@0566db>): static overload2: float32 := overload()
	<.main+2406 @0566d2> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2411 @0566d7> : 2e e8 49 05                store.m32 <@0549e8> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@0566db> - <@0566e4>): static overload3: float32 := overload(0)
	<.main+2415 @0566db> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2420 @0566e0> : 2e f0 49 05                store.m32 <@0549f0> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@0566e4> - <@0566ed>): static overload4: float32 := overload(0.000000)
	<.main+2424 @0566e4> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2429 @0566e9> : 2e f8 49 05                store.m32 <@0549f8> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@0566ed> - <@0566f6>): static overload5: float32 := overload(void(0, 0))
	<.main+2433 @0566ed> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2438 @0566f2> : 2e 00 4a 05                store.m32 <@054a00> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@0566f6> - <@056703>): static boilC: Celsius := Celsius(100.000000)
	<.main+2442 @0566f6> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2451 @0566ff> : 2d 08 4a 05                store.m64 <@054a08> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@056703> - <@05671f>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2455 @056703> : 2b 08 4a 05                load.m64 <@054a08> ;boilC
	<.main+2459 @056707> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2468 @056710> : 83                         mul.f64
	<.main+2469 @056711> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2478 @05671a> : 81                         add.f64
	<.main+2479 @05671b> : 2d 10 4a 05                store.m64 <@054a10> ;boilF
	test/lang/initByRef.ci:7: (13 bytes: <@05671f> - <@05672c>): static value: int64 := 42
	<.main+2483 @05671f> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+2492 @056728> : 2d 18 4a 05                store.m64 <@054a18> ;value
	test/lang/initByRef.ci:8: (9 bytes: <@05672c> - <@056735>): static valueRef: int64 := value
	<.main+2496 @05672c> : 1f 18 4a 05 00             load.ref <@054a18> ;value
	<.main+2501 @056731> : 2e 20 4a 05                store.m32 <@054a20> ;valueRef
	test/lang/initByRef.ci:9: (9 bytes: <@056735> - <@05673e>): static valuePtr: pointer := value
	<.main+2505 @056735> : 1f 18 4a 05 00             load.ref <@054a18> ;value
	<.main+2510 @05673a> : 2e 28 4a 05                store.m32 <@054a28> ;valuePtr
	test/lang/initByRef.ci:10: (14 bytes: <@05673e> - <@05674c>): static valueVar: variant := value
	<.main+2514 @05673e> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2519 @056743> : 1f 18 4a 05 00             load.ref <@054a18> ;value
	<.main+2524 @056748> : 2d 30 4a 05                store.m64 <@054a30> ;valueVar
	test/lang/initByRef.ci:12: (9 bytes: <@05674c> - <@056755>): static fromRef: int64 := valueRef
	<.main+2528 @05674c> : 2a 20 4a 05                load.m32 <@054a20> ;valueRef
	<.main+2532 @056750> : 23                         load.i64
	<.main+2533 @056751> : 2d 38 4a 05                store.m64 <@054a38> ;fromRef
	test/lang/initByRef.ci:13: (8 bytes: <@056755> - <@05675d>): static fromPtr: int64 := valuePtr
	<.main+2537 @056755> : 2a 28 4a 05                load.m32 <@054a28> ;valuePtr
	<.main+2541 @056759> : 2e 40 4a 05                store.m32 <@054a40> ;fromPtr
	test/lang/initByRef.ci:14: (8 bytes: <@05675d> - <@056765>): static fromVar: int64 := valueVar
	<.main+2545 @05675d> : 2a 30 4a 05                load.m32 <@054a30> ;valueVar
	<.main+2549 @056761> : 2e 48 4a 05                store.m32 <@054a48> ;fromVar
	test/lang/initByRef.ci:16: (9 bytes: <@056765> - <@05676e>): static nullRef: int64 := null
	<.main+2553 @056765> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2558 @05676a> : 2e 50 4a 05                store.m32 <@054a50> ;nullRef
	test/lang/initByRef.ci:17: (9 bytes: <@05676e> - <@056777>): static nullPtr: pointer := null
	<.main+2562 @05676e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2567 @056773> : 2e 58 4a 05                store.m32 <@054a58> ;nullPtr
	test/lang/initByRef.ci:18: (14 bytes: <@056777> - <@056785>): static nullVar: variant := null
	<.main+2571 @056777> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2576 @05677c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2581 @056781> : 2d 60 4a 05                store.m64 <@054a60> ;nullVar
	test/lang/initByRef.ci:19: (9 bytes: <@056785> - <@05678e>): static nullTyp: typename := null
	<.main+2585 @056785> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2590 @05678a> : 2e 68 4a 05                store.m32 <@054a68> ;nullTyp
	test/lang/initByRef.ci:20: (9 bytes: <@05678e> - <@056797>): static nullFun: function := null
	<.main+2594 @05678e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2599 @056793> : 2e 70 4a 05                store.m32 <@054a70> ;nullFun
	test/lang/initByRef.ci:21: (9 bytes: <@056797> - <@0567a0>): static nullObj: object := null
	<.main+2603 @056797> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2608 @05679c> : 2e 78 4a 05                store.m32 <@054a78> ;nullObj
	test/lang/initByRef.ci:23: (9 bytes: <@0567a0> - <@0567a9>): static typePtr: pointer := int64
	<.main+2612 @0567a0> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2617 @0567a5> : 2e 80 4a 05                store.m32 <@054a80> ;typePtr
	test/lang/initByRef.ci:24: (14 bytes: <@0567a9> - <@0567b7>): static typeVar: variant := int64
	<.main+2621 @0567a9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2626 @0567ae> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2631 @0567b3> : 2d 88 4a 05                store.m64 <@054a88> ;typeVar
	test/lang/initByRef.ci:25: (9 bytes: <@0567b7> - <@0567c0>): static typeTyp: typename := int64
	<.main+2635 @0567b7> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2640 @0567bc> : 2e 90 4a 05                store.m32 <@054a90> ;typeTyp
	test/lang/initByRef.ci:27: (8 bytes: <@0567c0> - <@0567c8>): static local: int64 := value
	<.main+2644 @0567c0> : 2b 18 4a 05                load.m64 <@054a18> ;value
	<.main+2648 @0567c4> : 2d 98 4a 05                store.m64 <@054a98> ;local
	test/lang/initByRef.ci:28: (8 bytes: <@0567c8> - <@0567d0>): static copyVal: int64 := local
	<.main+2652 @0567c8> : 2b 98 4a 05                load.m64 <@054a98> ;local
	<.main+2656 @0567cc> : 2d a0 4a 05                store.m64 <@054aa0> ;copyVal
	test/lang/initByRef.ci:29: (8 bytes: <@0567d0> - <@0567d8>): static copyRef: int64 := valueRef
	<.main+2660 @0567d0> : 2a 20 4a 05                load.m32 <@054a20> ;valueRef
	<.main+2664 @0567d4> : 2e a8 4a 05                store.m32 <@054aa8> ;copyRef
	test/lang/initByRef.ci:30: (8 bytes: <@0567d8> - <@0567e0>): static copyPtr: pointer := valuePtr
	<.main+2668 @0567d8> : 2a 28 4a 05                load.m32 <@054a28> ;valuePtr
	<.main+2672 @0567dc> : 2e b0 4a 05                store.m32 <@054ab0> ;copyPtr
	test/lang/initByRef.ci:31: (8 bytes: <@0567e0> - <@0567e8>): static copyVar: variant := valueVar
	<.main+2676 @0567e0> : 2b 30 4a 05                load.m64 <@054a30> ;valueVar
	<.main+2680 @0567e4> : 2d b8 4a 05                store.m64 <@054ab8> ;copyVar
	test/lang/initByRef.ci:32: (8 bytes: <@0567e8> - <@0567f0>): static copyTyp: typename := typeTyp
	<.main+2684 @0567e8> : 2a 90 4a 05                load.m32 <@054a90> ;typeTyp
	<.main+2688 @0567ec> : 2e c0 4a 05                store.m32 <@054ac0> ;copyTyp
	test/lang/initByRef.ci:35: (9 bytes: <@0567f0> - <@0567f9>): static ptrVoid: pointer := void
	<.main+2692 @0567f0> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2697 @0567f5> : 2e c8 4a 05                store.m32 <@054ac8> ;ptrVoid
	test/lang/initByRef.ci:36: (9 bytes: <@0567f9> - <@056802>): static ptrBool: pointer := bool
	<.main+2701 @0567f9> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2706 @0567fe> : 2e d0 4a 05                store.m32 <@054ad0> ;ptrBool
	test/lang/initByRef.ci:37: (9 bytes: <@056802> - <@05680b>): static ptrChar: pointer := char
	<.main+2710 @056802> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2715 @056807> : 2e d8 4a 05                store.m32 <@054ad8> ;ptrChar
	test/lang/initByRef.ci:38: (9 bytes: <@05680b> - <@056814>): static ptrInt8: pointer := int8
	<.main+2719 @05680b> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2724 @056810> : 2e e0 4a 05                store.m32 <@054ae0> ;ptrInt8
	test/lang/initByRef.ci:39: (9 bytes: <@056814> - <@05681d>): static ptrInt16: pointer := int16
	<.main+2728 @056814> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2733 @056819> : 2e e8 4a 05                store.m32 <@054ae8> ;ptrInt16
	test/lang/initByRef.ci:40: (9 bytes: <@05681d> - <@056826>): static ptrInt32: pointer := int32
	<.main+2737 @05681d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2742 @056822> : 2e f0 4a 05                store.m32 <@054af0> ;ptrInt32
	test/lang/initByRef.ci:41: (9 bytes: <@056826> - <@05682f>): static ptrInt64: pointer := int64
	<.main+2746 @056826> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2751 @05682b> : 2e f8 4a 05                store.m32 <@054af8> ;ptrInt64
	test/lang/initByRef.ci:42: (9 bytes: <@05682f> - <@056838>): static ptrUint8: pointer := uint8
	<.main+2755 @05682f> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2760 @056834> : 2e 00 4b 05                store.m32 <@054b00> ;ptrUint8
	test/lang/initByRef.ci:43: (9 bytes: <@056838> - <@056841>): static ptrUint16: pointer := uint16
	<.main+2764 @056838> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2769 @05683d> : 2e 08 4b 05                store.m32 <@054b08> ;ptrUint16
	test/lang/initByRef.ci:44: (9 bytes: <@056841> - <@05684a>): static ptrUint32: pointer := uint32
	<.main+2773 @056841> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2778 @056846> : 2e 10 4b 05                store.m32 <@054b10> ;ptrUint32
	test/lang/initByRef.ci:45: (9 bytes: <@05684a> - <@056853>): static ptrUint64: pointer := uint64
	<.main+2782 @05684a> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+2787 @05684f> : 2e 18 4b 05                store.m32 <@054b18> ;ptrUint64
	test/lang/initByRef.ci:46: (9 bytes: <@056853> - <@05685c>): static ptrFloat32: pointer := float32
	<.main+2791 @056853> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+2796 @056858> : 2e 20 4b 05                store.m32 <@054b20> ;ptrFloat32
	test/lang/initByRef.ci:47: (9 bytes: <@05685c> - <@056865>): static ptrFloat64: pointer := float64
	<.main+2800 @05685c> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+2805 @056861> : 2e 28 4b 05                store.m32 <@054b28> ;ptrFloat64
	test/lang/initByRef.ci:48: (9 bytes: <@056865> - <@05686e>): static ptrTypename: pointer := typename
	<.main+2809 @056865> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2814 @05686a> : 2e 30 4b 05                store.m32 <@054b30> ;ptrTypename
	test/lang/initByRef.ci:49: (9 bytes: <@05686e> - <@056877>): static ptrFunction: pointer := function
	<.main+2818 @05686e> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+2823 @056873> : 2e 38 4b 05                store.m32 <@054b38> ;ptrFunction
	test/lang/initByRef.ci:50: (9 bytes: <@056877> - <@056880>): static ptrPointer: pointer := pointer
	<.main+2827 @056877> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2832 @05687c> : 2e 40 4b 05                store.m32 <@054b40> ;ptrPointer
	test/lang/initByRef.ci:51: (9 bytes: <@056880> - <@056889>): static ptrVariant: pointer := variant
	<.main+2836 @056880> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+2841 @056885> : 2e 48 4b 05                store.m32 <@054b48> ;ptrVariant
	test/lang/initByRef.ci:52: (9 bytes: <@056889> - <@056892>): static ptrObject: pointer := object
	<.main+2845 @056889> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+2850 @05688e> : 2e 50 4b 05                store.m32 <@054b50> ;ptrObject
	test/lang/initByRef.ci:55: (14 bytes: <@056892> - <@0568a0>): static varVoid: variant := void
	<.main+2854 @056892> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2859 @056897> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2864 @05689c> : 2d 58 4b 05                store.m64 <@054b58> ;varVoid
	test/lang/initByRef.ci:56: (14 bytes: <@0568a0> - <@0568ae>): static varBool: variant := bool
	<.main+2868 @0568a0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2873 @0568a5> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2878 @0568aa> : 2d 60 4b 05                store.m64 <@054b60> ;varBool
	test/lang/initByRef.ci:57: (14 bytes: <@0568ae> - <@0568bc>): static varChar: variant := char
	<.main+2882 @0568ae> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2887 @0568b3> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2892 @0568b8> : 2d 68 4b 05                store.m64 <@054b68> ;varChar
	test/lang/initByRef.ci:58: (14 bytes: <@0568bc> - <@0568ca>): static varInt8: variant := int8
	<.main+2896 @0568bc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2901 @0568c1> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2906 @0568c6> : 2d 70 4b 05                store.m64 <@054b70> ;varInt8
	test/lang/initByRef.ci:59: (14 bytes: <@0568ca> - <@0568d8>): static varInt16: variant := int16
	<.main+2910 @0568ca> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2915 @0568cf> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2920 @0568d4> : 2d 78 4b 05                store.m64 <@054b78> ;varInt16
	test/lang/initByRef.ci:60: (14 bytes: <@0568d8> - <@0568e6>): static varInt32: variant := int32
	<.main+2924 @0568d8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2929 @0568dd> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2934 @0568e2> : 2d 80 4b 05                store.m64 <@054b80> ;varInt32
	test/lang/initByRef.ci:61: (14 bytes: <@0568e6> - <@0568f4>): static varInt64: variant := int64
	<.main+2938 @0568e6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2943 @0568eb> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2948 @0568f0> : 2d 88 4b 05                store.m64 <@054b88> ;varInt64
	test/lang/initByRef.ci:62: (14 bytes: <@0568f4> - <@056902>): static varUint8: variant := uint8
	<.main+2952 @0568f4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2957 @0568f9> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2962 @0568fe> : 2d 90 4b 05                store.m64 <@054b90> ;varUint8
	test/lang/initByRef.ci:63: (14 bytes: <@056902> - <@056910>): static varUint16: variant := uint16
	<.main+2966 @056902> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2971 @056907> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2976 @05690c> : 2d 98 4b 05                store.m64 <@054b98> ;varUint16
	test/lang/initByRef.ci:64: (14 bytes: <@056910> - <@05691e>): static varUint32: variant := uint32
	<.main+2980 @056910> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2985 @056915> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2990 @05691a> : 2d a0 4b 05                store.m64 <@054ba0> ;varUint32
	test/lang/initByRef.ci:65: (14 bytes: <@05691e> - <@05692c>): static varUint64: variant := uint64
	<.main+2994 @05691e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2999 @056923> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3004 @056928> : 2d a8 4b 05                store.m64 <@054ba8> ;varUint64
	test/lang/initByRef.ci:66: (14 bytes: <@05692c> - <@05693a>): static varFloat32: variant := float32
	<.main+3008 @05692c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3013 @056931> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3018 @056936> : 2d b0 4b 05                store.m64 <@054bb0> ;varFloat32
	test/lang/initByRef.ci:67: (14 bytes: <@05693a> - <@056948>): static varFloat64: variant := float64
	<.main+3022 @05693a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3027 @05693f> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3032 @056944> : 2d b8 4b 05                store.m64 <@054bb8> ;varFloat64
	test/lang/initByRef.ci:68: (14 bytes: <@056948> - <@056956>): static varTypename: variant := typename
	<.main+3036 @056948> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3041 @05694d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3046 @056952> : 2d c0 4b 05                store.m64 <@054bc0> ;varTypename
	test/lang/initByRef.ci:69: (14 bytes: <@056956> - <@056964>): static varFunction: variant := function
	<.main+3050 @056956> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3055 @05695b> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3060 @056960> : 2d c8 4b 05                store.m64 <@054bc8> ;varFunction
	test/lang/initByRef.ci:70: (14 bytes: <@056964> - <@056972>): static varPointer: variant := pointer
	<.main+3064 @056964> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3069 @056969> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3074 @05696e> : 2d d0 4b 05                store.m64 <@054bd0> ;varPointer
	test/lang/initByRef.ci:71: (14 bytes: <@056972> - <@056980>): static varVariant: variant := variant
	<.main+3078 @056972> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3083 @056977> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3088 @05697c> : 2d d8 4b 05                store.m64 <@054bd8> ;varVariant
	test/lang/initByRef.ci:72: (14 bytes: <@056980> - <@05698e>): static varObject: variant := object
	<.main+3092 @056980> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3097 @056985> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3102 @05698a> : 2d e0 4b 05                store.m64 <@054be0> ;varObject
	test/lang/initByRef.ci:75: (9 bytes: <@05698e> - <@056997>): static typVoid: typename := void
	<.main+3106 @05698e> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3111 @056993> : 2e e8 4b 05                store.m32 <@054be8> ;typVoid
	test/lang/initByRef.ci:76: (9 bytes: <@056997> - <@0569a0>): static typBool: typename := bool
	<.main+3115 @056997> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3120 @05699c> : 2e f0 4b 05                store.m32 <@054bf0> ;typBool
	test/lang/initByRef.ci:77: (9 bytes: <@0569a0> - <@0569a9>): static typChar: typename := char
	<.main+3124 @0569a0> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3129 @0569a5> : 2e f8 4b 05                store.m32 <@054bf8> ;typChar
	test/lang/initByRef.ci:78: (9 bytes: <@0569a9> - <@0569b2>): static typInt8: typename := int8
	<.main+3133 @0569a9> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3138 @0569ae> : 2e 00 4c 05                store.m32 <@054c00> ;typInt8
	test/lang/initByRef.ci:79: (9 bytes: <@0569b2> - <@0569bb>): static typInt16: typename := int16
	<.main+3142 @0569b2> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3147 @0569b7> : 2e 08 4c 05                store.m32 <@054c08> ;typInt16
	test/lang/initByRef.ci:80: (9 bytes: <@0569bb> - <@0569c4>): static typInt32: typename := int32
	<.main+3151 @0569bb> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3156 @0569c0> : 2e 10 4c 05                store.m32 <@054c10> ;typInt32
	test/lang/initByRef.ci:81: (9 bytes: <@0569c4> - <@0569cd>): static typInt64: typename := int64
	<.main+3160 @0569c4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3165 @0569c9> : 2e 18 4c 05                store.m32 <@054c18> ;typInt64
	test/lang/initByRef.ci:82: (9 bytes: <@0569cd> - <@0569d6>): static typUint8: typename := uint8
	<.main+3169 @0569cd> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3174 @0569d2> : 2e 20 4c 05                store.m32 <@054c20> ;typUint8
	test/lang/initByRef.ci:83: (9 bytes: <@0569d6> - <@0569df>): static typUint16: typename := uint16
	<.main+3178 @0569d6> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3183 @0569db> : 2e 28 4c 05                store.m32 <@054c28> ;typUint16
	test/lang/initByRef.ci:84: (9 bytes: <@0569df> - <@0569e8>): static typUint32: typename := uint32
	<.main+3187 @0569df> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3192 @0569e4> : 2e 30 4c 05                store.m32 <@054c30> ;typUint32
	test/lang/initByRef.ci:85: (9 bytes: <@0569e8> - <@0569f1>): static typUint64: typename := uint64
	<.main+3196 @0569e8> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3201 @0569ed> : 2e 38 4c 05                store.m32 <@054c38> ;typUint64
	test/lang/initByRef.ci:86: (9 bytes: <@0569f1> - <@0569fa>): static typFloat32: typename := float32
	<.main+3205 @0569f1> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3210 @0569f6> : 2e 40 4c 05                store.m32 <@054c40> ;typFloat32
	test/lang/initByRef.ci:87: (9 bytes: <@0569fa> - <@056a03>): static typFloat64: typename := float64
	<.main+3214 @0569fa> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3219 @0569ff> : 2e 48 4c 05                store.m32 <@054c48> ;typFloat64
	test/lang/initByRef.ci:88: (9 bytes: <@056a03> - <@056a0c>): static typTypename: typename := typename
	<.main+3223 @056a03> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3228 @056a08> : 2e 50 4c 05                store.m32 <@054c50> ;typTypename
	test/lang/initByRef.ci:89: (9 bytes: <@056a0c> - <@056a15>): static typFunction: typename := function
	<.main+3232 @056a0c> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3237 @056a11> : 2e 58 4c 05                store.m32 <@054c58> ;typFunction
	test/lang/initByRef.ci:90: (9 bytes: <@056a15> - <@056a1e>): static typPointer: typename := pointer
	<.main+3241 @056a15> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3246 @056a1a> : 2e 60 4c 05                store.m32 <@054c60> ;typPointer
	test/lang/initByRef.ci:91: (9 bytes: <@056a1e> - <@056a27>): static typVariant: typename := variant
	<.main+3250 @056a1e> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3255 @056a23> : 2e 68 4c 05                store.m32 <@054c68> ;typVariant
	test/lang/initByRef.ci:92: (9 bytes: <@056a27> - <@056a30>): static typObject: typename := object
	<.main+3259 @056a27> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3264 @056a2c> : 2e 70 4c 05                store.m32 <@054c70> ;typObject
	test/lang/initByRef.ci:95: (9 bytes: <@056a30> - <@056a39>): static valueOfPtr: pointer := pointer(value)
	<.main+3268 @056a30> : 1f 18 4a 05 00             load.ref <@054a18> ;value
	<.main+3273 @056a35> : 2e 78 4c 05                store.m32 <@054c78> ;valueOfPtr
	test/lang/initByRef.ci:96: (14 bytes: <@056a39> - <@056a47>): static valueOfVar: variant := variant(value)
	<.main+3277 @056a39> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3282 @056a3e> : 1f 18 4a 05 00             load.ref <@054a18> ;value
	<.main+3287 @056a43> : 2d 80 4c 05                store.m64 <@054c80> ;valueOfVar
	test/lang/initByRef.ci:97: (9 bytes: <@056a47> - <@056a50>): static valueOfTyp: typename := typename(value)
	<.main+3291 @056a47> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3296 @056a4c> : 2e 88 4c 05                store.m32 <@054c88> ;valueOfTyp
	test/lang/initByRef.ci:99: (9 bytes: <@056a50> - <@056a59>): static typeOfValue: typename := typename(value)
	<.main+3300 @056a50> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3305 @056a55> : 2e 90 4c 05                store.m32 <@054c90> ;typeOfValue
	test/lang/initByRef.ci:105: (13 bytes: <@056a59> - <@056a66>): static copyPtrFloat64: variant := ptrFloat64
	<.main+3309 @056a59> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3314 @056a5e> : 2a 28 4b 05                load.m32 <@054b28> ;ptrFloat64
	<.main+3318 @056a62> : 2d 98 4c 05                store.m64 <@054c98> ;copyPtrFloat64
	test/lang/initByRef.ci:108: (8 bytes: <@056a66> - <@056a6e>): static copyVarFloat64: pointer := varFloat64
	<.main+3322 @056a66> : 2a b8 4b 05                load.m32 <@054bb8> ;varFloat64
	<.main+3326 @056a6a> : 2e a0 4c 05                store.m32 <@054ca0> ;copyVarFloat64
	test/lang/function.ci:12: (25 bytes: <@056a6e> - <@056a87>): static funAddResult: int32 := funAdd(void(2, 7))
	<.main+3330 @056a6e> : 19                         load.z32
	<.main+3331 @056a6f> : 1c 02 00 00 00             load.c32 2
	<.main+3336 @056a74> : 1c 07 00 00 00             load.c32 7
	<.main+3341 @056a79> : 1f b0 4c 05 00             load.ref <@054cb0> ;funAdd(x: int32, y: int32): int32
	<.main+3346 @056a7e> : 02                         call
	<.main+3347 @056a7f> : 09 f8 ff ff                inc.sp(-8)
	<.main+3351 @056a83> : 2e b8 4c 05                store.m32 <@054cb8> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@056a87> - <@056a90>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+3355 @056a87> : 1f b0 4c 05 00             load.ref <@054cb0> ;funAdd(x: int32, y: int32): int32
	<.main+3360 @056a8c> : 2e c0 4c 05                store.m32 <@054cc0> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@056a90> - <@056aa8>): static funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+3364 @056a90> : 19                         load.z32
	<.main+3365 @056a91> : 1c 02 00 00 00             load.c32 2
	<.main+3370 @056a96> : 1c 08 00 00 00             load.c32 8
	<.main+3375 @056a9b> : 2a c0 4c 05                load.m32 <@054cc0> ;funAddRef(x: int32, y: int32): int32
	<.main+3379 @056a9f> : 02                         call
	<.main+3380 @056aa0> : 09 f8 ff ff                inc.sp(-8)
	<.main+3384 @056aa4> : 2e c8 4c 05                store.m32 <@054cc8> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@056aa8> - <@056ab1>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+3388 @056aa8> : 1f f0 4c 05 00             load.ref <@054cf0> ;funMul(x: int32, y: int32): int32
	<.main+3393 @056aad> : 2e d0 4c 05                store.m32 <@054cd0> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@056ab1> - <@056ac9>): static funMulResult: int32 := funMul(void(2, 6))
	<.main+3397 @056ab1> : 19                         load.z32
	<.main+3398 @056ab2> : 1c 02 00 00 00             load.c32 2
	<.main+3403 @056ab7> : 1c 06 00 00 00             load.c32 6
	<.main+3408 @056abc> : 2a d0 4c 05                load.m32 <@054cd0> ;funMul(x: int32, y: int32): int32
	<.main+3412 @056ac0> : 02                         call
	<.main+3413 @056ac1> : 09 f8 ff ff                inc.sp(-8)
	<.main+3417 @056ac5> : 2e d8 4c 05                store.m32 <@054cd8> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@056ac9> - <@056ad1>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+3421 @056ac9> : 2a d0 4c 05                load.m32 <@054cd0> ;funMul(x: int32, y: int32): int32
	<.main+3425 @056acd> : 2e e0 4c 05                store.m32 <@054ce0> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@056ad1> - <@056ae9>): static funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+3429 @056ad1> : 19                         load.z32
	<.main+3430 @056ad2> : 1c 02 00 00 00             load.c32 2
	<.main+3435 @056ad7> : 1c 07 00 00 00             load.c32 7
	<.main+3440 @056adc> : 2a e0 4c 05                load.m32 <@054ce0> ;funMulRef(x: int32, y: int32): int32
	<.main+3444 @056ae0> : 02                         call
	<.main+3445 @056ae1> : 09 f8 ff ff                inc.sp(-8)
	<.main+3449 @056ae5> : 2e e8 4c 05                store.m32 <@054ce8> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@056ae9> - <@056afd>): static fibonacci_13: uint32 := fib(13)
	<.main+3453 @056ae9> : 19                         load.z32
	<.main+3454 @056aea> : 1c 0d 00 00 00             load.c32 13
	<.main+3459 @056aef> : 1f f8 4c 05 00             load.ref <@054cf8> ;fib(n: uint32): uint32
	<.main+3464 @056af4> : 02                         call
	<.main+3465 @056af5> : 09 fc ff ff                inc.sp(-4)
	<.main+3469 @056af9> : 2e 30 4d 05                store.m32 <@054d30> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@056afd> - <@056b05>): static sizeofVoid: int32 := sizeof(void)
	<.main+3473 @056afd> : 2a d0 00 00                load.m32 <@0000d0>
	<.main+3477 @056b01> : 2e 38 4d 05                store.m32 <@054d38> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@056b05> - <@056b0d>): static sizeofBool: int32 := sizeof(bool)
	<.main+3481 @056b05> : 2a 70 01 00                load.m32 <@000170>
	<.main+3485 @056b09> : 2e 40 4d 05                store.m32 <@054d40> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@056b0d> - <@056b15>): static sizeofChar: int32 := sizeof(char)
	<.main+3489 @056b0d> : 2a 10 02 00                load.m32 <@000210>
	<.main+3493 @056b11> : 2e 48 4d 05                store.m32 <@054d48> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@056b15> - <@056b1d>): static sizeofInt8: int32 := sizeof(int8)
	<.main+3497 @056b15> : 2a b0 02 00                load.m32 <@0002b0>
	<.main+3501 @056b19> : 2e 50 4d 05                store.m32 <@054d50> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@056b1d> - <@056b25>): static sizeofInt16: int32 := sizeof(int16)
	<.main+3505 @056b1d> : 2a 50 03 00                load.m32 <@000350>
	<.main+3509 @056b21> : 2e 58 4d 05                store.m32 <@054d58> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@056b25> - <@056b2d>): static sizeofInt32: int32 := sizeof(int32)
	<.main+3513 @056b25> : 2a f0 03 00                load.m32 <@0003f0>
	<.main+3517 @056b29> : 2e 60 4d 05                store.m32 <@054d60> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@056b2d> - <@056b35>): static sizeofInt64: int32 := sizeof(int64)
	<.main+3521 @056b2d> : 2a 90 04 00                load.m32 <@000490>
	<.main+3525 @056b31> : 2e 68 4d 05                store.m32 <@054d68> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@056b35> - <@056b3d>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+3529 @056b35> : 2a 30 05 00                load.m32 <@000530>
	<.main+3533 @056b39> : 2e 70 4d 05                store.m32 <@054d70> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@056b3d> - <@056b45>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+3537 @056b3d> : 2a d0 05 00                load.m32 <@0005d0>
	<.main+3541 @056b41> : 2e 78 4d 05                store.m32 <@054d78> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@056b45> - <@056b4d>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+3545 @056b45> : 2a 70 06 00                load.m32 <@000670>
	<.main+3549 @056b49> : 2e 80 4d 05                store.m32 <@054d80> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@056b4d> - <@056b55>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+3553 @056b4d> : 2a 10 07 00                load.m32 <@000710>
	<.main+3557 @056b51> : 2e 88 4d 05                store.m32 <@054d88> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@056b55> - <@056b5d>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+3561 @056b55> : 2a b0 07 00                load.m32 <@0007b0>
	<.main+3565 @056b59> : 2e 90 4d 05                store.m32 <@054d90> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@056b5d> - <@056b65>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+3569 @056b5d> : 2a 50 08 00                load.m32 <@000850>
	<.main+3573 @056b61> : 2e 98 4d 05                store.m32 <@054d98> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@056b65> - <@056b6d>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+3577 @056b65> : 2a f0 08 00                load.m32 <@0008f0>
	<.main+3581 @056b69> : 2e a0 4d 05                store.m32 <@054da0> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@056b6d> - <@056b75>): static sizeofVariant: int32 := sizeof(variant)
	<.main+3585 @056b6d> : 2a 90 09 00                load.m32 <@000990>
	<.main+3589 @056b71> : 2e a8 4d 05                store.m32 <@054da8> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@056b75> - <@056b7d>): static sizeofTypename: int32 := sizeof(typename)
	<.main+3593 @056b75> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	<.main+3597 @056b79> : 2e b0 4d 05                store.m32 <@054db0> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@056b7d> - <@056b85>): static sizeofFunction: int32 := sizeof(function)
	<.main+3601 @056b7d> : 2a 30 0a 00                load.m32 <@000a30>
	<.main+3605 @056b81> : 2e b8 4d 05                store.m32 <@054db8> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@056b85> - <@056b8d>): static sizeofObject: int32 := sizeof(object)
	<.main+3609 @056b85> : 2a d8 0a 00                load.m32 <@000ad8>
	<.main+3613 @056b89> : 2e c0 4d 05                store.m32 <@054dc0> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@056b8d> - <@056b96>): static typeofRecord: typename := RecordSizeofExt
	<.main+3617 @056b8d> : 1f 78 a2 03 00             load.ref <@03a278> ;RecordSizeofExt
	<.main+3622 @056b92> : 2e c8 4d 05                store.m32 <@054dc8> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@056b96> - <@056ba2>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+3626 @056b96> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3630 @056b9a> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3634 @056b9e> : 2e d0 4d 05                store.m32 <@054dd0> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@056ba2> - <@056baf>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+3638 @056ba2> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3642 @056ba6> : 0c 28 00 00                inc.i32(+40)
	<.main+3646 @056baa> : 22                         load.i32
	<.main+3647 @056bab> : 2e d8 4d 05                store.m32 <@054dd8> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@056baf> - <@056bbc>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+3651 @056baf> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3655 @056bb3> : 0c 20 00 00                inc.i32(+32)
	<.main+3659 @056bb7> : 22                         load.i32
	<.main+3660 @056bb8> : 2e e0 4d 05                store.m32 <@054de0> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@056bbc> - <@056bc8>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+3664 @056bbc> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3668 @056bc0> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3672 @056bc4> : 2e e8 4d 05                store.m32 <@054de8> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@056bc8> - <@056bd4>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+3676 @056bc8> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3680 @056bcc> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3684 @056bd0> : 2e f0 4d 05                store.m32 <@054df0> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@056bd4> - <@056be0>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+3688 @056bd4> : 2a c8 4d 05                load.m32 <@054dc8> ;typeofRecord
	<.main+3692 @056bd8> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3696 @056bdc> : 2e f8 4d 05                store.m32 <@054df8> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@056be0> - <@056bec>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+3700 @056be0> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3704 @056be4> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3708 @056be8> : 2e 00 4e 05                store.m32 <@054e00> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@056bec> - <@056bf9>): static offsetOfBase: int32 := typeofBase.offset
	<.main+3712 @056bec> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3716 @056bf0> : 0c 28 00 00                inc.i32(+40)
	<.main+3720 @056bf4> : 22                         load.i32
	<.main+3721 @056bf5> : 2e 08 4e 05                store.m32 <@054e08> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@056bf9> - <@056c06>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+3725 @056bf9> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3729 @056bfd> : 0c 20 00 00                inc.i32(+32)
	<.main+3733 @056c01> : 22                         load.i32
	<.main+3734 @056c02> : 2e 10 4e 05                store.m32 <@054e10> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@056c06> - <@056c12>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+3738 @056c06> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3742 @056c0a> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3746 @056c0e> : 2e 18 4e 05                store.m32 <@054e18> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@056c12> - <@056c1e>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+3750 @056c12> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3754 @056c16> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3758 @056c1a> : 2e 20 4e 05                store.m32 <@054e20> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@056c1e> - <@056c2a>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+3762 @056c1e> : 2a f8 4d 05                load.m32 <@054df8> ;typeofBase
	<.main+3766 @056c22> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3770 @056c26> : 2e 28 4e 05                store.m32 <@054e28> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@056c2a> - <@056c37>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+3774 @056c2a> : 2a 28 4e 05                load.m32 <@054e28> ;typeofBase1
	<.main+3778 @056c2e> : 0c 28 00 00                inc.i32(+40)
	<.main+3782 @056c32> : 22                         load.i32
	<.main+3783 @056c33> : 2e 30 4e 05                store.m32 <@054e30> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@056c37> - <@056c44>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+3787 @056c37> : 2a 28 4e 05                load.m32 <@054e28> ;typeofBase1
	<.main+3791 @056c3b> : 0c 20 00 00                inc.i32(+32)
	<.main+3795 @056c3f> : 22                         load.i32
	<.main+3796 @056c40> : 2e 38 4e 05                store.m32 <@054e38> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@056c44> - <@056c50>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+3800 @056c44> : 2a 28 4e 05                load.m32 <@054e28> ;typeofBase1
	<.main+3804 @056c48> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3808 @056c4c> : 2e 40 4e 05                store.m32 <@054e40> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@056c50> - <@056c5d>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+3812 @056c50> : 2a 40 4e 05                load.m32 <@054e40> ;typeofBase2
	<.main+3816 @056c54> : 0c 28 00 00                inc.i32(+40)
	<.main+3820 @056c58> : 22                         load.i32
	<.main+3821 @056c59> : 2e 48 4e 05                store.m32 <@054e48> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@056c5d> - <@056c6a>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+3825 @056c5d> : 2a 40 4e 05                load.m32 <@054e40> ;typeofBase2
	<.main+3829 @056c61> : 0c 20 00 00                inc.i32(+32)
	<.main+3833 @056c65> : 22                         load.i32
	<.main+3834 @056c66> : 2e 50 4e 05                store.m32 <@054e50> ;sizeOfBase2
	test/stdc/number.ci:3: (13 bytes: <@056c6a> - <@056c77>): static pi64: float64 := 3.141593
	<.main+3838 @056c6a> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+3847 @056c73> : 2d 58 4e 05                store.m64 <@054e58> ;pi64
	test/stdc/number.ci:4: (13 bytes: <@056c77> - <@056c84>): static e64: float64 := 2.718282
	<.main+3851 @056c77> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+3860 @056c80> : 2d 60 4e 05                store.m64 <@054e60> ;e64
	test/stdc/number.ci:6: (9 bytes: <@056c84> - <@056c8d>): static pi32: float32 := pi64
	<.main+3864 @056c84> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+3868 @056c88> : 8c                         f64.2f32
	<.main+3869 @056c89> : 2e 68 4e 05                store.m32 <@054e68> ;pi32
	test/stdc/number.ci:7: (9 bytes: <@056c8d> - <@056c96>): static e32: float32 := e64
	<.main+3873 @056c8d> : 2b 60 4e 05                load.m64 <@054e60> ;e64
	<.main+3877 @056c91> : 8c                         f64.2f32
	<.main+3878 @056c92> : 2e 70 4e 05                store.m32 <@054e70> ;e32
	test/stdc/number.ci:14: (11 bytes: <@056c96> - <@056ca1>): static r_comp: int32 := int32(14 << 3)
	<.main+3882 @056c96> : 1c 0e 00 00 00             load.c32 14
	<.main+3887 @056c9b> : 3f 43                      b32.shl 0x003
	<.main+3889 @056c9d> : 2e 78 4e 05                store.m32 <@054e78> ;r_comp
	test/stdc/number.ci:15: (11 bytes: <@056ca1> - <@056cac>): static g_comp: int32 := int32(63 << 2)
	<.main+3893 @056ca1> : 1c 3f 00 00 00             load.c32 63
	<.main+3898 @056ca6> : 3f 42                      b32.shl 0x002
	<.main+3900 @056ca8> : 2e 80 4e 05                store.m32 <@054e80> ;g_comp
	test/stdc/number.ci:16: (11 bytes: <@056cac> - <@056cb7>): static b_comp: int32 := int32(31 << 3)
	<.main+3904 @056cac> : 1c 1f 00 00 00             load.c32 31
	<.main+3909 @056cb1> : 3f 43                      b32.shl 0x003
	<.main+3911 @056cb3> : 2e 88 4e 05                store.m32 <@054e88> ;b_comp
	test/stdc/number.ci:18: (38 bytes: <@056cb7> - <@056cdd>): static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+3915 @056cb7> : 2a 78 4e 05                load.m32 <@054e78> ;r_comp
	<.main+3919 @056cbb> : 3f 48                      b32.shl 0x008
	<.main+3921 @056cbd> : 1c 00 f8 00 00             load.c32 63488
	<.main+3926 @056cc2> : 31                         and.b32
	<.main+3927 @056cc3> : 2a 80 4e 05                load.m32 <@054e80> ;g_comp
	<.main+3931 @056cc7> : 3f 43                      b32.shl 0x003
	<.main+3933 @056cc9> : 1c e0 07 00 00             load.c32 2016
	<.main+3938 @056cce> : 31                         and.b32
	<.main+3939 @056ccf> : 32                         or.b32
	<.main+3940 @056cd0> : 2a 88 4e 05                load.m32 <@054e88> ;b_comp
	<.main+3944 @056cd4> : 3f c3                      b32.sar 0x003
	<.main+3946 @056cd6> : 3f 05                      b32.and 0x01f
	<.main+3948 @056cd8> : 32                         or.b32
	<.main+3949 @056cd9> : 2e 90 4e 05                store.m32 <@054e90> ;r5g6b5
	test/stdc/number.ci:19: (36 bytes: <@056cdd> - <@056d01>): static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3953 @056cdd> : 2a 78 4e 05                load.m32 <@054e78> ;r_comp
	<.main+3957 @056ce1> : 3f 50                      b32.shl 0x010
	<.main+3959 @056ce3> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3964 @056ce8> : 31                         and.b32
	<.main+3965 @056ce9> : 2a 80 4e 05                load.m32 <@054e80> ;g_comp
	<.main+3969 @056ced> : 3f 48                      b32.shl 0x008
	<.main+3971 @056cef> : 1c 00 ff 00 00             load.c32 65280
	<.main+3976 @056cf4> : 31                         and.b32
	<.main+3977 @056cf5> : 32                         or.b32
	<.main+3978 @056cf6> : 2a 88 4e 05                load.m32 <@054e88> ;b_comp
	<.main+3982 @056cfa> : 3f 08                      b32.and 0x0ff
	<.main+3984 @056cfc> : 32                         or.b32
	<.main+3985 @056cfd> : 2e 98 4e 05                store.m32 <@054e98> ;r8g8b8
	test/stdc/number.ci:21: (22 bytes: <@056d01> - <@056d17>): static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3989 @056d01> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+3993 @056d05> : 1c 0b 00 00 00             load.c32 11
	<.main+3998 @056d0a> : 1c 05 00 00 00             load.c32 5
	<.main+4003 @056d0f> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4007 @056d13> : 2e a0 4e 05                store.m32 <@054ea0> ;zxtR5
	test/stdc/number.ci:22: (22 bytes: <@056d17> - <@056d2d>): static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+4011 @056d17> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4015 @056d1b> : 1c 05 00 00 00             load.c32 5
	<.main+4020 @056d20> : 1c 06 00 00 00             load.c32 6
	<.main+4025 @056d25> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4029 @056d29> : 2e a8 4e 05                store.m32 <@054ea8> ;zxtG6
	test/stdc/number.ci:23: (18 bytes: <@056d2d> - <@056d3f>): static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4033 @056d2d> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4037 @056d31> : 19                         load.z32
	<.main+4038 @056d32> : 1c 05 00 00 00             load.c32 5
	<.main+4043 @056d37> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4047 @056d3b> : 2e b0 4e 05                store.m32 <@054eb0> ;zxtB5
	test/stdc/number.ci:25: (22 bytes: <@056d3f> - <@056d55>): static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+4051 @056d3f> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4055 @056d43> : 1c 0b 00 00 00             load.c32 11
	<.main+4060 @056d48> : 1c 05 00 00 00             load.c32 5
	<.main+4065 @056d4d> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4069 @056d51> : 2e b8 4e 05                store.m32 <@054eb8> ;sxtR5
	test/stdc/number.ci:26: (22 bytes: <@056d55> - <@056d6b>): static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+4073 @056d55> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4077 @056d59> : 1c 05 00 00 00             load.c32 5
	<.main+4082 @056d5e> : 1c 06 00 00 00             load.c32 6
	<.main+4087 @056d63> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4091 @056d67> : 2e c0 4e 05                store.m32 <@054ec0> ;sxtG6
	test/stdc/number.ci:27: (18 bytes: <@056d6b> - <@056d7d>): static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4095 @056d6b> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4099 @056d6f> : 19                         load.z32
	<.main+4100 @056d70> : 1c 05 00 00 00             load.c32 5
	<.main+4105 @056d75> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4109 @056d79> : 2e c8 4e 05                store.m32 <@054ec8> ;sxtB5
	test/stdc/number.ci:29: (22 bytes: <@056d7d> - <@056d93>): static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+4113 @056d7d> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4117 @056d81> : 1c 10 00 00 00             load.c32 16
	<.main+4122 @056d86> : 1c 08 00 00 00             load.c32 8
	<.main+4127 @056d8b> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4131 @056d8f> : 2e d0 4e 05                store.m32 <@054ed0> ;zxtR8
	test/stdc/number.ci:30: (22 bytes: <@056d93> - <@056da9>): static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+4135 @056d93> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4139 @056d97> : 1c 08 00 00 00             load.c32 8
	<.main+4144 @056d9c> : 1c 08 00 00 00             load.c32 8
	<.main+4149 @056da1> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4153 @056da5> : 2e d8 4e 05                store.m32 <@054ed8> ;zxtG8
	test/stdc/number.ci:31: (18 bytes: <@056da9> - <@056dbb>): static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+4157 @056da9> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4161 @056dad> : 19                         load.z32
	<.main+4162 @056dae> : 1c 08 00 00 00             load.c32 8
	<.main+4167 @056db3> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4171 @056db7> : 2e e0 4e 05                store.m32 <@054ee0> ;zxtB8
	test/stdc/number.ci:33: (22 bytes: <@056dbb> - <@056dd1>): static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+4175 @056dbb> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4179 @056dbf> : 1c 10 00 00 00             load.c32 16
	<.main+4184 @056dc4> : 1c 08 00 00 00             load.c32 8
	<.main+4189 @056dc9> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4193 @056dcd> : 2e e8 4e 05                store.m32 <@054ee8> ;sxtR8
	test/stdc/number.ci:34: (22 bytes: <@056dd1> - <@056de7>): static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+4197 @056dd1> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4201 @056dd5> : 1c 08 00 00 00             load.c32 8
	<.main+4206 @056dda> : 1c 08 00 00 00             load.c32 8
	<.main+4211 @056ddf> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4215 @056de3> : 2e f0 4e 05                store.m32 <@054ef0> ;sxtG8
	test/stdc/number.ci:35: (18 bytes: <@056de7> - <@056df9>): static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+4219 @056de7> : 2a 98 4e 05                load.m32 <@054e98> ;r8g8b8
	<.main+4223 @056deb> : 19                         load.z32
	<.main+4224 @056dec> : 1c 08 00 00 00             load.c32 8
	<.main+4229 @056df1> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4233 @056df5> : 2e f8 4e 05                store.m32 <@054ef8> ;sxtB8
	test/stdc/number.ci:37: (22 bytes: <@056df9> - <@056e0f>): static testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+4237 @056df9> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4241 @056dfd> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4250 @056e06> : 84                         div.f64
	<.main+4251 @056e07> : 01 26 00 00                nfc(38) ;float64.sin(x: float64): float64
	<.main+4255 @056e0b> : 2d 00 4f 05                store.m64 <@054f00> ;testSin_f64
	test/stdc/number.ci:38: (22 bytes: <@056e0f> - <@056e25>): static testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+4259 @056e0f> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4263 @056e13> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4272 @056e1c> : 84                         div.f64
	<.main+4273 @056e1d> : 01 27 00 00                nfc(39) ;float64.cos(x: float64): float64
	<.main+4277 @056e21> : 2d 08 4f 05                store.m64 <@054f08> ;testCos_f64
	test/stdc/number.ci:39: (22 bytes: <@056e25> - <@056e3b>): static testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+4281 @056e25> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4285 @056e29> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+4294 @056e32> : 84                         div.f64
	<.main+4295 @056e33> : 01 28 00 00                nfc(40) ;float64.tan(x: float64): float64
	<.main+4299 @056e37> : 2d 10 4f 05                store.m64 <@054f10> ;testTan_f64
	test/stdc/number.ci:40: (22 bytes: <@056e3b> - <@056e51>): static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+4303 @056e3b> : 2b 60 4e 05                load.m64 <@054e60> ;e64
	<.main+4307 @056e3f> : 2b 60 4e 05                load.m64 <@054e60> ;e64
	<.main+4311 @056e43> : 83                         mul.f64
	<.main+4312 @056e44> : 2b 60 4e 05                load.m64 <@054e60> ;e64
	<.main+4316 @056e48> : 83                         mul.f64
	<.main+4317 @056e49> : 01 29 00 00                nfc(41) ;float64.log(x: float64): float64
	<.main+4321 @056e4d> : 2d 18 4f 05                store.m64 <@054f18> ;testLog_f64
	test/stdc/number.ci:41: (17 bytes: <@056e51> - <@056e62>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+4325 @056e51> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4334 @056e5a> : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<.main+4338 @056e5e> : 2d 20 4f 05                store.m64 <@054f20> ;testExp_f64
	test/stdc/number.ci:42: (26 bytes: <@056e62> - <@056e7c>): static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+4342 @056e62> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4346 @056e66> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4350 @056e6a> : 83                         mul.f64
	<.main+4351 @056e6b> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+4360 @056e74> : 01 2b 00 00                nfc(43) ;float64.pow(x: float64, y: float64): float64
	<.main+4364 @056e78> : 2d 28 4f 05                store.m64 <@054f28> ;testPow_f64
	test/stdc/number.ci:43: (17 bytes: <@056e7c> - <@056e8d>): static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+4368 @056e7c> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4372 @056e80> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4376 @056e84> : 83                         mul.f64
	<.main+4377 @056e85> : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	<.main+4381 @056e89> : 2d 30 4f 05                store.m64 <@054f30> ;testSqrt_f64
	test/stdc/number.ci:44: (21 bytes: <@056e8d> - <@056ea2>): static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+4385 @056e8d> : 2b 58 4e 05                load.m64 <@054e58> ;pi64
	<.main+4389 @056e91> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4398 @056e9a> : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<.main+4402 @056e9e> : 2d 38 4f 05                store.m64 <@054f38> ;testAtan_f64
	test/stdc/number.ci:46: (18 bytes: <@056ea2> - <@056eb4>): static testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+4406 @056ea2> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4410 @056ea6> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4415 @056eab> : 74                         div.f32
	<.main+4416 @056eac> : 01 1e 00 00                nfc(30) ;float32.sin(x: float32): float32
	<.main+4420 @056eb0> : 2e 40 4f 05                store.m32 <@054f40> ;testSin_f32
	test/stdc/number.ci:47: (18 bytes: <@056eb4> - <@056ec6>): static testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+4424 @056eb4> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4428 @056eb8> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4433 @056ebd> : 74                         div.f32
	<.main+4434 @056ebe> : 01 1f 00 00                nfc(31) ;float32.cos(x: float32): float32
	<.main+4438 @056ec2> : 2e 48 4f 05                store.m32 <@054f48> ;testCos_f32
	test/stdc/number.ci:48: (18 bytes: <@056ec6> - <@056ed8>): static testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+4442 @056ec6> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4446 @056eca> : 7f 00 00 80 40             load.f32 4.000000
	<.main+4451 @056ecf> : 74                         div.f32
	<.main+4452 @056ed0> : 01 20 00 00                nfc(32) ;float32.tan(x: float32): float32
	<.main+4456 @056ed4> : 2e 50 4f 05                store.m32 <@054f50> ;testTan_f32
	test/stdc/number.ci:49: (22 bytes: <@056ed8> - <@056eee>): static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+4460 @056ed8> : 2a 70 4e 05                load.m32 <@054e70> ;e32
	<.main+4464 @056edc> : 2a 70 4e 05                load.m32 <@054e70> ;e32
	<.main+4468 @056ee0> : 73                         mul.f32
	<.main+4469 @056ee1> : 2a 70 4e 05                load.m32 <@054e70> ;e32
	<.main+4473 @056ee5> : 73                         mul.f32
	<.main+4474 @056ee6> : 01 21 00 00                nfc(33) ;float32.log(x: float32): float32
	<.main+4478 @056eea> : 2e 58 4f 05                store.m32 <@054f58> ;testLog_f32
	test/stdc/number.ci:50: (13 bytes: <@056eee> - <@056efb>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+4482 @056eee> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4487 @056ef3> : 01 22 00 00                nfc(34) ;float32.exp(x: float32): float32
	<.main+4491 @056ef7> : 2e 60 4f 05                store.m32 <@054f60> ;testExp_f32
	test/stdc/number.ci:51: (22 bytes: <@056efb> - <@056f11>): static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+4495 @056efb> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4499 @056eff> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4503 @056f03> : 73                         mul.f32
	<.main+4504 @056f04> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+4509 @056f09> : 01 23 00 00                nfc(35) ;float32.pow(x: float32, y: float32): float32
	<.main+4513 @056f0d> : 2e 68 4f 05                store.m32 <@054f68> ;testPow_f32
	test/stdc/number.ci:52: (17 bytes: <@056f11> - <@056f22>): static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+4517 @056f11> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4521 @056f15> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4525 @056f19> : 73                         mul.f32
	<.main+4526 @056f1a> : 01 24 00 00                nfc(36) ;float32.sqrt(x: float32): float32
	<.main+4530 @056f1e> : 2e 70 4f 05                store.m32 <@054f70> ;testSqrt_f32
	test/stdc/number.ci:53: (17 bytes: <@056f22> - <@056f33>): static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+4534 @056f22> : 2a 68 4e 05                load.m32 <@054e68> ;pi32
	<.main+4538 @056f26> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4543 @056f2b> : 01 25 00 00                nfc(37) ;float32.atan2(x: float32, y: float32): float32
	<.main+4547 @056f2f> : 2e 78 4f 05                store.m32 <@054f78> ;testAtan_f32
	test/stdc/number.ci:55: (12 bytes: <@056f33> - <@056f3f>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+4551 @056f33> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4555 @056f37> : 01 16 00 00                nfc(22) ;uint32.pop(value: int32): int32
	<.main+4559 @056f3b> : 2e 80 4f 05                store.m32 <@054f80> ;testPopulation_u32
	test/stdc/number.ci:56: (12 bytes: <@056f3f> - <@056f4b>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+4563 @056f3f> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4567 @056f43> : 01 17 00 00                nfc(23) ;uint32.swap(value: int32): int32
	<.main+4571 @056f47> : 2e 88 4f 05                store.m32 <@054f88> ;testSwapBits_u32
	test/stdc/number.ci:57: (12 bytes: <@056f4b> - <@056f57>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+4575 @056f4b> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4579 @056f4f> : 01 18 00 00                nfc(24) ;uint32.bsr(value: int32): int32
	<.main+4583 @056f53> : 2e 90 4f 05                store.m32 <@054f90> ;testBitScanReverse_u32
	test/stdc/number.ci:58: (12 bytes: <@056f57> - <@056f63>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+4587 @056f57> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4591 @056f5b> : 01 19 00 00                nfc(25) ;uint32.bsf(value: int32): int32
	<.main+4595 @056f5f> : 2e 98 4f 05                store.m32 <@054f98> ;testBitScanForward_u32
	test/stdc/number.ci:59: (12 bytes: <@056f63> - <@056f6f>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+4599 @056f63> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4603 @056f67> : 01 1a 00 00                nfc(26) ;uint32.hib(value: int32): int32
	<.main+4607 @056f6b> : 2e a0 4f 05                store.m32 <@054fa0> ;testHighBit_u32
	test/stdc/number.ci:60: (12 bytes: <@056f6f> - <@056f7b>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+4611 @056f6f> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4615 @056f73> : 01 1b 00 00                nfc(27) ;uint32.lob(value: int32): int32
	<.main+4619 @056f77> : 2e a8 4f 05                store.m32 <@054fa8> ;testLowBit_u32
	test/stdc/number.ci:62: (18 bytes: <@056f7b> - <@056f8d>): static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4623 @056f7b> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4627 @056f7f> : 19                         load.z32
	<.main+4628 @056f80> : 1c 05 00 00 00             load.c32 5
	<.main+4633 @056f85> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4637 @056f89> : 2e b0 4f 05                store.m32 <@054fb0> ;testZeroExtend_u32
	test/stdc/number.ci:63: (18 bytes: <@056f8d> - <@056f9f>): static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4641 @056f8d> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4645 @056f91> : 19                         load.z32
	<.main+4646 @056f92> : 1c 05 00 00 00             load.c32 5
	<.main+4651 @056f97> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4655 @056f9b> : 2e b8 4f 05                store.m32 <@054fb8> ;testSignExtend_u32
	test/stdc/number.ci:65: (20 bytes: <@056f9f> - <@056fb3>): static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+4659 @056f9f> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4663 @056fa3> : 5b                         i32.2i64
	<.main+4664 @056fa4> : 19                         load.z32
	<.main+4665 @056fa5> : 1c 05 00 00 00             load.c32 5
	<.main+4670 @056faa> : 01 1c 00 00                nfc(28) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+4674 @056fae> : 6a                         i64.2i32
	<.main+4675 @056faf> : 2e c0 4f 05                store.m32 <@054fc0> ;testZeroExtend_u64
	test/stdc/number.ci:66: (20 bytes: <@056fb3> - <@056fc7>): static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+4679 @056fb3> : 2a 90 4e 05                load.m32 <@054e90> ;r5g6b5
	<.main+4683 @056fb7> : 5b                         i32.2i64
	<.main+4684 @056fb8> : 19                         load.z32
	<.main+4685 @056fb9> : 1c 05 00 00 00             load.c32 5
	<.main+4690 @056fbe> : 01 1d 00 00                nfc(29) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+4694 @056fc2> : 6a                         i64.2i32
	<.main+4695 @056fc3> : 2e c8 4f 05                store.m32 <@054fc8> ;testSignExtend_u64
	test/stdc/memory.ci:7: (18 bytes: <@056fc7> - <@056fd9>): static p1: pointer := malloc(1024)
	<.main+4699 @056fc7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4704 @056fcc> : 1c 00 04 00 00             load.c32 1024
	<.main+4709 @056fd1> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4713 @056fd5> : 2e d0 4f 05                store.m32 <@054fd0> ;p1
	test/stdc/memory.ci:8: (18 bytes: <@056fd9> - <@056feb>): static p2: pointer := malloc(80)
	<.main+4717 @056fd9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4722 @056fde> : 1c 50 00 00 00             load.c32 80
	<.main+4727 @056fe3> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4731 @056fe7> : 2e d8 4f 05                store.m32 <@054fd8> ;p2
	test/stdc/memory.ci:9: (18 bytes: <@056feb> - <@056ffd>): static p3: pointer := malloc(160)
	<.main+4735 @056feb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4740 @056ff0> : 1c a0 00 00 00             load.c32 160
	<.main+4745 @056ff5> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4749 @056ff9> : 2e e0 4f 05                store.m32 <@054fe0> ;p3
	test/stdc/memory.ci:10: (18 bytes: <@056ffd> - <@05700f>): static p4: pointer := malloc(820)
	<.main+4753 @056ffd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4758 @057002> : 1c 34 03 00 00             load.c32 820
	<.main+4763 @057007> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4767 @05700b> : 2e e8 4f 05                store.m32 <@054fe8> ;p4
	test/stdc/memory.ci:23: (13 bytes: <@05700f> - <@05701c>): static val1: int64 := 42
	<.main+4771 @05700f> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4780 @057018> : 2d f0 4f 05                store.m64 <@054ff0> ;val1
	test/stdc/memory.ci:24: (13 bytes: <@05701c> - <@057029>): static val2: int64 := 96
	<.main+4784 @05701c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+4793 @057025> : 2d f8 4f 05                store.m64 <@054ff8> ;val2
	test/stdc/tryExec.ci:46: (18 bytes: <@057029> - <@05703b>): static tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+4797 @057029> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4802 @05702e> : 1f 00 50 05 00             load.ref <@055000> ;noError(ptr: pointer): void
	<.main+4807 @057033> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4811 @057037> : 2e 90 50 05                store.m32 <@055090> ;tryExecErr0
	test/stdc/tryExec.ci:47: (18 bytes: <@05703b> - <@05704d>): static tryExecErr1: int32 := tryExec(void(null, null))
	<.main+4815 @05703b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4820 @057040> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4825 @057045> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4829 @057049> : 2e 98 50 05                store.m32 <@055098> ;tryExecErr1
	test/stdc/tryExec.ci:48: (18 bytes: <@05704d> - <@05705f>): static tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+4833 @05704d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4838 @057052> : 1f 08 50 05 00             load.ref <@055008> ;stackOverflow(ptr: pointer): void
	<.main+4843 @057057> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4847 @05705b> : 2e a0 50 05                store.m32 <@0550a0> ;tryExecErr2
	test/stdc/tryExec.ci:49: (18 bytes: <@05705f> - <@057071>): static tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+4851 @05705f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4856 @057064> : 1f 20 50 05 00             load.ref <@055020> ;divisionByZero(args: pointer): void
	<.main+4861 @057069> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4865 @05706d> : 2e a8 50 05                store.m32 <@0550a8> ;tryExecErr3
	test/stdc/tryExec.ci:50: (18 bytes: <@057071> - <@057083>): static tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+4869 @057071> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4874 @057076> : 1f 88 50 05 00             load.ref <@055088> ;invalidInstruction(args: pointer): void
	<.main+4879 @05707b> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4883 @05707f> : 2e b0 50 05                store.m32 <@0550b0> ;tryExecErr4
	test/stdc/tryExec.ci:51: (18 bytes: <@057083> - <@057095>): static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+4887 @057083> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4892 @057088> : 1f 78 50 05 00             load.ref <@055078> ;invalidMemoryAccess(args: pointer): void
	<.main+4897 @05708d> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4901 @057091> : 2e b8 50 05                store.m32 <@0550b8> ;tryExecErr5
	test/stdc/tryExec.ci:52: (18 bytes: <@057095> - <@0570a7>): static tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+4905 @057095> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4910 @05709a> : 1f 30 50 05 00             load.ref <@055030> ;abortExecution(args: pointer): void
	<.main+4915 @05709f> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4919 @0570a3> : 2e c0 50 05                store.m32 <@0550c0> ;tryExecErr6
	test/lang/array.ci:59: (9 bytes: <@0570a7> - <@0570b0>): static arrArrayInitNull: int64[*] := null
	<.main+4923 @0570a7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4928 @0570ac> : 2e 10 51 05                store.m32 <@055110> ;arrArrayInitNull
	test/lang/array.ci:60: (10 bytes: <@0570b0> - <@0570ba>): static arrSliceInitNull: int64[] := null
	<.main+4932 @0570b0> : 19                         load.z32
	<.main+4933 @0570b1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4938 @0570b6> : 2d 18 51 05                store.m64 <@055118> ;arrSliceInitNull
	test/lang/array.ci:63: (9 bytes: <@0570ba> - <@0570c3>): static arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+4942 @0570ba> : 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+4947 @0570bf> : 2e 20 51 05                store.m32 <@055120> ;arrArrayInitFixed
	test/lang/array.ci:64: (14 bytes: <@0570c3> - <@0570d1>): static arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+4951 @0570c3> : 1c 07 00 00 00             load.c32 7
	<.main+4956 @0570c8> : 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+4961 @0570cd> : 2d 28 51 05                store.m64 <@055128> ;arrSliceInitFixed
	test/lang/array.ci:67: (8 bytes: <@0570d1> - <@0570d9>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+4965 @0570d1> : 2a 28 51 05                load.m32 <@055128> ;arrSliceInitFixed
	<.main+4969 @0570d5> : 2e 30 51 05                store.m32 <@055130> ;arrArrayInitSlice
	test/lang/array.ci:68: (8 bytes: <@0570d9> - <@0570e1>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+4973 @0570d9> : 2b 28 51 05                load.m64 <@055128> ;arrSliceInitFixed
	<.main+4977 @0570dd> : 2d 38 51 05                store.m64 <@055138> ;arrSliceInitSlice
	test/lang/array.ci:71: (8 bytes: <@0570e1> - <@0570e9>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+4981 @0570e1> : 2a 20 51 05                load.m32 <@055120> ;arrArrayInitFixed
	<.main+4985 @0570e5> : 2e 40 51 05                store.m32 <@055140> ;arrArrayInitPtr
	test/lang/array.ci:86: (9 bytes: <@0570e9> - <@0570f2>): static strArray: char[*] := "string"
	<.main+4989 @0570e9> : 1f ec e3 02 00             load.ref <@02e3ec> ;"string"
	<.main+4994 @0570ee> : 2e 50 51 05                store.m32 <@055150> ;strArray
	test/lang/array.ci:90: (14 bytes: <@0570f2> - <@057100>): static strSlice: char[] := "string"
	<.main+4998 @0570f2> : 1c 06 00 00 00             load.c32 6
	<.main+5003 @0570f7> : 1f ec e3 02 00             load.ref <@02e3ec> ;"string"
	<.main+5008 @0570fc> : 2d 58 51 05                store.m64 <@055158> ;strSlice
	test/lang/member.ci:35: (5 bytes: <@057100> - <@057105>): static global: int32
	<.main+5012 @057100> : 19                         load.z32
	<.main+5013 @057101> : 2e 98 51 05                store.m32 <@055198> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@057105> - <@05710e>): static globalInit: int32 := 1
	<.main+5017 @057105> : 1c 01 00 00 00             load.c32 1
	<.main+5022 @05710a> : 2e a0 51 05                store.m32 <@0551a0> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@05710e> - <@057117>): static const globalConstant: int32 := 2
	<.main+5026 @05710e> : 1c 02 00 00 00             load.c32 2
	<.main+5031 @057113> : 2e a8 51 05                store.m32 <@0551a8> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@057117> - <@057129>): static globalRecInit: Inner := {...}
	<.main+5035 @057117> : 1c 04 00 00 00             load.c32 4
	<.main+5040 @05711c> : 2e b8 51 05                store.m32 <@0551b8> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@057120> - <@057129>): void(globalRecInit.constant := 5);
	<.main+5044 @057120> : 1c 05 00 00 00             load.c32 5
	<.main+5049 @057125> : 2e bc 51 05                store.m32 <@0551bc> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@057129> - <@05713b>): static const globalConstantRec: Inner := {...}
	<.main+5053 @057129> : 1c 06 00 00 00             load.c32 6
	<.main+5058 @05712e> : 2e c0 51 05                store.m32 <@0551c0> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@057132> - <@05713b>): void(globalConstantRec.constant := 7);
	<.main+5062 @057132> : 1c 07 00 00 00             load.c32 7
	<.main+5067 @057137> : 2e c4 51 05                store.m32 <@0551c4> ;RecordMemberTest.globalConstantRec+4
	test/lang/member.ci:53: (72 bytes: <@05713b> - <@057183>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5071 @05713b> : 1c 0a 00 00 00             load.c32 10
	<.main+5076 @057140> : 2e c8 51 05                store.m32 <@0551c8> ;recordMemberTest
	test/lang/member.ci:55: (9 bytes: <@057144> - <@05714d>): void(recordMemberTest.constant := 11);
	<.main+5080 @057144> : 1c 0b 00 00 00             load.c32 11
	<.main+5085 @057149> : 2e cc 51 05                store.m32 <@0551cc> ;recordMemberTest+4
	test/lang/member.ci:56: (9 bytes: <@05714d> - <@057156>): void(recordMemberTest.memberInit := 12);
	<.main+5089 @05714d> : 1c 0c 00 00 00             load.c32 12
	<.main+5094 @057152> : 2e d0 51 05                store.m32 <@0551d0> ;recordMemberTest+8
	test/lang/member.ci:57: (9 bytes: <@057156> - <@05715f>): void(recordMemberTest.constantInit := 13);
	<.main+5098 @057156> : 1c 0d 00 00 00             load.c32 13
	<.main+5103 @05715b> : 2e d4 51 05                store.m32 <@0551d4> ;recordMemberTest+12
	test/lang/member.ci:60: (9 bytes: <@05715f> - <@057168>): void(recordMemberTest.memberRec.member := 14);
	<.main+5107 @05715f> : 1c 0e 00 00 00             load.c32 14
	<.main+5112 @057164> : 2e d8 51 05                store.m32 <@0551d8> ;recordMemberTest+16
	test/lang/member.ci:61: (9 bytes: <@057168> - <@057171>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5116 @057168> : 1c 0f 00 00 00             load.c32 15
	<.main+5121 @05716d> : 2e dc 51 05                store.m32 <@0551dc> ;recordMemberTest+20
	test/lang/member.ci:65: (9 bytes: <@057171> - <@05717a>): void(recordMemberTest.constantRec.member := 16);
	<.main+5125 @057171> : 1c 10 00 00 00             load.c32 16
	<.main+5130 @057176> : 2e e0 51 05                store.m32 <@0551e0> ;recordMemberTest+24
	test/lang/member.ci:66: (9 bytes: <@05717a> - <@057183>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5134 @05717a> : 1c 11 00 00 00             load.c32 17
	<.main+5139 @05717f> : 2e e4 51 05                store.m32 <@0551e4> ;recordMemberTest+28
	test/lang/method.ci:18: (9 bytes: <@057183> - <@05718c>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5143 @057183> : 1f 40 52 05 00             load.ref <@055240> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5148 @057188> : 2e 10 52 05                store.m32 <@055210> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/method.ci:62: (26 bytes: <@05718c> - <@0571a6>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5152 @05718c> : 1f 68 52 05 00             load.ref <@055268> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5157 @057191> : 2e 90 52 05                store.m32 <@055290> ;recordMethodTest
	:: (8 bytes: <@057195> - <@05719d>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5161 @057195> : 2a 10 52 05                load.m32 <@055210> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5165 @057199> : 2e 94 52 05                store.m32 <@055294> ;recordMethodTest+4
	:: (9 bytes: <@05719d> - <@0571a6>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5169 @05719d> : 1f 18 52 05 00             load.ref <@055218> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5174 @0571a2> : 2e 98 52 05                store.m32 <@055298> ;recordMethodTest+8
	test/lang/recUnion.ci:26: (21 bytes: <@0571a6> - <@0571bb>): static black: rgbU8 := {...}
	<.main+5178 @0571a6> : 19                         load.z32
	<.main+5179 @0571a7> : 1f 2a 53 05 00             load.ref <@05532a> ;black+2
	<.main+5184 @0571ac> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@0571ad> - <@0571b4>): void(black.g := (0));
	<.main+5185 @0571ad> : 19                         load.z32
	<.main+5186 @0571ae> : 1f 29 53 05 00             load.ref <@055329> ;black+1
	<.main+5191 @0571b3> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@0571b4> - <@0571bb>): void(black.b := (0));
	<.main+5192 @0571b4> : 19                         load.z32
	<.main+5193 @0571b5> : 1f 28 53 05 00             load.ref <@055328> ;black
	<.main+5198 @0571ba> : 25                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@0571bb> - <@0571d4>): static green: rgbU8 := {...}
	<.main+5199 @0571bb> : 19                         load.z32
	<.main+5200 @0571bc> : 1f 32 53 05 00             load.ref <@055332> ;green+2
	<.main+5205 @0571c1> : 25                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@0571c2> - <@0571cd>): void(green.g := (255));
	<.main+5206 @0571c2> : 1c ff 00 00 00             load.c32 255
	<.main+5211 @0571c7> : 1f 31 53 05 00             load.ref <@055331> ;green+1
	<.main+5216 @0571cc> : 25                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@0571cd> - <@0571d4>): void(green.b := (0));
	<.main+5217 @0571cd> : 19                         load.z32
	<.main+5218 @0571ce> : 1f 30 53 05 00             load.ref <@055330> ;green
	<.main+5223 @0571d3> : 25                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@0571d4> - <@0571f5>): static white: rgbU8 := {...}
	<.main+5224 @0571d4> : 1c ff 00 00 00             load.c32 255
	<.main+5229 @0571d9> : 1f 3a 53 05 00             load.ref <@05533a> ;white+2
	<.main+5234 @0571de> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@0571df> - <@0571ea>): void(white.g := (255));
	<.main+5235 @0571df> : 1c ff 00 00 00             load.c32 255
	<.main+5240 @0571e4> : 1f 39 53 05 00             load.ref <@055339> ;white+1
	<.main+5245 @0571e9> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@0571ea> - <@0571f5>): void(white.b := (255));
	<.main+5246 @0571ea> : 1c ff 00 00 00             load.c32 255
	<.main+5251 @0571ef> : 1f 38 53 05 00             load.ref <@055338> ;white
	<.main+5256 @0571f4> : 25                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@0571f5> - <@0571fe>): static cyan: color := {...}
	<.main+5257 @0571f5> : 1c ff ff 00 00             load.c32 65535
	<.main+5262 @0571fa> : 2e 40 53 05                store.m32 <@055340> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@0571fe> - <@057217>): static blue: color := {...}
	<.main+5266 @0571fe> : 19                         load.z32
	<.main+5267 @0571ff> : 1f 4a 53 05 00             load.ref <@05534a> ;blue+2
	<.main+5272 @057204> : 25                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@057205> - <@05720c>): void(blue.rgb.g := (0));
	<.main+5273 @057205> : 19                         load.z32
	<.main+5274 @057206> : 1f 49 53 05 00             load.ref <@055349> ;blue+1
	<.main+5279 @05720b> : 25                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@05720c> - <@057217>): void(blue.rgb.b := (255));
	<.main+5280 @05720c> : 1c ff 00 00 00             load.c32 255
	<.main+5285 @057211> : 1f 48 53 05 00             load.ref <@055348> ;blue
	<.main+5290 @057216> : 25                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@057217> - <@057220>): static shift: int32 := 2
	<.main+5291 @057217> : 1c 02 00 00 00             load.c32 2
	<.main+5296 @05721c> : 2e 50 53 05                store.m32 <@055350> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@057220> - <@05722b>): static boolA: bool := true
	<.main+5300 @057220> : 1c 01 00 00 00             load.c32 1
	<.main+5305 @057225> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5310 @05722a> : 25                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@05722b> - <@057236>): static boolB: bool := bool(!false)
	<.main+5311 @05722b> : 1c 01 00 00 00             load.c32 1
	<.main+5316 @057230> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5321 @057235> : 25                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@057236> - <@057249>): static boolAnd: bool := bool(boolA & boolB)
	<.main+5322 @057236> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5327 @05723b> : 20                         load.i8
	<.main+5328 @05723c> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5333 @057241> : 20                         load.i8
	<.main+5334 @057242> : 31                         and.b32
	<.main+5335 @057243> : 1f 68 53 05 00             load.ref <@055368> ;boolAnd
	<.main+5340 @057248> : 25                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@057249> - <@05725c>): static boolIor: bool := bool(boolA | boolB)
	<.main+5341 @057249> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5346 @05724e> : 20                         load.i8
	<.main+5347 @05724f> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5352 @057254> : 20                         load.i8
	<.main+5353 @057255> : 32                         or.b32
	<.main+5354 @057256> : 1f 70 53 05 00             load.ref <@055370> ;boolIor
	<.main+5359 @05725b> : 25                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@05725c> - <@05726f>): static boolXor: bool := bool(boolA ^ boolB)
	<.main+5360 @05725c> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5365 @057261> : 20                         load.i8
	<.main+5366 @057262> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5371 @057267> : 20                         load.i8
	<.main+5372 @057268> : 36                         xor.b32
	<.main+5373 @057269> : 1f 78 53 05 00             load.ref <@055378> ;boolXor
	<.main+5378 @05726e> : 25                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@05726f> - <@05727c>): static boolNot: bool := bool(!boolB)
	<.main+5379 @05726f> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5384 @057274> : 20                         load.i8
	<.main+5385 @057275> : 0b                         not.b32
	<.main+5386 @057276> : 1f 80 53 05 00             load.ref <@055380> ;boolNot
	<.main+5391 @05727b> : 25                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@05727c> - <@05728f>): static boolCeq: bool := bool(boolA == boolB)
	<.main+5392 @05727c> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5397 @057281> : 20                         load.i8
	<.main+5398 @057282> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5403 @057287> : 20                         load.i8
	<.main+5404 @057288> : 57                         ceq.i32
	<.main+5405 @057289> : 1f 88 53 05 00             load.ref <@055388> ;boolCeq
	<.main+5410 @05728e> : 25                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@05728f> - <@0572a3>): static boolCne: bool := bool(boolA != boolB)
	<.main+5411 @05728f> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5416 @057294> : 20                         load.i8
	<.main+5417 @057295> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5422 @05729a> : 20                         load.i8
	<.main+5423 @05729b> : 57                         ceq.i32
	<.main+5424 @05729c> : 0b                         not.b32
	<.main+5425 @05729d> : 1f 90 53 05 00             load.ref <@055390> ;boolCne
	<.main+5430 @0572a2> : 25                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@0572a3> - <@0572b6>): static boolClt: bool := bool(boolA < boolB)
	<.main+5431 @0572a3> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5436 @0572a8> : 20                         load.i8
	<.main+5437 @0572a9> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5442 @0572ae> : 20                         load.i8
	<.main+5443 @0572af> : 58                         clt.i32
	<.main+5444 @0572b0> : 1f 98 53 05 00             load.ref <@055398> ;boolClt
	<.main+5449 @0572b5> : 25                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@0572b6> - <@0572ca>): static boolCle: bool := bool(boolA <= boolB)
	<.main+5450 @0572b6> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5455 @0572bb> : 20                         load.i8
	<.main+5456 @0572bc> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5461 @0572c1> : 20                         load.i8
	<.main+5462 @0572c2> : 59                         cgt.i32
	<.main+5463 @0572c3> : 0b                         not.b32
	<.main+5464 @0572c4> : 1f a0 53 05 00             load.ref <@0553a0> ;boolCle
	<.main+5469 @0572c9> : 25                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@0572ca> - <@0572dd>): static boolCgt: bool := bool(boolA > boolB)
	<.main+5470 @0572ca> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5475 @0572cf> : 20                         load.i8
	<.main+5476 @0572d0> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5481 @0572d5> : 20                         load.i8
	<.main+5482 @0572d6> : 59                         cgt.i32
	<.main+5483 @0572d7> : 1f a8 53 05 00             load.ref <@0553a8> ;boolCgt
	<.main+5488 @0572dc> : 25                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@0572dd> - <@0572f1>): static boolCge: bool := bool(boolA >= boolB)
	<.main+5489 @0572dd> : 1f 58 53 05 00             load.ref <@055358> ;boolA
	<.main+5494 @0572e2> : 20                         load.i8
	<.main+5495 @0572e3> : 1f 60 53 05 00             load.ref <@055360> ;boolB
	<.main+5500 @0572e8> : 20                         load.i8
	<.main+5501 @0572e9> : 58                         clt.i32
	<.main+5502 @0572ea> : 0b                         not.b32
	<.main+5503 @0572eb> : 1f b0 53 05 00             load.ref <@0553b0> ;boolCge
	<.main+5508 @0572f0> : 25                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@0572f1> - <@0572fc>): static chrA: char := 'a'
	<.main+5509 @0572f1> : 1c 61 00 00 00             load.c32 97
	<.main+5514 @0572f6> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5519 @0572fb> : 25                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@0572fc> - <@057307>): static chrB: char := 'b'
	<.main+5520 @0572fc> : 1c 62 00 00 00             load.c32 98
	<.main+5525 @057301> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5530 @057306> : 25                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@057307> - <@057313>): static chrPls: char := char(+chrB)
	<.main+5531 @057307> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5536 @05730c> : 20                         load.i8
	<.main+5537 @05730d> : 1f c8 53 05 00             load.ref <@0553c8> ;chrPls
	<.main+5542 @057312> : 25                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@057313> - <@057320>): static chrNeg: char := char(-chrB)
	<.main+5543 @057313> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5548 @057318> : 20                         load.i8
	<.main+5549 @057319> : 50                         neg.i32
	<.main+5550 @05731a> : 1f d0 53 05 00             load.ref <@0553d0> ;chrNeg
	<.main+5555 @05731f> : 25                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@057320> - <@05732d>): static chrCmt: char := char(~chrB)
	<.main+5556 @057320> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5561 @057325> : 20                         load.i8
	<.main+5562 @057326> : 30                         cmt.b32
	<.main+5563 @057327> : 1f d8 53 05 00             load.ref <@0553d8> ;chrCmt
	<.main+5568 @05732c> : 25                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@05732d> - <@057340>): static chrAdd: char := char(chrA + chrB)
	<.main+5569 @05732d> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5574 @057332> : 20                         load.i8
	<.main+5575 @057333> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5580 @057338> : 20                         load.i8
	<.main+5581 @057339> : 51                         add.i32
	<.main+5582 @05733a> : 1f e0 53 05 00             load.ref <@0553e0> ;chrAdd
	<.main+5587 @05733f> : 25                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@057340> - <@057353>): static chrSub: char := char(chrA - chrB)
	<.main+5588 @057340> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5593 @057345> : 20                         load.i8
	<.main+5594 @057346> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5599 @05734b> : 20                         load.i8
	<.main+5600 @05734c> : 52                         sub.i32
	<.main+5601 @05734d> : 1f e8 53 05 00             load.ref <@0553e8> ;chrSub
	<.main+5606 @057352> : 25                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@057353> - <@057366>): static chrMul: char := char(chrA * chrB)
	<.main+5607 @057353> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5612 @057358> : 20                         load.i8
	<.main+5613 @057359> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5618 @05735e> : 20                         load.i8
	<.main+5619 @05735f> : 53                         mul.i32
	<.main+5620 @057360> : 1f f0 53 05 00             load.ref <@0553f0> ;chrMul
	<.main+5625 @057365> : 25                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@057366> - <@057379>): static chrDiv: char := char(chrA / chrB)
	<.main+5626 @057366> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5631 @05736b> : 20                         load.i8
	<.main+5632 @05736c> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5637 @057371> : 20                         load.i8
	<.main+5638 @057372> : 54                         div.i32
	<.main+5639 @057373> : 1f f8 53 05 00             load.ref <@0553f8> ;chrDiv
	<.main+5644 @057378> : 25                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@057379> - <@05738c>): static chrMod: char := char(chrA % chrB)
	<.main+5645 @057379> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5650 @05737e> : 20                         load.i8
	<.main+5651 @05737f> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5656 @057384> : 20                         load.i8
	<.main+5657 @057385> : 55                         mod.i32
	<.main+5658 @057386> : 1f 00 54 05 00             load.ref <@055400> ;chrMod
	<.main+5663 @05738b> : 25                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@05738c> - <@05739f>): static chrAnd: char := char(chrA & chrB)
	<.main+5664 @05738c> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5669 @057391> : 20                         load.i8
	<.main+5670 @057392> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5675 @057397> : 20                         load.i8
	<.main+5676 @057398> : 31                         and.b32
	<.main+5677 @057399> : 1f 08 54 05 00             load.ref <@055408> ;chrAnd
	<.main+5682 @05739e> : 25                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@05739f> - <@0573b2>): static chrIor: char := char(chrA | chrB)
	<.main+5683 @05739f> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5688 @0573a4> : 20                         load.i8
	<.main+5689 @0573a5> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5694 @0573aa> : 20                         load.i8
	<.main+5695 @0573ab> : 32                         or.b32
	<.main+5696 @0573ac> : 1f 10 54 05 00             load.ref <@055410> ;chrIor
	<.main+5701 @0573b1> : 25                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@0573b2> - <@0573c5>): static chrXor: char := char(chrA ^ chrB)
	<.main+5702 @0573b2> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5707 @0573b7> : 20                         load.i8
	<.main+5708 @0573b8> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5713 @0573bd> : 20                         load.i8
	<.main+5714 @0573be> : 36                         xor.b32
	<.main+5715 @0573bf> : 1f 18 54 05 00             load.ref <@055418> ;chrXor
	<.main+5720 @0573c4> : 25                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@0573c5> - <@0573d6>): static chrShl: char := int32((chrA) << shift)
	<.main+5721 @0573c5> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5726 @0573ca> : 20                         load.i8
	<.main+5727 @0573cb> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+5731 @0573cf> : 3a                         shl.b32
	<.main+5732 @0573d0> : 1f 20 54 05 00             load.ref <@055420> ;chrShl
	<.main+5737 @0573d5> : 25                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@0573d6> - <@0573e7>): static chrShr: char := int32((chrA) >> shift)
	<.main+5738 @0573d6> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5743 @0573db> : 20                         load.i8
	<.main+5744 @0573dc> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+5748 @0573e0> : 3c                         sar.b32
	<.main+5749 @0573e1> : 1f 28 54 05 00             load.ref <@055428> ;chrShr
	<.main+5754 @0573e6> : 25                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@0573e7> - <@0573f5>): static chrNot: bool := bool(!(chrB))
	<.main+5755 @0573e7> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5760 @0573ec> : 20                         load.i8
	<.main+5761 @0573ed> : 5a                         i32.2bool
	<.main+5762 @0573ee> : 0b                         not.b32
	<.main+5763 @0573ef> : 1f 30 54 05 00             load.ref <@055430> ;chrNot
	<.main+5768 @0573f4> : 25                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@0573f5> - <@057408>): static chrCeq: bool := bool(chrA == chrB)
	<.main+5769 @0573f5> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5774 @0573fa> : 20                         load.i8
	<.main+5775 @0573fb> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5780 @057400> : 20                         load.i8
	<.main+5781 @057401> : 57                         ceq.i32
	<.main+5782 @057402> : 1f 38 54 05 00             load.ref <@055438> ;chrCeq
	<.main+5787 @057407> : 25                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@057408> - <@05741c>): static chrCne: bool := bool(chrA != chrB)
	<.main+5788 @057408> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5793 @05740d> : 20                         load.i8
	<.main+5794 @05740e> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5799 @057413> : 20                         load.i8
	<.main+5800 @057414> : 57                         ceq.i32
	<.main+5801 @057415> : 0b                         not.b32
	<.main+5802 @057416> : 1f 40 54 05 00             load.ref <@055440> ;chrCne
	<.main+5807 @05741b> : 25                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@05741c> - <@05742f>): static chrClt: bool := bool(chrA < chrB)
	<.main+5808 @05741c> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5813 @057421> : 20                         load.i8
	<.main+5814 @057422> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5819 @057427> : 20                         load.i8
	<.main+5820 @057428> : 58                         clt.i32
	<.main+5821 @057429> : 1f 48 54 05 00             load.ref <@055448> ;chrClt
	<.main+5826 @05742e> : 25                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@05742f> - <@057443>): static chrCle: bool := bool(chrA <= chrB)
	<.main+5827 @05742f> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5832 @057434> : 20                         load.i8
	<.main+5833 @057435> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5838 @05743a> : 20                         load.i8
	<.main+5839 @05743b> : 59                         cgt.i32
	<.main+5840 @05743c> : 0b                         not.b32
	<.main+5841 @05743d> : 1f 50 54 05 00             load.ref <@055450> ;chrCle
	<.main+5846 @057442> : 25                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@057443> - <@057456>): static chrCgt: bool := bool(chrA > chrB)
	<.main+5847 @057443> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5852 @057448> : 20                         load.i8
	<.main+5853 @057449> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5858 @05744e> : 20                         load.i8
	<.main+5859 @05744f> : 59                         cgt.i32
	<.main+5860 @057450> : 1f 58 54 05 00             load.ref <@055458> ;chrCgt
	<.main+5865 @057455> : 25                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@057456> - <@05746a>): static chrCge: bool := bool(chrA >= chrB)
	<.main+5866 @057456> : 1f b8 53 05 00             load.ref <@0553b8> ;chrA
	<.main+5871 @05745b> : 20                         load.i8
	<.main+5872 @05745c> : 1f c0 53 05 00             load.ref <@0553c0> ;chrB
	<.main+5877 @057461> : 20                         load.i8
	<.main+5878 @057462> : 58                         clt.i32
	<.main+5879 @057463> : 0b                         not.b32
	<.main+5880 @057464> : 1f 60 54 05 00             load.ref <@055460> ;chrCge
	<.main+5885 @057469> : 25                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@05746a> - <@057475>): static i8A: int8 := a
	<.main+5886 @05746a> : 1c 60 00 00 00             load.c32 96
	<.main+5891 @05746f> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+5896 @057474> : 25                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@057475> - <@057480>): static i8B: int8 := b
	<.main+5897 @057475> : 1c 2a 00 00 00             load.c32 42
	<.main+5902 @05747a> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5907 @05747f> : 25                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@057480> - <@05748c>): static i8Pls: int8 := int8(+i8B)
	<.main+5908 @057480> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5913 @057485> : 20                         load.i8
	<.main+5914 @057486> : 1f 78 54 05 00             load.ref <@055478> ;i8Pls
	<.main+5919 @05748b> : 25                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@05748c> - <@057499>): static i8Neg: int8 := int8(-i8B)
	<.main+5920 @05748c> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5925 @057491> : 20                         load.i8
	<.main+5926 @057492> : 50                         neg.i32
	<.main+5927 @057493> : 1f 80 54 05 00             load.ref <@055480> ;i8Neg
	<.main+5932 @057498> : 25                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@057499> - <@0574a6>): static i8Cmt: int8 := int8(~i8B)
	<.main+5933 @057499> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5938 @05749e> : 20                         load.i8
	<.main+5939 @05749f> : 30                         cmt.b32
	<.main+5940 @0574a0> : 1f 88 54 05 00             load.ref <@055488> ;i8Cmt
	<.main+5945 @0574a5> : 25                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@0574a6> - <@0574b9>): static i8Add: int8 := int8(i8A + i8B)
	<.main+5946 @0574a6> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+5951 @0574ab> : 20                         load.i8
	<.main+5952 @0574ac> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5957 @0574b1> : 20                         load.i8
	<.main+5958 @0574b2> : 51                         add.i32
	<.main+5959 @0574b3> : 1f 90 54 05 00             load.ref <@055490> ;i8Add
	<.main+5964 @0574b8> : 25                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@0574b9> - <@0574cc>): static i8Sub: int8 := int8(i8A - i8B)
	<.main+5965 @0574b9> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+5970 @0574be> : 20                         load.i8
	<.main+5971 @0574bf> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5976 @0574c4> : 20                         load.i8
	<.main+5977 @0574c5> : 52                         sub.i32
	<.main+5978 @0574c6> : 1f 98 54 05 00             load.ref <@055498> ;i8Sub
	<.main+5983 @0574cb> : 25                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@0574cc> - <@0574df>): static i8Mul: int8 := int8(i8A * i8B)
	<.main+5984 @0574cc> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+5989 @0574d1> : 20                         load.i8
	<.main+5990 @0574d2> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+5995 @0574d7> : 20                         load.i8
	<.main+5996 @0574d8> : 53                         mul.i32
	<.main+5997 @0574d9> : 1f a0 54 05 00             load.ref <@0554a0> ;i8Mul
	<.main+6002 @0574de> : 25                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@0574df> - <@0574f2>): static i8Div: int8 := int8(i8A / i8B)
	<.main+6003 @0574df> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6008 @0574e4> : 20                         load.i8
	<.main+6009 @0574e5> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6014 @0574ea> : 20                         load.i8
	<.main+6015 @0574eb> : 54                         div.i32
	<.main+6016 @0574ec> : 1f a8 54 05 00             load.ref <@0554a8> ;i8Div
	<.main+6021 @0574f1> : 25                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@0574f2> - <@057505>): static i8Mod: int8 := int8(i8A % i8B)
	<.main+6022 @0574f2> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6027 @0574f7> : 20                         load.i8
	<.main+6028 @0574f8> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6033 @0574fd> : 20                         load.i8
	<.main+6034 @0574fe> : 55                         mod.i32
	<.main+6035 @0574ff> : 1f b0 54 05 00             load.ref <@0554b0> ;i8Mod
	<.main+6040 @057504> : 25                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@057505> - <@057518>): static i8And: int8 := int8(i8A & i8B)
	<.main+6041 @057505> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6046 @05750a> : 20                         load.i8
	<.main+6047 @05750b> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6052 @057510> : 20                         load.i8
	<.main+6053 @057511> : 31                         and.b32
	<.main+6054 @057512> : 1f b8 54 05 00             load.ref <@0554b8> ;i8And
	<.main+6059 @057517> : 25                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@057518> - <@05752b>): static i8Ior: int8 := int8(i8A | i8B)
	<.main+6060 @057518> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6065 @05751d> : 20                         load.i8
	<.main+6066 @05751e> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6071 @057523> : 20                         load.i8
	<.main+6072 @057524> : 32                         or.b32
	<.main+6073 @057525> : 1f c0 54 05 00             load.ref <@0554c0> ;i8Ior
	<.main+6078 @05752a> : 25                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@05752b> - <@05753e>): static i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6079 @05752b> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6084 @057530> : 20                         load.i8
	<.main+6085 @057531> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6090 @057536> : 20                         load.i8
	<.main+6091 @057537> : 36                         xor.b32
	<.main+6092 @057538> : 1f c8 54 05 00             load.ref <@0554c8> ;i8Xor
	<.main+6097 @05753d> : 25                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@05753e> - <@05754f>): static i8Shl: int8 := int32((i8A) << shift)
	<.main+6098 @05753e> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6103 @057543> : 20                         load.i8
	<.main+6104 @057544> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6108 @057548> : 3a                         shl.b32
	<.main+6109 @057549> : 1f d0 54 05 00             load.ref <@0554d0> ;i8Shl
	<.main+6114 @05754e> : 25                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@05754f> - <@057560>): static i8Shr: int8 := int32((i8A) >> shift)
	<.main+6115 @05754f> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6120 @057554> : 20                         load.i8
	<.main+6121 @057555> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6125 @057559> : 3c                         sar.b32
	<.main+6126 @05755a> : 1f d8 54 05 00             load.ref <@0554d8> ;i8Shr
	<.main+6131 @05755f> : 25                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@057560> - <@05756e>): static i8Not: bool := bool(!(i8B))
	<.main+6132 @057560> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6137 @057565> : 20                         load.i8
	<.main+6138 @057566> : 5a                         i32.2bool
	<.main+6139 @057567> : 0b                         not.b32
	<.main+6140 @057568> : 1f e0 54 05 00             load.ref <@0554e0> ;i8Not
	<.main+6145 @05756d> : 25                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@05756e> - <@057581>): static i8Ceq: bool := bool(i8A == i8B)
	<.main+6146 @05756e> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6151 @057573> : 20                         load.i8
	<.main+6152 @057574> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6157 @057579> : 20                         load.i8
	<.main+6158 @05757a> : 57                         ceq.i32
	<.main+6159 @05757b> : 1f e8 54 05 00             load.ref <@0554e8> ;i8Ceq
	<.main+6164 @057580> : 25                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@057581> - <@057595>): static i8Cne: bool := bool(i8A != i8B)
	<.main+6165 @057581> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6170 @057586> : 20                         load.i8
	<.main+6171 @057587> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6176 @05758c> : 20                         load.i8
	<.main+6177 @05758d> : 57                         ceq.i32
	<.main+6178 @05758e> : 0b                         not.b32
	<.main+6179 @05758f> : 1f f0 54 05 00             load.ref <@0554f0> ;i8Cne
	<.main+6184 @057594> : 25                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@057595> - <@0575a8>): static i8Clt: bool := bool(i8A < i8B)
	<.main+6185 @057595> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6190 @05759a> : 20                         load.i8
	<.main+6191 @05759b> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6196 @0575a0> : 20                         load.i8
	<.main+6197 @0575a1> : 58                         clt.i32
	<.main+6198 @0575a2> : 1f f8 54 05 00             load.ref <@0554f8> ;i8Clt
	<.main+6203 @0575a7> : 25                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@0575a8> - <@0575bc>): static i8Cle: bool := bool(i8A <= i8B)
	<.main+6204 @0575a8> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6209 @0575ad> : 20                         load.i8
	<.main+6210 @0575ae> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6215 @0575b3> : 20                         load.i8
	<.main+6216 @0575b4> : 59                         cgt.i32
	<.main+6217 @0575b5> : 0b                         not.b32
	<.main+6218 @0575b6> : 1f 00 55 05 00             load.ref <@055500> ;i8Cle
	<.main+6223 @0575bb> : 25                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@0575bc> - <@0575cf>): static i8Cgt: bool := bool(i8A > i8B)
	<.main+6224 @0575bc> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6229 @0575c1> : 20                         load.i8
	<.main+6230 @0575c2> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6235 @0575c7> : 20                         load.i8
	<.main+6236 @0575c8> : 59                         cgt.i32
	<.main+6237 @0575c9> : 1f 08 55 05 00             load.ref <@055508> ;i8Cgt
	<.main+6242 @0575ce> : 25                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@0575cf> - <@0575e3>): static i8Cge: bool := bool(i8A >= i8B)
	<.main+6243 @0575cf> : 1f 68 54 05 00             load.ref <@055468> ;i8A
	<.main+6248 @0575d4> : 20                         load.i8
	<.main+6249 @0575d5> : 1f 70 54 05 00             load.ref <@055470> ;i8B
	<.main+6254 @0575da> : 20                         load.i8
	<.main+6255 @0575db> : 58                         clt.i32
	<.main+6256 @0575dc> : 0b                         not.b32
	<.main+6257 @0575dd> : 1f 10 55 05 00             load.ref <@055510> ;i8Cge
	<.main+6262 @0575e2> : 25                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@0575e3> - <@0575ee>): static u8A: uint8 := a
	<.main+6263 @0575e3> : 1c 60 00 00 00             load.c32 96
	<.main+6268 @0575e8> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6273 @0575ed> : 25                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@0575ee> - <@0575f9>): static u8B: uint8 := b
	<.main+6274 @0575ee> : 1c 2a 00 00 00             load.c32 42
	<.main+6279 @0575f3> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6284 @0575f8> : 25                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@0575f9> - <@057605>): static u8Pls: uint8 := uint8(+u8B)
	<.main+6285 @0575f9> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6290 @0575fe> : 20                         load.i8
	<.main+6291 @0575ff> : 1f 28 55 05 00             load.ref <@055528> ;u8Pls
	<.main+6296 @057604> : 25                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@057605> - <@057612>): static u8Neg: uint8 := uint8(-u8B)
	<.main+6297 @057605> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6302 @05760a> : 20                         load.i8
	<.main+6303 @05760b> : 50                         neg.i32
	<.main+6304 @05760c> : 1f 30 55 05 00             load.ref <@055530> ;u8Neg
	<.main+6309 @057611> : 25                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@057612> - <@05761f>): static u8Cmt: uint8 := uint8(~u8B)
	<.main+6310 @057612> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6315 @057617> : 20                         load.i8
	<.main+6316 @057618> : 30                         cmt.b32
	<.main+6317 @057619> : 1f 38 55 05 00             load.ref <@055538> ;u8Cmt
	<.main+6322 @05761e> : 25                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@05761f> - <@057632>): static u8Add: uint8 := uint8(u8A + u8B)
	<.main+6323 @05761f> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6328 @057624> : 20                         load.i8
	<.main+6329 @057625> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6334 @05762a> : 20                         load.i8
	<.main+6335 @05762b> : 51                         add.i32
	<.main+6336 @05762c> : 1f 40 55 05 00             load.ref <@055540> ;u8Add
	<.main+6341 @057631> : 25                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@057632> - <@057645>): static u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6342 @057632> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6347 @057637> : 20                         load.i8
	<.main+6348 @057638> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6353 @05763d> : 20                         load.i8
	<.main+6354 @05763e> : 52                         sub.i32
	<.main+6355 @05763f> : 1f 48 55 05 00             load.ref <@055548> ;u8Sub
	<.main+6360 @057644> : 25                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@057645> - <@057658>): static u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6361 @057645> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6366 @05764a> : 20                         load.i8
	<.main+6367 @05764b> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6372 @057650> : 20                         load.i8
	<.main+6373 @057651> : 33                         mul.u32
	<.main+6374 @057652> : 1f 50 55 05 00             load.ref <@055550> ;u8Mul
	<.main+6379 @057657> : 25                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@057658> - <@05766b>): static u8Div: uint8 := uint8(u8A / u8B)
	<.main+6380 @057658> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6385 @05765d> : 20                         load.i8
	<.main+6386 @05765e> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6391 @057663> : 20                         load.i8
	<.main+6392 @057664> : 34                         div.u32
	<.main+6393 @057665> : 1f 58 55 05 00             load.ref <@055558> ;u8Div
	<.main+6398 @05766a> : 25                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@05766b> - <@05767e>): static u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6399 @05766b> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6404 @057670> : 20                         load.i8
	<.main+6405 @057671> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6410 @057676> : 20                         load.i8
	<.main+6411 @057677> : 35                         mod.u32
	<.main+6412 @057678> : 1f 60 55 05 00             load.ref <@055560> ;u8Mod
	<.main+6417 @05767d> : 25                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@05767e> - <@057691>): static u8And: uint8 := uint8(u8A & u8B)
	<.main+6418 @05767e> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6423 @057683> : 20                         load.i8
	<.main+6424 @057684> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6429 @057689> : 20                         load.i8
	<.main+6430 @05768a> : 31                         and.b32
	<.main+6431 @05768b> : 1f 68 55 05 00             load.ref <@055568> ;u8And
	<.main+6436 @057690> : 25                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@057691> - <@0576a4>): static u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6437 @057691> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6442 @057696> : 20                         load.i8
	<.main+6443 @057697> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6448 @05769c> : 20                         load.i8
	<.main+6449 @05769d> : 32                         or.b32
	<.main+6450 @05769e> : 1f 70 55 05 00             load.ref <@055570> ;u8Ior
	<.main+6455 @0576a3> : 25                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@0576a4> - <@0576b7>): static u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6456 @0576a4> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6461 @0576a9> : 20                         load.i8
	<.main+6462 @0576aa> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6467 @0576af> : 20                         load.i8
	<.main+6468 @0576b0> : 36                         xor.b32
	<.main+6469 @0576b1> : 1f 78 55 05 00             load.ref <@055578> ;u8Xor
	<.main+6474 @0576b6> : 25                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@0576b7> - <@0576c8>): static u8Shl: uint8 := int32((u8A) << shift)
	<.main+6475 @0576b7> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6480 @0576bc> : 20                         load.i8
	<.main+6481 @0576bd> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6485 @0576c1> : 3a                         shl.b32
	<.main+6486 @0576c2> : 1f 80 55 05 00             load.ref <@055580> ;u8Shl
	<.main+6491 @0576c7> : 25                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@0576c8> - <@0576d9>): static u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6492 @0576c8> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6497 @0576cd> : 20                         load.i8
	<.main+6498 @0576ce> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6502 @0576d2> : 3c                         sar.b32
	<.main+6503 @0576d3> : 1f 88 55 05 00             load.ref <@055588> ;u8Shr
	<.main+6508 @0576d8> : 25                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@0576d9> - <@0576e7>): static u8Not: bool := bool(!(u8B))
	<.main+6509 @0576d9> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6514 @0576de> : 20                         load.i8
	<.main+6515 @0576df> : 5a                         i32.2bool
	<.main+6516 @0576e0> : 0b                         not.b32
	<.main+6517 @0576e1> : 1f 90 55 05 00             load.ref <@055590> ;u8Not
	<.main+6522 @0576e6> : 25                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@0576e7> - <@0576fa>): static u8Ceq: bool := bool(u8A == u8B)
	<.main+6523 @0576e7> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6528 @0576ec> : 20                         load.i8
	<.main+6529 @0576ed> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6534 @0576f2> : 20                         load.i8
	<.main+6535 @0576f3> : 57                         ceq.i32
	<.main+6536 @0576f4> : 1f 98 55 05 00             load.ref <@055598> ;u8Ceq
	<.main+6541 @0576f9> : 25                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@0576fa> - <@05770e>): static u8Cne: bool := bool(u8A != u8B)
	<.main+6542 @0576fa> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6547 @0576ff> : 20                         load.i8
	<.main+6548 @057700> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6553 @057705> : 20                         load.i8
	<.main+6554 @057706> : 57                         ceq.i32
	<.main+6555 @057707> : 0b                         not.b32
	<.main+6556 @057708> : 1f a0 55 05 00             load.ref <@0555a0> ;u8Cne
	<.main+6561 @05770d> : 25                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@05770e> - <@057721>): static u8Clt: bool := bool(u8A < u8B)
	<.main+6562 @05770e> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6567 @057713> : 20                         load.i8
	<.main+6568 @057714> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6573 @057719> : 20                         load.i8
	<.main+6574 @05771a> : 38                         clt.u32
	<.main+6575 @05771b> : 1f a8 55 05 00             load.ref <@0555a8> ;u8Clt
	<.main+6580 @057720> : 25                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@057721> - <@057735>): static u8Cle: bool := bool(u8A <= u8B)
	<.main+6581 @057721> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6586 @057726> : 20                         load.i8
	<.main+6587 @057727> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6592 @05772c> : 20                         load.i8
	<.main+6593 @05772d> : 39                         cgt.u32
	<.main+6594 @05772e> : 0b                         not.b32
	<.main+6595 @05772f> : 1f b0 55 05 00             load.ref <@0555b0> ;u8Cle
	<.main+6600 @057734> : 25                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@057735> - <@057748>): static u8Cgt: bool := bool(u8A > u8B)
	<.main+6601 @057735> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6606 @05773a> : 20                         load.i8
	<.main+6607 @05773b> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6612 @057740> : 20                         load.i8
	<.main+6613 @057741> : 39                         cgt.u32
	<.main+6614 @057742> : 1f b8 55 05 00             load.ref <@0555b8> ;u8Cgt
	<.main+6619 @057747> : 25                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@057748> - <@05775c>): static u8Cge: bool := bool(u8A >= u8B)
	<.main+6620 @057748> : 1f 18 55 05 00             load.ref <@055518> ;u8A
	<.main+6625 @05774d> : 20                         load.i8
	<.main+6626 @05774e> : 1f 20 55 05 00             load.ref <@055520> ;u8B
	<.main+6631 @057753> : 20                         load.i8
	<.main+6632 @057754> : 38                         clt.u32
	<.main+6633 @057755> : 0b                         not.b32
	<.main+6634 @057756> : 1f c0 55 05 00             load.ref <@0555c0> ;u8Cge
	<.main+6639 @05775b> : 25                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@05775c> - <@057767>): static i16A: int16 := a
	<.main+6640 @05775c> : 1c 60 00 00 00             load.c32 96
	<.main+6645 @057761> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6650 @057766> : 26                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@057767> - <@057772>): static i16B: int16 := b
	<.main+6651 @057767> : 1c 2a 00 00 00             load.c32 42
	<.main+6656 @05776c> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6661 @057771> : 26                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@057772> - <@05777e>): static i16Pls: int16 := int16(+i16B)
	<.main+6662 @057772> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6667 @057777> : 21                         load.i16
	<.main+6668 @057778> : 1f d8 55 05 00             load.ref <@0555d8> ;i16Pls
	<.main+6673 @05777d> : 26                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@05777e> - <@05778b>): static i16Neg: int16 := int16(-i16B)
	<.main+6674 @05777e> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6679 @057783> : 21                         load.i16
	<.main+6680 @057784> : 50                         neg.i32
	<.main+6681 @057785> : 1f e0 55 05 00             load.ref <@0555e0> ;i16Neg
	<.main+6686 @05778a> : 26                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@05778b> - <@057798>): static i16Cmt: int16 := int16(~i16B)
	<.main+6687 @05778b> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6692 @057790> : 21                         load.i16
	<.main+6693 @057791> : 30                         cmt.b32
	<.main+6694 @057792> : 1f e8 55 05 00             load.ref <@0555e8> ;i16Cmt
	<.main+6699 @057797> : 26                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@057798> - <@0577ab>): static i16Add: int16 := int16(i16A + i16B)
	<.main+6700 @057798> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6705 @05779d> : 21                         load.i16
	<.main+6706 @05779e> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6711 @0577a3> : 21                         load.i16
	<.main+6712 @0577a4> : 51                         add.i32
	<.main+6713 @0577a5> : 1f f0 55 05 00             load.ref <@0555f0> ;i16Add
	<.main+6718 @0577aa> : 26                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@0577ab> - <@0577be>): static i16Sub: int16 := int16(i16A - i16B)
	<.main+6719 @0577ab> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6724 @0577b0> : 21                         load.i16
	<.main+6725 @0577b1> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6730 @0577b6> : 21                         load.i16
	<.main+6731 @0577b7> : 52                         sub.i32
	<.main+6732 @0577b8> : 1f f8 55 05 00             load.ref <@0555f8> ;i16Sub
	<.main+6737 @0577bd> : 26                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@0577be> - <@0577d1>): static i16Mul: int16 := int16(i16A * i16B)
	<.main+6738 @0577be> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6743 @0577c3> : 21                         load.i16
	<.main+6744 @0577c4> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6749 @0577c9> : 21                         load.i16
	<.main+6750 @0577ca> : 53                         mul.i32
	<.main+6751 @0577cb> : 1f 00 56 05 00             load.ref <@055600> ;i16Mul
	<.main+6756 @0577d0> : 26                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@0577d1> - <@0577e4>): static i16Div: int16 := int16(i16A / i16B)
	<.main+6757 @0577d1> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6762 @0577d6> : 21                         load.i16
	<.main+6763 @0577d7> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6768 @0577dc> : 21                         load.i16
	<.main+6769 @0577dd> : 54                         div.i32
	<.main+6770 @0577de> : 1f 08 56 05 00             load.ref <@055608> ;i16Div
	<.main+6775 @0577e3> : 26                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@0577e4> - <@0577f7>): static i16Mod: int16 := int16(i16A % i16B)
	<.main+6776 @0577e4> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6781 @0577e9> : 21                         load.i16
	<.main+6782 @0577ea> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6787 @0577ef> : 21                         load.i16
	<.main+6788 @0577f0> : 55                         mod.i32
	<.main+6789 @0577f1> : 1f 10 56 05 00             load.ref <@055610> ;i16Mod
	<.main+6794 @0577f6> : 26                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@0577f7> - <@05780a>): static i16And: int16 := int16(i16A & i16B)
	<.main+6795 @0577f7> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6800 @0577fc> : 21                         load.i16
	<.main+6801 @0577fd> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6806 @057802> : 21                         load.i16
	<.main+6807 @057803> : 31                         and.b32
	<.main+6808 @057804> : 1f 18 56 05 00             load.ref <@055618> ;i16And
	<.main+6813 @057809> : 26                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@05780a> - <@05781d>): static i16Ior: int16 := int16(i16A | i16B)
	<.main+6814 @05780a> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6819 @05780f> : 21                         load.i16
	<.main+6820 @057810> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6825 @057815> : 21                         load.i16
	<.main+6826 @057816> : 32                         or.b32
	<.main+6827 @057817> : 1f 20 56 05 00             load.ref <@055620> ;i16Ior
	<.main+6832 @05781c> : 26                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@05781d> - <@057830>): static i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6833 @05781d> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6838 @057822> : 21                         load.i16
	<.main+6839 @057823> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6844 @057828> : 21                         load.i16
	<.main+6845 @057829> : 36                         xor.b32
	<.main+6846 @05782a> : 1f 28 56 05 00             load.ref <@055628> ;i16Xor
	<.main+6851 @05782f> : 26                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@057830> - <@057841>): static i16Shl: int16 := int32((i16A) << shift)
	<.main+6852 @057830> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6857 @057835> : 21                         load.i16
	<.main+6858 @057836> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6862 @05783a> : 3a                         shl.b32
	<.main+6863 @05783b> : 1f 30 56 05 00             load.ref <@055630> ;i16Shl
	<.main+6868 @057840> : 26                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@057841> - <@057852>): static i16Shr: int16 := int32((i16A) >> shift)
	<.main+6869 @057841> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6874 @057846> : 21                         load.i16
	<.main+6875 @057847> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+6879 @05784b> : 3c                         sar.b32
	<.main+6880 @05784c> : 1f 38 56 05 00             load.ref <@055638> ;i16Shr
	<.main+6885 @057851> : 26                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@057852> - <@057860>): static i16Not: bool := bool(!(i16B))
	<.main+6886 @057852> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6891 @057857> : 21                         load.i16
	<.main+6892 @057858> : 5a                         i32.2bool
	<.main+6893 @057859> : 0b                         not.b32
	<.main+6894 @05785a> : 1f 40 56 05 00             load.ref <@055640> ;i16Not
	<.main+6899 @05785f> : 25                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@057860> - <@057873>): static i16Ceq: bool := bool(i16A == i16B)
	<.main+6900 @057860> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6905 @057865> : 21                         load.i16
	<.main+6906 @057866> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6911 @05786b> : 21                         load.i16
	<.main+6912 @05786c> : 57                         ceq.i32
	<.main+6913 @05786d> : 1f 48 56 05 00             load.ref <@055648> ;i16Ceq
	<.main+6918 @057872> : 25                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@057873> - <@057887>): static i16Cne: bool := bool(i16A != i16B)
	<.main+6919 @057873> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6924 @057878> : 21                         load.i16
	<.main+6925 @057879> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6930 @05787e> : 21                         load.i16
	<.main+6931 @05787f> : 57                         ceq.i32
	<.main+6932 @057880> : 0b                         not.b32
	<.main+6933 @057881> : 1f 50 56 05 00             load.ref <@055650> ;i16Cne
	<.main+6938 @057886> : 25                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@057887> - <@05789a>): static i16Clt: bool := bool(i16A < i16B)
	<.main+6939 @057887> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6944 @05788c> : 21                         load.i16
	<.main+6945 @05788d> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6950 @057892> : 21                         load.i16
	<.main+6951 @057893> : 58                         clt.i32
	<.main+6952 @057894> : 1f 58 56 05 00             load.ref <@055658> ;i16Clt
	<.main+6957 @057899> : 25                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@05789a> - <@0578ae>): static i16Cle: bool := bool(i16A <= i16B)
	<.main+6958 @05789a> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6963 @05789f> : 21                         load.i16
	<.main+6964 @0578a0> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6969 @0578a5> : 21                         load.i16
	<.main+6970 @0578a6> : 59                         cgt.i32
	<.main+6971 @0578a7> : 0b                         not.b32
	<.main+6972 @0578a8> : 1f 60 56 05 00             load.ref <@055660> ;i16Cle
	<.main+6977 @0578ad> : 25                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@0578ae> - <@0578c1>): static i16Cgt: bool := bool(i16A > i16B)
	<.main+6978 @0578ae> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+6983 @0578b3> : 21                         load.i16
	<.main+6984 @0578b4> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+6989 @0578b9> : 21                         load.i16
	<.main+6990 @0578ba> : 59                         cgt.i32
	<.main+6991 @0578bb> : 1f 68 56 05 00             load.ref <@055668> ;i16Cgt
	<.main+6996 @0578c0> : 25                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@0578c1> - <@0578d5>): static i16Cge: bool := bool(i16A >= i16B)
	<.main+6997 @0578c1> : 1f c8 55 05 00             load.ref <@0555c8> ;i16A
	<.main+7002 @0578c6> : 21                         load.i16
	<.main+7003 @0578c7> : 1f d0 55 05 00             load.ref <@0555d0> ;i16B
	<.main+7008 @0578cc> : 21                         load.i16
	<.main+7009 @0578cd> : 58                         clt.i32
	<.main+7010 @0578ce> : 0b                         not.b32
	<.main+7011 @0578cf> : 1f 70 56 05 00             load.ref <@055670> ;i16Cge
	<.main+7016 @0578d4> : 25                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@0578d5> - <@0578e0>): static u16A: uint16 := a
	<.main+7017 @0578d5> : 1c 60 00 00 00             load.c32 96
	<.main+7022 @0578da> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7027 @0578df> : 26                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@0578e0> - <@0578eb>): static u16B: uint16 := b
	<.main+7028 @0578e0> : 1c 2a 00 00 00             load.c32 42
	<.main+7033 @0578e5> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7038 @0578ea> : 26                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@0578eb> - <@0578f7>): static u16Pls: uint16 := uint16(+u16B)
	<.main+7039 @0578eb> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7044 @0578f0> : 21                         load.i16
	<.main+7045 @0578f1> : 1f 88 56 05 00             load.ref <@055688> ;u16Pls
	<.main+7050 @0578f6> : 26                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@0578f7> - <@057904>): static u16Neg: uint16 := uint16(-u16B)
	<.main+7051 @0578f7> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7056 @0578fc> : 21                         load.i16
	<.main+7057 @0578fd> : 50                         neg.i32
	<.main+7058 @0578fe> : 1f 90 56 05 00             load.ref <@055690> ;u16Neg
	<.main+7063 @057903> : 26                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@057904> - <@057911>): static u16Cmt: uint16 := uint16(~u16B)
	<.main+7064 @057904> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7069 @057909> : 21                         load.i16
	<.main+7070 @05790a> : 30                         cmt.b32
	<.main+7071 @05790b> : 1f 98 56 05 00             load.ref <@055698> ;u16Cmt
	<.main+7076 @057910> : 26                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@057911> - <@057924>): static u16Add: uint16 := uint16(u16A + u16B)
	<.main+7077 @057911> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7082 @057916> : 21                         load.i16
	<.main+7083 @057917> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7088 @05791c> : 21                         load.i16
	<.main+7089 @05791d> : 51                         add.i32
	<.main+7090 @05791e> : 1f a0 56 05 00             load.ref <@0556a0> ;u16Add
	<.main+7095 @057923> : 26                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@057924> - <@057937>): static u16Sub: uint16 := uint16(u16A - u16B)
	<.main+7096 @057924> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7101 @057929> : 21                         load.i16
	<.main+7102 @05792a> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7107 @05792f> : 21                         load.i16
	<.main+7108 @057930> : 52                         sub.i32
	<.main+7109 @057931> : 1f a8 56 05 00             load.ref <@0556a8> ;u16Sub
	<.main+7114 @057936> : 26                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@057937> - <@05794a>): static u16Mul: uint16 := uint16(u16A * u16B)
	<.main+7115 @057937> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7120 @05793c> : 21                         load.i16
	<.main+7121 @05793d> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7126 @057942> : 21                         load.i16
	<.main+7127 @057943> : 33                         mul.u32
	<.main+7128 @057944> : 1f b0 56 05 00             load.ref <@0556b0> ;u16Mul
	<.main+7133 @057949> : 26                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@05794a> - <@05795d>): static u16Div: uint16 := uint16(u16A / u16B)
	<.main+7134 @05794a> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7139 @05794f> : 21                         load.i16
	<.main+7140 @057950> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7145 @057955> : 21                         load.i16
	<.main+7146 @057956> : 34                         div.u32
	<.main+7147 @057957> : 1f b8 56 05 00             load.ref <@0556b8> ;u16Div
	<.main+7152 @05795c> : 26                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@05795d> - <@057970>): static u16Mod: uint16 := uint16(u16A % u16B)
	<.main+7153 @05795d> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7158 @057962> : 21                         load.i16
	<.main+7159 @057963> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7164 @057968> : 21                         load.i16
	<.main+7165 @057969> : 35                         mod.u32
	<.main+7166 @05796a> : 1f c0 56 05 00             load.ref <@0556c0> ;u16Mod
	<.main+7171 @05796f> : 26                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@057970> - <@057983>): static u16And: uint16 := uint16(u16A & u16B)
	<.main+7172 @057970> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7177 @057975> : 21                         load.i16
	<.main+7178 @057976> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7183 @05797b> : 21                         load.i16
	<.main+7184 @05797c> : 31                         and.b32
	<.main+7185 @05797d> : 1f c8 56 05 00             load.ref <@0556c8> ;u16And
	<.main+7190 @057982> : 26                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@057983> - <@057996>): static u16Ior: uint16 := uint16(u16A | u16B)
	<.main+7191 @057983> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7196 @057988> : 21                         load.i16
	<.main+7197 @057989> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7202 @05798e> : 21                         load.i16
	<.main+7203 @05798f> : 32                         or.b32
	<.main+7204 @057990> : 1f d0 56 05 00             load.ref <@0556d0> ;u16Ior
	<.main+7209 @057995> : 26                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@057996> - <@0579a9>): static u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+7210 @057996> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7215 @05799b> : 21                         load.i16
	<.main+7216 @05799c> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7221 @0579a1> : 21                         load.i16
	<.main+7222 @0579a2> : 36                         xor.b32
	<.main+7223 @0579a3> : 1f d8 56 05 00             load.ref <@0556d8> ;u16Xor
	<.main+7228 @0579a8> : 26                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@0579a9> - <@0579ba>): static u16Shl: uint16 := int32((u16A) << shift)
	<.main+7229 @0579a9> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7234 @0579ae> : 21                         load.i16
	<.main+7235 @0579af> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7239 @0579b3> : 3a                         shl.b32
	<.main+7240 @0579b4> : 1f e0 56 05 00             load.ref <@0556e0> ;u16Shl
	<.main+7245 @0579b9> : 26                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@0579ba> - <@0579cb>): static u16Shr: uint16 := int32((u16A) >> shift)
	<.main+7246 @0579ba> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7251 @0579bf> : 21                         load.i16
	<.main+7252 @0579c0> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7256 @0579c4> : 3c                         sar.b32
	<.main+7257 @0579c5> : 1f e8 56 05 00             load.ref <@0556e8> ;u16Shr
	<.main+7262 @0579ca> : 26                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@0579cb> - <@0579d9>): static u16Not: bool := bool(!(u16B))
	<.main+7263 @0579cb> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7268 @0579d0> : 21                         load.i16
	<.main+7269 @0579d1> : 5a                         i32.2bool
	<.main+7270 @0579d2> : 0b                         not.b32
	<.main+7271 @0579d3> : 1f f0 56 05 00             load.ref <@0556f0> ;u16Not
	<.main+7276 @0579d8> : 25                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@0579d9> - <@0579ec>): static u16Ceq: bool := bool(u16A == u16B)
	<.main+7277 @0579d9> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7282 @0579de> : 21                         load.i16
	<.main+7283 @0579df> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7288 @0579e4> : 21                         load.i16
	<.main+7289 @0579e5> : 57                         ceq.i32
	<.main+7290 @0579e6> : 1f f8 56 05 00             load.ref <@0556f8> ;u16Ceq
	<.main+7295 @0579eb> : 25                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@0579ec> - <@057a00>): static u16Cne: bool := bool(u16A != u16B)
	<.main+7296 @0579ec> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7301 @0579f1> : 21                         load.i16
	<.main+7302 @0579f2> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7307 @0579f7> : 21                         load.i16
	<.main+7308 @0579f8> : 57                         ceq.i32
	<.main+7309 @0579f9> : 0b                         not.b32
	<.main+7310 @0579fa> : 1f 00 57 05 00             load.ref <@055700> ;u16Cne
	<.main+7315 @0579ff> : 25                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@057a00> - <@057a13>): static u16Clt: bool := bool(u16A < u16B)
	<.main+7316 @057a00> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7321 @057a05> : 21                         load.i16
	<.main+7322 @057a06> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7327 @057a0b> : 21                         load.i16
	<.main+7328 @057a0c> : 38                         clt.u32
	<.main+7329 @057a0d> : 1f 08 57 05 00             load.ref <@055708> ;u16Clt
	<.main+7334 @057a12> : 25                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@057a13> - <@057a27>): static u16Cle: bool := bool(u16A <= u16B)
	<.main+7335 @057a13> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7340 @057a18> : 21                         load.i16
	<.main+7341 @057a19> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7346 @057a1e> : 21                         load.i16
	<.main+7347 @057a1f> : 39                         cgt.u32
	<.main+7348 @057a20> : 0b                         not.b32
	<.main+7349 @057a21> : 1f 10 57 05 00             load.ref <@055710> ;u16Cle
	<.main+7354 @057a26> : 25                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@057a27> - <@057a3a>): static u16Cgt: bool := bool(u16A > u16B)
	<.main+7355 @057a27> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7360 @057a2c> : 21                         load.i16
	<.main+7361 @057a2d> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7366 @057a32> : 21                         load.i16
	<.main+7367 @057a33> : 39                         cgt.u32
	<.main+7368 @057a34> : 1f 18 57 05 00             load.ref <@055718> ;u16Cgt
	<.main+7373 @057a39> : 25                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@057a3a> - <@057a4e>): static u16Cge: bool := bool(u16A >= u16B)
	<.main+7374 @057a3a> : 1f 78 56 05 00             load.ref <@055678> ;u16A
	<.main+7379 @057a3f> : 21                         load.i16
	<.main+7380 @057a40> : 1f 80 56 05 00             load.ref <@055680> ;u16B
	<.main+7385 @057a45> : 21                         load.i16
	<.main+7386 @057a46> : 38                         clt.u32
	<.main+7387 @057a47> : 0b                         not.b32
	<.main+7388 @057a48> : 1f 20 57 05 00             load.ref <@055720> ;u16Cge
	<.main+7393 @057a4d> : 25                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@057a4e> - <@057a57>): static i32A: int32 := a
	<.main+7394 @057a4e> : 1c 60 00 00 00             load.c32 96
	<.main+7399 @057a53> : 2e 28 57 05                store.m32 <@055728> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@057a57> - <@057a60>): static i32B: int32 := b
	<.main+7403 @057a57> : 1c 2a 00 00 00             load.c32 42
	<.main+7408 @057a5c> : 2e 30 57 05                store.m32 <@055730> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@057a60> - <@057a68>): static i32Pls: int32 := int32(+i32B)
	<.main+7412 @057a60> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7416 @057a64> : 2e 38 57 05                store.m32 <@055738> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@057a68> - <@057a71>): static i32Neg: int32 := int32(-i32B)
	<.main+7420 @057a68> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7424 @057a6c> : 50                         neg.i32
	<.main+7425 @057a6d> : 2e 40 57 05                store.m32 <@055740> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@057a71> - <@057a7a>): static i32Cmt: int32 := int32(~i32B)
	<.main+7429 @057a71> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7433 @057a75> : 30                         cmt.b32
	<.main+7434 @057a76> : 2e 48 57 05                store.m32 <@055748> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@057a7a> - <@057a87>): static i32Add: int32 := int32(i32A + i32B)
	<.main+7438 @057a7a> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7442 @057a7e> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7446 @057a82> : 51                         add.i32
	<.main+7447 @057a83> : 2e 50 57 05                store.m32 <@055750> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@057a87> - <@057a94>): static i32Sub: int32 := int32(i32A - i32B)
	<.main+7451 @057a87> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7455 @057a8b> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7459 @057a8f> : 52                         sub.i32
	<.main+7460 @057a90> : 2e 58 57 05                store.m32 <@055758> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@057a94> - <@057aa1>): static i32Mul: int32 := int32(i32A * i32B)
	<.main+7464 @057a94> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7468 @057a98> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7472 @057a9c> : 53                         mul.i32
	<.main+7473 @057a9d> : 2e 60 57 05                store.m32 <@055760> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@057aa1> - <@057aae>): static i32Div: int32 := int32(i32A / i32B)
	<.main+7477 @057aa1> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7481 @057aa5> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7485 @057aa9> : 54                         div.i32
	<.main+7486 @057aaa> : 2e 68 57 05                store.m32 <@055768> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@057aae> - <@057abb>): static i32Mod: int32 := int32(i32A % i32B)
	<.main+7490 @057aae> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7494 @057ab2> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7498 @057ab6> : 55                         mod.i32
	<.main+7499 @057ab7> : 2e 70 57 05                store.m32 <@055770> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@057abb> - <@057ac8>): static i32And: int32 := int32(i32A & i32B)
	<.main+7503 @057abb> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7507 @057abf> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7511 @057ac3> : 31                         and.b32
	<.main+7512 @057ac4> : 2e 78 57 05                store.m32 <@055778> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@057ac8> - <@057ad5>): static i32Ior: int32 := int32(i32A | i32B)
	<.main+7516 @057ac8> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7520 @057acc> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7524 @057ad0> : 32                         or.b32
	<.main+7525 @057ad1> : 2e 80 57 05                store.m32 <@055780> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@057ad5> - <@057ae2>): static i32Xor: int32 := int32(i32A ^ i32B)
	<.main+7529 @057ad5> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7533 @057ad9> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7537 @057add> : 36                         xor.b32
	<.main+7538 @057ade> : 2e 88 57 05                store.m32 <@055788> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@057ae2> - <@057aef>): static i32Shl: int32 := int32(i32A << shift)
	<.main+7542 @057ae2> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7546 @057ae6> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7550 @057aea> : 3a                         shl.b32
	<.main+7551 @057aeb> : 2e 90 57 05                store.m32 <@055790> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@057aef> - <@057afc>): static i32Shr: int32 := int32(i32A >> shift)
	<.main+7555 @057aef> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7559 @057af3> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7563 @057af7> : 3c                         sar.b32
	<.main+7564 @057af8> : 2e 98 57 05                store.m32 <@055798> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@057afc> - <@057b08>): static i32Not: bool := bool(!(i32B))
	<.main+7568 @057afc> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7572 @057b00> : 5a                         i32.2bool
	<.main+7573 @057b01> : 0b                         not.b32
	<.main+7574 @057b02> : 1f a0 57 05 00             load.ref <@0557a0> ;i32Not
	<.main+7579 @057b07> : 25                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@057b08> - <@057b17>): static i32Ceq: bool := bool(i32A == i32B)
	<.main+7580 @057b08> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7584 @057b0c> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7588 @057b10> : 57                         ceq.i32
	<.main+7589 @057b11> : 1f a8 57 05 00             load.ref <@0557a8> ;i32Ceq
	<.main+7594 @057b16> : 25                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@057b17> - <@057b27>): static i32Cne: bool := bool(i32A != i32B)
	<.main+7595 @057b17> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7599 @057b1b> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7603 @057b1f> : 57                         ceq.i32
	<.main+7604 @057b20> : 0b                         not.b32
	<.main+7605 @057b21> : 1f b0 57 05 00             load.ref <@0557b0> ;i32Cne
	<.main+7610 @057b26> : 25                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@057b27> - <@057b36>): static i32Clt: bool := bool(i32A < i32B)
	<.main+7611 @057b27> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7615 @057b2b> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7619 @057b2f> : 58                         clt.i32
	<.main+7620 @057b30> : 1f b8 57 05 00             load.ref <@0557b8> ;i32Clt
	<.main+7625 @057b35> : 25                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@057b36> - <@057b46>): static i32Cle: bool := bool(i32A <= i32B)
	<.main+7626 @057b36> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7630 @057b3a> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7634 @057b3e> : 59                         cgt.i32
	<.main+7635 @057b3f> : 0b                         not.b32
	<.main+7636 @057b40> : 1f c0 57 05 00             load.ref <@0557c0> ;i32Cle
	<.main+7641 @057b45> : 25                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@057b46> - <@057b55>): static i32Cgt: bool := bool(i32A > i32B)
	<.main+7642 @057b46> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7646 @057b4a> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7650 @057b4e> : 59                         cgt.i32
	<.main+7651 @057b4f> : 1f c8 57 05 00             load.ref <@0557c8> ;i32Cgt
	<.main+7656 @057b54> : 25                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@057b55> - <@057b65>): static i32Cge: bool := bool(i32A >= i32B)
	<.main+7657 @057b55> : 2a 28 57 05                load.m32 <@055728> ;i32A
	<.main+7661 @057b59> : 2a 30 57 05                load.m32 <@055730> ;i32B
	<.main+7665 @057b5d> : 58                         clt.i32
	<.main+7666 @057b5e> : 0b                         not.b32
	<.main+7667 @057b5f> : 1f d0 57 05 00             load.ref <@0557d0> ;i32Cge
	<.main+7672 @057b64> : 25                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@057b65> - <@057b6e>): static u32A: uint32 := a
	<.main+7673 @057b65> : 1c 60 00 00 00             load.c32 96
	<.main+7678 @057b6a> : 2e d8 57 05                store.m32 <@0557d8> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@057b6e> - <@057b77>): static u32B: uint32 := b
	<.main+7682 @057b6e> : 1c 2a 00 00 00             load.c32 42
	<.main+7687 @057b73> : 2e e0 57 05                store.m32 <@0557e0> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@057b77> - <@057b7f>): static u32Pls: uint32 := uint32(+u32B)
	<.main+7691 @057b77> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7695 @057b7b> : 2e e8 57 05                store.m32 <@0557e8> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@057b7f> - <@057b88>): static u32Neg: uint32 := uint32(-u32B)
	<.main+7699 @057b7f> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7703 @057b83> : 50                         neg.i32
	<.main+7704 @057b84> : 2e f0 57 05                store.m32 <@0557f0> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@057b88> - <@057b91>): static u32Cmt: uint32 := uint32(~u32B)
	<.main+7708 @057b88> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7712 @057b8c> : 30                         cmt.b32
	<.main+7713 @057b8d> : 2e f8 57 05                store.m32 <@0557f8> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@057b91> - <@057b9e>): static u32Add: uint32 := uint32(u32A + u32B)
	<.main+7717 @057b91> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7721 @057b95> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7725 @057b99> : 51                         add.i32
	<.main+7726 @057b9a> : 2e 00 58 05                store.m32 <@055800> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@057b9e> - <@057bab>): static u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7730 @057b9e> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7734 @057ba2> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7738 @057ba6> : 52                         sub.i32
	<.main+7739 @057ba7> : 2e 08 58 05                store.m32 <@055808> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@057bab> - <@057bb8>): static u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7743 @057bab> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7747 @057baf> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7751 @057bb3> : 33                         mul.u32
	<.main+7752 @057bb4> : 2e 10 58 05                store.m32 <@055810> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@057bb8> - <@057bc5>): static u32Div: uint32 := uint32(u32A / u32B)
	<.main+7756 @057bb8> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7760 @057bbc> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7764 @057bc0> : 34                         div.u32
	<.main+7765 @057bc1> : 2e 18 58 05                store.m32 <@055818> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@057bc5> - <@057bd2>): static u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7769 @057bc5> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7773 @057bc9> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7777 @057bcd> : 35                         mod.u32
	<.main+7778 @057bce> : 2e 20 58 05                store.m32 <@055820> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@057bd2> - <@057bdf>): static u32And: uint32 := uint32(u32A & u32B)
	<.main+7782 @057bd2> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7786 @057bd6> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7790 @057bda> : 31                         and.b32
	<.main+7791 @057bdb> : 2e 28 58 05                store.m32 <@055828> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@057bdf> - <@057bec>): static u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7795 @057bdf> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7799 @057be3> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7803 @057be7> : 32                         or.b32
	<.main+7804 @057be8> : 2e 30 58 05                store.m32 <@055830> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@057bec> - <@057bf9>): static u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7808 @057bec> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7812 @057bf0> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7816 @057bf4> : 36                         xor.b32
	<.main+7817 @057bf5> : 2e 38 58 05                store.m32 <@055838> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@057bf9> - <@057c06>): static u32Shl: uint32 := uint32(u32A << shift)
	<.main+7821 @057bf9> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7825 @057bfd> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7829 @057c01> : 3a                         shl.b32
	<.main+7830 @057c02> : 2e 40 58 05                store.m32 <@055840> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@057c06> - <@057c13>): static u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7834 @057c06> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7838 @057c0a> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+7842 @057c0e> : 3b                         shr.b32
	<.main+7843 @057c0f> : 2e 48 58 05                store.m32 <@055848> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@057c13> - <@057c1f>): static u32Not: bool := bool(!(u32B))
	<.main+7847 @057c13> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7851 @057c17> : 5a                         i32.2bool
	<.main+7852 @057c18> : 0b                         not.b32
	<.main+7853 @057c19> : 1f 50 58 05 00             load.ref <@055850> ;u32Not
	<.main+7858 @057c1e> : 25                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@057c1f> - <@057c2e>): static u32Ceq: bool := bool(u32A == u32B)
	<.main+7859 @057c1f> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7863 @057c23> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7867 @057c27> : 57                         ceq.i32
	<.main+7868 @057c28> : 1f 58 58 05 00             load.ref <@055858> ;u32Ceq
	<.main+7873 @057c2d> : 25                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@057c2e> - <@057c3e>): static u32Cne: bool := bool(u32A != u32B)
	<.main+7874 @057c2e> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7878 @057c32> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7882 @057c36> : 57                         ceq.i32
	<.main+7883 @057c37> : 0b                         not.b32
	<.main+7884 @057c38> : 1f 60 58 05 00             load.ref <@055860> ;u32Cne
	<.main+7889 @057c3d> : 25                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@057c3e> - <@057c4d>): static u32Clt: bool := bool(u32A < u32B)
	<.main+7890 @057c3e> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7894 @057c42> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7898 @057c46> : 38                         clt.u32
	<.main+7899 @057c47> : 1f 68 58 05 00             load.ref <@055868> ;u32Clt
	<.main+7904 @057c4c> : 25                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@057c4d> - <@057c5d>): static u32Cle: bool := bool(u32A <= u32B)
	<.main+7905 @057c4d> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7909 @057c51> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7913 @057c55> : 39                         cgt.u32
	<.main+7914 @057c56> : 0b                         not.b32
	<.main+7915 @057c57> : 1f 70 58 05 00             load.ref <@055870> ;u32Cle
	<.main+7920 @057c5c> : 25                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@057c5d> - <@057c6c>): static u32Cgt: bool := bool(u32A > u32B)
	<.main+7921 @057c5d> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7925 @057c61> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7929 @057c65> : 39                         cgt.u32
	<.main+7930 @057c66> : 1f 78 58 05 00             load.ref <@055878> ;u32Cgt
	<.main+7935 @057c6b> : 25                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@057c6c> - <@057c7c>): static u32Cge: bool := bool(u32A >= u32B)
	<.main+7936 @057c6c> : 2a d8 57 05                load.m32 <@0557d8> ;u32A
	<.main+7940 @057c70> : 2a e0 57 05                load.m32 <@0557e0> ;u32B
	<.main+7944 @057c74> : 38                         clt.u32
	<.main+7945 @057c75> : 0b                         not.b32
	<.main+7946 @057c76> : 1f 80 58 05 00             load.ref <@055880> ;u32Cge
	<.main+7951 @057c7b> : 25                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@057c7c> - <@057c89>): static i64A: int64 := a
	<.main+7952 @057c7c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+7961 @057c85> : 2d 88 58 05                store.m64 <@055888> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@057c89> - <@057c96>): static i64B: int64 := b
	<.main+7965 @057c89> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+7974 @057c92> : 2d 90 58 05                store.m64 <@055890> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@057c96> - <@057c9e>): static i64Pls: int64 := int64(+i64B)
	<.main+7978 @057c96> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+7982 @057c9a> : 2d 98 58 05                store.m64 <@055898> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@057c9e> - <@057ca7>): static i64Neg: int64 := int64(-i64B)
	<.main+7986 @057c9e> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+7990 @057ca2> : 60                         neg.i64
	<.main+7991 @057ca3> : 2d a0 58 05                store.m64 <@0558a0> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@057ca7> - <@057cb0>): static i64Cmt: int64 := int64(~i64B)
	<.main+7995 @057ca7> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+7999 @057cab> : 40                         cmt.b64
	<.main+8000 @057cac> : 2d a8 58 05                store.m64 <@0558a8> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@057cb0> - <@057cbd>): static i64Add: int64 := int64(i64A + i64B)
	<.main+8004 @057cb0> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8008 @057cb4> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8012 @057cb8> : 61                         add.i64
	<.main+8013 @057cb9> : 2d b0 58 05                store.m64 <@0558b0> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@057cbd> - <@057cca>): static i64Sub: int64 := int64(i64A - i64B)
	<.main+8017 @057cbd> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8021 @057cc1> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8025 @057cc5> : 62                         sub.i64
	<.main+8026 @057cc6> : 2d b8 58 05                store.m64 <@0558b8> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@057cca> - <@057cd7>): static i64Mul: int64 := int64(i64A * i64B)
	<.main+8030 @057cca> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8034 @057cce> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8038 @057cd2> : 63                         mul.i64
	<.main+8039 @057cd3> : 2d c0 58 05                store.m64 <@0558c0> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@057cd7> - <@057ce4>): static i64Div: int64 := int64(i64A / i64B)
	<.main+8043 @057cd7> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8047 @057cdb> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8051 @057cdf> : 64                         div.i64
	<.main+8052 @057ce0> : 2d c8 58 05                store.m64 <@0558c8> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@057ce4> - <@057cf1>): static i64Mod: int64 := int64(i64A % i64B)
	<.main+8056 @057ce4> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8060 @057ce8> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8064 @057cec> : 65                         mod.i64
	<.main+8065 @057ced> : 2d d0 58 05                store.m64 <@0558d0> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@057cf1> - <@057cfe>): static i64And: int64 := int64(i64A & i64B)
	<.main+8069 @057cf1> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8073 @057cf5> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8077 @057cf9> : 41                         and.b64
	<.main+8078 @057cfa> : 2d d8 58 05                store.m64 <@0558d8> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@057cfe> - <@057d0b>): static i64Ior: int64 := int64(i64A | i64B)
	<.main+8082 @057cfe> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8086 @057d02> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8090 @057d06> : 42                         or.b64
	<.main+8091 @057d07> : 2d e0 58 05                store.m64 <@0558e0> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@057d0b> - <@057d18>): static i64Xor: int64 := int64(i64A ^ i64B)
	<.main+8095 @057d0b> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8099 @057d0f> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8103 @057d13> : 46                         xor.b64
	<.main+8104 @057d14> : 2d e8 58 05                store.m64 <@0558e8> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@057d18> - <@057d25>): static i64Shl: int64 := int64(i64A << shift)
	<.main+8108 @057d18> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8112 @057d1c> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+8116 @057d20> : 4a                         shl.b64
	<.main+8117 @057d21> : 2d f0 58 05                store.m64 <@0558f0> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@057d25> - <@057d32>): static i64Shr: int64 := int64(i64A >> shift)
	<.main+8121 @057d25> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8125 @057d29> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+8129 @057d2d> : 4c                         sar.b64
	<.main+8130 @057d2e> : 2d f8 58 05                store.m64 <@0558f8> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@057d32> - <@057d3e>): static i64Not: bool := bool(!(i64B))
	<.main+8134 @057d32> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8138 @057d36> : 6b                         i64.2bool
	<.main+8139 @057d37> : 0b                         not.b32
	<.main+8140 @057d38> : 1f 00 59 05 00             load.ref <@055900> ;i64Not
	<.main+8145 @057d3d> : 25                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@057d3e> - <@057d4d>): static i64Ceq: bool := bool(i64A == i64B)
	<.main+8146 @057d3e> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8150 @057d42> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8154 @057d46> : 67                         ceq.i64
	<.main+8155 @057d47> : 1f 08 59 05 00             load.ref <@055908> ;i64Ceq
	<.main+8160 @057d4c> : 25                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@057d4d> - <@057d5d>): static i64Cne: bool := bool(i64A != i64B)
	<.main+8161 @057d4d> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8165 @057d51> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8169 @057d55> : 67                         ceq.i64
	<.main+8170 @057d56> : 0b                         not.b32
	<.main+8171 @057d57> : 1f 10 59 05 00             load.ref <@055910> ;i64Cne
	<.main+8176 @057d5c> : 25                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@057d5d> - <@057d6c>): static i64Clt: bool := bool(i64A < i64B)
	<.main+8177 @057d5d> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8181 @057d61> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8185 @057d65> : 68                         clt.i64
	<.main+8186 @057d66> : 1f 18 59 05 00             load.ref <@055918> ;i64Clt
	<.main+8191 @057d6b> : 25                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@057d6c> - <@057d7c>): static i64Cle: bool := bool(i64A <= i64B)
	<.main+8192 @057d6c> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8196 @057d70> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8200 @057d74> : 69                         cgt.i64
	<.main+8201 @057d75> : 0b                         not.b32
	<.main+8202 @057d76> : 1f 20 59 05 00             load.ref <@055920> ;i64Cle
	<.main+8207 @057d7b> : 25                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@057d7c> - <@057d8b>): static i64Cgt: bool := bool(i64A > i64B)
	<.main+8208 @057d7c> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8212 @057d80> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8216 @057d84> : 69                         cgt.i64
	<.main+8217 @057d85> : 1f 28 59 05 00             load.ref <@055928> ;i64Cgt
	<.main+8222 @057d8a> : 25                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@057d8b> - <@057d9b>): static i64Cge: bool := bool(i64A >= i64B)
	<.main+8223 @057d8b> : 2b 88 58 05                load.m64 <@055888> ;i64A
	<.main+8227 @057d8f> : 2b 90 58 05                load.m64 <@055890> ;i64B
	<.main+8231 @057d93> : 68                         clt.i64
	<.main+8232 @057d94> : 0b                         not.b32
	<.main+8233 @057d95> : 1f 30 59 05 00             load.ref <@055930> ;i64Cge
	<.main+8238 @057d9a> : 25                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@057d9b> - <@057da8>): static u64A: uint64 := a
	<.main+8239 @057d9b> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8248 @057da4> : 2d 38 59 05                store.m64 <@055938> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@057da8> - <@057db5>): static u64B: uint64 := b
	<.main+8252 @057da8> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8261 @057db1> : 2d 40 59 05                store.m64 <@055940> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@057db5> - <@057dbd>): static u64Pls: uint64 := uint64(+u64B)
	<.main+8265 @057db5> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8269 @057db9> : 2d 48 59 05                store.m64 <@055948> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@057dbd> - <@057dc6>): static u64Neg: uint64 := uint64(-u64B)
	<.main+8273 @057dbd> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8277 @057dc1> : 60                         neg.i64
	<.main+8278 @057dc2> : 2d 50 59 05                store.m64 <@055950> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@057dc6> - <@057dcf>): static u64Cmt: uint64 := uint64(~u64B)
	<.main+8282 @057dc6> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8286 @057dca> : 40                         cmt.b64
	<.main+8287 @057dcb> : 2d 58 59 05                store.m64 <@055958> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@057dcf> - <@057ddc>): static u64Add: uint64 := uint64(u64A + u64B)
	<.main+8291 @057dcf> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8295 @057dd3> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8299 @057dd7> : 61                         add.i64
	<.main+8300 @057dd8> : 2d 60 59 05                store.m64 <@055960> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@057ddc> - <@057de9>): static u64Sub: uint64 := uint64(u64A - u64B)
	<.main+8304 @057ddc> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8308 @057de0> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8312 @057de4> : 62                         sub.i64
	<.main+8313 @057de5> : 2d 68 59 05                store.m64 <@055968> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@057de9> - <@057df6>): static u64Mul: uint64 := uint64(u64A * u64B)
	<.main+8317 @057de9> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8321 @057ded> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8325 @057df1> : 43                         mul.u64
	<.main+8326 @057df2> : 2d 70 59 05                store.m64 <@055970> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@057df6> - <@057e03>): static u64Div: uint64 := uint64(u64A / u64B)
	<.main+8330 @057df6> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8334 @057dfa> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8338 @057dfe> : 44                         div.u64
	<.main+8339 @057dff> : 2d 78 59 05                store.m64 <@055978> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@057e03> - <@057e10>): static u64Mod: uint64 := uint64(u64A % u64B)
	<.main+8343 @057e03> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8347 @057e07> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8351 @057e0b> : 45                         mod.u64
	<.main+8352 @057e0c> : 2d 80 59 05                store.m64 <@055980> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@057e10> - <@057e1d>): static u64And: uint64 := uint64(u64A & u64B)
	<.main+8356 @057e10> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8360 @057e14> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8364 @057e18> : 41                         and.b64
	<.main+8365 @057e19> : 2d 88 59 05                store.m64 <@055988> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@057e1d> - <@057e2a>): static u64Ior: uint64 := uint64(u64A | u64B)
	<.main+8369 @057e1d> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8373 @057e21> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8377 @057e25> : 42                         or.b64
	<.main+8378 @057e26> : 2d 90 59 05                store.m64 <@055990> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@057e2a> - <@057e37>): static u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+8382 @057e2a> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8386 @057e2e> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8390 @057e32> : 46                         xor.b64
	<.main+8391 @057e33> : 2d 98 59 05                store.m64 <@055998> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@057e37> - <@057e44>): static u64Shl: uint64 := uint64(u64A << shift)
	<.main+8395 @057e37> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8399 @057e3b> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+8403 @057e3f> : 4a                         shl.b64
	<.main+8404 @057e40> : 2d a0 59 05                store.m64 <@0559a0> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@057e44> - <@057e51>): static u64Shr: uint64 := uint64(u64A >> shift)
	<.main+8408 @057e44> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8412 @057e48> : 2a 50 53 05                load.m32 <@055350> ;shift
	<.main+8416 @057e4c> : 4b                         shr.b64
	<.main+8417 @057e4d> : 2d a8 59 05                store.m64 <@0559a8> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@057e51> - <@057e5d>): static u64Not: bool := bool(!(u64B))
	<.main+8421 @057e51> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8425 @057e55> : 6b                         i64.2bool
	<.main+8426 @057e56> : 0b                         not.b32
	<.main+8427 @057e57> : 1f b0 59 05 00             load.ref <@0559b0> ;u64Not
	<.main+8432 @057e5c> : 25                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@057e5d> - <@057e6c>): static u64Ceq: bool := bool(u64A == u64B)
	<.main+8433 @057e5d> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8437 @057e61> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8441 @057e65> : 67                         ceq.i64
	<.main+8442 @057e66> : 1f b8 59 05 00             load.ref <@0559b8> ;u64Ceq
	<.main+8447 @057e6b> : 25                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@057e6c> - <@057e7c>): static u64Cne: bool := bool(u64A != u64B)
	<.main+8448 @057e6c> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8452 @057e70> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8456 @057e74> : 67                         ceq.i64
	<.main+8457 @057e75> : 0b                         not.b32
	<.main+8458 @057e76> : 1f c0 59 05 00             load.ref <@0559c0> ;u64Cne
	<.main+8463 @057e7b> : 25                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@057e7c> - <@057e8b>): static u64Clt: bool := bool(u64A < u64B)
	<.main+8464 @057e7c> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8468 @057e80> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8472 @057e84> : 48                         clt.u64
	<.main+8473 @057e85> : 1f c8 59 05 00             load.ref <@0559c8> ;u64Clt
	<.main+8478 @057e8a> : 25                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@057e8b> - <@057e9b>): static u64Cle: bool := bool(u64A <= u64B)
	<.main+8479 @057e8b> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8483 @057e8f> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8487 @057e93> : 49                         cgt.u64
	<.main+8488 @057e94> : 0b                         not.b32
	<.main+8489 @057e95> : 1f d0 59 05 00             load.ref <@0559d0> ;u64Cle
	<.main+8494 @057e9a> : 25                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@057e9b> - <@057eaa>): static u64Cgt: bool := bool(u64A > u64B)
	<.main+8495 @057e9b> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8499 @057e9f> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8503 @057ea3> : 49                         cgt.u64
	<.main+8504 @057ea4> : 1f d8 59 05 00             load.ref <@0559d8> ;u64Cgt
	<.main+8509 @057ea9> : 25                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@057eaa> - <@057eba>): static u64Cge: bool := bool(u64A >= u64B)
	<.main+8510 @057eaa> : 2b 38 59 05                load.m64 <@055938> ;u64A
	<.main+8514 @057eae> : 2b 40 59 05                load.m64 <@055940> ;u64B
	<.main+8518 @057eb2> : 48                         clt.u64
	<.main+8519 @057eb3> : 0b                         not.b32
	<.main+8520 @057eb4> : 1f e0 59 05 00             load.ref <@0559e0> ;u64Cge
	<.main+8525 @057eb9> : 25                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@057eba> - <@057ec3>): static f32A: float32 := a
	<.main+8526 @057eba> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8531 @057ebf> : 2e e8 59 05                store.m32 <@0559e8> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@057ec3> - <@057ecc>): static f32B: float32 := b
	<.main+8535 @057ec3> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8540 @057ec8> : 2e f0 59 05                store.m32 <@0559f0> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@057ecc> - <@057ed4>): static f32Pls: float32 := float32(+f32B)
	<.main+8544 @057ecc> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8548 @057ed0> : 2e f8 59 05                store.m32 <@0559f8> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@057ed4> - <@057edd>): static f32Neg: float32 := float32(-f32B)
	<.main+8552 @057ed4> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8556 @057ed8> : 70                         neg.f32
	<.main+8557 @057ed9> : 2e 00 5a 05                store.m32 <@055a00> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@057edd> - <@057eea>): static f32Add: float32 := float32(f32A + f32B)
	<.main+8561 @057edd> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8565 @057ee1> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8569 @057ee5> : 71                         add.f32
	<.main+8570 @057ee6> : 2e 08 5a 05                store.m32 <@055a08> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@057eea> - <@057ef7>): static f32Sub: float32 := float32(f32A - f32B)
	<.main+8574 @057eea> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8578 @057eee> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8582 @057ef2> : 72                         sub.f32
	<.main+8583 @057ef3> : 2e 10 5a 05                store.m32 <@055a10> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@057ef7> - <@057f04>): static f32Mul: float32 := float32(f32A * f32B)
	<.main+8587 @057ef7> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8591 @057efb> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8595 @057eff> : 73                         mul.f32
	<.main+8596 @057f00> : 2e 18 5a 05                store.m32 <@055a18> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@057f04> - <@057f11>): static f32Div: float32 := float32(f32A / f32B)
	<.main+8600 @057f04> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8604 @057f08> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8608 @057f0c> : 74                         div.f32
	<.main+8609 @057f0d> : 2e 20 5a 05                store.m32 <@055a20> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@057f11> - <@057f1e>): static f32Mod: float32 := float32(f32A % f32B)
	<.main+8613 @057f11> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8617 @057f15> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8621 @057f19> : 75                         mod.f32
	<.main+8622 @057f1a> : 2e 28 5a 05                store.m32 <@055a28> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@057f1e> - <@057f2a>): static f32Not: bool := bool(!(f32B))
	<.main+8626 @057f1e> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8630 @057f22> : 7c                         f32.2bool
	<.main+8631 @057f23> : 0b                         not.b32
	<.main+8632 @057f24> : 1f 30 5a 05 00             load.ref <@055a30> ;f32Not
	<.main+8637 @057f29> : 25                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@057f2a> - <@057f39>): static f32Ceq: bool := bool(f32A == f32B)
	<.main+8638 @057f2a> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8642 @057f2e> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8646 @057f32> : 77                         ceq.f32
	<.main+8647 @057f33> : 1f 38 5a 05 00             load.ref <@055a38> ;f32Ceq
	<.main+8652 @057f38> : 25                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@057f39> - <@057f49>): static f32Cne: bool := bool(f32A != f32B)
	<.main+8653 @057f39> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8657 @057f3d> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8661 @057f41> : 77                         ceq.f32
	<.main+8662 @057f42> : 0b                         not.b32
	<.main+8663 @057f43> : 1f 40 5a 05 00             load.ref <@055a40> ;f32Cne
	<.main+8668 @057f48> : 25                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@057f49> - <@057f58>): static f32Clt: bool := bool(f32A < f32B)
	<.main+8669 @057f49> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8673 @057f4d> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8677 @057f51> : 78                         clt.f32
	<.main+8678 @057f52> : 1f 48 5a 05 00             load.ref <@055a48> ;f32Clt
	<.main+8683 @057f57> : 25                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@057f58> - <@057f68>): static f32Cle: bool := bool(f32A <= f32B)
	<.main+8684 @057f58> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8688 @057f5c> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8692 @057f60> : 79                         cgt.f32
	<.main+8693 @057f61> : 0b                         not.b32
	<.main+8694 @057f62> : 1f 50 5a 05 00             load.ref <@055a50> ;f32Cle
	<.main+8699 @057f67> : 25                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@057f68> - <@057f77>): static f32Cgt: bool := bool(f32A > f32B)
	<.main+8700 @057f68> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8704 @057f6c> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8708 @057f70> : 79                         cgt.f32
	<.main+8709 @057f71> : 1f 58 5a 05 00             load.ref <@055a58> ;f32Cgt
	<.main+8714 @057f76> : 25                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@057f77> - <@057f87>): static f32Cge: bool := bool(f32A >= f32B)
	<.main+8715 @057f77> : 2a e8 59 05                load.m32 <@0559e8> ;f32A
	<.main+8719 @057f7b> : 2a f0 59 05                load.m32 <@0559f0> ;f32B
	<.main+8723 @057f7f> : 78                         clt.f32
	<.main+8724 @057f80> : 0b                         not.b32
	<.main+8725 @057f81> : 1f 60 5a 05 00             load.ref <@055a60> ;f32Cge
	<.main+8730 @057f86> : 25                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@057f87> - <@057f94>): static f64A: float64 := a
	<.main+8731 @057f87> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8740 @057f90> : 2d 68 5a 05                store.m64 <@055a68> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@057f94> - <@057fa1>): static f64B: float64 := b
	<.main+8744 @057f94> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8753 @057f9d> : 2d 70 5a 05                store.m64 <@055a70> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@057fa1> - <@057fa9>): static f64Pls: float64 := float64(+f64B)
	<.main+8757 @057fa1> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8761 @057fa5> : 2d 78 5a 05                store.m64 <@055a78> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@057fa9> - <@057fb2>): static f64Neg: float64 := float64(-f64B)
	<.main+8765 @057fa9> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8769 @057fad> : 80                         neg.f64
	<.main+8770 @057fae> : 2d 80 5a 05                store.m64 <@055a80> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@057fb2> - <@057fbf>): static f64Add: float64 := float64(f64A + f64B)
	<.main+8774 @057fb2> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8778 @057fb6> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8782 @057fba> : 81                         add.f64
	<.main+8783 @057fbb> : 2d 88 5a 05                store.m64 <@055a88> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@057fbf> - <@057fcc>): static f64Sub: float64 := float64(f64A - f64B)
	<.main+8787 @057fbf> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8791 @057fc3> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8795 @057fc7> : 82                         sub.f64
	<.main+8796 @057fc8> : 2d 90 5a 05                store.m64 <@055a90> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@057fcc> - <@057fd9>): static f64Mul: float64 := float64(f64A * f64B)
	<.main+8800 @057fcc> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8804 @057fd0> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8808 @057fd4> : 83                         mul.f64
	<.main+8809 @057fd5> : 2d 98 5a 05                store.m64 <@055a98> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@057fd9> - <@057fe6>): static f64Div: float64 := float64(f64A / f64B)
	<.main+8813 @057fd9> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8817 @057fdd> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8821 @057fe1> : 84                         div.f64
	<.main+8822 @057fe2> : 2d a0 5a 05                store.m64 <@055aa0> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@057fe6> - <@057ff3>): static f64Mod: float64 := float64(f64A % f64B)
	<.main+8826 @057fe6> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8830 @057fea> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8834 @057fee> : 85                         mod.f64
	<.main+8835 @057fef> : 2d a8 5a 05                store.m64 <@055aa8> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@057ff3> - <@057fff>): static f64Not: bool := bool(!(f64B))
	<.main+8839 @057ff3> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8843 @057ff7> : 8d                         f64.2bool
	<.main+8844 @057ff8> : 0b                         not.b32
	<.main+8845 @057ff9> : 1f b0 5a 05 00             load.ref <@055ab0> ;f64Not
	<.main+8850 @057ffe> : 25                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@057fff> - <@05800e>): static f64Ceq: bool := bool(f64A == f64B)
	<.main+8851 @057fff> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8855 @058003> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8859 @058007> : 87                         ceq.f64
	<.main+8860 @058008> : 1f b8 5a 05 00             load.ref <@055ab8> ;f64Ceq
	<.main+8865 @05800d> : 25                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@05800e> - <@05801e>): static f64Cne: bool := bool(f64A != f64B)
	<.main+8866 @05800e> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8870 @058012> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8874 @058016> : 87                         ceq.f64
	<.main+8875 @058017> : 0b                         not.b32
	<.main+8876 @058018> : 1f c0 5a 05 00             load.ref <@055ac0> ;f64Cne
	<.main+8881 @05801d> : 25                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@05801e> - <@05802d>): static f64Clt: bool := bool(f64A < f64B)
	<.main+8882 @05801e> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8886 @058022> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8890 @058026> : 88                         clt.f64
	<.main+8891 @058027> : 1f c8 5a 05 00             load.ref <@055ac8> ;f64Clt
	<.main+8896 @05802c> : 25                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@05802d> - <@05803d>): static f64Cle: bool := bool(f64A <= f64B)
	<.main+8897 @05802d> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8901 @058031> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8905 @058035> : 89                         cgt.f64
	<.main+8906 @058036> : 0b                         not.b32
	<.main+8907 @058037> : 1f d0 5a 05 00             load.ref <@055ad0> ;f64Cle
	<.main+8912 @05803c> : 25                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@05803d> - <@05804c>): static f64Cgt: bool := bool(f64A > f64B)
	<.main+8913 @05803d> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8917 @058041> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8921 @058045> : 89                         cgt.f64
	<.main+8922 @058046> : 1f d8 5a 05 00             load.ref <@055ad8> ;f64Cgt
	<.main+8927 @05804b> : 25                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@05804c> - <@05805c>): static f64Cge: bool := bool(f64A >= f64B)
	<.main+8928 @05804c> : 2b 68 5a 05                load.m64 <@055a68> ;f64A
	<.main+8932 @058050> : 2b 70 5a 05                load.m64 <@055a70> ;f64B
	<.main+8936 @058054> : 88                         clt.f64
	<.main+8937 @058055> : 0b                         not.b32
	<.main+8938 @058056> : 1f e0 5a 05 00             load.ref <@055ae0> ;f64Cge
	<.main+8943 @05805b> : 25                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@05805c> - <@058065>): static ptrA: pointer := null
	<.main+8944 @05805c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8949 @058061> : 2e e8 5a 05                store.m32 <@055ae8> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@058065> - <@05806e>): static ptrB: pointer := pointer(shift)
	<.main+8953 @058065> : 1f 50 53 05 00             load.ref <@055350> ;shift
	<.main+8958 @05806a> : 2e f0 5a 05                store.m32 <@055af0> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@05806e> - <@05807d>): static ptrCeq: bool := bool(ptrA == ptrB)
	<.main+8962 @05806e> : 2a e8 5a 05                load.m32 <@055ae8> ;ptrA
	<.main+8966 @058072> : 2a f0 5a 05                load.m32 <@055af0> ;ptrB
	<.main+8970 @058076> : 57                         ceq.i32
	<.main+8971 @058077> : 1f f8 5a 05 00             load.ref <@055af8> ;ptrCeq
	<.main+8976 @05807c> : 25                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@05807d> - <@05808d>): static ptrCne: bool := bool(ptrA != ptrB)
	<.main+8977 @05807d> : 2a e8 5a 05                load.m32 <@055ae8> ;ptrA
	<.main+8981 @058081> : 2a f0 5a 05                load.m32 <@055af0> ;ptrB
	<.main+8985 @058085> : 57                         ceq.i32
	<.main+8986 @058086> : 0b                         not.b32
	<.main+8987 @058087> : 1f 00 5b 05 00             load.ref <@055b00> ;ptrCne
	<.main+8992 @05808c> : 25                         store.i8
	test/lang/statementIf.ci:26: (5 bytes: <@05808d> - <@058092>): static t: int32 := 0
	<.main+8993 @05808d> : 19                         load.z32
	<.main+8994 @05808e> : 2e 08 5b 05                store.m32 <@055b08> ;t
	test/lang/statementFor.ci:12: (5 bytes: <@058092> - <@058097>): static forIdx: int32
	<.main+8998 @058092> : 19                         load.z32
	<.main+8999 @058093> : 2e 10 5b 05                store.m32 <@055b10> ;forIdx
	test/stdc/test.math.ci:3: (24 bytes: <@058097> - <@0580af>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9003 @058097> : 1a                         load.z64
	<.main+9004 @058098> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9013 @0580a1> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9018 @0580a6> : 02                         call
	<.main+9019 @0580a7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9023 @0580ab> : 2d 18 5b 05                store.m64 <@055b18> ;testMathFloor_1
	test/stdc/test.math.ci:4: (24 bytes: <@0580af> - <@0580c7>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9027 @0580af> : 1a                         load.z64
	<.main+9028 @0580b0> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9037 @0580b9> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9042 @0580be> : 02                         call
	<.main+9043 @0580bf> : 09 f8 ff ff                inc.sp(-8)
	<.main+9047 @0580c3> : 2d 20 5b 05                store.m64 <@055b20> ;testMathFloor_2
	test/stdc/test.math.ci:5: (24 bytes: <@0580c7> - <@0580df>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9051 @0580c7> : 1a                         load.z64
	<.main+9052 @0580c8> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9061 @0580d1> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9066 @0580d6> : 02                         call
	<.main+9067 @0580d7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9071 @0580db> : 2d 28 5b 05                store.m64 <@055b28> ;testMathFloor_3
	test/stdc/test.math.ci:6: (24 bytes: <@0580df> - <@0580f7>): static testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+9075 @0580df> : 1a                         load.z64
	<.main+9076 @0580e0> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9085 @0580e9> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9090 @0580ee> : 02                         call
	<.main+9091 @0580ef> : 09 f8 ff ff                inc.sp(-8)
	<.main+9095 @0580f3> : 2d 30 5b 05                store.m64 <@055b30> ;testMathFloor_4
	test/stdc/test.math.ci:7: (24 bytes: <@0580f7> - <@05810f>): static testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+9099 @0580f7> : 1a                         load.z64
	<.main+9100 @0580f8> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9109 @058101> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9114 @058106> : 02                         call
	<.main+9115 @058107> : 09 f8 ff ff                inc.sp(-8)
	<.main+9119 @05810b> : 2d 38 5b 05                store.m64 <@055b38> ;testMathFloor_5
	test/stdc/test.math.ci:8: (24 bytes: <@05810f> - <@058127>): static testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+9123 @05810f> : 1a                         load.z64
	<.main+9124 @058110> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9133 @058119> : 1f 98 34 05 00             load.ref <@053498> ;Math.floor(x: float64): float64
	<.main+9138 @05811e> : 02                         call
	<.main+9139 @05811f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9143 @058123> : 2d 40 5b 05                store.m64 <@055b40> ;testMathFloor_6
	test/stdc/test.math.ci:10: (29 bytes: <@058127> - <@058144>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9147 @058127> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9156 @058130> : 11 00                      dup.x64 sp(0)
	<.main+9158 @058132> : 1a                         load.z64
	<.main+9159 @058133> : 89                         cgt.f64
	<.main+9160 @058134> : 11 01                      dup.x64 sp(1)
	<.main+9162 @058136> : 1a                         load.z64
	<.main+9163 @058137> : 88                         clt.f64
	<.main+9164 @058138> : 52                         sub.i32
	<.main+9165 @058139> : 13 02                      set.x32 sp(2)
	<.main+9167 @05813b> : 09 fc ff ff                inc.sp(-4)
	<.main+9171 @05813f> : 5d                         i32.2f64
	<.main+9172 @058140> : 2d 48 5b 05                store.m64 <@055b48> ;testMathSign_1F
	test/stdc/test.math.ci:11: (21 bytes: <@058144> - <@058159>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9176 @058144> : 1a                         load.z64
	<.main+9177 @058145> : 11 00                      dup.x64 sp(0)
	<.main+9179 @058147> : 1a                         load.z64
	<.main+9180 @058148> : 89                         cgt.f64
	<.main+9181 @058149> : 11 01                      dup.x64 sp(1)
	<.main+9183 @05814b> : 1a                         load.z64
	<.main+9184 @05814c> : 88                         clt.f64
	<.main+9185 @05814d> : 52                         sub.i32
	<.main+9186 @05814e> : 13 02                      set.x32 sp(2)
	<.main+9188 @058150> : 09 fc ff ff                inc.sp(-4)
	<.main+9192 @058154> : 5d                         i32.2f64
	<.main+9193 @058155> : 2d 50 5b 05                store.m64 <@055b50> ;testMathSign_2F
	test/stdc/test.math.ci:12: (29 bytes: <@058159> - <@058176>): static testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+9197 @058159> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9206 @058162> : 11 00                      dup.x64 sp(0)
	<.main+9208 @058164> : 1a                         load.z64
	<.main+9209 @058165> : 89                         cgt.f64
	<.main+9210 @058166> : 11 01                      dup.x64 sp(1)
	<.main+9212 @058168> : 1a                         load.z64
	<.main+9213 @058169> : 88                         clt.f64
	<.main+9214 @05816a> : 52                         sub.i32
	<.main+9215 @05816b> : 13 02                      set.x32 sp(2)
	<.main+9217 @05816d> : 09 fc ff ff                inc.sp(-4)
	<.main+9221 @058171> : 5d                         i32.2f64
	<.main+9222 @058172> : 2d 58 5b 05                store.m64 <@055b58> ;testMathSign_3F
	test/stdc/test.math.ci:13: (21 bytes: <@058176> - <@05818b>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9226 @058176> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9231 @05817b> : 10 00                      dup.x32 sp(0)
	<.main+9233 @05817d> : 19                         load.z32
	<.main+9234 @05817e> : 79                         cgt.f32
	<.main+9235 @05817f> : 10 01                      dup.x32 sp(1)
	<.main+9237 @058181> : 19                         load.z32
	<.main+9238 @058182> : 78                         clt.f32
	<.main+9239 @058183> : 52                         sub.i32
	<.main+9240 @058184> : 13 01                      set.x32 sp(1)
	<.main+9242 @058186> : 5d                         i32.2f64
	<.main+9243 @058187> : 2d 60 5b 05                store.m64 <@055b60> ;testMathSign_1f
	test/stdc/test.math.ci:14: (17 bytes: <@05818b> - <@05819c>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9247 @05818b> : 19                         load.z32
	<.main+9248 @05818c> : 10 00                      dup.x32 sp(0)
	<.main+9250 @05818e> : 19                         load.z32
	<.main+9251 @05818f> : 79                         cgt.f32
	<.main+9252 @058190> : 10 01                      dup.x32 sp(1)
	<.main+9254 @058192> : 19                         load.z32
	<.main+9255 @058193> : 78                         clt.f32
	<.main+9256 @058194> : 52                         sub.i32
	<.main+9257 @058195> : 13 01                      set.x32 sp(1)
	<.main+9259 @058197> : 5d                         i32.2f64
	<.main+9260 @058198> : 2d 68 5b 05                store.m64 <@055b68> ;testMathSign_2f
	test/stdc/test.math.ci:15: (21 bytes: <@05819c> - <@0581b1>): static testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+9264 @05819c> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9269 @0581a1> : 10 00                      dup.x32 sp(0)
	<.main+9271 @0581a3> : 19                         load.z32
	<.main+9272 @0581a4> : 79                         cgt.f32
	<.main+9273 @0581a5> : 10 01                      dup.x32 sp(1)
	<.main+9275 @0581a7> : 19                         load.z32
	<.main+9276 @0581a8> : 78                         clt.f32
	<.main+9277 @0581a9> : 52                         sub.i32
	<.main+9278 @0581aa> : 13 01                      set.x32 sp(1)
	<.main+9280 @0581ac> : 5d                         i32.2f64
	<.main+9281 @0581ad> : 2d 70 5b 05                store.m64 <@055b70> ;testMathSign_3f
	test/stdc/test.math.ci:17: (24 bytes: <@0581b1> - <@0581c9>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9285 @0581b1> : 1a                         load.z64
	<.main+9286 @0581b2> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9295 @0581bb> : 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<.main+9300 @0581c0> : 02                         call
	<.main+9301 @0581c1> : 09 f8 ff ff                inc.sp(-8)
	<.main+9305 @0581c5> : 2d 78 5b 05                store.m64 <@055b78> ;testMathAbs_1F
	test/stdc/test.math.ci:18: (15 bytes: <@0581c9> - <@0581d8>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9309 @0581c9> : 1b                         load.z128
	<.main+9310 @0581ca> : 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<.main+9315 @0581cf> : 02                         call
	<.main+9316 @0581d0> : 09 f8 ff ff                inc.sp(-8)
	<.main+9320 @0581d4> : 2d 80 5b 05                store.m64 <@055b80> ;testMathAbs_2F
	test/stdc/test.math.ci:19: (24 bytes: <@0581d8> - <@0581f0>): static testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+9324 @0581d8> : 1a                         load.z64
	<.main+9325 @0581d9> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9334 @0581e2> : 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<.main+9339 @0581e7> : 02                         call
	<.main+9340 @0581e8> : 09 f8 ff ff                inc.sp(-8)
	<.main+9344 @0581ec> : 2d 88 5b 05                store.m64 <@055b88> ;testMathAbs_3F
	test/stdc/test.math.ci:20: (21 bytes: <@0581f0> - <@058205>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9348 @0581f0> : 19                         load.z32
	<.main+9349 @0581f1> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9354 @0581f6> : 1f b0 34 05 00             load.ref <@0534b0> ;Math.abs(x: float32): float32
	<.main+9359 @0581fb> : 02                         call
	<.main+9360 @0581fc> : 09 fc ff ff                inc.sp(-4)
	<.main+9364 @058200> : 7d                         f32.2f64
	<.main+9365 @058201> : 2d 90 5b 05                store.m64 <@055b90> ;testMathAbs_1f
	test/stdc/test.math.ci:21: (17 bytes: <@058205> - <@058216>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9369 @058205> : 19                         load.z32
	<.main+9370 @058206> : 19                         load.z32
	<.main+9371 @058207> : 1f b0 34 05 00             load.ref <@0534b0> ;Math.abs(x: float32): float32
	<.main+9376 @05820c> : 02                         call
	<.main+9377 @05820d> : 09 fc ff ff                inc.sp(-4)
	<.main+9381 @058211> : 7d                         f32.2f64
	<.main+9382 @058212> : 2d 98 5b 05                store.m64 <@055b98> ;testMathAbs_2f
	test/stdc/test.math.ci:22: (21 bytes: <@058216> - <@05822b>): static testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+9386 @058216> : 19                         load.z32
	<.main+9387 @058217> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9392 @05821c> : 1f b0 34 05 00             load.ref <@0534b0> ;Math.abs(x: float32): float32
	<.main+9397 @058221> : 02                         call
	<.main+9398 @058222> : 09 fc ff ff                inc.sp(-4)
	<.main+9402 @058226> : 7d                         f32.2f64
	<.main+9403 @058227> : 2d a0 5b 05                store.m64 <@055ba0> ;testMathAbs_3f
	test/stdc/test.math.ci:24: (26 bytes: <@05822b> - <@058245>): static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9407 @05822b> : 19                         load.z32
	<.main+9408 @05822c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9413 @058231> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9418 @058236> : 1f 20 35 05 00             load.ref <@053520> ;Math.min(a: float32, b: float32): float32
	<.main+9423 @05823b> : 02                         call
	<.main+9424 @05823c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9428 @058240> : 7d                         f32.2f64
	<.main+9429 @058241> : 2d a8 5b 05                store.m64 <@055ba8> ;testMathMin_1f
	test/stdc/test.math.ci:25: (26 bytes: <@058245> - <@05825f>): static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9433 @058245> : 19                         load.z32
	<.main+9434 @058246> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9439 @05824b> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9444 @058250> : 1f 50 35 05 00             load.ref <@053550> ;Math.max(a: float32, b: float32): float32
	<.main+9449 @058255> : 02                         call
	<.main+9450 @058256> : 09 f8 ff ff                inc.sp(-8)
	<.main+9454 @05825a> : 7d                         f32.2f64
	<.main+9455 @05825b> : 2d b0 5b 05                store.m64 <@055bb0> ;testMathMax_2f
	test/stdc/test.math.ci:26: (33 bytes: <@05825f> - <@058280>): static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9459 @05825f> : 1a                         load.z64
	<.main+9460 @058260> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9469 @058269> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9478 @058272> : 1f 38 35 05 00             load.ref <@053538> ;Math.min(a: float64, b: float64): float64
	<.main+9483 @058277> : 02                         call
	<.main+9484 @058278> : 09 f0 ff ff                inc.sp(-16)
	<.main+9488 @05827c> : 2d b8 5b 05                store.m64 <@055bb8> ;testMathMin_1F
	test/stdc/test.math.ci:27: (33 bytes: <@058280> - <@0582a1>): static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9492 @058280> : 1a                         load.z64
	<.main+9493 @058281> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9502 @05828a> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9511 @058293> : 1f 68 35 05 00             load.ref <@053568> ;Math.max(a: float64, b: float64): float64
	<.main+9516 @058298> : 02                         call
	<.main+9517 @058299> : 09 f0 ff ff                inc.sp(-16)
	<.main+9521 @05829d> : 2d c0 5b 05                store.m64 <@055bc0> ;testMathMax_2F
	test/stdc/test.math.ci:29: (27 bytes: <@0582a1> - <@0582bc>): static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9525 @0582a1> : 19                         load.z32
	<.main+9526 @0582a2> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9531 @0582a7> : 19                         load.z32
	<.main+9532 @0582a8> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9537 @0582ad> : 1f 80 35 05 00             load.ref <@053580> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9542 @0582b2> : 02                         call
	<.main+9543 @0582b3> : 09 f4 ff ff                inc.sp(-12)
	<.main+9547 @0582b7> : 7d                         f32.2f64
	<.main+9548 @0582b8> : 2d c8 5b 05                store.m64 <@055bc8> ;testMathClamp_1f
	test/stdc/test.math.ci:30: (34 bytes: <@0582bc> - <@0582de>): static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9552 @0582bc> : 1a                         load.z64
	<.main+9553 @0582bd> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9562 @0582c6> : 1a                         load.z64
	<.main+9563 @0582c7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9572 @0582d0> : 1f a0 35 05 00             load.ref <@0535a0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9577 @0582d5> : 02                         call
	<.main+9578 @0582d6> : 09 e8 ff ff                inc.sp(-24)
	<.main+9582 @0582da> : 2d d0 5b 05                store.m64 <@055bd0> ;testMathClamp_1F
	test/stdc/test.math.ci:32: (25 bytes: <@0582de> - <@0582f7>): static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9586 @0582de> : 19                         load.z32
	<.main+9587 @0582df> : 10 00                      dup.x32 sp(0)
	<.main+9589 @0582e1> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9594 @0582e6> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9599 @0582eb> : 10 03                      dup.x32 sp(3)
	<.main+9601 @0582ed> : 72                         sub.f32
	<.main+9602 @0582ee> : 73                         mul.f32
	<.main+9603 @0582ef> : 71                         add.f32
	<.main+9604 @0582f0> : 13 01                      set.x32 sp(1)
	<.main+9606 @0582f2> : 7d                         f32.2f64
	<.main+9607 @0582f3> : 2d d8 5b 05                store.m64 <@055bd8> ;testMathLerp_1f
	test/stdc/test.math.ci:33: (32 bytes: <@0582f7> - <@058317>): static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9611 @0582f7> : 1a                         load.z64
	<.main+9612 @0582f8> : 11 00                      dup.x64 sp(0)
	<.main+9614 @0582fa> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9623 @058303> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9632 @05830c> : 11 06                      dup.x64 sp(6)
	<.main+9634 @05830e> : 82                         sub.f64
	<.main+9635 @05830f> : 83                         mul.f64
	<.main+9636 @058310> : 81                         add.f64
	<.main+9637 @058311> : 14 02                      set.x64 sp(2)
	<.main+9639 @058313> : 2d e0 5b 05                store.m64 <@055be0> ;testMathLerp_1F
	test/stdc/test.math.ci:35: (64 bytes: <@058317> - <@058357>): static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9643 @058317> : 19                         load.z32
	<.main+9644 @058318> : 19                         load.z32
	<.main+9645 @058319> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9650 @05831e> : 10 02                      dup.x32 sp(2)
	<.main+9652 @058320> : 72                         sub.f32
	<.main+9653 @058321> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9658 @058326> : 10 03                      dup.x32 sp(3)
	<.main+9660 @058328> : 72                         sub.f32
	<.main+9661 @058329> : 74                         div.f32
	<.main+9662 @05832a> : 19                         load.z32
	<.main+9663 @05832b> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9668 @058330> : 1f 80 35 05 00             load.ref <@053580> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9673 @058335> : 02                         call
	<.main+9674 @058336> : 09 f4 ff ff                inc.sp(-12)
	<.main+9678 @05833a> : 10 00                      dup.x32 sp(0)
	<.main+9680 @05833c> : 10 01                      dup.x32 sp(1)
	<.main+9682 @05833e> : 73                         mul.f32
	<.main+9683 @05833f> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9688 @058344> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9693 @058349> : 10 03                      dup.x32 sp(3)
	<.main+9695 @05834b> : 73                         mul.f32
	<.main+9696 @05834c> : 72                         sub.f32
	<.main+9697 @05834d> : 73                         mul.f32
	<.main+9698 @05834e> : 13 01                      set.x32 sp(1)
	<.main+9700 @058350> : 13 01                      set.x32 sp(1)
	<.main+9702 @058352> : 7d                         f32.2f64
	<.main+9703 @058353> : 2d e8 5b 05                store.m64 <@055be8> ;testMathSmooth_1f
	test/stdc/test.math.ci:36: (82 bytes: <@058357> - <@0583a9>): static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9707 @058357> : 1b                         load.z128
	<.main+9708 @058358> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9717 @058361> : 11 04                      dup.x64 sp(4)
	<.main+9719 @058363> : 82                         sub.f64
	<.main+9720 @058364> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9729 @05836d> : 11 06                      dup.x64 sp(6)
	<.main+9731 @05836f> : 82                         sub.f64
	<.main+9732 @058370> : 84                         div.f64
	<.main+9733 @058371> : 1a                         load.z64
	<.main+9734 @058372> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9743 @05837b> : 1f a0 35 05 00             load.ref <@0535a0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9748 @058380> : 02                         call
	<.main+9749 @058381> : 09 e8 ff ff                inc.sp(-24)
	<.main+9753 @058385> : 11 00                      dup.x64 sp(0)
	<.main+9755 @058387> : 11 02                      dup.x64 sp(2)
	<.main+9757 @058389> : 83                         mul.f64
	<.main+9758 @05838a> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9767 @058393> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9776 @05839c> : 11 06                      dup.x64 sp(6)
	<.main+9778 @05839e> : 83                         mul.f64
	<.main+9779 @05839f> : 82                         sub.f64
	<.main+9780 @0583a0> : 83                         mul.f64
	<.main+9781 @0583a1> : 14 02                      set.x64 sp(2)
	<.main+9783 @0583a3> : 14 02                      set.x64 sp(2)
	<.main+9785 @0583a5> : 2d f0 5b 05                store.m64 <@055bf0> ;testMathSmooth_1F
	test/stdc/test.math.ci:38: (25 bytes: <@0583a9> - <@0583c2>): static testMathMin_nan: float64 := Math.min()
	<.main+9789 @0583a9> : 19                         load.z32
	<.main+9790 @0583aa> : 0a 04 00 00                load.sp(+4)
	<.main+9794 @0583ae> : 1a                         load.z64
	<.main+9795 @0583af> : 11 02                      dup.x64 sp(2)
	<.main+9797 @0583b1> : 1f c0 35 05 00             load.ref <@0535c0> ;Math.min(data: float64[]): float64
	<.main+9802 @0583b6> : 02                         call
	<.main+9803 @0583b7> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9806 @0583ba> : 09 f0 ff ff                inc.sp(-16)
	<.main+9810 @0583be> : 2d f8 5b 05                store.m64 <@055bf8> ;testMathMin_nan
	test/stdc/test.math.ci:39: (110 bytes: <@0583c2> - <@058430>): static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9814 @0583c2> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9823 @0583cb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9832 @0583d4> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9841 @0583dd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9850 @0583e6> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9859 @0583ef> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9868 @0583f8> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9877 @058401> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9886 @05840a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9895 @058413> : 1c 09 00 00 00             load.c32 9
	<.main+9900 @058418> : 0a 04 00 00                load.sp(+4)
	<.main+9904 @05841c> : 1a                         load.z64
	<.main+9905 @05841d> : 11 02                      dup.x64 sp(2)
	<.main+9907 @05841f> : 1f c0 35 05 00             load.ref <@0535c0> ;Math.min(data: float64[]): float64
	<.main+9912 @058424> : 02                         call
	<.main+9913 @058425> : 17 16 02                   mov.x64 sp(22, 2)
	<.main+9916 @058428> : 09 a8 ff ff                inc.sp(-88)
	<.main+9920 @05842c> : 2d 00 5c 05                store.m64 <@055c00> ;testMathMin_1
	test/stdc/test.math.ci:40: (25 bytes: <@058430> - <@058449>): static testMathMax_nan: float64 := Math.max()
	<.main+9924 @058430> : 19                         load.z32
	<.main+9925 @058431> : 0a 04 00 00                load.sp(+4)
	<.main+9929 @058435> : 1a                         load.z64
	<.main+9930 @058436> : 11 02                      dup.x64 sp(2)
	<.main+9932 @058438> : 1f 10 36 05 00             load.ref <@053610> ;Math.max(data: float64[]): float64
	<.main+9937 @05843d> : 02                         call
	<.main+9938 @05843e> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9941 @058441> : 09 f0 ff ff                inc.sp(-16)
	<.main+9945 @058445> : 2d 08 5c 05                store.m64 <@055c08> ;testMathMax_nan
	test/stdc/test.math.ci:41: (110 bytes: <@058449> - <@0584b7>): static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9949 @058449> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9958 @058452> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9967 @05845b> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9976 @058464> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9985 @05846d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9994 @058476> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10003 @05847f>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10012 @058488>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10021 @058491>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10030 @05849a>: 1c 09 00 00 00             load.c32 9
	<.main+10035 @05849f>: 0a 04 00 00                load.sp(+4)
	<.main+10039 @0584a3>: 1a                         load.z64
	<.main+10040 @0584a4>: 11 02                      dup.x64 sp(2)
	<.main+10042 @0584a6>: 1f 10 36 05 00             load.ref <@053610> ;Math.max(data: float64[]): float64
	<.main+10047 @0584ab>: 02                         call
	<.main+10048 @0584ac>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10051 @0584af>: 09 a8 ff ff                inc.sp(-88)
	<.main+10055 @0584b3>: 2d 10 5c 05                store.m64 <@055c10> ;testMathMax_9
	test/stdc/test.math.ci:43: (25 bytes: <@0584b7> - <@0584d0>): static testMathSum_0: float64 := Math.sum()
	<.main+10059 @0584b7>: 19                         load.z32
	<.main+10060 @0584b8>: 0a 04 00 00                load.sp(+4)
	<.main+10064 @0584bc>: 1a                         load.z64
	<.main+10065 @0584bd>: 11 02                      dup.x64 sp(2)
	<.main+10067 @0584bf>: 1f 60 36 05 00             load.ref <@053660> ;Math.sum(data: float64[]): float64
	<.main+10072 @0584c4>: 02                         call
	<.main+10073 @0584c5>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10076 @0584c8>: 09 f0 ff ff                inc.sp(-16)
	<.main+10080 @0584cc>: 2d 18 5c 05                store.m64 <@055c18> ;testMathSum_0
	test/stdc/test.math.ci:44: (38 bytes: <@0584d0> - <@0584f6>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10084 @0584d0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10093 @0584d9>: 1c 01 00 00 00             load.c32 1
	<.main+10098 @0584de>: 0a 04 00 00                load.sp(+4)
	<.main+10102 @0584e2>: 1a                         load.z64
	<.main+10103 @0584e3>: 11 02                      dup.x64 sp(2)
	<.main+10105 @0584e5>: 1f 60 36 05 00             load.ref <@053660> ;Math.sum(data: float64[]): float64
	<.main+10110 @0584ea>: 02                         call
	<.main+10111 @0584eb>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10114 @0584ee>: 09 e8 ff ff                inc.sp(-24)
	<.main+10118 @0584f2>: 2d 20 5c 05                store.m64 <@055c20> ;testMathSum_1
	test/stdc/test.math.ci:45: (47 bytes: <@0584f6> - <@058525>): static testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+10122 @0584f6>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10131 @0584ff>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10140 @058508>: 1c 02 00 00 00             load.c32 2
	<.main+10145 @05850d>: 0a 04 00 00                load.sp(+4)
	<.main+10149 @058511>: 1a                         load.z64
	<.main+10150 @058512>: 11 02                      dup.x64 sp(2)
	<.main+10152 @058514>: 1f 60 36 05 00             load.ref <@053660> ;Math.sum(data: float64[]): float64
	<.main+10157 @058519>: 02                         call
	<.main+10158 @05851a>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10161 @05851d>: 09 e0 ff ff                inc.sp(-32)
	<.main+10165 @058521>: 2d 28 5c 05                store.m64 <@055c28> ;testMathSum_3
	test/stdc/test.math.ci:46: (119 bytes: <@058525> - <@05859c>): static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+10169 @058525>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10178 @05852e>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10187 @058537>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10196 @058540>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10205 @058549>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10214 @058552>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10223 @05855b>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10232 @058564>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10241 @05856d>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10250 @058576>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10259 @05857f>: 1c 0a 00 00 00             load.c32 10
	<.main+10264 @058584>: 0a 04 00 00                load.sp(+4)
	<.main+10268 @058588>: 1a                         load.z64
	<.main+10269 @058589>: 11 02                      dup.x64 sp(2)
	<.main+10271 @05858b>: 1f 60 36 05 00             load.ref <@053660> ;Math.sum(data: float64[]): float64
	<.main+10276 @058590>: 02                         call
	<.main+10277 @058591>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10280 @058594>: 09 a0 ff ff                inc.sp(-96)
	<.main+10284 @058598>: 2d 30 5c 05                store.m64 <@055c30> ;testMathSum_55
	test/stdc/test.math.ci:48: (13 bytes: <@05859c> - <@0585a9>): static testMathEval_x: float64 := 10
	<.main+10288 @05859c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10297 @0585a5>: 2d 38 5c 05                store.m64 <@055c38> ;testMathEval_x
	test/stdc/test.math.ci:49: (29 bytes: <@0585a9> - <@0585c6>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10301 @0585a9>: 19                         load.z32
	<.main+10302 @0585aa>: 0a 04 00 00                load.sp(+4)
	<.main+10306 @0585ae>: 1a                         load.z64
	<.main+10307 @0585af>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10311 @0585b3>: 11 04                      dup.x64 sp(4)
	<.main+10313 @0585b5>: 1f 88 36 05 00             load.ref <@053688> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10318 @0585ba>: 02                         call
	<.main+10319 @0585bb>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10322 @0585be>: 09 e8 ff ff                inc.sp(-24)
	<.main+10326 @0585c2>: 2d 40 5c 05                store.m64 <@055c40> ;testMathEval_0
	test/stdc/test.math.ci:50: (13 bytes: <@0585c6> - <@0585d3>): static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+10330 @0585c6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10339 @0585cf>: 2d 48 5c 05                store.m64 <@055c48> ;testMathEval_1
	test/stdc/test.math.ci:51: (28 bytes: <@0585d3> - <@0585ef>): static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+10343 @0585d3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10352 @0585dc>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10356 @0585e0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10365 @0585e9>: 83                         mul.f64
	<.main+10366 @0585ea>: 81                         add.f64
	<.main+10367 @0585eb>: 2d 50 5c 05                store.m64 <@055c50> ;testMathEval_2
	test/stdc/test.math.ci:52: (45 bytes: <@0585ef> - <@05861c>): static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+10371 @0585ef>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10375 @0585f3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10384 @0585fc>: 11 02                      dup.x64 sp(2)
	<.main+10386 @0585fe>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10395 @058607>: 11 06                      dup.x64 sp(6)
	<.main+10397 @058609>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10406 @058612>: 83                         mul.f64
	<.main+10407 @058613>: 81                         add.f64
	<.main+10408 @058614>: 83                         mul.f64
	<.main+10409 @058615>: 81                         add.f64
	<.main+10410 @058616>: 14 02                      set.x64 sp(2)
	<.main+10412 @058618>: 2d 58 5c 05                store.m64 <@055c58> ;testMathEval_3
	test/stdc/test.math.ci:53: (62 bytes: <@05861c> - <@05865a>): static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10416 @05861c>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10420 @058620>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10429 @058629>: 11 02                      dup.x64 sp(2)
	<.main+10431 @05862b>: 11 04                      dup.x64 sp(4)
	<.main+10433 @05862d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10442 @058636>: 11 02                      dup.x64 sp(2)
	<.main+10444 @058638>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10453 @058641>: 11 06                      dup.x64 sp(6)
	<.main+10455 @058643>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10464 @05864c>: 83                         mul.f64
	<.main+10465 @05864d>: 81                         add.f64
	<.main+10466 @05864e>: 83                         mul.f64
	<.main+10467 @05864f>: 81                         add.f64
	<.main+10468 @058650>: 14 02                      set.x64 sp(2)
	<.main+10470 @058652>: 83                         mul.f64
	<.main+10471 @058653>: 81                         add.f64
	<.main+10472 @058654>: 14 02                      set.x64 sp(2)
	<.main+10474 @058656>: 2d 60 5c 05                store.m64 <@055c60> ;testMathEval_4
	test/stdc/test.math.ci:54: (78 bytes: <@05865a> - <@0586a8>): static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10478 @05865a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10487 @058663>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10496 @05866c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10505 @058675>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10514 @05867e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10523 @058687>: 1c 05 00 00 00             load.c32 5
	<.main+10528 @05868c>: 0a 04 00 00                load.sp(+4)
	<.main+10532 @058690>: 1a                         load.z64
	<.main+10533 @058691>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10537 @058695>: 11 04                      dup.x64 sp(4)
	<.main+10539 @058697>: 1f 88 36 05 00             load.ref <@053688> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10544 @05869c>: 02                         call
	<.main+10545 @05869d>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10548 @0586a0>: 09 c0 ff ff                inc.sp(-64)
	<.main+10552 @0586a4>: 2d 68 5c 05                store.m64 <@055c68> ;testMathEval_5
	test/stdc/test.math.ci:55: (87 bytes: <@0586a8> - <@0586ff>): static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10556 @0586a8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10565 @0586b1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10574 @0586ba>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10583 @0586c3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10592 @0586cc>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10601 @0586d5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10610 @0586de>: 1c 06 00 00 00             load.c32 6
	<.main+10615 @0586e3>: 0a 04 00 00                load.sp(+4)
	<.main+10619 @0586e7>: 1a                         load.z64
	<.main+10620 @0586e8>: 2b 38 5c 05                load.m64 <@055c38> ;testMathEval_x
	<.main+10624 @0586ec>: 11 04                      dup.x64 sp(4)
	<.main+10626 @0586ee>: 1f 88 36 05 00             load.ref <@053688> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10631 @0586f3>: 02                         call
	<.main+10632 @0586f4>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10635 @0586f7>: 09 b8 ff ff                inc.sp(-72)
	<.main+10639 @0586fb>: 2d 70 5c 05                store.m64 <@055c70> ;testMathEval_6
	test/stdc/test.math.ci:57: (35 bytes: <@0586ff> - <@058722>): static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10643 @0586ff>: 1a                         load.z64
	<.main+10644 @058700>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10653 @058709>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10662 @058712>: 84                         div.f64
	<.main+10663 @058713>: 19                         load.z32
	<.main+10664 @058714>: 1f 38 37 05 00             load.ref <@053738> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10669 @058719>: 02                         call
	<.main+10670 @05871a>: 09 f4 ff ff                inc.sp(-12)
	<.main+10674 @05871e>: 2d 78 5c 05                store.m64 <@055c78> ;testMathSin_f64
	test/stdc/test.math.ci:58: (49 bytes: <@058722> - <@058753>): static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10678 @058722>: 1b                         load.z128
	<.main+10679 @058723>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10688 @05872c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10697 @058735>: 84                         div.f64
	<.main+10698 @058736>: 1f c8 34 05 00             load.ref <@0534c8> ;Math.abs(x: float64): float64
	<.main+10703 @05873b>: 02                         call
	<.main+10704 @05873c>: 09 f8 ff ff                inc.sp(-8)
	<.main+10708 @058740>: 1c 01 00 00 00             load.c32 1
	<.main+10713 @058745>: 1f 38 37 05 00             load.ref <@053738> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10718 @05874a>: 02                         call
	<.main+10719 @05874b>: 09 f4 ff ff                inc.sp(-12)
	<.main+10723 @05874f>: 2d 80 5c 05                store.m64 <@055c80> ;testMathCos_f64
	test/stdc/test.math.ci:59: (34 bytes: <@058753> - <@058775>): static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10727 @058753>: 1a                         load.z64
	<.main+10728 @058754>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10737 @05875d>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10746 @058766>: 84                         div.f64
	<.main+10747 @058767>: 1f 88 38 05 00             load.ref <@053888> ;Math.tan(arg: float64): float64
	<.main+10752 @05876c>: 02                         call
	<.main+10753 @05876d>: 09 f8 ff ff                inc.sp(-8)
	<.main+10757 @058771>: 2d 88 5c 05                store.m64 <@055c88> ;testMathTan_f64
	test/stdc/test.math.ci:60: (34 bytes: <@058775> - <@058797>): static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10761 @058775>: 1a                         load.z64
	<.main+10762 @058776>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10771 @05877f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10780 @058788>: 84                         div.f64
	<.main+10781 @058789>: 1f 08 3a 05 00             load.ref <@053a08> ;Math.sinh(x: float64): float64
	<.main+10786 @05878e>: 02                         call
	<.main+10787 @05878f>: 09 f8 ff ff                inc.sp(-8)
	<.main+10791 @058793>: 2d 90 5c 05                store.m64 <@055c90> ;testMathSinh_f64
	test/stdc/test.math.ci:61: (34 bytes: <@058797> - <@0587b9>): static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10795 @058797>: 1a                         load.z64
	<.main+10796 @058798>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10805 @0587a1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10814 @0587aa>: 84                         div.f64
	<.main+10815 @0587ab>: 1f 00 3b 05 00             load.ref <@053b00> ;Math.cosh(x: float64): float64
	<.main+10820 @0587b0>: 02                         call
	<.main+10821 @0587b1>: 09 f8 ff ff                inc.sp(-8)
	<.main+10825 @0587b5>: 2d 98 5c 05                store.m64 <@055c98> ;testMathCosh_f64
	test/stdc/test.math.ci:63: (24 bytes: <@0587b9> - <@0587d1>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10829 @0587b9>: 1a                         load.z64
	<.main+10830 @0587ba>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10839 @0587c3>: 1f 50 3b 05 00             load.ref <@053b50> ;Math.asin(x: float64): float64
	<.main+10844 @0587c8>: 02                         call
	<.main+10845 @0587c9>: 09 f8 ff ff                inc.sp(-8)
	<.main+10849 @0587cd>: 2d a0 5c 05                store.m64 <@055ca0> ;testMathAsin_f64
	test/stdc/test.math.ci:64: (44 bytes: <@0587d1> - <@0587fd>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10853 @0587d1>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10862 @0587da>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10871 @0587e3>: 84                         div.f64
	<.main+10872 @0587e4>: 1a                         load.z64
	<.main+10873 @0587e5>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10882 @0587ee>: 1f 50 3b 05 00             load.ref <@053b50> ;Math.asin(x: float64): float64
	<.main+10887 @0587f3>: 02                         call
	<.main+10888 @0587f4>: 09 f8 ff ff                inc.sp(-8)
	<.main+10892 @0587f8>: 82                         sub.f64
	<.main+10893 @0587f9>: 2d a8 5c 05                store.m64 <@055ca8> ;testMathAcos_f64
	test/stdc/test.math.ci:67: (34 bytes: <@0587fd> - <@05881f>): static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10897 @0587fd>: 19                         load.z32
	<.main+10898 @0587fe>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10903 @058803>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10908 @058808>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10913 @05880d>: 1f b8 36 05 00             load.ref <@0536b8> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10918 @058812>: 02                         call
	<.main+10919 @058813>: 09 f4 ff ff                inc.sp(-12)
	<.main+10923 @058817>: 19                         load.z32
	<.main+10924 @058818>: 57                         ceq.i32
	<.main+10925 @058819>: 1f b0 5c 05 00             load.ref <@055cb0> ;testMathCmp_f32
	<.main+10930 @05881e>: 25                         store.i8
	test/stdc/test.math.ci:68: (46 bytes: <@05881f> - <@05884d>): static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10931 @05881f>: 19                         load.z32
	<.main+10932 @058820>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10941 @058829>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10950 @058832>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10959 @05883b>: 1f f8 36 05 00             load.ref <@0536f8> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10964 @058840>: 02                         call
	<.main+10965 @058841>: 09 e8 ff ff                inc.sp(-24)
	<.main+10969 @058845>: 19                         load.z32
	<.main+10970 @058846>: 57                         ceq.i32
	<.main+10971 @058847>: 1f b8 5c 05 00             load.ref <@055cb8> ;testMathCmp_f64
	<.main+10976 @05884c>: 25                         store.i8
	test/stdc/test.math.ci:70: (33 bytes: <@05884d> - <@05886e>): static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10977 @05884d>: 1a                         load.z64
	<.main+10978 @05884e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10987 @058857>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10996 @058860>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11001 @058865>: 02                         call
	<.main+11002 @058866>: 09 f0 ff ff                inc.sp(-16)
	<.main+11006 @05886a>: 2d c0 5c 05                store.m64 <@055cc0> ;testMathAbsMod_f64_0a
	test/stdc/test.math.ci:71: (24 bytes: <@05886e> - <@058886>): static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+11010 @05886e>: 1b                         load.z128
	<.main+11011 @05886f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11020 @058878>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11025 @05887d>: 02                         call
	<.main+11026 @05887e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11030 @058882>: 2d c8 5c 05                store.m64 <@055cc8> ;testMathAbsMod_f64_0b
	test/stdc/test.math.ci:72: (33 bytes: <@058886> - <@0588a7>): static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+11034 @058886>: 1a                         load.z64
	<.main+11035 @058887>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11044 @058890>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11053 @058899>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11058 @05889e>: 02                         call
	<.main+11059 @05889f>: 09 f0 ff ff                inc.sp(-16)
	<.main+11063 @0588a3>: 2d d0 5c 05                store.m64 <@055cd0> ;testMathAbsMod_f64_0c
	test/stdc/test.math.ci:74: (33 bytes: <@0588a7> - <@0588c8>): static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+11067 @0588a7>: 1a                         load.z64
	<.main+11068 @0588a8>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11077 @0588b1>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11086 @0588ba>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11091 @0588bf>: 02                         call
	<.main+11092 @0588c0>: 09 f0 ff ff                inc.sp(-16)
	<.main+11096 @0588c4>: 2d d8 5c 05                store.m64 <@055cd8> ;testMathAbsMod_f64_9a
	test/stdc/test.math.ci:75: (33 bytes: <@0588c8> - <@0588e9>): static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+11100 @0588c8>: 1a                         load.z64
	<.main+11101 @0588c9>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11110 @0588d2>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11119 @0588db>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11124 @0588e0>: 02                         call
	<.main+11125 @0588e1>: 09 f0 ff ff                inc.sp(-16)
	<.main+11129 @0588e5>: 2d e0 5c 05                store.m64 <@055ce0> ;testMathAbsMod_f64_9b
	test/stdc/test.math.ci:76: (33 bytes: <@0588e9> - <@05890a>): static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+11133 @0588e9>: 1a                         load.z64
	<.main+11134 @0588ea>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11143 @0588f3>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11152 @0588fc>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11157 @058901>: 02                         call
	<.main+11158 @058902>: 09 f0 ff ff                inc.sp(-16)
	<.main+11162 @058906>: 2d e8 5c 05                store.m64 <@055ce8> ;testMathAbsMod_f64_9c
	test/stdc/test.math.ci:77: (33 bytes: <@05890a> - <@05892b>): static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+11166 @05890a>: 1a                         load.z64
	<.main+11167 @05890b>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11176 @058914>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11185 @05891d>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11190 @058922>: 02                         call
	<.main+11191 @058923>: 09 f0 ff ff                inc.sp(-16)
	<.main+11195 @058927>: 2d f0 5c 05                store.m64 <@055cf0> ;testMathAbsMod_f64_9d
	test/stdc/test.math.ci:79: (33 bytes: <@05892b> - <@05894c>): static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+11199 @05892b>: 1a                         load.z64
	<.main+11200 @05892c>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11209 @058935>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11218 @05893e>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11223 @058943>: 02                         call
	<.main+11224 @058944>: 09 f0 ff ff                inc.sp(-16)
	<.main+11228 @058948>: 2d f8 5c 05                store.m64 <@055cf8> ;testMathAbsMod_f64_8a
	test/stdc/test.math.ci:80: (33 bytes: <@05894c> - <@05896d>): static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+11232 @05894c>: 1a                         load.z64
	<.main+11233 @05894d>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11242 @058956>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11251 @05895f>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11256 @058964>: 02                         call
	<.main+11257 @058965>: 09 f0 ff ff                inc.sp(-16)
	<.main+11261 @058969>: 2d 00 5d 05                store.m64 <@055d00> ;testMathAbsMod_f64_8b
	test/stdc/test.math.ci:81: (33 bytes: <@05896d> - <@05898e>): static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+11265 @05896d>: 1a                         load.z64
	<.main+11266 @05896e>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11275 @058977>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11284 @058980>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11289 @058985>: 02                         call
	<.main+11290 @058986>: 09 f0 ff ff                inc.sp(-16)
	<.main+11294 @05898a>: 2d 08 5d 05                store.m64 <@055d08> ;testMathAbsMod_f64_8c
	test/stdc/test.math.ci:82: (33 bytes: <@05898e> - <@0589af>): static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+11298 @05898e>: 1a                         load.z64
	<.main+11299 @05898f>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11308 @058998>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11317 @0589a1>: 1f 00 35 05 00             load.ref <@053500> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11322 @0589a6>: 02                         call
	<.main+11323 @0589a7>: 09 f0 ff ff                inc.sp(-16)
	<.main+11327 @0589ab>: 2d 10 5d 05                store.m64 <@055d10> ;testMathAbsMod_f64_8d
	test/stdc/test.math.ci:84: (25 bytes: <@0589af> - <@0589c8>): static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+11331 @0589af>: 19                         load.z32
	<.main+11332 @0589b0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11337 @0589b5>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11342 @0589ba>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11347 @0589bf>: 02                         call
	<.main+11348 @0589c0>: 09 f8 ff ff                inc.sp(-8)
	<.main+11352 @0589c4>: 2e 18 5d 05                store.m32 <@055d18> ;testMathAbsMod_f32_0a
	test/stdc/test.math.ci:85: (21 bytes: <@0589c8> - <@0589dd>): static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+11356 @0589c8>: 19                         load.z32
	<.main+11357 @0589c9>: 19                         load.z32
	<.main+11358 @0589ca>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11363 @0589cf>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11368 @0589d4>: 02                         call
	<.main+11369 @0589d5>: 09 f8 ff ff                inc.sp(-8)
	<.main+11373 @0589d9>: 2e 20 5d 05                store.m32 <@055d20> ;testMathAbsMod_f32_0b
	test/stdc/test.math.ci:86: (25 bytes: <@0589dd> - <@0589f6>): static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+11377 @0589dd>: 19                         load.z32
	<.main+11378 @0589de>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11383 @0589e3>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11388 @0589e8>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11393 @0589ed>: 02                         call
	<.main+11394 @0589ee>: 09 f8 ff ff                inc.sp(-8)
	<.main+11398 @0589f2>: 2e 28 5d 05                store.m32 <@055d28> ;testMathAbsMod_f32_0c
	test/stdc/test.math.ci:88: (25 bytes: <@0589f6> - <@058a0f>): static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+11402 @0589f6>: 19                         load.z32
	<.main+11403 @0589f7>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11408 @0589fc>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11413 @058a01>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11418 @058a06>: 02                         call
	<.main+11419 @058a07>: 09 f8 ff ff                inc.sp(-8)
	<.main+11423 @058a0b>: 2e 30 5d 05                store.m32 <@055d30> ;testMathAbsMod_f32_9a
	test/stdc/test.math.ci:89: (25 bytes: <@058a0f> - <@058a28>): static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+11427 @058a0f>: 19                         load.z32
	<.main+11428 @058a10>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11433 @058a15>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11438 @058a1a>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11443 @058a1f>: 02                         call
	<.main+11444 @058a20>: 09 f8 ff ff                inc.sp(-8)
	<.main+11448 @058a24>: 2e 38 5d 05                store.m32 <@055d38> ;testMathAbsMod_f32_9b
	test/stdc/test.math.ci:90: (25 bytes: <@058a28> - <@058a41>): static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+11452 @058a28>: 19                         load.z32
	<.main+11453 @058a29>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11458 @058a2e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11463 @058a33>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11468 @058a38>: 02                         call
	<.main+11469 @058a39>: 09 f8 ff ff                inc.sp(-8)
	<.main+11473 @058a3d>: 2e 40 5d 05                store.m32 <@055d40> ;testMathAbsMod_f32_9c
	test/stdc/test.math.ci:91: (25 bytes: <@058a41> - <@058a5a>): static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+11477 @058a41>: 19                         load.z32
	<.main+11478 @058a42>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11483 @058a47>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11488 @058a4c>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11493 @058a51>: 02                         call
	<.main+11494 @058a52>: 09 f8 ff ff                inc.sp(-8)
	<.main+11498 @058a56>: 2e 48 5d 05                store.m32 <@055d48> ;testMathAbsMod_f32_9d
	test/stdc/test.math.ci:93: (25 bytes: <@058a5a> - <@058a73>): static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+11502 @058a5a>: 19                         load.z32
	<.main+11503 @058a5b>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11508 @058a60>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11513 @058a65>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11518 @058a6a>: 02                         call
	<.main+11519 @058a6b>: 09 f8 ff ff                inc.sp(-8)
	<.main+11523 @058a6f>: 2e 50 5d 05                store.m32 <@055d50> ;testMathAbsMod_f32_8a
	test/stdc/test.math.ci:94: (25 bytes: <@058a73> - <@058a8c>): static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+11527 @058a73>: 19                         load.z32
	<.main+11528 @058a74>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11533 @058a79>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11538 @058a7e>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11543 @058a83>: 02                         call
	<.main+11544 @058a84>: 09 f8 ff ff                inc.sp(-8)
	<.main+11548 @058a88>: 2e 58 5d 05                store.m32 <@055d58> ;testMathAbsMod_f32_8b
	test/stdc/test.math.ci:95: (25 bytes: <@058a8c> - <@058aa5>): static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+11552 @058a8c>: 19                         load.z32
	<.main+11553 @058a8d>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11558 @058a92>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11563 @058a97>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11568 @058a9c>: 02                         call
	<.main+11569 @058a9d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11573 @058aa1>: 2e 60 5d 05                store.m32 <@055d60> ;testMathAbsMod_f32_8c
	test/stdc/test.math.ci:96: (25 bytes: <@058aa5> - <@058abe>): static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+11577 @058aa5>: 19                         load.z32
	<.main+11578 @058aa6>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11583 @058aab>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11588 @058ab0>: 1f e0 34 05 00             load.ref <@0534e0> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11593 @058ab5>: 02                         call
	<.main+11594 @058ab6>: 09 f8 ff ff                inc.sp(-8)
	<.main+11598 @058aba>: 2e 68 5d 05                store.m32 <@055d68> ;testMathAbsMod_f32_8d
	test/stdc/memory.ci:13: (18 bytes: <@058abe> - <@058ad0>): pointer.fill(void(void(p1, 0), 1024));
	<.main+11602 @058abe>: 2a d0 4f 05                load.m32 <@054fd0> ;p1
	<.main+11606 @058ac2>: 19                         load.z32
	<.main+11607 @058ac3>: 1c 00 04 00 00             load.c32 1024
	<.main+11612 @058ac8>: 01 0a 00 00                nfc(10) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11616 @058acc>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (21 bytes: <@058ad0> - <@058ae5>): pointer.copy(void(void(p1, p3), 160));
	<.main+11620 @058ad0>: 2a d0 4f 05                load.m32 <@054fd0> ;p1
	<.main+11624 @058ad4>: 2a e0 4f 05                load.m32 <@054fe0> ;p3
	<.main+11628 @058ad8>: 1c a0 00 00 00             load.c32 160
	<.main+11633 @058add>: 01 0b 00 00                nfc(11) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11637 @058ae1>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (13 bytes: <@058ae5> - <@058af2>): free(p1);
	<.main+11641 @058ae5>: 2a d0 4f 05                load.m32 <@054fd0> ;p1
	<.main+11645 @058ae9>: 19                         load.z32
	<.main+11646 @058aea>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11650 @058aee>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (13 bytes: <@058af2> - <@058aff>): free(p2);
	<.main+11654 @058af2>: 2a d8 4f 05                load.m32 <@054fd8> ;p2
	<.main+11658 @058af6>: 19                         load.z32
	<.main+11659 @058af7>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11663 @058afb>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (13 bytes: <@058aff> - <@058b0c>): free(p3);
	<.main+11667 @058aff>: 2a e0 4f 05                load.m32 <@054fe0> ;p3
	<.main+11671 @058b03>: 19                         load.z32
	<.main+11672 @058b04>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11676 @058b08>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (13 bytes: <@058b0c> - <@058b19>): free(p4);
	<.main+11680 @058b0c>: 2a e8 4f 05                load.m32 <@054fe8> ;p4
	<.main+11684 @058b10>: 19                         load.z32
	<.main+11685 @058b11>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11689 @058b15>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:26: (35 bytes: <@058b19> - <@058b3c>): debug(void("val1", val1));
	<.main+11693 @058b19>: 1f 30 d5 03 00             load.ref <@03d530> ;"test/stdc/memory.ci"
	<.main+11698 @058b1e>: 1c 1a 00 00 00             load.c32 26
	<.main+11703 @058b23>: 1c 0e 00 00 00             load.c32 14
	<.main+11708 @058b28>: 19                         load.z32
	<.main+11709 @058b29>: 1f 58 d5 03 00             load.ref <@03d558> ;"val1"
	<.main+11714 @058b2e>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11719 @058b33>: 1f f0 4f 05 00             load.ref <@054ff0> ;val1
	<.main+11724 @058b38>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (35 bytes: <@058b3c> - <@058b5f>): debug(void("val2", val2));
	<.main+11728 @058b3c>: 1f 30 d5 03 00             load.ref <@03d530> ;"test/stdc/memory.ci"
	<.main+11733 @058b41>: 1c 1b 00 00 00             load.c32 27
	<.main+11738 @058b46>: 1c 0e 00 00 00             load.c32 14
	<.main+11743 @058b4b>: 19                         load.z32
	<.main+11744 @058b4c>: 1f 5d d5 03 00             load.ref <@03d55d> ;"val2"
	<.main+11749 @058b51>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11754 @058b56>: 1f f8 4f 05 00             load.ref <@054ff8> ;val2
	<.main+11759 @058b5b>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (22 bytes: <@058b5f> - <@058b75>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+11763 @058b5f>: 1f f8 4f 05 00             load.ref <@054ff8> ;val2
	<.main+11768 @058b64>: 1f f0 4f 05 00             load.ref <@054ff0> ;val1
	<.main+11773 @058b69>: 2a 90 04 00                load.m32 <@000490>
	<.main+11777 @058b6d>: 01 0c 00 00                nfc(12) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+11781 @058b71>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (18 bytes: <@058b75> - <@058b87>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+11785 @058b75>: 1f f0 4f 05 00             load.ref <@054ff0> ;val1
	<.main+11790 @058b7a>: 19                         load.z32
	<.main+11791 @058b7b>: 2a 90 04 00                load.m32 <@000490>
	<.main+11795 @058b7f>: 01 0a 00 00                nfc(10) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11799 @058b83>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (35 bytes: <@058b87> - <@058baa>): debug(void("val1", val1));
	<.main+11803 @058b87>: 1f 30 d5 03 00             load.ref <@03d530> ;"test/stdc/memory.ci"
	<.main+11808 @058b8c>: 1c 20 00 00 00             load.c32 32
	<.main+11813 @058b91>: 1c 0e 00 00 00             load.c32 14
	<.main+11818 @058b96>: 19                         load.z32
	<.main+11819 @058b97>: 1f 58 d5 03 00             load.ref <@03d558> ;"val1"
	<.main+11824 @058b9c>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11829 @058ba1>: 1f f0 4f 05 00             load.ref <@054ff0> ;val1
	<.main+11834 @058ba6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (35 bytes: <@058baa> - <@058bcd>): debug(void("val2", val2));
	<.main+11838 @058baa>: 1f 30 d5 03 00             load.ref <@03d530> ;"test/stdc/memory.ci"
	<.main+11843 @058baf>: 1c 21 00 00 00             load.c32 33
	<.main+11848 @058bb4>: 1c 0e 00 00 00             load.c32 14
	<.main+11853 @058bb9>: 19                         load.z32
	<.main+11854 @058bba>: 1f 5d d5 03 00             load.ref <@03d55d> ;"val2"
	<.main+11859 @058bbf>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11864 @058bc4>: 1f f8 4f 05 00             load.ref <@054ff8> ;val2
	<.main+11869 @058bc9>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:54: (46 bytes: <@058bcd> - <@058bfb>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+11873 @058bcd>: 19                         load.z32
	<.main+11874 @058bce>: 04 1d 00 00                jmp <.main+11903 @058beb>
	test/lang/array.ci:55: (21 bytes: <@058bd2> - <@058be7>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+11878 @058bd2>: 1c 2a 00 00 00             load.c32 42
	<.main+11883 @058bd7>: 10 01                      dup.x32 sp(1)
	<.main+11885 @058bd9>: 51                         add.i32
	<.main+11886 @058bda>: 5b                         i32.2i64
	<.main+11887 @058bdb>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+11892 @058be0>: 10 03                      dup.x32 sp(3)
	<.main+11894 @058be2>: 0d 08 00 00                mad.u32 8
	<.main+11898 @058be6>: 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@058be7> - <@058beb>): int32(i := int32(i + 1))
	<.main+11899 @058be7>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@058beb> - <@058bf7>): bool(i < arrFixedNoInit.length)
	<.main+11903 @058beb>: 10 00                      dup.x32 sp(0)
	<.main+11905 @058bed>: 1c 07 00 00 00             load.c32 7
	<.main+11910 @058bf2>: 58                         clt.i32
	<.main+11911 @058bf3>: 05 df ff ff                jnz <.main+11878 @058bd2>
	<.main+11915 @058bf7>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:82: (23 bytes: <@058bfb> - <@058c12>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+11919 @058bfb>: 1f 48 51 05 00             load.ref <@055148> ;strFixed
	<.main+11924 @058c00>: 1f ec e3 02 00             load.ref <@02e3ec> ;"string"
	<.main+11929 @058c05>: 1c 07 00 00 00             load.c32 7
	<.main+11934 @058c0a>: 01 0b 00 00                nfc(11) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11938 @058c0e>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (35 bytes: <@058c12> - <@058c35>): debug(void("string as variant", strFixed));
	<.main+11942 @058c12>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+11947 @058c17>: 1c 53 00 00 00             load.c32 83
	<.main+11952 @058c1c>: 1c 0e 00 00 00             load.c32 14
	<.main+11957 @058c21>: 19                         load.z32
	<.main+11958 @058c22>: 1f 83 f6 03 00             load.ref <@03f683> ;"string as variant"
	<.main+11963 @058c27>: 1f 90 04 04 00             load.ref <@040490>
	<.main+11968 @058c2c>: 1f 48 51 05 00             load.ref <@055148> ;strFixed
	<.main+11973 @058c31>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (35 bytes: <@058c35> - <@058c58>): debug(void("string to variant", variant(strFixed)));
	<.main+11977 @058c35>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+11982 @058c3a>: 1c 54 00 00 00             load.c32 84
	<.main+11987 @058c3f>: 1c 0e 00 00 00             load.c32 14
	<.main+11992 @058c44>: 19                         load.z32
	<.main+11993 @058c45>: 1f 95 f6 03 00             load.ref <@03f695> ;"string to variant"
	<.main+11998 @058c4a>: 1f 90 04 04 00             load.ref <@040490>
	<.main+12003 @058c4f>: 1f 48 51 05 00             load.ref <@055148> ;strFixed
	<.main+12008 @058c54>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:87: (34 bytes: <@058c58> - <@058c7a>): debug(void("string as variant", strArray));
	<.main+12012 @058c58>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12017 @058c5d>: 1c 57 00 00 00             load.c32 87
	<.main+12022 @058c62>: 1c 0e 00 00 00             load.c32 14
	<.main+12027 @058c67>: 19                         load.z32
	<.main+12028 @058c68>: 1f 83 f6 03 00             load.ref <@03f683> ;"string as variant"
	<.main+12033 @058c6d>: 1f 58 06 04 00             load.ref <@040658>
	<.main+12038 @058c72>: 2a 50 51 05                load.m32 <@055150> ;strArray
	<.main+12042 @058c76>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (34 bytes: <@058c7a> - <@058c9c>): debug(void("string to variant", variant(strArray)));
	<.main+12046 @058c7a>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12051 @058c7f>: 1c 58 00 00 00             load.c32 88
	<.main+12056 @058c84>: 1c 0e 00 00 00             load.c32 14
	<.main+12061 @058c89>: 19                         load.z32
	<.main+12062 @058c8a>: 1f 95 f6 03 00             load.ref <@03f695> ;"string to variant"
	<.main+12067 @058c8f>: 1f 58 06 04 00             load.ref <@040658>
	<.main+12072 @058c94>: 2a 50 51 05                load.m32 <@055150> ;strArray
	<.main+12076 @058c98>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:91: (34 bytes: <@058c9c> - <@058cbe>): debug(void("string as variant", strSlice));
	<.main+12080 @058c9c>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12085 @058ca1>: 1c 5b 00 00 00             load.c32 91
	<.main+12090 @058ca6>: 1c 0e 00 00 00             load.c32 14
	<.main+12095 @058cab>: 19                         load.z32
	<.main+12096 @058cac>: 1f 83 f6 03 00             load.ref <@03f683> ;"string as variant"
	<.main+12101 @058cb1>: 1f 88 07 04 00             load.ref <@040788>
	<.main+12106 @058cb6>: 2a 58 51 05                load.m32 <@055158> ;strSlice
	<.main+12110 @058cba>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (34 bytes: <@058cbe> - <@058ce0>): debug(void("string to variant", variant(strSlice)));
	<.main+12114 @058cbe>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12119 @058cc3>: 1c 5c 00 00 00             load.c32 92
	<.main+12124 @058cc8>: 1c 0e 00 00 00             load.c32 14
	<.main+12129 @058ccd>: 19                         load.z32
	<.main+12130 @058cce>: 1f 95 f6 03 00             load.ref <@03f695> ;"string to variant"
	<.main+12135 @058cd3>: 1f 88 07 04 00             load.ref <@040788>
	<.main+12140 @058cd8>: 2a 58 51 05                load.m32 <@055158> ;strSlice
	<.main+12144 @058cdc>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (53 bytes: <@058ce0> - <@058d15>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+12148 @058ce0>: 2a 0c 51 05                load.m32 <@05510c> ;arrSliceNoInit+4
	<.main+12152 @058ce4>: 19                         load.z32
	<.main+12153 @058ce5>: 38                         clt.u32
	<.main+12154 @058ce6>: 05 08 00 00                jnz <.main+12162 @058cee>
	<.main+12158 @058cea>: 04 2b 00 00                jmp <.main+12201 @058d15>
	<.main+12162 @058cee>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12167 @058cf3>: 1c 62 00 00 00             load.c32 98
	<.main+12172 @058cf8>: 1c fe ff ff ff             load.c32 -2
	<.main+12177 @058cfd>: 1c 80 00 00 00             load.c32 128
	<.main+12182 @058d02>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12187 @058d07>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12192 @058d0c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12197 @058d11>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (53 bytes: <@058d15> - <@058d4a>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+12201 @058d15>: 2a 1c 51 05                load.m32 <@05511c> ;arrSliceInitNull+4
	<.main+12205 @058d19>: 19                         load.z32
	<.main+12206 @058d1a>: 57                         ceq.i32
	<.main+12207 @058d1b>: 06 08 00 00                jz <.main+12215 @058d23>
	<.main+12211 @058d1f>: 04 2b 00 00                jmp <.main+12254 @058d4a>
	<.main+12215 @058d23>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12220 @058d28>: 1c 63 00 00 00             load.c32 99
	<.main+12225 @058d2d>: 1c fe ff ff ff             load.c32 -2
	<.main+12230 @058d32>: 1c 80 00 00 00             load.c32 128
	<.main+12235 @058d37>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12240 @058d3c>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12245 @058d41>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12250 @058d46>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (61 bytes: <@058d4a> - <@058d87>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+12254 @058d4a>: 2b c8 50 05                load.m64 <@0550c8> ;arrFixedNoInit
	<.main+12258 @058d4e>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12267 @058d57>: 67                         ceq.i64
	<.main+12268 @058d58>: 06 08 00 00                jz <.main+12276 @058d60>
	<.main+12272 @058d5c>: 04 2b 00 00                jmp <.main+12315 @058d87>
	<.main+12276 @058d60>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12281 @058d65>: 1c 65 00 00 00             load.c32 101
	<.main+12286 @058d6a>: 1c fe ff ff ff             load.c32 -2
	<.main+12291 @058d6f>: 1c 80 00 00 00             load.c32 128
	<.main+12296 @058d74>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12301 @058d79>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12306 @058d7e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12311 @058d83>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@058d87> - <@058da0>): assertEq(void(7, arrFixedNoInit.length));
	<.main+12315 @058d87>: 1c 07 00 00 00             load.c32 7
	<.main+12320 @058d8c>: 1c 07 00 00 00             load.c32 7
	<.main+12325 @058d91>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12330 @058d96>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12335 @058d9b>: 02                         call
	<.main+12336 @058d9c>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (24 bytes: <@058da0> - <@058db8>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+12340 @058da0>: 1c 07 00 00 00             load.c32 7
	<.main+12345 @058da5>: 2a 2c 51 05                load.m32 <@05512c> ;arrSliceInitFixed+4
	<.main+12349 @058da9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12354 @058dae>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12359 @058db3>: 02                         call
	<.main+12360 @058db4>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (24 bytes: <@058db8> - <@058dd0>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+12364 @058db8>: 1c 07 00 00 00             load.c32 7
	<.main+12369 @058dbd>: 2a 3c 51 05                load.m32 <@05513c> ;arrSliceInitSlice+4
	<.main+12373 @058dc1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12378 @058dc6>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12383 @058dcb>: 02                         call
	<.main+12384 @058dcc>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@058dd0> - <@058df0>): assertEq(void(0, lenSlice(null)));
	<.main+12388 @058dd0>: 19                         load.z32
	<.main+12389 @058dd1>: 1a                         load.z64
	<.main+12390 @058dd2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12395 @058dd7>: 1f 60 51 05 00             load.ref <@055160> ;lenSlice(values: int64[]): int32
	<.main+12400 @058ddc>: 02                         call
	<.main+12401 @058ddd>: 09 f8 ff ff                inc.sp(-8)
	<.main+12405 @058de1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12410 @058de6>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12415 @058deb>: 02                         call
	<.main+12416 @058dec>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (31 bytes: <@058df0> - <@058e0f>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+12420 @058df0>: 19                         load.z32
	<.main+12421 @058df1>: 19                         load.z32
	<.main+12422 @058df2>: 2b 18 51 05                load.m64 <@055118> ;arrSliceInitNull
	<.main+12426 @058df6>: 1f 60 51 05 00             load.ref <@055160> ;lenSlice(values: int64[]): int32
	<.main+12431 @058dfb>: 02                         call
	<.main+12432 @058dfc>: 09 f8 ff ff                inc.sp(-8)
	<.main+12436 @058e00>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12441 @058e05>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12446 @058e0a>: 02                         call
	<.main+12447 @058e0b>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (41 bytes: <@058e0f> - <@058e38>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+12451 @058e0f>: 1c 07 00 00 00             load.c32 7
	<.main+12456 @058e14>: 19                         load.z32
	<.main+12457 @058e15>: 1c 07 00 00 00             load.c32 7
	<.main+12462 @058e1a>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+12467 @058e1f>: 1f 60 51 05 00             load.ref <@055160> ;lenSlice(values: int64[]): int32
	<.main+12472 @058e24>: 02                         call
	<.main+12473 @058e25>: 09 f8 ff ff                inc.sp(-8)
	<.main+12477 @058e29>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12482 @058e2e>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12487 @058e33>: 02                         call
	<.main+12488 @058e34>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (35 bytes: <@058e38> - <@058e5b>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+12492 @058e38>: 1c 07 00 00 00             load.c32 7
	<.main+12497 @058e3d>: 19                         load.z32
	<.main+12498 @058e3e>: 2b 28 51 05                load.m64 <@055128> ;arrSliceInitFixed
	<.main+12502 @058e42>: 1f 60 51 05 00             load.ref <@055160> ;lenSlice(values: int64[]): int32
	<.main+12507 @058e47>: 02                         call
	<.main+12508 @058e48>: 09 f8 ff ff                inc.sp(-8)
	<.main+12512 @058e4c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12517 @058e51>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12522 @058e56>: 02                         call
	<.main+12523 @058e57>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (35 bytes: <@058e5b> - <@058e7e>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+12527 @058e5b>: 1c 07 00 00 00             load.c32 7
	<.main+12532 @058e60>: 19                         load.z32
	<.main+12533 @058e61>: 2b 38 51 05                load.m64 <@055138> ;arrSliceInitSlice
	<.main+12537 @058e65>: 1f 60 51 05 00             load.ref <@055160> ;lenSlice(values: int64[]): int32
	<.main+12542 @058e6a>: 02                         call
	<.main+12543 @058e6b>: 09 f8 ff ff                inc.sp(-8)
	<.main+12547 @058e6f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12552 @058e74>: 1f e0 33 05 00             load.ref <@0533e0> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12557 @058e79>: 02                         call
	<.main+12558 @058e7a>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (827 bytes: <@058e7e> - <@0591b9>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+12562 @058e7e>: 19                         load.z32
	<.main+12563 @058e7f>: 04 2a 03 00                jmp <.main+13373 @0591a9>
	test/lang/array.ci:119: (9 bytes: <@058e83> - <@058e8c>): expected: int64 := int32(42 + i)
	<.main+12567 @058e83>: 1c 2a 00 00 00             load.c32 42
	<.main+12572 @058e88>: 10 01                      dup.x32 sp(1)
	<.main+12574 @058e8a>: 51                         add.i32
	<.main+12575 @058e8b>: 5b                         i32.2i64
	test/lang/array.ci:120: (62 bytes: <@058e8c> - <@058eca>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+12576 @058e8c>: 11 00                      dup.x64 sp(0)
	<.main+12578 @058e8e>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+12583 @058e93>: 10 05                      dup.x32 sp(5)
	<.main+12585 @058e95>: 0d 08 00 00                mad.u32 8
	<.main+12589 @058e99>: 23                         load.i64
	<.main+12590 @058e9a>: 67                         ceq.i64
	<.main+12591 @058e9b>: 06 08 00 00                jz <.main+12599 @058ea3>
	<.main+12595 @058e9f>: 04 2b 00 00                jmp <.main+12638 @058eca>
	<.main+12599 @058ea3>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12604 @058ea8>: 1c 78 00 00 00             load.c32 120
	<.main+12609 @058ead>: 1c fe ff ff ff             load.c32 -2
	<.main+12614 @058eb2>: 1c 80 00 00 00             load.c32 128
	<.main+12619 @058eb7>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12624 @058ebc>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12629 @058ec1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12634 @058ec6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (61 bytes: <@058eca> - <@058f07>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+12638 @058eca>: 11 00                      dup.x64 sp(0)
	<.main+12640 @058ecc>: 2a 20 51 05                load.m32 <@055120> ;arrArrayInitFixed
	<.main+12644 @058ed0>: 10 05                      dup.x32 sp(5)
	<.main+12646 @058ed2>: 0d 08 00 00                mad.u32 8
	<.main+12650 @058ed6>: 23                         load.i64
	<.main+12651 @058ed7>: 67                         ceq.i64
	<.main+12652 @058ed8>: 06 08 00 00                jz <.main+12660 @058ee0>
	<.main+12656 @058edc>: 04 2b 00 00                jmp <.main+12699 @058f07>
	<.main+12660 @058ee0>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12665 @058ee5>: 1c 79 00 00 00             load.c32 121
	<.main+12670 @058eea>: 1c fe ff ff ff             load.c32 -2
	<.main+12675 @058eef>: 1c 80 00 00 00             load.c32 128
	<.main+12680 @058ef4>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12685 @058ef9>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12690 @058efe>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12695 @058f03>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (61 bytes: <@058f07> - <@058f44>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+12699 @058f07>: 11 00                      dup.x64 sp(0)
	<.main+12701 @058f09>: 2a 28 51 05                load.m32 <@055128> ;arrSliceInitFixed
	<.main+12705 @058f0d>: 10 05                      dup.x32 sp(5)
	<.main+12707 @058f0f>: 0d 08 00 00                mad.u32 8
	<.main+12711 @058f13>: 23                         load.i64
	<.main+12712 @058f14>: 67                         ceq.i64
	<.main+12713 @058f15>: 06 08 00 00                jz <.main+12721 @058f1d>
	<.main+12717 @058f19>: 04 2b 00 00                jmp <.main+12760 @058f44>
	<.main+12721 @058f1d>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12726 @058f22>: 1c 7a 00 00 00             load.c32 122
	<.main+12731 @058f27>: 1c fe ff ff ff             load.c32 -2
	<.main+12736 @058f2c>: 1c 80 00 00 00             load.c32 128
	<.main+12741 @058f31>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12746 @058f36>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12751 @058f3b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12756 @058f40>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (68 bytes: <@058f44> - <@058f88>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+12760 @058f44>: 11 00                      dup.x64 sp(0)
	<.main+12762 @058f46>: 1a                         load.z64
	<.main+12763 @058f47>: 10 06                      dup.x32 sp(6)
	<.main+12765 @058f49>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+12770 @058f4e>: 1f 68 51 05 00             load.ref <@055168> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12775 @058f53>: 02                         call
	<.main+12776 @058f54>: 09 f8 ff ff                inc.sp(-8)
	<.main+12780 @058f58>: 67                         ceq.i64
	<.main+12781 @058f59>: 06 08 00 00                jz <.main+12789 @058f61>
	<.main+12785 @058f5d>: 04 2b 00 00                jmp <.main+12828 @058f88>
	<.main+12789 @058f61>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12794 @058f66>: 1c 7c 00 00 00             load.c32 124
	<.main+12799 @058f6b>: 1c fe ff ff ff             load.c32 -2
	<.main+12804 @058f70>: 1c 80 00 00 00             load.c32 128
	<.main+12809 @058f75>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12814 @058f7a>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12819 @058f7f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12824 @058f84>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (67 bytes: <@058f88> - <@058fcb>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+12828 @058f88>: 11 00                      dup.x64 sp(0)
	<.main+12830 @058f8a>: 1a                         load.z64
	<.main+12831 @058f8b>: 10 06                      dup.x32 sp(6)
	<.main+12833 @058f8d>: 2a 20 51 05                load.m32 <@055120> ;arrArrayInitFixed
	<.main+12837 @058f91>: 1f 68 51 05 00             load.ref <@055168> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12842 @058f96>: 02                         call
	<.main+12843 @058f97>: 09 f8 ff ff                inc.sp(-8)
	<.main+12847 @058f9b>: 67                         ceq.i64
	<.main+12848 @058f9c>: 06 08 00 00                jz <.main+12856 @058fa4>
	<.main+12852 @058fa0>: 04 2b 00 00                jmp <.main+12895 @058fcb>
	<.main+12856 @058fa4>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12861 @058fa9>: 1c 7d 00 00 00             load.c32 125
	<.main+12866 @058fae>: 1c fe ff ff ff             load.c32 -2
	<.main+12871 @058fb3>: 1c 80 00 00 00             load.c32 128
	<.main+12876 @058fb8>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12881 @058fbd>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12886 @058fc2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12891 @058fc7>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (67 bytes: <@058fcb> - <@05900e>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+12895 @058fcb>: 11 00                      dup.x64 sp(0)
	<.main+12897 @058fcd>: 1a                         load.z64
	<.main+12898 @058fce>: 10 06                      dup.x32 sp(6)
	<.main+12900 @058fd0>: 2a 28 51 05                load.m32 <@055128> ;arrSliceInitFixed
	<.main+12904 @058fd4>: 1f 68 51 05 00             load.ref <@055168> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12909 @058fd9>: 02                         call
	<.main+12910 @058fda>: 09 f8 ff ff                inc.sp(-8)
	<.main+12914 @058fde>: 67                         ceq.i64
	<.main+12915 @058fdf>: 06 08 00 00                jz <.main+12923 @058fe7>
	<.main+12919 @058fe3>: 04 2b 00 00                jmp <.main+12962 @05900e>
	<.main+12923 @058fe7>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12928 @058fec>: 1c 7e 00 00 00             load.c32 126
	<.main+12933 @058ff1>: 1c fe ff ff ff             load.c32 -2
	<.main+12938 @058ff6>: 1c 80 00 00 00             load.c32 128
	<.main+12943 @058ffb>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12948 @059000>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12953 @059005>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12958 @05900a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (68 bytes: <@05900e> - <@059052>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+12962 @05900e>: 11 00                      dup.x64 sp(0)
	<.main+12964 @059010>: 1a                         load.z64
	<.main+12965 @059011>: 10 06                      dup.x32 sp(6)
	<.main+12967 @059013>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+12972 @059018>: 1f 78 51 05 00             load.ref <@055178> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+12977 @05901d>: 02                         call
	<.main+12978 @05901e>: 09 f8 ff ff                inc.sp(-8)
	<.main+12982 @059022>: 67                         ceq.i64
	<.main+12983 @059023>: 06 08 00 00                jz <.main+12991 @05902b>
	<.main+12987 @059027>: 04 2b 00 00                jmp <.main+13030 @059052>
	<.main+12991 @05902b>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+12996 @059030>: 1c 80 00 00 00             load.c32 128
	<.main+13001 @059035>: 1c fe ff ff ff             load.c32 -2
	<.main+13006 @05903a>: 1c 80 00 00 00             load.c32 128
	<.main+13011 @05903f>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13016 @059044>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13021 @059049>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13026 @05904e>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (67 bytes: <@059052> - <@059095>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+13030 @059052>: 11 00                      dup.x64 sp(0)
	<.main+13032 @059054>: 1a                         load.z64
	<.main+13033 @059055>: 10 06                      dup.x32 sp(6)
	<.main+13035 @059057>: 2a 20 51 05                load.m32 <@055120> ;arrArrayInitFixed
	<.main+13039 @05905b>: 1f 78 51 05 00             load.ref <@055178> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13044 @059060>: 02                         call
	<.main+13045 @059061>: 09 f8 ff ff                inc.sp(-8)
	<.main+13049 @059065>: 67                         ceq.i64
	<.main+13050 @059066>: 06 08 00 00                jz <.main+13058 @05906e>
	<.main+13054 @05906a>: 04 2b 00 00                jmp <.main+13097 @059095>
	<.main+13058 @05906e>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+13063 @059073>: 1c 81 00 00 00             load.c32 129
	<.main+13068 @059078>: 1c fe ff ff ff             load.c32 -2
	<.main+13073 @05907d>: 1c 80 00 00 00             load.c32 128
	<.main+13078 @059082>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13083 @059087>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13088 @05908c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13093 @059091>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (67 bytes: <@059095> - <@0590d8>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+13097 @059095>: 11 00                      dup.x64 sp(0)
	<.main+13099 @059097>: 1a                         load.z64
	<.main+13100 @059098>: 10 06                      dup.x32 sp(6)
	<.main+13102 @05909a>: 2a 28 51 05                load.m32 <@055128> ;arrSliceInitFixed
	<.main+13106 @05909e>: 1f 78 51 05 00             load.ref <@055178> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13111 @0590a3>: 02                         call
	<.main+13112 @0590a4>: 09 f8 ff ff                inc.sp(-8)
	<.main+13116 @0590a8>: 67                         ceq.i64
	<.main+13117 @0590a9>: 06 08 00 00                jz <.main+13125 @0590b1>
	<.main+13121 @0590ad>: 04 2b 00 00                jmp <.main+13164 @0590d8>
	<.main+13125 @0590b1>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+13130 @0590b6>: 1c 82 00 00 00             load.c32 130
	<.main+13135 @0590bb>: 1c fe ff ff ff             load.c32 -2
	<.main+13140 @0590c0>: 1c 80 00 00 00             load.c32 128
	<.main+13145 @0590c5>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13150 @0590ca>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13155 @0590cf>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13160 @0590d4>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (73 bytes: <@0590d8> - <@059121>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+13164 @0590d8>: 11 00                      dup.x64 sp(0)
	<.main+13166 @0590da>: 1a                         load.z64
	<.main+13167 @0590db>: 10 06                      dup.x32 sp(6)
	<.main+13169 @0590dd>: 1c 07 00 00 00             load.c32 7
	<.main+13174 @0590e2>: 1f c8 50 05 00             load.ref <@0550c8> ;arrFixedNoInit
	<.main+13179 @0590e7>: 1f 88 51 05 00             load.ref <@055188> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13184 @0590ec>: 02                         call
	<.main+13185 @0590ed>: 09 f4 ff ff                inc.sp(-12)
	<.main+13189 @0590f1>: 67                         ceq.i64
	<.main+13190 @0590f2>: 06 08 00 00                jz <.main+13198 @0590fa>
	<.main+13194 @0590f6>: 04 2b 00 00                jmp <.main+13237 @059121>
	<.main+13198 @0590fa>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+13203 @0590ff>: 1c 84 00 00 00             load.c32 132
	<.main+13208 @059104>: 1c fe ff ff ff             load.c32 -2
	<.main+13213 @059109>: 1c 80 00 00 00             load.c32 128
	<.main+13218 @05910e>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13223 @059113>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13228 @059118>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13233 @05911d>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (67 bytes: <@059121> - <@059164>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+13237 @059121>: 11 00                      dup.x64 sp(0)
	<.main+13239 @059123>: 1a                         load.z64
	<.main+13240 @059124>: 10 06                      dup.x32 sp(6)
	<.main+13242 @059126>: 2b 28 51 05                load.m64 <@055128> ;arrSliceInitFixed
	<.main+13246 @05912a>: 1f 88 51 05 00             load.ref <@055188> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13251 @05912f>: 02                         call
	<.main+13252 @059130>: 09 f4 ff ff                inc.sp(-12)
	<.main+13256 @059134>: 67                         ceq.i64
	<.main+13257 @059135>: 06 08 00 00                jz <.main+13265 @05913d>
	<.main+13261 @059139>: 04 2b 00 00                jmp <.main+13304 @059164>
	<.main+13265 @05913d>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+13270 @059142>: 1c 86 00 00 00             load.c32 134
	<.main+13275 @059147>: 1c fe ff ff ff             load.c32 -2
	<.main+13280 @05914c>: 1c 80 00 00 00             load.c32 128
	<.main+13285 @059151>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13290 @059156>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13295 @05915b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13300 @059160>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (61 bytes: <@059164> - <@0591a1>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+13304 @059164>: 11 00                      dup.x64 sp(0)
	<.main+13306 @059166>: 2a 38 51 05                load.m32 <@055138> ;arrSliceInitSlice
	<.main+13310 @05916a>: 10 05                      dup.x32 sp(5)
	<.main+13312 @05916c>: 0d 08 00 00                mad.u32 8
	<.main+13316 @059170>: 23                         load.i64
	<.main+13317 @059171>: 67                         ceq.i64
	<.main+13318 @059172>: 06 08 00 00                jz <.main+13326 @05917a>
	<.main+13322 @059176>: 04 2b 00 00                jmp <.main+13365 @0591a1>
	<.main+13326 @05917a>: 1f c0 f5 03 00             load.ref <@03f5c0> ;"test/lang/array.ci"
	<.main+13331 @05917f>: 1c 88 00 00 00             load.c32 136
	<.main+13336 @059184>: 1c fe ff ff ff             load.c32 -2
	<.main+13341 @059189>: 1c 80 00 00 00             load.c32 128
	<.main+13346 @05918e>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13351 @059193>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13356 @059198>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13361 @05919d>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13365 @0591a1>: 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@0591a5> - <@0591a9>): int32(i := int32(i + 1))
	<.main+13369 @0591a5>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@0591a9> - <@0591b5>): bool(i < arrFixedNoInit.length)
	<.main+13373 @0591a9>: 10 00                      dup.x32 sp(0)
	<.main+13375 @0591ab>: 1c 07 00 00 00             load.c32 7
	<.main+13380 @0591b0>: 58                         clt.i32
	<.main+13381 @0591b1>: 05 d2 fc ff                jnz <.main+12567 @058e83>
	<.main+13385 @0591b5>: 09 fc ff ff                inc.sp(-4)
	test/lang/method.ci:78: (21 bytes: <@0591b9> - <@0591ce>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+13389 @0591b9>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13393 @0591bd>: 1c 01 00 00 00             load.c32 1
	<.main+13398 @0591c2>: 13 04                      set.x32 sp(4)
	<.main+13400 @0591c4>: 1f e8 51 05 00             load.ref <@0551e8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13405 @0591c9>: 02                         call
	<.main+13406 @0591ca>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (20 bytes: <@0591ce> - <@0591e2>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+13410 @0591ce>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13414 @0591d2>: 1c 01 00 00 00             load.c32 1
	<.main+13419 @0591d7>: 13 04                      set.x32 sp(4)
	<.main+13421 @0591d9>: 2a 98 52 05                load.m32 <@055298> ;recordMethodTest+8
	<.main+13425 @0591dd>: 02                         call
	<.main+13426 @0591de>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (19 bytes: <@0591e2> - <@0591f5>): staticMethod(void(recordMethodTest, 2));
	<.main+13430 @0591e2>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13434 @0591e6>: 1c 02 00 00 00             load.c32 2
	<.main+13439 @0591eb>: 1f a0 52 05 00             load.ref <@0552a0> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13444 @0591f0>: 02                         call
	<.main+13445 @0591f1>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (19 bytes: <@0591f5> - <@059208>): virtualMethod(void(recordMethodTest, 2));
	<.main+13449 @0591f5>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13453 @0591f9>: 1c 02 00 00 00             load.c32 2
	<.main+13458 @0591fe>: 1f e8 52 05 00             load.ref <@0552e8> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13463 @059203>: 02                         call
	<.main+13464 @059204>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (21 bytes: <@059208> - <@05921d>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+13468 @059208>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13472 @05920c>: 1c 03 00 00 00             load.c32 3
	<.main+13477 @059211>: 13 04                      set.x32 sp(4)
	<.main+13479 @059213>: 1f e8 51 05 00             load.ref <@0551e8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13484 @059218>: 02                         call
	<.main+13485 @059219>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (21 bytes: <@05921d> - <@059232>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13489 @05921d>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13493 @059221>: 1c 03 00 00 00             load.c32 3
	<.main+13498 @059226>: 13 04                      set.x32 sp(4)
	<.main+13500 @059228>: 1f 18 52 05 00             load.ref <@055218> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13505 @05922d>: 02                         call
	<.main+13506 @05922e>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (20 bytes: <@059232> - <@059246>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13510 @059232>: 2c 90 52 05                load.m128 <@055290> ;recordMethodTest
	<.main+13514 @059236>: 1c 03 00 00 00             load.c32 3
	<.main+13519 @05923b>: 13 04                      set.x32 sp(4)
	<.main+13521 @05923d>: 2a 98 52 05                load.m32 <@055298> ;recordMethodTest+8
	<.main+13525 @059241>: 02                         call
	<.main+13526 @059242>: 09 f0 ff ff                inc.sp(-16)
	test/lang/statementIf.ci:4: (39 bytes: <@059246> - <@05926d>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+13530 @059246>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13535 @05924b>: 1c 04 00 00 00             load.c32 4
	<.main+13540 @059250>: 1c 0e 00 00 00             load.c32 14
	<.main+13545 @059255>: 1c 01 00 00 00             load.c32 1
	<.main+13550 @05925a>: 1f 79 fb 04 00             load.ref <@04fb79> ;"0 == 0"
	<.main+13555 @05925f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13560 @059264>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13565 @059269>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@05926d> - <@059294>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+13569 @05926d>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13574 @059272>: 1c 0c 00 00 00             load.c32 12
	<.main+13579 @059277>: 1c 0e 00 00 00             load.c32 14
	<.main+13584 @05927c>: 1c 03 00 00 00             load.c32 3
	<.main+13589 @059281>: 1f 79 fb 04 00             load.ref <@04fb79> ;"0 == 0"
	<.main+13594 @059286>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13599 @05928b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13604 @059290>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@059294> - <@0592bb>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+13608 @059294>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13613 @059299>: 1c 16 00 00 00             load.c32 22
	<.main+13618 @05929e>: 1c 0e 00 00 00             load.c32 14
	<.main+13623 @0592a3>: 1c 06 00 00 00             load.c32 6
	<.main+13628 @0592a8>: 1f 79 fb 04 00             load.ref <@04fb79> ;"0 == 0"
	<.main+13633 @0592ad>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13638 @0592b2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13643 @0592b7>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:28: (49 bytes: <@0592bb> - <@0592ec>): if (bool(t == 0))
	<.main+13647 @0592bb>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13651 @0592bf>: 19                         load.z32
	<.main+13652 @0592c0>: 57                         ceq.i32
	<.main+13653 @0592c1>: 06 2b 00 00                jz <.main+13696 @0592ec>
	test/lang/statementIf.ci:29: (39 bytes: <@0592c5> - <@0592ec>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+13657 @0592c5>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13662 @0592ca>: 1c 1d 00 00 00             load.c32 29
	<.main+13667 @0592cf>: 1c 0e 00 00 00             load.c32 14
	<.main+13672 @0592d4>: 1c 07 00 00 00             load.c32 7
	<.main+13677 @0592d9>: 1f 87 fb 04 00             load.ref <@04fb87> ;"t == 0"
	<.main+13682 @0592de>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13687 @0592e3>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13692 @0592e8>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (49 bytes: <@0592ec> - <@05931d>): if (bool(t != 0))
	<.main+13696 @0592ec>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13700 @0592f0>: 19                         load.z32
	<.main+13701 @0592f1>: 57                         ceq.i32
	<.main+13702 @0592f2>: 05 2b 00 00                jnz <.main+13745 @05931d>
	test/lang/statementIf.ci:33: (39 bytes: <@0592f6> - <@05931d>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+13706 @0592f6>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13711 @0592fb>: 1c 21 00 00 00             load.c32 33
	<.main+13716 @059300>: 1c 0e 00 00 00             load.c32 14
	<.main+13721 @059305>: 1c 08 00 00 00             load.c32 8
	<.main+13726 @05930a>: 1f 8e fb 04 00             load.ref <@04fb8e> ;"t != 0"
	<.main+13731 @05930f>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13736 @059314>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13741 @059319>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (92 bytes: <@05931d> - <@059379>): if (bool(t == 0))
	<.main+13745 @05931d>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13749 @059321>: 19                         load.z32
	<.main+13750 @059322>: 57                         ceq.i32
	<.main+13751 @059323>: 06 2f 00 00                jz <.main+13798 @059352>
	test/lang/statementIf.ci:37: (39 bytes: <@059327> - <@05934e>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13755 @059327>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13760 @05932c>: 1c 25 00 00 00             load.c32 37
	<.main+13765 @059331>: 1c 0e 00 00 00             load.c32 14
	<.main+13770 @059336>: 1c 09 00 00 00             load.c32 9
	<.main+13775 @05933b>: 1f 87 fb 04 00             load.ref <@04fb87> ;"t == 0"
	<.main+13780 @059340>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13785 @059345>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13790 @05934a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13794 @05934e>: 04 2b 00 00                jmp <.main+13837 @059379>
	test/lang/statementIf.ci:40: (39 bytes: <@059352> - <@059379>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+13798 @059352>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13803 @059357>: 1c 28 00 00 00             load.c32 40
	<.main+13808 @05935c>: 1c 0e 00 00 00             load.c32 14
	<.main+13813 @059361>: 1c 0a 00 00 00             load.c32 10
	<.main+13818 @059366>: 1f 8e fb 04 00             load.ref <@04fb8e> ;"t != 0"
	<.main+13823 @05936b>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13828 @059370>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13833 @059375>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (92 bytes: <@059379> - <@0593d5>): if (bool(t != 0))
	<.main+13837 @059379>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13841 @05937d>: 19                         load.z32
	<.main+13842 @05937e>: 57                         ceq.i32
	<.main+13843 @05937f>: 05 2f 00 00                jnz <.main+13890 @0593ae>
	test/lang/statementIf.ci:44: (39 bytes: <@059383> - <@0593aa>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+13847 @059383>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13852 @059388>: 1c 2c 00 00 00             load.c32 44
	<.main+13857 @05938d>: 1c 0e 00 00 00             load.c32 14
	<.main+13862 @059392>: 1c 0b 00 00 00             load.c32 11
	<.main+13867 @059397>: 1f 8e fb 04 00             load.ref <@04fb8e> ;"t != 0"
	<.main+13872 @05939c>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13877 @0593a1>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13882 @0593a6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13886 @0593aa>: 04 2b 00 00                jmp <.main+13929 @0593d5>
	test/lang/statementIf.ci:47: (39 bytes: <@0593ae> - <@0593d5>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+13890 @0593ae>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13895 @0593b3>: 1c 2f 00 00 00             load.c32 47
	<.main+13900 @0593b8>: 1c 0e 00 00 00             load.c32 14
	<.main+13905 @0593bd>: 1c 0c 00 00 00             load.c32 12
	<.main+13910 @0593c2>: 1f 87 fb 04 00             load.ref <@04fb87> ;"t == 0"
	<.main+13915 @0593c7>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13920 @0593cc>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13925 @0593d1>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (377 bytes: <@0593d5> - <@05954e>): if (bool(t == 0))
	<.main+13929 @0593d5>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13933 @0593d9>: 19                         load.z32
	<.main+13934 @0593da>: 57                         ceq.i32
	<.main+13935 @0593db>: 06 2f 00 00                jz <.main+13982 @05940a>
	test/lang/statementIf.ci:51: (39 bytes: <@0593df> - <@059406>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13939 @0593df>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+13944 @0593e4>: 1c 33 00 00 00             load.c32 51
	<.main+13949 @0593e9>: 1c 0e 00 00 00             load.c32 14
	<.main+13954 @0593ee>: 1c 09 00 00 00             load.c32 9
	<.main+13959 @0593f3>: 1f 87 fb 04 00             load.ref <@04fb87> ;"t == 0"
	<.main+13964 @0593f8>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13969 @0593fd>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+13974 @059402>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13978 @059406>: 04 48 01 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:53: (324 bytes: <@05940a> - <@05954e>): if (bool(t == 1))
	<.main+13982 @05940a>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+13986 @05940e>: 1c 01 00 00 00             load.c32 1
	<.main+13991 @059413>: 57                         ceq.i32
	<.main+13992 @059414>: 06 2f 00 00                jz <.main+14039 @059443>
	test/lang/statementIf.ci:54: (39 bytes: <@059418> - <@05943f>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+13996 @059418>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14001 @05941d>: 1c 36 00 00 00             load.c32 54
	<.main+14006 @059422>: 1c 0e 00 00 00             load.c32 14
	<.main+14011 @059427>: 1c 0a 00 00 00             load.c32 10
	<.main+14016 @05942c>: 1f 95 fb 04 00             load.ref <@04fb95> ;"t == 1"
	<.main+14021 @059431>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14026 @059436>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14031 @05943b>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14035 @05943f>: 04 0f 01 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:56: (267 bytes: <@059443> - <@05954e>): if (bool(t == 2))
	<.main+14039 @059443>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+14043 @059447>: 1c 02 00 00 00             load.c32 2
	<.main+14048 @05944c>: 57                         ceq.i32
	<.main+14049 @05944d>: 06 2f 00 00                jz <.main+14096 @05947c>
	test/lang/statementIf.ci:57: (39 bytes: <@059451> - <@059478>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+14053 @059451>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14058 @059456>: 1c 39 00 00 00             load.c32 57
	<.main+14063 @05945b>: 1c 0e 00 00 00             load.c32 14
	<.main+14068 @059460>: 1c 0a 00 00 00             load.c32 10
	<.main+14073 @059465>: 1f 9c fb 04 00             load.ref <@04fb9c> ;"t == 2"
	<.main+14078 @05946a>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14083 @05946f>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14088 @059474>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14092 @059478>: 04 d6 00 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:59: (210 bytes: <@05947c> - <@05954e>): if (bool(t == 3))
	<.main+14096 @05947c>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+14100 @059480>: 1c 03 00 00 00             load.c32 3
	<.main+14105 @059485>: 57                         ceq.i32
	<.main+14106 @059486>: 06 2f 00 00                jz <.main+14153 @0594b5>
	test/lang/statementIf.ci:60: (39 bytes: <@05948a> - <@0594b1>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+14110 @05948a>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14115 @05948f>: 1c 3c 00 00 00             load.c32 60
	<.main+14120 @059494>: 1c 0e 00 00 00             load.c32 14
	<.main+14125 @059499>: 1c 0a 00 00 00             load.c32 10
	<.main+14130 @05949e>: 1f a3 fb 04 00             load.ref <@04fba3> ;"t == 3"
	<.main+14135 @0594a3>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14140 @0594a8>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14145 @0594ad>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14149 @0594b1>: 04 9d 00 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:62: (153 bytes: <@0594b5> - <@05954e>): if (bool(t == 4))
	<.main+14153 @0594b5>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+14157 @0594b9>: 1c 04 00 00 00             load.c32 4
	<.main+14162 @0594be>: 57                         ceq.i32
	<.main+14163 @0594bf>: 06 2f 00 00                jz <.main+14210 @0594ee>
	test/lang/statementIf.ci:63: (39 bytes: <@0594c3> - <@0594ea>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+14167 @0594c3>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14172 @0594c8>: 1c 3f 00 00 00             load.c32 63
	<.main+14177 @0594cd>: 1c 0e 00 00 00             load.c32 14
	<.main+14182 @0594d2>: 1c 0a 00 00 00             load.c32 10
	<.main+14187 @0594d7>: 1f aa fb 04 00             load.ref <@04fbaa> ;"t == 4"
	<.main+14192 @0594dc>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14197 @0594e1>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14202 @0594e6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14206 @0594ea>: 04 64 00 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:65: (96 bytes: <@0594ee> - <@05954e>): if (bool(t == 5))
	<.main+14210 @0594ee>: 2a 08 5b 05                load.m32 <@055b08> ;t
	<.main+14214 @0594f2>: 1c 05 00 00 00             load.c32 5
	<.main+14219 @0594f7>: 57                         ceq.i32
	<.main+14220 @0594f8>: 06 2f 00 00                jz <.main+14267 @059527>
	test/lang/statementIf.ci:66: (39 bytes: <@0594fc> - <@059523>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+14224 @0594fc>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14229 @059501>: 1c 42 00 00 00             load.c32 66
	<.main+14234 @059506>: 1c 0e 00 00 00             load.c32 14
	<.main+14239 @05950b>: 1c 0a 00 00 00             load.c32 10
	<.main+14244 @059510>: 1f b1 fb 04 00             load.ref <@04fbb1> ;"t == 5"
	<.main+14249 @059515>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14254 @05951a>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14259 @05951f>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14263 @059523>: 04 2b 00 00                jmp <.main+14306 @05954e>
	test/lang/statementIf.ci:69: (39 bytes: <@059527> - <@05954e>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+14267 @059527>: 1f 60 fb 04 00             load.ref <@04fb60> ;"test/lang/statementIf.ci"
	<.main+14272 @05952c>: 1c 45 00 00 00             load.c32 69
	<.main+14277 @059531>: 1c 0e 00 00 00             load.c32 14
	<.main+14282 @059536>: 1c 0a 00 00 00             load.c32 10
	<.main+14287 @05953b>: 1f b8 fb 04 00             load.ref <@04fbb8> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14292 @059540>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14297 @059545>: 1f 08 5b 05 00             load.ref <@055b08> ;t
	<.main+14302 @05954a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@05954e> - <@05957d>): for ( ; ; )
	<.main+14306 @05954e>: 04 2b 00 00                jmp <.main+14349 @059579>
	test/lang/statementFor.ci:4: (35 bytes: <@059552> - <@059575>): debug("for ( ; ; )");
	<.main+14310 @059552>: 1f a0 fc 04 00             load.ref <@04fca0> ;"test/lang/statementFor.ci"
	<.main+14315 @059557>: 1c 04 00 00 00             load.c32 4
	<.main+14320 @05955c>: 1c 0e 00 00 00             load.c32 14
	<.main+14325 @059561>: 19                         load.z32
	<.main+14326 @059562>: 1f ba fc 04 00             load.ref <@04fcba> ;"for ( ; ; )"
	<.main+14331 @059567>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14336 @05956c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14341 @059571>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@059575> - <@059579>): break;
	<.main+14345 @059575>: 04 08 00 00                jmp <.main+14353 @05957d>
	:: (4 bytes: <@059579> - <@05957d>)
	<.main+14349 @059579>: 04 d9 ff ff                jmp <.main+14310 @059552>
	test/lang/statementFor.ci:8: (59 bytes: <@05957d> - <@0595b8>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+14353 @05957d>: 19                         load.z32
	<.main+14354 @05957e>: 04 2a 00 00                jmp <.main+14396 @0595a8>
	test/lang/statementFor.ci:9: (34 bytes: <@059582> - <@0595a4>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+14358 @059582>: 1f a0 fc 04 00             load.ref <@04fca0> ;"test/lang/statementFor.ci"
	<.main+14363 @059587>: 1c 09 00 00 00             load.c32 9
	<.main+14368 @05958c>: 1c 0e 00 00 00             load.c32 14
	<.main+14373 @059591>: 19                         load.z32
	<.main+14374 @059592>: 1f c6 fc 04 00             load.ref <@04fcc6> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14379 @059597>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14384 @05959c>: 0a 18 00 00                load.sp(+24)
	<.main+14388 @0595a0>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@0595a4> - <@0595a8>): int32(i := int32(i + 1))
	<.main+14392 @0595a4>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@0595a8> - <@0595b4>): bool(i < 2)
	<.main+14396 @0595a8>: 10 00                      dup.x32 sp(0)
	<.main+14398 @0595aa>: 1c 02 00 00 00             load.c32 2
	<.main+14403 @0595af>: 58                         clt.i32
	<.main+14404 @0595b0>: 05 d2 ff ff                jnz <.main+14358 @059582>
	<.main+14408 @0595b4>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:13: (70 bytes: <@0595b8> - <@0595fe>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+14412 @0595b8>: 19                         load.z32
	<.main+14413 @0595b9>: 2e 10 5b 05                store.m32 <@055b10> ;forIdx
	<.main+14417 @0595bd>: 04 33 00 00                jmp <.main+14468 @0595f0>
	test/lang/statementFor.ci:14: (35 bytes: <@0595c1> - <@0595e4>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+14421 @0595c1>: 1f a0 fc 04 00             load.ref <@04fca0> ;"test/lang/statementFor.ci"
	<.main+14426 @0595c6>: 1c 0e 00 00 00             load.c32 14
	<.main+14431 @0595cb>: 1c 0e 00 00 00             load.c32 14
	<.main+14436 @0595d0>: 19                         load.z32
	<.main+14437 @0595d1>: 1f ec fc 04 00             load.ref <@04fcec> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14442 @0595d6>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14447 @0595db>: 1f 10 5b 05 00             load.ref <@055b10> ;forIdx
	<.main+14452 @0595e0>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (12 bytes: <@0595e4> - <@0595f0>): int32(forIdx := int32(forIdx + 1))
	<.main+14456 @0595e4>: 2a 10 5b 05                load.m32 <@055b10> ;forIdx
	<.main+14460 @0595e8>: 0c 01 00 00                inc.i32(+1)
	<.main+14464 @0595ec>: 2e 10 5b 05                store.m32 <@055b10> ;forIdx
	test/lang/statementFor.ci:13: (14 bytes: <@0595f0> - <@0595fe>): bool(forIdx < 2)
	<.main+14468 @0595f0>: 2a 10 5b 05                load.m32 <@055b10> ;forIdx
	<.main+14472 @0595f4>: 1c 02 00 00 00             load.c32 2
	<.main+14477 @0595f9>: 58                         clt.i32
	<.main+14478 @0595fa>: 05 c7 ff ff                jnz <.main+14421 @0595c1>
	test/lang/statementFor.ci:17: (75 bytes: <@0595fe> - <@059649>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14482 @0595fe>: 19                         load.z32
	<.main+14483 @0595ff>: 04 3a 00 00                jmp <.main+14541 @059639>
	test/lang/statementFor.ci:18: (16 bytes: <@059603> - <@059613>): if (bool(i < 2))
	<.main+14487 @059603>: 10 00                      dup.x32 sp(0)
	<.main+14489 @059605>: 1c 02 00 00 00             load.c32 2
	<.main+14494 @05960a>: 58                         clt.i32
	<.main+14495 @05960b>: 06 08 00 00                jz <.main+14503 @059613>
	test/lang/statementFor.ci:19: (4 bytes: <@05960f> - <@059613>): continue;
	<.main+14499 @05960f>: 04 26 00 00                jmp <.main+14537 @059635>
	test/lang/statementFor.ci:21: (34 bytes: <@059613> - <@059635>): debug(void("for with continue", i));
	<.main+14503 @059613>: 1f a0 fc 04 00             load.ref <@04fca0> ;"test/lang/statementFor.ci"
	<.main+14508 @059618>: 1c 15 00 00 00             load.c32 21
	<.main+14513 @05961d>: 1c 0e 00 00 00             load.c32 14
	<.main+14518 @059622>: 19                         load.z32
	<.main+14519 @059623>: 1f 16 fd 04 00             load.ref <@04fd16> ;"for with continue"
	<.main+14524 @059628>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14529 @05962d>: 0a 18 00 00                load.sp(+24)
	<.main+14533 @059631>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@059635> - <@059639>): int32(i := int32(i + 1))
	<.main+14537 @059635>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@059639> - <@059645>): bool(i < 7)
	<.main+14541 @059639>: 10 00                      dup.x32 sp(0)
	<.main+14543 @05963b>: 1c 07 00 00 00             load.c32 7
	<.main+14548 @059640>: 58                         clt.i32
	<.main+14549 @059641>: 05 c2 ff ff                jnz <.main+14487 @059603>
	<.main+14553 @059645>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@059649> - <@059694>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14557 @059649>: 19                         load.z32
	<.main+14558 @05964a>: 04 3a 00 00                jmp <.main+14616 @059684>
	test/lang/statementFor.ci:25: (16 bytes: <@05964e> - <@05965e>): if (bool(i > 2))
	<.main+14562 @05964e>: 10 00                      dup.x32 sp(0)
	<.main+14564 @059650>: 1c 02 00 00 00             load.c32 2
	<.main+14569 @059655>: 59                         cgt.i32
	<.main+14570 @059656>: 06 08 00 00                jz <.main+14578 @05965e>
	test/lang/statementFor.ci:26: (4 bytes: <@05965a> - <@05965e>): break;
	<.main+14574 @05965a>: 04 36 00 00                jmp <.main+14628 @059690>
	test/lang/statementFor.ci:28: (34 bytes: <@05965e> - <@059680>): debug(void("for with break", i));
	<.main+14578 @05965e>: 1f a0 fc 04 00             load.ref <@04fca0> ;"test/lang/statementFor.ci"
	<.main+14583 @059663>: 1c 1c 00 00 00             load.c32 28
	<.main+14588 @059668>: 1c 0e 00 00 00             load.c32 14
	<.main+14593 @05966d>: 19                         load.z32
	<.main+14594 @05966e>: 1f 28 fd 04 00             load.ref <@04fd28> ;"for with break"
	<.main+14599 @059673>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14604 @059678>: 0a 18 00 00                load.sp(+24)
	<.main+14608 @05967c>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@059680> - <@059684>): int32(i := int32(i + 1))
	<.main+14612 @059680>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@059684> - <@059690>): bool(i < 7)
	<.main+14616 @059684>: 10 00                      dup.x32 sp(0)
	<.main+14618 @059686>: 1c 07 00 00 00             load.c32 7
	<.main+14623 @05968b>: 58                         clt.i32
	<.main+14624 @05968c>: 05 c2 ff ff                jnz <.main+14562 @05964e>
	<.main+14628 @059690>: 09 fc ff ff                inc.sp(-4)
	<.main+14632 @059694>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 347.79] > .main
[ 348.55]  > funAdd(x: int32, y: int32): int32
[ 348.57]  < return
[ 348.58]  > funAdd(x: int32, y: int32): int32
[ 348.60]  < return
[ 348.61]  > funMul(x: int32, y: int32): int32
[ 348.62]  < return
[ 348.64]  > funMul(x: int32, y: int32): int32
[ 348.65]  < return
[ 348.66]  > fib(n: uint32): uint32
[ 348.68]   > fib(n: uint32): uint32
[ 348.69]    > fib(n: uint32): uint32
[ 348.73]     > fib(n: uint32): uint32
[ 348.74]      > fib(n: uint32): uint32
[ 348.76]       > fib(n: uint32): uint32
[ 348.79]        > fib(n: uint32): uint32
[ 348.80]         > fib(n: uint32): uint32
[ 348.82]          > fib(n: uint32): uint32
[ 348.83]           > fib(n: uint32): uint32
[ 348.85]            > fib(n: uint32): uint32
[ 348.87]             > fib(n: uint32): uint32
[ 348.88]              > fib(n: uint32): uint32
[ 348.89]              < return
[ 348.90]              > fib(n: uint32): uint32
[ 348.92]              < return
[ 348.93]             < return
[ 348.94]             > fib(n: uint32): uint32
[ 348.97]             < return
[ 348.98]            < return
[ 349.00]            > fib(n: uint32): uint32
[ 349.02]             > fib(n: uint32): uint32
[ 349.04]             < return
[ 349.05]             > fib(n: uint32): uint32
[ 349.06]             < return
[ 349.07]            < return
[ 349.08]           < return
[ 349.08]           > fib(n: uint32): uint32
[ 349.10]            > fib(n: uint32): uint32
[ 349.13]             > fib(n: uint32): uint32
[ 349.14]             < return
[ 349.15]             > fib(n: uint32): uint32
[ 349.17]             < return
[ 349.18]            < return
[ 349.18]            > fib(n: uint32): uint32
[ 349.20]            < return
[ 349.23]           < return
[ 349.25]          < return
[ 349.26]          > fib(n: uint32): uint32
[ 349.27]           > fib(n: uint32): uint32
[ 349.29]            > fib(n: uint32): uint32
[ 349.30]             > fib(n: uint32): uint32
[ 349.33]             < return
[ 349.34]             > fib(n: uint32): uint32
[ 349.35]             < return
[ 349.36]            < return
[ 349.37]            > fib(n: uint32): uint32
[ 349.38]            < return
[ 349.39]           < return
[ 349.40]           > fib(n: uint32): uint32
[ 349.42]            > fib(n: uint32): uint32
[ 349.43]            < return
[ 349.44]            > fib(n: uint32): uint32
[ 349.45]            < return
[ 349.48]           < return
[ 349.49]          < return
[ 349.51]         < return
[ 349.54]         > fib(n: uint32): uint32
[ 349.55]          > fib(n: uint32): uint32
[ 349.58]           > fib(n: uint32): uint32
[ 349.60]            > fib(n: uint32): uint32
[ 349.61]             > fib(n: uint32): uint32
[ 349.63]             < return
[ 349.64]             > fib(n: uint32): uint32
[ 349.65]             < return
[ 349.66]            < return
[ 349.67]            > fib(n: uint32): uint32
[ 349.68]            < return
[ 349.69]           < return
[ 349.70]           > fib(n: uint32): uint32
[ 349.73]            > fib(n: uint32): uint32
[ 349.74]            < return
[ 349.75]            > fib(n: uint32): uint32
[ 349.77]            < return
[ 349.78]           < return
[ 349.78]          < return
[ 349.79]          > fib(n: uint32): uint32
[ 349.81]           > fib(n: uint32): uint32
[ 349.82]            > fib(n: uint32): uint32
[ 349.84]            < return
[ 349.85]            > fib(n: uint32): uint32
[ 349.86]            < return
[ 349.87]           < return
[ 349.90]           > fib(n: uint32): uint32
[ 349.93]           < return
[ 349.94]          < return
[ 349.94]         < return
[ 349.95]        < return
[ 349.96]        > fib(n: uint32): uint32
[ 349.98]         > fib(n: uint32): uint32
[ 350.01]          > fib(n: uint32): uint32
[ 350.02]           > fib(n: uint32): uint32
[ 350.04]            > fib(n: uint32): uint32
[ 350.05]             > fib(n: uint32): uint32
[ 350.06]             < return
[ 350.07]             > fib(n: uint32): uint32
[ 350.09]             < return
[ 350.10]            < return
[ 350.11]            > fib(n: uint32): uint32
[ 350.12]            < return
[ 350.13]           < return
[ 350.14]           > fib(n: uint32): uint32
[ 350.15]            > fib(n: uint32): uint32
[ 350.17]            < return
[ 350.17]            > fib(n: uint32): uint32
[ 350.19]            < return
[ 350.20]           < return
[ 350.20]          < return
[ 350.21]          > fib(n: uint32): uint32
[ 350.25]           > fib(n: uint32): uint32
[ 350.26]            > fib(n: uint32): uint32
[ 350.28]            < return
[ 350.30]            > fib(n: uint32): uint32
[ 350.31]            < return
[ 350.32]           < return
[ 350.33]           > fib(n: uint32): uint32
[ 350.34]           < return
[ 350.35]          < return
[ 350.36]         < return
[ 350.37]         > fib(n: uint32): uint32
[ 350.38]          > fib(n: uint32): uint32
[ 350.40]           > fib(n: uint32): uint32
[ 350.42]            > fib(n: uint32): uint32
[ 350.43]            < return
[ 350.44]            > fib(n: uint32): uint32
[ 350.45]            < return
[ 350.46]           < return
[ 350.47]           > fib(n: uint32): uint32
[ 350.48]           < return
[ 350.49]          < return
[ 350.50]          > fib(n: uint32): uint32
[ 350.52]           > fib(n: uint32): uint32
[ 350.53]           < return
[ 350.54]           > fib(n: uint32): uint32
[ 350.55]           < return
[ 350.56]          < return
[ 350.57]         < return
[ 350.58]        < return
[ 350.59]       < return
[ 350.60]       > fib(n: uint32): uint32
[ 350.61]        > fib(n: uint32): uint32
[ 350.63]         > fib(n: uint32): uint32
[ 350.66]          > fib(n: uint32): uint32
[ 350.69]           > fib(n: uint32): uint32
[ 350.70]            > fib(n: uint32): uint32
[ 350.72]             > fib(n: uint32): uint32
[ 350.73]             < return
[ 350.74]             > fib(n: uint32): uint32
[ 350.77]             < return
[ 350.78]            < return
[ 350.79]            > fib(n: uint32): uint32
[ 350.80]            < return
[ 350.81]           < return
[ 350.82]           > fib(n: uint32): uint32
[ 350.84]            > fib(n: uint32): uint32
[ 350.85]            < return
[ 350.86]            > fib(n: uint32): uint32
[ 350.87]            < return
[ 350.88]           < return
[ 350.91]          < return
[ 350.92]          > fib(n: uint32): uint32
[ 350.93]           > fib(n: uint32): uint32
[ 350.95]            > fib(n: uint32): uint32
[ 350.96]            < return
[ 350.97]            > fib(n: uint32): uint32
[ 350.99]            < return
[ 351.00]           < return
[ 351.00]           > fib(n: uint32): uint32
[ 351.02]           < return
[ 351.03]          < return
[ 351.04]         < return
[ 351.05]         > fib(n: uint32): uint32
[ 351.09]          > fib(n: uint32): uint32
[ 351.12]           > fib(n: uint32): uint32
[ 351.13]            > fib(n: uint32): uint32
[ 351.15]            < return
[ 351.16]            > fib(n: uint32): uint32
[ 351.17]            < return
[ 351.18]           < return
[ 351.19]           > fib(n: uint32): uint32
[ 351.20]           < return
[ 351.21]          < return
[ 351.22]          > fib(n: uint32): uint32
[ 351.23]           > fib(n: uint32): uint32
[ 351.25]           < return
[ 351.26]           > fib(n: uint32): uint32
[ 351.27]           < return
[ 351.29]          < return
[ 351.30]         < return
[ 351.31]        < return
[ 351.32]        > fib(n: uint32): uint32
[ 351.33]         > fib(n: uint32): uint32
[ 351.36]          > fib(n: uint32): uint32
[ 351.38]           > fib(n: uint32): uint32
[ 351.40]            > fib(n: uint32): uint32
[ 351.41]            < return
[ 351.42]            > fib(n: uint32): uint32
[ 351.43]            < return
[ 351.44]           < return
[ 351.45]           > fib(n: uint32): uint32
[ 351.46]           < return
[ 351.47]          < return
[ 351.48]          > fib(n: uint32): uint32
[ 351.50]           > fib(n: uint32): uint32
[ 351.51]           < return
[ 351.52]           > fib(n: uint32): uint32
[ 351.53]           < return
[ 351.54]          < return
[ 351.55]         < return
[ 351.56]         > fib(n: uint32): uint32
[ 351.57]          > fib(n: uint32): uint32
[ 351.59]           > fib(n: uint32): uint32
[ 351.62]           < return
[ 351.63]           > fib(n: uint32): uint32
[ 351.66]           < return
[ 351.68]          < return
[ 351.70]          > fib(n: uint32): uint32
[ 351.72]          < return
[ 351.73]         < return
[ 351.74]        < return
[ 351.74]       < return
[ 351.75]      < return
[ 351.76]      > fib(n: uint32): uint32
[ 351.78]       > fib(n: uint32): uint32
[ 351.79]        > fib(n: uint32): uint32
[ 351.81]         > fib(n: uint32): uint32
[ 351.82]          > fib(n: uint32): uint32
[ 351.84]           > fib(n: uint32): uint32
[ 351.85]            > fib(n: uint32): uint32
[ 351.87]             > fib(n: uint32): uint32
[ 351.88]             < return
[ 351.89]             > fib(n: uint32): uint32
[ 351.90]             < return
[ 351.91]            < return
[ 351.92]            > fib(n: uint32): uint32
[ 351.94]            < return
[ 351.94]           < return
[ 351.95]           > fib(n: uint32): uint32
[ 351.97]            > fib(n: uint32): uint32
[ 351.98]            < return
[ 351.99]            > fib(n: uint32): uint32
[ 352.00]            < return
[ 352.01]           < return
[ 352.02]          < return
[ 352.03]          > fib(n: uint32): uint32
[ 352.06]           > fib(n: uint32): uint32
[ 352.08]            > fib(n: uint32): uint32
[ 352.09]            < return
[ 352.10]            > fib(n: uint32): uint32
[ 352.12]            < return
[ 352.13]           < return
[ 352.13]           > fib(n: uint32): uint32
[ 352.15]           < return
[ 352.16]          < return
[ 352.17]         < return
[ 352.18]         > fib(n: uint32): uint32
[ 352.19]          > fib(n: uint32): uint32
[ 352.21]           > fib(n: uint32): uint32
[ 352.22]            > fib(n: uint32): uint32
[ 352.24]            < return
[ 352.25]            > fib(n: uint32): uint32
[ 352.26]            < return
[ 352.27]           < return
[ 352.28]           > fib(n: uint32): uint32
[ 352.29]           < return
[ 352.30]          < return
[ 352.33]          > fib(n: uint32): uint32
[ 352.36]           > fib(n: uint32): uint32
[ 352.38]           < return
[ 352.38]           > fib(n: uint32): uint32
[ 352.41]           < return
[ 352.42]          < return
[ 352.43]         < return
[ 352.44]        < return
[ 352.45]        > fib(n: uint32): uint32
[ 352.46]         > fib(n: uint32): uint32
[ 352.48]          > fib(n: uint32): uint32
[ 352.50]           > fib(n: uint32): uint32
[ 352.51]            > fib(n: uint32): uint32
[ 352.52]            < return
[ 352.54]            > fib(n: uint32): uint32
[ 352.55]            < return
[ 352.56]           < return
[ 352.58]           > fib(n: uint32): uint32
[ 352.59]           < return
[ 352.60]          < return
[ 352.61]          > fib(n: uint32): uint32
[ 352.63]           > fib(n: uint32): uint32
[ 352.64]           < return
[ 352.65]           > fib(n: uint32): uint32
[ 352.66]           < return
[ 352.67]          < return
[ 352.68]         < return
[ 352.71]         > fib(n: uint32): uint32
[ 352.72]          > fib(n: uint32): uint32
[ 352.74]           > fib(n: uint32): uint32
[ 352.77]           < return
[ 352.78]           > fib(n: uint32): uint32
[ 352.79]           < return
[ 352.80]          < return
[ 352.81]          > fib(n: uint32): uint32
[ 352.82]          < return
[ 352.83]         < return
[ 352.84]        < return
[ 352.85]       < return
[ 352.86]       > fib(n: uint32): uint32
[ 352.87]        > fib(n: uint32): uint32
[ 352.89]         > fib(n: uint32): uint32
[ 352.90]          > fib(n: uint32): uint32
[ 352.92]           > fib(n: uint32): uint32
[ 352.93]            > fib(n: uint32): uint32
[ 352.95]            < return
[ 352.98]            > fib(n: uint32): uint32
[ 352.99]            < return
[ 353.00]           < return
[ 353.01]           > fib(n: uint32): uint32
[ 353.03]           < return
[ 353.05]          < return
[ 353.06]          > fib(n: uint32): uint32
[ 353.10]           > fib(n: uint32): uint32
[ 353.11]           < return
[ 353.12]           > fib(n: uint32): uint32
[ 353.15]           < return
[ 353.15]          < return
[ 353.16]         < return
[ 353.17]         > fib(n: uint32): uint32
[ 353.19]          > fib(n: uint32): uint32
[ 353.20]           > fib(n: uint32): uint32
[ 353.22]           < return
[ 353.23]           > fib(n: uint32): uint32
[ 353.24]           < return
[ 353.25]          < return
[ 353.26]          > fib(n: uint32): uint32
[ 353.27]          < return
[ 353.28]         < return
[ 353.29]        < return
[ 353.30]        > fib(n: uint32): uint32
[ 353.31]         > fib(n: uint32): uint32
[ 353.33]          > fib(n: uint32): uint32
[ 353.34]           > fib(n: uint32): uint32
[ 353.36]           < return
[ 353.37]           > fib(n: uint32): uint32
[ 353.38]           < return
[ 353.39]          < return
[ 353.40]          > fib(n: uint32): uint32
[ 353.41]          < return
[ 353.42]         < return
[ 353.43]         > fib(n: uint32): uint32
[ 353.44]          > fib(n: uint32): uint32
[ 353.46]          < return
[ 353.47]          > fib(n: uint32): uint32
[ 353.50]          < return
[ 353.51]         < return
[ 353.52]        < return
[ 353.54]       < return
[ 353.56]      < return
[ 353.57]     < return
[ 353.58]     > fib(n: uint32): uint32
[ 353.59]      > fib(n: uint32): uint32
[ 353.61]       > fib(n: uint32): uint32
[ 353.62]        > fib(n: uint32): uint32
[ 353.64]         > fib(n: uint32): uint32
[ 353.65]          > fib(n: uint32): uint32
[ 353.67]           > fib(n: uint32): uint32
[ 353.68]            > fib(n: uint32): uint32
[ 353.70]             > fib(n: uint32): uint32
[ 353.71]             < return
[ 353.72]             > fib(n: uint32): uint32
[ 353.74]             < return
[ 353.76]            < return
[ 353.77]            > fib(n: uint32): uint32
[ 353.79]            < return
[ 353.80]           < return
[ 353.81]           > fib(n: uint32): uint32
[ 353.82]            > fib(n: uint32): uint32
[ 353.83]            < return
[ 353.85]            > fib(n: uint32): uint32
[ 353.86]            < return
[ 353.87]           < return
[ 353.89]          < return
[ 353.90]          > fib(n: uint32): uint32
[ 353.92]           > fib(n: uint32): uint32
[ 353.93]            > fib(n: uint32): uint32
[ 353.94]            < return
[ 353.95]            > fib(n: uint32): uint32
[ 353.98]            < return
[ 353.99]           < return
[ 354.00]           > fib(n: uint32): uint32
[ 354.01]           < return
[ 354.02]          < return
[ 354.03]         < return
[ 354.04]         > fib(n: uint32): uint32
[ 354.05]          > fib(n: uint32): uint32
[ 354.07]           > fib(n: uint32): uint32
[ 354.08]            > fib(n: uint32): uint32
[ 354.10]            < return
[ 354.11]            > fib(n: uint32): uint32
[ 354.12]            < return
[ 354.15]           < return
[ 354.16]           > fib(n: uint32): uint32
[ 354.17]           < return
[ 354.18]          < return
[ 354.20]          > fib(n: uint32): uint32
[ 354.22]           > fib(n: uint32): uint32
[ 354.23]           < return
[ 354.24]           > fib(n: uint32): uint32
[ 354.25]           < return
[ 354.26]          < return
[ 354.27]         < return
[ 354.28]        < return
[ 354.29]        > fib(n: uint32): uint32
[ 354.30]         > fib(n: uint32): uint32
[ 354.32]          > fib(n: uint32): uint32
[ 354.33]           > fib(n: uint32): uint32
[ 354.35]            > fib(n: uint32): uint32
[ 354.36]            < return
[ 354.37]            > fib(n: uint32): uint32
[ 354.39]            < return
[ 354.40]           < return
[ 354.41]           > fib(n: uint32): uint32
[ 354.42]           < return
[ 354.43]          < return
[ 354.44]          > fib(n: uint32): uint32
[ 354.45]           > fib(n: uint32): uint32
[ 354.49]           < return
[ 354.50]           > fib(n: uint32): uint32
[ 354.51]           < return
[ 354.53]          < return
[ 354.54]         < return
[ 354.55]         > fib(n: uint32): uint32
[ 354.56]          > fib(n: uint32): uint32
[ 354.58]           > fib(n: uint32): uint32
[ 354.59]           < return
[ 354.60]           > fib(n: uint32): uint32
[ 354.62]           < return
[ 354.62]          < return
[ 354.63]          > fib(n: uint32): uint32
[ 354.65]          < return
[ 354.65]         < return
[ 354.66]        < return
[ 354.67]       < return
[ 354.68]       > fib(n: uint32): uint32
[ 354.70]        > fib(n: uint32): uint32
[ 354.71]         > fib(n: uint32): uint32
[ 354.73]          > fib(n: uint32): uint32
[ 354.74]           > fib(n: uint32): uint32
[ 354.76]            > fib(n: uint32): uint32
[ 354.77]            < return
[ 354.78]            > fib(n: uint32): uint32
[ 354.79]            < return
[ 354.80]           < return
[ 354.81]           > fib(n: uint32): uint32
[ 354.82]           < return
[ 354.83]          < return
[ 354.84]          > fib(n: uint32): uint32
[ 354.86]           > fib(n: uint32): uint32
[ 354.89]           < return
[ 354.91]           > fib(n: uint32): uint32
[ 354.93]           < return
[ 354.94]          < return
[ 354.94]         < return
[ 354.95]         > fib(n: uint32): uint32
[ 354.97]          > fib(n: uint32): uint32
[ 355.00]           > fib(n: uint32): uint32
[ 355.01]           < return
[ 355.02]           > fib(n: uint32): uint32
[ 355.03]           < return
[ 355.04]          < return
[ 355.05]          > fib(n: uint32): uint32
[ 355.06]          < return
[ 355.07]         < return
[ 355.08]        < return
[ 355.09]        > fib(n: uint32): uint32
[ 355.11]         > fib(n: uint32): uint32
[ 355.12]          > fib(n: uint32): uint32
[ 355.16]           > fib(n: uint32): uint32
[ 355.17]           < return
[ 355.18]           > fib(n: uint32): uint32
[ 355.19]           < return
[ 355.20]          < return
[ 355.23]          > fib(n: uint32): uint32
[ 355.24]          < return
[ 355.25]         < return
[ 355.26]         > fib(n: uint32): uint32
[ 355.27]          > fib(n: uint32): uint32
[ 355.29]          < return
[ 355.30]          > fib(n: uint32): uint32
[ 355.31]          < return
[ 355.32]         < return
[ 355.33]        < return
[ 355.34]       < return
[ 355.35]      < return
[ 355.35]      > fib(n: uint32): uint32
[ 355.38]       > fib(n: uint32): uint32
[ 355.40]        > fib(n: uint32): uint32
[ 355.41]         > fib(n: uint32): uint32
[ 355.43]          > fib(n: uint32): uint32
[ 355.44]           > fib(n: uint32): uint32
[ 355.46]            > fib(n: uint32): uint32
[ 355.47]            < return
[ 355.48]            > fib(n: uint32): uint32
[ 355.50]            < return
[ 355.50]           < return
[ 355.51]           > fib(n: uint32): uint32
[ 355.56]           < return
[ 355.57]          < return
[ 355.58]          > fib(n: uint32): uint32
[ 355.59]           > fib(n: uint32): uint32
[ 355.61]           < return
[ 355.62]           > fib(n: uint32): uint32
[ 355.64]           < return
[ 355.65]          < return
[ 355.66]         < return
[ 355.67]         > fib(n: uint32): uint32
[ 355.69]          > fib(n: uint32): uint32
[ 355.70]           > fib(n: uint32): uint32
[ 355.71]           < return
[ 355.72]           > fib(n: uint32): uint32
[ 355.74]           < return
[ 355.75]          < return
[ 355.75]          > fib(n: uint32): uint32
[ 355.77]          < return
[ 355.78]         < return
[ 355.78]        < return
[ 355.79]        > fib(n: uint32): uint32
[ 355.81]         > fib(n: uint32): uint32
[ 355.82]          > fib(n: uint32): uint32
[ 355.84]           > fib(n: uint32): uint32
[ 355.85]           < return
[ 355.86]           > fib(n: uint32): uint32
[ 355.89]           < return
[ 355.90]          < return
[ 355.91]          > fib(n: uint32): uint32
[ 355.94]          < return
[ 355.95]         < return
[ 355.96]         > fib(n: uint32): uint32
[ 355.97]          > fib(n: uint32): uint32
[ 355.99]          < return
[ 356.00]          > fib(n: uint32): uint32
[ 356.01]          < return
[ 356.02]         < return
[ 356.03]        < return
[ 356.04]       < return
[ 356.05]       > fib(n: uint32): uint32
[ 356.06]        > fib(n: uint32): uint32
[ 356.08]         > fib(n: uint32): uint32
[ 356.09]          > fib(n: uint32): uint32
[ 356.11]           > fib(n: uint32): uint32
[ 356.12]           < return
[ 356.13]           > fib(n: uint32): uint32
[ 356.14]           < return
[ 356.15]          < return
[ 356.16]          > fib(n: uint32): uint32
[ 356.17]          < return
[ 356.18]         < return
[ 356.19]         > fib(n: uint32): uint32
[ 356.21]          > fib(n: uint32): uint32
[ 356.22]          < return
[ 356.23]          > fib(n: uint32): uint32
[ 356.24]          < return
[ 356.25]         < return
[ 356.26]        < return
[ 356.27]        > fib(n: uint32): uint32
[ 356.30]         > fib(n: uint32): uint32
[ 356.33]          > fib(n: uint32): uint32
[ 356.35]          < return
[ 356.36]          > fib(n: uint32): uint32
[ 356.37]          < return
[ 356.38]         < return
[ 356.39]         > fib(n: uint32): uint32
[ 356.41]         < return
[ 356.42]        < return
[ 356.43]       < return
[ 356.44]      < return
[ 356.45]     < return
[ 356.46]    < return
[ 356.46]    > fib(n: uint32): uint32
[ 356.48]     > fib(n: uint32): uint32
[ 356.50]      > fib(n: uint32): uint32
[ 356.51]       > fib(n: uint32): uint32
[ 356.53]        > fib(n: uint32): uint32
[ 356.56]         > fib(n: uint32): uint32
[ 356.58]          > fib(n: uint32): uint32
[ 356.59]           > fib(n: uint32): uint32
[ 356.61]            > fib(n: uint32): uint32
[ 356.62]             > fib(n: uint32): uint32
[ 356.65]             < return
[ 356.66]             > fib(n: uint32): uint32
[ 356.68]             < return
[ 356.68]            < return
[ 356.69]            > fib(n: uint32): uint32
[ 356.71]            < return
[ 356.72]           < return
[ 356.73]           > fib(n: uint32): uint32
[ 356.74]            > fib(n: uint32): uint32
[ 356.75]            < return
[ 356.76]            > fib(n: uint32): uint32
[ 356.78]            < return
[ 356.80]           < return
[ 356.81]          < return
[ 356.82]          > fib(n: uint32): uint32
[ 356.83]           > fib(n: uint32): uint32
[ 356.85]            > fib(n: uint32): uint32
[ 356.86]            < return
[ 356.87]            > fib(n: uint32): uint32
[ 356.88]            < return
[ 356.89]           < return
[ 356.90]           > fib(n: uint32): uint32
[ 356.92]           < return
[ 356.94]          < return
[ 356.95]         < return
[ 356.96]         > fib(n: uint32): uint32
[ 357.00]          > fib(n: uint32): uint32
[ 357.01]           > fib(n: uint32): uint32
[ 357.03]            > fib(n: uint32): uint32
[ 357.04]            < return
[ 357.05]            > fib(n: uint32): uint32
[ 357.07]            < return
[ 357.07]           < return
[ 357.08]           > fib(n: uint32): uint32
[ 357.10]           < return
[ 357.11]          < return
[ 357.13]          > fib(n: uint32): uint32
[ 357.14]           > fib(n: uint32): uint32
[ 357.16]           < return
[ 357.17]           > fib(n: uint32): uint32
[ 357.18]           < return
[ 357.19]          < return
[ 357.20]         < return
[ 357.20]        < return
[ 357.21]        > fib(n: uint32): uint32
[ 357.23]         > fib(n: uint32): uint32
[ 357.24]          > fib(n: uint32): uint32
[ 357.26]           > fib(n: uint32): uint32
[ 357.27]            > fib(n: uint32): uint32
[ 357.31]            < return
[ 357.32]            > fib(n: uint32): uint32
[ 357.33]            < return
[ 357.34]           < return
[ 357.36]           > fib(n: uint32): uint32
[ 357.38]           < return
[ 357.38]          < return
[ 357.39]          > fib(n: uint32): uint32
[ 357.41]           > fib(n: uint32): uint32
[ 357.42]           < return
[ 357.43]           > fib(n: uint32): uint32
[ 357.45]           < return
[ 357.46]          < return
[ 357.46]         < return
[ 357.47]         > fib(n: uint32): uint32
[ 357.49]          > fib(n: uint32): uint32
[ 357.50]           > fib(n: uint32): uint32
[ 357.52]           < return
[ 357.53]           > fib(n: uint32): uint32
[ 357.54]           < return
[ 357.55]          < return
[ 357.56]          > fib(n: uint32): uint32
[ 357.57]          < return
[ 357.58]         < return
[ 357.59]        < return
[ 357.60]       < return
[ 357.61]       > fib(n: uint32): uint32
[ 357.62]        > fib(n: uint32): uint32
[ 357.64]         > fib(n: uint32): uint32
[ 357.65]          > fib(n: uint32): uint32
[ 357.67]           > fib(n: uint32): uint32
[ 357.68]            > fib(n: uint32): uint32
[ 357.71]            < return
[ 357.72]            > fib(n: uint32): uint32
[ 357.74]            < return
[ 357.75]           < return
[ 357.77]           > fib(n: uint32): uint32
[ 357.78]           < return
[ 357.79]          < return
[ 357.80]          > fib(n: uint32): uint32
[ 357.82]           > fib(n: uint32): uint32
[ 357.83]           < return
[ 357.84]           > fib(n: uint32): uint32
[ 357.85]           < return
[ 357.86]          < return
[ 357.87]         < return
[ 357.88]         > fib(n: uint32): uint32
[ 357.89]          > fib(n: uint32): uint32
[ 357.91]           > fib(n: uint32): uint32
[ 357.92]           < return
[ 357.93]           > fib(n: uint32): uint32
[ 357.96]           < return
[ 357.97]          < return
[ 357.98]          > fib(n: uint32): uint32
[ 358.00]          < return
[ 358.01]         < return
[ 358.01]        < return
[ 358.02]        > fib(n: uint32): uint32
[ 358.04]         > fib(n: uint32): uint32
[ 358.07]          > fib(n: uint32): uint32
[ 358.08]           > fib(n: uint32): uint32
[ 358.10]           < return
[ 358.11]           > fib(n: uint32): uint32
[ 358.12]           < return
[ 358.14]          < return
[ 358.17]          > fib(n: uint32): uint32
[ 358.18]          < return
[ 358.19]         < return
[ 358.20]         > fib(n: uint32): uint32
[ 358.21]          > fib(n: uint32): uint32
[ 358.23]          < return
[ 358.24]          > fib(n: uint32): uint32
[ 358.25]          < return
[ 358.26]         < return
[ 358.27]        < return
[ 358.27]       < return
[ 358.28]      < return
[ 358.29]      > fib(n: uint32): uint32
[ 358.31]       > fib(n: uint32): uint32
[ 358.32]        > fib(n: uint32): uint32
[ 358.36]         > fib(n: uint32): uint32
[ 358.37]          > fib(n: uint32): uint32
[ 358.39]           > fib(n: uint32): uint32
[ 358.42]            > fib(n: uint32): uint32
[ 358.43]            < return
[ 358.44]            > fib(n: uint32): uint32
[ 358.45]            < return
[ 358.46]           < return
[ 358.47]           > fib(n: uint32): uint32
[ 358.49]           < return
[ 358.49]          < return
[ 358.50]          > fib(n: uint32): uint32
[ 358.52]           > fib(n: uint32): uint32
[ 358.53]           < return
[ 358.54]           > fib(n: uint32): uint32
[ 358.55]           < return
[ 358.56]          < return
[ 358.57]         < return
[ 358.58]         > fib(n: uint32): uint32
[ 358.60]          > fib(n: uint32): uint32
[ 358.61]           > fib(n: uint32): uint32
[ 358.62]           < return
[ 358.63]           > fib(n: uint32): uint32
[ 358.65]           < return
[ 358.65]          < return
[ 358.68]          > fib(n: uint32): uint32
[ 358.70]          < return
[ 358.71]         < return
[ 358.71]        < return
[ 358.74]        > fib(n: uint32): uint32
[ 358.75]         > fib(n: uint32): uint32
[ 358.77]          > fib(n: uint32): uint32
[ 358.78]           > fib(n: uint32): uint32
[ 358.80]           < return
[ 358.81]           > fib(n: uint32): uint32
[ 358.82]           < return
[ 358.83]          < return
[ 358.84]          > fib(n: uint32): uint32
[ 358.85]          < return
[ 358.86]         < return
[ 358.87]         > fib(n: uint32): uint32
[ 358.88]          > fib(n: uint32): uint32
[ 358.90]          < return
[ 358.91]          > fib(n: uint32): uint32
[ 358.92]          < return
[ 358.93]         < return
[ 358.94]        < return
[ 358.95]       < return
[ 358.96]       > fib(n: uint32): uint32
[ 358.97]        > fib(n: uint32): uint32
[ 358.99]         > fib(n: uint32): uint32
[ 359.00]          > fib(n: uint32): uint32
[ 359.02]           > fib(n: uint32): uint32
[ 359.03]           < return
[ 359.04]           > fib(n: uint32): uint32
[ 359.06]           < return
[ 359.06]          < return
[ 359.09]          > fib(n: uint32): uint32
[ 359.12]          < return
[ 359.13]         < return
[ 359.14]         > fib(n: uint32): uint32
[ 359.15]          > fib(n: uint32): uint32
[ 359.17]          < return
[ 359.19]          > fib(n: uint32): uint32
[ 359.20]          < return
[ 359.21]         < return
[ 359.22]        < return
[ 359.23]        > fib(n: uint32): uint32
[ 359.25]         > fib(n: uint32): uint32
[ 359.26]          > fib(n: uint32): uint32
[ 359.27]          < return
[ 359.28]          > fib(n: uint32): uint32
[ 359.30]          < return
[ 359.31]         < return
[ 359.31]         > fib(n: uint32): uint32
[ 359.33]         < return
[ 359.36]        < return
[ 359.38]       < return
[ 359.39]      < return
[ 359.39]     < return
[ 359.40]     > fib(n: uint32): uint32
[ 359.42]      > fib(n: uint32): uint32
[ 359.44]       > fib(n: uint32): uint32
[ 359.45]        > fib(n: uint32): uint32
[ 359.47]         > fib(n: uint32): uint32
[ 359.48]          > fib(n: uint32): uint32
[ 359.50]           > fib(n: uint32): uint32
[ 359.51]            > fib(n: uint32): uint32
[ 359.53]            < return
[ 359.54]            > fib(n: uint32): uint32
[ 359.55]            < return
[ 359.56]           < return
[ 359.57]           > fib(n: uint32): uint32
[ 359.60]           < return
[ 359.60]          < return
[ 359.61]          > fib(n: uint32): uint32
[ 359.63]           > fib(n: uint32): uint32
[ 359.64]           < return
[ 359.65]           > fib(n: uint32): uint32
[ 359.66]           < return
[ 359.67]          < return
[ 359.68]         < return
[ 359.69]         > fib(n: uint32): uint32
[ 359.70]          > fib(n: uint32): uint32
[ 359.74]           > fib(n: uint32): uint32
[ 359.77]           < return
[ 359.79]           > fib(n: uint32): uint32
[ 359.81]           < return
[ 359.81]          < return
[ 359.82]          > fib(n: uint32): uint32
[ 359.84]          < return
[ 359.84]         < return
[ 359.85]        < return
[ 359.86]        > fib(n: uint32): uint32
[ 359.88]         > fib(n: uint32): uint32
[ 359.89]          > fib(n: uint32): uint32
[ 359.91]           > fib(n: uint32): uint32
[ 359.92]           < return
[ 359.93]           > fib(n: uint32): uint32
[ 359.94]           < return
[ 359.95]          < return
[ 359.96]          > fib(n: uint32): uint32
[ 359.98]          < return
[ 359.98]         < return
[ 359.99]         > fib(n: uint32): uint32
[ 360.01]          > fib(n: uint32): uint32
[ 360.02]          < return
[ 360.03]          > fib(n: uint32): uint32
[ 360.04]          < return
[ 360.07]         < return
[ 360.09]        < return
[ 360.10]       < return
[ 360.11]       > fib(n: uint32): uint32
[ 360.13]        > fib(n: uint32): uint32
[ 360.14]         > fib(n: uint32): uint32
[ 360.16]          > fib(n: uint32): uint32
[ 360.19]           > fib(n: uint32): uint32
[ 360.20]           < return
[ 360.21]           > fib(n: uint32): uint32
[ 360.22]           < return
[ 360.23]          < return
[ 360.24]          > fib(n: uint32): uint32
[ 360.25]          < return
[ 360.26]         < return
[ 360.27]         > fib(n: uint32): uint32
[ 360.29]          > fib(n: uint32): uint32
[ 360.30]          < return
[ 360.31]          > fib(n: uint32): uint32
[ 360.32]          < return
[ 360.33]         < return
[ 360.34]        < return
[ 360.35]        > fib(n: uint32): uint32
[ 360.37]         > fib(n: uint32): uint32
[ 360.38]          > fib(n: uint32): uint32
[ 360.39]          < return
[ 360.40]          > fib(n: uint32): uint32
[ 360.42]          < return
[ 360.43]         < return
[ 360.43]         > fib(n: uint32): uint32
[ 360.45]         < return
[ 360.46]        < return
[ 360.47]       < return
[ 360.49]      < return
[ 360.50]      > fib(n: uint32): uint32
[ 360.52]       > fib(n: uint32): uint32
[ 360.55]        > fib(n: uint32): uint32
[ 360.56]         > fib(n: uint32): uint32
[ 360.58]          > fib(n: uint32): uint32
[ 360.59]           > fib(n: uint32): uint32
[ 360.61]           < return
[ 360.62]           > fib(n: uint32): uint32
[ 360.63]           < return
[ 360.64]          < return
[ 360.65]          > fib(n: uint32): uint32
[ 360.66]          < return
[ 360.67]         < return
[ 360.68]         > fib(n: uint32): uint32
[ 360.69]          > fib(n: uint32): uint32
[ 360.71]          < return
[ 360.72]          > fib(n: uint32): uint32
[ 360.75]          < return
[ 360.76]         < return
[ 360.77]        < return
[ 360.78]        > fib(n: uint32): uint32
[ 360.79]         > fib(n: uint32): uint32
[ 360.82]          > fib(n: uint32): uint32
[ 360.83]          < return
[ 360.85]          > fib(n: uint32): uint32
[ 360.86]          < return
[ 360.87]         < return
[ 360.88]         > fib(n: uint32): uint32
[ 360.90]         < return
[ 360.93]        < return
[ 360.94]       < return
[ 360.95]       > fib(n: uint32): uint32
[ 360.96]        > fib(n: uint32): uint32
[ 361.00]         > fib(n: uint32): uint32
[ 361.02]          > fib(n: uint32): uint32
[ 361.03]          < return
[ 361.04]          > fib(n: uint32): uint32
[ 361.07]          < return
[ 361.08]         < return
[ 361.09]         > fib(n: uint32): uint32
[ 361.10]         < return
[ 361.11]        < return
[ 361.12]        > fib(n: uint32): uint32
[ 361.13]         > fib(n: uint32): uint32
[ 361.15]         < return
[ 361.16]         > fib(n: uint32): uint32
[ 361.19]         < return
[ 361.20]        < return
[ 361.20]       < return
[ 361.23]      < return
[ 361.25]     < return
[ 361.26]    < return
[ 361.27]   < return
[ 361.28]   > fib(n: uint32): uint32
[ 361.29]    > fib(n: uint32): uint32
[ 361.31]     > fib(n: uint32): uint32
[ 361.32]      > fib(n: uint32): uint32
[ 361.34]       > fib(n: uint32): uint32
[ 361.35]        > fib(n: uint32): uint32
[ 361.37]         > fib(n: uint32): uint32
[ 361.38]          > fib(n: uint32): uint32
[ 361.40]           > fib(n: uint32): uint32
[ 361.41]            > fib(n: uint32): uint32
[ 361.43]             > fib(n: uint32): uint32
[ 361.44]             < return
[ 361.45]             > fib(n: uint32): uint32
[ 361.46]             < return
[ 361.47]            < return
[ 361.48]            > fib(n: uint32): uint32
[ 361.50]            < return
[ 361.50]           < return
[ 361.53]           > fib(n: uint32): uint32
[ 361.56]            > fib(n: uint32): uint32
[ 361.57]            < return
[ 361.58]            > fib(n: uint32): uint32
[ 361.60]            < return
[ 361.61]           < return
[ 361.62]          < return
[ 361.64]          > fib(n: uint32): uint32
[ 361.65]           > fib(n: uint32): uint32
[ 361.67]            > fib(n: uint32): uint32
[ 361.68]            < return
[ 361.69]            > fib(n: uint32): uint32
[ 361.70]            < return
[ 361.71]           < return
[ 361.72]           > fib(n: uint32): uint32
[ 361.74]           < return
[ 361.74]          < return
[ 361.75]         < return
[ 361.76]         > fib(n: uint32): uint32
[ 361.77]          > fib(n: uint32): uint32
[ 361.79]           > fib(n: uint32): uint32
[ 361.81]            > fib(n: uint32): uint32
[ 361.82]            < return
[ 361.83]            > fib(n: uint32): uint32
[ 361.84]            < return
[ 361.85]           < return
[ 361.86]           > fib(n: uint32): uint32
[ 361.87]           < return
[ 361.88]          < return
[ 361.89]          > fib(n: uint32): uint32
[ 361.91]           > fib(n: uint32): uint32
[ 361.92]           < return
[ 361.93]           > fib(n: uint32): uint32
[ 361.96]           < return
[ 361.97]          < return
[ 361.98]         < return
[ 361.99]        < return
[ 362.00]        > fib(n: uint32): uint32
[ 362.02]         > fib(n: uint32): uint32
[ 362.04]          > fib(n: uint32): uint32
[ 362.06]           > fib(n: uint32): uint32
[ 362.07]            > fib(n: uint32): uint32
[ 362.09]            < return
[ 362.10]            > fib(n: uint32): uint32
[ 362.11]            < return
[ 362.12]           < return
[ 362.13]           > fib(n: uint32): uint32
[ 362.14]           < return
[ 362.15]          < return
[ 362.16]          > fib(n: uint32): uint32
[ 362.18]           > fib(n: uint32): uint32
[ 362.21]           < return
[ 362.22]           > fib(n: uint32): uint32
[ 362.23]           < return
[ 362.24]          < return
[ 362.25]         < return
[ 362.26]         > fib(n: uint32): uint32
[ 362.27]          > fib(n: uint32): uint32
[ 362.29]           > fib(n: uint32): uint32
[ 362.32]           < return
[ 362.33]           > fib(n: uint32): uint32
[ 362.34]           < return
[ 362.35]          < return
[ 362.36]          > fib(n: uint32): uint32
[ 362.37]          < return
[ 362.38]         < return
[ 362.40]        < return
[ 362.41]       < return
[ 362.42]       > fib(n: uint32): uint32
[ 362.43]        > fib(n: uint32): uint32
[ 362.45]         > fib(n: uint32): uint32
[ 362.46]          > fib(n: uint32): uint32
[ 362.48]           > fib(n: uint32): uint32
[ 362.50]            > fib(n: uint32): uint32
[ 362.51]            < return
[ 362.52]            > fib(n: uint32): uint32
[ 362.53]            < return
[ 362.54]           < return
[ 362.55]           > fib(n: uint32): uint32
[ 362.58]           < return
[ 362.59]          < return
[ 362.60]          > fib(n: uint32): uint32
[ 362.62]           > fib(n: uint32): uint32
[ 362.64]           < return
[ 362.65]           > fib(n: uint32): uint32
[ 362.67]           < return
[ 362.67]          < return
[ 362.68]         < return
[ 362.69]         > fib(n: uint32): uint32
[ 362.71]          > fib(n: uint32): uint32
[ 362.72]           > fib(n: uint32): uint32
[ 362.74]           < return
[ 362.75]           > fib(n: uint32): uint32
[ 362.76]           < return
[ 362.77]          < return
[ 362.78]          > fib(n: uint32): uint32
[ 362.79]          < return
[ 362.80]         < return
[ 362.81]        < return
[ 362.81]        > fib(n: uint32): uint32
[ 362.83]         > fib(n: uint32): uint32
[ 362.85]          > fib(n: uint32): uint32
[ 362.86]           > fib(n: uint32): uint32
[ 362.87]           < return
[ 362.88]           > fib(n: uint32): uint32
[ 362.92]           < return
[ 362.93]          < return
[ 362.93]          > fib(n: uint32): uint32
[ 362.96]          < return
[ 362.97]         < return
[ 362.98]         > fib(n: uint32): uint32
[ 363.00]          > fib(n: uint32): uint32
[ 363.01]          < return
[ 363.02]          > fib(n: uint32): uint32
[ 363.03]          < return
[ 363.04]         < return
[ 363.05]        < return
[ 363.06]       < return
[ 363.06]      < return
[ 363.07]      > fib(n: uint32): uint32
[ 363.09]       > fib(n: uint32): uint32
[ 363.10]        > fib(n: uint32): uint32
[ 363.12]         > fib(n: uint32): uint32
[ 363.13]          > fib(n: uint32): uint32
[ 363.15]           > fib(n: uint32): uint32
[ 363.16]            > fib(n: uint32): uint32
[ 363.18]            < return
[ 363.19]            > fib(n: uint32): uint32
[ 363.20]            < return
[ 363.21]           < return
[ 363.22]           > fib(n: uint32): uint32
[ 363.23]           < return
[ 363.24]          < return
[ 363.25]          > fib(n: uint32): uint32
[ 363.26]           > fib(n: uint32): uint32
[ 363.28]           < return
[ 363.29]           > fib(n: uint32): uint32
[ 363.32]           < return
[ 363.33]          < return
[ 363.35]         < return
[ 363.37]         > fib(n: uint32): uint32
[ 363.40]          > fib(n: uint32): uint32
[ 363.42]           > fib(n: uint32): uint32
[ 363.43]           < return
[ 363.44]           > fib(n: uint32): uint32
[ 363.45]           < return
[ 363.46]          < return
[ 363.47]          > fib(n: uint32): uint32
[ 363.49]          < return
[ 363.49]         < return
[ 363.50]        < return
[ 363.51]        > fib(n: uint32): uint32
[ 363.53]         > fib(n: uint32): uint32
[ 363.54]          > fib(n: uint32): uint32
[ 363.56]           > fib(n: uint32): uint32
[ 363.59]           < return
[ 363.62]           > fib(n: uint32): uint32
[ 363.63]           < return
[ 363.64]          < return
[ 363.65]          > fib(n: uint32): uint32
[ 363.66]          < return
[ 363.67]         < return
[ 363.68]         > fib(n: uint32): uint32
[ 363.70]          > fib(n: uint32): uint32
[ 363.71]          < return
[ 363.72]          > fib(n: uint32): uint32
[ 363.73]          < return
[ 363.74]         < return
[ 363.75]        < return
[ 363.76]       < return
[ 363.77]       > fib(n: uint32): uint32
[ 363.78]        > fib(n: uint32): uint32
[ 363.80]         > fib(n: uint32): uint32
[ 363.83]          > fib(n: uint32): uint32
[ 363.84]           > fib(n: uint32): uint32
[ 363.86]           < return
[ 363.87]           > fib(n: uint32): uint32
[ 363.88]           < return
[ 363.89]          < return
[ 363.90]          > fib(n: uint32): uint32
[ 363.91]          < return
[ 363.92]         < return
[ 363.93]         > fib(n: uint32): uint32
[ 363.94]          > fib(n: uint32): uint32
[ 363.98]          < return
[ 363.99]          > fib(n: uint32): uint32
[ 364.00]          < return
[ 364.02]         < return
[ 364.03]        < return
[ 364.04]        > fib(n: uint32): uint32
[ 364.06]         > fib(n: uint32): uint32
[ 364.07]          > fib(n: uint32): uint32
[ 364.08]          < return
[ 364.09]          > fib(n: uint32): uint32
[ 364.11]          < return
[ 364.12]         < return
[ 364.12]         > fib(n: uint32): uint32
[ 364.14]         < return
[ 364.15]        < return
[ 364.15]       < return
[ 364.16]      < return
[ 364.17]     < return
[ 364.18]     > fib(n: uint32): uint32
[ 364.19]      > fib(n: uint32): uint32
[ 364.21]       > fib(n: uint32): uint32
[ 364.23]        > fib(n: uint32): uint32
[ 364.24]         > fib(n: uint32): uint32
[ 364.25]          > fib(n: uint32): uint32
[ 364.27]           > fib(n: uint32): uint32
[ 364.32]            > fib(n: uint32): uint32
[ 364.33]            < return
[ 364.34]            > fib(n: uint32): uint32
[ 364.36]            < return
[ 364.37]           < return
[ 364.37]           > fib(n: uint32): uint32
[ 364.39]           < return
[ 364.41]          < return
[ 364.42]          > fib(n: uint32): uint32
[ 364.43]           > fib(n: uint32): uint32
[ 364.45]           < return
[ 364.46]           > fib(n: uint32): uint32
[ 364.47]           < return
[ 364.48]          < return
[ 364.49]         < return
[ 364.50]         > fib(n: uint32): uint32
[ 364.51]          > fib(n: uint32): uint32
[ 364.53]           > fib(n: uint32): uint32
[ 364.54]           < return
[ 364.55]           > fib(n: uint32): uint32
[ 364.56]           < return
[ 364.57]          < return
[ 364.58]          > fib(n: uint32): uint32
[ 364.59]          < return
[ 364.60]         < return
[ 364.61]        < return
[ 364.62]        > fib(n: uint32): uint32
[ 364.64]         > fib(n: uint32): uint32
[ 364.65]          > fib(n: uint32): uint32
[ 364.67]           > fib(n: uint32): uint32
[ 364.68]           < return
[ 364.69]           > fib(n: uint32): uint32
[ 364.72]           < return
[ 364.73]          < return
[ 364.74]          > fib(n: uint32): uint32
[ 364.75]          < return
[ 364.77]         < return
[ 364.78]         > fib(n: uint32): uint32
[ 364.80]          > fib(n: uint32): uint32
[ 364.81]          < return
[ 364.82]          > fib(n: uint32): uint32
[ 364.83]          < return
[ 364.84]         < return
[ 364.85]        < return
[ 364.86]       < return
[ 364.87]       > fib(n: uint32): uint32
[ 364.88]        > fib(n: uint32): uint32
[ 364.90]         > fib(n: uint32): uint32
[ 364.92]          > fib(n: uint32): uint32
[ 364.93]           > fib(n: uint32): uint32
[ 364.97]           < return
[ 364.99]           > fib(n: uint32): uint32
[ 365.02]           < return
[ 365.04]          < return
[ 365.05]          > fib(n: uint32): uint32
[ 365.06]          < return
[ 365.07]         < return
[ 365.09]         > fib(n: uint32): uint32
[ 365.11]          > fib(n: uint32): uint32
[ 365.13]          < return
[ 365.14]          > fib(n: uint32): uint32
[ 365.15]          < return
[ 365.16]         < return
[ 365.17]        < return
[ 365.18]        > fib(n: uint32): uint32
[ 365.19]         > fib(n: uint32): uint32
[ 365.21]          > fib(n: uint32): uint32
[ 365.22]          < return
[ 365.23]          > fib(n: uint32): uint32
[ 365.26]          < return
[ 365.27]         < return
[ 365.28]         > fib(n: uint32): uint32
[ 365.29]         < return
[ 365.30]        < return
[ 365.31]       < return
[ 365.31]      < return
[ 365.32]      > fib(n: uint32): uint32
[ 365.34]       > fib(n: uint32): uint32
[ 365.36]        > fib(n: uint32): uint32
[ 365.37]         > fib(n: uint32): uint32
[ 365.40]          > fib(n: uint32): uint32
[ 365.43]           > fib(n: uint32): uint32
[ 365.45]           < return
[ 365.46]           > fib(n: uint32): uint32
[ 365.47]           < return
[ 365.48]          < return
[ 365.49]          > fib(n: uint32): uint32
[ 365.52]          < return
[ 365.52]         < return
[ 365.53]         > fib(n: uint32): uint32
[ 365.55]          > fib(n: uint32): uint32
[ 365.56]          < return
[ 365.57]          > fib(n: uint32): uint32
[ 365.58]          < return
[ 365.59]         < return
[ 365.60]        < return
[ 365.61]        > fib(n: uint32): uint32
[ 365.62]         > fib(n: uint32): uint32
[ 365.64]          > fib(n: uint32): uint32
[ 365.65]          < return
[ 365.66]          > fib(n: uint32): uint32
[ 365.68]          < return
[ 365.69]         < return
[ 365.69]         > fib(n: uint32): uint32
[ 365.71]         < return
[ 365.72]        < return
[ 365.73]       < return
[ 365.75]       > fib(n: uint32): uint32
[ 365.77]        > fib(n: uint32): uint32
[ 365.80]         > fib(n: uint32): uint32
[ 365.81]          > fib(n: uint32): uint32
[ 365.83]          < return
[ 365.83]          > fib(n: uint32): uint32
[ 365.85]          < return
[ 365.86]         < return
[ 365.87]         > fib(n: uint32): uint32
[ 365.88]         < return
[ 365.89]        < return
[ 365.90]        > fib(n: uint32): uint32
[ 365.91]         > fib(n: uint32): uint32
[ 365.93]         < return
[ 365.94]         > fib(n: uint32): uint32
[ 365.95]         < return
[ 365.96]        < return
[ 365.96]       < return
[ 365.97]      < return
[ 365.98]     < return
[ 365.99]    < return
[ 366.00]    > fib(n: uint32): uint32
[ 366.01]     > fib(n: uint32): uint32
[ 366.03]      > fib(n: uint32): uint32
[ 366.05]       > fib(n: uint32): uint32
[ 366.06]        > fib(n: uint32): uint32
[ 366.07]         > fib(n: uint32): uint32
[ 366.09]          > fib(n: uint32): uint32
[ 366.11]           > fib(n: uint32): uint32
[ 366.12]            > fib(n: uint32): uint32
[ 366.13]            < return
[ 366.16]            > fib(n: uint32): uint32
[ 366.18]            < return
[ 366.19]           < return
[ 366.21]           > fib(n: uint32): uint32
[ 366.22]           < return
[ 366.23]          < return
[ 366.24]          > fib(n: uint32): uint32
[ 366.25]           > fib(n: uint32): uint32
[ 366.27]           < return
[ 366.28]           > fib(n: uint32): uint32
[ 366.29]           < return
[ 366.30]          < return
[ 366.31]         < return
[ 366.32]         > fib(n: uint32): uint32
[ 366.33]          > fib(n: uint32): uint32
[ 366.35]           > fib(n: uint32): uint32
[ 366.36]           < return
[ 366.37]           > fib(n: uint32): uint32
[ 366.38]           < return
[ 366.41]          < return
[ 366.42]          > fib(n: uint32): uint32
[ 366.44]          < return
[ 366.44]         < return
[ 366.45]        < return
[ 366.46]        > fib(n: uint32): uint32
[ 366.48]         > fib(n: uint32): uint32
[ 366.49]          > fib(n: uint32): uint32
[ 366.52]           > fib(n: uint32): uint32
[ 366.54]           < return
[ 366.55]           > fib(n: uint32): uint32
[ 366.56]           < return
[ 366.57]          < return
[ 366.59]          > fib(n: uint32): uint32
[ 366.61]          < return
[ 366.61]         < return
[ 366.62]         > fib(n: uint32): uint32
[ 366.64]          > fib(n: uint32): uint32
[ 366.66]          < return
[ 366.67]          > fib(n: uint32): uint32
[ 366.68]          < return
[ 366.69]         < return
[ 366.70]        < return
[ 366.71]       < return
[ 366.71]       > fib(n: uint32): uint32
[ 366.73]        > fib(n: uint32): uint32
[ 366.75]         > fib(n: uint32): uint32
[ 366.76]          > fib(n: uint32): uint32
[ 366.78]           > fib(n: uint32): uint32
[ 366.81]           < return
[ 366.83]           > fib(n: uint32): uint32
[ 366.84]           < return
[ 366.85]          < return
[ 366.86]          > fib(n: uint32): uint32
[ 366.87]          < return
[ 366.88]         < return
[ 366.89]         > fib(n: uint32): uint32
[ 366.91]          > fib(n: uint32): uint32
[ 366.92]          < return
[ 366.93]          > fib(n: uint32): uint32
[ 366.94]          < return
[ 366.95]         < return
[ 366.96]        < return
[ 366.97]        > fib(n: uint32): uint32
[ 366.99]         > fib(n: uint32): uint32
[ 367.00]          > fib(n: uint32): uint32
[ 367.02]          < return
[ 367.03]          > fib(n: uint32): uint32
[ 367.04]          < return
[ 367.05]         < return
[ 367.06]         > fib(n: uint32): uint32
[ 367.07]         < return
[ 367.08]        < return
[ 367.09]       < return
[ 367.10]      < return
[ 367.11]      > fib(n: uint32): uint32
[ 367.14]       > fib(n: uint32): uint32
[ 367.17]        > fib(n: uint32): uint32
[ 367.18]         > fib(n: uint32): uint32
[ 367.20]          > fib(n: uint32): uint32
[ 367.21]           > fib(n: uint32): uint32
[ 367.23]           < return
[ 367.24]           > fib(n: uint32): uint32
[ 367.25]           < return
[ 367.26]          < return
[ 367.27]          > fib(n: uint32): uint32
[ 367.28]          < return
[ 367.29]         < return
[ 367.30]         > fib(n: uint32): uint32
[ 367.32]          > fib(n: uint32): uint32
[ 367.33]          < return
[ 367.34]          > fib(n: uint32): uint32
[ 367.36]          < return
[ 367.36]         < return
[ 367.37]        < return
[ 367.38]        > fib(n: uint32): uint32
[ 367.40]         > fib(n: uint32): uint32
[ 367.41]          > fib(n: uint32): uint32
[ 367.43]          < return
[ 367.44]          > fib(n: uint32): uint32
[ 367.45]          < return
[ 367.46]         < return
[ 367.47]         > fib(n: uint32): uint32
[ 367.48]         < return
[ 367.49]        < return
[ 367.50]       < return
[ 367.51]       > fib(n: uint32): uint32
[ 367.54]        > fib(n: uint32): uint32
[ 367.57]         > fib(n: uint32): uint32
[ 367.59]          > fib(n: uint32): uint32
[ 367.60]          < return
[ 367.61]          > fib(n: uint32): uint32
[ 367.62]          < return
[ 367.63]         < return
[ 367.64]         > fib(n: uint32): uint32
[ 367.66]         < return
[ 367.67]        < return
[ 367.68]        > fib(n: uint32): uint32
[ 367.69]         > fib(n: uint32): uint32
[ 367.71]         < return
[ 367.72]         > fib(n: uint32): uint32
[ 367.73]         < return
[ 367.74]        < return
[ 367.75]       < return
[ 367.76]      < return
[ 367.76]     < return
[ 367.77]     > fib(n: uint32): uint32
[ 367.80]      > fib(n: uint32): uint32
[ 367.82]       > fib(n: uint32): uint32
[ 367.85]        > fib(n: uint32): uint32
[ 367.86]         > fib(n: uint32): uint32
[ 367.88]          > fib(n: uint32): uint32
[ 367.89]           > fib(n: uint32): uint32
[ 367.92]           < return
[ 367.93]           > fib(n: uint32): uint32
[ 367.94]           < return
[ 367.95]          < return
[ 367.96]          > fib(n: uint32): uint32
[ 367.98]          < return
[ 367.99]         < return
[ 368.01]         > fib(n: uint32): uint32
[ 368.02]          > fib(n: uint32): uint32
[ 368.04]          < return
[ 368.05]          > fib(n: uint32): uint32
[ 368.06]          < return
[ 368.07]         < return
[ 368.08]        < return
[ 368.09]        > fib(n: uint32): uint32
[ 368.10]         > fib(n: uint32): uint32
[ 368.14]          > fib(n: uint32): uint32
[ 368.16]          < return
[ 368.17]          > fib(n: uint32): uint32
[ 368.19]          < return
[ 368.20]         < return
[ 368.20]         > fib(n: uint32): uint32
[ 368.22]         < return
[ 368.23]        < return
[ 368.25]       < return
[ 368.26]       > fib(n: uint32): uint32
[ 368.28]        > fib(n: uint32): uint32
[ 368.29]         > fib(n: uint32): uint32
[ 368.31]          > fib(n: uint32): uint32
[ 368.32]          < return
[ 368.33]          > fib(n: uint32): uint32
[ 368.34]          < return
[ 368.35]         < return
[ 368.36]         > fib(n: uint32): uint32
[ 368.37]         < return
[ 368.38]        < return
[ 368.39]        > fib(n: uint32): uint32
[ 368.41]         > fib(n: uint32): uint32
[ 368.43]         < return
[ 368.44]         > fib(n: uint32): uint32
[ 368.46]         < return
[ 368.47]        < return
[ 368.49]       < return
[ 368.51]      < return
[ 368.52]      > fib(n: uint32): uint32
[ 368.54]       > fib(n: uint32): uint32
[ 368.57]        > fib(n: uint32): uint32
[ 368.58]         > fib(n: uint32): uint32
[ 368.60]          > fib(n: uint32): uint32
[ 368.61]          < return
[ 368.62]          > fib(n: uint32): uint32
[ 368.63]          < return
[ 368.64]         < return
[ 368.65]         > fib(n: uint32): uint32
[ 368.67]         < return
[ 368.68]        < return
[ 368.69]        > fib(n: uint32): uint32
[ 368.70]         > fib(n: uint32): uint32
[ 368.71]         < return
[ 368.72]         > fib(n: uint32): uint32
[ 368.74]         < return
[ 368.75]        < return
[ 368.75]       < return
[ 368.76]       > fib(n: uint32): uint32
[ 368.78]        > fib(n: uint32): uint32
[ 368.79]         > fib(n: uint32): uint32
[ 368.81]         < return
[ 368.82]         > fib(n: uint32): uint32
[ 368.83]         < return
[ 368.84]        < return
[ 368.85]        > fib(n: uint32): uint32
[ 368.86]        < return
[ 368.87]       < return
[ 368.88]      < return
[ 368.90]     < return
[ 368.91]    < return
[ 368.92]   < return
[ 368.93]  < return
[ 369.02]  > typename.name(type: typename): .cstr
[ 369.06]  < return
[ 369.08]  > typename.file(type: typename): .cstr
[ 369.10]  < return
[ 369.11]  > typename.line(type: typename): int32
[ 369.12]  < return
[ 369.13]  > typename.base(type: typename): typename
[ 369.15]  < return
[ 369.16]  > typename.name(type: typename): .cstr
[ 369.18]  < return
[ 369.22]  > typename.file(type: typename): .cstr
[ 369.25]  < return
[ 369.26]  > typename.line(type: typename): int32
[ 369.30]  < return
[ 369.31]  > typename.base(type: typename): typename
[ 369.35]  < return
[ 369.38]  > typename.base(type: typename): typename
[ 369.40]  < return
[ 369.46]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.47]  < return
[ 369.50]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.51]  < return
[ 369.52]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.54]  < return
[ 369.55]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.57]  < return
[ 369.58]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.59]  < return
[ 369.60]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.63]  < return
[ 369.64]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.66]  < return
[ 369.67]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.70]  < return
[ 369.71]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.72]  < return
[ 369.74]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.75]  < return
[ 369.76]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.78]  < return
[ 369.79]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.80]  < return
[ 369.81]  > float64.sin(x: float64): float64
[ 369.85]  < return
[ 369.86]  > float64.cos(x: float64): float64
[ 369.88]  < return
[ 369.89]  > float64.tan(x: float64): float64
[ 369.91]  < return
[ 369.92]  > float64.log(x: float64): float64
[ 369.94]  < return
[ 369.96]  > float64.exp(x: float64): float64
[ 369.98]  < return
[ 369.99]  > float64.pow(x: float64, y: float64): float64
[ 370.02]  < return
[ 370.04]  > float64.sqrt(x: float64): float64
[ 370.05]  < return
[ 370.06]  > float64.atan2(x: float64, y: float64): float64
[ 370.08]  < return
[ 370.09]  > float32.sin(x: float32): float32
[ 370.11]  < return
[ 370.12]  > float32.cos(x: float32): float32
[ 370.13]  < return
[ 370.15]  > float32.tan(x: float32): float32
[ 370.16]  < return
[ 370.18]  > float32.log(x: float32): float32
[ 370.19]  < return
[ 370.20]  > float32.exp(x: float32): float32
[ 370.21]  < return
[ 370.23]  > float32.pow(x: float32, y: float32): float32
[ 370.24]  < return
[ 370.25]  > float32.sqrt(x: float32): float32
[ 370.27]  < return
[ 370.28]  > float32.atan2(x: float32, y: float32): float32
[ 370.30]  < return
[ 370.31]  > uint32.pop(value: int32): int32
[ 370.32]  < return
[ 370.33]  > uint32.swap(value: int32): int32
[ 370.35]  < return
[ 370.36]  > uint32.bsr(value: int32): int32
[ 370.40]  < return
[ 370.41]  > uint32.bsf(value: int32): int32
[ 370.43]  < return
[ 370.44]  > uint32.hib(value: int32): int32
[ 370.45]  < return
[ 370.46]  > uint32.lob(value: int32): int32
[ 370.47]  < return
[ 370.49]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 370.50]  < return
[ 370.51]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 370.53]  < return
[ 370.54]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 370.56]  < return
[ 370.57]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 370.58]  < return
[ 370.60]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 370.62]  < return
[ 370.64]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 370.66]  < return
[ 370.69]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 370.71]  < return
[ 370.73]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 370.74]  < return
[ 370.76]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.77]   > noError(ptr: pointer): void
[ 370.79]   < return
[ 370.80]   > halt(): void
[ 370.81]   < return
[ 370.81]  < return
[ 370.82]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.84]  < return
[ 370.85]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.87]   > stackOverflow(ptr: pointer): void
[ 370.88]    > stackOverflow(ptr: pointer): void
[ 370.89]     > stackOverflow(ptr: pointer): void
[ 370.91]      > stackOverflow(ptr: pointer): void
[ 370.92]       > stackOverflow(ptr: pointer): void
[ 370.94]        > stackOverflow(ptr: pointer): void
[ 370.95]         > stackOverflow(ptr: pointer): void
[ 370.97]          > stackOverflow(ptr: pointer): void
[ 370.98]           > stackOverflow(ptr: pointer): void
[ 371.00]            > stackOverflow(ptr: pointer): void
[ 371.01]             > stackOverflow(ptr: pointer): void
[ 371.02]              > stackOverflow(ptr: pointer): void
[ 371.04]               > stackOverflow(ptr: pointer): void
[ 371.05]                > stackOverflow(ptr: pointer): void
[ 371.07]                 > stackOverflow(ptr: pointer): void
[ 371.08]                  > stackOverflow(ptr: pointer): void
[ 371.10]                   > stackOverflow(ptr: pointer): void
[ 371.11]                    > stackOverflow(ptr: pointer): void
[ 371.12]                     > stackOverflow(ptr: pointer): void
[ 371.14]                      > stackOverflow(ptr: pointer): void
[ 371.15]                       > stackOverflow(ptr: pointer): void
[ 371.17]                        > stackOverflow(ptr: pointer): void
[ 371.18]                         > stackOverflow(ptr: pointer): void
[ 371.20]                          > stackOverflow(ptr: pointer): void
[ 371.21]                           > stackOverflow(ptr: pointer): void
[ 371.23]                            > stackOverflow(ptr: pointer): void
[ 371.24]                             > stackOverflow(ptr: pointer): void
[ 371.25]                              > stackOverflow(ptr: pointer): void
[ 371.27]                               > stackOverflow(ptr: pointer): void
[ 371.28]                                > stackOverflow(ptr: pointer): void
[ 371.30]                                 > stackOverflow(ptr: pointer): void
[ 371.31]                                  > stackOverflow(ptr: pointer): void
[ 371.33]                                   > stackOverflow(ptr: pointer): void
[ 371.34]                                    > stackOverflow(ptr: pointer): void
[ 371.36]                                     > stackOverflow(ptr: pointer): void
[ 371.37]                                      > stackOverflow(ptr: pointer): void
[ 371.39]                                       > stackOverflow(ptr: pointer): void
[ 371.40]                                        > stackOverflow(ptr: pointer): void
[ 371.42]                                         > stackOverflow(ptr: pointer): void
[ 371.43]                                          > stackOverflow(ptr: pointer): void
[ 371.44]                                           > stackOverflow(ptr: pointer): void
[ 371.46]                                            > stackOverflow(ptr: pointer): void
[ 371.47]                                             > stackOverflow(ptr: pointer): void
[ 371.49]                                              > stackOverflow(ptr: pointer): void
[ 371.50]                                               > stackOverflow(ptr: pointer): void
[ 371.52]                                                > stackOverflow(ptr: pointer): void
[ 371.53]                                                 > stackOverflow(ptr: pointer): void
[ 371.55]                                                  > stackOverflow(ptr: pointer): void
[ 371.56]                                                   > stackOverflow(ptr: pointer): void
[ 371.58]                                                    > stackOverflow(ptr: pointer): void
[ 371.59]                                                     > stackOverflow(ptr: pointer): void
[ 371.61]                                                      > stackOverflow(ptr: pointer): void
[ 371.62]                                                       > stackOverflow(ptr: pointer): void
[ 371.63]                                                        > stackOverflow(ptr: pointer): void
[ 371.65]                                                         > stackOverflow(ptr: pointer): void
[ 371.66]                                                          > stackOverflow(ptr: pointer): void
[ 371.68]                                                           > stackOverflow(ptr: pointer): void
[ 371.69]                                                            > stackOverflow(ptr: pointer): void
[ 371.71]                                                             > stackOverflow(ptr: pointer): void
[ 371.72]                                                              > stackOverflow(ptr: pointer): void
[ 371.74]                                                               > stackOverflow(ptr: pointer): void
[ 371.75]                                                                > stackOverflow(ptr: pointer): void
[ 371.76]                                                                 > stackOverflow(ptr: pointer): void
[ 371.78]                                                                  > stackOverflow(ptr: pointer): void
[ 371.79]                                                                  < return
[ 371.80]                                                                 < return
[ 371.81]                                                                < return
[ 371.81]                                                               < return
[ 371.82]                                                              < return
[ 371.83]                                                             < return
[ 371.84]                                                            < return
[ 371.85]                                                           < return
[ 371.85]                                                          < return
[ 371.86]                                                         < return
[ 371.87]                                                        < return
[ 371.87]                                                       < return
[ 371.88]                                                      < return
[ 371.89]                                                     < return
[ 371.90]                                                    < return
[ 371.91]                                                   < return
[ 371.91]                                                  < return
[ 371.92]                                                 < return
[ 371.93]                                                < return
[ 371.94]                                               < return
[ 371.94]                                              < return
[ 371.95]                                             < return
[ 371.96]                                            < return
[ 371.96]                                           < return
[ 371.99]                                          < return
[ 372.01]                                         < return
[ 372.02]                                        < return
[ 372.03]                                       < return
[ 372.03]                                      < return
[ 372.04]                                     < return
[ 372.05]                                    < return
[ 372.06]                                   < return
[ 372.06]                                  < return
[ 372.08]                                 < return
[ 372.09]                                < return
[ 372.10]                               < return
[ 372.11]                              < return
[ 372.11]                             < return
[ 372.12]                            < return
[ 372.13]                           < return
[ 372.15]                          < return
[ 372.16]                         < return
[ 372.16]                        < return
[ 372.17]                       < return
[ 372.18]                      < return
[ 372.19]                     < return
[ 372.19]                    < return
[ 372.20]                   < return
[ 372.21]                  < return
[ 372.21]                 < return
[ 372.22]                < return
[ 372.23]               < return
[ 372.24]              < return
[ 372.24]             < return
[ 372.25]            < return
[ 372.26]           < return
[ 372.26]          < return
[ 372.27]         < return
[ 372.28]        < return
[ 372.29]       < return
[ 372.29]      < return
[ 372.30]     < return
[ 372.31]    < return
[ 372.32]   < return
[ 372.32]  < return
[ 372.33]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 372.35]   > divisionByZero(args: pointer): void
[ 372.36]   < return
[ 372.37]  < return
[ 372.38]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 372.39]   > invalidInstruction(args: pointer): void
[ 372.41]   < return
[ 372.42]  < return
[ 372.43]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 372.44]   > invalidMemoryAccess(args: pointer): void
[ 372.45]   < return
[ 372.46]  < return
[ 372.47]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 372.48]   > abortExecution(args: pointer): void
[ 372.51]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 372.61]    < return
[ 372.62]   < return
[ 372.63]  < return
[ 374.30]  > Math.floor(x: float64): float64
[ 374.31]   > Math.modf(x: float64, intPart: float64): float64
[ 374.32]   < return
[ 374.33]  < return
[ 374.35]  > Math.floor(x: float64): float64
[ 374.36]   > Math.modf(x: float64, intPart: float64): float64
[ 374.37]   < return
[ 374.37]  < return
[ 374.39]  > Math.floor(x: float64): float64
[ 374.39]   > Math.modf(x: float64, intPart: float64): float64
[ 374.42]   < return
[ 374.43]  < return
[ 374.44]  > Math.floor(x: float64): float64
[ 374.46]   > Math.modf(x: float64, intPart: float64): float64
[ 374.47]    > Math.modf(x: float64, intPart: float64): float64
[ 374.48]    < return
[ 374.49]   < return
[ 374.50]  < return
[ 374.51]  > Math.floor(x: float64): float64
[ 374.52]   > Math.modf(x: float64, intPart: float64): float64
[ 374.53]    > Math.modf(x: float64, intPart: float64): float64
[ 374.54]    < return
[ 374.55]   < return
[ 374.56]  < return
[ 374.57]  > Math.floor(x: float64): float64
[ 374.58]   > Math.modf(x: float64, intPart: float64): float64
[ 374.59]    > Math.modf(x: float64, intPart: float64): float64
[ 374.60]    < return
[ 374.61]   < return
[ 374.62]  < return
[ 374.74]  > Math.abs(x: float64): float64
[ 374.75]  < return
[ 374.78]  > Math.abs(x: float64): float64
[ 374.79]  < return
[ 374.82]  > Math.abs(x: float64): float64
[ 374.83]  < return
[ 374.84]  > Math.abs(x: float32): float32
[ 374.85]  < return
[ 374.87]  > Math.abs(x: float32): float32
[ 374.88]  < return
[ 374.89]  > Math.abs(x: float32): float32
[ 374.92]  < return
[ 374.93]  > Math.min(a: float32, b: float32): float32
[ 374.94]  < return
[ 374.96]  > Math.max(a: float32, b: float32): float32
[ 374.97]  < return
[ 374.99]  > Math.min(a: float64, b: float64): float64
[ 374.99]  < return
[ 375.01]  > Math.max(a: float64, b: float64): float64
[ 375.03]  < return
[ 375.05]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 375.06]  < return
[ 375.09]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 375.10]  < return
[ 375.15]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 375.16]  < return
[ 375.19]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 375.20]  < return
[ 375.23]  > Math.min(data: float64[]): float64
[ 375.24]  < return
[ 375.27]  > Math.min(data: float64[]): float64
[ 375.31]  < return
[ 375.33]  > Math.max(data: float64[]): float64
[ 375.36]  < return
[ 375.40]  > Math.max(data: float64[]): float64
[ 375.45]  < return
[ 375.47]  > Math.sum(data: float64[]): float64
[ 375.48]  < return
[ 375.50]  > Math.sum(data: float64[]): float64
[ 375.52]  < return
[ 375.54]  > Math.sum(data: float64[]): float64
[ 375.56]  < return
[ 375.58]  > Math.sum(data: float64[]): float64
[ 375.64]  < return
[ 375.66]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 375.68]  < return
[ 375.75]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 375.80]  < return
[ 375.83]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 375.87]  < return
[ 375.89]  > Math.sinCos(arg: float64, quad: int32): float64
[ 375.92]  < return
[ 375.94]  > Math.abs(x: float64): float64
[ 375.96]  < return
[ 375.97]  > Math.sinCos(arg: float64, quad: int32): float64
[ 376.04]  < return
[ 376.06]  > Math.tan(arg: float64): float64
[ 376.09]   > Math.modf(x: float64, intPart: float64): float64
[ 376.10]   < return
[ 376.14]  < return
[ 376.18]  > Math.sinh(x: float64): float64
[ 376.22]   > float64.exp(x: float64): float64
[ 376.24]   < return
[ 376.25]   > float64.exp(x: float64): float64
[ 376.26]   < return
[ 376.27]  < return
[ 376.29]  > Math.cosh(x: float64): float64
[ 376.30]   > float64.exp(x: float64): float64
[ 376.31]   < return
[ 376.32]   > float64.exp(x: float64): float64
[ 376.33]   < return
[ 376.35]  < return
[ 376.37]  > Math.asin(x: float64): float64
[ 376.38]   > float64.sqrt(x: float64): float64
[ 376.40]   < return
[ 376.40]   > float64.atan2(x: float64, y: float64): float64
[ 376.42]   < return
[ 376.43]  < return
[ 376.45]  > Math.asin(x: float64): float64
[ 376.46]   > float64.sqrt(x: float64): float64
[ 376.49]   < return
[ 376.50]   > float64.atan2(x: float64, y: float64): float64
[ 376.51]   < return
[ 376.53]  < return
[ 376.55]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 376.56]  < return
[ 376.58]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 376.60]  < return
[ 376.62]  > Math.absMod(val: float64, mod: float64): float64
[ 376.62]  < return
[ 376.64]  > Math.absMod(val: float64, mod: float64): float64
[ 376.65]  < return
[ 376.67]  > Math.absMod(val: float64, mod: float64): float64
[ 376.67]  < return
[ 376.69]  > Math.absMod(val: float64, mod: float64): float64
[ 376.70]  < return
[ 376.72]  > Math.absMod(val: float64, mod: float64): float64
[ 376.73]  < return
[ 376.75]  > Math.absMod(val: float64, mod: float64): float64
[ 376.75]  < return
[ 376.77]  > Math.absMod(val: float64, mod: float64): float64
[ 376.78]  < return
[ 376.80]  > Math.absMod(val: float64, mod: float64): float64
[ 376.82]  < return
[ 376.84]  > Math.absMod(val: float64, mod: float64): float64
[ 376.85]  < return
[ 376.88]  > Math.absMod(val: float64, mod: float64): float64
[ 376.89]  < return
[ 376.91]  > Math.absMod(val: float64, mod: float64): float64
[ 376.91]  < return
[ 376.93]  > Math.absMod(val: float32, mod: float32): float32
[ 376.94]  < return
[ 376.98]  > Math.absMod(val: float32, mod: float32): float32
[ 377.00]  < return
[ 377.02]  > Math.absMod(val: float32, mod: float32): float32
[ 377.03]  < return
[ 377.05]  > Math.absMod(val: float32, mod: float32): float32
[ 377.06]  < return
[ 377.07]  > Math.absMod(val: float32, mod: float32): float32
[ 377.08]  < return
[ 377.10]  > Math.absMod(val: float32, mod: float32): float32
[ 377.11]  < return
[ 377.14]  > Math.absMod(val: float32, mod: float32): float32
[ 377.15]  < return
[ 377.16]  > Math.absMod(val: float32, mod: float32): float32
[ 377.17]  < return
[ 377.19]  > Math.absMod(val: float32, mod: float32): float32
[ 377.20]  < return
[ 377.21]  > Math.absMod(val: float32, mod: float32): float32
[ 377.22]  < return
[ 377.24]  > Math.absMod(val: float32, mod: float32): float32
[ 377.25]  < return
[ 377.26]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 377.30]  < return
[ 377.32]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 377.33]  < return
[ 377.36]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 377.38]  < return
[ 377.39]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 377.40]  < return
[ 377.42]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 377.43]  < return
[ 377.45]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 377.46]  < return
[ 377.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 377.51]  < return
[ 377.52]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 377.58]  < return
[ 377.59]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 377.61]  < return
[ 377.62]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 377.64]  < return
[ 377.68]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 377.72]  < return
[ 377.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 377.76]  < return
[ 377.93]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 377.94]  < return
[ 377.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 378.07]  < return
[ 378.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 378.17]  < return
[ 378.19]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 378.22]  < return
[ 378.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 378.26]  < return
[ 378.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 378.33]  < return
[ 378.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 378.39]  < return
[ 378.43]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.44]  < return
[ 378.45]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.46]  < return
[ 378.48]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.49]  < return
[ 378.50]  > lenSlice(values: int64[]): int32
[ 378.52]  < return
[ 378.53]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.54]  < return
[ 378.56]  > lenSlice(values: int64[]): int32
[ 378.57]  < return
[ 378.58]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.59]  < return
[ 378.61]  > lenSlice(values: int64[]): int32
[ 378.62]  < return
[ 378.64]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.65]  < return
[ 378.66]  > lenSlice(values: int64[]): int32
[ 378.68]  < return
[ 378.69]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.72]  < return
[ 378.75]  > lenSlice(values: int64[]): int32
[ 378.76]  < return
[ 378.78]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 378.79]  < return
[ 378.86]  > nthFixed(idx: int32, values: int64[7]): int64
[ 378.88]  < return
[ 378.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 378.92]  < return
[ 378.94]  > nthFixed(idx: int32, values: int64[7]): int64
[ 378.96]  < return
[ 379.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.02]  < return
[ 379.05]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.09]  < return
[ 379.11]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.14]  < return
[ 379.16]  > nthSlice(idx: int32, values: int64[]): int64
[ 379.18]  < return
[ 379.20]  > nthSlice(idx: int32, values: int64[]): int64
[ 379.22]  < return
[ 379.31]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.33]  < return
[ 379.35]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.37]  < return
[ 379.40]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.42]  < return
[ 379.46]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.47]  < return
[ 379.50]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.51]  < return
[ 379.53]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.55]  < return
[ 379.57]  > nthSlice(idx: int32, values: int64[]): int64
[ 379.59]  < return
[ 379.61]  > nthSlice(idx: int32, values: int64[]): int64
[ 379.62]  < return
[ 379.72]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.74]  < return
[ 379.77]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.79]  < return
[ 379.81]  > nthFixed(idx: int32, values: int64[7]): int64
[ 379.83]  < return
[ 379.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.87]  < return
[ 379.89]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.90]  < return
[ 379.93]  > nthArray(idx: int32, values: int64[*]): int64
[ 379.94]  < return
[ 379.96]  > nthSlice(idx: int32, values: int64[]): int64
[ 379.98]  < return
[ 380.00]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.02]  < return
[ 380.09]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.13]  < return
[ 380.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.18]  < return
[ 380.20]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.22]  < return
[ 380.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.26]  < return
[ 380.28]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.30]  < return
[ 380.32]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.33]  < return
[ 380.36]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.39]  < return
[ 380.41]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.46]  < return
[ 380.59]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.60]  < return
[ 380.66]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.67]  < return
[ 380.70]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.71]  < return
[ 380.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.75]  < return
[ 380.79]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.81]  < return
[ 380.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.85]  < return
[ 380.89]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.92]  < return
[ 380.95]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.97]  < return
[ 381.06]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.08]  < return
[ 381.11]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.13]  < return
[ 381.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.17]  < return
[ 381.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.20]  < return
[ 381.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.24]  < return
[ 381.30]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.31]  < return
[ 381.37]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.38]  < return
[ 381.40]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.42]  < return
[ 381.50]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.52]  < return
[ 381.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.56]  < return
[ 381.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.60]  < return
[ 381.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.63]  < return
[ 381.66]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.67]  < return
[ 381.69]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.73]  < return
[ 381.78]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.80]  < return
[ 381.82]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.84]  < return
[ 381.88]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 381.90]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 382.01]   < return
[ 382.02]  < return
[ 382.03]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 382.05]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 382.14]   < return
[ 382.17]  < return
[ 382.20]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 382.21]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 382.24]   < return
[ 382.26]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 382.27]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 382.46]    < return
[ 382.47]   < return
[ 382.48]  < return
[ 382.49]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 382.51]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 382.53]   < return
[ 382.54]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 382.55]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 382.73]    < return
[ 382.76]   < return
[ 382.77]  < return
[ 382.78]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 382.80]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 382.89]   < return
[ 382.90]  < return
[ 382.92]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 382.94]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 383.03]   < return
[ 383.04]  < return
[ 383.06]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 383.07]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 383.20]   < return
[ 383.21]  < return
[ 383.23]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 383.25]  < return
[ 383.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 383.30]  < return
[ 383.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 383.34]  < return
[ 383.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 383.41]  < return
[ 383.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 383.51]  < return
[ 383.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 383.58]  < return
[ 383.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 383.65]  < return
[ 383.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 383.69]  < return
[ 383.72]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 383.74]  < return
[ 383.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 383.84]  < return
[ 383.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 383.90]  < return
[ 383.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 383.96]  < return
[ 384.04]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 384.06]  < return
[ 384.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 384.13]  < return
[ 384.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 384.21]  < return
[ 384.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 384.26]  < return
[ 384.30]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 384.32]  < return
[ 384.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 384.39]  < return
[ 384.43]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 384.45]  < return
[ 384.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 384.51]  < return
[ 384.57]  > halt(): void
[ 384.58]  < return
[ 384.58] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:59: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:75: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:64: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:77: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:89: mul: function(<mul>)
lib/vec/mat4f.ci:108: rotation: function(<rotation>)
lib/vec/mat4f.ci:160: translation: function(<translation>)
lib/vec/mat4f.ci:170: scale: function(<scale>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(238200)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(237896)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 366232(357.6 Kb)
memory[heap] @059698; size: 1206374(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 340960(333.0 Kb)
memory[code] @000000; size: 20098(19.6 Kb)
memory[data] @000000; size: 2674(2.6 Kb)

---------- heap memory:
memory[free] @0596a8; size: 1206336(1.2 Mb)

---------- Profile functions: 79/118, coverage: 66.95%
::[.005900, .005900): exec(2), time(0.016 ms): halt(): void
::[.005ba0, .005ba0): exec(0), time(0.000 ms): variant.is(var: variant, type: typename): bool
::[.005e38, .005e38): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006178, .006178): exec(3), time(0.074 ms): typename.base(type: typename): typename
::[.006378, .006378): exec(2), time(0.046 ms): typename.file(type: typename): .cstr
::[.006578, .006578): exec(2), time(0.046 ms): typename.line(type: typename): int32
::[.006778, .006778): exec(2), time(0.056 ms): typename.name(type: typename): .cstr
::[.006f10, .006f10): exec(40), time(2.027 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0077f0, .0077f0): exec(7), time(1.796 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007a90, .007a90): exec(8), time(0.170 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007dc8, .007dc8): exec(2), time(0.052 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.008100, .008100): exec(2), time(0.031 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008430, .008430): exec(1), time(0.016 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0086d8, .0086d8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0088e0, .0088e0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008a48, .008a48): exec(0), time(0.000 ms): System.rand(): int32
::[.008bb0, .008bb0): exec(0), time(0.000 ms): System.time(): int32
::[.008d18, .008d18): exec(0), time(0.000 ms): System.clock(): int32
::[.008e80, .008e80): exec(0), time(0.000 ms): System.millis(): int64
::[.009080, .009080): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0093b8, .0093b8): exec(7), time(0.111 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0096e8, .0096e8): exec(7), time(0.113 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0098e8, .0098e8): exec(1), time(0.015 ms): uint32.pop(value: int32): int32
::[.009ae8, .009ae8): exec(1), time(0.014 ms): uint32.swap(value: int32): int32
::[.009ce8, .009ce8): exec(1), time(0.028 ms): uint32.bsr(value: int32): int32
::[.009ee8, .009ee8): exec(1), time(0.014 ms): uint32.bsf(value: int32): int32
::[.00a0e8, .00a0e8): exec(1), time(0.014 ms): uint32.hib(value: int32): int32
::[.00a2e8, .00a2e8): exec(1), time(0.014 ms): uint32.lob(value: int32): int32
::[.00a610, .00a610): exec(1), time(0.014 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a938, .00a938): exec(1), time(0.014 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00ab38, .00ab38): exec(1), time(0.014 ms): float32.sin(x: float32): float32
::[.00ad38, .00ad38): exec(1), time(0.014 ms): float32.cos(x: float32): float32
::[.00af38, .00af38): exec(1), time(0.014 ms): float32.tan(x: float32): float32
::[.00b138, .00b138): exec(1), time(0.014 ms): float32.log(x: float32): float32
::[.00b338, .00b338): exec(1), time(0.014 ms): float32.exp(x: float32): float32
::[.00b5d0, .00b5d0): exec(1), time(0.014 ms): float32.pow(x: float32, y: float32): float32
::[.00b7d0, .00b7d0): exec(1), time(0.014 ms): float32.sqrt(x: float32): float32
::[.00ba68, .00ba68): exec(1), time(0.018 ms): float32.atan2(x: float32, y: float32): float32
::[.00bc60, .00bc60): exec(1), time(0.030 ms): float64.sin(x: float64): float64
::[.00be58, .00be58): exec(1), time(0.023 ms): float64.cos(x: float64): float64
::[.00c050, .00c050): exec(1), time(0.014 ms): float64.tan(x: float64): float64
::[.00c248, .00c248): exec(1), time(0.017 ms): float64.log(x: float64): float64
::[.00c440, .00c440): exec(5), time(0.074 ms): float64.exp(x: float64): float64
::[.00c6d0, .00c6d0): exec(1), time(0.029 ms): float64.pow(x: float64, y: float64): float64
::[.00c8c8, .00c8c8): exec(3), time(0.055 ms): float64.sqrt(x: float64): float64
::[.00cb58, .00cb58): exec(3), time(0.046 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:75:[.0533e0, .05343e): exec(8), time(0.107 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.053440, .053496): exec(10), time(0.139 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.053498, .0534b0): exec(6), time(0.249-0.127 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.0534b0, .0534c2): exec(3), time(0.029 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.0534c8, .0534da): exec(4), time(0.054 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.0534e0, .0534fb): exec(11), time(0.124 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.053500, .05351b): exec(11), time(0.133 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.053520, .053531): exec(1), time(0.010 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.053538, .053549): exec(1), time(0.009 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.053550, .053561): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.053568, .053579): exec(1), time(0.023 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.053580, .05359e): exec(2), time(0.022 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.0535a0, .0535be): exec(2), time(0.023 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.0535c0, .05360f): exec(2), time(0.062 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.053610, .05365f): exec(2), time(0.076 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.053660, .053688): exec(4), time(0.110 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.053688, .0536b7): exec(3), time(0.105 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.0536b8, .0536f1): exec(1), time(0.013 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.0536f8, .053731): exec(1), time(0.013 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.053738, .053887): exec(2), time(0.101 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.053888, .053a02): exec(1), time(0.083-0.012 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.053a08, .053af9): exec(1), time(0.093-0.032 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.053b00, .053b4b): exec(1), time(0.066-0.025 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.053b50, .053bfd): exec(2), time(0.150-0.067 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.053c00, .053c07): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.053c08, .053c0f): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.053c10, .053c8b): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.053c90, .053caf): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.053cb0, .053d14): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.053d18, .053d3e): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.053d40, .053d72): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.053d78, .053daa): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.053db0, .053df9): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.053e00, .053e7e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.053e80, .053ebf): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.053ec0, .053f07): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.053f08, .053f2c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.053f30, .053f3e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.053f40, .053f94): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.053fa8, .054239): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.054240, .054257): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.054258, .054289): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.0542a0, .0542b9): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.0542c0, .0542c7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.0542c8, .0542d5): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:64:[.0542d8, .054309): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:77:[.054310, .054325): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:89:[.054328, .0544c9): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
lib/vec/mat4f.ci:108:[.0544d0, .0546dc): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
lib/vec/mat4f.ci:160:[.0546e0, .054738): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
lib/vec/mat4f.ci:170:[.054738, .054811): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
test/lang/function.ci:4:[.054ca8, .054ca9): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.054cb0, .054cb8): exec(2), time(0.027 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.054cf0, .054cf8): exec(2), time(0.025 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.054cf8, .054d2e): exec(753), time(20.262 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.055000, .055001): exec(1), time(0.015 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.055008, .055020): exec(64-64), time(1.451 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.055020, .05502c): exec(1-1), time(0.016 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.055030, .055074): exec(1-1), time(0.136-0.106 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.055078, .055085): exec(1-1), time(0.016 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.055088, .05508a): exec(1-1), time(0.014 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.055160, .055164): exec(5), time(0.077 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.055168, .055174): exec(21), time(0.401 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.055178, .055184): exec(21), time(0.425 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.055188, .055194): exec(14), time(0.310 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.0551e8, .05520f): exec(3), time(0.467-0.391 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.055218, .05523f): exec(4), time(0.622-0.491 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.055240, .055267): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.055268, .05528f): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.0552a0, .0552e2): exec(1), time(0.282-0.241 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.0552e8, .055327): exec(1), time(0.275-0.235 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.055d6c, .059698): exec(1), time(36.797-28.335 ms): .main

---------- Profile statements: 875/1192, coverage: 73.41%
lib/stdlib.ci:77:[.0533e9, .0533ea) exec(8), time(0.048-0.048 ms): <assertEq+9>
lib/stdlib.ci:76:[.0533e0, .0533ea) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:80:[.0533ee, .0533f9) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:81:[.0533f9, .053404) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:82:[.053404, .053407) exec(0), time(0.000 ms): <assertEq+36>
::[.053407, .053413) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:79:[.0533ea, .053413) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:84:[.053413, .053439) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.053458, .053469) exec(3), time(0.051-0.051 ms): <modf+24>
lib/std/math.ci:26:[.053469, .053470) exec(3), time(0.001-0.001 ms): <modf+41>
lib/std/math.ci:27:[.053470, .053473) exec(3), time(0.018-0.018 ms): <modf+48>
lib/std/math.ci:24:[.053450, .053477) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.053477, .05347b) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.05347b, .05347f) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.053440, .05347f) exec(10-3), time(0.005-0.005 ms): <modf+0>
lib/std/math.ci:32:[.05347f, .05348b) exec(7), time(0.006-0.006 ms): <modf+63>
lib/std/math.ci:33:[.05348b, .053493) exec(7), time(0.004-0.004 ms): <modf+75>
lib/std/math.ci:34:[.053493, .053496) exec(7), time(0.045-0.045 ms): <modf+83>
lib/std/math.ci:48:[.053498, .053499) exec(6), time(0.018-0.018 ms): <floor+0>
lib/std/math.ci:49:[.053499, .0534ad) exec(6), time(0.167-0.167 ms): <floor+1>
lib/std/math.ci:50:[.0534ad, .0534b0) exec(6), time(0.036-0.036 ms): <floor+21>
lib/std/math.ci:79:[.0534b8, .0534be) exec(1), time(0.020-0.020 ms): <abs+8>
lib/std/math.ci:78:[.0534b0, .0534be) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.0534be, .0534c2) exec(2), time(0.013-0.013 ms): <abs+14>
lib/std/math.ci:87:[.0534d0, .0534d6) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:86:[.0534c8, .0534d6) exec(4-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:89:[.0534d6, .0534da) exec(3), time(0.040-0.040 ms): <abs+14>
lib/std/math.ci:95:[.0534ef, .0534f7) exec(4), time(0.037-0.037 ms): <absMod+15>
lib/std/math.ci:94:[.0534e0, .0534f7) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:97:[.0534f7, .0534fb) exec(7), time(0.048-0.048 ms): <absMod+23>
lib/std/math.ci:103:[.05350f, .053517) exec(4), time(0.025-0.025 ms): <absMod+15>
lib/std/math.ci:102:[.053500, .053517) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:105:[.053517, .05351b) exec(7), time(0.047-0.047 ms): <absMod+23>
lib/std/math.ci:117:[.053529, .05352d) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:116:[.053520, .05352d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.05352d, .053531) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.053541, .053545) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:124:[.053538, .053545) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.053545, .053549) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.053559, .05355d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.053550, .05355d) exec(1), time(0.000 ms): <max+0>
lib/std/math.ci:141:[.05355d, .053561) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:147:[.053571, .053575) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.053568, .053575) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.053575, .053579) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:161:[.053589, .05358d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.053580, .05358d) exec(2), time(0.001-0.001 ms): <clamp+0>
lib/std/math.ci:164:[.053596, .05359a) exec(1), time(0.019-0.019 ms): <clamp+22>
lib/std/math.ci:163:[.05358d, .05359a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.05359a, .05359e) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:172:[.0535a9, .0535ad) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.0535a0, .0535ad) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:175:[.0535b6, .0535ba) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:174:[.0535ad, .0535ba) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:177:[.0535ba, .0535be) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:203:[.0535c8, .0535d4) exec(1), time(0.007-0.007 ms): <min+8>
lib/std/math.ci:202:[.0535c0, .0535d4) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.0535d4, .0535d7) exec(1), time(0.000 ms): <min+20>
lib/std/math.ci:208:[.0535f0, .0535fb) exec(2), time(0.001-0.001 ms): <min+48>
lib/std/math.ci:207:[.0535e0, .0535fb) exec(8-2), time(0.006-0.006 ms): <min+32>
lib/std/math.ci:206:[.0535fb, .0535ff) exec(8), time(0.006-0.006 ms): <min+59>
lib/std/math.ci:206:[.0535ff, .053608) exec(9), time(0.005-0.005 ms): <min+63>
lib/std/math.ci:206:[.0535d7, .05360c) exec(1), time(0.001-0.001 ms): <min+23>
lib/std/math.ci:211:[.05360c, .05360f) exec(1), time(0.006-0.006 ms): <min+76>
lib/std/math.ci:217:[.053618, .053624) exec(1), time(0.007-0.007 ms): <max+8>
lib/std/math.ci:216:[.053610, .053624) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.053624, .053627) exec(1), time(0.001-0.001 ms): <max+20>
lib/std/math.ci:222:[.053640, .05364b) exec(2), time(0.002-0.002 ms): <max+48>
lib/std/math.ci:221:[.053630, .05364b) exec(8-2), time(0.006-0.006 ms): <max+32>
lib/std/math.ci:220:[.05364b, .05364f) exec(8), time(0.000 ms): <max+59>
lib/std/math.ci:220:[.05364f, .053658) exec(9), time(0.009-0.009 ms): <max+63>
lib/std/math.ci:220:[.053627, .05365c) exec(1), time(0.001-0.001 ms): <max+23>
lib/std/math.ci:225:[.05365c, .05365f) exec(1), time(0.006-0.006 ms): <max+76>
lib/std/math.ci:230:[.053660, .053661) exec(4), time(0.002-0.002 ms): <sum+0>
lib/std/math.ci:232:[.053666, .053674) exec(13), time(0.013-0.013 ms): <sum+6>
lib/std/math.ci:231:[.053674, .053678) exec(13), time(0.008-0.008 ms): <sum+20>
lib/std/math.ci:231:[.053678, .053681) exec(17), time(0.014-0.014 ms): <sum+24>
lib/std/math.ci:231:[.053661, .053685) exec(4), time(0.006-0.006 ms): <sum+1>
lib/std/math.ci:234:[.053685, .053688) exec(4), time(0.024-0.024 ms): <sum+37>
lib/std/math.ci:257:[.053688, .053689) exec(3), time(0.002-0.002 ms): <eval+0>
lib/std/math.ci:259:[.053693, .0536a4) exec(11), time(0.012-0.012 ms): <eval+11>
lib/std/math.ci:258:[.0536a4, .0536a8) exec(11), time(0.006-0.006 ms): <eval+28>
lib/std/math.ci:258:[.0536a8, .0536b0) exec(14), time(0.009-0.009 ms): <eval+32>
lib/std/math.ci:258:[.053689, .0536b4) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:261:[.0536b4, .0536b7) exec(3), time(0.018-0.018 ms): <eval+44>
lib/std/math.ci:268:[.0536cd, .0536d5) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.0536c1, .0536d5) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.0536e5, .0536ed) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.0536d9, .0536ed) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.0536b8, .0536ed) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:276:[.0536ed, .0536f1) exec(1), time(0.007-0.007 ms): <cmp+53>
lib/std/math.ci:283:[.05370d, .053715) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.053701, .053715) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:288:[.053725, .05372d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.053719, .05372d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.0536f8, .05372d) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:291:[.05372d, .053731) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:309:[.053738, .05373a) exec(2), time(0.000 ms): <sinCos+0>
lib/std/math.ci:311:[.053742, .053743) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.053743, .05374b) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.05373a, .05374b) exec(2), time(0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:315:[.05374b, .05374c) exec(2), time(0.001-0.001 ms): <sinCos+19>
lib/std/math.ci:316:[.05374c, .053764) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:318:[.053774, .053775) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.053775, .053787) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.053787, .05378b) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.05378b, .05378c) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.05378c, .0537aa) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.0537aa, .0537bc) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.0537c4, .0537c7) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:328:[.0537c7, .0537cf) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:329:[.0537cf, .0537d6) exec(2), time(0.003-0.003 ms): <sinCos+151>
lib/std/math.ci:330:[.0537d6, .0537dc) exec(2), time(0.001-0.001 ms): <sinCos+158>
lib/std/math.ci:317:[.053764, .0537e0) exec(2), time(0.003-0.003 ms): <sinCos+44>
lib/std/math.ci:333:[.0537e8, .0537f6) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:332:[.0537e0, .0537f6) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:336:[.053802, .053803) exec(1), time(0.000 ms): <sinCos+202>
lib/std/math.ci:335:[.0537f6, .053803) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:339:[.053803, .053808) exec(2), time(0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:340:[.053808, .053848) exec(2), time(0.024-0.024 ms): <sinCos+208>
lib/std/math.ci:341:[.053848, .05387b) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:342:[.05387b, .053887) exec(2), time(0.015-0.015 ms): <sinCos+323>
lib/std/math.ci:365:[.053888, .053889) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.053889, .05388a) exec(1), time(0.000 ms): <tan+1>
lib/std/math.ci:369:[.053892, .053897) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.053897, .0538a1) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.05388a, .0538a1) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:372:[.0538a1, .0538b9) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.0538b9, .0538ba) exec(1), time(0.001-0.001 ms): <tan+49>
lib/std/math.ci:375:[.0538ba, .0538ca) exec(1), time(0.018-0.018 ms): <tan+50>
lib/std/math.ci:376:[.0538ca, .0538d3) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:380:[.0538e7, .0538f5) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:381:[.0538f5, .0538ff) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.05390f, .05391a) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.05391a, .053924) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.053934, .053942) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.053942, .05394d) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.053928, .05394d) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.053903, .05394d) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.0538db, .05394d) exec(1), time(0.002-0.002 ms): <tan+83>
lib/std/math.ci:378:[.0538d3, .05394d) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.05394d, .053952) exec(1), time(0.001-0.001 ms): <tan+197>
lib/std/math.ci:393:[.053952, .053992) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.053992, .0539b9) exec(1), time(0.002-0.002 ms): <tan+266>
lib/std/math.ci:398:[.0539ca, .0539da) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.0539c2, .0539da) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.0539da, .0539e8) exec(1), time(0.014-0.014 ms): <tan+338>
lib/std/math.ci:396:[.0539b9, .0539e8) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.0539f1, .0539fb) exec(0), time(0.000 ms): <tan+361>
lib/std/math.ci:402:[.0539e8, .0539fb) exec(1), time(0.001-0.001 ms): <tan+352>
lib/std/math.ci:405:[.0539fb, .053a02) exec(1), time(0.006-0.006 ms): <tan+371>
lib/std/math.ci:421:[.053a08, .053a09) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:423:[.053a11, .053a16) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.053a16, .053a20) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.053a09, .053a20) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.053a30, .053a47) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.053a20, .053a47) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:431:[.053a47, .053a48) exec(1), time(0.001-0.001 ms): <sinh+63>
lib/std/math.ci:433:[.053a58, .053a72) exec(1), time(0.047-0.047 ms): <sinh+80>
lib/std/math.ci:436:[.053a76, .053a7b) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.053a7b, .053ab0) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.053ab0, .053adb) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.053a48, .053adf) exec(1), time(0.048-0.048 ms): <sinh+64>
lib/std/math.ci:442:[.053ae8, .053af2) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.053adf, .053af2) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:444:[.053af2, .053af9) exec(1), time(0.007-0.007 ms): <sinh+234>
lib/std/math.ci:450:[.053b08, .053b0d) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.053b00, .053b0d) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:453:[.053b1d, .053b30) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.053b0d, .053b30) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:455:[.053b30, .053b4b) exec(1), time(0.060-0.060 ms): <cosh+48>
lib/std/math.ci:466:[.053b58, .053b5c) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.053b50, .053b5c) exec(2), time(0.003-0.003 ms): <asin+0>
lib/std/math.ci:469:[.053b5c, .053b5d) exec(2), time(0.002-0.002 ms): <asin+12>
lib/std/math.ci:471:[.053b65, .053b6f) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.053b6f, .053b74) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.053b5d, .053b74) exec(2), time(0.002-0.002 ms): <asin+13>
lib/std/math.ci:477:[.053b84, .053b94) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.053b74, .053b94) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.053b94, .053ba7) exec(2), time(0.055-0.055 ms): <asin+68>
lib/std/math.ci:482:[.053bb7, .053bd5) exec(0), time(0.000 ms): <asin+103>
lib/std/math.ci:485:[.053bd9, .053be3) exec(2), time(0.055-0.055 ms): <asin+137>
lib/std/math.ci:481:[.053ba7, .053be3) exec(2-2), time(0.000 ms): <asin+87>
lib/std/math.ci:489:[.053bec, .053bf6) exec(0), time(0.000 ms): <asin+156>
lib/std/math.ci:488:[.053be3, .053bf6) exec(2), time(0.002-0.002 ms): <asin+147>
lib/std/math.ci:491:[.053bf6, .053bfd) exec(2), time(0.014-0.014 ms): <asin+166>
::[.053c03, .053c06) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.053c00, .053c07) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.053c0b, .053c0e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.053c08, .053c0f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.053c2f, .053c34) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.053c34, .053c3c) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.053c49, .053c56) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.053c3c, .053c5b) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.053c10, .053c5f) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.053c5f, .053c64) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.053c64, .053c6c) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.053c79, .053c86) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.053c6c, .053c8b) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.053c90, .053c9b) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.053ca2, .053caa) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.053c9b, .053caf) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.053cb0, .053cc7) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.053cc7, .053cd7) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.053cd7, .053ce6) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.053ce6, .053cf9) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.053d04, .053d0f) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.053cf9, .053d14) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.053d24, .053d28) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.053d18, .053d28) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.053d28, .053d29) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.053d2d, .053d31) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.053d31, .053d3b) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.053d29, .053d3b) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.053d3b, .053d3e) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.053d55, .053d58) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.053d45, .053d58) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.053d58, .053d5c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.053d5c, .053d66) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.053d40, .053d6a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.053d6a, .053d72) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.053d78, .053d7d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.053d92, .053d95) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.053d82, .053d95) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.053d95, .053d99) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.053d99, .053da3) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.053d7d, .053da7) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.053da7, .053daa) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.053dcf, .053dda) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.053db5, .053dda) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.053dda, .053dde) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.053dde, .053dea) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.053db0, .053dee) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.053dee, .053df9) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.053e00, .053e0d) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.053e0d, .053e1a) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.053e23, .053e2e) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.053e1a, .053e2e) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.053e53, .053e5e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.053e33, .053e5e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.053e5e, .053e62) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.053e62, .053e6b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.053e2e, .053e6f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.053e6f, .053e7e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.053e80, .053e81) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.053e86, .053e9c) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.053ea8, .053eac) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.053e9c, .053eac) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.053eac, .053eb0) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.053eb0, .053eb8) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.053e81, .053ebc) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.053ebc, .053ebf) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.053ecf, .053eda) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.053ec0, .053eda) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.053ee9, .053ef4) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.053eda, .053ef4) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.053ef4, .053f07) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.053f08, .053f2c) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.053f30, .053f3e) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.053f4e, .053f52) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.053f45, .053f52) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.053f52, .053f5e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.053f5e, .053f66) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.053f66, .053f6a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.053f6a, .053f74) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.053f40, .053f78) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.053f81, .053f89) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.053f78, .053f89) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.053f89, .053f90) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.053f90, .053f94) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.053fa8, .053fa9) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.053fa9, .053fad) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.053fad, .053fb0) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.053fb0, .053fe6) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.053fe6, .05401b) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.05401f, .05403a) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.05403a, .054041) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.054041, .054049) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.05401b, .054049) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.054051, .054066) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.054049, .054066) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.054066, .054070) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.054070, .054077) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.054082, .05408c) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.054077, .05408c) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.054097, .05409f) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.0540bd, .0540f1) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.0540f1, .0540fc) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.0540fc, .054104) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.054104, .05410c) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.05410c, .054114) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.0540b9, .054114) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.05409f, .054114) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.054114, .054148) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.054148, .054153) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.054153, .05415b) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.05408c, .05415b) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.05415f, .054193) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.054193, .05419e) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.05419e, .0541a6) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.0541a6, .0541ae) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.0541ae, .0541b6) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.05415b, .0541b6) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.0541bb, .0541ef) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.0541ef, .054200) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.054200, .054208) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.054208, .05420c) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.05420c, .054215) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.0541b6, .054219) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.054222, .05422a) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.054219, .05422a) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.05422a, .054231) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.054231, .054239) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.054240, .054257) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.054258, .054259) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.054261, .054268) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.054268, .05426d) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.054259, .05426d) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.05426d, .054289) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.0542a0, .0542b9) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.0542c3, .0542c6) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.0542c0, .0542c7) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.0542cb, .0542ce) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.0542ce, .0542d1) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.0542d1, .0542d4) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.0542c8, .0542d5) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:69:[.0542db, .0542de) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:69:[.0542de, .0542e1) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:69:[.0542e1, .0542e4) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:70:[.0542e4, .0542e7) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:70:[.0542e7, .0542ea) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:70:[.0542ea, .0542ed) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:70:[.0542ed, .0542f0) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:71:[.0542f0, .0542f3) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:71:[.0542f3, .0542f6) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:71:[.0542f6, .0542f9) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:71:[.0542f9, .0542fc) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:72:[.0542fc, .0542ff) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:72:[.0542ff, .054302) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:72:[.054302, .054305) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:72:[.054305, .054308) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:68:[.0542d8, .054309) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:78:[.054315, .05431a) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:78:[.05431a, .05431f) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:78:[.05431f, .054324) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:78:[.054310, .054325) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:91:[.05432c, .054331) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:91:[.054331, .05433a) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:91:[.05433a, .054343) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:91:[.054343, .05434c) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:92:[.05434c, .054355) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:92:[.054355, .05435e) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:92:[.05435e, .054367) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:92:[.054367, .054370) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:93:[.054370, .054379) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:93:[.054379, .054382) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:93:[.054382, .05438b) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:93:[.05438b, .054394) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:94:[.054394, .05439d) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:94:[.05439d, .0543a6) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:94:[.0543a6, .0543af) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:94:[.0543af, .0543b8) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:90:[.054328, .0543b8) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:98:[.0543f8, .05443c) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:99:[.05443c, .054480) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:100:[.054480, .0544c4) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:96:[.0543b8, .0544c9) exec(0), time(0.000 ms): <mul+144>
lib/vec/mat4f.ci:109:[.0544d0, .0544e2) exec(0), time(0.000 ms): <rotation+0>
lib/vec/mat4f.ci:111:[.0544f3, .054517) exec(0), time(0.000 ms): <rotation+35>
lib/vec/mat4f.ci:114:[.05452b, .05453f) exec(0), time(0.000 ms): <rotation+91>
lib/vec/mat4f.ci:115:[.05453f, .054553) exec(0), time(0.000 ms): <rotation+111>
lib/vec/mat4f.ci:116:[.054553, .054567) exec(0), time(0.000 ms): <rotation+131>
lib/vec/mat4f.ci:112:[.054517, .05456c) exec(0), time(0.000 ms): <rotation+71>
lib/vec/mat4f.ci:110:[.0544e2, .05456c) exec(0), time(0.000 ms): <rotation+18>
lib/vec/mat4f.ci:119:[.05456c, .054572) exec(0), time(0.000 ms): <rotation+156>
lib/vec/mat4f.ci:120:[.054572, .05457c) exec(0), time(0.000 ms): <rotation+162>
lib/vec/mat4f.ci:121:[.05457c, .054586) exec(0), time(0.000 ms): <rotation+172>
lib/vec/mat4f.ci:122:[.054586, .054589) exec(0), time(0.000 ms): <rotation+182>
lib/vec/mat4f.ci:123:[.054589, .054590) exec(0), time(0.000 ms): <rotation+185>
lib/vec/mat4f.ci:124:[.054590, .054597) exec(0), time(0.000 ms): <rotation+192>
lib/vec/mat4f.ci:125:[.054597, .05459c) exec(0), time(0.000 ms): <rotation+199>
lib/vec/mat4f.ci:126:[.05459c, .0545a1) exec(0), time(0.000 ms): <rotation+204>
lib/vec/mat4f.ci:127:[.0545a1, .0545a6) exec(0), time(0.000 ms): <rotation+209>
lib/vec/mat4f.ci:128:[.0545a6, .0545ab) exec(0), time(0.000 ms): <rotation+214>
lib/vec/mat4f.ci:129:[.0545ab, .0545b0) exec(0), time(0.000 ms): <rotation+219>
lib/vec/mat4f.ci:130:[.0545b0, .0545b5) exec(0), time(0.000 ms): <rotation+224>
lib/vec/mat4f.ci:132:[.0545b5, .0545bb) exec(0), time(0.000 ms): <rotation+229>
lib/vec/mat4f.ci:133:[.0545bb, .0545c1) exec(0), time(0.000 ms): <rotation+235>
lib/vec/mat4f.ci:134:[.0545c1, .0545c9) exec(0), time(0.000 ms): <rotation+241>
lib/vec/mat4f.ci:138:[.0545d6, .0545e3) exec(0), time(0.000 ms): <rotation+262>
lib/vec/mat4f.ci:139:[.0545e3, .0545f0) exec(0), time(0.000 ms): <rotation+275>
lib/vec/mat4f.ci:140:[.0545f0, .05461b) exec(0), time(0.000 ms): <rotation+288>
lib/vec/mat4f.ci:142:[.05461b, .054628) exec(0), time(0.000 ms): <rotation+331>
lib/vec/mat4f.ci:143:[.054628, .054635) exec(0), time(0.000 ms): <rotation+344>
lib/vec/mat4f.ci:144:[.054635, .054642) exec(0), time(0.000 ms): <rotation+357>
lib/vec/mat4f.ci:145:[.054642, .05466d) exec(0), time(0.000 ms): <rotation+370>
lib/vec/mat4f.ci:147:[.05466d, .05467a) exec(0), time(0.000 ms): <rotation+413>
lib/vec/mat4f.ci:148:[.05467a, .054687) exec(0), time(0.000 ms): <rotation+426>
lib/vec/mat4f.ci:149:[.054687, .054694) exec(0), time(0.000 ms): <rotation+439>
lib/vec/mat4f.ci:150:[.054694, .0546bf) exec(0), time(0.000 ms): <rotation+452>
lib/vec/mat4f.ci:152:[.0546bf, .0546d7) exec(0), time(0.000 ms): <rotation+495>
lib/vec/mat4f.ci:136:[.0545c9, .0546dc) exec(0), time(0.000 ms): <rotation+249>
lib/vec/mat4f.ci:162:[.0546e7, .0546ea) exec(0), time(0.000 ms): <translation+7>
lib/vec/mat4f.ci:162:[.0546ea, .0546ed) exec(0), time(0.000 ms): <translation+10>
lib/vec/mat4f.ci:162:[.0546ed, .0546f5) exec(0), time(0.000 ms): <translation+13>
lib/vec/mat4f.ci:163:[.0546f5, .0546f8) exec(0), time(0.000 ms): <translation+21>
lib/vec/mat4f.ci:163:[.0546f8, .0546ff) exec(0), time(0.000 ms): <translation+24>
lib/vec/mat4f.ci:163:[.0546ff, .054702) exec(0), time(0.000 ms): <translation+31>
lib/vec/mat4f.ci:163:[.054702, .05470e) exec(0), time(0.000 ms): <translation+34>
lib/vec/mat4f.ci:164:[.05470e, .054711) exec(0), time(0.000 ms): <translation+46>
lib/vec/mat4f.ci:164:[.054711, .054714) exec(0), time(0.000 ms): <translation+49>
lib/vec/mat4f.ci:164:[.054714, .05471b) exec(0), time(0.000 ms): <translation+52>
lib/vec/mat4f.ci:164:[.05471b, .054727) exec(0), time(0.000 ms): <translation+59>
lib/vec/mat4f.ci:165:[.054727, .05472a) exec(0), time(0.000 ms): <translation+71>
lib/vec/mat4f.ci:165:[.05472a, .05472d) exec(0), time(0.000 ms): <translation+74>
lib/vec/mat4f.ci:165:[.05472d, .054730) exec(0), time(0.000 ms): <translation+77>
lib/vec/mat4f.ci:165:[.054730, .054737) exec(0), time(0.000 ms): <translation+80>
lib/vec/mat4f.ci:161:[.0546e0, .054738) exec(0), time(0.000 ms): <translation+0>
lib/vec/mat4f.ci:173:[.05476f, .054772) exec(0), time(0.000 ms): <scale+55>
lib/vec/mat4f.ci:173:[.054772, .054775) exec(0), time(0.000 ms): <scale+58>
lib/vec/mat4f.ci:173:[.054775, .054778) exec(0), time(0.000 ms): <scale+61>
lib/vec/mat4f.ci:174:[.054778, .05477b) exec(0), time(0.000 ms): <scale+64>
lib/vec/mat4f.ci:174:[.05477b, .0547b6) exec(0), time(0.000 ms): <scale+67>
lib/vec/mat4f.ci:174:[.0547b6, .0547b9) exec(0), time(0.000 ms): <scale+126>
lib/vec/mat4f.ci:174:[.0547b9, .0547bc) exec(0), time(0.000 ms): <scale+129>
lib/vec/mat4f.ci:175:[.0547bc, .0547bf) exec(0), time(0.000 ms): <scale+132>
lib/vec/mat4f.ci:175:[.0547bf, .0547c2) exec(0), time(0.000 ms): <scale+135>
lib/vec/mat4f.ci:175:[.0547c2, .0547fd) exec(0), time(0.000 ms): <scale+138>
lib/vec/mat4f.ci:175:[.0547fd, .054800) exec(0), time(0.000 ms): <scale+197>
lib/vec/mat4f.ci:176:[.054800, .054803) exec(0), time(0.000 ms): <scale+200>
lib/vec/mat4f.ci:176:[.054803, .054806) exec(0), time(0.000 ms): <scale+203>
lib/vec/mat4f.ci:176:[.054806, .054809) exec(0), time(0.000 ms): <scale+206>
lib/vec/mat4f.ci:176:[.054809, .054810) exec(0), time(0.000 ms): <scale+209>
lib/vec/mat4f.ci:172:[.054738, .054811) exec(0), time(0.000 ms): <scale+0>
test/lang/function.ci:8:[.054cb0, .054cb8) exec(2), time(0.019-0.019 ms): <funAdd+0>
test/lang/function.ci:34:[.054cf0, .054cf8) exec(2), time(0.018-0.018 ms): <funMul+0>
test/lang/function.ci:40:[.054d04, .054d08) exec(377), time(3.276-3.276 ms): <fib+12>
test/lang/function.ci:39:[.054cf8, .054d08) exec(753-377), time(0.819-0.819 ms): <fib+0>
test/lang/function.ci:42:[.054d08, .054d2e) exec(376-375), time(20.268-20.268 ms): <fib+16>
test/stdc/tryExec.ci:15:[.055008, .05500c) exec(64-1), time(0.040-0.040 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.05500c, .05501b) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.055020, .055027) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.055034, .05503b) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.05503b, .055042) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.055042, .055049) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.055030, .055049) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.055049, .05506f) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.055078, .05507d) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.05507d, .055080) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.055088, .05508a) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.055160, .055164) exec(5), time(0.036-0.036 ms): <lenSlice+0>
test/lang/array.ci:104:[.055168, .055174) exec(21), time(0.237-0.237 ms): <nthFixed+0>
test/lang/array.ci:105:[.055178, .055184) exec(21), time(0.217-0.217 ms): <nthArray+0>
test/lang/array.ci:106:[.055188, .055194) exec(14), time(0.168-0.168 ms): <nthSlice+0>
test/lang/method.ci:11:[.0551e8, .05520e) exec(3), time(0.423-0.423 ms): <staticMethod+0>
test/lang/method.ci:41:[.055218, .05523e) exec(4), time(0.547-0.547 ms): <virtualMethod+0>
test/lang/method.ci:48:[.055240, .055266) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.055268, .05528e) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.0552a0, .0552c3) exec(1), time(0.041-0.041 ms): <staticMethod+0>
test/lang/method.ci:87:[.0552d1, .0552e1) exec(1), time(0.222-0.222 ms): <staticMethod+49>
test/lang/method.ci:86:[.0552c3, .0552e1) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.0552e8, .05530b) exec(1), time(0.027-0.027 ms): <virtualMethod+0>
test/lang/method.ci:93:[.055319, .055326) exec(1), time(0.229-0.229 ms): <virtualMethod+49>
test/lang/method.ci:92:[.05530b, .055326) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.055d6c, .055d7a) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.055d7a, .055d88) exec(1), time(0.002-0.002 ms): <.main+14>
::[.055d91, .055d98) exec(1), time(0.002-0.002 ms): <.main+37>
::[.055d98, .055d9d) exec(1), time(0.001-0.001 ms): <.main+44>
::[.055d9d, .055da2) exec(1), time(0.002-0.002 ms): <.main+49>
lib/std/string.ci:223:[.055d88, .055da2) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.055da2, .055da7) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/emit.ci:4:[.055da7, .055dac) exec(1), time(0.001-0.001 ms): <.main+59>
test/lang/emit.ci:6:[.055dac, .055db5) exec(1), time(0.001-0.001 ms): <.main+64>
test/lang/emit.ci:7:[.055db5, .055dbe) exec(1), time(0.001-0.001 ms): <.main+73>
test/lang/emit.ci:9:[.055dbe, .055dcb) exec(1), time(0.003-0.003 ms): <.main+82>
test/lang/emit.ci:10:[.055dcb, .055dda) exec(1), time(0.002-0.002 ms): <.main+95>
test/lang/emit.ci:17:[.055dda, .055de3) exec(1), time(0.001-0.001 ms): <.main+110>
test/lang/emit.ci:18:[.055de3, .055ded) exec(1), time(0.002-0.002 ms): <.main+119>
test/lang/emit.ci:19:[.055ded, .055dfb) exec(1), time(0.002-0.002 ms): <.main+129>
test/lang/emit.ci:20:[.055dfb, .055e08) exec(1), time(0.002-0.002 ms): <.main+143>
test/lang/emit.ci:23:[.055e08, .055e16) exec(1), time(0.002-0.002 ms): <.main+156>
test/lang/inlineMacros.ci:10:[.055e16, .055e1f) exec(1), time(0.001-0.001 ms): <.main+170>
test/lang/inlineMacros.ci:11:[.055e1f, .055e28) exec(1), time(0.001-0.001 ms): <.main+179>
test/lang/inlineMacros.ci:12:[.055e28, .055e31) exec(1), time(0.001-0.001 ms): <.main+188>
test/lang/inlineMacros.ci:13:[.055e31, .055e3a) exec(1), time(0.001-0.001 ms): <.main+197>
test/lang/inlineMacros.ci:15:[.055e3a, .055e3f) exec(1), time(0.002-0.002 ms): <.main+206>
test/lang/inlineMacros.ci:16:[.055e3f, .055e44) exec(1), time(0.001-0.001 ms): <.main+211>
test/lang/inlineMacros.ci:17:[.055e44, .055e49) exec(1), time(0.001-0.001 ms): <.main+216>
test/lang/inlineMacros.ci:19:[.055e49, .055e52) exec(1), time(0.001-0.001 ms): <.main+221>
test/lang/inlineMacros.ci:20:[.055e52, .055e5a) exec(1), time(0.001-0.001 ms): <.main+230>
test/lang/inlineMacros.ci:21:[.055e5a, .055e6a) exec(1), time(0.003-0.003 ms): <.main+238>
test/lang/inlineMacros.ci:23:[.055e6a, .055e77) exec(1), time(0.001-0.001 ms): <.main+254>
test/lang/inlineMacros.ci:24:[.055e77, .055e84) exec(1), time(0.002-0.002 ms): <.main+267>
test/lang/inlineMacros.ci:25:[.055e84, .055e9d) exec(1), time(0.004-0.004 ms): <.main+280>
test/lang/inlineMacros.ci:27:[.055e9d, .055eb9) exec(1), time(0.004-0.004 ms): <.main+305>
test/lang/inlineMacros.ci:28:[.055eb9, .055ed3) exec(1), time(0.004-0.004 ms): <.main+333>
test/lang/inlineMacros.ci:29:[.055ed3, .055ef9) exec(1), time(0.005-0.005 ms): <.main+359>
test/lang/inlineMacros.ci:31:[.055ef9, .055f1e) exec(1), time(0.006-0.006 ms): <.main+397>
test/lang/inlineMacros.ci:32:[.055f1e, .055f41) exec(1), time(0.006-0.006 ms): <.main+434>
test/lang/inlineMacros.ci:33:[.055f41, .055f70) exec(1), time(0.007-0.007 ms): <.main+469>
test/lang/inlineMacros.ci:35:[.055f70, .055f95) exec(1), time(0.005-0.005 ms): <.main+516>
test/lang/inlineMacros.ci:36:[.055f95, .055fb8) exec(1), time(0.006-0.006 ms): <.main+553>
test/lang/inlineMacros.ci:37:[.055fb8, .055fe7) exec(1), time(0.007-0.007 ms): <.main+588>
test/lang/inlineMacros.ci:41:[.055fe7, .056000) exec(1), time(0.004-0.004 ms): <.main+635>
test/lang/inlineMacros.ci:42:[.056000, .056015) exec(1), time(0.003-0.003 ms): <.main+660>
test/lang/inlineMacros.ci:43:[.056015, .05602c) exec(1), time(0.004-0.004 ms): <.main+681>
test/lang/inlineMacros.ci:44:[.05602c, .056043) exec(1), time(0.005-0.005 ms): <.main+704>
test/lang/inlineMacros.ci:45:[.056043, .05606e) exec(1), time(0.007-0.007 ms): <.main+727>
test/lang/inlineMacros.ci:46:[.05606e, .056099) exec(1), time(0.007-0.007 ms): <.main+770>
test/lang/inlineMacros.ci:50:[.056099, .0560db) exec(1), time(0.004-0.004 ms): <.main+813>
test/lang/inlineMacros.ci:51:[.0560db, .05611d) exec(1), time(0.010-0.010 ms): <.main+879>
test/lang/inlineMacros.ci:52:[.05611d, .05615b) exec(1), time(0.004-0.004 ms): <.main+945>
test/lang/inlineMacros.ci:53:[.05615b, .056199) exec(1), time(0.009-0.009 ms): <.main+1007>
test/lang/inlineMacros.ci:54:[.056199, .0561eb) exec(1), time(0.006-0.006 ms): <.main+1069>
test/lang/inlineMacros.ci:55:[.0561eb, .05623d) exec(1), time(0.010-0.010 ms): <.main+1151>
test/lang/inlineMacros.ci:59:[.05623d, .05629a) exec(1), time(0.015-0.015 ms): <.main+1233>
test/lang/inlineMacros.ci:60:[.05629a, .0562f7) exec(1), time(0.016-0.016 ms): <.main+1326>
test/lang/inlineMacros.ci:61:[.0562f7, .056350) exec(1), time(0.016-0.016 ms): <.main+1419>
test/lang/inlineMacros.ci:62:[.056350, .0563a9) exec(1), time(0.016-0.016 ms): <.main+1508>
test/lang/inlineMacros.ci:63:[.0563a9, .056416) exec(1), time(0.031-0.031 ms): <.main+1597>
test/lang/inlineMacros.ci:64:[.056416, .056483) exec(1), time(0.018-0.018 ms): <.main+1706>
test/lang/inlineMacros.ci:68:[.056483, .0564e0) exec(1), time(0.014-0.014 ms): <.main+1815>
test/lang/inlineMacros.ci:69:[.0564e0, .05653d) exec(1), time(0.028-0.028 ms): <.main+1908>
test/lang/inlineMacros.ci:70:[.05653d, .056596) exec(1), time(0.015-0.015 ms): <.main+2001>
test/lang/inlineMacros.ci:71:[.056596, .0565ef) exec(1), time(0.015-0.015 ms): <.main+2090>
test/lang/inlineMacros.ci:72:[.0565ef, .05665c) exec(1), time(0.017-0.017 ms): <.main+2179>
test/lang/inlineMacros.ci:73:[.05665c, .0566c9) exec(1), time(0.018-0.018 ms): <.main+2288>
test/lang/overload.inline.ci:9:[.0566c9, .0566d2) exec(1), time(0.001-0.001 ms): <.main+2397>
test/lang/overload.inline.ci:10:[.0566d2, .0566db) exec(1), time(0.001-0.001 ms): <.main+2406>
test/lang/overload.inline.ci:11:[.0566db, .0566e4) exec(1), time(0.002-0.002 ms): <.main+2415>
test/lang/overload.inline.ci:12:[.0566e4, .0566ed) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/overload.inline.ci:13:[.0566ed, .0566f6) exec(1), time(0.001-0.001 ms): <.main+2433>
test/lang/overload.inline.ci:28:[.0566f6, .056703) exec(1), time(0.001-0.001 ms): <.main+2442>
test/lang/overload.inline.ci:29:[.056703, .05671f) exec(1), time(0.003-0.003 ms): <.main+2455>
test/lang/initByRef.ci:7:[.05671f, .05672c) exec(1), time(0.002-0.002 ms): <.main+2483>
test/lang/initByRef.ci:8:[.05672c, .056735) exec(1), time(0.001-0.001 ms): <.main+2496>
test/lang/initByRef.ci:9:[.056735, .05673e) exec(1), time(0.001-0.001 ms): <.main+2505>
test/lang/initByRef.ci:10:[.05673e, .05674c) exec(1), time(0.002-0.002 ms): <.main+2514>
test/lang/initByRef.ci:12:[.05674c, .056755) exec(1), time(0.002-0.002 ms): <.main+2528>
test/lang/initByRef.ci:13:[.056755, .05675d) exec(1), time(0.001-0.001 ms): <.main+2537>
test/lang/initByRef.ci:14:[.05675d, .056765) exec(1), time(0.002-0.002 ms): <.main+2545>
test/lang/initByRef.ci:16:[.056765, .05676e) exec(1), time(0.001-0.001 ms): <.main+2553>
test/lang/initByRef.ci:17:[.05676e, .056777) exec(1), time(0.001-0.001 ms): <.main+2562>
test/lang/initByRef.ci:18:[.056777, .056785) exec(1), time(0.002-0.002 ms): <.main+2571>
test/lang/initByRef.ci:19:[.056785, .05678e) exec(1), time(0.001-0.001 ms): <.main+2585>
test/lang/initByRef.ci:20:[.05678e, .056797) exec(1), time(0.002-0.002 ms): <.main+2594>
test/lang/initByRef.ci:21:[.056797, .0567a0) exec(1), time(0.001-0.001 ms): <.main+2603>
test/lang/initByRef.ci:23:[.0567a0, .0567a9) exec(1), time(0.001-0.001 ms): <.main+2612>
test/lang/initByRef.ci:24:[.0567a9, .0567b7) exec(1), time(0.002-0.002 ms): <.main+2621>
test/lang/initByRef.ci:25:[.0567b7, .0567c0) exec(1), time(0.001-0.001 ms): <.main+2635>
test/lang/initByRef.ci:27:[.0567c0, .0567c8) exec(1), time(0.002-0.002 ms): <.main+2644>
test/lang/initByRef.ci:28:[.0567c8, .0567d0) exec(1), time(0.001-0.001 ms): <.main+2652>
test/lang/initByRef.ci:29:[.0567d0, .0567d8) exec(1), time(0.001-0.001 ms): <.main+2660>
test/lang/initByRef.ci:30:[.0567d8, .0567e0) exec(1), time(0.001-0.001 ms): <.main+2668>
test/lang/initByRef.ci:31:[.0567e0, .0567e8) exec(1), time(0.001-0.001 ms): <.main+2676>
test/lang/initByRef.ci:32:[.0567e8, .0567f0) exec(1), time(0.001-0.001 ms): <.main+2684>
test/lang/initByRef.ci:35:[.0567f0, .0567f9) exec(1), time(0.002-0.002 ms): <.main+2692>
test/lang/initByRef.ci:36:[.0567f9, .056802) exec(1), time(0.001-0.001 ms): <.main+2701>
test/lang/initByRef.ci:37:[.056802, .05680b) exec(1), time(0.001-0.001 ms): <.main+2710>
test/lang/initByRef.ci:38:[.05680b, .056814) exec(1), time(0.001-0.001 ms): <.main+2719>
test/lang/initByRef.ci:39:[.056814, .05681d) exec(1), time(0.001-0.001 ms): <.main+2728>
test/lang/initByRef.ci:40:[.05681d, .056826) exec(1), time(0.001-0.001 ms): <.main+2737>
test/lang/initByRef.ci:41:[.056826, .05682f) exec(1), time(0.001-0.001 ms): <.main+2746>
test/lang/initByRef.ci:42:[.05682f, .056838) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/initByRef.ci:43:[.056838, .056841) exec(1), time(0.019-0.019 ms): <.main+2764>
test/lang/initByRef.ci:44:[.056841, .05684a) exec(1), time(0.001-0.001 ms): <.main+2773>
test/lang/initByRef.ci:45:[.05684a, .056853) exec(1), time(0.001-0.001 ms): <.main+2782>
test/lang/initByRef.ci:46:[.056853, .05685c) exec(1), time(0.001-0.001 ms): <.main+2791>
test/lang/initByRef.ci:47:[.05685c, .056865) exec(1), time(0.001-0.001 ms): <.main+2800>
test/lang/initByRef.ci:48:[.056865, .05686e) exec(1), time(0.001-0.001 ms): <.main+2809>
test/lang/initByRef.ci:49:[.05686e, .056877) exec(1), time(0.001-0.001 ms): <.main+2818>
test/lang/initByRef.ci:50:[.056877, .056880) exec(1), time(0.001-0.001 ms): <.main+2827>
test/lang/initByRef.ci:51:[.056880, .056889) exec(1), time(0.002-0.002 ms): <.main+2836>
test/lang/initByRef.ci:52:[.056889, .056892) exec(1), time(0.001-0.001 ms): <.main+2845>
test/lang/initByRef.ci:55:[.056892, .0568a0) exec(1), time(0.002-0.002 ms): <.main+2854>
test/lang/initByRef.ci:56:[.0568a0, .0568ae) exec(1), time(0.002-0.002 ms): <.main+2868>
test/lang/initByRef.ci:57:[.0568ae, .0568bc) exec(1), time(0.002-0.002 ms): <.main+2882>
test/lang/initByRef.ci:58:[.0568bc, .0568ca) exec(1), time(0.002-0.002 ms): <.main+2896>
test/lang/initByRef.ci:59:[.0568ca, .0568d8) exec(1), time(0.001-0.001 ms): <.main+2910>
test/lang/initByRef.ci:60:[.0568d8, .0568e6) exec(1), time(0.001-0.001 ms): <.main+2924>
test/lang/initByRef.ci:61:[.0568e6, .0568f4) exec(1), time(0.002-0.002 ms): <.main+2938>
test/lang/initByRef.ci:62:[.0568f4, .056902) exec(1), time(0.002-0.002 ms): <.main+2952>
test/lang/initByRef.ci:63:[.056902, .056910) exec(1), time(0.002-0.002 ms): <.main+2966>
test/lang/initByRef.ci:64:[.056910, .05691e) exec(1), time(0.002-0.002 ms): <.main+2980>
test/lang/initByRef.ci:65:[.05691e, .05692c) exec(1), time(0.002-0.002 ms): <.main+2994>
test/lang/initByRef.ci:66:[.05692c, .05693a) exec(1), time(0.002-0.002 ms): <.main+3008>
test/lang/initByRef.ci:67:[.05693a, .056948) exec(1), time(0.002-0.002 ms): <.main+3022>
test/lang/initByRef.ci:68:[.056948, .056956) exec(1), time(0.002-0.002 ms): <.main+3036>
test/lang/initByRef.ci:69:[.056956, .056964) exec(1), time(0.002-0.002 ms): <.main+3050>
test/lang/initByRef.ci:70:[.056964, .056972) exec(1), time(0.002-0.002 ms): <.main+3064>
test/lang/initByRef.ci:71:[.056972, .056980) exec(1), time(0.002-0.002 ms): <.main+3078>
test/lang/initByRef.ci:72:[.056980, .05698e) exec(1), time(0.002-0.002 ms): <.main+3092>
test/lang/initByRef.ci:75:[.05698e, .056997) exec(1), time(0.001-0.001 ms): <.main+3106>
test/lang/initByRef.ci:76:[.056997, .0569a0) exec(1), time(0.001-0.001 ms): <.main+3115>
test/lang/initByRef.ci:77:[.0569a0, .0569a9) exec(1), time(0.001-0.001 ms): <.main+3124>
test/lang/initByRef.ci:78:[.0569a9, .0569b2) exec(1), time(0.001-0.001 ms): <.main+3133>
test/lang/initByRef.ci:79:[.0569b2, .0569bb) exec(1), time(0.001-0.001 ms): <.main+3142>
test/lang/initByRef.ci:80:[.0569bb, .0569c4) exec(1), time(0.002-0.002 ms): <.main+3151>
test/lang/initByRef.ci:81:[.0569c4, .0569cd) exec(1), time(0.001-0.001 ms): <.main+3160>
test/lang/initByRef.ci:82:[.0569cd, .0569d6) exec(1), time(0.001-0.001 ms): <.main+3169>
test/lang/initByRef.ci:83:[.0569d6, .0569df) exec(1), time(0.002-0.002 ms): <.main+3178>
test/lang/initByRef.ci:84:[.0569df, .0569e8) exec(1), time(0.001-0.001 ms): <.main+3187>
test/lang/initByRef.ci:85:[.0569e8, .0569f1) exec(1), time(0.001-0.001 ms): <.main+3196>
test/lang/initByRef.ci:86:[.0569f1, .0569fa) exec(1), time(0.002-0.002 ms): <.main+3205>
test/lang/initByRef.ci:87:[.0569fa, .056a03) exec(1), time(0.001-0.001 ms): <.main+3214>
test/lang/initByRef.ci:88:[.056a03, .056a0c) exec(1), time(0.001-0.001 ms): <.main+3223>
test/lang/initByRef.ci:89:[.056a0c, .056a15) exec(1), time(0.001-0.001 ms): <.main+3232>
test/lang/initByRef.ci:90:[.056a15, .056a1e) exec(1), time(0.001-0.001 ms): <.main+3241>
test/lang/initByRef.ci:91:[.056a1e, .056a27) exec(1), time(0.001-0.001 ms): <.main+3250>
test/lang/initByRef.ci:92:[.056a27, .056a30) exec(1), time(0.001-0.001 ms): <.main+3259>
test/lang/initByRef.ci:95:[.056a30, .056a39) exec(1), time(0.001-0.001 ms): <.main+3268>
test/lang/initByRef.ci:96:[.056a39, .056a47) exec(1), time(0.002-0.002 ms): <.main+3277>
test/lang/initByRef.ci:97:[.056a47, .056a50) exec(1), time(0.001-0.001 ms): <.main+3291>
test/lang/initByRef.ci:99:[.056a50, .056a59) exec(1), time(0.002-0.002 ms): <.main+3300>
test/lang/initByRef.ci:105:[.056a59, .056a66) exec(1), time(0.002-0.002 ms): <.main+3309>
test/lang/initByRef.ci:108:[.056a66, .056a6e) exec(1), time(0.001-0.001 ms): <.main+3322>
test/lang/function.ci:12:[.056a6e, .056a87) exec(1), time(0.027-0.027 ms): <.main+3330>
test/lang/function.ci:15:[.056a87, .056a90) exec(1), time(0.001-0.001 ms): <.main+3355>
test/lang/function.ci:18:[.056a90, .056aa8) exec(1), time(0.025-0.025 ms): <.main+3364>
test/lang/function.ci:21:[.056aa8, .056ab1) exec(1), time(0.001-0.001 ms): <.main+3388>
test/lang/function.ci:24:[.056ab1, .056ac9) exec(1), time(0.025-0.025 ms): <.main+3397>
test/lang/function.ci:27:[.056ac9, .056ad1) exec(1), time(0.001-0.001 ms): <.main+3421>
test/lang/function.ci:30:[.056ad1, .056ae9) exec(1), time(0.025-0.025 ms): <.main+3429>
test/lang/function.ci:46:[.056ae9, .056afd) exec(1), time(20.290-20.290 ms): <.main+3453>
test/lang/reflect.ci:3:[.056afd, .056b05) exec(1), time(0.020-0.020 ms): <.main+3473>
test/lang/reflect.ci:4:[.056b05, .056b0d) exec(1), time(0.001-0.001 ms): <.main+3481>
test/lang/reflect.ci:5:[.056b0d, .056b15) exec(1), time(0.002-0.002 ms): <.main+3489>
test/lang/reflect.ci:6:[.056b15, .056b1d) exec(1), time(0.001-0.001 ms): <.main+3497>
test/lang/reflect.ci:7:[.056b1d, .056b25) exec(1), time(0.001-0.001 ms): <.main+3505>
test/lang/reflect.ci:8:[.056b25, .056b2d) exec(1), time(0.002-0.002 ms): <.main+3513>
test/lang/reflect.ci:9:[.056b2d, .056b35) exec(1), time(0.001-0.001 ms): <.main+3521>
test/lang/reflect.ci:10:[.056b35, .056b3d) exec(1), time(0.002-0.002 ms): <.main+3529>
test/lang/reflect.ci:11:[.056b3d, .056b45) exec(1), time(0.001-0.001 ms): <.main+3537>
test/lang/reflect.ci:12:[.056b45, .056b4d) exec(1), time(0.001-0.001 ms): <.main+3545>
test/lang/reflect.ci:13:[.056b4d, .056b55) exec(1), time(0.002-0.002 ms): <.main+3553>
test/lang/reflect.ci:14:[.056b55, .056b5d) exec(1), time(0.001-0.001 ms): <.main+3561>
test/lang/reflect.ci:15:[.056b5d, .056b65) exec(1), time(0.001-0.001 ms): <.main+3569>
test/lang/reflect.ci:16:[.056b65, .056b6d) exec(1), time(0.001-0.001 ms): <.main+3577>
test/lang/reflect.ci:17:[.056b6d, .056b75) exec(1), time(0.001-0.001 ms): <.main+3585>
test/lang/reflect.ci:18:[.056b75, .056b7d) exec(1), time(0.001-0.001 ms): <.main+3593>
test/lang/reflect.ci:19:[.056b7d, .056b85) exec(1), time(0.002-0.002 ms): <.main+3601>
test/lang/reflect.ci:20:[.056b85, .056b8d) exec(1), time(0.001-0.001 ms): <.main+3609>
test/lang/reflect.ci:30:[.056b8d, .056b96) exec(1), time(0.002-0.002 ms): <.main+3617>
test/lang/reflect.ci:31:[.056b96, .056ba2) exec(1), time(0.050-0.050 ms): <.main+3626>
test/lang/reflect.ci:32:[.056ba2, .056baf) exec(1), time(0.003-0.003 ms): <.main+3638>
test/lang/reflect.ci:33:[.056baf, .056bbc) exec(1), time(0.003-0.003 ms): <.main+3651>
test/lang/reflect.ci:34:[.056bbc, .056bc8) exec(1), time(0.026-0.026 ms): <.main+3664>
test/lang/reflect.ci:35:[.056bc8, .056bd4) exec(1), time(0.026-0.026 ms): <.main+3676>
test/lang/reflect.ci:37:[.056bd4, .056be0) exec(1), time(0.026-0.026 ms): <.main+3688>
test/lang/reflect.ci:38:[.056be0, .056bec) exec(1), time(0.040-0.040 ms): <.main+3700>
test/lang/reflect.ci:39:[.056bec, .056bf9) exec(1), time(0.003-0.003 ms): <.main+3712>
test/lang/reflect.ci:40:[.056bf9, .056c06) exec(1), time(0.002-0.002 ms): <.main+3725>
test/lang/reflect.ci:41:[.056c06, .056c12) exec(1), time(0.039-0.039 ms): <.main+3738>
test/lang/reflect.ci:42:[.056c12, .056c1e) exec(1), time(0.039-0.039 ms): <.main+3750>
test/lang/reflect.ci:44:[.056c1e, .056c2a) exec(1), time(0.066-0.066 ms): <.main+3762>
test/lang/reflect.ci:45:[.056c2a, .056c37) exec(1), time(0.002-0.002 ms): <.main+3774>
test/lang/reflect.ci:46:[.056c37, .056c44) exec(1), time(0.002-0.002 ms): <.main+3787>
test/lang/reflect.ci:48:[.056c44, .056c50) exec(1), time(0.023-0.023 ms): <.main+3800>
test/lang/reflect.ci:49:[.056c50, .056c5d) exec(1), time(0.003-0.003 ms): <.main+3812>
test/lang/reflect.ci:50:[.056c5d, .056c6a) exec(1), time(0.003-0.003 ms): <.main+3825>
test/stdc/number.ci:3:[.056c6a, .056c77) exec(1), time(0.002-0.002 ms): <.main+3838>
test/stdc/number.ci:4:[.056c77, .056c84) exec(1), time(0.001-0.001 ms): <.main+3851>
test/stdc/number.ci:6:[.056c84, .056c8d) exec(1), time(0.002-0.002 ms): <.main+3864>
test/stdc/number.ci:7:[.056c8d, .056c96) exec(1), time(0.002-0.002 ms): <.main+3873>
test/stdc/number.ci:14:[.056c96, .056ca1) exec(1), time(0.002-0.002 ms): <.main+3882>
test/stdc/number.ci:15:[.056ca1, .056cac) exec(1), time(0.002-0.002 ms): <.main+3893>
test/stdc/number.ci:16:[.056cac, .056cb7) exec(1), time(0.002-0.002 ms): <.main+3904>
test/stdc/number.ci:18:[.056cb7, .056cdd) exec(1), time(0.010-0.010 ms): <.main+3915>
test/stdc/number.ci:19:[.056cdd, .056d01) exec(1), time(0.009-0.009 ms): <.main+3953>
test/stdc/number.ci:21:[.056d01, .056d17) exec(1), time(0.026-0.026 ms): <.main+3989>
test/stdc/number.ci:22:[.056d17, .056d2d) exec(1), time(0.039-0.039 ms): <.main+4011>
test/stdc/number.ci:23:[.056d2d, .056d3f) exec(1), time(0.025-0.025 ms): <.main+4033>
test/stdc/number.ci:25:[.056d3f, .056d55) exec(1), time(0.025-0.025 ms): <.main+4051>
test/stdc/number.ci:26:[.056d55, .056d6b) exec(1), time(0.025-0.025 ms): <.main+4073>
test/stdc/number.ci:27:[.056d6b, .056d7d) exec(1), time(0.039-0.039 ms): <.main+4095>
test/stdc/number.ci:29:[.056d7d, .056d93) exec(1), time(0.025-0.025 ms): <.main+4113>
test/stdc/number.ci:30:[.056d93, .056da9) exec(1), time(0.038-0.038 ms): <.main+4135>
test/stdc/number.ci:31:[.056da9, .056dbb) exec(1), time(0.025-0.025 ms): <.main+4157>
test/stdc/number.ci:33:[.056dbb, .056dd1) exec(1), time(0.027-0.027 ms): <.main+4175>
test/stdc/number.ci:34:[.056dd1, .056de7) exec(1), time(0.025-0.025 ms): <.main+4197>
test/stdc/number.ci:35:[.056de7, .056df9) exec(1), time(0.025-0.025 ms): <.main+4219>
test/stdc/number.ci:37:[.056df9, .056e0f) exec(1), time(0.041-0.041 ms): <.main+4237>
test/stdc/number.ci:38:[.056e0f, .056e25) exec(1), time(0.034-0.034 ms): <.main+4259>
test/stdc/number.ci:39:[.056e25, .056e3b) exec(1), time(0.025-0.025 ms): <.main+4281>
test/stdc/number.ci:40:[.056e3b, .056e51) exec(1), time(0.043-0.043 ms): <.main+4303>
test/stdc/number.ci:41:[.056e51, .056e62) exec(1), time(0.027-0.027 ms): <.main+4325>
test/stdc/number.ci:42:[.056e62, .056e7c) exec(1), time(0.040-0.040 ms): <.main+4342>
test/stdc/number.ci:43:[.056e7c, .056e8d) exec(1), time(0.025-0.025 ms): <.main+4368>
test/stdc/number.ci:44:[.056e8d, .056ea2) exec(1), time(0.031-0.031 ms): <.main+4385>
test/stdc/number.ci:46:[.056ea2, .056eb4) exec(1), time(0.025-0.025 ms): <.main+4406>
test/stdc/number.ci:47:[.056eb4, .056ec6) exec(1), time(0.025-0.025 ms): <.main+4424>
test/stdc/number.ci:48:[.056ec6, .056ed8) exec(1), time(0.025-0.025 ms): <.main+4442>
test/stdc/number.ci:49:[.056ed8, .056eee) exec(1), time(0.027-0.027 ms): <.main+4460>
test/stdc/number.ci:50:[.056eee, .056efb) exec(1), time(0.024-0.024 ms): <.main+4482>
test/stdc/number.ci:51:[.056efb, .056f11) exec(1), time(0.026-0.026 ms): <.main+4495>
test/stdc/number.ci:52:[.056f11, .056f22) exec(1), time(0.025-0.025 ms): <.main+4517>
test/stdc/number.ci:53:[.056f22, .056f33) exec(1), time(0.028-0.028 ms): <.main+4534>
test/stdc/number.ci:55:[.056f33, .056f3f) exec(1), time(0.024-0.024 ms): <.main+4551>
test/stdc/number.ci:56:[.056f3f, .056f4b) exec(1), time(0.024-0.024 ms): <.main+4563>
test/stdc/number.ci:57:[.056f4b, .056f57) exec(1), time(0.051-0.051 ms): <.main+4575>
test/stdc/number.ci:58:[.056f57, .056f63) exec(1), time(0.024-0.024 ms): <.main+4587>
test/stdc/number.ci:59:[.056f63, .056f6f) exec(1), time(0.024-0.024 ms): <.main+4599>
test/stdc/number.ci:60:[.056f6f, .056f7b) exec(1), time(0.023-0.023 ms): <.main+4611>
test/stdc/number.ci:62:[.056f7b, .056f8d) exec(1), time(0.025-0.025 ms): <.main+4623>
test/stdc/number.ci:63:[.056f8d, .056f9f) exec(1), time(0.026-0.026 ms): <.main+4641>
test/stdc/number.ci:65:[.056f9f, .056fb3) exec(1), time(0.027-0.027 ms): <.main+4659>
test/stdc/number.ci:66:[.056fb3, .056fc7) exec(1), time(0.027-0.027 ms): <.main+4679>
test/stdc/memory.ci:7:[.056fc7, .056fd9) exec(1), time(0.031-0.031 ms): <.main+4699>
test/stdc/memory.ci:8:[.056fd9, .056feb) exec(1), time(0.037-0.037 ms): <.main+4717>
test/stdc/memory.ci:9:[.056feb, .056ffd) exec(1), time(0.056-0.056 ms): <.main+4735>
test/stdc/memory.ci:10:[.056ffd, .05700f) exec(1), time(0.028-0.028 ms): <.main+4753>
test/stdc/memory.ci:23:[.05700f, .05701c) exec(1), time(0.002-0.002 ms): <.main+4771>
test/stdc/memory.ci:24:[.05701c, .057029) exec(1), time(0.002-0.002 ms): <.main+4784>
test/stdc/tryExec.ci:46:[.057029, .05703b) exec(1), time(0.062-0.062 ms): <.main+4797>
test/stdc/tryExec.ci:47:[.05703b, .05704d) exec(1), time(0.028-0.028 ms): <.main+4815>
test/stdc/tryExec.ci:48:[.05704d, .05705f) exec(1), time(1.480-1.480 ms): <.main+4833>
test/stdc/tryExec.ci:49:[.05705f, .057071) exec(1), time(0.047-0.047 ms): <.main+4851>
test/stdc/tryExec.ci:50:[.057071, .057083) exec(1), time(0.042-0.042 ms): <.main+4869>
test/stdc/tryExec.ci:51:[.057083, .057095) exec(1), time(0.045-0.045 ms): <.main+4887>
test/stdc/tryExec.ci:52:[.057095, .0570a7) exec(1), time(0.165-0.165 ms): <.main+4905>
test/lang/array.ci:59:[.0570a7, .0570b0) exec(1), time(0.002-0.002 ms): <.main+4923>
test/lang/array.ci:60:[.0570b0, .0570ba) exec(1), time(0.002-0.002 ms): <.main+4932>
test/lang/array.ci:63:[.0570ba, .0570c3) exec(1), time(0.002-0.002 ms): <.main+4942>
test/lang/array.ci:64:[.0570c3, .0570d1) exec(1), time(0.002-0.002 ms): <.main+4951>
test/lang/array.ci:67:[.0570d1, .0570d9) exec(1), time(0.002-0.002 ms): <.main+4965>
test/lang/array.ci:68:[.0570d9, .0570e1) exec(1), time(0.001-0.001 ms): <.main+4973>
test/lang/array.ci:71:[.0570e1, .0570e9) exec(1), time(0.001-0.001 ms): <.main+4981>
test/lang/array.ci:86:[.0570e9, .0570f2) exec(1), time(0.001-0.001 ms): <.main+4989>
test/lang/array.ci:90:[.0570f2, .057100) exec(1), time(0.002-0.002 ms): <.main+4998>
test/lang/member.ci:35:[.057100, .057105) exec(1), time(0.001-0.001 ms): <.main+5012>
test/lang/member.ci:38:[.057105, .05710e) exec(1), time(0.001-0.001 ms): <.main+5017>
test/lang/member.ci:41:[.05710e, .057117) exec(1), time(0.002-0.002 ms): <.main+5026>
test/lang/member.ci:47:[.057120, .057129) exec(1), time(0.001-0.001 ms): <.main+5044>
test/lang/member.ci:47:[.057117, .057129) exec(1-1), time(0.000 ms): <.main+5035>
test/lang/member.ci:50:[.057132, .05713b) exec(1), time(0.001-0.001 ms): <.main+5062>
test/lang/member.ci:50:[.057129, .05713b) exec(1-1), time(0.000 ms): <.main+5053>
test/lang/member.ci:55:[.057144, .05714d) exec(1), time(0.002-0.002 ms): <.main+5080>
test/lang/member.ci:56:[.05714d, .057156) exec(1), time(0.001-0.001 ms): <.main+5089>
test/lang/member.ci:57:[.057156, .05715f) exec(1), time(0.001-0.001 ms): <.main+5098>
test/lang/member.ci:60:[.05715f, .057168) exec(1), time(0.002-0.002 ms): <.main+5107>
test/lang/member.ci:61:[.057168, .057171) exec(1), time(0.001-0.001 ms): <.main+5116>
test/lang/member.ci:65:[.057171, .05717a) exec(1), time(0.002-0.002 ms): <.main+5125>
test/lang/member.ci:66:[.05717a, .057183) exec(1), time(0.001-0.001 ms): <.main+5134>
test/lang/member.ci:53:[.05713b, .057183) exec(1-1), time(0.000 ms): <.main+5071>
test/lang/method.ci:18:[.057183, .05718c) exec(1), time(0.001-0.001 ms): <.main+5143>
::[.057195, .05719d) exec(1), time(0.002-0.002 ms): <.main+5161>
::[.05719d, .0571a6) exec(1), time(0.001-0.001 ms): <.main+5169>
test/lang/method.ci:62:[.05718c, .0571a6) exec(1-1), time(0.000 ms): <.main+5152>
test/lang/recUnion.ci:26:[.0571ad, .0571b4) exec(1), time(0.003-0.003 ms): <.main+5185>
test/lang/recUnion.ci:26:[.0571b4, .0571bb) exec(1), time(0.002-0.002 ms): <.main+5192>
test/lang/recUnion.ci:26:[.0571a6, .0571bb) exec(1-1), time(0.000 ms): <.main+5178>
test/lang/recUnion.ci:27:[.0571c2, .0571cd) exec(1), time(0.002-0.002 ms): <.main+5206>
test/lang/recUnion.ci:27:[.0571cd, .0571d4) exec(1), time(0.002-0.002 ms): <.main+5217>
test/lang/recUnion.ci:27:[.0571bb, .0571d4) exec(1-1), time(0.000 ms): <.main+5199>
test/lang/recUnion.ci:28:[.0571df, .0571ea) exec(1), time(0.002-0.002 ms): <.main+5235>
test/lang/recUnion.ci:28:[.0571ea, .0571f5) exec(1), time(0.002-0.002 ms): <.main+5246>
test/lang/recUnion.ci:28:[.0571d4, .0571f5) exec(1-1), time(0.000 ms): <.main+5224>
test/lang/recUnion.ci:30:[.0571f5, .0571fe) exec(1), time(0.001-0.001 ms): <.main+5257>
test/lang/recUnion.ci:31:[.057205, .05720c) exec(1), time(0.002-0.002 ms): <.main+5273>
test/lang/recUnion.ci:31:[.05720c, .057217) exec(1), time(0.002-0.002 ms): <.main+5280>
test/lang/recUnion.ci:31:[.0571fe, .057217) exec(1-1), time(0.000 ms): <.main+5266>
test/lang/useOperator.ci:5:[.057217, .057220) exec(1), time(0.001-0.001 ms): <.main+5291>
test/lang/useOperator.ci:7:[.057220, .05722b) exec(1), time(0.002-0.002 ms): <.main+5300>
test/lang/useOperator.ci:8:[.05722b, .057236) exec(1), time(0.002-0.002 ms): <.main+5311>
test/lang/useOperator.ci:17:[.057236, .057249) exec(1), time(0.005-0.005 ms): <.main+5322>
test/lang/useOperator.ci:18:[.057249, .05725c) exec(1), time(0.005-0.005 ms): <.main+5341>
test/lang/useOperator.ci:19:[.05725c, .05726f) exec(1), time(0.006-0.006 ms): <.main+5360>
test/lang/useOperator.ci:22:[.05726f, .05727c) exec(1), time(0.004-0.004 ms): <.main+5379>
test/lang/useOperator.ci:23:[.05727c, .05728f) exec(1), time(0.005-0.005 ms): <.main+5392>
test/lang/useOperator.ci:24:[.05728f, .0572a3) exec(1), time(0.006-0.006 ms): <.main+5411>
test/lang/useOperator.ci:25:[.0572a3, .0572b6) exec(1), time(0.005-0.005 ms): <.main+5431>
test/lang/useOperator.ci:26:[.0572b6, .0572ca) exec(1), time(0.007-0.007 ms): <.main+5450>
test/lang/useOperator.ci:27:[.0572ca, .0572dd) exec(1), time(0.005-0.005 ms): <.main+5470>
test/lang/useOperator.ci:28:[.0572dd, .0572f1) exec(1), time(0.005-0.005 ms): <.main+5489>
test/lang/useOperator.ci:30:[.0572f1, .0572fc) exec(1), time(0.002-0.002 ms): <.main+5509>
test/lang/useOperator.ci:31:[.0572fc, .057307) exec(1), time(0.003-0.003 ms): <.main+5520>
test/lang/useOperator.ci:32:[.057307, .057313) exec(1), time(0.003-0.003 ms): <.main+5531>
test/lang/useOperator.ci:33:[.057313, .057320) exec(1), time(0.004-0.004 ms): <.main+5543>
test/lang/useOperator.ci:34:[.057320, .05732d) exec(1), time(0.004-0.004 ms): <.main+5556>
test/lang/useOperator.ci:35:[.05732d, .057340) exec(1), time(0.006-0.006 ms): <.main+5569>
test/lang/useOperator.ci:36:[.057340, .057353) exec(1), time(0.005-0.005 ms): <.main+5588>
test/lang/useOperator.ci:37:[.057353, .057366) exec(1), time(0.005-0.005 ms): <.main+5607>
test/lang/useOperator.ci:38:[.057366, .057379) exec(1), time(0.005-0.005 ms): <.main+5626>
test/lang/useOperator.ci:39:[.057379, .05738c) exec(1), time(0.005-0.005 ms): <.main+5645>
test/lang/useOperator.ci:40:[.05738c, .05739f) exec(1), time(0.006-0.006 ms): <.main+5664>
test/lang/useOperator.ci:41:[.05739f, .0573b2) exec(1), time(0.005-0.005 ms): <.main+5683>
test/lang/useOperator.ci:42:[.0573b2, .0573c5) exec(1), time(0.005-0.005 ms): <.main+5702>
test/lang/useOperator.ci:43:[.0573c5, .0573d6) exec(1), time(0.005-0.005 ms): <.main+5721>
test/lang/useOperator.ci:44:[.0573d6, .0573e7) exec(1), time(0.005-0.005 ms): <.main+5738>
test/lang/useOperator.ci:45:[.0573e7, .0573f5) exec(1), time(0.005-0.005 ms): <.main+5755>
test/lang/useOperator.ci:46:[.0573f5, .057408) exec(1), time(0.005-0.005 ms): <.main+5769>
test/lang/useOperator.ci:47:[.057408, .05741c) exec(1), time(0.006-0.006 ms): <.main+5788>
test/lang/useOperator.ci:48:[.05741c, .05742f) exec(1), time(0.005-0.005 ms): <.main+5808>
test/lang/useOperator.ci:49:[.05742f, .057443) exec(1), time(0.009-0.009 ms): <.main+5827>
test/lang/useOperator.ci:50:[.057443, .057456) exec(1), time(0.006-0.006 ms): <.main+5847>
test/lang/useOperator.ci:51:[.057456, .05746a) exec(1), time(0.006-0.006 ms): <.main+5866>
test/lang/useOperator.ci:53:[.05746a, .057475) exec(1), time(0.020-0.020 ms): <.main+5886>
test/lang/useOperator.ci:54:[.057475, .057480) exec(1), time(0.003-0.003 ms): <.main+5897>
test/lang/useOperator.ci:55:[.057480, .05748c) exec(1), time(0.003-0.003 ms): <.main+5908>
test/lang/useOperator.ci:56:[.05748c, .057499) exec(1), time(0.004-0.004 ms): <.main+5920>
test/lang/useOperator.ci:57:[.057499, .0574a6) exec(1), time(0.004-0.004 ms): <.main+5933>
test/lang/useOperator.ci:58:[.0574a6, .0574b9) exec(1), time(0.006-0.006 ms): <.main+5946>
test/lang/useOperator.ci:59:[.0574b9, .0574cc) exec(1), time(0.005-0.005 ms): <.main+5965>
test/lang/useOperator.ci:60:[.0574cc, .0574df) exec(1), time(0.006-0.006 ms): <.main+5984>
test/lang/useOperator.ci:61:[.0574df, .0574f2) exec(1), time(0.021-0.021 ms): <.main+6003>
test/lang/useOperator.ci:62:[.0574f2, .057505) exec(1), time(0.005-0.005 ms): <.main+6022>
test/lang/useOperator.ci:63:[.057505, .057518) exec(1), time(0.006-0.006 ms): <.main+6041>
test/lang/useOperator.ci:64:[.057518, .05752b) exec(1), time(0.005-0.005 ms): <.main+6060>
test/lang/useOperator.ci:65:[.05752b, .05753e) exec(1), time(0.006-0.006 ms): <.main+6079>
test/lang/useOperator.ci:66:[.05753e, .05754f) exec(1), time(0.004-0.004 ms): <.main+6098>
test/lang/useOperator.ci:67:[.05754f, .057560) exec(1), time(0.004-0.004 ms): <.main+6115>
test/lang/useOperator.ci:68:[.057560, .05756e) exec(1), time(0.004-0.004 ms): <.main+6132>
test/lang/useOperator.ci:69:[.05756e, .057581) exec(1), time(0.005-0.005 ms): <.main+6146>
test/lang/useOperator.ci:70:[.057581, .057595) exec(1), time(0.007-0.007 ms): <.main+6165>
test/lang/useOperator.ci:71:[.057595, .0575a8) exec(1), time(0.005-0.005 ms): <.main+6185>
test/lang/useOperator.ci:72:[.0575a8, .0575bc) exec(1), time(0.006-0.006 ms): <.main+6204>
test/lang/useOperator.ci:73:[.0575bc, .0575cf) exec(1), time(0.006-0.006 ms): <.main+6224>
test/lang/useOperator.ci:74:[.0575cf, .0575e3) exec(1), time(0.006-0.006 ms): <.main+6243>
test/lang/useOperator.ci:76:[.0575e3, .0575ee) exec(1), time(0.003-0.003 ms): <.main+6263>
test/lang/useOperator.ci:77:[.0575ee, .0575f9) exec(1), time(0.002-0.002 ms): <.main+6274>
test/lang/useOperator.ci:78:[.0575f9, .057605) exec(1), time(0.003-0.003 ms): <.main+6285>
test/lang/useOperator.ci:79:[.057605, .057612) exec(1), time(0.004-0.004 ms): <.main+6297>
test/lang/useOperator.ci:80:[.057612, .05761f) exec(1), time(0.004-0.004 ms): <.main+6310>
test/lang/useOperator.ci:81:[.05761f, .057632) exec(1), time(0.006-0.006 ms): <.main+6323>
test/lang/useOperator.ci:82:[.057632, .057645) exec(1), time(0.006-0.006 ms): <.main+6342>
test/lang/useOperator.ci:83:[.057645, .057658) exec(1), time(0.005-0.005 ms): <.main+6361>
test/lang/useOperator.ci:84:[.057658, .05766b) exec(1), time(0.005-0.005 ms): <.main+6380>
test/lang/useOperator.ci:85:[.05766b, .05767e) exec(1), time(0.005-0.005 ms): <.main+6399>
test/lang/useOperator.ci:86:[.05767e, .057691) exec(1), time(0.006-0.006 ms): <.main+6418>
test/lang/useOperator.ci:87:[.057691, .0576a4) exec(1), time(0.006-0.006 ms): <.main+6437>
test/lang/useOperator.ci:88:[.0576a4, .0576b7) exec(1), time(0.005-0.005 ms): <.main+6456>
test/lang/useOperator.ci:89:[.0576b7, .0576c8) exec(1), time(0.004-0.004 ms): <.main+6475>
test/lang/useOperator.ci:90:[.0576c8, .0576d9) exec(1), time(0.005-0.005 ms): <.main+6492>
test/lang/useOperator.ci:91:[.0576d9, .0576e7) exec(1), time(0.006-0.006 ms): <.main+6509>
test/lang/useOperator.ci:92:[.0576e7, .0576fa) exec(1), time(0.006-0.006 ms): <.main+6523>
test/lang/useOperator.ci:93:[.0576fa, .05770e) exec(1), time(0.006-0.006 ms): <.main+6542>
test/lang/useOperator.ci:94:[.05770e, .057721) exec(1), time(0.005-0.005 ms): <.main+6562>
test/lang/useOperator.ci:95:[.057721, .057735) exec(1), time(0.006-0.006 ms): <.main+6581>
test/lang/useOperator.ci:96:[.057735, .057748) exec(1), time(0.006-0.006 ms): <.main+6601>
test/lang/useOperator.ci:97:[.057748, .05775c) exec(1), time(0.006-0.006 ms): <.main+6620>
test/lang/useOperator.ci:99:[.05775c, .057767) exec(1), time(0.003-0.003 ms): <.main+6640>
test/lang/useOperator.ci:100:[.057767, .057772) exec(1), time(0.002-0.002 ms): <.main+6651>
test/lang/useOperator.ci:101:[.057772, .05777e) exec(1), time(0.003-0.003 ms): <.main+6662>
test/lang/useOperator.ci:102:[.05777e, .05778b) exec(1), time(0.004-0.004 ms): <.main+6674>
test/lang/useOperator.ci:103:[.05778b, .057798) exec(1), time(0.004-0.004 ms): <.main+6687>
test/lang/useOperator.ci:104:[.057798, .0577ab) exec(1), time(0.006-0.006 ms): <.main+6700>
test/lang/useOperator.ci:105:[.0577ab, .0577be) exec(1), time(0.006-0.006 ms): <.main+6719>
test/lang/useOperator.ci:106:[.0577be, .0577d1) exec(1), time(0.006-0.006 ms): <.main+6738>
test/lang/useOperator.ci:107:[.0577d1, .0577e4) exec(1), time(0.006-0.006 ms): <.main+6757>
test/lang/useOperator.ci:108:[.0577e4, .0577f7) exec(1), time(0.006-0.006 ms): <.main+6776>
test/lang/useOperator.ci:109:[.0577f7, .05780a) exec(1), time(0.006-0.006 ms): <.main+6795>
test/lang/useOperator.ci:110:[.05780a, .05781d) exec(1), time(0.027-0.027 ms): <.main+6814>
test/lang/useOperator.ci:111:[.05781d, .057830) exec(1), time(0.005-0.005 ms): <.main+6833>
test/lang/useOperator.ci:112:[.057830, .057841) exec(1), time(0.005-0.005 ms): <.main+6852>
test/lang/useOperator.ci:113:[.057841, .057852) exec(1), time(0.005-0.005 ms): <.main+6869>
test/lang/useOperator.ci:114:[.057852, .057860) exec(1), time(0.005-0.005 ms): <.main+6886>
test/lang/useOperator.ci:115:[.057860, .057873) exec(1), time(0.020-0.020 ms): <.main+6900>
test/lang/useOperator.ci:116:[.057873, .057887) exec(1), time(0.007-0.007 ms): <.main+6919>
test/lang/useOperator.ci:117:[.057887, .05789a) exec(1), time(0.006-0.006 ms): <.main+6939>
test/lang/useOperator.ci:118:[.05789a, .0578ae) exec(1), time(0.006-0.006 ms): <.main+6958>
test/lang/useOperator.ci:119:[.0578ae, .0578c1) exec(1), time(0.006-0.006 ms): <.main+6978>
test/lang/useOperator.ci:120:[.0578c1, .0578d5) exec(1), time(0.007-0.007 ms): <.main+6997>
test/lang/useOperator.ci:122:[.0578d5, .0578e0) exec(1), time(0.002-0.002 ms): <.main+7017>
test/lang/useOperator.ci:123:[.0578e0, .0578eb) exec(1), time(0.003-0.003 ms): <.main+7028>
test/lang/useOperator.ci:124:[.0578eb, .0578f7) exec(1), time(0.003-0.003 ms): <.main+7039>
test/lang/useOperator.ci:125:[.0578f7, .057904) exec(1), time(0.004-0.004 ms): <.main+7051>
test/lang/useOperator.ci:126:[.057904, .057911) exec(1), time(0.004-0.004 ms): <.main+7064>
test/lang/useOperator.ci:127:[.057911, .057924) exec(1), time(0.005-0.005 ms): <.main+7077>
test/lang/useOperator.ci:128:[.057924, .057937) exec(1), time(0.019-0.019 ms): <.main+7096>
test/lang/useOperator.ci:129:[.057937, .05794a) exec(1), time(0.005-0.005 ms): <.main+7115>
test/lang/useOperator.ci:130:[.05794a, .05795d) exec(1), time(0.005-0.005 ms): <.main+7134>
test/lang/useOperator.ci:131:[.05795d, .057970) exec(1), time(0.005-0.005 ms): <.main+7153>
test/lang/useOperator.ci:132:[.057970, .057983) exec(1), time(0.005-0.005 ms): <.main+7172>
test/lang/useOperator.ci:133:[.057983, .057996) exec(1), time(0.005-0.005 ms): <.main+7191>
test/lang/useOperator.ci:134:[.057996, .0579a9) exec(1), time(0.006-0.006 ms): <.main+7210>
test/lang/useOperator.ci:135:[.0579a9, .0579ba) exec(1), time(0.005-0.005 ms): <.main+7229>
test/lang/useOperator.ci:136:[.0579ba, .0579cb) exec(1), time(0.005-0.005 ms): <.main+7246>
test/lang/useOperator.ci:137:[.0579cb, .0579d9) exec(1), time(0.004-0.004 ms): <.main+7263>
test/lang/useOperator.ci:138:[.0579d9, .0579ec) exec(1), time(0.005-0.005 ms): <.main+7277>
test/lang/useOperator.ci:139:[.0579ec, .057a00) exec(1), time(0.006-0.006 ms): <.main+7296>
test/lang/useOperator.ci:140:[.057a00, .057a13) exec(1), time(0.006-0.006 ms): <.main+7316>
test/lang/useOperator.ci:141:[.057a13, .057a27) exec(1), time(0.007-0.007 ms): <.main+7335>
test/lang/useOperator.ci:142:[.057a27, .057a3a) exec(1), time(0.006-0.006 ms): <.main+7355>
test/lang/useOperator.ci:143:[.057a3a, .057a4e) exec(1), time(0.007-0.007 ms): <.main+7374>
test/lang/useOperator.ci:145:[.057a4e, .057a57) exec(1), time(0.002-0.002 ms): <.main+7394>
test/lang/useOperator.ci:146:[.057a57, .057a60) exec(1), time(0.015-0.015 ms): <.main+7403>
test/lang/useOperator.ci:147:[.057a60, .057a68) exec(1), time(0.001-0.001 ms): <.main+7412>
test/lang/useOperator.ci:148:[.057a68, .057a71) exec(1), time(0.002-0.002 ms): <.main+7420>
test/lang/useOperator.ci:149:[.057a71, .057a7a) exec(1), time(0.003-0.003 ms): <.main+7429>
test/lang/useOperator.ci:150:[.057a7a, .057a87) exec(1), time(0.004-0.004 ms): <.main+7438>
test/lang/useOperator.ci:151:[.057a87, .057a94) exec(1), time(0.003-0.003 ms): <.main+7451>
test/lang/useOperator.ci:152:[.057a94, .057aa1) exec(1), time(0.003-0.003 ms): <.main+7464>
test/lang/useOperator.ci:153:[.057aa1, .057aae) exec(1), time(0.003-0.003 ms): <.main+7477>
test/lang/useOperator.ci:154:[.057aae, .057abb) exec(1), time(0.003-0.003 ms): <.main+7490>
test/lang/useOperator.ci:155:[.057abb, .057ac8) exec(1), time(0.003-0.003 ms): <.main+7503>
test/lang/useOperator.ci:156:[.057ac8, .057ad5) exec(1), time(0.003-0.003 ms): <.main+7516>
test/lang/useOperator.ci:157:[.057ad5, .057ae2) exec(1), time(0.003-0.003 ms): <.main+7529>
test/lang/useOperator.ci:158:[.057ae2, .057aef) exec(1), time(0.003-0.003 ms): <.main+7542>
test/lang/useOperator.ci:159:[.057aef, .057afc) exec(1), time(0.003-0.003 ms): <.main+7555>
test/lang/useOperator.ci:160:[.057afc, .057b08) exec(1), time(0.004-0.004 ms): <.main+7568>
test/lang/useOperator.ci:161:[.057b08, .057b17) exec(1), time(0.004-0.004 ms): <.main+7580>
test/lang/useOperator.ci:162:[.057b17, .057b27) exec(1), time(0.004-0.004 ms): <.main+7595>
test/lang/useOperator.ci:163:[.057b27, .057b36) exec(1), time(0.004-0.004 ms): <.main+7611>
test/lang/useOperator.ci:164:[.057b36, .057b46) exec(1), time(0.005-0.005 ms): <.main+7626>
test/lang/useOperator.ci:165:[.057b46, .057b55) exec(1), time(0.005-0.005 ms): <.main+7642>
test/lang/useOperator.ci:166:[.057b55, .057b65) exec(1), time(0.005-0.005 ms): <.main+7657>
test/lang/useOperator.ci:168:[.057b65, .057b6e) exec(1), time(0.002-0.002 ms): <.main+7673>
test/lang/useOperator.ci:169:[.057b6e, .057b77) exec(1), time(0.002-0.002 ms): <.main+7682>
test/lang/useOperator.ci:170:[.057b77, .057b7f) exec(1), time(0.001-0.001 ms): <.main+7691>
test/lang/useOperator.ci:171:[.057b7f, .057b88) exec(1), time(0.002-0.002 ms): <.main+7699>
test/lang/useOperator.ci:172:[.057b88, .057b91) exec(1), time(0.002-0.002 ms): <.main+7708>
test/lang/useOperator.ci:173:[.057b91, .057b9e) exec(1), time(0.004-0.004 ms): <.main+7717>
test/lang/useOperator.ci:174:[.057b9e, .057bab) exec(1), time(0.003-0.003 ms): <.main+7730>
test/lang/useOperator.ci:175:[.057bab, .057bb8) exec(1), time(0.003-0.003 ms): <.main+7743>
test/lang/useOperator.ci:176:[.057bb8, .057bc5) exec(1), time(0.003-0.003 ms): <.main+7756>
test/lang/useOperator.ci:177:[.057bc5, .057bd2) exec(1), time(0.003-0.003 ms): <.main+7769>
test/lang/useOperator.ci:178:[.057bd2, .057bdf) exec(1), time(0.003-0.003 ms): <.main+7782>
test/lang/useOperator.ci:179:[.057bdf, .057bec) exec(1), time(0.003-0.003 ms): <.main+7795>
test/lang/useOperator.ci:180:[.057bec, .057bf9) exec(1), time(0.003-0.003 ms): <.main+7808>
test/lang/useOperator.ci:181:[.057bf9, .057c06) exec(1), time(0.003-0.003 ms): <.main+7821>
test/lang/useOperator.ci:182:[.057c06, .057c13) exec(1), time(0.003-0.003 ms): <.main+7834>
test/lang/useOperator.ci:183:[.057c13, .057c1f) exec(1), time(0.004-0.004 ms): <.main+7847>
test/lang/useOperator.ci:184:[.057c1f, .057c2e) exec(1), time(0.004-0.004 ms): <.main+7859>
test/lang/useOperator.ci:185:[.057c2e, .057c3e) exec(1), time(0.005-0.005 ms): <.main+7874>
test/lang/useOperator.ci:186:[.057c3e, .057c4d) exec(1), time(0.004-0.004 ms): <.main+7890>
test/lang/useOperator.ci:187:[.057c4d, .057c5d) exec(1), time(0.005-0.005 ms): <.main+7905>
test/lang/useOperator.ci:188:[.057c5d, .057c6c) exec(1), time(0.004-0.004 ms): <.main+7921>
test/lang/useOperator.ci:189:[.057c6c, .057c7c) exec(1), time(0.005-0.005 ms): <.main+7936>
test/lang/useOperator.ci:191:[.057c7c, .057c89) exec(1), time(0.001-0.001 ms): <.main+7952>
test/lang/useOperator.ci:192:[.057c89, .057c96) exec(1), time(0.001-0.001 ms): <.main+7965>
test/lang/useOperator.ci:193:[.057c96, .057c9e) exec(1), time(0.002-0.002 ms): <.main+7978>
test/lang/useOperator.ci:194:[.057c9e, .057ca7) exec(1), time(0.003-0.003 ms): <.main+7986>
test/lang/useOperator.ci:195:[.057ca7, .057cb0) exec(1), time(0.002-0.002 ms): <.main+7995>
test/lang/useOperator.ci:196:[.057cb0, .057cbd) exec(1), time(0.003-0.003 ms): <.main+8004>
test/lang/useOperator.ci:197:[.057cbd, .057cca) exec(1), time(0.004-0.004 ms): <.main+8017>
test/lang/useOperator.ci:198:[.057cca, .057cd7) exec(1), time(0.003-0.003 ms): <.main+8030>
test/lang/useOperator.ci:199:[.057cd7, .057ce4) exec(1), time(0.003-0.003 ms): <.main+8043>
test/lang/useOperator.ci:200:[.057ce4, .057cf1) exec(1), time(0.003-0.003 ms): <.main+8056>
test/lang/useOperator.ci:201:[.057cf1, .057cfe) exec(1), time(0.003-0.003 ms): <.main+8069>
test/lang/useOperator.ci:202:[.057cfe, .057d0b) exec(1), time(0.004-0.004 ms): <.main+8082>
test/lang/useOperator.ci:203:[.057d0b, .057d18) exec(1), time(0.003-0.003 ms): <.main+8095>
test/lang/useOperator.ci:204:[.057d18, .057d25) exec(1), time(0.003-0.003 ms): <.main+8108>
test/lang/useOperator.ci:205:[.057d25, .057d32) exec(1), time(0.004-0.004 ms): <.main+8121>
test/lang/useOperator.ci:206:[.057d32, .057d3e) exec(1), time(0.004-0.004 ms): <.main+8134>
test/lang/useOperator.ci:207:[.057d3e, .057d4d) exec(1), time(0.004-0.004 ms): <.main+8146>
test/lang/useOperator.ci:208:[.057d4d, .057d5d) exec(1), time(0.005-0.005 ms): <.main+8161>
test/lang/useOperator.ci:209:[.057d5d, .057d6c) exec(1), time(0.004-0.004 ms): <.main+8177>
test/lang/useOperator.ci:210:[.057d6c, .057d7c) exec(1), time(0.005-0.005 ms): <.main+8192>
test/lang/useOperator.ci:211:[.057d7c, .057d8b) exec(1), time(0.019-0.019 ms): <.main+8208>
test/lang/useOperator.ci:212:[.057d8b, .057d9b) exec(1), time(0.005-0.005 ms): <.main+8223>
test/lang/useOperator.ci:214:[.057d9b, .057da8) exec(1), time(0.001-0.001 ms): <.main+8239>
test/lang/useOperator.ci:215:[.057da8, .057db5) exec(1), time(0.001-0.001 ms): <.main+8252>
test/lang/useOperator.ci:216:[.057db5, .057dbd) exec(1), time(0.001-0.001 ms): <.main+8265>
test/lang/useOperator.ci:217:[.057dbd, .057dc6) exec(1), time(0.002-0.002 ms): <.main+8273>
test/lang/useOperator.ci:218:[.057dc6, .057dcf) exec(1), time(0.002-0.002 ms): <.main+8282>
test/lang/useOperator.ci:219:[.057dcf, .057ddc) exec(1), time(0.003-0.003 ms): <.main+8291>
test/lang/useOperator.ci:220:[.057ddc, .057de9) exec(1), time(0.003-0.003 ms): <.main+8304>
test/lang/useOperator.ci:221:[.057de9, .057df6) exec(1), time(0.004-0.004 ms): <.main+8317>
test/lang/useOperator.ci:222:[.057df6, .057e03) exec(1), time(0.003-0.003 ms): <.main+8330>
test/lang/useOperator.ci:223:[.057e03, .057e10) exec(1), time(0.003-0.003 ms): <.main+8343>
test/lang/useOperator.ci:224:[.057e10, .057e1d) exec(1), time(0.003-0.003 ms): <.main+8356>
test/lang/useOperator.ci:225:[.057e1d, .057e2a) exec(1), time(0.003-0.003 ms): <.main+8369>
test/lang/useOperator.ci:226:[.057e2a, .057e37) exec(1), time(0.004-0.004 ms): <.main+8382>
test/lang/useOperator.ci:227:[.057e37, .057e44) exec(1), time(0.004-0.004 ms): <.main+8395>
test/lang/useOperator.ci:228:[.057e44, .057e51) exec(1), time(0.004-0.004 ms): <.main+8408>
test/lang/useOperator.ci:229:[.057e51, .057e5d) exec(1), time(0.004-0.004 ms): <.main+8421>
test/lang/useOperator.ci:230:[.057e5d, .057e6c) exec(1), time(0.004-0.004 ms): <.main+8433>
test/lang/useOperator.ci:231:[.057e6c, .057e7c) exec(1), time(0.005-0.005 ms): <.main+8448>
test/lang/useOperator.ci:232:[.057e7c, .057e8b) exec(1), time(0.005-0.005 ms): <.main+8464>
test/lang/useOperator.ci:233:[.057e8b, .057e9b) exec(1), time(0.005-0.005 ms): <.main+8479>
test/lang/useOperator.ci:234:[.057e9b, .057eaa) exec(1), time(0.004-0.004 ms): <.main+8495>
test/lang/useOperator.ci:235:[.057eaa, .057eba) exec(1), time(0.019-0.019 ms): <.main+8510>
test/lang/useOperator.ci:237:[.057eba, .057ec3) exec(1), time(0.002-0.002 ms): <.main+8526>
test/lang/useOperator.ci:238:[.057ec3, .057ecc) exec(1), time(0.002-0.002 ms): <.main+8535>
test/lang/useOperator.ci:239:[.057ecc, .057ed4) exec(1), time(0.002-0.002 ms): <.main+8544>
test/lang/useOperator.ci:240:[.057ed4, .057edd) exec(1), time(0.002-0.002 ms): <.main+8552>
test/lang/useOperator.ci:242:[.057edd, .057eea) exec(1), time(0.003-0.003 ms): <.main+8561>
test/lang/useOperator.ci:243:[.057eea, .057ef7) exec(1), time(0.003-0.003 ms): <.main+8574>
test/lang/useOperator.ci:244:[.057ef7, .057f04) exec(1), time(0.003-0.003 ms): <.main+8587>
test/lang/useOperator.ci:245:[.057f04, .057f11) exec(1), time(0.004-0.004 ms): <.main+8600>
test/lang/useOperator.ci:246:[.057f11, .057f1e) exec(1), time(0.004-0.004 ms): <.main+8613>
test/lang/useOperator.ci:252:[.057f1e, .057f2a) exec(1), time(0.004-0.004 ms): <.main+8626>
test/lang/useOperator.ci:253:[.057f2a, .057f39) exec(1), time(0.004-0.004 ms): <.main+8638>
test/lang/useOperator.ci:254:[.057f39, .057f49) exec(1), time(0.005-0.005 ms): <.main+8653>
test/lang/useOperator.ci:255:[.057f49, .057f58) exec(1), time(0.004-0.004 ms): <.main+8669>
test/lang/useOperator.ci:256:[.057f58, .057f68) exec(1), time(0.005-0.005 ms): <.main+8684>
test/lang/useOperator.ci:257:[.057f68, .057f77) exec(1), time(0.004-0.004 ms): <.main+8700>
test/lang/useOperator.ci:258:[.057f77, .057f87) exec(1), time(0.005-0.005 ms): <.main+8715>
test/lang/useOperator.ci:260:[.057f87, .057f94) exec(1), time(0.001-0.001 ms): <.main+8731>
test/lang/useOperator.ci:261:[.057f94, .057fa1) exec(1), time(0.001-0.001 ms): <.main+8744>
test/lang/useOperator.ci:262:[.057fa1, .057fa9) exec(1), time(0.001-0.001 ms): <.main+8757>
test/lang/useOperator.ci:263:[.057fa9, .057fb2) exec(1), time(0.002-0.002 ms): <.main+8765>
test/lang/useOperator.ci:265:[.057fb2, .057fbf) exec(1), time(0.003-0.003 ms): <.main+8774>
test/lang/useOperator.ci:266:[.057fbf, .057fcc) exec(1), time(0.004-0.004 ms): <.main+8787>
test/lang/useOperator.ci:267:[.057fcc, .057fd9) exec(1), time(0.003-0.003 ms): <.main+8800>
test/lang/useOperator.ci:268:[.057fd9, .057fe6) exec(1), time(0.003-0.003 ms): <.main+8813>
test/lang/useOperator.ci:269:[.057fe6, .057ff3) exec(1), time(0.003-0.003 ms): <.main+8826>
test/lang/useOperator.ci:275:[.057ff3, .057fff) exec(1), time(0.004-0.004 ms): <.main+8839>
test/lang/useOperator.ci:276:[.057fff, .05800e) exec(1), time(0.004-0.004 ms): <.main+8851>
test/lang/useOperator.ci:277:[.05800e, .05801e) exec(1), time(0.005-0.005 ms): <.main+8866>
test/lang/useOperator.ci:278:[.05801e, .05802d) exec(1), time(0.004-0.004 ms): <.main+8882>
test/lang/useOperator.ci:279:[.05802d, .05803d) exec(1), time(0.005-0.005 ms): <.main+8897>
test/lang/useOperator.ci:280:[.05803d, .05804c) exec(1), time(0.005-0.005 ms): <.main+8913>
test/lang/useOperator.ci:281:[.05804c, .05805c) exec(1), time(0.005-0.005 ms): <.main+8928>
test/lang/useOperator.ci:283:[.05805c, .058065) exec(1), time(0.001-0.001 ms): <.main+8944>
test/lang/useOperator.ci:284:[.058065, .05806e) exec(1), time(0.001-0.001 ms): <.main+8953>
test/lang/useOperator.ci:299:[.05806e, .05807d) exec(1), time(0.004-0.004 ms): <.main+8962>
test/lang/useOperator.ci:300:[.05807d, .05808d) exec(1), time(0.005-0.005 ms): <.main+8977>
test/lang/statementIf.ci:26:[.05808d, .058092) exec(1), time(0.002-0.002 ms): <.main+8993>
test/lang/statementFor.ci:12:[.058092, .058097) exec(1), time(0.002-0.002 ms): <.main+8998>
test/stdc/test.math.ci:3:[.058097, .0580af) exec(1), time(0.044-0.044 ms): <.main+9003>
test/stdc/test.math.ci:4:[.0580af, .0580c7) exec(1), time(0.039-0.039 ms): <.main+9027>
test/stdc/test.math.ci:5:[.0580c7, .0580df) exec(1), time(0.053-0.053 ms): <.main+9051>
test/stdc/test.math.ci:6:[.0580df, .0580f7) exec(1), time(0.069-0.069 ms): <.main+9075>
test/stdc/test.math.ci:7:[.0580f7, .05810f) exec(1), time(0.059-0.059 ms): <.main+9099>
test/stdc/test.math.ci:8:[.05810f, .058127) exec(1), time(0.056-0.056 ms): <.main+9123>
test/stdc/test.math.ci:10:[.058127, .058144) exec(1), time(0.012-0.012 ms): <.main+9147>
test/stdc/test.math.ci:11:[.058144, .058159) exec(1), time(0.026-0.026 ms): <.main+9176>
test/stdc/test.math.ci:12:[.058159, .058176) exec(1), time(0.026-0.026 ms): <.main+9197>
test/stdc/test.math.ci:13:[.058176, .05818b) exec(1), time(0.010-0.010 ms): <.main+9226>
test/stdc/test.math.ci:14:[.05818b, .05819c) exec(1), time(0.011-0.011 ms): <.main+9247>
test/stdc/test.math.ci:15:[.05819c, .0581b1) exec(1), time(0.011-0.011 ms): <.main+9264>
test/stdc/test.math.ci:17:[.0581b1, .0581c9) exec(1), time(0.044-0.044 ms): <.main+9285>
test/stdc/test.math.ci:18:[.0581c9, .0581d8) exec(1), time(0.022-0.022 ms): <.main+9309>
test/stdc/test.math.ci:19:[.0581d8, .0581f0) exec(1), time(0.036-0.036 ms): <.main+9324>
test/stdc/test.math.ci:20:[.0581f0, .058205) exec(1), time(0.024-0.024 ms): <.main+9348>
test/stdc/test.math.ci:21:[.058205, .058216) exec(1), time(0.023-0.023 ms): <.main+9369>
test/stdc/test.math.ci:22:[.058216, .05822b) exec(1), time(0.036-0.036 ms): <.main+9386>
test/stdc/test.math.ci:24:[.05822b, .058245) exec(1), time(0.024-0.024 ms): <.main+9407>
test/stdc/test.math.ci:25:[.058245, .05825f) exec(1), time(0.026-0.026 ms): <.main+9433>
test/stdc/test.math.ci:26:[.05825f, .058280) exec(1), time(0.023-0.023 ms): <.main+9459>
test/stdc/test.math.ci:27:[.058280, .0582a1) exec(1), time(0.037-0.037 ms): <.main+9492>
test/stdc/test.math.ci:29:[.0582a1, .0582bc) exec(1), time(0.040-0.040 ms): <.main+9525>
test/stdc/test.math.ci:30:[.0582bc, .0582de) exec(1), time(0.025-0.025 ms): <.main+9552>
test/stdc/test.math.ci:32:[.0582de, .0582f7) exec(1), time(0.011-0.011 ms): <.main+9586>
test/stdc/test.math.ci:33:[.0582f7, .058317) exec(1), time(0.010-0.010 ms): <.main+9611>
test/stdc/test.math.ci:35:[.058317, .058357) exec(1), time(0.045-0.045 ms): <.main+9643>
test/stdc/test.math.ci:36:[.058357, .0583a9) exec(1), time(0.043-0.043 ms): <.main+9707>
test/stdc/test.math.ci:38:[.0583a9, .0583c2) exec(1), time(0.026-0.026 ms): <.main+9789>
test/stdc/test.math.ci:39:[.0583c2, .058430) exec(1), time(0.073-0.073 ms): <.main+9814>
test/stdc/test.math.ci:40:[.058430, .058449) exec(1), time(0.041-0.041 ms): <.main+9924>
test/stdc/test.math.ci:41:[.058449, .0584b7) exec(1), time(0.088-0.088 ms): <.main+9949>
test/stdc/test.math.ci:43:[.0584b7, .0584d0) exec(1), time(0.030-0.030 ms): <.main+10059>
test/stdc/test.math.ci:44:[.0584d0, .0584f6) exec(1), time(0.035-0.035 ms): <.main+10084>
test/stdc/test.math.ci:45:[.0584f6, .058525) exec(1), time(0.040-0.040 ms): <.main+10122>
test/stdc/test.math.ci:46:[.058525, .05859c) exec(1), time(0.081-0.081 ms): <.main+10169>
test/stdc/test.math.ci:48:[.05859c, .0585a9) exec(1), time(0.002-0.002 ms): <.main+10288>
test/stdc/test.math.ci:49:[.0585a9, .0585c6) exec(1), time(0.030-0.030 ms): <.main+10301>
test/stdc/test.math.ci:50:[.0585c6, .0585d3) exec(1), time(0.002-0.002 ms): <.main+10330>
test/stdc/test.math.ci:51:[.0585d3, .0585ef) exec(1), time(0.006-0.006 ms): <.main+10343>
test/stdc/test.math.ci:52:[.0585ef, .05861c) exec(1), time(0.012-0.012 ms): <.main+10371>
test/stdc/test.math.ci:53:[.05861c, .05865a) exec(1), time(0.016-0.016 ms): <.main+10416>
test/stdc/test.math.ci:54:[.05865a, .0586a8) exec(1), time(0.086-0.086 ms): <.main+10478>
test/stdc/test.math.ci:55:[.0586a8, .0586ff) exec(1), time(0.063-0.063 ms): <.main+10556>
test/stdc/test.math.ci:57:[.0586ff, .058722) exec(1), time(0.049-0.049 ms): <.main+10643>
test/stdc/test.math.ci:58:[.058722, .058753) exec(1), time(0.119-0.119 ms): <.main+10678>
test/stdc/test.math.ci:59:[.058753, .058775) exec(1), time(0.117-0.117 ms): <.main+10727>
test/stdc/test.math.ci:60:[.058775, .058797) exec(1), time(0.110-0.110 ms): <.main+10761>
test/stdc/test.math.ci:61:[.058797, .0587b9) exec(1), time(0.081-0.081 ms): <.main+10795>
test/stdc/test.math.ci:63:[.0587b9, .0587d1) exec(1), time(0.074-0.074 ms): <.main+10829>
test/stdc/test.math.ci:64:[.0587d1, .0587fd) exec(1), time(0.106-0.106 ms): <.main+10853>
test/stdc/test.math.ci:67:[.0587fd, .05881f) exec(1), time(0.030-0.030 ms): <.main+10897>
test/stdc/test.math.ci:68:[.05881f, .05884d) exec(1), time(0.030-0.030 ms): <.main+10931>
test/stdc/test.math.ci:70:[.05884d, .05886e) exec(1), time(0.023-0.023 ms): <.main+10977>
test/stdc/test.math.ci:71:[.05886e, .058886) exec(1), time(0.022-0.022 ms): <.main+11010>
test/stdc/test.math.ci:72:[.058886, .0588a7) exec(1), time(0.023-0.023 ms): <.main+11034>
test/stdc/test.math.ci:74:[.0588a7, .0588c8) exec(1), time(0.024-0.024 ms): <.main+11067>
test/stdc/test.math.ci:75:[.0588c8, .0588e9) exec(1), time(0.029-0.029 ms): <.main+11100>
test/stdc/test.math.ci:76:[.0588e9, .05890a) exec(1), time(0.023-0.023 ms): <.main+11133>
test/stdc/test.math.ci:77:[.05890a, .05892b) exec(1), time(0.023-0.023 ms): <.main+11166>
test/stdc/test.math.ci:79:[.05892b, .05894c) exec(1), time(0.043-0.043 ms): <.main+11199>
test/stdc/test.math.ci:80:[.05894c, .05896d) exec(1), time(0.037-0.037 ms): <.main+11232>
test/stdc/test.math.ci:81:[.05896d, .05898e) exec(1), time(0.023-0.023 ms): <.main+11265>
test/stdc/test.math.ci:82:[.05898e, .0589af) exec(1), time(0.023-0.023 ms): <.main+11298>
test/stdc/test.math.ci:84:[.0589af, .0589c8) exec(1), time(0.047-0.047 ms): <.main+11331>
test/stdc/test.math.ci:85:[.0589c8, .0589dd) exec(1), time(0.040-0.040 ms): <.main+11356>
test/stdc/test.math.ci:86:[.0589dd, .0589f6) exec(1), time(0.024-0.024 ms): <.main+11377>
test/stdc/test.math.ci:88:[.0589f6, .058a0f) exec(1), time(0.025-0.025 ms): <.main+11402>
test/stdc/test.math.ci:89:[.058a0f, .058a28) exec(1), time(0.024-0.024 ms): <.main+11427>
test/stdc/test.math.ci:90:[.058a28, .058a41) exec(1), time(0.037-0.037 ms): <.main+11452>
test/stdc/test.math.ci:91:[.058a41, .058a5a) exec(1), time(0.023-0.023 ms): <.main+11477>
test/stdc/test.math.ci:93:[.058a5a, .058a73) exec(1), time(0.024-0.024 ms): <.main+11502>
test/stdc/test.math.ci:94:[.058a73, .058a8c) exec(1), time(0.024-0.024 ms): <.main+11527>
test/stdc/test.math.ci:95:[.058a8c, .058aa5) exec(1), time(0.023-0.023 ms): <.main+11552>
test/stdc/test.math.ci:96:[.058aa5, .058abe) exec(1), time(0.023-0.023 ms): <.main+11577>
test/stdc/memory.ci:13:[.058abe, .058ad0) exec(1), time(0.051-0.051 ms): <.main+11602>
test/stdc/memory.ci:14:[.058ad0, .058ae5) exec(1), time(0.043-0.043 ms): <.main+11620>
test/stdc/memory.ci:17:[.058ae5, .058af2) exec(1), time(0.028-0.028 ms): <.main+11641>
test/stdc/memory.ci:18:[.058af2, .058aff) exec(1), time(0.027-0.027 ms): <.main+11654>
test/stdc/memory.ci:19:[.058aff, .058b0c) exec(1), time(0.026-0.026 ms): <.main+11667>
test/stdc/memory.ci:20:[.058b0c, .058b19) exec(1), time(0.027-0.027 ms): <.main+11680>
test/stdc/memory.ci:26:[.058b19, .058b3c) exec(1), time(0.041-0.041 ms): <.main+11693>
test/stdc/memory.ci:27:[.058b3c, .058b5f) exec(1), time(0.072-0.072 ms): <.main+11728>
test/stdc/memory.ci:29:[.058b5f, .058b75) exec(1), time(0.029-0.029 ms): <.main+11763>
test/stdc/memory.ci:30:[.058b75, .058b87) exec(1), time(0.051-0.051 ms): <.main+11785>
test/stdc/memory.ci:32:[.058b87, .058baa) exec(1), time(0.054-0.054 ms): <.main+11803>
test/stdc/memory.ci:33:[.058baa, .058bcd) exec(1), time(0.039-0.039 ms): <.main+11838>
test/lang/array.ci:55:[.058bd2, .058be7) exec(7), time(0.073-0.073 ms): <.main+11878>
test/lang/array.ci:54:[.058be7, .058beb) exec(7), time(0.003-0.003 ms): <.main+11899>
test/lang/array.ci:54:[.058beb, .058bf7) exec(8), time(0.032-0.032 ms): <.main+11903>
test/lang/array.ci:54:[.058bcd, .058bfb) exec(1), time(0.006-0.006 ms): <.main+11873>
test/lang/array.ci:82:[.058bfb, .058c12) exec(1), time(0.048-0.048 ms): <.main+11919>
test/lang/array.ci:83:[.058c12, .058c35) exec(1), time(0.106-0.106 ms): <.main+11942>
test/lang/array.ci:84:[.058c35, .058c58) exec(1), time(0.103-0.103 ms): <.main+11977>
test/lang/array.ci:87:[.058c58, .058c7a) exec(1), time(0.044-0.044 ms): <.main+12012>
test/lang/array.ci:88:[.058c7a, .058c9c) exec(1), time(0.044-0.044 ms): <.main+12046>
test/lang/array.ci:91:[.058c9c, .058cbe) exec(1), time(0.062-0.062 ms): <.main+12080>
test/lang/array.ci:92:[.058cbe, .058ce0) exec(1), time(0.059-0.059 ms): <.main+12114>
test/lang/array.ci:98:[.058ce0, .058d15) exec(1), time(0.006-0.006 ms): <.main+12148>
test/lang/array.ci:99:[.058d15, .058d4a) exec(1), time(0.005-0.005 ms): <.main+12201>
test/lang/array.ci:101:[.058d4a, .058d87) exec(1), time(0.005-0.005 ms): <.main+12254>
test/lang/array.ci:108:[.058d87, .058da0) exec(1), time(0.024-0.024 ms): <.main+12315>
test/lang/array.ci:109:[.058da0, .058db8) exec(1), time(0.024-0.024 ms): <.main+12340>
test/lang/array.ci:110:[.058db8, .058dd0) exec(1), time(0.024-0.024 ms): <.main+12364>
test/lang/array.ci:112:[.058dd0, .058df0) exec(1), time(0.051-0.051 ms): <.main+12388>
test/lang/array.ci:113:[.058df0, .058e0f) exec(1), time(0.051-0.051 ms): <.main+12420>
test/lang/array.ci:114:[.058e0f, .058e38) exec(1), time(0.052-0.052 ms): <.main+12451>
test/lang/array.ci:115:[.058e38, .058e5b) exec(1), time(0.069-0.069 ms): <.main+12492>
test/lang/array.ci:116:[.058e5b, .058e7e) exec(1), time(0.066-0.066 ms): <.main+12527>
test/lang/array.ci:119:[.058e83, .058e8c) exec(7), time(0.028-0.028 ms): <.main+12567>
test/lang/array.ci:120:[.058e8c, .058eca) exec(7), time(0.077-0.077 ms): <.main+12576>
test/lang/array.ci:121:[.058eca, .058f07) exec(7), time(0.073-0.073 ms): <.main+12638>
test/lang/array.ci:122:[.058f07, .058f44) exec(7), time(0.061-0.061 ms): <.main+12699>
test/lang/array.ci:124:[.058f44, .058f88) exec(7), time(0.339-0.339 ms): <.main+12760>
test/lang/array.ci:125:[.058f88, .058fcb) exec(7), time(0.316-0.316 ms): <.main+12828>
test/lang/array.ci:126:[.058fcb, .05900e) exec(7), time(0.270-0.270 ms): <.main+12895>
test/lang/array.ci:128:[.05900e, .059052) exec(7), time(0.302-0.302 ms): <.main+12962>
test/lang/array.ci:129:[.059052, .059095) exec(7), time(0.295-0.295 ms): <.main+13030>
test/lang/array.ci:130:[.059095, .0590d8) exec(7), time(0.337-0.337 ms): <.main+13097>
test/lang/array.ci:132:[.0590d8, .059121) exec(7), time(0.342-0.342 ms): <.main+13164>
test/lang/array.ci:134:[.059121, .059164) exec(7), time(0.309-0.309 ms): <.main+13237>
test/lang/array.ci:136:[.059164, .0591a1) exec(7), time(0.064-0.064 ms): <.main+13304>
test/lang/array.ci:118:[.0591a5, .0591a9) exec(7), time(0.005-0.005 ms): <.main+13369>
test/lang/array.ci:118:[.0591a9, .0591b5) exec(8), time(0.047-0.047 ms): <.main+13373>
test/lang/array.ci:118:[.058e7e, .0591b9) exec(1), time(0.006-0.006 ms): <.main+12562>
test/lang/method.ci:78:[.0591b9, .0591ce) exec(1), time(0.151-0.151 ms): <.main+13389>
test/lang/method.ci:79:[.0591ce, .0591e2) exec(1), time(0.161-0.161 ms): <.main+13410>
test/lang/method.ci:97:[.0591e2, .0591f5) exec(1), time(0.296-0.296 ms): <.main+13430>
test/lang/method.ci:98:[.0591f5, .059208) exec(1), time(0.288-0.288 ms): <.main+13449>
test/lang/method.ci:101:[.059208, .05921d) exec(1), time(0.133-0.133 ms): <.main+13468>
test/lang/method.ci:102:[.05921d, .059232) exec(1), time(0.136-0.136 ms): <.main+13489>
test/lang/method.ci:103:[.059232, .059246) exec(1), time(0.164-0.164 ms): <.main+13510>
test/lang/statementIf.ci:4:[.059246, .05926d) exec(1), time(0.038-0.038 ms): <.main+13530>
test/lang/statementIf.ci:12:[.05926d, .059294) exec(1), time(0.052-0.052 ms): <.main+13569>
test/lang/statementIf.ci:22:[.059294, .0592bb) exec(1), time(0.039-0.039 ms): <.main+13608>
test/lang/statementIf.ci:29:[.0592c5, .0592ec) exec(1), time(0.059-0.059 ms): <.main+13657>
test/lang/statementIf.ci:28:[.0592bb, .0592ec) exec(1-1), time(0.000 ms): <.main+13647>
test/lang/statementIf.ci:33:[.0592f6, .05931d) exec(0), time(0.000 ms): <.main+13706>
test/lang/statementIf.ci:32:[.0592ec, .05931d) exec(1), time(0.005-0.005 ms): <.main+13696>
test/lang/statementIf.ci:37:[.059327, .05934e) exec(1), time(0.073-0.073 ms): <.main+13755>
test/lang/statementIf.ci:40:[.059352, .059379) exec(0), time(0.000 ms): <.main+13798>
test/lang/statementIf.ci:36:[.05931d, .059379) exec(1), time(0.075-0.075 ms): <.main+13745>
test/lang/statementIf.ci:44:[.059383, .0593aa) exec(0), time(0.000 ms): <.main+13847>
test/lang/statementIf.ci:47:[.0593ae, .0593d5) exec(1), time(0.059-0.059 ms): <.main+13890>
test/lang/statementIf.ci:43:[.059379, .0593d5) exec(1-1), time(0.000 ms): <.main+13837>
test/lang/statementIf.ci:51:[.0593df, .059406) exec(1), time(0.059-0.059 ms): <.main+13939>
test/lang/statementIf.ci:54:[.059418, .05943f) exec(0), time(0.000 ms): <.main+13996>
test/lang/statementIf.ci:57:[.059451, .059478) exec(0), time(0.000 ms): <.main+14053>
test/lang/statementIf.ci:60:[.05948a, .0594b1) exec(0), time(0.000 ms): <.main+14110>
test/lang/statementIf.ci:63:[.0594c3, .0594ea) exec(0), time(0.000 ms): <.main+14167>
test/lang/statementIf.ci:66:[.0594fc, .059523) exec(0), time(0.000 ms): <.main+14224>
test/lang/statementIf.ci:69:[.059527, .05954e) exec(0), time(0.000 ms): <.main+14267>
test/lang/statementIf.ci:65:[.0594ee, .05954e) exec(0), time(0.000 ms): <.main+14210>
test/lang/statementIf.ci:62:[.0594b5, .05954e) exec(0), time(0.000 ms): <.main+14153>
test/lang/statementIf.ci:59:[.05947c, .05954e) exec(0), time(0.000 ms): <.main+14096>
test/lang/statementIf.ci:56:[.059443, .05954e) exec(0), time(0.000 ms): <.main+14039>
test/lang/statementIf.ci:53:[.05940a, .05954e) exec(0), time(0.000 ms): <.main+13982>
test/lang/statementIf.ci:50:[.0593d5, .05954e) exec(1), time(0.061-0.061 ms): <.main+13929>
test/lang/statementFor.ci:4:[.059552, .059575) exec(1), time(0.035-0.035 ms): <.main+14310>
test/lang/statementFor.ci:5:[.059575, .059579) exec(1), time(0.000 ms): <.main+14345>
::[.059579, .05957d) exec(1), time(0.000 ms): <.main+14349>
test/lang/statementFor.ci:3:[.05954e, .05957d) exec(1-1), time(0.000 ms): <.main+14306>
test/lang/statementFor.ci:9:[.059582, .0595a4) exec(2), time(0.122-0.122 ms): <.main+14358>
test/lang/statementFor.ci:8:[.0595a4, .0595a8) exec(2), time(0.002-0.002 ms): <.main+14392>
test/lang/statementFor.ci:8:[.0595a8, .0595b4) exec(3), time(0.013-0.013 ms): <.main+14396>
test/lang/statementFor.ci:8:[.05957d, .0595b8) exec(1), time(0.006-0.006 ms): <.main+14353>
test/lang/statementFor.ci:14:[.0595c1, .0595e4) exec(2), time(0.083-0.083 ms): <.main+14421>
test/lang/statementFor.ci:13:[.0595e4, .0595f0) exec(2), time(0.006-0.006 ms): <.main+14456>
test/lang/statementFor.ci:13:[.0595f0, .0595fe) exec(3), time(0.013-0.013 ms): <.main+14468>
test/lang/statementFor.ci:13:[.0595b8, .0595fe) exec(1-1), time(0.000 ms): <.main+14412>
test/lang/statementFor.ci:19:[.05960f, .059613) exec(2), time(0.002-0.002 ms): <.main+14499>
test/lang/statementFor.ci:18:[.059603, .059613) exec(7-2), time(0.020-0.020 ms): <.main+14487>
test/lang/statementFor.ci:21:[.059613, .059635) exec(5), time(0.234-0.234 ms): <.main+14503>
test/lang/statementFor.ci:17:[.059635, .059639) exec(7), time(0.004-0.004 ms): <.main+14537>
test/lang/statementFor.ci:17:[.059639, .059645) exec(8), time(0.037-0.037 ms): <.main+14541>
test/lang/statementFor.ci:17:[.0595fe, .059649) exec(1), time(0.007-0.007 ms): <.main+14482>
test/lang/statementFor.ci:26:[.05965a, .05965e) exec(1), time(0.001-0.001 ms): <.main+14574>
test/lang/statementFor.ci:25:[.05964e, .05965e) exec(4-1), time(0.014-0.014 ms): <.main+14562>
test/lang/statementFor.ci:28:[.05965e, .059680) exec(3), time(0.120-0.120 ms): <.main+14578>
test/lang/statementFor.ci:24:[.059680, .059684) exec(3), time(0.002-0.002 ms): <.main+14612>
test/lang/statementFor.ci:24:[.059684, .059690) exec(4), time(0.017-0.017 ms): <.main+14616>
test/lang/statementFor.ci:24:[.059649, .059694) exec(1), time(0.003-0.003 ms): <.main+14557>

---------- Exitcode: 0, time: 36.806 ms
